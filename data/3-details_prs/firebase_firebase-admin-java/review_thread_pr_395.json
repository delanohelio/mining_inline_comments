{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NTg4NTky", "number": 395, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDoyMTozMlrOD4eXrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODowNzozM1rOD5hRFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTQ0NDI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/google/firebase/auth/FirebaseTokenVerifierImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDoyMTozMlrOGPUsvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToxNzo1NFrOGQ77BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMDk1OQ==", "bodyText": "\"... the expected value ('%s').\"", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r418720959", "createdAt": "2020-05-01T20:21:32Z", "author": {"login": "kevinthecheung"}, "path": "src/main/java/com/google/firebase/auth/FirebaseTokenVerifierImpl.java", "diffHunk": "@@ -278,6 +283,18 @@ private boolean containsLegacyUidField(IdToken.Payload payload) {\n     return false;\n   }\n \n+  private void checkTenantId(final FirebaseToken firebaseToken) throws FirebaseAuthException {\n+    String tokenTenantId = Strings.nullToEmpty(firebaseToken.getTenantId());\n+    if (!this.tenantId.equals(tokenTenantId)) {\n+      throw new FirebaseAuthException(\n+          FirebaseUserManager.TENANT_ID_MISMATCH_ERROR,\n+          String.format(\n+            \"The tenant ID ('%s') of the token did not match the expected ('%s') value\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMjE2NQ==", "bodyText": "Done.", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420412165", "createdAt": "2020-05-05T21:17:54Z", "author": {"login": "micahstairs"}, "path": "src/main/java/com/google/firebase/auth/FirebaseTokenVerifierImpl.java", "diffHunk": "@@ -278,6 +283,18 @@ private boolean containsLegacyUidField(IdToken.Payload payload) {\n     return false;\n   }\n \n+  private void checkTenantId(final FirebaseToken firebaseToken) throws FirebaseAuthException {\n+    String tokenTenantId = Strings.nullToEmpty(firebaseToken.getTenantId());\n+    if (!this.tenantId.equals(tokenTenantId)) {\n+      throw new FirebaseAuthException(\n+          FirebaseUserManager.TENANT_ID_MISMATCH_ERROR,\n+          String.format(\n+            \"The tenant ID ('%s') of the token did not match the expected ('%s') value\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMDk1OQ=="}, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTQ0NjA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/google/firebase/auth/FirebaseUserManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDoyMjoxNVrOGPUt5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToxODo1OFrOGQ789Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMTI1Mw==", "bodyText": "Tenant", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r418721253", "createdAt": "2020-05-01T20:22:15Z", "author": {"login": "kevinthecheung"}, "path": "src/main/java/com/google/firebase/auth/FirebaseUserManager.java", "diffHunk": "@@ -94,40 +102,36 @@\n       \"iss\", \"jti\", \"nbf\", \"nonce\", \"sub\", \"firebase\");\n \n   private static final String ID_TOOLKIT_URL =\n-      \"https://identitytoolkit.googleapis.com/v1/projects/%s\";\n+      \"https://identitytoolkit.googleapis.com/%s/projects/%s\";\n   private static final String CLIENT_VERSION_HEADER = \"X-Client-Version\";\n \n-  private final String baseUrl;\n+  private final String userMgtBaseUrl;\n+  private final String tenantMgtBaseUrl;\n   private final JsonFactory jsonFactory;\n   private final HttpRequestFactory requestFactory;\n   private final String clientVersion = \"Java/Admin/\" + SdkUtils.getVersion();\n \n   private HttpResponseInterceptor interceptor;\n \n-  /**\n-   * Creates a new FirebaseUserManager instance.\n-   *\n-   * @param app A non-null {@link FirebaseApp}.\n-   */\n-  FirebaseUserManager(@NonNull FirebaseApp app) {\n-    this(app, null);\n-  }\n-\n-  FirebaseUserManager(@NonNull FirebaseApp app, @Nullable HttpRequestFactory requestFactory) {\n-    checkNotNull(app, \"FirebaseApp must not be null\");\n+  FirebaseUserManager(Builder builder) {\n+    FirebaseApp app = checkNotNull(builder.app, \"FirebaseApp must not be null\");\n     String projectId = ImplFirebaseTrampolines.getProjectId(app);\n     checkArgument(!Strings.isNullOrEmpty(projectId),\n         \"Project ID is required to access the auth service. Use a service account credential or \"\n             + \"set the project ID explicitly via FirebaseOptions. Alternatively you can also \"\n             + \"set the project ID via the GOOGLE_CLOUD_PROJECT environment variable.\");\n-    this.baseUrl = String.format(ID_TOOLKIT_URL, projectId);\n-    this.jsonFactory = app.getOptions().getJsonFactory();\n-\n-    if (requestFactory == null) {\n-      requestFactory = ApiClientUtils.newAuthorizedRequestFactory(app);\n+    String tenantId = builder.tenantId;\n+    if (builder.tenantId == null) {\n+      this.userMgtBaseUrl = String.format(ID_TOOLKIT_URL, \"v1\", projectId);\n+    } else {\n+      checkArgument(!tenantId.isEmpty(), \"tenant ID must not be empty\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMjY2MQ==", "bodyText": "Done.", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420412661", "createdAt": "2020-05-05T21:18:58Z", "author": {"login": "micahstairs"}, "path": "src/main/java/com/google/firebase/auth/FirebaseUserManager.java", "diffHunk": "@@ -94,40 +102,36 @@\n       \"iss\", \"jti\", \"nbf\", \"nonce\", \"sub\", \"firebase\");\n \n   private static final String ID_TOOLKIT_URL =\n-      \"https://identitytoolkit.googleapis.com/v1/projects/%s\";\n+      \"https://identitytoolkit.googleapis.com/%s/projects/%s\";\n   private static final String CLIENT_VERSION_HEADER = \"X-Client-Version\";\n \n-  private final String baseUrl;\n+  private final String userMgtBaseUrl;\n+  private final String tenantMgtBaseUrl;\n   private final JsonFactory jsonFactory;\n   private final HttpRequestFactory requestFactory;\n   private final String clientVersion = \"Java/Admin/\" + SdkUtils.getVersion();\n \n   private HttpResponseInterceptor interceptor;\n \n-  /**\n-   * Creates a new FirebaseUserManager instance.\n-   *\n-   * @param app A non-null {@link FirebaseApp}.\n-   */\n-  FirebaseUserManager(@NonNull FirebaseApp app) {\n-    this(app, null);\n-  }\n-\n-  FirebaseUserManager(@NonNull FirebaseApp app, @Nullable HttpRequestFactory requestFactory) {\n-    checkNotNull(app, \"FirebaseApp must not be null\");\n+  FirebaseUserManager(Builder builder) {\n+    FirebaseApp app = checkNotNull(builder.app, \"FirebaseApp must not be null\");\n     String projectId = ImplFirebaseTrampolines.getProjectId(app);\n     checkArgument(!Strings.isNullOrEmpty(projectId),\n         \"Project ID is required to access the auth service. Use a service account credential or \"\n             + \"set the project ID explicitly via FirebaseOptions. Alternatively you can also \"\n             + \"set the project ID via the GOOGLE_CLOUD_PROJECT environment variable.\");\n-    this.baseUrl = String.format(ID_TOOLKIT_URL, projectId);\n-    this.jsonFactory = app.getOptions().getJsonFactory();\n-\n-    if (requestFactory == null) {\n-      requestFactory = ApiClientUtils.newAuthorizedRequestFactory(app);\n+    String tenantId = builder.tenantId;\n+    if (builder.tenantId == null) {\n+      this.userMgtBaseUrl = String.format(ID_TOOLKIT_URL, \"v1\", projectId);\n+    } else {\n+      checkArgument(!tenantId.isEmpty(), \"tenant ID must not be empty\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMTI1Mw=="}, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTQ0NzA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/google/firebase/auth/FirebaseUserManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDoyMjo0NVrOGPUulQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToxOTozNlrOGQ7-YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMTQyOQ==", "bodyText": "Tenant", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r418721429", "createdAt": "2020-05-01T20:22:45Z", "author": {"login": "kevinthecheung"}, "path": "src/main/java/com/google/firebase/auth/FirebaseUserManager.java", "diffHunk": "@@ -228,6 +233,56 @@ UserImportResult importUsers(UserImportRequest request) throws FirebaseAuthExcep\n     return new UserImportResult(request.getUsersCount(), response);\n   }\n \n+  Tenant getTenant(String tenantId) throws FirebaseAuthException {\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + getTenantUrlSuffix(tenantId));\n+    return sendRequest(\"GET\", url, null, Tenant.class);\n+  }\n+\n+  Tenant createTenant(Tenant.CreateRequest request) throws FirebaseAuthException {\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + \"/tenants\");\n+    return sendRequest(\"POST\", url, request.getProperties(), Tenant.class);\n+  }\n+\n+  Tenant updateTenant(Tenant.UpdateRequest request) throws FirebaseAuthException {\n+    Map<String, Object> properties = request.getProperties();\n+    checkArgument(!properties.isEmpty(), \"tenant update must have at least one property set\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMzAyNA==", "bodyText": "Done.", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420413024", "createdAt": "2020-05-05T21:19:36Z", "author": {"login": "micahstairs"}, "path": "src/main/java/com/google/firebase/auth/FirebaseUserManager.java", "diffHunk": "@@ -228,6 +233,56 @@ UserImportResult importUsers(UserImportRequest request) throws FirebaseAuthExcep\n     return new UserImportResult(request.getUsersCount(), response);\n   }\n \n+  Tenant getTenant(String tenantId) throws FirebaseAuthException {\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + getTenantUrlSuffix(tenantId));\n+    return sendRequest(\"GET\", url, null, Tenant.class);\n+  }\n+\n+  Tenant createTenant(Tenant.CreateRequest request) throws FirebaseAuthException {\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + \"/tenants\");\n+    return sendRequest(\"POST\", url, request.getProperties(), Tenant.class);\n+  }\n+\n+  Tenant updateTenant(Tenant.UpdateRequest request) throws FirebaseAuthException {\n+    Map<String, Object> properties = request.getProperties();\n+    checkArgument(!properties.isEmpty(), \"tenant update must have at least one property set\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMTQyOQ=="}, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTQ0ODMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/google/firebase/auth/FirebaseUserManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDoyMzoxNFrOGPUvUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToyMDowNlrOGQ7_Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMTYxNg==", "bodyText": "Invalid", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r418721616", "createdAt": "2020-05-01T20:23:14Z", "author": {"login": "kevinthecheung"}, "path": "src/main/java/com/google/firebase/auth/FirebaseUserManager.java", "diffHunk": "@@ -228,6 +233,56 @@ UserImportResult importUsers(UserImportRequest request) throws FirebaseAuthExcep\n     return new UserImportResult(request.getUsersCount(), response);\n   }\n \n+  Tenant getTenant(String tenantId) throws FirebaseAuthException {\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + getTenantUrlSuffix(tenantId));\n+    return sendRequest(\"GET\", url, null, Tenant.class);\n+  }\n+\n+  Tenant createTenant(Tenant.CreateRequest request) throws FirebaseAuthException {\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + \"/tenants\");\n+    return sendRequest(\"POST\", url, request.getProperties(), Tenant.class);\n+  }\n+\n+  Tenant updateTenant(Tenant.UpdateRequest request) throws FirebaseAuthException {\n+    Map<String, Object> properties = request.getProperties();\n+    checkArgument(!properties.isEmpty(), \"tenant update must have at least one property set\");\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + getTenantUrlSuffix(request.getTenantId()));\n+    url.put(\"updateMask\", generateMask(properties));\n+    return sendRequest(\"PATCH\", url, properties, Tenant.class);\n+  }\n+\n+  private static String generateMask(Map<String, Object> properties) {\n+    // This implementation does not currently handle the case of nested properties. This is fine\n+    // since we do not currently generate masks for any properties with nested values. When it\n+    // comes time to implement this, we can check if a property has nested properties by checking\n+    // if it is an instance of the Map class.\n+    return Joiner.on(\",\").join(ImmutableSortedSet.copyOf(properties.keySet()));\n+  }\n+\n+  void deleteTenant(String tenantId) throws FirebaseAuthException {\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + getTenantUrlSuffix(tenantId));\n+    sendRequest(\"DELETE\", url, null, GenericJson.class);\n+  }\n+\n+  ListTenantsResponse listTenants(int maxResults, String pageToken)\n+      throws FirebaseAuthException {\n+    ImmutableMap.Builder<String, Object> builder =\n+        ImmutableMap.<String, Object>builder().put(\"pageSize\", maxResults);\n+    if (pageToken != null) {\n+      checkArgument(!pageToken.equals(\n+          ListTenantsPage.END_OF_LIST), \"invalid end of list page token\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMzI3OQ==", "bodyText": "Done.", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420413279", "createdAt": "2020-05-05T21:20:06Z", "author": {"login": "micahstairs"}, "path": "src/main/java/com/google/firebase/auth/FirebaseUserManager.java", "diffHunk": "@@ -228,6 +233,56 @@ UserImportResult importUsers(UserImportRequest request) throws FirebaseAuthExcep\n     return new UserImportResult(request.getUsersCount(), response);\n   }\n \n+  Tenant getTenant(String tenantId) throws FirebaseAuthException {\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + getTenantUrlSuffix(tenantId));\n+    return sendRequest(\"GET\", url, null, Tenant.class);\n+  }\n+\n+  Tenant createTenant(Tenant.CreateRequest request) throws FirebaseAuthException {\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + \"/tenants\");\n+    return sendRequest(\"POST\", url, request.getProperties(), Tenant.class);\n+  }\n+\n+  Tenant updateTenant(Tenant.UpdateRequest request) throws FirebaseAuthException {\n+    Map<String, Object> properties = request.getProperties();\n+    checkArgument(!properties.isEmpty(), \"tenant update must have at least one property set\");\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + getTenantUrlSuffix(request.getTenantId()));\n+    url.put(\"updateMask\", generateMask(properties));\n+    return sendRequest(\"PATCH\", url, properties, Tenant.class);\n+  }\n+\n+  private static String generateMask(Map<String, Object> properties) {\n+    // This implementation does not currently handle the case of nested properties. This is fine\n+    // since we do not currently generate masks for any properties with nested values. When it\n+    // comes time to implement this, we can check if a property has nested properties by checking\n+    // if it is an instance of the Map class.\n+    return Joiner.on(\",\").join(ImmutableSortedSet.copyOf(properties.keySet()));\n+  }\n+\n+  void deleteTenant(String tenantId) throws FirebaseAuthException {\n+    GenericUrl url = new GenericUrl(tenantMgtBaseUrl + getTenantUrlSuffix(tenantId));\n+    sendRequest(\"DELETE\", url, null, GenericJson.class);\n+  }\n+\n+  ListTenantsResponse listTenants(int maxResults, String pageToken)\n+      throws FirebaseAuthException {\n+    ImmutableMap.Builder<String, Object> builder =\n+        ImmutableMap.<String, Object>builder().put(\"pageSize\", maxResults);\n+    if (pageToken != null) {\n+      checkArgument(!pageToken.equals(\n+          ListTenantsPage.END_OF_LIST), \"invalid end of list page token\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMTYxNg=="}, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTQ1NDQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/google/firebase/auth/ListTenantsPage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDoyNTozNlrOGPUy-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToyMDo0NVrOGQ8AwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMjU1Mw==", "bodyText": "\"User manager must not be null.\"", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r418722553", "createdAt": "2020-05-01T20:25:36Z", "author": {"login": "kevinthecheung"}, "path": "src/main/java/com/google/firebase/auth/ListTenantsPage.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.gax.paging.Page;\n+import com.google.common.collect.ImmutableList;\n+import com.google.firebase.auth.internal.DownloadAccountResponse;\n+import com.google.firebase.auth.internal.ListTenantsResponse;\n+import com.google.firebase.internal.NonNull;\n+import com.google.firebase.internal.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Represents a page of {@link Tenant} instances.\n+ *\n+ * <p>Provides methods for iterating over the tenants in the current page, and calling up\n+ * subsequent pages of tenants.\n+ *\n+ * <p>Instances of this class are thread-safe and immutable.\n+ */\n+public class ListTenantsPage implements Page<Tenant> {\n+\n+  static final String END_OF_LIST = \"\";\n+\n+  private final ListTenantsResponse currentBatch;\n+  private final TenantSource source;\n+  private final int maxResults;\n+\n+  private ListTenantsPage(\n+      @NonNull ListTenantsResponse currentBatch, @NonNull TenantSource source, int maxResults) {\n+    this.currentBatch = checkNotNull(currentBatch);\n+    this.source = checkNotNull(source);\n+    this.maxResults = maxResults;\n+  }\n+\n+  /**\n+   * Checks if there is another page of tenants available to retrieve.\n+   *\n+   * @return true if another page is available, or false otherwise.\n+   */\n+  @Override\n+  public boolean hasNextPage() {\n+    return !END_OF_LIST.equals(currentBatch.getPageToken());\n+  }\n+\n+  /**\n+   * Returns the string token that identifies the next page.\n+   *\n+   * <p>Never returns null. Returns empty string if there are no more pages available to be\n+   * retrieved.\n+   *\n+   * @return A non-null string token (possibly empty, representing no more pages)\n+   */\n+  @NonNull\n+  @Override\n+  public String getNextPageToken() {\n+    return currentBatch.getPageToken();\n+  }\n+\n+  /**\n+   * Returns the next page of tenants.\n+   *\n+   * @return A new {@link ListTenantsPage} instance, or null if there are no more pages.\n+   */\n+  @Nullable\n+  @Override\n+  public ListTenantsPage getNextPage() {\n+    if (hasNextPage()) {\n+      PageFactory factory = new PageFactory(source, maxResults, currentBatch.getPageToken());\n+      try {\n+        return factory.create();\n+      } catch (FirebaseAuthException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns an {@link Iterable} that facilitates transparently iterating over all the tenants in\n+   * the current Firebase project, starting from this page.\n+   *\n+   * <p>The {@link Iterator} instances produced by the returned {@link Iterable} never buffers more\n+   * than one page of tenants at a time. It is safe to abandon the iterators (i.e. break the loops)\n+   * at any time.\n+   *\n+   * @return a new {@link Iterable} instance.\n+   */\n+  @NonNull\n+  @Override\n+  public Iterable<Tenant> iterateAll() {\n+    return new TenantIterable(this);\n+  }\n+\n+  /**\n+   * Returns an {@link Iterable} over the users in this page.\n+   *\n+   * @return a {@link Iterable} instance.\n+   */\n+  @NonNull\n+  @Override\n+  public Iterable<Tenant> getValues() {\n+    return currentBatch.getTenants();\n+  }\n+\n+  private static class TenantIterable implements Iterable<Tenant> {\n+\n+    private final ListTenantsPage startingPage;\n+\n+    TenantIterable(@NonNull ListTenantsPage startingPage) {\n+      this.startingPage = checkNotNull(startingPage, \"starting page must not be null\");\n+    }\n+\n+    @Override\n+    @NonNull\n+    public Iterator<Tenant> iterator() {\n+      return new TenantIterator(startingPage);\n+    }\n+\n+    /**\n+     * An {@link Iterator} that cycles through tenants, one at a time.\n+     *\n+     * <p>It buffers the last retrieved batch of tenants in memory. The {@code maxResults} parameter\n+     * is an upper bound on the batch size.\n+     */\n+    private static class TenantIterator implements Iterator<Tenant> {\n+\n+      private ListTenantsPage currentPage;\n+      private List<Tenant> batch;\n+      private int index = 0;\n+\n+      private TenantIterator(ListTenantsPage startingPage) {\n+        setCurrentPage(startingPage);\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        if (index == batch.size()) {\n+          if (currentPage.hasNextPage()) {\n+            setCurrentPage(currentPage.getNextPage());\n+          } else {\n+            return false;\n+          }\n+        }\n+\n+        return index < batch.size();\n+      }\n+\n+      @Override\n+      public Tenant next() {\n+        if (!hasNext()) {\n+          throw new NoSuchElementException();\n+        }\n+        return batch.get(index++);\n+      }\n+\n+      @Override\n+      public void remove() {\n+        throw new UnsupportedOperationException(\"remove operation not supported\");\n+      }\n+\n+      private void setCurrentPage(ListTenantsPage page) {\n+        this.currentPage = checkNotNull(page);\n+        this.batch = ImmutableList.copyOf(page.getValues());\n+        this.index = 0;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Represents a source of tenant data that can be queried to load a batch of tenants.\n+   */\n+  interface TenantSource {\n+    @NonNull\n+    ListTenantsResponse fetch(int maxResults, String pageToken)\n+      throws FirebaseAuthException;\n+  }\n+\n+  static class DefaultTenantSource implements TenantSource {\n+\n+    private final FirebaseUserManager userManager;\n+\n+    DefaultTenantSource(FirebaseUserManager userManager) {\n+      this.userManager = checkNotNull(userManager, \"user manager must not be null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMzYzMg==", "bodyText": "Done.", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420413632", "createdAt": "2020-05-05T21:20:45Z", "author": {"login": "micahstairs"}, "path": "src/main/java/com/google/firebase/auth/ListTenantsPage.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.gax.paging.Page;\n+import com.google.common.collect.ImmutableList;\n+import com.google.firebase.auth.internal.DownloadAccountResponse;\n+import com.google.firebase.auth.internal.ListTenantsResponse;\n+import com.google.firebase.internal.NonNull;\n+import com.google.firebase.internal.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Represents a page of {@link Tenant} instances.\n+ *\n+ * <p>Provides methods for iterating over the tenants in the current page, and calling up\n+ * subsequent pages of tenants.\n+ *\n+ * <p>Instances of this class are thread-safe and immutable.\n+ */\n+public class ListTenantsPage implements Page<Tenant> {\n+\n+  static final String END_OF_LIST = \"\";\n+\n+  private final ListTenantsResponse currentBatch;\n+  private final TenantSource source;\n+  private final int maxResults;\n+\n+  private ListTenantsPage(\n+      @NonNull ListTenantsResponse currentBatch, @NonNull TenantSource source, int maxResults) {\n+    this.currentBatch = checkNotNull(currentBatch);\n+    this.source = checkNotNull(source);\n+    this.maxResults = maxResults;\n+  }\n+\n+  /**\n+   * Checks if there is another page of tenants available to retrieve.\n+   *\n+   * @return true if another page is available, or false otherwise.\n+   */\n+  @Override\n+  public boolean hasNextPage() {\n+    return !END_OF_LIST.equals(currentBatch.getPageToken());\n+  }\n+\n+  /**\n+   * Returns the string token that identifies the next page.\n+   *\n+   * <p>Never returns null. Returns empty string if there are no more pages available to be\n+   * retrieved.\n+   *\n+   * @return A non-null string token (possibly empty, representing no more pages)\n+   */\n+  @NonNull\n+  @Override\n+  public String getNextPageToken() {\n+    return currentBatch.getPageToken();\n+  }\n+\n+  /**\n+   * Returns the next page of tenants.\n+   *\n+   * @return A new {@link ListTenantsPage} instance, or null if there are no more pages.\n+   */\n+  @Nullable\n+  @Override\n+  public ListTenantsPage getNextPage() {\n+    if (hasNextPage()) {\n+      PageFactory factory = new PageFactory(source, maxResults, currentBatch.getPageToken());\n+      try {\n+        return factory.create();\n+      } catch (FirebaseAuthException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns an {@link Iterable} that facilitates transparently iterating over all the tenants in\n+   * the current Firebase project, starting from this page.\n+   *\n+   * <p>The {@link Iterator} instances produced by the returned {@link Iterable} never buffers more\n+   * than one page of tenants at a time. It is safe to abandon the iterators (i.e. break the loops)\n+   * at any time.\n+   *\n+   * @return a new {@link Iterable} instance.\n+   */\n+  @NonNull\n+  @Override\n+  public Iterable<Tenant> iterateAll() {\n+    return new TenantIterable(this);\n+  }\n+\n+  /**\n+   * Returns an {@link Iterable} over the users in this page.\n+   *\n+   * @return a {@link Iterable} instance.\n+   */\n+  @NonNull\n+  @Override\n+  public Iterable<Tenant> getValues() {\n+    return currentBatch.getTenants();\n+  }\n+\n+  private static class TenantIterable implements Iterable<Tenant> {\n+\n+    private final ListTenantsPage startingPage;\n+\n+    TenantIterable(@NonNull ListTenantsPage startingPage) {\n+      this.startingPage = checkNotNull(startingPage, \"starting page must not be null\");\n+    }\n+\n+    @Override\n+    @NonNull\n+    public Iterator<Tenant> iterator() {\n+      return new TenantIterator(startingPage);\n+    }\n+\n+    /**\n+     * An {@link Iterator} that cycles through tenants, one at a time.\n+     *\n+     * <p>It buffers the last retrieved batch of tenants in memory. The {@code maxResults} parameter\n+     * is an upper bound on the batch size.\n+     */\n+    private static class TenantIterator implements Iterator<Tenant> {\n+\n+      private ListTenantsPage currentPage;\n+      private List<Tenant> batch;\n+      private int index = 0;\n+\n+      private TenantIterator(ListTenantsPage startingPage) {\n+        setCurrentPage(startingPage);\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        if (index == batch.size()) {\n+          if (currentPage.hasNextPage()) {\n+            setCurrentPage(currentPage.getNextPage());\n+          } else {\n+            return false;\n+          }\n+        }\n+\n+        return index < batch.size();\n+      }\n+\n+      @Override\n+      public Tenant next() {\n+        if (!hasNext()) {\n+          throw new NoSuchElementException();\n+        }\n+        return batch.get(index++);\n+      }\n+\n+      @Override\n+      public void remove() {\n+        throw new UnsupportedOperationException(\"remove operation not supported\");\n+      }\n+\n+      private void setCurrentPage(ListTenantsPage page) {\n+        this.currentPage = checkNotNull(page);\n+        this.batch = ImmutableList.copyOf(page.getValues());\n+        this.index = 0;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Represents a source of tenant data that can be queried to load a batch of tenants.\n+   */\n+  interface TenantSource {\n+    @NonNull\n+    ListTenantsResponse fetch(int maxResults, String pageToken)\n+      throws FirebaseAuthException;\n+  }\n+\n+  static class DefaultTenantSource implements TenantSource {\n+\n+    private final FirebaseUserManager userManager;\n+\n+    DefaultTenantSource(FirebaseUserManager userManager) {\n+      this.userManager = checkNotNull(userManager, \"user manager must not be null\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMjU1Mw=="}, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNTU4ODI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/google/firebase/auth/ListTenantsPage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMToyMjoxMlrOGPWFTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToyMTozMlrOGQ8COg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MzYyOQ==", "bodyText": "Invalid\nand period at the end", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r418743629", "createdAt": "2020-05-01T21:22:12Z", "author": {"login": "kevinthecheung"}, "path": "src/main/java/com/google/firebase/auth/ListTenantsPage.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.gax.paging.Page;\n+import com.google.common.collect.ImmutableList;\n+import com.google.firebase.auth.internal.DownloadAccountResponse;\n+import com.google.firebase.auth.internal.ListTenantsResponse;\n+import com.google.firebase.internal.NonNull;\n+import com.google.firebase.internal.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Represents a page of {@link Tenant} instances.\n+ *\n+ * <p>Provides methods for iterating over the tenants in the current page, and calling up\n+ * subsequent pages of tenants.\n+ *\n+ * <p>Instances of this class are thread-safe and immutable.\n+ */\n+public class ListTenantsPage implements Page<Tenant> {\n+\n+  static final String END_OF_LIST = \"\";\n+\n+  private final ListTenantsResponse currentBatch;\n+  private final TenantSource source;\n+  private final int maxResults;\n+\n+  private ListTenantsPage(\n+      @NonNull ListTenantsResponse currentBatch, @NonNull TenantSource source, int maxResults) {\n+    this.currentBatch = checkNotNull(currentBatch);\n+    this.source = checkNotNull(source);\n+    this.maxResults = maxResults;\n+  }\n+\n+  /**\n+   * Checks if there is another page of tenants available to retrieve.\n+   *\n+   * @return true if another page is available, or false otherwise.\n+   */\n+  @Override\n+  public boolean hasNextPage() {\n+    return !END_OF_LIST.equals(currentBatch.getPageToken());\n+  }\n+\n+  /**\n+   * Returns the string token that identifies the next page.\n+   *\n+   * <p>Never returns null. Returns empty string if there are no more pages available to be\n+   * retrieved.\n+   *\n+   * @return A non-null string token (possibly empty, representing no more pages)\n+   */\n+  @NonNull\n+  @Override\n+  public String getNextPageToken() {\n+    return currentBatch.getPageToken();\n+  }\n+\n+  /**\n+   * Returns the next page of tenants.\n+   *\n+   * @return A new {@link ListTenantsPage} instance, or null if there are no more pages.\n+   */\n+  @Nullable\n+  @Override\n+  public ListTenantsPage getNextPage() {\n+    if (hasNextPage()) {\n+      PageFactory factory = new PageFactory(source, maxResults, currentBatch.getPageToken());\n+      try {\n+        return factory.create();\n+      } catch (FirebaseAuthException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns an {@link Iterable} that facilitates transparently iterating over all the tenants in\n+   * the current Firebase project, starting from this page.\n+   *\n+   * <p>The {@link Iterator} instances produced by the returned {@link Iterable} never buffers more\n+   * than one page of tenants at a time. It is safe to abandon the iterators (i.e. break the loops)\n+   * at any time.\n+   *\n+   * @return a new {@link Iterable} instance.\n+   */\n+  @NonNull\n+  @Override\n+  public Iterable<Tenant> iterateAll() {\n+    return new TenantIterable(this);\n+  }\n+\n+  /**\n+   * Returns an {@link Iterable} over the users in this page.\n+   *\n+   * @return a {@link Iterable} instance.\n+   */\n+  @NonNull\n+  @Override\n+  public Iterable<Tenant> getValues() {\n+    return currentBatch.getTenants();\n+  }\n+\n+  private static class TenantIterable implements Iterable<Tenant> {\n+\n+    private final ListTenantsPage startingPage;\n+\n+    TenantIterable(@NonNull ListTenantsPage startingPage) {\n+      this.startingPage = checkNotNull(startingPage, \"starting page must not be null\");\n+    }\n+\n+    @Override\n+    @NonNull\n+    public Iterator<Tenant> iterator() {\n+      return new TenantIterator(startingPage);\n+    }\n+\n+    /**\n+     * An {@link Iterator} that cycles through tenants, one at a time.\n+     *\n+     * <p>It buffers the last retrieved batch of tenants in memory. The {@code maxResults} parameter\n+     * is an upper bound on the batch size.\n+     */\n+    private static class TenantIterator implements Iterator<Tenant> {\n+\n+      private ListTenantsPage currentPage;\n+      private List<Tenant> batch;\n+      private int index = 0;\n+\n+      private TenantIterator(ListTenantsPage startingPage) {\n+        setCurrentPage(startingPage);\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        if (index == batch.size()) {\n+          if (currentPage.hasNextPage()) {\n+            setCurrentPage(currentPage.getNextPage());\n+          } else {\n+            return false;\n+          }\n+        }\n+\n+        return index < batch.size();\n+      }\n+\n+      @Override\n+      public Tenant next() {\n+        if (!hasNext()) {\n+          throw new NoSuchElementException();\n+        }\n+        return batch.get(index++);\n+      }\n+\n+      @Override\n+      public void remove() {\n+        throw new UnsupportedOperationException(\"remove operation not supported\");\n+      }\n+\n+      private void setCurrentPage(ListTenantsPage page) {\n+        this.currentPage = checkNotNull(page);\n+        this.batch = ImmutableList.copyOf(page.getValues());\n+        this.index = 0;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Represents a source of tenant data that can be queried to load a batch of tenants.\n+   */\n+  interface TenantSource {\n+    @NonNull\n+    ListTenantsResponse fetch(int maxResults, String pageToken)\n+      throws FirebaseAuthException;\n+  }\n+\n+  static class DefaultTenantSource implements TenantSource {\n+\n+    private final FirebaseUserManager userManager;\n+\n+    DefaultTenantSource(FirebaseUserManager userManager) {\n+      this.userManager = checkNotNull(userManager, \"user manager must not be null\");\n+    }\n+\n+    @Override\n+    public ListTenantsResponse fetch(int maxResults, String pageToken)\n+        throws FirebaseAuthException {\n+      return userManager.listTenants(maxResults, pageToken);\n+    }\n+  }\n+\n+  /**\n+   * A simple factory class for {@link ListTenantsPage} instances.\n+   *\n+   * <p>Performs argument validation before attempting to load any tenant data (which is expensive,\n+   * and hence may be performed asynchronously on a separate thread).\n+   */\n+  static class PageFactory {\n+\n+    private final TenantSource source;\n+    private final int maxResults;\n+    private final String pageToken;\n+\n+    PageFactory(@NonNull TenantSource source) {\n+      this(source, FirebaseUserManager.MAX_LIST_TENANTS_RESULTS, null);\n+    }\n+\n+    PageFactory(@NonNull TenantSource source, int maxResults, @Nullable String pageToken) {\n+      checkArgument(maxResults > 0 && maxResults <= FirebaseUserManager.MAX_LIST_TENANTS_RESULTS,\n+          \"maxResults must be a positive integer that does not exceed %s\",\n+          FirebaseUserManager.MAX_LIST_TENANTS_RESULTS);\n+      checkArgument(!END_OF_LIST.equals(pageToken), \"invalid end of list page token\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNDAxMA==", "bodyText": "Done.", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420414010", "createdAt": "2020-05-05T21:21:32Z", "author": {"login": "micahstairs"}, "path": "src/main/java/com/google/firebase/auth/ListTenantsPage.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.gax.paging.Page;\n+import com.google.common.collect.ImmutableList;\n+import com.google.firebase.auth.internal.DownloadAccountResponse;\n+import com.google.firebase.auth.internal.ListTenantsResponse;\n+import com.google.firebase.internal.NonNull;\n+import com.google.firebase.internal.Nullable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Represents a page of {@link Tenant} instances.\n+ *\n+ * <p>Provides methods for iterating over the tenants in the current page, and calling up\n+ * subsequent pages of tenants.\n+ *\n+ * <p>Instances of this class are thread-safe and immutable.\n+ */\n+public class ListTenantsPage implements Page<Tenant> {\n+\n+  static final String END_OF_LIST = \"\";\n+\n+  private final ListTenantsResponse currentBatch;\n+  private final TenantSource source;\n+  private final int maxResults;\n+\n+  private ListTenantsPage(\n+      @NonNull ListTenantsResponse currentBatch, @NonNull TenantSource source, int maxResults) {\n+    this.currentBatch = checkNotNull(currentBatch);\n+    this.source = checkNotNull(source);\n+    this.maxResults = maxResults;\n+  }\n+\n+  /**\n+   * Checks if there is another page of tenants available to retrieve.\n+   *\n+   * @return true if another page is available, or false otherwise.\n+   */\n+  @Override\n+  public boolean hasNextPage() {\n+    return !END_OF_LIST.equals(currentBatch.getPageToken());\n+  }\n+\n+  /**\n+   * Returns the string token that identifies the next page.\n+   *\n+   * <p>Never returns null. Returns empty string if there are no more pages available to be\n+   * retrieved.\n+   *\n+   * @return A non-null string token (possibly empty, representing no more pages)\n+   */\n+  @NonNull\n+  @Override\n+  public String getNextPageToken() {\n+    return currentBatch.getPageToken();\n+  }\n+\n+  /**\n+   * Returns the next page of tenants.\n+   *\n+   * @return A new {@link ListTenantsPage} instance, or null if there are no more pages.\n+   */\n+  @Nullable\n+  @Override\n+  public ListTenantsPage getNextPage() {\n+    if (hasNextPage()) {\n+      PageFactory factory = new PageFactory(source, maxResults, currentBatch.getPageToken());\n+      try {\n+        return factory.create();\n+      } catch (FirebaseAuthException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns an {@link Iterable} that facilitates transparently iterating over all the tenants in\n+   * the current Firebase project, starting from this page.\n+   *\n+   * <p>The {@link Iterator} instances produced by the returned {@link Iterable} never buffers more\n+   * than one page of tenants at a time. It is safe to abandon the iterators (i.e. break the loops)\n+   * at any time.\n+   *\n+   * @return a new {@link Iterable} instance.\n+   */\n+  @NonNull\n+  @Override\n+  public Iterable<Tenant> iterateAll() {\n+    return new TenantIterable(this);\n+  }\n+\n+  /**\n+   * Returns an {@link Iterable} over the users in this page.\n+   *\n+   * @return a {@link Iterable} instance.\n+   */\n+  @NonNull\n+  @Override\n+  public Iterable<Tenant> getValues() {\n+    return currentBatch.getTenants();\n+  }\n+\n+  private static class TenantIterable implements Iterable<Tenant> {\n+\n+    private final ListTenantsPage startingPage;\n+\n+    TenantIterable(@NonNull ListTenantsPage startingPage) {\n+      this.startingPage = checkNotNull(startingPage, \"starting page must not be null\");\n+    }\n+\n+    @Override\n+    @NonNull\n+    public Iterator<Tenant> iterator() {\n+      return new TenantIterator(startingPage);\n+    }\n+\n+    /**\n+     * An {@link Iterator} that cycles through tenants, one at a time.\n+     *\n+     * <p>It buffers the last retrieved batch of tenants in memory. The {@code maxResults} parameter\n+     * is an upper bound on the batch size.\n+     */\n+    private static class TenantIterator implements Iterator<Tenant> {\n+\n+      private ListTenantsPage currentPage;\n+      private List<Tenant> batch;\n+      private int index = 0;\n+\n+      private TenantIterator(ListTenantsPage startingPage) {\n+        setCurrentPage(startingPage);\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        if (index == batch.size()) {\n+          if (currentPage.hasNextPage()) {\n+            setCurrentPage(currentPage.getNextPage());\n+          } else {\n+            return false;\n+          }\n+        }\n+\n+        return index < batch.size();\n+      }\n+\n+      @Override\n+      public Tenant next() {\n+        if (!hasNext()) {\n+          throw new NoSuchElementException();\n+        }\n+        return batch.get(index++);\n+      }\n+\n+      @Override\n+      public void remove() {\n+        throw new UnsupportedOperationException(\"remove operation not supported\");\n+      }\n+\n+      private void setCurrentPage(ListTenantsPage page) {\n+        this.currentPage = checkNotNull(page);\n+        this.batch = ImmutableList.copyOf(page.getValues());\n+        this.index = 0;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Represents a source of tenant data that can be queried to load a batch of tenants.\n+   */\n+  interface TenantSource {\n+    @NonNull\n+    ListTenantsResponse fetch(int maxResults, String pageToken)\n+      throws FirebaseAuthException;\n+  }\n+\n+  static class DefaultTenantSource implements TenantSource {\n+\n+    private final FirebaseUserManager userManager;\n+\n+    DefaultTenantSource(FirebaseUserManager userManager) {\n+      this.userManager = checkNotNull(userManager, \"user manager must not be null\");\n+    }\n+\n+    @Override\n+    public ListTenantsResponse fetch(int maxResults, String pageToken)\n+        throws FirebaseAuthException {\n+      return userManager.listTenants(maxResults, pageToken);\n+    }\n+  }\n+\n+  /**\n+   * A simple factory class for {@link ListTenantsPage} instances.\n+   *\n+   * <p>Performs argument validation before attempting to load any tenant data (which is expensive,\n+   * and hence may be performed asynchronously on a separate thread).\n+   */\n+  static class PageFactory {\n+\n+    private final TenantSource source;\n+    private final int maxResults;\n+    private final String pageToken;\n+\n+    PageFactory(@NonNull TenantSource source) {\n+      this(source, FirebaseUserManager.MAX_LIST_TENANTS_RESULTS, null);\n+    }\n+\n+    PageFactory(@NonNull TenantSource source, int maxResults, @Nullable String pageToken) {\n+      checkArgument(maxResults > 0 && maxResults <= FirebaseUserManager.MAX_LIST_TENANTS_RESULTS,\n+          \"maxResults must be a positive integer that does not exceed %s\",\n+          FirebaseUserManager.MAX_LIST_TENANTS_RESULTS);\n+      checkArgument(!END_OF_LIST.equals(pageToken), \"invalid end of list page token\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MzYyOQ=="}, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjM4MzMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/google/firebase/auth/Tenant.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODowMTo0MlrOGQ1Rdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToyMzoxOFrOGQ8FXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwMzIyMw==", "bodyText": "Probably omit \"and false otherwise\" (Or \"True if ... and false otherwise.\")\nhere and below", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420303223", "createdAt": "2020-05-05T18:01:42Z", "author": {"login": "kevinthecheung"}, "path": "src/main/java/com/google/firebase/auth/Tenant.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.api.client.util.Key;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Contains metadata associated with a Firebase tenant.\n+ *\n+ * <p>Instances of this class are immutable and thread safe.\n+ */\n+public final class Tenant {\n+\n+  // Lazily initialized from 'resourceName'.\n+  private String tenantId;\n+\n+  @Key(\"name\")\n+  private String resourceName;\n+\n+  @Key(\"displayName\")\n+  private String displayName;\n+\n+  @Key(\"allowPasswordSignup\")\n+  private boolean passwordSignInAllowed;\n+\n+  @Key(\"enableEmailLinkSignin\")\n+  private boolean emailLinkSignInEnabled;\n+\n+  public String getTenantId() {\n+    if (tenantId == null) {\n+      tenantId = resourceName.substring(resourceName.lastIndexOf(\"/\") + 1);\n+    }\n+    return tenantId;\n+  }\n+\n+  public String getDisplayName() {\n+    return displayName;\n+  }\n+\n+  public boolean isPasswordSignInAllowed() {\n+    return passwordSignInAllowed;\n+  }\n+\n+  public boolean isEmailLinkSignInEnabled() {\n+    return emailLinkSignInEnabled;\n+  }\n+\n+  /**\n+   * Returns a new {@link UpdateRequest}, which can be used to update the attributes\n+   * of this tenant.\n+   *\n+   * @return a non-null Tenant.UpdateRequest instance.\n+   */\n+  public UpdateRequest updateRequest() {\n+    return new UpdateRequest(getTenantId());\n+  }\n+\n+  /**\n+   * A specification class for creating a new tenant.\n+   *\n+   * <p>Set the initial attributes of the new tenant by calling various setter methods available in\n+   * this class. None of the attributes are required.\n+   */\n+  public static final class CreateRequest {\n+\n+    private final Map<String,Object> properties = new HashMap<>();\n+\n+    /**\n+     * Creates a new {@link CreateRequest}, which can be used to create a new tenant.\n+     *\n+     * <p>The returned object should be passed to {@link TenantManager#createTenant(CreateRequest)}\n+     * to register the tenant information persistently.\n+     */\n+    public CreateRequest() { }\n+\n+    /**\n+     * Sets the display name for the new tenant.\n+     *\n+     * @param displayName a non-null, non-empty display name string.\n+     */\n+    public CreateRequest setDisplayName(String displayName) {\n+      checkArgument(!Strings.isNullOrEmpty(displayName), \"display name must not be null or empty\");\n+      properties.put(\"displayName\", displayName);\n+      return this;\n+    }\n+\n+    /**\n+     * Sets whether to allow email/password user authentication.\n+     *\n+     * @param passwordSignInAllowed a boolean indicating whether users can be authenticated using\n+     *     an email and password, and false otherwise.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNDgxMw==", "bodyText": "Omitted.", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420414813", "createdAt": "2020-05-05T21:23:18Z", "author": {"login": "micahstairs"}, "path": "src/main/java/com/google/firebase/auth/Tenant.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.api.client.util.Key;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Contains metadata associated with a Firebase tenant.\n+ *\n+ * <p>Instances of this class are immutable and thread safe.\n+ */\n+public final class Tenant {\n+\n+  // Lazily initialized from 'resourceName'.\n+  private String tenantId;\n+\n+  @Key(\"name\")\n+  private String resourceName;\n+\n+  @Key(\"displayName\")\n+  private String displayName;\n+\n+  @Key(\"allowPasswordSignup\")\n+  private boolean passwordSignInAllowed;\n+\n+  @Key(\"enableEmailLinkSignin\")\n+  private boolean emailLinkSignInEnabled;\n+\n+  public String getTenantId() {\n+    if (tenantId == null) {\n+      tenantId = resourceName.substring(resourceName.lastIndexOf(\"/\") + 1);\n+    }\n+    return tenantId;\n+  }\n+\n+  public String getDisplayName() {\n+    return displayName;\n+  }\n+\n+  public boolean isPasswordSignInAllowed() {\n+    return passwordSignInAllowed;\n+  }\n+\n+  public boolean isEmailLinkSignInEnabled() {\n+    return emailLinkSignInEnabled;\n+  }\n+\n+  /**\n+   * Returns a new {@link UpdateRequest}, which can be used to update the attributes\n+   * of this tenant.\n+   *\n+   * @return a non-null Tenant.UpdateRequest instance.\n+   */\n+  public UpdateRequest updateRequest() {\n+    return new UpdateRequest(getTenantId());\n+  }\n+\n+  /**\n+   * A specification class for creating a new tenant.\n+   *\n+   * <p>Set the initial attributes of the new tenant by calling various setter methods available in\n+   * this class. None of the attributes are required.\n+   */\n+  public static final class CreateRequest {\n+\n+    private final Map<String,Object> properties = new HashMap<>();\n+\n+    /**\n+     * Creates a new {@link CreateRequest}, which can be used to create a new tenant.\n+     *\n+     * <p>The returned object should be passed to {@link TenantManager#createTenant(CreateRequest)}\n+     * to register the tenant information persistently.\n+     */\n+    public CreateRequest() { }\n+\n+    /**\n+     * Sets the display name for the new tenant.\n+     *\n+     * @param displayName a non-null, non-empty display name string.\n+     */\n+    public CreateRequest setDisplayName(String displayName) {\n+      checkArgument(!Strings.isNullOrEmpty(displayName), \"display name must not be null or empty\");\n+      properties.put(\"displayName\", displayName);\n+      return this;\n+    }\n+\n+    /**\n+     * Sets whether to allow email/password user authentication.\n+     *\n+     * @param passwordSignInAllowed a boolean indicating whether users can be authenticated using\n+     *     an email and password, and false otherwise.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwMzIyMw=="}, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjM5MjIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/google/firebase/auth/TenantAwareFirebaseAuth.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODowNDoxNFrOGQ1XGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToyMzo1MFrOGQ8GWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNDY2NA==", "bodyText": "Returns the client's tenant ID.", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420304664", "createdAt": "2020-05-05T18:04:14Z", "author": {"login": "kevinthecheung"}, "path": "src/main/java/com/google/firebase/auth/TenantAwareFirebaseAuth.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.api.client.util.Clock;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Supplier;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.auth.internal.FirebaseTokenFactory;\n+\n+/**\n+ * The tenant-aware Firebase client.\n+ *\n+ * <p>This can be used to perform a variety of authentication-related operations, scoped to a\n+ * particular tenant.\n+ */\n+public class TenantAwareFirebaseAuth extends AbstractFirebaseAuth {\n+\n+  private final String tenantId;\n+\n+  TenantAwareFirebaseAuth(final FirebaseApp firebaseApp, final String tenantId) {\n+    super(builderFromAppAndTenantId(firebaseApp, tenantId));\n+    checkArgument(!Strings.isNullOrEmpty(tenantId));\n+    this.tenantId = tenantId;\n+  }\n+\n+  private static Builder builderFromAppAndTenantId(final FirebaseApp app, final String tenantId) {\n+    return AbstractFirebaseAuth.builder()\n+        .setFirebaseApp(app)\n+        .setTokenFactory(\n+            new Supplier<FirebaseTokenFactory>() {\n+              @Override\n+              public FirebaseTokenFactory get() {\n+                return FirebaseTokenUtils.createTokenFactory(app, Clock.SYSTEM, tenantId);\n+              }\n+            })\n+        .setIdTokenVerifier(\n+            new Supplier<FirebaseTokenVerifier>() {\n+              @Override\n+              public FirebaseTokenVerifier get() {\n+                return FirebaseTokenUtils.createIdTokenVerifier(app, Clock.SYSTEM, tenantId);\n+              }\n+            })\n+        .setCookieVerifier(\n+            new Supplier<FirebaseTokenVerifier>() {\n+              @Override\n+              public FirebaseTokenVerifier get() {\n+                return FirebaseTokenUtils.createSessionCookieVerifier(app, Clock.SYSTEM);\n+              }\n+            })\n+        .setUserManager(\n+            new Supplier<FirebaseUserManager>() {\n+              @Override\n+              public FirebaseUserManager get() {\n+                return FirebaseUserManager\n+                  .builder()\n+                  .setFirebaseApp(app)\n+                  .setTenantId(tenantId)\n+                  .build();\n+              }\n+            });\n+  }\n+\n+  /** Returns the corresponding tenant ID. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNTA2NQ==", "bodyText": "Done.", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420415065", "createdAt": "2020-05-05T21:23:50Z", "author": {"login": "micahstairs"}, "path": "src/main/java/com/google/firebase/auth/TenantAwareFirebaseAuth.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.auth;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.api.client.util.Clock;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Supplier;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.auth.internal.FirebaseTokenFactory;\n+\n+/**\n+ * The tenant-aware Firebase client.\n+ *\n+ * <p>This can be used to perform a variety of authentication-related operations, scoped to a\n+ * particular tenant.\n+ */\n+public class TenantAwareFirebaseAuth extends AbstractFirebaseAuth {\n+\n+  private final String tenantId;\n+\n+  TenantAwareFirebaseAuth(final FirebaseApp firebaseApp, final String tenantId) {\n+    super(builderFromAppAndTenantId(firebaseApp, tenantId));\n+    checkArgument(!Strings.isNullOrEmpty(tenantId));\n+    this.tenantId = tenantId;\n+  }\n+\n+  private static Builder builderFromAppAndTenantId(final FirebaseApp app, final String tenantId) {\n+    return AbstractFirebaseAuth.builder()\n+        .setFirebaseApp(app)\n+        .setTokenFactory(\n+            new Supplier<FirebaseTokenFactory>() {\n+              @Override\n+              public FirebaseTokenFactory get() {\n+                return FirebaseTokenUtils.createTokenFactory(app, Clock.SYSTEM, tenantId);\n+              }\n+            })\n+        .setIdTokenVerifier(\n+            new Supplier<FirebaseTokenVerifier>() {\n+              @Override\n+              public FirebaseTokenVerifier get() {\n+                return FirebaseTokenUtils.createIdTokenVerifier(app, Clock.SYSTEM, tenantId);\n+              }\n+            })\n+        .setCookieVerifier(\n+            new Supplier<FirebaseTokenVerifier>() {\n+              @Override\n+              public FirebaseTokenVerifier get() {\n+                return FirebaseTokenUtils.createSessionCookieVerifier(app, Clock.SYSTEM);\n+              }\n+            })\n+        .setUserManager(\n+            new Supplier<FirebaseUserManager>() {\n+              @Override\n+              public FirebaseUserManager get() {\n+                return FirebaseUserManager\n+                  .builder()\n+                  .setFirebaseApp(app)\n+                  .setTenantId(tenantId)\n+                  .build();\n+              }\n+            });\n+  }\n+\n+  /** Returns the corresponding tenant ID. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNDY2NA=="}, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNjQwNDcwOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/google/firebase/auth/FirebaseTokenVerifierImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODowNzozM1rOGQ1fGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToyNDo0MlrOGQ8IFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNjcxNQ==", "bodyText": "the expected value ('TENANT_1')\nhere and below", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420306715", "createdAt": "2020-05-05T18:07:33Z", "author": {"login": "kevinthecheung"}, "path": "src/test/java/com/google/firebase/auth/FirebaseTokenVerifierImplTest.java", "diffHunk": "@@ -216,6 +218,50 @@ public void testMalformedToken() throws Exception {\n     tokenVerifier.verifyToken(\"not.a.jwt\");\n   }\n \n+  @Test\n+  public void testVerifyTokenDifferentTenantIds() throws Exception {\n+    try {\n+      fullyPopulatedBuilder()\n+        .setTenantId(\"TENANT_1\")\n+        .build()\n+        .verifyToken(createTokenWithTenantId(\"TENANT_2\"));\n+    } catch (FirebaseAuthException e) {\n+      assertEquals(FirebaseUserManager.TENANT_ID_MISMATCH_ERROR, e.getErrorCode());\n+      assertEquals(\n+          \"The tenant ID ('TENANT_2') of the token did not match the expected ('TENANT_1') value\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNTUwOA==", "bodyText": "Done.", "url": "https://github.com/firebase/firebase-admin-java/pull/395#discussion_r420415508", "createdAt": "2020-05-05T21:24:42Z", "author": {"login": "micahstairs"}, "path": "src/test/java/com/google/firebase/auth/FirebaseTokenVerifierImplTest.java", "diffHunk": "@@ -216,6 +218,50 @@ public void testMalformedToken() throws Exception {\n     tokenVerifier.verifyToken(\"not.a.jwt\");\n   }\n \n+  @Test\n+  public void testVerifyTokenDifferentTenantIds() throws Exception {\n+    try {\n+      fullyPopulatedBuilder()\n+        .setTenantId(\"TENANT_1\")\n+        .build()\n+        .verifyToken(createTokenWithTenantId(\"TENANT_2\"));\n+    } catch (FirebaseAuthException e) {\n+      assertEquals(FirebaseUserManager.TENANT_ID_MISMATCH_ERROR, e.getErrorCode());\n+      assertEquals(\n+          \"The tenant ID ('TENANT_2') of the token did not match the expected ('TENANT_1') value\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwNjcxNQ=="}, "originalCommit": {"oid": "312183aafcfb9d49eb9b01b2d8265a3903495587"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1553, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}