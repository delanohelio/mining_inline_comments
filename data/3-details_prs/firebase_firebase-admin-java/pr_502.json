{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM3MjYzMjA1", "number": 502, "title": "feat(rc): Add Remote Config Management API ", "bodyText": "RELEASE NOTES: Added support for the Remote Config API. This API enables Firebase developers to programmatically manage the set of JSON-formatted parameters and conditions known as the Remote Config template.\nResolves: #446", "createdAt": "2020-12-11T18:43:51Z", "url": "https://github.com/firebase/firebase-admin-java/pull/502", "merged": true, "mergeCommit": {"oid": "5f3b696db4bf4550203a47834dfa19a8a33d750b"}, "closed": true, "closedAt": "2020-12-14T19:40:20Z", "author": {"login": "lahirumaramba"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJOJNYgH2gAyNTM3MjYzMjA1Ojg4NDgyZGI5NTg4OTE5ZTUyM2JhYjk0NDk2ZWQxOWEwOGZhMzQxNDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmKoqEgFqTU1MTgwOTIzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "88482db9588919e523bab94496ed19a08fa34140", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/88482db9588919e523bab94496ed19a08fa34140", "committedDate": "2020-09-15T20:51:17Z", "message": "Add initial classes for Remote Config API (#477)\n\n- Add initial classes for Remote Config API\r\n- Add unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "936043bf8e61f8792dc668b1801de9939f6e61d8", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/936043bf8e61f8792dc668b1801de9939f6e61d8", "committedDate": "2020-09-24T18:49:35Z", "message": "Add the entry point for Remote Config (#478)\n\n* Add the entry point for Remote Config\r\n\r\n* Remove the builder in RemoteConfig.java\r\n\r\n* Remove fromApp and use the constructor directly\r\n\r\n* Fix doc strings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "150b121b2ca8187b119bb2e3c3807d8f50385f5e", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/150b121b2ca8187b119bb2e3c3807d8f50385f5e", "committedDate": "2020-10-02T18:35:40Z", "message": "Add parameters to Remote Config template (#479)\n\n- Introduce Response Types and Public Types\r\n- Implement toResponseType() and toPublicType()\r\n- Add parameters to RemoteConfigTemplate\r\n- Add unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01d0c98ef2ba9bccc1d2331fbed8b39e2c5410f7", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/01d0c98ef2ba9bccc1d2331fbed8b39e2c5410f7", "committedDate": "2020-10-06T16:10:24Z", "message": "Remote Config Refactor Public and Response types (#481)\n\n* Refactor Public and Response types\r\n\r\n* reformat code\r\n\r\n* Clean up code style\r\n\r\n* Remove getUseInAppDefault and use the value type in setter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2c5e815725201757af764e4025f0a2c3565f019", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/f2c5e815725201757af764e4025f0a2c3565f019", "committedDate": "2020-10-13T17:06:31Z", "message": "Remove RemoteConfig prefix from classes (#483)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4bde999d4e072b5bf9d2f558d0124668b455070", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/e4bde999d4e072b5bf9d2f558d0124668b455070", "committedDate": "2020-10-27T21:30:03Z", "message": "Add Remote Config conditions to template (#489)\n\n* Add Remote Config conditions to template"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd5dfdaf13cd9ccc620a414402dac5699831ae90", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/cd5dfdaf13cd9ccc620a414402dac5699831ae90", "committedDate": "2020-11-02T18:05:59Z", "message": "Add Remote Config Parameter Group type (#490)\n\n* Introduce Parameter Groups\r\n\r\n* Refactor unit tests\r\n\r\n* PR fixes\r\n\r\n* Fix variable names in unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daf8b2c4253f5d4bee2f9528a2a526e3b8733589", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/daf8b2c4253f5d4bee2f9528a2a526e3b8733589", "committedDate": "2020-11-10T20:22:23Z", "message": "Add Version information to RC template (#491)\n\n* Add Version information to RC template\r\n\r\n* PR fixes\r\n\r\n* PR fixes\r\n\r\n* Clean up template unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a3f03665c35454e5e4e969c853ec3dbd43786d3", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/1a3f03665c35454e5e4e969c853ec3dbd43786d3", "committedDate": "2020-11-24T16:16:17Z", "message": "Add Remote Config Pubish, Validate, and GetTemplateAtVersion operations (#496)\n\n* Add Pubish, Validate, and GetTemplateAtVersion operations\r\n\r\n* Clean up tests\r\n\r\n* Move PublishOptions to parent package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33b9e3b91943fd39945b7612909eb92121936817", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/33b9e3b91943fd39945b7612909eb92121936817", "committedDate": "2020-12-01T23:10:30Z", "message": "Add Remote Config rollback operation (#497)\n\n* Add Remote Config rollback operation\r\n\r\n* PR fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8085ceeb68db4b067cef1c2ad45a9437aa192b9b", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/8085ceeb68db4b067cef1c2ad45a9437aa192b9b", "committedDate": "2020-12-02T22:43:27Z", "message": "Add List Versions operation in Remote Config (#498)\n\n* Add List Versions operation in Remote Config\r\n\r\n* PR fixes\r\n\r\n* Move convertToUtcZuluFormat to utils class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09043e6bf13cd9113e7f3cf00899738db4a8c9be", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/09043e6bf13cd9113e7f3cf00899738db4a8c9be", "committedDate": "2020-12-10T23:28:01Z", "message": "Add toJSON and fromJSON to Remote Config Template (#500)\n\n* Add toJSON and fromJSON to Remote Config Template"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/03b9f3d63c90222932ebff6df70d30ca9f802c59", "committedDate": "2020-12-11T18:35:36Z", "message": "Add Remote Config Integration tests (#501)\n\n* Add Remote Config Integration tests\r\n\r\n* Updated listversions tests to use the sync apis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNDczNDkz", "url": "https://github.com/firebase/firebase-admin-java/pull/502#pullrequestreview-550473493", "createdAt": "2020-12-11T18:52:22Z", "commit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTIwOTEw", "url": "https://github.com/firebase/firebase-admin-java/pull/502#pullrequestreview-550520910", "createdAt": "2020-12-11T19:33:51Z", "commit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTozMzo1MlrOIEISfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQyMDo0MToxMFrOIEMTOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMTAyMA==", "bodyText": "This is correct; would \"template to get\" or \"template to retrieve\" be more accurate?", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541201020", "createdAt": "2020-12-11T19:33:52Z", "author": {"login": "egilmorez"}, "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwNjAzNw==", "bodyText": "This somehow overloads the similar previous method, right?  Should we say something here about how/why, much as you have done for the async methods?", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541206037", "createdAt": "2020-12-11T19:38:54Z", "author": {"login": "egilmorez"}, "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(\n+          @NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return getTemplateAtVersionOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMDkyOQ==", "bodyText": "I guess the difference here is the length of the version number . . . but I'm a bit confused looking at these.  Can you check and make sure each similar/overloaded method has a descr. mentioning the distinction?\nWould be easier for me to eyeball if we had a staged version.  Is that even feasible before a PR like this is merged?", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541210929", "createdAt": "2020-12-11T19:44:06Z", "author": {"login": "egilmorez"}, "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(\n+          @NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return getTemplateAtVersionOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(long versionNumber) throws FirebaseRemoteConfigException {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(String versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(@NonNull String versionNumber) {\n+    return getTemplateAtVersionOp(versionNumber).callAsync(app);\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(long versionNumber)} but performs the operation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxNDEwMw==", "bodyText": "Would it be accurate to say something like \"ignoring\" or \"disregarding any existing ETag conflicts.\"  ?\nOr maybe \"without evaluating the ETag values.\"  ?\nFeels a little odd just attached with \"and\" this way.", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541214103", "createdAt": "2020-12-11T19:47:16Z", "author": {"login": "egilmorez"}, "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(\n+          @NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return getTemplateAtVersionOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(long versionNumber) throws FirebaseRemoteConfigException {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(String versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(@NonNull String versionNumber) {\n+    return getTemplateAtVersionOp(versionNumber).callAsync(app);\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(long versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(long versionNumber) {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateAtVersionOp(\n+          final String versionNumber) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplateAtVersion(versionNumber);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Publishes a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return The published {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while publishing the template.\n+   */\n+  public Template publishTemplate(@NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #publishTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is published.\n+   */\n+  public ApiFuture<Template> publishTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template).callAsync(app);\n+  }\n+\n+  /**\n+   * Validates a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return The validated {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while validating the template.\n+   */\n+  public Template validateTemplate(\n+          @NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #validateTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is validated.\n+   */\n+  public ApiFuture<Template> validateTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).callAsync(app);\n+  }\n+\n+  /**\n+   * Force publishes a Remote Config template.\n+   *\n+   * <p>This method forces the Remote Config template to be updated and circumvent the ETag.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxNjY0OA==", "bodyText": "Is this the long version number variant?", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541216648", "createdAt": "2020-12-11T19:49:53Z", "author": {"login": "egilmorez"}, "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(\n+          @NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return getTemplateAtVersionOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(long versionNumber) throws FirebaseRemoteConfigException {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(String versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(@NonNull String versionNumber) {\n+    return getTemplateAtVersionOp(versionNumber).callAsync(app);\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(long versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(long versionNumber) {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateAtVersionOp(\n+          final String versionNumber) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplateAtVersion(versionNumber);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Publishes a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return The published {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while publishing the template.\n+   */\n+  public Template publishTemplate(@NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #publishTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is published.\n+   */\n+  public ApiFuture<Template> publishTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template).callAsync(app);\n+  }\n+\n+  /**\n+   * Validates a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return The validated {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while validating the template.\n+   */\n+  public Template validateTemplate(\n+          @NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #validateTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is validated.\n+   */\n+  public ApiFuture<Template> validateTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).callAsync(app);\n+  }\n+\n+  /**\n+   * Force publishes a Remote Config template.\n+   *\n+   * <p>This method forces the Remote Config template to be updated and circumvent the ETag.\n+   * This approach is not recommended because it risks causing the loss of updates to your\n+   * Remote Config template if multiple clients are updating the Remote Config template.\n+   * See <a href=\"https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates\">\n+   * ETag usage and forced updates</a>.\n+   *\n+   * @param template The Remote Config template to be forcefully published.\n+   * @return The published {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while publishing the template.\n+   */\n+  public Template forcePublishTemplate(\n+          @NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template, new PublishOptions().setForcePublish(true)).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #forcePublishTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be forcefully published.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is published.\n+   */\n+  public ApiFuture<Template> forcePublishTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template, new PublishOptions().setForcePublish(true)).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> publishTemplateOp(\n+          final Template template) {\n+    return publishTemplateOp(template, new PublishOptions());\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> publishTemplateOp(\n+          final Template template, final PublishOptions options) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient\n+                .publishTemplate(template, options.isValidateOnly(), options.isForcePublish());\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Rolls back a project's published Remote Config template to the specified version.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxODE3Mg==", "bodyText": "Do you mean that this method fires off the deletion?  Otherwise, this might seem like extra/unnecessary information.\nHere and below (whose desc may also need clarification on the nature of the override).", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541218172", "createdAt": "2020-12-11T19:51:29Z", "author": {"login": "egilmorez"}, "path": "src/main/java/com/google/firebase/remoteconfig/FirebaseRemoteConfig.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ImplFirebaseTrampolines;\n+import com.google.firebase.internal.CallableOperation;\n+import com.google.firebase.internal.FirebaseService;\n+import com.google.firebase.internal.NonNull;\n+\n+/**\n+ * This class is the entry point for all server-side Firebase Remote Config actions.\n+ *\n+ * <p>You can get an instance of {@link FirebaseRemoteConfig} via {@link #getInstance(FirebaseApp)},\n+ * and then use it to manage Remote Config templates.\n+ */\n+public final class FirebaseRemoteConfig {\n+\n+  private static final String SERVICE_ID = FirebaseRemoteConfig.class.getName();\n+  private final FirebaseApp app;\n+  private final FirebaseRemoteConfigClient remoteConfigClient;\n+\n+  @VisibleForTesting\n+  FirebaseRemoteConfig(FirebaseApp app, FirebaseRemoteConfigClient client) {\n+    this.app = checkNotNull(app);\n+    this.remoteConfigClient = checkNotNull(client);\n+  }\n+\n+  private FirebaseRemoteConfig(FirebaseApp app) {\n+    this(app, FirebaseRemoteConfigClientImpl.fromApp(app));\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the default {@link FirebaseApp}.\n+   */\n+  public static FirebaseRemoteConfig getInstance() {\n+    return getInstance(FirebaseApp.getInstance());\n+  }\n+\n+  /**\n+   * Gets the {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   *\n+   * @return The {@link FirebaseRemoteConfig} instance for the specified {@link FirebaseApp}.\n+   */\n+  public static synchronized FirebaseRemoteConfig getInstance(FirebaseApp app) {\n+    FirebaseRemoteConfigService service = ImplFirebaseTrampolines.getService(app, SERVICE_ID,\n+            FirebaseRemoteConfigService.class);\n+    if (service == null) {\n+      service = ImplFirebaseTrampolines.addService(app, new FirebaseRemoteConfigService(app));\n+    }\n+    return service.getInstance();\n+  }\n+\n+  /**\n+   * Gets the current active version of the Remote Config template.\n+   *\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplate() throws FirebaseRemoteConfigException {\n+    return getTemplateOp().call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplate()} but performs the operation asynchronously.\n+   *\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *      the template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAsync() {\n+    return getTemplateOp().callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateOp() {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplate();\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(\n+          @NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return getTemplateAtVersionOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Gets the requested version of the of the Remote Config template.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return A {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while getting the template.\n+   */\n+  public Template getTemplateAtVersion(long versionNumber) throws FirebaseRemoteConfigException {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(String versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(@NonNull String versionNumber) {\n+    return getTemplateAtVersionOp(versionNumber).callAsync(app);\n+  }\n+\n+  /**\n+   * Similar to {@link #getTemplateAtVersion(long versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to look up.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the requested template is available.\n+   */\n+  public ApiFuture<Template> getTemplateAtVersionAsync(long versionNumber) {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return getTemplateAtVersionOp(versionNumberString).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> getTemplateAtVersionOp(\n+          final String versionNumber) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.getTemplateAtVersion(versionNumber);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Publishes a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return The published {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while publishing the template.\n+   */\n+  public Template publishTemplate(@NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #publishTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be published.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is published.\n+   */\n+  public ApiFuture<Template> publishTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template).callAsync(app);\n+  }\n+\n+  /**\n+   * Validates a Remote Config template.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return The validated {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while validating the template.\n+   */\n+  public Template validateTemplate(\n+          @NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #validateTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be validated.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is validated.\n+   */\n+  public ApiFuture<Template> validateTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template, new PublishOptions().setValidateOnly(true)).callAsync(app);\n+  }\n+\n+  /**\n+   * Force publishes a Remote Config template.\n+   *\n+   * <p>This method forces the Remote Config template to be updated and circumvent the ETag.\n+   * This approach is not recommended because it risks causing the loss of updates to your\n+   * Remote Config template if multiple clients are updating the Remote Config template.\n+   * See <a href=\"https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates\">\n+   * ETag usage and forced updates</a>.\n+   *\n+   * @param template The Remote Config template to be forcefully published.\n+   * @return The published {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while publishing the template.\n+   */\n+  public Template forcePublishTemplate(\n+          @NonNull Template template) throws FirebaseRemoteConfigException {\n+    return publishTemplateOp(template, new PublishOptions().setForcePublish(true)).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #forcePublishTemplate(Template template)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param template The Remote Config template to be forcefully published.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} when\n+   *     the provided template is published.\n+   */\n+  public ApiFuture<Template> forcePublishTemplateAsync(@NonNull Template template) {\n+    return publishTemplateOp(template, new PublishOptions().setForcePublish(true)).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> publishTemplateOp(\n+          final Template template) {\n+    return publishTemplateOp(template, new PublishOptions());\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> publishTemplateOp(\n+          final Template template, final PublishOptions options) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient\n+                .publishTemplate(template, options.isValidateOnly(), options.isForcePublish());\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Rolls back a project's published Remote Config template to the specified version.\n+   *\n+   * <p>A rollback is equivalent to getting a previously published Remote Config\n+   * template and re-publishing it using a force update.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to roll back to.\n+   *                      The specified version number must be lower than the current version\n+   *                      number, and not have been deleted due to staleness. Only the last 300\n+   *                      versions are stored. All versions that correspond to non-active Remote\n+   *                      Config templates (that is, all except the template that is being fetched\n+   *                      by clients) are also deleted if they are more than 90 days old.\n+   * @return The rolled back {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while rolling back the template.\n+   */\n+  public Template rollback(long versionNumber) throws FirebaseRemoteConfigException {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return rollbackOp(versionNumberString).call();\n+  }\n+\n+  /**\n+   * Rolls back a project's published Remote Config template to the specified version.\n+   *\n+   * <p>A rollback is equivalent to getting a previously published Remote Config\n+   * template and re-publishing it using a force update.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to roll back to.\n+   *                      The specified version number must be lower than the current version\n+   *                      number, and not have been deleted due to staleness. Only the last 300\n+   *                      versions are stored. All versions that correspond to non-active Remote\n+   *                      Config templates (that is, all except the template that is being fetched\n+   *                      by clients) are also deleted if they are more than 90 days old.\n+   * @return The rolled back {@link Template}.\n+   * @throws FirebaseRemoteConfigException If an error occurs while rolling back the template.\n+   */\n+  public Template rollback(@NonNull String versionNumber) throws FirebaseRemoteConfigException {\n+    return rollbackOp(versionNumber).call();\n+  }\n+\n+  /**\n+   * Similar to {@link #rollback(long versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to roll back to.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} once\n+   *     the rollback operation is successful.\n+   */\n+  public ApiFuture<Template> rollbackAsync(long versionNumber) {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return rollbackOp(versionNumberString).callAsync(app);\n+  }\n+\n+  /**\n+   * Similar to {@link #rollback(String versionNumber)} but performs the operation\n+   * asynchronously.\n+   *\n+   * @param versionNumber The version number of the Remote Config template to roll back to.\n+   * @return An {@code ApiFuture} that completes with a {@link Template} once\n+   *     the rollback operation is successful.\n+   */\n+  public ApiFuture<Template> rollbackAsync(@NonNull String versionNumber) {\n+    String versionNumberString = String.valueOf(versionNumber);\n+    return rollbackOp(versionNumberString).callAsync(app);\n+  }\n+\n+  private CallableOperation<Template, FirebaseRemoteConfigException> rollbackOp(\n+          final String versionNumber) {\n+    final FirebaseRemoteConfigClient remoteConfigClient = getRemoteConfigClient();\n+    return new CallableOperation<Template, FirebaseRemoteConfigException>() {\n+      @Override\n+      protected Template execute() throws FirebaseRemoteConfigException {\n+        return remoteConfigClient.rollback(versionNumber);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Gets a list of Remote Config template versions that have been published, sorted in reverse\n+   * chronological order. Only the last 300 versions are stored.\n+   *\n+   * <p>All versions that correspond to non-active Remote Config templates (that is, all except the\n+   * template that is being fetched by clients) are also deleted if they are more than 90 days old.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyMzQ2MQ==", "bodyText": "Nit, but I'd say \"an empty string\"", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541223461", "createdAt": "2020-12-11T19:57:26Z", "author": {"login": "egilmorez"}, "path": "src/main/java/com/google/firebase/remoteconfig/ListVersionsPage.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.gax.paging.Page;\n+import com.google.common.collect.ImmutableList;\n+import com.google.firebase.internal.NonNull;\n+import com.google.firebase.remoteconfig.internal.TemplateResponse;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Represents a page of {@link Version} instances. Provides methods for iterating\n+ * over the versions in the current page, and calling up subsequent pages of versions. Instances of\n+ * this class are thread-safe and immutable.\n+ */\n+public final class ListVersionsPage implements Page<Version> {\n+\n+  static final String END_OF_LIST = \"\";\n+\n+  private final VersionsResultBatch currentBatch;\n+  private final VersionSource source;\n+  private final ListVersionsOptions listVersionsOptions;\n+\n+  private ListVersionsPage(\n+          @NonNull VersionsResultBatch currentBatch, @NonNull VersionSource source,\n+          @NonNull ListVersionsOptions listVersionsOptions) {\n+    this.currentBatch = checkNotNull(currentBatch);\n+    this.source = checkNotNull(source);\n+    this.listVersionsOptions = listVersionsOptions;\n+  }\n+\n+  /**\n+   * Checks if there is another page of versions available to retrieve.\n+   *\n+   * @return true if another page is available, or false otherwise.\n+   */\n+  @Override\n+  public boolean hasNextPage() {\n+    return !END_OF_LIST.equals(currentBatch.getNextPageToken());\n+  }\n+\n+  /**\n+   * Returns the next page of versions.\n+   *\n+   * @return A new {@link ListVersionsPage} instance, or null if there are no more pages.\n+   */\n+  @NonNull\n+  @Override\n+  public ListVersionsPage getNextPage() {\n+    if (hasNextPage()) {\n+      ListVersionsOptions options;\n+      if (listVersionsOptions != null) {\n+        options = listVersionsOptions.toBuilder().setPageToken(currentBatch.getNextPageToken())\n+                .build();\n+      } else {\n+        options = ListVersionsOptions.builder().setPageToken(currentBatch.getNextPageToken())\n+                .build();\n+      }\n+      Factory factory = new Factory(source, options);\n+      try {\n+        return factory.create();\n+      } catch (FirebaseRemoteConfigException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Returns the string token that identifies the next page. Never returns null. Returns empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2NDIxNg==", "bodyText": "This means console or backend, correct?  Might be worth noting.", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541264216", "createdAt": "2020-12-11T20:38:23Z", "author": {"login": "egilmorez"}, "path": "src/main/java/com/google/firebase/remoteconfig/Version.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.Strings;\n+import com.google.firebase.internal.NonNull;\n+import com.google.firebase.internal.Nullable;\n+import com.google.firebase.remoteconfig.internal.TemplateResponse;\n+import com.google.firebase.remoteconfig.internal.TemplateResponse.VersionResponse;\n+\n+import java.text.ParseException;\n+import java.util.Objects;\n+\n+/**\n+ * Represents a Remote Config template version.\n+ * Output only, except for the version description. Contains metadata about a particular\n+ * version of the Remote Config template. All fields are set at the time the specified Remote\n+ * Config template is published. A version's description field may be specified when\n+ * publishing a template.\n+ */\n+public final class Version {\n+\n+  private final String versionNumber;\n+  private final long updateTime;\n+  private final String updateOrigin;\n+  private final String updateType;\n+  private final User updateUser;\n+  private final String rollbackSource;\n+  private final boolean legacy;\n+  private String description;\n+\n+  private Version() {\n+    this.versionNumber = null;\n+    this.updateTime = 0L;\n+    this.updateOrigin = null;\n+    this.updateType = null;\n+    this.updateUser = null;\n+    this.rollbackSource = null;\n+    this.legacy = false;\n+  }\n+\n+  Version(@NonNull VersionResponse versionResponse) {\n+    checkNotNull(versionResponse);\n+    this.versionNumber = versionResponse.getVersionNumber();\n+\n+    if (!Strings.isNullOrEmpty(versionResponse.getUpdateTime())) {\n+      try {\n+        this.updateTime = RemoteConfigUtil.convertToMilliseconds(versionResponse.getUpdateTime());\n+      } catch (ParseException e) {\n+        throw new IllegalStateException(\"Unable to parse update time.\", e);\n+      }\n+    } else {\n+      this.updateTime = 0L;\n+    }\n+\n+    this.updateOrigin = versionResponse.getUpdateOrigin();\n+    this.updateType = versionResponse.getUpdateType();\n+    TemplateResponse.UserResponse userResponse = versionResponse.getUpdateUser();\n+    this.updateUser = (userResponse != null) ? new User(userResponse) : null;\n+    this.description = versionResponse.getDescription();\n+    this.rollbackSource = versionResponse.getRollbackSource();\n+    this.legacy = versionResponse.isLegacy();\n+  }\n+\n+  /**\n+   * Creates a new {@link Version} with a description.\n+   */\n+  public static Version withDescription(String description) {\n+    return new Version().setDescription(description);\n+  }\n+\n+  /**\n+   * Gets the version number of the template.\n+   *\n+   * @return The version number or null.\n+   */\n+  @Nullable\n+  public String getVersionNumber() {\n+    return versionNumber;\n+  }\n+\n+  /**\n+   * Gets the update time of the version. The timestamp of when this version of the Remote Config\n+   * template was written to the Remote Config backend.\n+   *\n+   * @return The update time of the version or null.\n+   */\n+  @Nullable\n+  public long getUpdateTime() {\n+    return updateTime;\n+  }\n+\n+  /**\n+   * Gets the origin of the template update action.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2Njc0Ng==", "bodyText": "I'm not 100% clear here.  Are the number and the source the same thing?  Or does this actually get the version from which this version was rolled back?", "url": "https://github.com/firebase/firebase-admin-java/pull/502#discussion_r541266746", "createdAt": "2020-12-11T20:41:10Z", "author": {"login": "egilmorez"}, "path": "src/main/java/com/google/firebase/remoteconfig/Version.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.remoteconfig;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.Strings;\n+import com.google.firebase.internal.NonNull;\n+import com.google.firebase.internal.Nullable;\n+import com.google.firebase.remoteconfig.internal.TemplateResponse;\n+import com.google.firebase.remoteconfig.internal.TemplateResponse.VersionResponse;\n+\n+import java.text.ParseException;\n+import java.util.Objects;\n+\n+/**\n+ * Represents a Remote Config template version.\n+ * Output only, except for the version description. Contains metadata about a particular\n+ * version of the Remote Config template. All fields are set at the time the specified Remote\n+ * Config template is published. A version's description field may be specified when\n+ * publishing a template.\n+ */\n+public final class Version {\n+\n+  private final String versionNumber;\n+  private final long updateTime;\n+  private final String updateOrigin;\n+  private final String updateType;\n+  private final User updateUser;\n+  private final String rollbackSource;\n+  private final boolean legacy;\n+  private String description;\n+\n+  private Version() {\n+    this.versionNumber = null;\n+    this.updateTime = 0L;\n+    this.updateOrigin = null;\n+    this.updateType = null;\n+    this.updateUser = null;\n+    this.rollbackSource = null;\n+    this.legacy = false;\n+  }\n+\n+  Version(@NonNull VersionResponse versionResponse) {\n+    checkNotNull(versionResponse);\n+    this.versionNumber = versionResponse.getVersionNumber();\n+\n+    if (!Strings.isNullOrEmpty(versionResponse.getUpdateTime())) {\n+      try {\n+        this.updateTime = RemoteConfigUtil.convertToMilliseconds(versionResponse.getUpdateTime());\n+      } catch (ParseException e) {\n+        throw new IllegalStateException(\"Unable to parse update time.\", e);\n+      }\n+    } else {\n+      this.updateTime = 0L;\n+    }\n+\n+    this.updateOrigin = versionResponse.getUpdateOrigin();\n+    this.updateType = versionResponse.getUpdateType();\n+    TemplateResponse.UserResponse userResponse = versionResponse.getUpdateUser();\n+    this.updateUser = (userResponse != null) ? new User(userResponse) : null;\n+    this.description = versionResponse.getDescription();\n+    this.rollbackSource = versionResponse.getRollbackSource();\n+    this.legacy = versionResponse.isLegacy();\n+  }\n+\n+  /**\n+   * Creates a new {@link Version} with a description.\n+   */\n+  public static Version withDescription(String description) {\n+    return new Version().setDescription(description);\n+  }\n+\n+  /**\n+   * Gets the version number of the template.\n+   *\n+   * @return The version number or null.\n+   */\n+  @Nullable\n+  public String getVersionNumber() {\n+    return versionNumber;\n+  }\n+\n+  /**\n+   * Gets the update time of the version. The timestamp of when this version of the Remote Config\n+   * template was written to the Remote Config backend.\n+   *\n+   * @return The update time of the version or null.\n+   */\n+  @Nullable\n+  public long getUpdateTime() {\n+    return updateTime;\n+  }\n+\n+  /**\n+   * Gets the origin of the template update action.\n+   *\n+   * @return The origin of the template update action or null.\n+   */\n+  @Nullable\n+  public String getUpdateOrigin() {\n+    return updateOrigin;\n+  }\n+\n+  /**\n+   * Gets the type of the template update action.\n+   *\n+   * @return The type of the template update action or null.\n+   */\n+  @Nullable\n+  public String getUpdateType() {\n+    return updateType;\n+  }\n+\n+  /**\n+   * Gets the update user of the template.\n+   * An aggregation of all metadata fields about the account that performed the update.\n+   *\n+   * @return The update user of the template or null.\n+   */\n+  @Nullable\n+  public User getUpdateUser() {\n+    return updateUser;\n+  }\n+\n+  /**\n+   * Gets the user-provided description of the corresponding Remote Config template.\n+   *\n+   * @return The description of the template or null.\n+   */\n+  @Nullable\n+  public String getDescription() {\n+    return description;\n+  }\n+\n+  /**\n+   * Gets the rollback source of the template.\n+   *\n+   * <p>The version number of the Remote Config template that has become the current version", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03b9f3d63c90222932ebff6df70d30ca9f802c59"}, "originalPosition": 153}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2557d615e2e60c5d507384a7bc3cfbc8f53e0256", "author": {"user": {"login": "lahirumaramba", "name": "Lahiru Maramba"}}, "url": "https://github.com/firebase/firebase-admin-java/commit/2557d615e2e60c5d507384a7bc3cfbc8f53e0256", "committedDate": "2020-12-13T23:10:46Z", "message": "Fix documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxODA5MjMz", "url": "https://github.com/firebase/firebase-admin-java/pull/502#pullrequestreview-551809233", "createdAt": "2020-12-14T19:09:49Z", "commit": {"oid": "2557d615e2e60c5d507384a7bc3cfbc8f53e0256"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2796, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}