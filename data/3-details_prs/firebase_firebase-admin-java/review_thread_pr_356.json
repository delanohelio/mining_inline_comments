{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MjAyMTg2", "number": 356, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMTo0MDo0M1rODeMZ9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMTo0MDo0M1rODeMZ9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTg3MTI0OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/google/firebase/internal/TestApiClientUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMTo0MDo0M1rOFnOffQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMTo0MDo0M1rOFnOffQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3NjIyMQ==", "bodyText": "At first I kind of want to say we should bake this assertion into the API infrastructure itself instead of directly verifying in a unit test that no one touched the code. But then the OO design I came up with to facilitate this turns out to be impossible due to various classes being final. I was hoping that we can write a subclass of HttpRequest called RetryingHttpRequest that declares at compile time that getUnsuccessfulResponseHandler will return RetryHandlerDecorator or a suitable base class, but alas, HttpRequest is final. (And so is HttpRequestFactory, which is the other class I wanted to subclass.)\nWithout the above OO structure, the only other way to structure the test to be more behavioural would be to treat the retrying mechanism completely like a black box, and empirically measure retry intervals and retry counts after forcing an unsuccessful response. This is going to be painfully flaky, so I think what you have is probably for the best.", "url": "https://github.com/firebase/firebase-admin-java/pull/356#discussion_r376676221", "createdAt": "2020-02-08T01:40:43Z", "author": {"login": "weixifan"}, "path": "src/test/java/com/google/firebase/internal/TestApiClientUtils.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.firebase.internal;\n+\n+import static com.google.firebase.internal.ApiClientUtils.DEFAULT_RETRY_CONFIG;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpRequest;\n+import com.google.api.client.http.HttpRequestFactory;\n+import com.google.api.client.http.HttpUnsuccessfulResponseHandler;\n+import com.google.api.client.testing.util.MockSleeper;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.internal.RetryInitializer.RetryHandlerDecorator;\n+import java.io.IOException;\n+\n+public class TestApiClientUtils {\n+\n+  private static final RetryConfig TEST_RETRY_CONFIG = RetryConfig.builder()\n+      .setMaxRetries(DEFAULT_RETRY_CONFIG.getMaxRetries())\n+      .setRetryStatusCodes(DEFAULT_RETRY_CONFIG.getRetryStatusCodes())\n+      .setMaxIntervalMillis(DEFAULT_RETRY_CONFIG.getMaxIntervalMillis())\n+      .setSleeper(new MockSleeper())\n+      .build();\n+\n+  private static final GenericUrl TEST_URL = new GenericUrl(\"https://firebase.google.com\");\n+\n+  /**\n+   * Creates a new {@code HttpRequestFactory} which provides authorization (OAuth2), timeouts and\n+   * automatic retries. Bypasses exponential backoff between consecutive retries for faster\n+   * execution during tests.\n+   *\n+   * @param app {@link FirebaseApp} from which to obtain authorization credentials.\n+   * @return A new {@code HttpRequestFactory} instance.\n+   */\n+  public static HttpRequestFactory delayBypassedRequestFactory(FirebaseApp app) {\n+    return ApiClientUtils.newAuthorizedRequestFactory(app, TEST_RETRY_CONFIG);\n+  }\n+\n+  /**\n+   * Creates a new {@code HttpRequestFactory} which provides authorization (OAuth2), timeouts but\n+   * no retries.\n+   *\n+   * @param app {@link FirebaseApp} from which to obtain authorization credentials.\n+   * @return A new {@code HttpRequestFactory} instance.\n+   */\n+  public static HttpRequestFactory retryDisabledRequestFactory(FirebaseApp app) {\n+    return ApiClientUtils.newAuthorizedRequestFactory(app, null);\n+  }\n+\n+  /**\n+   * Checks whther the given HttpRequestFactory has been configured for authorization and\n+   * automatic retries.\n+   *\n+   * @param requestFactory The HttpRequestFactory to check.\n+   */\n+  public static void assertAuthAndRetrySupport(HttpRequestFactory requestFactory) {\n+    assertTrue(requestFactory.getInitializer() instanceof FirebaseRequestInitializer);\n+    HttpRequest request;\n+    try {\n+      request = requestFactory.buildGetRequest(TEST_URL);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Failed to initialize request\", e);\n+    }\n+\n+    // Verify authorization\n+    assertTrue(request.getHeaders().getAuthorization().startsWith(\"Bearer \"));\n+\n+    // Verify retry support\n+    HttpUnsuccessfulResponseHandler retryHandler = request.getUnsuccessfulResponseHandler();\n+    assertTrue(retryHandler instanceof RetryHandlerDecorator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "666fa3cbd1412bfd0b4e3395433d72cbd49b2841"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1511, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}