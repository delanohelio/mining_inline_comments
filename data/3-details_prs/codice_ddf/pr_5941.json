{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzODI0NTg3", "number": 5941, "title": "[2.20.x] DDF-5940 - Add anyText expansion whitelist / blacklist capability", "bodyText": "What does this PR do?\nAdds the ability to provide a whitelist or blacklist for text fields that are included in an anyText query.\nWho is reviewing it?\n@bdeining\n@pklinef\nSelect relevant component teams:\n@codice/solr\nAsk 2 committers to review/merge the PR and tag them here.\n@andrewkfiedler\n@jlcsmith\nHow should this be tested?\n\nBuild and do a standard profile install\nIngest some data\nPerform an anyText query that will find the data\nIn the admin console, select the Solr Catalog application\nEdit the Solr Catalog Provider configuration\nAdd new whitelist or blacklist entries\n\n\nentries can be the field name as seen by DDF OR Solr (i.e. id or id_txt)\nentries can be regular expressions (i.e. to ignore all security fields use security.*)\n\n\nIn the admin console, select the Catalog application and choose Configuration\nEdit the Solr Cache Provider configuration\nAdd the same configuration here as in the Solr Catalog Provider configuration.  This configures the cache the same as the catalog.  Alternatively, you could disable the cache instead of doing this step.\nUsing the whitelist / blacklist capability to eliminate / restrict fields, perform a new query that would only hit against a removed field and verify that the result is no longer returned.\nModify the whitelist / blacklist configurations to allow that field in the anyText expansion, perform the same search again and verify that it now shows up again.\n\nA simple example to prove it works is to do a search for Adler32.  This will return all ingested records because the ingest checksum uses the Adler32 algorithm.  Then add a blacklist entry for checksum-algorithm and perform the search again.  No results will show up unless your data also has Adler somewhere else in the data.\nAny background context you want to provide?\nWhat are the relevant tickets?\nFixes: #5940\nScreenshots\n\nChecklist:\n\n Documentation Updated\n Update / Add Threat Dragon models\n Update / Add Unit Tests\n Update / Add Integration Tests\n\nNotes on Review Process\nPlease see Notes on Review Process for further guidance on requirements for merging and abbreviated reviews.\nReview Comment Legend:\n\n\u270f\ufe0f (Pencil) This comment is a nitpick or style suggestion, no action required for approval. This comment should provide a suggestion either as an in line code snippet or a gist.\n\u2753 (Question Mark) This comment is to gain a clearer understanding of design or code choices, clarification is required but action may not be necessary for approval.\n\u2757 (Exclamation Mark) This comment is critical and requires clarification or action before approval.", "createdAt": "2020-03-25T20:58:35Z", "url": "https://github.com/codice/ddf/pull/5941", "merged": true, "mergeCommit": {"oid": "a77256f26471b1de3b078da579fd73738ef81508"}, "closed": true, "closedAt": "2020-03-26T21:47:13Z", "author": {"login": "derekwilhelm"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRIbNGgH2gAyMzkzODI0NTg3OjhjMWMzMTQwOGVjNzAwMjkzMzhlZTg0YjZhMzA5MjI5MmVkZTg4ODQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRe3MbAH2gAyMzkzODI0NTg3OmVhYWMyNTA0MjFhYjE1YzYwNTMxMDQ3NjViMDFiOWY5YmJjMjcyODE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8c1c31408ec70029338ee84b6a3092292ede8884", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/8c1c31408ec70029338ee84b6a3092292ede8884", "committedDate": "2020-03-25T14:31:45Z", "message": "Add anyText expansion whitelist and blacklist"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7", "committedDate": "2020-03-25T19:37:38Z", "message": "Add whitelist/blacklist configuration to cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNTQ2NzE2", "url": "https://github.com/codice/ddf/pull/5941#pullrequestreview-381546716", "createdAt": "2020-03-25T21:22:36Z", "commit": {"oid": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToyMjozNlrOF7u3GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToyMjozNlrOF7u3GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw==", "bodyText": "I would suggest updating this to allow a blacklist and a whitelist at the same time.  A common strategy for this is have the whitelist take precedence.  Then admins could filter out entire namespaces while letting a few parts of the namespace through the filter.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private void filterAnyTextFieldCache() {\n          \n          \n            \n                Set<String> filteredList = new HashSet<>();\n          \n          \n            \n            \n          \n          \n            \n                ConfigurationStore config = ConfigurationStore.getInstance();\n          \n          \n            \n                List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n          \n          \n            \n                List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n          \n          \n            \n                if (!anyTextFieldWhitelist.isEmpty()) {\n          \n          \n            \n                  for (String whitelistField : anyTextFieldWhitelist) {\n          \n          \n            \n                    String whitelist;\n          \n          \n            \n                    if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      whitelist = whitelistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.addAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(whitelist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } else if (!anyTextFieldBlacklist.isEmpty()) {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                  for (String blacklistField : anyTextFieldBlacklist) {\n          \n          \n            \n                    String blacklist;\n          \n          \n            \n                    if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      blacklist = blacklistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.removeAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(blacklist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } else {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                }\n          \n          \n            \n              private void filterAnyTextFieldCache() {\n          \n          \n            \n                Set<String> filteredList = new HashSet<>();\n          \n          \n            \n            \n          \n          \n            \n                ConfigurationStore config = ConfigurationStore.getInstance();\n          \n          \n            \n                List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n          \n          \n            \n                List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n          \n          \n            \n                \n          \n          \n            \n                if (!anyTextFieldBlacklist.isEmpty()) {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                  for (String blacklistField : anyTextFieldBlacklist) {\n          \n          \n            \n                    String blacklist;\n          \n          \n            \n                    if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      blacklist = blacklistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.removeAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(blacklist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } \n          \n          \n            \n                if (!anyTextFieldWhitelist.isEmpty()) {\n          \n          \n            \n                  for (String whitelistField : anyTextFieldWhitelist) {\n          \n          \n            \n                    String whitelist;\n          \n          \n            \n                    if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      whitelist = whitelistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.addAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(whitelist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } \n          \n          \n            \n                \n          \n          \n            \n                if (anyTextFieldWhitelist.isEmpty() && anyTextFieldBlacklist.isEmpty()) {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                }", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398178073", "createdAt": "2020-03-25T21:22:36Z", "author": {"login": "andrewkfiedler"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,123 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {\n+    Set<String> filteredList = new HashSet<>();\n+\n+    ConfigurationStore config = ConfigurationStore.getInstance();\n+    List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n+    List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n+    if (!anyTextFieldWhitelist.isEmpty()) {\n+      for (String whitelistField : anyTextFieldWhitelist) {\n+        String whitelist;\n+        if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          whitelist = whitelistField;\n+        }\n+        filteredList.addAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(whitelist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else if (!anyTextFieldBlacklist.isEmpty()) {\n+      filteredList.addAll(anyTextFieldsCache);\n+      for (String blacklistField : anyTextFieldBlacklist) {\n+        String blacklist;\n+        if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          blacklist = blacklistField;\n+        }\n+        filteredList.removeAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(blacklist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else {\n+      filteredList.addAll(anyTextFieldsCache);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNTU3MTYw", "url": "https://github.com/codice/ddf/pull/5941#pullrequestreview-381557160", "createdAt": "2020-03-25T21:40:21Z", "commit": {"oid": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0281f9c3e17201dfa9a40fb245a2df45489d761", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/e0281f9c3e17201dfa9a40fb245a2df45489d761", "committedDate": "2020-03-25T23:57:56Z", "message": "Allow both blacklist and whitelist at the same time"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMTIzMzY2", "url": "https://github.com/codice/ddf/pull/5941#pullrequestreview-382123366", "createdAt": "2020-03-26T15:26:31Z", "commit": {"oid": "e0281f9c3e17201dfa9a40fb245a2df45489d761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNToyNjozMVrOF8MaqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNToyNjozMVrOF8MaqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MjMxMg==", "bodyText": "\u270f\ufe0f Ideally this ConfigurationStore would only have configuration as its responsibility.  I would recommend extracting the anyText field cache related fields, methods, and logic to a new class.", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398662312", "createdAt": "2020-03-26T15:26:31Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,127 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0281f9c3e17201dfa9a40fb245a2df45489d761"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eaac250421ab15c6053104765b01b9f9bbc27281", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/eaac250421ab15c6053104765b01b9f9bbc27281", "committedDate": "2020-03-26T16:40:14Z", "message": "Update unit tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4862, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}