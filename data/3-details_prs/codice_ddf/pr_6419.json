{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5NDYzNjIw", "number": 6419, "title": "[2.26.x] DDF-4729 adds WFS 1.1.0 sorting", "bodyText": "What does this PR do?\nPorts & refactors the WFS 2.0 sorting functionality into the WFS 1.1.0 source. Adds flag to enable/disable sorting (default to disable).  Adds mapping of DDF sort attributes to WFS attributes.\nWho is reviewing it?\n@millerw8\n@jrnorth\n@glenhein\n@derekwilhelm\nSelect relevant component teams:\n@codice/data\nAsk 2 committers to review/merge the PR and tag them here.\n@jrnorth\n@emmberk\nHow should this be tested?\n\nbuild / install DDF\nbuild DDF UI master (update ddf.version to 2.26.1-SNAPSHOT)\ninstall DDF UI features into DDF per the README https://github.com/codice/ddf-ui/blob/master/README.md\nVerify Intrigue UI is accessible\nstart up GeoServer\nconfigure a Metacard to WFS Feature Map\n\nFeature type = {http://www.openplans.org/topp}states\nMetacard title to feature property mapping = STATE_NAME\n\nSave the config\n7) configure a new WFS v1.1.0 Federated Source\nWFS URL = http://<host>:<port>/geoserver/ows\nForced Feature Type = states\ndisable sorting true (should be default)\n\nSave the config\n8) From Intrigue, execute an anyText contains * search with sorting by \u201ctitle\u201d A-Z, source = WFS.  Verify the WFS results are returned.  Note, the results will not be sorted (as expected)\n9) Update the WFS 1.1.0 Federated Source configuration and ENABLE sorting\n10) repeat the same query.  The results should now be sorted by state name (Alabama, Arizona, etc).\n11) verify paging works as expected and the results are still sorted\n12) change the query to sort by \u201ccreated\u201d timestamp\n13) Verify no results are returned (expected) and the heartbeat indicates a warning.  Tooltip will say \u201cSomething went wrong searching this source\u201d.\nAny background context you want to provide?\nWhat are the relevant tickets?\nFixes: #4729\nScreenshots\n\nChecklist:\n\n Documentation Updated\n Update / Add Threat Dragon models\n Update / Add Unit Tests\n Update / Add Integration Tests\n\nNotes on Review Process\nPlease see Notes on Review Process for further guidance on requirements for merging and abbreviated reviews.\nReview Comment Legend:\n\n\u270f\ufe0f (Pencil) This comment is a nitpick or style suggestion, no action required for approval. This comment should provide a suggestion either as an in line code snippet or a gist.\n\u2753 (Question Mark) This comment is to gain a clearer understanding of design or code choices, clarification is required but action may not be necessary for approval.\n\u2757 (Exclamation Mark) This comment is critical and requires clarification or action before approval.", "createdAt": "2020-11-11T21:34:45Z", "url": "https://github.com/codice/ddf/pull/6419", "merged": true, "mergeCommit": {"oid": "674450d9a6a4d5500e60d9beb6e76a7676169017"}, "closed": true, "closedAt": "2020-11-13T03:23:17Z", "author": {"login": "jlcsmith"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdbk8pegFqTUyODU1MjAyOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdb5B3YgBqjM5OTA2NTM4Nzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTUyMDI4", "url": "https://github.com/codice/ddf/pull/6419#pullrequestreview-528552028", "createdAt": "2020-11-11T21:36:00Z", "commit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozNjowMVrOHxfJEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozNjowMVrOHxfJEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1MjQ5Nw==", "bodyText": "Note: I thought it most appropriate to fail the query if the sort property can't be mapped.  GeoServer fails any query with a SortBy property that it doesn't know about.", "url": "https://github.com/codice/ddf/pull/6419#discussion_r521652497", "createdAt": "2020-11-11T21:36:01Z", "author": {"login": "jlcsmith"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -763,6 +775,30 @@ private GetFeatureType buildGetFeatureRequest(\n           if (areAnyFiltersSet(filter)) {\n             wfsQuery.setFilter(filter);\n           }\n+          if (!this.disableSorting) {\n+            if (query.getSortBy() != null) {\n+              SortByType sortByType = buildSortBy(filterDelegateEntry.getKey(), query.getSortBy());\n+              if (sortByType != null\n+                  && sortByType.getSortProperty() != null\n+                  && sortByType.getSortProperty().size() > 0) {\n+                LOGGER.debug(\n+                    \"Sorting using sort property [{}] and sort order [{}].\",\n+                    sortByType.getSortProperty().get(0).getPropertyName(),\n+                    sortByType.getSortProperty().get(0).getSortOrder());\n+                wfsQuery.setSortBy(sortByType);\n+              } else {\n+                throw new UnsupportedQueryException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTUzNzg4", "url": "https://github.com/codice/ddf/pull/6419#pullrequestreview-528553788", "createdAt": "2020-11-11T21:38:39Z", "commit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozODo0MFrOHxfO_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozODo0MFrOHxfO_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDAxMw==", "bodyText": "this was a small improvement I wanted to slip into this PR.  Empty string values shouldn't be considered invalid in a query.", "url": "https://github.com/codice/ddf/pull/6419#discussion_r521654013", "createdAt": "2020-11-11T21:38:40Z", "author": {"login": "jlcsmith"}, "path": "catalog/spatial/wfs/2.0.0/spatial-wfs-v2_0_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v2_0_0/catalog/source/WfsFilterDelegate.java", "diffHunk": "@@ -1172,9 +1172,7 @@ private TimeInstantType createTimeInstantType(String type, String date) {\n   }\n \n   private boolean isValidInputParameters(String propertyName, Object literal) {\n-    if (literal == null\n-        || StringUtils.isEmpty(propertyName)\n-        || StringUtils.isEmpty(literal.toString())) {\n+    if (literal == null || StringUtils.isEmpty(propertyName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTU0MDcx", "url": "https://github.com/codice/ddf/pull/6419#pullrequestreview-528554071", "createdAt": "2020-11-11T21:39:06Z", "commit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozOTowNlrOHxfQEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMTozOTowNlrOHxfQEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDI5MQ==", "bodyText": "this was a small improvement I wanted to slip into this PR. Empty string values shouldn't be considered invalid in a query.", "url": "https://github.com/codice/ddf/pull/6419#discussion_r521654291", "createdAt": "2020-11-11T21:39:06Z", "author": {"login": "jlcsmith"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsFilterDelegate.java", "diffHunk": "@@ -764,9 +764,7 @@ private FeatureIdType createFeatureIdFilter(final String id) {\n   }\n \n   private boolean isValidInputParameters(String propertyName, Object literal) {\n-    return !(literal == null\n-        || StringUtils.isEmpty(propertyName)\n-        || StringUtils.isEmpty(literal.toString()));\n+    return !(literal == null || StringUtils.isEmpty(propertyName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MzEzMjE5", "url": "https://github.com/codice/ddf/pull/6419#pullrequestreview-529313219", "createdAt": "2020-11-12T17:19:28Z", "commit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MjYwMTA3", "url": "https://github.com/codice/ddf/pull/6419#pullrequestreview-529260107", "createdAt": "2020-11-12T16:24:08Z", "commit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjoyNDowOFrOHyC0Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNzoxOTo1MVrOHyFVmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzNzAwMg==", "bodyText": "\u2753 How common is it for a WFS server to not support sorting? Since we're recommending unchecking this where possible, I wonder if it should default to false.", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522237002", "createdAt": "2020-11-12T16:24:08Z", "author": {"login": "SmithJosh"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/resources/OSGI-INF/metatype/metatype.xml", "diffHunk": "@@ -88,6 +88,9 @@\n           name=\"Single-Character Wildcard Character\" id=\"singleChar\" required=\"false\" type=\"Char\" default=\"?\"/>\n         <AD description=\"Escape character to use in PropertyIsLike filters.\"\n           name=\"Escape Character\" id=\"escapeChar\" required=\"false\" type=\"Char\" default=\"\\\\\"/>\n+        <AD description=\"When selected, the system will not specify sort criteria with the query.  This should only be used if the remote source is unable to handle sorting.\"\n+            name=\"Disable Sorting\" id=\"disableSorting\" required=\"true\"\n+            type=\"Boolean\" default=\"true\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI3ODI5OA==", "bodyText": "\u270f\ufe0f Suggestion: wrap these lines in a LOGGER.isDebugEnabled check", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522278298", "createdAt": "2020-11-12T17:19:51Z", "author": {"login": "SmithJosh"}, "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MzM1MDUy", "url": "https://github.com/codice/ddf/pull/6419#pullrequestreview-529335052", "createdAt": "2020-11-12T17:42:37Z", "commit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MzI4MTk5", "url": "https://github.com/codice/ddf/pull/6419#pullrequestreview-529328199", "createdAt": "2020-11-12T17:35:03Z", "commit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "state": "APPROVED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNzozNTowM1rOHyGCUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODozMDowNFrOHyIMGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI4OTc0Nw==", "bodyText": "\u270f\ufe0f These two conditionals can be combined to reduce nesting:\nif (!disableSorting && query.getSortBy() != null) {", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522289747", "createdAt": "2020-11-12T17:35:03Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -763,6 +775,30 @@ private GetFeatureType buildGetFeatureRequest(\n           if (areAnyFiltersSet(filter)) {\n             wfsQuery.setFilter(filter);\n           }\n+          if (!this.disableSorting) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NDUxMA==", "bodyText": "\u270f\ufe0f I find these kinds of configurations easier to understand when they're stated in terms of whether something is enabled rather than disabled.", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522294510", "createdAt": "2020-11-12T17:41:56Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -248,6 +254,9 @@\n \n   private static final String FEATURE_MEMBER_ELEMENT = \"featureMember\";\n \n+  private static final String DISABLE_SORTING = \"disableSorting\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NzYwMw==", "bodyText": "\u270f\ufe0f Looks like this will fail checkstyle", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522297603", "createdAt": "2020-11-12T17:46:47Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -1041,18 +1114,18 @@ private String handleClientException(Exception ce) {\n \n   private void logMessage(GetFeatureType getFeature) {\n     if (LOGGER.isDebugEnabled()) {\n-      try {\n-        StringWriter writer = new StringWriter();\n-        JAXBContext contextObj = JAXBContext.newInstance(GetFeatureType.class);\n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwNjExNg==", "bodyText": "\u270f\ufe0f All three: PROPERTY instead of PROEPRTY", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522306116", "createdAt": "2020-11-12T17:59:52Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -235,6 +239,12 @@\n \n   private static final String LITERAL = \"literal\";\n \n+  private static final String MOCK_TEMPORAL_SORT_PROEPRTY = \"myTemporalSortProperty\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwODg4Mg==", "bodyText": "Don't need a captor for this test (or for any of the following tests that expect an exception).", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522308882", "createdAt": "2020-11-12T18:04:10Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxMTcyNA==", "bodyText": "distanceSortProperty", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522311724", "createdAt": "2020-11-12T18:08:55Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+    final QueryType queryType = getFeatureType.getQuery().get(0);\n+    if (sortingEnabled) {\n+      assertThat(queryType.isSetSortBy(), is(true));\n+      assertThat(queryType.getSortBy().getSortProperty().size(), is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().size(),\n+          is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().get(0),\n+          is(sortProperty));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getSortOrder().value(), is(sortOrder));\n+    } else {\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  private void setupMapper(\n+      String temporalSortProperty, String relevanceSortProperty, String distanceSortProperty) {\n+    final MetacardMapperImpl metacardMapper = new MetacardMapperImpl();\n+    metacardMapper.setSortByTemporalFeatureProperty(temporalSortProperty);\n+    metacardMapper.setSortByDistanceFeatureProperty(relevanceSortProperty);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxMTgzMg==", "bodyText": "relevanceSortProperty", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522311832", "createdAt": "2020-11-12T18:09:07Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+    final QueryType queryType = getFeatureType.getQuery().get(0);\n+    if (sortingEnabled) {\n+      assertThat(queryType.isSetSortBy(), is(true));\n+      assertThat(queryType.getSortBy().getSortProperty().size(), is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().size(),\n+          is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().get(0),\n+          is(sortProperty));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getSortOrder().value(), is(sortOrder));\n+    } else {\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  private void setupMapper(\n+      String temporalSortProperty, String relevanceSortProperty, String distanceSortProperty) {\n+    final MetacardMapperImpl metacardMapper = new MetacardMapperImpl();\n+    metacardMapper.setSortByTemporalFeatureProperty(temporalSortProperty);\n+    metacardMapper.setSortByDistanceFeatureProperty(relevanceSortProperty);\n+    metacardMapper.setSortByRelevanceFeatureProperty(distanceSortProperty);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNDQ4MA==", "bodyText": "\u270f\ufe0f Assertions on collection size should use the hasSize() matcher for more useful messages when the test fails.", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522314480", "createdAt": "2020-11-12T18:12:57Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNTk1Mw==", "bodyText": "Consider adding a unit test for this change.", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522315953", "createdAt": "2020-11-12T18:15:19Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsFilterDelegate.java", "diffHunk": "@@ -764,9 +764,7 @@ private FeatureIdType createFeatureIdFilter(final String id) {\n   }\n \n   private boolean isValidInputParameters(String propertyName, Object literal) {\n-    return !(literal == null\n-        || StringUtils.isEmpty(propertyName)\n-        || StringUtils.isEmpty(literal.toString()));\n+    return !(literal == null || StringUtils.isEmpty(propertyName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDI5MQ=="}, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNzYyMQ==", "bodyText": "\u270f\ufe0f proeprty -> property", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522317621", "createdAt": "2020-11-12T18:18:05Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });\n+    LOGGER.debug(\n+        \"Mapping sort proeprty: featureType {}, incomingPropertyName {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyMjQ0NQ==", "bodyText": "\u270f\ufe0f Looks like a switch statement would be appropriate here.", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522322445", "createdAt": "2020-11-12T18:25:51Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });\n+    LOGGER.debug(\n+        \"Mapping sort proeprty: featureType {}, incomingPropertyName {}\",\n+        featureType,\n+        incomingPropertyName);\n+    MetacardMapper metacardToFeaturePropertyMapper =\n+        lookupMetacardAttributeToFeaturePropertyMapper(featureType, metacardMapperList);\n+    String mappedPropertyName = null;\n+\n+    if (metacardToFeaturePropertyMapper != null) {\n+\n+      if (org.apache.commons.lang.StringUtils.equals(Result.TEMPORAL, incomingPropertyName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyMzc0MQ==", "bodyText": "\u270f\ufe0f mappedPropertyName = StringUtils.defaultIfBlank(metacardToFeaturePropertyMapper.getSortByTemporalFeatureProperty(), null);", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522323741", "createdAt": "2020-11-12T18:27:55Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });\n+    LOGGER.debug(\n+        \"Mapping sort proeprty: featureType {}, incomingPropertyName {}\",\n+        featureType,\n+        incomingPropertyName);\n+    MetacardMapper metacardToFeaturePropertyMapper =\n+        lookupMetacardAttributeToFeaturePropertyMapper(featureType, metacardMapperList);\n+    String mappedPropertyName = null;\n+\n+    if (metacardToFeaturePropertyMapper != null) {\n+\n+      if (org.apache.commons.lang.StringUtils.equals(Result.TEMPORAL, incomingPropertyName)\n+          || org.apache.commons.lang.StringUtils.equals(Metacard.EFFECTIVE, incomingPropertyName)) {\n+        mappedPropertyName =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNTAxNg==", "bodyText": "\u270f\ufe0f Same here. PROEPRTY -> PROPERTY", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522325016", "createdAt": "2020-11-12T18:30:04Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/spatial-wfs-common/src/test/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSourceTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package org.codice.ddf.spatial.ogc.wfs.catalog.common;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+\n+import ddf.catalog.data.ContentType;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.Result;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResourceResponse;\n+import ddf.catalog.operation.SourceResponse;\n+import ddf.catalog.resource.ResourceNotFoundException;\n+import ddf.catalog.resource.ResourceNotSupportedException;\n+import ddf.catalog.source.SourceMonitor;\n+import ddf.catalog.source.UnsupportedQueryException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.xml.namespace.QName;\n+import org.codice.ddf.spatial.ogc.wfs.catalog.mapper.MetacardMapper;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class AbstractWfsSourceTest {\n+  private AbstractWfsSource wfsSource;\n+  private static final String FEATURE_NAME = \"SampleFeature\";\n+  private static final String TEMPORAL_SORT_PROEPRTY = \"myTemporalSortProperty\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e56893db8e5fef87e92e61713c755dc02de99d"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4687ff34cf27dbbcb6d8ff36f62bc42cd27155f7", "author": {"user": {"login": "jlcsmith", "name": "Jason Smith"}}, "url": "https://github.com/codice/ddf/commit/4687ff34cf27dbbcb6d8ff36f62bc42cd27155f7", "committedDate": "2020-11-12T20:59:34Z", "message": "DDF-4729 adds WFS 1.1.0 sorting\n\n- adds flag to enable/disable sorting\n- adds mapping of DDF sort attributes to WFS attributes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "author": {"user": {"login": "jlcsmith", "name": "Jason Smith"}}, "url": "https://github.com/codice/ddf/commit/823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "committedDate": "2020-11-12T20:59:34Z", "message": "code cleanup"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee624ed1766a70e04abbe084568f7e0ad4cfbd6e", "author": {"user": {"login": "jlcsmith", "name": "Jason Smith"}}, "url": "https://github.com/codice/ddf/commit/ee624ed1766a70e04abbe084568f7e0ad4cfbd6e", "committedDate": "2020-11-12T20:59:02Z", "message": "code cleanup"}, "afterCommit": {"oid": "823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "author": {"user": {"login": "jlcsmith", "name": "Jason Smith"}}, "url": "https://github.com/codice/ddf/commit/823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "committedDate": "2020-11-12T20:59:34Z", "message": "code cleanup"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 807, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}