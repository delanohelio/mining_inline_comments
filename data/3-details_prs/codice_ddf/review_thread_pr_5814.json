{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMTE2MTE2", "number": 5814, "reviewThreads": {"totalCount": 64, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0MToxNVrODdZtXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxNToxMFrODi0W2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTU2NTA5OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0MToxNVrOFl-7XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0MToxNVrOFl-7XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3MjYzNw==", "bodyText": "The testValidity logic could be moved to a validateLineAndPolygon function in validation.js and this call could be replaced with validateGeo(mode, currentValue)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375372637", "createdAt": "2020-02-05T16:41:15Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,142 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateListOfPoints,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n-  }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n-  }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n-          <TextField\n-            label={label}\n-            value={this.state.value}\n-            onChange={value => {\n-              value = value.trim()\n-              if (value.includes('MULTI')) {\n-                value = this.convertMultiWkt(value.includes('POLYGON'), value)\n-              } else if (value.includes('POLYGON') && value.endsWith('))')) {\n-                value = this.convertWkt(value, 4)\n-              } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n-                value = this.convertWkt(value, 2)\n-              }\n-              this.setState({ value })\n-              const fn = cursor(geometryKey)\n-              try {\n-                fn(JSON.parse(value))\n-              } catch (e) {\n-                // do nothing\n-              }\n-            }}\n-            onBlur={() => this.isValidInput(this.state.value)}\n-            onFocus={value => {\n-              this.setState({ isValid: true })\n-            }}\n-          />\n-          <Units value={props[unitKey]} onChange={cursor(unitKey)}>\n-            <TextField\n-              type=\"number\"\n-              label=\"Buffer width\"\n-              min={0.000001}\n-              value={`${props[widthKey]}`}\n-              onChange={cursor(widthKey)}\n-            />\n-          </Units>\n-        </div>\n-        {this.state.isValid ? (\n-          ''\n-        ) : (\n-          <Invalid>\n-            &nbsp;\n-            <span className=\"fa fa-exclamation-triangle\" />\n-            &nbsp; {this.invalidMessage} &nbsp; &nbsp;\n-            <span className=\"fa fa-times\" onClick={this.removeErrorBox} />\n-          </Invalid>\n-        )}\n-      </React.Fragment>\n-    )\n-  }\n-  removeErrorBox() {\n-    this.setState({ isValid: true })\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  isValidInput(value) {\n-    this.invalidMessage = ''\n-    this.setState({ value, isValid: this.isValidPolygon(value) })\n-  }\n-  is2DArray(coordinates) {\n-    try {\n-      const parsedCoords = JSON.parse(coordinates)\n-      return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n-    } catch (e) {\n-      return false\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  validatePoint(point) {\n-    if (\n-      point.length !== 2 ||\n-      (Number.isNaN(Number.parseFloat(point[0])) &&\n-        Number.isNaN(Number.parseFloat(point[1])))\n-    ) {\n-      return JSON.stringify(point) + ' is not a valid point.'\n-    } else if (\n-      point[0] > 180 ||\n-      point[0] < -180 ||\n-      point[1] > 90 ||\n-      point[1] < -90\n-    ) {\n-      return JSON.stringify(point) + ' is not a valid point.'\n-    }\n-    return ''\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  validateListOfPoints(coordinates) {\n-    let message = ''\n-    const isLine = this.props.mode.includes('line')\n-    let numPoints = isLine ? 2 : 4\n-    if (!this.props.mode.includes('multi')) {\n-      if (coordinates.some(coords => coords.length > 2)) {\n-        message = ''\n-      } else if (coordinates.length < numPoints) {\n-        message = `Minimum of ${numPoints} points needed for ${\n-          isLine ? 'Line' : 'Polygon'\n-        }`\n-      }\n-    }\n-    for (let i = 0; i < coordinates.length; i++) {\n-      if (coordinates[i].length > 2) {\n-        coordinates[i].forEach(coordinate => {\n-          if (this.validatePoint(coordinate)) {\n-            message = this.validatePoint(coordinate)\n-          }\n-        })\n-      } else {\n-        if (this.props.mode.includes('multi')) {\n-          message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n-        } else if (this.validatePoint(coordinates[i])) {\n-          message = this.validatePoint(coordinates[i])\n-        }\n-      }\n-    }\n-    if (message !== '') {\n-      this.invalidMessage = message\n-      throw 'Invalid coordinates.'\n-    }\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+function is2DArray(coordinates) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n   }\n-  isValidPolygon(coordinates) {\n-    if (!this.is2DArray(coordinates)) {\n-      this.invalidMessage = 'Not an acceptable value.'\n-      return false\n+}\n+\n+const BaseLine = props => {\n+  const { label, geometryKey, setState, unitKey, widthKey, mode } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey } = props\n+      setCurrentValue(JSON.stringify(props[geometryKey]))\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  function testValidity() {\n+    if (!is2DArray(currentValue)) {\n+      return { error: true, message: 'Not an acceptable value' }\n     }\n     try {\n-      this.validateListOfPoints(JSON.parse(coordinates))\n-      return true\n+      return validateListOfPoints(JSON.parse(currentValue), mode)\n     } catch (e) {\n-      return false\n+      //do nothing\n     }\n   }\n-  convertWkt(value, numCoords) {\n-    const coordinatePairs = value.match(coordinatePairRegex)\n-    if (!coordinatePairs || coordinatePairs.length < numCoords) {\n-      return value\n-    }\n-    const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n-    return `[[${coordinates.join('],[')}]]`\n-  }\n-  convertMultiWkt(isPolygon, value) {\n-    if (isPolygon && !value.endsWith(')))')) {\n-      return value\n-    } else if (!value.endsWith('))')) {\n-      return value\n-    }\n-    const splitter = isPolygon ? '))' : ')'\n-    const numPoints = isPolygon ? 4 : 2\n-    let shapes = value\n-      .split(splitter)\n-      .map(shape => shape.match(coordinatePairRegex))\n-    shapes = shapes\n-      .filter(shape => shape !== null && shape.length >= numPoints)\n-      .map(shape =>\n-        shape.map(coordinatePair => coordinatePair.replace(' ', ','))\n-      )\n-    return shapes.length === 0\n-      ? value\n-      : shapes.length === 1\n-        ? `[[${shapes[0].join('],[')}]]`\n-        : `[${shapes.map(shapeCoords => `[[${shapeCoords.join('],[')}]]`)}]`\n-  }\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState(geometryKey, undefined)\n+              } else {\n+                setState(geometryKey, JSON.parse(value))\n+              }\n+            } catch (e) {\n+              // do nothing\n+            }\n+          }}\n+          onBlur={() => setBaseLineError(testValidity())}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f07d5c0275a2e8cbd8cb636c65b14e5ff7e8fb7a"}, "originalPosition": 300}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTU3Nzk1OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0NDo0OVrOFl_DxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0NDo0OVrOFl_DxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NDc4OQ==", "bodyText": "this and validateLatLon are functionally the same and could be combined", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375374789", "createdAt": "2020-02-05T16:44:49Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,326 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function hasPointError(point: any[]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f07d5c0275a2e8cbd8cb636c65b14e5ff7e8fb7a"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjE0OTU2OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTozOTozNVrOFmEslg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTozOTozNVrOFmEslg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NzE1OA==", "bodyText": "this and the line above are the value of isNorthingInvalid", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375467158", "createdAt": "2020-02-05T19:39:35Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,326 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateLatLon(lat: string, lon: string) {\n+  const latitude = parseFloat(lat)\n+  const longitude = parseFloat(lon)\n+  return latitude > -90 && latitude < 90 && longitude > -180 && longitude < 180\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // casting to Number() will return NaN if it's not a number, i.e. \"3e\".\n+  //Except for empty string, which is why we have to do this check below\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  // isNaN will try to parse anything into a number\n+  // have to check this because parseFloat will be able to parse things with letters, i.e. \"12.3w\"\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsEasting)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the validate lat lon method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    validateLatLon(lat, lon) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+  if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  } else if (\n+    key === 'utmUpsNorthing' &&\n+    isNaN(utmUpsParts.northing) &&\n+    utmUpsNorthing !== undefined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abcbef3c16a5cca26709b97cb0adfb4f1381545"}, "originalPosition": 316}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjE1Mjk2OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTo0MDo0M1rOFmEu0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTo0MDo0M1rOFmEu0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NzcyOA==", "bodyText": "same here with isEastingInvalid", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375467728", "createdAt": "2020-02-05T19:40:43Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,326 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateLatLon(lat: string, lon: string) {\n+  const latitude = parseFloat(lat)\n+  const longitude = parseFloat(lon)\n+  return latitude > -90 && latitude < 90 && longitude > -180 && longitude < 180\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // casting to Number() will return NaN if it's not a number, i.e. \"3e\".\n+  //Except for empty string, which is why we have to do this check below\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  // isNaN will try to parse anything into a number\n+  // have to check this because parseFloat will be able to parse things with letters, i.e. \"12.3w\"\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsEasting)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the validate lat lon method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    validateLatLon(lat, lon) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+  if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  } else if (\n+    key === 'utmUpsNorthing' &&\n+    isNaN(utmUpsParts.northing) &&\n+    utmUpsNorthing !== undefined\n+  ) {\n+    error = { error: true, message: 'Northing value is invalid' }\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    isNaN(utmUpsParts.easting) &&\n+    utmUpsEasting !== undefined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abcbef3c16a5cca26709b97cb0adfb4f1381545"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzg5MjMxOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-old.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOToyNjozM1rOFnyoAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOToyNjozM1rOFnyoAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2ODIyNw==", "bodyText": "\u270f\ufe0f investigate need to pass in this", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377268227", "createdAt": "2020-02-10T19:26:33Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-old.js", "diffHunk": "@@ -235,14 +228,14 @@ module.exports = Backbone.AssociatedModel.extend({\n       this.set('locationType', 'utmUps')\n     }\n     this.drawing = false\n-    store.get('content').turnOffDrawing()\n+    store.get('content').turnOffDrawing(this)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzg5ODQ5OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-serialization.js", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOToyODoyOFrOFnyr0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNjowMjozM1rOFo0gvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2OTIwMQ==", "bodyText": "\u270f\ufe0f verify radius should be 0 and not ''", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377269201", "createdAt": "2020-02-10T19:28:28Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-serialization.js", "diffHunk": "@@ -98,15 +98,15 @@ const Point = {\n \n     return {\n       mode: 'circle',\n-      locationType: 'latlon',\n+      locationType: 'dd',\n       lat,\n       lon,\n       radius: width,\n       radiusUnits: unit,\n     }\n   },\n   'location->json': location => {\n-    const { lat = 0, lon = 0, radius = 1, radiusUnits = 'meters' } = location\n+    const { lat = '', lon = '', radius = 0, radiusUnits = 'meters' } = location", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcwODI2Nw==", "bodyText": "on the same note, width, above, and lineWidth, up in the LineString and MultiLineString definitions in this file, are currently set to 1. I'm wondering if I need to also change these.", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377708267", "createdAt": "2020-02-11T15:29:03Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-serialization.js", "diffHunk": "@@ -98,15 +98,15 @@ const Point = {\n \n     return {\n       mode: 'circle',\n-      locationType: 'latlon',\n+      locationType: 'dd',\n       lat,\n       lon,\n       radius: width,\n       radiusUnits: unit,\n     }\n   },\n   'location->json': location => {\n-    const { lat = 0, lon = 0, radius = 1, radiusUnits = 'meters' } = location\n+    const { lat = '', lon = '', radius = 0, radiusUnits = 'meters' } = location", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2OTIwMQ=="}, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxOTcyMA==", "bodyText": "I changed it to '' here and everything seems to be fine. I'm going to wait to commit this change until after investigating what i mentioned above", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377719720", "createdAt": "2020-02-11T15:45:47Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-serialization.js", "diffHunk": "@@ -98,15 +98,15 @@ const Point = {\n \n     return {\n       mode: 'circle',\n-      locationType: 'latlon',\n+      locationType: 'dd',\n       lat,\n       lon,\n       radius: width,\n       radiusUnits: unit,\n     }\n   },\n   'location->json': location => {\n-    const { lat = 0, lon = 0, radius = 1, radiusUnits = 'meters' } = location\n+    const { lat = '', lon = '', radius = 0, radiusUnits = 'meters' } = location", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2OTIwMQ=="}, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0NzcwOQ==", "bodyText": "it seems that, from the entry point of the anyGeo search, the radius will never be undefined (it's an empty string if you don't type anything in), so this default value never gets used. Not sure what we should put here, so I'll leave this open for now", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378347709", "createdAt": "2020-02-12T16:02:33Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-serialization.js", "diffHunk": "@@ -98,15 +98,15 @@ const Point = {\n \n     return {\n       mode: 'circle',\n-      locationType: 'latlon',\n+      locationType: 'dd',\n       lat,\n       lon,\n       radius: width,\n       radiusUnits: unit,\n     }\n   },\n   'location->json': location => {\n-    const { lat = 0, lon = 0, radius = 1, radiusUnits = 'meters' } = location\n+    const { lat = '', lon = '', radius = 0, radiusUnits = 'meters' } = location", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2OTIwMQ=="}, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzkyNTk3OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/cesium.line.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTozNzoyMlrOFny9Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTozODo1NFrOFoN5MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI3MzYwNg==", "bodyText": "\u270f\ufe0f\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (!linePoints || !linePoints[0]) {\n          \n          \n            \n                if (!linePoints || linePoints[0] === undefined) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377273606", "createdAt": "2020-02-10T19:37:22Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/cesium.line.js", "diffHunk": "@@ -53,7 +53,7 @@ class LineRenderView extends GeometryRenderView {\n         json.lineWidth,\n         model.get('lineUnits')\n       ) || 1\n-    if (!linePoints) {\n+    if (!linePoints || !linePoints[0]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxNDk5Mw==", "bodyText": "and I think we discussed the same for the other cases in cesium.polygon, openlayers.line and openlayers.polygon", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377714993", "createdAt": "2020-02-11T15:38:54Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/cesium.line.js", "diffHunk": "@@ -53,7 +53,7 @@ class LineRenderView extends GeometryRenderView {\n         json.lineWidth,\n         model.get('lineUnits')\n       ) || 1\n-    if (!linePoints) {\n+    if (!linePoints || !linePoints[0]) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI3MzYwNg=="}, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzk0MDY1OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo0MjowOFrOFnzGWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo0MjowOFrOFnzGWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI3NTk5Mg==", "bodyText": "push changes to eliminate this function here", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377275992", "createdAt": "2020-02-10T19:42:08Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,128 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateLinePolygon,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzk3NTgxOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo1MzoyMFrOFnzcWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo1MzoyMFrOFnzcWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4MTYyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        typeof setBufferState === 'function' ? setBufferState(unitKey, value) : setState({ [unitKey]: value })\n          \n          \n            \n                        typeof setBufferState === 'function' ? setBufferState({ [unitKey]: value }) : setState({ [unitKey]: value })", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377281627", "createdAt": "2020-02-10T19:53:20Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,128 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateLinePolygon,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const { label, geometryKey, setState, setBufferState, unitKey, widthKey, mode, polyType } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey } = props\n+      setCurrentValue(JSON.stringify(props[geometryKey]))\n+      if(props.drawing) {\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({[geometryKey]: undefined})\n+              } else {\n+                setState({[geometryKey]: JSON.parse(value)})\n+              }\n+            } catch (e) {\n+              // do nothing\n+            }\n+          }}\n+          onBlur={() => setBaseLineError(validateLinePolygon(currentValue, mode || polyType))}\n+        />\n+        {getErrorComponent(baseLineError)}\n+        <Units\n+          value={props[unitKey]}\n+          onChange={value => {\n+            typeof setBufferState === 'function' ? setBufferState(unitKey, value) : setState({ [unitKey]: value })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzk4OTkwOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo1NzozM1rOFnzlBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo1NzozM1rOFnzlBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4Mzg0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          typeof setBufferState === 'function' ? setBufferState(widthKey, value) : setState({ [widthKey]: value })\n          \n          \n            \n                          typeof setBufferState === 'function' ? setBufferState({ [widthKey]: value }) : setState({ [widthKey]: value })", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377283844", "createdAt": "2020-02-10T19:57:33Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,128 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateLinePolygon,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const { label, geometryKey, setState, setBufferState, unitKey, widthKey, mode, polyType } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey } = props\n+      setCurrentValue(JSON.stringify(props[geometryKey]))\n+      if(props.drawing) {\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({[geometryKey]: undefined})\n+              } else {\n+                setState({[geometryKey]: JSON.parse(value)})\n+              }\n+            } catch (e) {\n+              // do nothing\n+            }\n+          }}\n+          onBlur={() => setBaseLineError(validateLinePolygon(currentValue, mode || polyType))}\n+        />\n+        {getErrorComponent(baseLineError)}\n+        <Units\n+          value={props[unitKey]}\n+          onChange={value => {\n+            typeof setBufferState === 'function' ? setBufferState(unitKey, value) : setState({ [unitKey]: value })\n+          }}\n+        >\n           <TextField\n-            label={label}\n-            value={this.state.value}\n+            type=\"number\"\n+            label=\"Buffer width\"\n+            value={String(props[widthKey])}\n             onChange={value => {\n-              value = value.trim()\n-              if (value.includes('MULTI')) {\n-                value = this.convertMultiWkt(value.includes('POLYGON'), value)\n-              } else if (value.includes('POLYGON') && value.endsWith('))')) {\n-                value = this.convertWkt(value, 4)\n-              } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n-                value = this.convertWkt(value, 2)\n-              }\n-              this.setState({ value })\n-              const fn = cursor(geometryKey)\n-              try {\n-                fn(JSON.parse(value))\n-              } catch (e) {\n-                // do nothing\n+              if (widthKey === 'lineWidth') {\n+                setBufferError(validateGeo('lineWidth', value))\n               }\n-            }}\n-            onBlur={() => this.isValidInput(this.state.value)}\n-            onFocus={value => {\n-              this.setState({ isValid: true })\n+              typeof setBufferState === 'function' ? setBufferState(widthKey, value) : setState({ [widthKey]: value })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDAwODA0OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowMzo1NlrOFnzw5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowMzo1NlrOFnzw5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4Njg4NQ==", "bodyText": "delete", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377286885", "createdAt": "2020-02-10T20:03:56Z", "author": {"login": "andrewzimmer"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +103,141 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(() => {\n+    console.log(props.drawing)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDAxMjc4OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowNTo0NVrOFnzz7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowNTo0NVrOFnzz7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4NzY2MA==", "bodyText": "\u270f\ufe0f remove", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377287660", "createdAt": "2020-02-10T20:05:45Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +103,141 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(() => {\n+    console.log(props.drawing)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDAxOTIxOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowODowMlrOFnz4Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowODowMlrOFnz4Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4ODczOQ==", "bodyText": "\u270f\ufe0f investigate converting getErrrorComponent to a functional component", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377288739", "createdAt": "2020-02-10T20:08:02Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +103,141 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(() => {\n+    console.log(props.drawing)\n+    if(props.drawing) {\n+      setDmsError(initialErrorStateWithDefault)\n+    }\n+  }, [props.dmsWest, props.dmsSouth, props.dmsEast, props.dmsNorth])\n+\n+  function validate(key, type, value) {\n+    const label =\n+      key.includes('East') || key.includes('West') ? 'dmsLon' : 'dmsLat'\n+    const { error, message, defaultValue } = validateGeo(label, value)\n+    if (type === 'blur') {\n+      setDmsError({\n+        error: value !== undefined && value.length === 0,\n+        message,\n+        defaultValue,\n+      })\n+    } else if (defaultValue) {\n+      setDmsError({\n+        error,\n+        message,\n+        defaultValue,\n+      })\n+    }\n+    defaultValue ? setState({[key]: defaultValue}) : setState({[key]: value})\n+  }\n+\n+  return (\n+    <div className=\"input-location\">\n+      <DmsLongitude\n+        label=\"West\"\n+        value={dmsWest}\n+        onChange={(value, type) => validate('dmsWest', type, value)}\n+      >\n+        <DirectionInput\n+          options={longitudeDirections}\n+          value={dmsWestDirection}\n+          onChange={value => setState({['dmsWestDirection']: value})}\n+        />\n+      </DmsLongitude>\n+      <DmsLatitude\n+        label=\"South\"\n+        value={dmsSouth}\n+        onChange={(value, type) => validate('dmsSouth', type, value)}\n+      >\n+        <DirectionInput\n+          options={latitudeDirections}\n+          value={dmsSouthDirection}\n+          onChange={value => setState({['dmsSouthDirection']: value})}\n+        />\n+      </DmsLatitude>\n+      <DmsLongitude\n+        label=\"East\"\n+        value={dmsEast}\n+        onChange={(value, type) => validate('dmsEast', type, value)}\n+      >\n+        <DirectionInput\n+          options={longitudeDirections}\n+          value={dmsEastDirection}\n+          onChange={value => setState({['dmsEastDirection']: value})}\n+        />\n+      </DmsLongitude>\n+      <DmsLatitude\n+        label=\"North\"\n+        value={dmsNorth}\n+        onChange={(value, type) => validate('dmsNorth', type, value)}\n+      >\n+        <DirectionInput\n+          options={latitudeDirections}\n+          value={dmsNorthDirection}\n+          onChange={value => setState({['dmsNorthDirection']: value})}\n+        />\n+      </DmsLatitude>\n+      {getErrorComponent(dmsError)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA0MDQ0OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/location.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoxNTozNFrOFn0Frg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoxNTozNFrOFn0Frg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5MjIwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      setBufferState={(key, value) => setState(key, value)}\n          \n          \n            \n                      setBufferState={(key, value) => setState({ [key]: value })}", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377292206", "createdAt": "2020-02-10T20:15:34Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/location.js", "diffHunk": "@@ -84,6 +55,7 @@ const inputs = plugin({\n           setState={({ value, ...data }) => {\n             setState({ keywordValue: value, ...data })\n           }}\n+          setBufferState={(key, value) => setState(key, value)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA2MTM1OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyMjoxMlrOFn0SBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyMjoxMlrOFn0SBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NTM2Ng==", "bodyText": "move function to this file?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377295366", "createdAt": "2020-02-10T20:22:12Z", "author": {"login": "andrewzimmer"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -13,8 +13,22 @@\n  *\n  **/\n \n+const React = require('react')\n import { InvalidSearchFormMessage } from '../../../component/announcement/CommonMessages'\n+import styled from 'styled-components'\n const announcement = require('../../../component/announcement/index.jsx')\n+const {\n+  validateInput,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA2Njc5OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyNDowOVrOFn0VfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyNDowOVrOFn0VfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NjI1Mg==", "bodyText": "\u270f\ufe0f rename or leave comment for significance of extra values", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377296252", "createdAt": "2020-02-10T20:24:09Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA4MDg1OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyODo0NlrOFn0eJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyODo0NlrOFn0eJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5ODQ3MQ==", "bodyText": "can just return whatever validateListOfPoints returns\nalso, \u270f\ufe0f switch order of args for validateListOfPoints for consistency's sake", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377298471", "createdAt": "2020-02-10T20:28:46Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA4NzgzOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMToxMVrOFn0ihg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMToxMVrOFn0ihg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5OTU5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      (coord: any) => !coord || coord.toString().length == 0\n          \n          \n            \n                      (coord: any) => !coord || coord.toString().length === 0", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377299590", "createdAt": "2020-02-10T20:31:11Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA5NDEyOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMzoxNlrOFn0mSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzowMDowN1rOFoRKww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMDU1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!bufferWidth || bufferWidth == 0) {\n          \n          \n            \n                  if (!bufferWidth || bufferWidth === 0) {\n          \n      \n    \n    \n  \n\nis this second check necessary though?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377300555", "createdAt": "2020-02-10T20:33:16Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2ODY0Mw==", "bodyText": "actually, didn't we talk about checking for negative values here as well @andrewzimmer @willwill96 ?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377768643", "createdAt": "2020-02-11T17:00:07Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMDU1NQ=="}, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA5NTU5OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMzo0OVrOFn0nPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMzo0OVrOFn0nPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMDc5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    errors.add('Line buffer width must be greater than 0.000001')\n          \n          \n            \n                    errors.add('Line buffer width must be greater than 0')", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377300797", "createdAt": "2020-02-10T20:33:49Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA5NzA3OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNDoxN1rOFn0oFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNDoxN1rOFn0oFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTAxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    errors.add('Radius must be greater than 0.000001')\n          \n          \n            \n                    errors.add('Radius must be greater than 0')\n          \n      \n    \n    \n  \n\nsame for inline messages", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301012", "createdAt": "2020-02-10T20:34:17Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA5Nzc1OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNDozM1rOFn0oiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNDozM1rOFn0oiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTEyOQ==", "bodyText": "\u270f\ufe0f\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      (coord: any) => !coord || coord.toString().length == 0\n          \n          \n            \n                      (coord: any) => !coord || coord.toString().length === 0", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301129", "createdAt": "2020-02-10T20:34:33Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDEwMjI3OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNjoxM1rOFn0rSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNjoxM1rOFn0rSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTgzMg==", "bodyText": "could pull filter.geojson.properties into a local variable since it's used in multiple places", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301832", "createdAt": "2020-02-10T20:36:13Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDEwMzI1OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNjozNVrOFn0r4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjowMzozM1rOFoa1Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTk4Ng==", "bodyText": "\u270f\ufe0f verify 0 is not an edge case for these guys", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301986", "createdAt": "2020-02-10T20:36:35Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNjk5MA==", "bodyText": "so, it seems like when you type a 0 into the text box, i.e., for east, then the value of east will be the string \"0\", which is truthy. When drawing, the values are numbers rather than strings. So the edge case does exist, if you managed to hit 0 exactly while drawing.\nWe want to show an error when any of these values are either empty, or undefined. so the new check would look something like\nif (box.east === undefined || box.east === '' || box.west === undefined... \nis there a better way?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377926990", "createdAt": "2020-02-11T22:03:33Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTk4Ng=="}, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDEyNDg1OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0NDowNlrOFn05jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoyNDozM1rOFoSD6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNTQ4NQ==", "bodyText": "\u270f\ufe0f I think you can use parseFloat to avoid this ternary, because that gives you NaN  for a blank string", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377305485", "createdAt": "2020-02-10T20:44:06Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4MzI3NA==", "bodyText": "We were using parseFloat originally, but that would parse numbers out of strings with a mix of numbers and invalid characters (i.e. 23$%jdkk), making those kinds of entries valid. We didn't want to allow that, so we made a regex to test for non-numeric characters. But eventually we decided this way would be cleaner, because Number('23$%jdkk') results in NaN", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377783274", "createdAt": "2020-02-11T17:24:33Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNTQ4NQ=="}, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDEyNzU0OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0NTowMFrOFn07Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0NTowMFrOFn07Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNTkwNg==", "bodyText": "\u270f\ufe0f can remove the second part of the ternary:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!bufferWidth || bufferWidth == 0) {\n          \n          \n            \n                  if (!bufferWidth) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377305906", "createdAt": "2020-02-10T20:45:00Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDEzNjExOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0Nzo1N1rOFn1AgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0Nzo1N1rOFn1AgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNzI2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                (Number.isNaN(Number.parseFloat(point[0])) &&\n          \n          \n            \n                Number.isNaN(Number.parseFloat(point[0])) ||", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377307265", "createdAt": "2020-02-10T20:47:57Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDEzOTAyOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0ODo0MFrOFn1CLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0ODo0MFrOFn1CLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNzY5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  message: label + 'cannot be less than 0.000001',\n          \n          \n            \n                  message: label + 'must be greater than 0',", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377307693", "createdAt": "2020-02-10T20:48:40Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  // These checks are to ensure that we only mark a value as \"invalid\" \n+  // if the user has entered something already\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+   if (\n+    key === 'utmUpsNorthing' &&\n+    isNorthingInvalid && !isEastingInvalid\n+  ) {\n+    error = { error: true, message: 'Northing value is invalid' }\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    isEastingInvalid && !isNorthingInvalid\n+  ) {\n+    error = { error: true, message: 'Easting value is invalid' }\n+  } else if (\n+    isUps &&\n+    (!upsValidDistance(northing) || !upsValidDistance(easting))\n+  ) {\n+    error = { error: true, message: 'Invalid UPS distance' }\n+  } else if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  }\n+  return error\n+}\n+\n+function validateRadiusLineBuffer(key: string, value: string) {\n+  const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '\n+  if ((value !== undefined && value.length === 0) || Number(value) < 0.000001) {\n+    return {\n+      error: true,\n+      message: label + 'cannot be less than 0.000001',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjc0ODQ5OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/component/content/content.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTozMjoxNlrOFoNn1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTozMjoxNlrOFoNn1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxMDU0OA==", "bodyText": "Do we want to do the same thing here as we did with turnOffDrawing and move the setting of attributes on the model to location-old to be consistent?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377710548", "createdAt": "2020-02-11T15:32:16Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/content/content.js", "diffHunk": "@@ -110,7 +110,11 @@ module.exports = Backbone.AssociatedModel.extend({\n   },\n   turnOnDrawing(model) {\n     this.set('drawing', true)\n+    model.set('drawing', true)\n     this.set('drawingModel', model)\n+    if (model.get('mode') === 'line' && !model.get('lineWidth')) {\n+      model.set('lineWidth', 1)\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjc2ODYzOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-old.js", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTozNzoxMFrOFoN0eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzowNzozNFrOFoRcpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxMzc4Ng==", "bodyText": "Is it really necessary to have this.drawing = false and this.set('drawing', false) here? If the goal of setting this.drawing was to affect the model, it obviously didn't achieve it since we also have to do this.set. I'm just not sure if that was the goal or if this.drawing serves another purpose", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377713786", "createdAt": "2020-02-11T15:37:10Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-old.js", "diffHunk": "@@ -235,14 +228,15 @@ module.exports = Backbone.AssociatedModel.extend({\n       this.set('locationType', 'utmUps')\n     }\n     this.drawing = false\n+    this.set('drawing', false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzIyMg==", "bodyText": "I wasn't sure either, it seems that this.drawing is checked in some places in the file - but maybe those checks could just be replaced with this.get('drawing'). I tried this and it seems to work fine so I'll push it up", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377773222", "createdAt": "2020-02-11T17:07:34Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-old.js", "diffHunk": "@@ -235,14 +228,15 @@ module.exports = Backbone.AssociatedModel.extend({\n       this.set('locationType', 'utmUps')\n     }\n     this.drawing = false\n+    this.set('drawing', false)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxMzc4Ng=="}, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjc5ODczOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo0NDowNVrOFoOHRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo0NDowNVrOFoOHRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxODU5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  console.log(props.drawing)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377718599", "createdAt": "2020-02-11T15:44:05Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +106,149 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(\n+    () => {\n+      console.log(props.drawing)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjgxMjM4OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo0NzoyMFrOFoOP1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo0OToxNlrOFoQvMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMDc5MA==", "bodyText": "Could we conditionally set label as a local variable in this function instead of passing it as a param (to keep consistent with the dms version of this function)?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377720790", "createdAt": "2020-02-11T15:47:20Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -30,22 +33,49 @@ const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n \n const minimumDifference = 0.0001\n \n-const BoundingBoxLatLon = props => {\n-  const { north, east, south, west, cursor } = props\n-\n-  const { mapEast, mapWest, mapSouth, mapNorth } = props\n-\n+const BoundingBoxLatLonDd = props => {\n+  const {\n+    north,\n+    east,\n+    south,\n+    west,\n+    setState,\n+    mapEast,\n+    mapWest,\n+    mapSouth,\n+    mapNorth,\n+  } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n   const westMax = parseFloat(mapEast) - minimumDifference\n   const eastMin = parseFloat(mapWest) + minimumDifference\n   const northMin = parseFloat(mapSouth) + minimumDifference\n   const southMax = parseFloat(mapNorth) - minimumDifference\n \n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+      }\n+    },\n+    [props.east, props.west, props.south, props.north]\n+  )\n+\n+  function onChangeDd(key, label, value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2MTU4Ng==", "bodyText": "good call \ud83d\udc4d", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377761586", "createdAt": "2020-02-11T16:49:16Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -30,22 +33,49 @@ const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n \n const minimumDifference = 0.0001\n \n-const BoundingBoxLatLon = props => {\n-  const { north, east, south, west, cursor } = props\n-\n-  const { mapEast, mapWest, mapSouth, mapNorth } = props\n-\n+const BoundingBoxLatLonDd = props => {\n+  const {\n+    north,\n+    east,\n+    south,\n+    west,\n+    setState,\n+    mapEast,\n+    mapWest,\n+    mapSouth,\n+    mapNorth,\n+  } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n   const westMax = parseFloat(mapEast) - minimumDifference\n   const eastMin = parseFloat(mapWest) + minimumDifference\n   const northMin = parseFloat(mapSouth) + minimumDifference\n   const southMax = parseFloat(mapNorth) - minimumDifference\n \n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+      }\n+    },\n+    [props.east, props.west, props.south, props.north]\n+  )\n+\n+  function onChangeDd(key, label, value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMDc5MA=="}, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjgxNDkxOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo0Nzo1NVrOFoORaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODozNDoyNlrOFoUU5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMTE5Mw==", "bodyText": "for consistency with DD:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              function validate(key, type, value) {\n          \n          \n            \n              function onChangeDms(key, value, type) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377721193", "createdAt": "2020-02-11T15:47:55Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +106,149 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(\n+    () => {\n+      console.log(props.drawing)\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+      }\n+    },\n+    [props.dmsWest, props.dmsSouth, props.dmsEast, props.dmsNorth]\n+  )\n+\n+  function validate(key, type, value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NDEyOA==", "bodyText": "I thought it might be confusing to call it onChange... because it's technically being called both in the onChange and the onBlur (even though we're only specifically invoking it from the onChange). If you think it isn't confusing then I'm okay with changing it", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377764128", "createdAt": "2020-02-11T16:53:06Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +106,149 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(\n+    () => {\n+      console.log(props.drawing)\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+      }\n+    },\n+    [props.dmsWest, props.dmsSouth, props.dmsEast, props.dmsNorth]\n+  )\n+\n+  function validate(key, type, value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMTE5Mw=="}, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NDEyMw==", "bodyText": "oh okay that makes sense, maybe we call them validateDd and validateDms?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377774123", "createdAt": "2020-02-11T17:08:57Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +106,149 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(\n+    () => {\n+      console.log(props.drawing)\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+      }\n+    },\n+    [props.dmsWest, props.dmsSouth, props.dmsEast, props.dmsNorth]\n+  )\n+\n+  function validate(key, type, value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMTE5Mw=="}, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgyMDM5MA==", "bodyText": "yeah that sounds good to me", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377820390", "createdAt": "2020-02-11T18:34:26Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +106,149 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(\n+    () => {\n+      console.log(props.drawing)\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+      }\n+    },\n+    [props.dmsWest, props.dmsSouth, props.dmsEast, props.dmsNorth]\n+  )\n+\n+  function validate(key, type, value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMTE5Mw=="}, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjgzNjI4OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/location.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo1MzoxMFrOFoOeyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo1MzoxMFrOFoOeyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyNDYxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      <Menu value={mode} onChange={value => setState('mode', value)}>\n          \n          \n            \n                      <Menu value={mode} onChange={value => setState({ ['mode']: value })}>", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377724617", "createdAt": "2020-02-11T15:53:10Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/location.js", "diffHunk": "@@ -103,35 +75,20 @@ const DrawButton = ({ onDraw }) => (\n   </Button>\n )\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n-\n const Root = styled.div`\n   height: ${props => (props.isOpen ? 'auto' : props.theme.minimumButtonSize)};\n `\n \n const Component = CustomElements.registerReact('location')\n-let errors = false\n-let inValidInput = ''\n-let inValidKey = ''\n-let defaultCoord = ''\n const LocationInput = props => {\n-  const { mode, setState, cursor } = props\n+  const { mode, setState } = props\n   const input = inputs[mode] || {}\n   const { Component: Input = null } = input\n-  const removeErrorBox = () => {\n-    setState((errors = false))\n-  }\n   return (\n     <Root isOpen={input.label !== undefined}>\n       <Component>\n         <Dropdown label={input.label || 'Select Location Option'}>\n-          <Menu value={mode} onChange={cursor('mode')}>\n+          <Menu value={mode} onChange={value => setState('mode', value)}>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjg1MTA4OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo1NjozMlrOFoOoHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo1NjozMlrOFoOoHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyNzAwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              function validate(key, type, value) {\n          \n          \n            \n              function onChangeDms(key, value, type) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377727006", "createdAt": "2020-02-11T15:56:32Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "diffHunk": "@@ -12,90 +12,213 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n const { Radio, RadioItem } = require('../radio')\n const TextField = require('../text-field')\n-\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+  initialErrorStateWithDefault,\n+} from '../utils/validation'\n const { Units, Zone, Hemisphere, MinimumSpacing } = require('./common')\n-\n const {\n   DmsLatitude,\n   DmsLongitude,\n } = require('../../component/location-new/geo-components/coordinates.js')\n const DirectionInput = require('../../component/location-new/geo-components/direction.js')\n const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n-import styled from 'styled-components'\n-\n-const ErrorBlock = styled.div`\n-  width: 100%;\n-  display: flex;\n-  flex-direction: row;\n-  justify-content: flex-start;\n-  align-items: center;\n-  background: ${({ theme }) => theme.negativeColor};\n-`\n-\n-const WarningIcon = styled.span`\n-  padding: ${({ theme }) => theme.minimumSpacing};\n-`\n-\n-const PointRadiusLatLon = props => {\n-  const { lat, lon, radius, radiusUnits, cursor } = props\n+\n+const PointRadiusLatLonDd = props => {\n+  const { lat, lon, radius, radiusUnits, setState } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.lat, props.lon, props.radius]\n+  )\n+\n+  function onChangeDd(key, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (defaultValue) {\n+      setDdError({ error, message, defaultValue })\n+      setState({ [key]: defaultValue })\n+    } else {\n+      setState({ [key]: value })\n+    }\n+  }\n+\n   return (\n     <div>\n       <TextField\n         type=\"number\"\n         label=\"Latitude\"\n-        value={lat}\n-        onChange={cursor('lat')}\n-        onBlur={props.callback}\n+        value={lat !== undefined ? String(lat) : lat}\n+        onChange={value => onChangeDd('lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', lat))}\n         addon=\"\u00b0\"\n       />\n       <TextField\n         type=\"number\"\n         label=\"Longitude\"\n-        value={lon}\n-        onChange={cursor('lon')}\n+        value={lon !== undefined ? String(lon) : lon}\n+        onChange={value => onChangeDd('lon', value)}\n+        onBlur={() => setDdError(validateGeo('lon', lon))}\n         addon=\"\u00b0\"\n       />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n+      {getErrorComponent(ddError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n         <TextField\n           type=\"number\"\n-          min=\"0\"\n           label=\"Radius\"\n-          value={radius}\n-          onChange={cursor('radius')}\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n         />\n       </Units>\n+      {getErrorComponent(radiusError)}\n     </div>\n   )\n }\n \n-const usngs = require('usng.js')\n-const converter = new usngs.Converter()\n+const PointRadiusLatLonDms = props => {\n+  const {\n+    dmsLat,\n+    dmsLon,\n+    dmsLatDirection,\n+    dmsLonDirection,\n+    radius,\n+    radiusUnits,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n \n-const PointRadiusUsngMgrs = props => {\n-  const { usng, radius, radiusUnits, cursor } = props\n-  let error = false\n-  try {\n-    const result = converter.USNGtoLL(usng, true)\n-    error = isNaN(result.lat) || isNaN(result.lon)\n-  } catch (err) {\n-    error = true\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.dmsLat, props.dmsLon, props.radius]\n+  )\n+\n+  function validate(key, type, value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjg4MDM2OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjowMzoxMFrOFoO6WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoyNjoxN1rOFoSH8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczMTY3Mg==", "bodyText": "should type=\"number\" be added in here like all the other radius text fields?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377731672", "createdAt": "2020-02-11T16:03:10Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "diffHunk": "@@ -12,90 +12,213 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n const { Radio, RadioItem } = require('../radio')\n const TextField = require('../text-field')\n-\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+  initialErrorStateWithDefault,\n+} from '../utils/validation'\n const { Units, Zone, Hemisphere, MinimumSpacing } = require('./common')\n-\n const {\n   DmsLatitude,\n   DmsLongitude,\n } = require('../../component/location-new/geo-components/coordinates.js')\n const DirectionInput = require('../../component/location-new/geo-components/direction.js')\n const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n-import styled from 'styled-components'\n-\n-const ErrorBlock = styled.div`\n-  width: 100%;\n-  display: flex;\n-  flex-direction: row;\n-  justify-content: flex-start;\n-  align-items: center;\n-  background: ${({ theme }) => theme.negativeColor};\n-`\n-\n-const WarningIcon = styled.span`\n-  padding: ${({ theme }) => theme.minimumSpacing};\n-`\n-\n-const PointRadiusLatLon = props => {\n-  const { lat, lon, radius, radiusUnits, cursor } = props\n+\n+const PointRadiusLatLonDd = props => {\n+  const { lat, lon, radius, radiusUnits, setState } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.lat, props.lon, props.radius]\n+  )\n+\n+  function onChangeDd(key, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (defaultValue) {\n+      setDdError({ error, message, defaultValue })\n+      setState({ [key]: defaultValue })\n+    } else {\n+      setState({ [key]: value })\n+    }\n+  }\n+\n   return (\n     <div>\n       <TextField\n         type=\"number\"\n         label=\"Latitude\"\n-        value={lat}\n-        onChange={cursor('lat')}\n-        onBlur={props.callback}\n+        value={lat !== undefined ? String(lat) : lat}\n+        onChange={value => onChangeDd('lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', lat))}\n         addon=\"\u00b0\"\n       />\n       <TextField\n         type=\"number\"\n         label=\"Longitude\"\n-        value={lon}\n-        onChange={cursor('lon')}\n+        value={lon !== undefined ? String(lon) : lon}\n+        onChange={value => onChangeDd('lon', value)}\n+        onBlur={() => setDdError(validateGeo('lon', lon))}\n         addon=\"\u00b0\"\n       />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n+      {getErrorComponent(ddError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n         <TextField\n           type=\"number\"\n-          min=\"0\"\n           label=\"Radius\"\n-          value={radius}\n-          onChange={cursor('radius')}\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n         />\n       </Units>\n+      {getErrorComponent(radiusError)}\n     </div>\n   )\n }\n \n-const usngs = require('usng.js')\n-const converter = new usngs.Converter()\n+const PointRadiusLatLonDms = props => {\n+  const {\n+    dmsLat,\n+    dmsLon,\n+    dmsLatDirection,\n+    dmsLonDirection,\n+    radius,\n+    radiusUnits,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n \n-const PointRadiusUsngMgrs = props => {\n-  const { usng, radius, radiusUnits, cursor } = props\n-  let error = false\n-  try {\n-    const result = converter.USNGtoLL(usng, true)\n-    error = isNaN(result.lat) || isNaN(result.lon)\n-  } catch (err) {\n-    error = true\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.dmsLat, props.dmsLon, props.radius]\n+  )\n+\n+  function validate(key, type, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (type === 'blur') {\n+      setDmsError({\n+        error: value !== undefined && value.length === 0,\n+        message,\n+        defaultValue,\n+      })\n+    } else if (defaultValue) {\n+      setDmsError({\n+        error,\n+        message,\n+        defaultValue,\n+      })\n+    }\n+    defaultValue\n+      ? setState({ [key]: defaultValue })\n+      : setState({ [key]: value })\n   }\n+\n   return (\n     <div>\n-      <TextField label=\"USNG / MGRS\" value={usng} onChange={cursor('usng')} />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n-        <TextField label=\"Radius\" value={radius} onChange={cursor('radius')} />\n+      <DmsLatitude\n+        label=\"Latitude\"\n+        value={dmsLat}\n+        onChange={(value, type) => validate('dmsLat', type, value)}\n+      >\n+        <DirectionInput\n+          options={latitudeDirections}\n+          value={dmsLatDirection}\n+          onChange={value => setState({ ['dmsLatDirection']: value })}\n+        />\n+      </DmsLatitude>\n+      <DmsLongitude\n+        label=\"Longitude\"\n+        value={dmsLon}\n+        onChange={(value, type) => validate('dmsLon', type, value)}\n+      >\n+        <DirectionInput\n+          options={longitudeDirections}\n+          value={dmsLonDirection}\n+          onChange={value => setState({ ['dmsLonDirection']: value })}\n+        />\n+      </DmsLongitude>\n+      {getErrorComponent(dmsError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n+        <TextField\n+          label=\"Radius\"\n+          type=\"number\"\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n+        />\n       </Units>\n-      {error ? (\n-        <ErrorBlock>\n-          <WarningIcon className=\"fa fa-warning\" />\n-          <span>Invalid USNG / MGRS coords</span>\n-        </ErrorBlock>\n-      ) : null}\n+      {getErrorComponent(radiusError)}\n+    </div>\n+  )\n+}\n+\n+const PointRadiusUsngMgrs = props => {\n+  const { usng, radius, radiusUnits, setState } = props\n+  const [usngError, setUsngError] = useState(initialErrorState)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setUsngError(initialErrorState)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.usng, props.radius]\n+  )\n+\n+  return (\n+    <div>\n+      <TextField\n+        label=\"USNG / MGRS\"\n+        value={usng}\n+        onChange={value => setState({ ['usng']: value })}\n+        onBlur={() => setUsngError(validateGeo('usng', usng))}\n+      />\n+      {getErrorComponent(usngError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n+        <TextField\n+          label=\"Radius\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4NDMwNg==", "bodyText": "yeah good catch \ud83d\udc4d", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377784306", "createdAt": "2020-02-11T17:26:17Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "diffHunk": "@@ -12,90 +12,213 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n const { Radio, RadioItem } = require('../radio')\n const TextField = require('../text-field')\n-\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+  initialErrorStateWithDefault,\n+} from '../utils/validation'\n const { Units, Zone, Hemisphere, MinimumSpacing } = require('./common')\n-\n const {\n   DmsLatitude,\n   DmsLongitude,\n } = require('../../component/location-new/geo-components/coordinates.js')\n const DirectionInput = require('../../component/location-new/geo-components/direction.js')\n const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n-import styled from 'styled-components'\n-\n-const ErrorBlock = styled.div`\n-  width: 100%;\n-  display: flex;\n-  flex-direction: row;\n-  justify-content: flex-start;\n-  align-items: center;\n-  background: ${({ theme }) => theme.negativeColor};\n-`\n-\n-const WarningIcon = styled.span`\n-  padding: ${({ theme }) => theme.minimumSpacing};\n-`\n-\n-const PointRadiusLatLon = props => {\n-  const { lat, lon, radius, radiusUnits, cursor } = props\n+\n+const PointRadiusLatLonDd = props => {\n+  const { lat, lon, radius, radiusUnits, setState } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.lat, props.lon, props.radius]\n+  )\n+\n+  function onChangeDd(key, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (defaultValue) {\n+      setDdError({ error, message, defaultValue })\n+      setState({ [key]: defaultValue })\n+    } else {\n+      setState({ [key]: value })\n+    }\n+  }\n+\n   return (\n     <div>\n       <TextField\n         type=\"number\"\n         label=\"Latitude\"\n-        value={lat}\n-        onChange={cursor('lat')}\n-        onBlur={props.callback}\n+        value={lat !== undefined ? String(lat) : lat}\n+        onChange={value => onChangeDd('lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', lat))}\n         addon=\"\u00b0\"\n       />\n       <TextField\n         type=\"number\"\n         label=\"Longitude\"\n-        value={lon}\n-        onChange={cursor('lon')}\n+        value={lon !== undefined ? String(lon) : lon}\n+        onChange={value => onChangeDd('lon', value)}\n+        onBlur={() => setDdError(validateGeo('lon', lon))}\n         addon=\"\u00b0\"\n       />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n+      {getErrorComponent(ddError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n         <TextField\n           type=\"number\"\n-          min=\"0\"\n           label=\"Radius\"\n-          value={radius}\n-          onChange={cursor('radius')}\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n         />\n       </Units>\n+      {getErrorComponent(radiusError)}\n     </div>\n   )\n }\n \n-const usngs = require('usng.js')\n-const converter = new usngs.Converter()\n+const PointRadiusLatLonDms = props => {\n+  const {\n+    dmsLat,\n+    dmsLon,\n+    dmsLatDirection,\n+    dmsLonDirection,\n+    radius,\n+    radiusUnits,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n \n-const PointRadiusUsngMgrs = props => {\n-  const { usng, radius, radiusUnits, cursor } = props\n-  let error = false\n-  try {\n-    const result = converter.USNGtoLL(usng, true)\n-    error = isNaN(result.lat) || isNaN(result.lon)\n-  } catch (err) {\n-    error = true\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.dmsLat, props.dmsLon, props.radius]\n+  )\n+\n+  function validate(key, type, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (type === 'blur') {\n+      setDmsError({\n+        error: value !== undefined && value.length === 0,\n+        message,\n+        defaultValue,\n+      })\n+    } else if (defaultValue) {\n+      setDmsError({\n+        error,\n+        message,\n+        defaultValue,\n+      })\n+    }\n+    defaultValue\n+      ? setState({ [key]: defaultValue })\n+      : setState({ [key]: value })\n   }\n+\n   return (\n     <div>\n-      <TextField label=\"USNG / MGRS\" value={usng} onChange={cursor('usng')} />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n-        <TextField label=\"Radius\" value={radius} onChange={cursor('radius')} />\n+      <DmsLatitude\n+        label=\"Latitude\"\n+        value={dmsLat}\n+        onChange={(value, type) => validate('dmsLat', type, value)}\n+      >\n+        <DirectionInput\n+          options={latitudeDirections}\n+          value={dmsLatDirection}\n+          onChange={value => setState({ ['dmsLatDirection']: value })}\n+        />\n+      </DmsLatitude>\n+      <DmsLongitude\n+        label=\"Longitude\"\n+        value={dmsLon}\n+        onChange={(value, type) => validate('dmsLon', type, value)}\n+      >\n+        <DirectionInput\n+          options={longitudeDirections}\n+          value={dmsLonDirection}\n+          onChange={value => setState({ ['dmsLonDirection']: value })}\n+        />\n+      </DmsLongitude>\n+      {getErrorComponent(dmsError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n+        <TextField\n+          label=\"Radius\"\n+          type=\"number\"\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n+        />\n       </Units>\n-      {error ? (\n-        <ErrorBlock>\n-          <WarningIcon className=\"fa fa-warning\" />\n-          <span>Invalid USNG / MGRS coords</span>\n-        </ErrorBlock>\n-      ) : null}\n+      {getErrorComponent(radiusError)}\n+    </div>\n+  )\n+}\n+\n+const PointRadiusUsngMgrs = props => {\n+  const { usng, radius, radiusUnits, setState } = props\n+  const [usngError, setUsngError] = useState(initialErrorState)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setUsngError(initialErrorState)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.usng, props.radius]\n+  )\n+\n+  return (\n+    <div>\n+      <TextField\n+        label=\"USNG / MGRS\"\n+        value={usng}\n+        onChange={value => setState({ ['usng']: value })}\n+        onBlur={() => setUsngError(validateGeo('usng', usng))}\n+      />\n+      {getErrorComponent(usngError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n+        <TextField\n+          label=\"Radius\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczMTY3Mg=="}, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjkwMDQxOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjowODoxM1rOFoPG8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjowODoxM1rOFoPG8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNDg5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      label=\"Radius\"\n          \n          \n            \n                      type=\"number\"\n          \n          \n            \n                      label=\"Radius\"", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377734897", "createdAt": "2020-02-11T16:08:13Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "diffHunk": "@@ -108,85 +231,122 @@ const PointRadiusUtmUps = props => {\n     utmUpsHemisphere,\n     radius,\n     radiusUnits,\n-    cursor,\n+    setState,\n   } = props\n+  const [utmError, setUtmError] = useState(initialErrorState)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setUtmError(initialErrorState)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [\n+      props.utmUpsEasting,\n+      props.utmUpsNorthing,\n+      props.utmUpsZone,\n+      props.utmUpsHemisphere,\n+      props.radius,\n+    ]\n+  )\n+\n   return (\n     <div>\n       <TextField\n         label=\"Easting\"\n-        value={utmUpsEasting}\n-        onChange={cursor('utmUpsEasting')}\n+        value={\n+          utmUpsEasting !== undefined ? String(utmUpsEasting) : utmUpsEasting\n+        }\n+        onChange={value => setState({ ['utmUpsEasting']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsEasting',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n         addon=\"m\"\n       />\n       <TextField\n         label=\"Northing\"\n-        value={utmUpsNorthing}\n-        onChange={cursor('utmUpsNorthing')}\n+        value={\n+          utmUpsNorthing !== undefined ? String(utmUpsNorthing) : utmUpsNorthing\n+        }\n+        onChange={value => setState({ ['utmUpsNorthing']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsNorthing',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n         addon=\"m\"\n       />\n-      <Zone value={utmUpsZone} onChange={cursor('utmUpsZone')} />\n+      <Zone\n+        value={utmUpsZone}\n+        onChange={value => setState({ ['utmUpsZone']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsZone',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n+      />\n       <Hemisphere\n         value={utmUpsHemisphere}\n-        onChange={cursor('utmUpsHemisphere')}\n+        onChange={value => setState({ ['utmUpsHemisphere']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsHemisphere',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n       />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n-        <TextField label=\"Radius\" value={radius} onChange={cursor('radius')} />\n-      </Units>\n-    </div>\n-  )\n-}\n-\n-const PointRadiusDms = props => {\n-  const {\n-    dmsLat,\n-    dmsLon,\n-    dmsLatDirection,\n-    dmsLonDirection,\n-    radius,\n-    radiusUnits,\n-    cursor,\n-  } = props\n-  const latitudeDirections = [Direction.North, Direction.South]\n-  const longitudeDirections = [Direction.East, Direction.West]\n-\n-  return (\n-    <div>\n-      <DmsLatitude label=\"Latitude\" value={dmsLat} onChange={cursor('dmsLat')}>\n-        <DirectionInput\n-          options={latitudeDirections}\n-          value={dmsLatDirection}\n-          onChange={cursor('dmsLatDirection')}\n-        />\n-      </DmsLatitude>\n-      <DmsLongitude\n-        label=\"Longitude\"\n-        value={dmsLon}\n-        onChange={cursor('dmsLon')}\n+      {getErrorComponent(utmError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n       >\n-        <DirectionInput\n-          options={longitudeDirections}\n-          value={dmsLonDirection}\n-          onChange={cursor('dmsLonDirection')}\n-        />\n-      </DmsLongitude>\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n         <TextField\n           label=\"Radius\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 411}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjkzNjQ5OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxNzowM1rOFoPdfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxNzowM1rOFoPdfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MDY2OQ==", "bodyText": "\u270f\ufe0f all caps variable names for constants", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377740669", "createdAt": "2020-02-11T16:17:03Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -13,8 +13,22 @@\n  *\n  **/\n \n+const React = require('react')\n import { InvalidSearchFormMessage } from '../../../component/announcement/CommonMessages'\n+import styled from 'styled-components'\n const announcement = require('../../../component/announcement/index.jsx')\n+const {\n+  validateInput,\n+} = require('../../../component/location-new/utils/dms-utils')\n+const usngs = require('usng.js')\n+const converter = new usngs.Converter()\n+const northingOffset = 10000000\n+const latitude = 'latitude'\n+const longitude = 'longitude'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjk0NDg0OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxOToxMFrOFoPi6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxOToxMFrOFoPi6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MjA1OQ==", "bodyText": "\u270f\ufe0f arrow function", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377742059", "createdAt": "2020-02-11T16:19:10Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjk0NTU0OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxOToyM1rOFoPjZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxOToyM1rOFoPjZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MjE4Mw==", "bodyText": "\u270f\ufe0f arrow function", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377742183", "createdAt": "2020-02-11T16:19:23Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjk2NTYzOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoyNDoyMlrOFoPwHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoyNDoyMlrOFoPwHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0NTQzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      message = JSON.stringify(coord) + ' is not a valid point.'\n          \n          \n            \n                      message = JSON.stringify(coord) + ' is not a valid point'", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377745439", "createdAt": "2020-02-11T16:24:22Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzAxNjg1OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNjozMVrOFoQPZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo0MTo0OFrOFoWkTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1MzQ0NQ==", "bodyText": "There was some confusion on this when it first went in so I figured it'd be good to add a comment to explain it\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n          \n          \n            \n                    // Handle the case where the user has selected a \"multi\" mode but one or more shapes were invalid and therefore eliminated\n          \n          \n            \n                    // User should then be prompted to switch to the single-shape mode for the same shape\n          \n          \n            \n                    message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n          \n      \n    \n    \n  \n\nlet me know if that makes sense please \ud83d\ude04", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377753445", "createdAt": "2020-02-11T16:36:31Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1NzEwMQ==", "bodyText": "looks good to me!", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377857101", "createdAt": "2020-02-11T19:41:48Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1MzQ0NQ=="}, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzAxNzkyOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNjo0NlrOFoQQAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNjo0NlrOFoQQAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1MzYwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    message = JSON.stringify(coordinate) + ' is not a valid point.'\n          \n          \n            \n                    message = JSON.stringify(coordinate) + ' is not a valid point'", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377753600", "createdAt": "2020-02-11T16:36:46Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzAyMDA5OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNzoyM1rOFoQRgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNzoyM1rOFoQRgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1Mzk4NA==", "bodyText": "should just return what validateListOfPoints returns", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377753984", "createdAt": "2020-02-11T16:37:23Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzA0NzY1OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo0NDoxMlrOFoQixw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo0NDoxMlrOFoQixw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1ODQwNw==", "bodyText": "is2DArray is also doing a JSON.parse of the currentValue, and in the catch it returns false, causing this function to return { error: true, message: 'Not an acceptable value' }. I think we should do the same thing here", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377758407", "createdAt": "2020-02-11T16:44:12Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzA1ODI4OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo0Njo1N1rOFoQpdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo0Njo1N1rOFoQpdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2MDExNg==", "bodyText": "\u270f\ufe0f could just make this one giant return statement", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377760116", "createdAt": "2020-02-11T16:46:57Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzA4ODYyOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo1NDoyMVrOFoQ8TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjozNDoxM1rOFobpOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NDk0MA==", "bodyText": "\u2757\ufe0f The above code doesn't accept MultiPolygons but this will:\ncase 'Polygon':\n  if (geometry.coordinates[0].length < 4) {\n    // check for MultiPolygon\n    geometry.coordinates[0].forEach((shape: number[]) => {\n    if(shape.length < 4) {\n      errors.add(\n         'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n       )\n    }\n  })\n}\nbreak", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377764940", "createdAt": "2020-02-11T16:54:21Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMjI1Mg==", "bodyText": "i think i also still need the !geometry.coordinates[0].length part of the if statement, otherwise single numbers pass the check geometry.coordinates[0].length < 4, since geometry.coordinates[0].length  evaluates to undefined.", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377932252", "createdAt": "2020-02-11T22:15:46Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NDk0MA=="}, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MDI4MA==", "bodyText": "I just tried testing, and it seems that (for both polygon and multipolygon), if you remove one of the points of a polygon, leaving only three points, that the model doesn't update with this value. it still has all 4 points, and the validation passes. maybe we can look at it more closely tomorrow.", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377940280", "createdAt": "2020-02-11T22:34:13Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NDk0MA=="}, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzEwODMzOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo1OToxN1rOFoRIxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo1ODo0MlrOFoXGvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2ODEzNA==", "bodyText": "Since we're thinking about changing the error message to \"must be greater than 0\" should we also change this to 0?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!bufferWidth || bufferWidth < 0.000001) {\n          \n          \n            \n                  if (!bufferWidth || bufferWidth <= 0) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377768134", "createdAt": "2020-02-11T16:59:17Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2MjgzNg==", "bodyText": "we're removing that check anyway, and just checking !bufferWidth", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377862836", "createdAt": "2020-02-11T19:52:43Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2ODEzNA=="}, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NTkxNw==", "bodyText": "But doesn't that only cover the case of when bufferWidth === 0? What about if it's negative?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377865917", "createdAt": "2020-02-11T19:58:42Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2ODEzNA=="}, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzExNjA2OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzowMToxN1rOFoRNsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzowMToxN1rOFoRNsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2OTM5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              if ((value !== undefined && value.length === 0) || Number(value) < 0.000001) {\n          \n          \n            \n              if ((value !== undefined && value.length === 0) || Number(value) <= 0) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377769395", "createdAt": "2020-02-11T17:01:17Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  // These checks are to ensure that we only mark a value as \"invalid\"\n+  // if the user has entered something already\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+  if (key === 'utmUpsNorthing' && isNorthingInvalid && !isEastingInvalid) {\n+    error = { error: true, message: 'Northing value is invalid' }\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    isEastingInvalid &&\n+    !isNorthingInvalid\n+  ) {\n+    error = { error: true, message: 'Easting value is invalid' }\n+  } else if (\n+    isUps &&\n+    (!upsValidDistance(northing) || !upsValidDistance(easting))\n+  ) {\n+    error = { error: true, message: 'Invalid UPS distance' }\n+  } else if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  }\n+  return error\n+}\n+\n+function validateRadiusLineBuffer(key: string, value: string) {\n+  const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '\n+  if ((value !== undefined && value.length === 0) || Number(value) < 0.000001) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 354}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzE2NTg3OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNDoyM1rOFoRs0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNDoyM1rOFoRs0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzM2MA==", "bodyText": "\u270f\ufe0f could we switch the order of params here? I just like the concept of maintaining the same order for params that are shared across multiple functions and putting any extra params at the end\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n          \n          \n            \n            function validateDDLatLon(label: string, value: string, defaultCoord: number) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377777360", "createdAt": "2020-02-11T17:14:23Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzE2ODM0OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNTowOVrOFoRuXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNTowOVrOFoRuXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3Nzc1Ng==", "bodyText": "\u270f\ufe0f see https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(latitude, 90, value)\n          \n          \n            \n                  return validateDDLatLon(latitude, value, 90)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377777756", "createdAt": "2020-02-11T17:15:09Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzE2OTY2OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNTozMlrOFoRvKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNTozMlrOFoRvKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3Nzk2Mg==", "bodyText": "\u270f\ufe0f see https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(longitude, 180, value)\n          \n          \n            \n                  return validateDDLatLon(longitude, value, 180)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377777962", "createdAt": "2020-02-11T17:15:32Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzIxNzkyOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoyODo0M1rOFoSNPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoyODo0M1rOFoSNPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4NTY2Mw==", "bodyText": "\u270f\ufe0f\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n          \n          \n            \n                utmUpsNorthing === undefined || \n          \n          \n            \n                utmUpsEasting === undefined", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377785663", "createdAt": "2020-02-11T17:28:43Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  // These checks are to ensure that we only mark a value as \"invalid\"\n+  // if the user has entered something already\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 332}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzMyODgyOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowMTozMFrOFoTR5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzoxNToyMFrOFp9zHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzIzOQ==", "bodyText": "turns out we don't actually need to maintain state for the current value, so this can be removed", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377803239", "createdAt": "2020-02-11T18:01:30Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,142 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzMjY1Mw==", "bodyText": "actually, after further testing, I take that back \u261d\ufe0f\nIf I'm editing a polygon that starts with [[-97.438844,52.236694], and I delete up to the decimal of either of those values, JSON.parse throws an error when attempting to set the state of the location-old model and the model isn't set. currentValue is, however, because it's set with the plain string. So the value state is necessary to maintain intermediary values that don't parse into JSONs when manually editing. Line and Polygon are unique in this sense because of their structure", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377832653", "createdAt": "2020-02-11T18:56:35Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,142 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzIzOQ=="}, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0ODQ0NA==", "bodyText": "Eliminating the value state can be revisited now that the model is being set with invalid values", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379548444", "createdAt": "2020-02-14T17:15:20Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,142 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzIzOQ=="}, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzc3MjA4OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoxODo1NFrOFoXqgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoxODo1NFrOFoXqgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTA3Mw==", "bodyText": "if you end up going with this change https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(LATITUDE, 90, value)\n          \n          \n            \n                  return validateDDLatLon(LATITUDE, value, 90)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377875073", "createdAt": "2020-02-11T20:18:54Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +49,444 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, 90, value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cbe3ae229717f43a32b63c40b193cd6e33739c5"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzc3NTI3OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoyMDowMVrOFoXslg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoyMDowMVrOFoXslg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTYwNg==", "bodyText": "if you end up going with this change https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(LONGITUDE, 180, value)\n          \n          \n            \n                  return validateDDLatLon(LONGITUDE, value, 180)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377875606", "createdAt": "2020-02-11T20:20:01Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +49,444 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(LONGITUDE, 180, value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cbe3ae229717f43a32b63c40b193cd6e33739c5"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDY2NTk2OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowNzo0N1rOFpZ1aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTo1ODoyOFrOFplA0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTIwOQ==", "bodyText": "\u2753 do we want to correct possible negative inputs here?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378959209", "createdAt": "2020-02-13T16:07:47Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,146 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(typeof(props[geometryKey]) === 'string' ? props[geometryKey] : JSON.stringify(props[geometryKey]))\n+      if (props.drawing) {\n+        if(lineWidth === undefined || Number(lineWidth) === 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwODk4NA==", "bodyText": "i think the solution here is to set a minimum on these text fields for both radius and buffer width - ill go ahead and do that", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379108984", "createdAt": "2020-02-13T20:45:34Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,146 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(typeof(props[geometryKey]) === 'string' ? props[geometryKey] : JSON.stringify(props[geometryKey]))\n+      if (props.drawing) {\n+        if(lineWidth === undefined || Number(lineWidth) === 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTIwOQ=="}, "originalCommit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0MjM1Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379142352", "createdAt": "2020-02-13T21:58:28Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,146 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(typeof(props[geometryKey]) === 'string' ? props[geometryKey] : JSON.stringify(props[geometryKey]))\n+      if (props.drawing) {\n+        if(lineWidth === undefined || Number(lineWidth) === 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTIwOQ=="}, "originalCommit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDY2NzYxOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowODoxMVrOFpZ2Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowODoxMVrOFpZ2Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTQ1NQ==", "bodyText": "Maybe something like:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          // do nothing\n          \n          \n            \n                          // Set state with invalid value to trigger error messaging", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378959455", "createdAt": "2020-02-13T16:08:11Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,146 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(typeof(props[geometryKey]) === 'string' ? props[geometryKey] : JSON.stringify(props[geometryKey]))\n+      if (props.drawing) {\n+        if(lineWidth === undefined || Number(lineWidth) === 0) {\n+          setState({ [widthKey]: 1 })\n+        }\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({ [geometryKey]: undefined })\n+              } else {\n+                setState({ [geometryKey]: JSON.parse(value) })\n+              }\n+            } catch (e) {\n+              // do nothing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDgxMTg0OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0NDoyNFrOFpbRhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0NDoyNFrOFpbRhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4Mjc4OQ==", "bodyText": "\u270f\ufe0f just to match the label of the text field\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '\n          \n          \n            \n              const label = key === 'lineWidth' ? 'Buffer width' : 'Radius '", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378982789", "createdAt": "2020-02-13T16:44:24Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +45,445 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(key: string, value: any) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, value, 90)\n+    case 'lon':\n+      return validateDDLatLon(LONGITUDE, value, 180)\n+    case 'dmsLat':\n+      return validateDmsLatLon(LATITUDE, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(LONGITUDE, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export const ErrorComponent = (props: any) => {\n+  const { errorState } = props\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        // Handle the case where the user has selected a \"multi\" mode but\n+        // one or more shapes were invalid and therefore eliminated\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    Number.isNaN(Number.parseFloat(point[0])) ||\n+    Number.isNaN(Number.parseFloat(point[1]))\n+  ) {\n+    return true\n+  }\n+  return point[0] > 180 || point[0] < -180 || point[1] > 90 || point[1] < -90\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  const properties = filter.geojson.properties\n+  const bufferWidth = properties.buffer && properties.buffer.width\n+  switch (properties.type) {\n+    case 'Polygon':\n+      if (!Array.isArray(geometry.coordinates[0]) || !geometry.coordinates[0].length) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      } else if (geometry.coordinates[0].length < 4) {\n+        // check for MultiPolygon\n+        geometry.coordinates[0].forEach((shape: number[]) => {\n+          if (shape.length < 4) {\n+            errors.add(\n+              'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+            )\n+          }\n+        })\n+      }\n+      break\n+    case 'LineString':\n+      if (!Array.isArray(geometry.coordinates) || !geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      // Can't just check !bufferWidth because of the case of the string \"0\"\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Line buffer width must be greater than 0')\n+      }\n+      break\n+    case 'Point':\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Radius must be greater than 0')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length === 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const { east, west, north, south } = filter.geojson.properties\n+      if (\n+        [east, west, north, south].some(\n+          direction => direction === '' || direction === undefined\n+        )\n+      ) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    return validateListOfPoints(JSON.parse(currentValue), mode)\n+  } catch (e) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+}\n+\n+function validateDDLatLon(label: string, value: string, defaultCoord: number) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === LATITUDE ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  const dmsValidation = validateDmsInput(value, validator)\n+  if (dmsValidation.error) {\n+    defaultValue = dmsValidation.defaultValue\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(key: string, value: any) {\n+  let { utmUpsEasting, utmUpsNorthing, zoneNumber, hemisphere } = value\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  const isUps = zoneNumber === 0\n+  let error = { error: false, message: '' }\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  const isNorthingInvalid = isNaN(northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid = isNaN(easting) && utmUpsEasting !== undefined\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    utmUpsEasting !== undefined &&\n+    !isNorthingInvalid\n+  ) {\n+    return { error: true, message: 'Easting value is invalid' }\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+    northing =\n+      isUps || northernHemisphere ? northing : northing - NORTHING_OFFSET\n+  } else if (\n+    key === 'utmUpsNorthing' &&\n+    utmUpsNorthing !== undefined &&\n+    !isEastingInvalid\n+  ) {\n+    return { error: true, message: 'Northing value is invalid' }\n+  }\n+  if (isUps && (!upsValidDistance(northing) || !upsValidDistance(easting))) {\n+    return { error: true, message: 'Invalid UPS distance' }\n+  }\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  // These checks are to ensure that we only mark a value as \"invalid\"\n+  // if the user has entered something already\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    utmUpsNorthing === undefined ||\n+    utmUpsEasting === undefined\n+  if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    return { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  }\n+  return error\n+}\n+\n+function validateRadiusLineBuffer(key: string, value: string) {\n+  const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTYyODI0OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/openlayers.line.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo1OToxOVrOFpjWeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo1OToxOVrOFpjWeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNTEyOA==", "bodyText": "\u2757\ufe0f with polygon here, the error is true for lines with 3 or less points because A minimum of 4 points needed for polygon and the shape won't be drawn on the map\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (polygon !== undefined && !validateGeo('polygon', JSON.stringify(polygon.getCoordinates())).error) {\n          \n          \n            \n                if (polygon !== undefined && !validateGeo('line', JSON.stringify(polygon.getCoordinates())).error) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379115128", "createdAt": "2020-02-13T20:59:19Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/openlayers.line.js", "diffHunk": "@@ -97,14 +98,14 @@ Draw.LineView = Marionette.View.extend({\n   updatePrimitive(model) {\n     const polygon = this.modelToPolygon(model)\n     // make sure the current model has width and height before drawing\n-    if (polygon && !_.isUndefined(polygon)) {\n+    if (polygon !== undefined && !validateGeo('polygon', JSON.stringify(polygon.getCoordinates())).error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTYzNTkwOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/cesium.polygon.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTowMjowNlrOFpjbRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMToxNjozNlrOFpj00Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNjM1Nw==", "bodyText": "\u2753 does polygonPoints need to be JSON stringified as well?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379116357", "createdAt": "2020-02-13T21:02:06Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/cesium.polygon.js", "diffHunk": "@@ -72,7 +76,7 @@ class PolygonRenderView extends GeometryRenderView {\n     this.primitive = new Cesium.PolylineCollection()\n     this.cameraMagnitude = this.map.camera.getMagnitude()\n     ;(polygons || []).forEach(polygonPoints => {\n-      if (!polygonPoints || polygonPoints.length < 3) {\n+      if (validateGeo('polygon', polygonPoints).error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyMjg5Nw==", "bodyText": "yes :0)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379122897", "createdAt": "2020-02-13T21:16:36Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/cesium.polygon.js", "diffHunk": "@@ -72,7 +76,7 @@ class PolygonRenderView extends GeometryRenderView {\n     this.primitive = new Cesium.PolylineCollection()\n     this.cameraMagnitude = this.map.camera.getMagnitude()\n     ;(polygons || []).forEach(polygonPoints => {\n-      if (!polygonPoints || polygonPoints.length < 3) {\n+      if (validateGeo('polygon', polygonPoints).error) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNjM1Nw=="}, "originalCommit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTY1MTUwOnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTowNzo1NlrOFpjlaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTowNzo1NlrOFpjlaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODk1Mg==", "bodyText": "\u270f\ufe0f If you changed this function to this:\nfunction validateLinePolygon(mode: string, currentValue: string) {\ntry {\nconst parsedCoords = JSON.parse(currentValue)\nif (!is2DArray(parsedCoords)) {\nreturn { error: true, message: 'Not an acceptable value' }\n}\nreturn validateListOfPoints(parsedCoords, mode)\n} catch (e) {\nreturn { error: true, message: 'Not an acceptable value' }\n}\n}\nthen is2DArray could be simplified to:\nfunction is2DArray(coordinates: string) {\nreturn Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n}", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379118952", "createdAt": "2020-02-13T21:07:56Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +45,448 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(key: string, value: any) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, value, 90)\n+    case 'lon':\n+      return validateDDLatLon(LONGITUDE, value, 180)\n+    case 'dmsLat':\n+      return validateDmsLatLon(LATITUDE, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(LONGITUDE, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export const ErrorComponent = (props: any) => {\n+  const { errorState } = props\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        // Handle the case where the user has selected a \"multi\" mode but\n+        // one or more shapes were invalid and therefore eliminated\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    Number.isNaN(Number.parseFloat(point[0])) ||\n+    Number.isNaN(Number.parseFloat(point[1]))\n+  ) {\n+    return true\n+  }\n+  return point[0] > 180 || point[0] < -180 || point[1] > 90 || point[1] < -90\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  const properties = filter.geojson.properties\n+  const bufferWidth = properties.buffer && properties.buffer.width\n+  switch (properties.type) {\n+    case 'Polygon':\n+      if (!Array.isArray(geometry.coordinates[0]) || !geometry.coordinates[0].length) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      } else if (geometry.coordinates[0].length < 4) {\n+        // check for MultiPolygon\n+        geometry.coordinates[0].forEach((shape: number[]) => {\n+          if (shape.length < 4) {\n+            errors.add(\n+              'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+            )\n+          }\n+        })\n+      }\n+      break\n+    case 'LineString':\n+      if (!Array.isArray(geometry.coordinates) || !geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      // Can't just check !bufferWidth because of the case of the string \"0\"\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Line buffer width must be greater than 0')\n+      }\n+      break\n+    case 'Point':\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Radius must be greater than 0')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length === 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const { east, west, north, south } = filter.geojson.properties\n+      if (\n+        [east, west, north, south].some(\n+          direction => direction === '' || direction === undefined\n+        )\n+      ) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    return validateListOfPoints(JSON.parse(currentValue), mode)\n+  } catch (e) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODM5NjI2OnYy", "diffSide": "RIGHT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzoxNjoyMlrOFp903w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzoxNjoyMlrOFp903w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0ODg5NQ==", "bodyText": "This case can be removed now that the model is being set upon JSON.parse failure", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379548895", "createdAt": "2020-02-14T17:16:22Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,153 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(\n+        typeof props[geometryKey] === 'string'\n+          ? props[geometryKey]\n+          : JSON.stringify(props[geometryKey])\n+      )\n+      if (props.drawing) {\n+        if (\n+          geometryKey === 'line' &&\n+          (lineWidth === undefined || Number(lineWidth) <= 0)\n+        ) {\n+          setState({ [widthKey]: 1 })\n+        }\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({ [geometryKey]: undefined })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61d3144f463e5f2fbd1e68a7abda04fed03b24b3"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODM1OTkyOnYy", "diffSide": "LEFT", "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxNToxMFrOFuRxdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzoxMTowNlrOFuYruA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MDAwNQ==", "bodyText": "\u2753 Just curious as to why setting the error state has been removed from the onChange here", "url": "https://github.com/codice/ddf/pull/5814#discussion_r384070005", "createdAt": "2020-02-25T19:15:10Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -134,20 +134,35 @@ const BaseLine = props => {\n             typeof setBufferState === 'function'\n               ? setBufferState(unitKey, value)\n               : setState({ [unitKey]: value })\n+            if (widthKey === 'lineWidth') {\n+              setBufferError(\n+                validateGeo('lineWidth', {\n+                  value: props[widthKey],\n+                  units: value,\n+                })\n+              )\n+            }\n           }}\n         >\n           <TextField\n             type=\"number\"\n             label=\"Buffer width\"\n             value={String(props[widthKey])}\n             onChange={value => {\n-              if (widthKey === 'lineWidth') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ddacff3a14d526e65ce956598108acf9acb2902"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4MzIyNA==", "bodyText": "I made this change because of the different way we're checking if there is an error or not.. before, we were just doing it if the buffer was 0 or empty. now we're doing it based on that conversion (if its less than one meter or equivalent). because it's more complicated now I moved this validation to the onBlur.", "url": "https://github.com/codice/ddf/pull/5814#discussion_r384183224", "createdAt": "2020-02-25T23:11:06Z", "author": {"login": "cassandrabailey293"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -134,20 +134,35 @@ const BaseLine = props => {\n             typeof setBufferState === 'function'\n               ? setBufferState(unitKey, value)\n               : setState({ [unitKey]: value })\n+            if (widthKey === 'lineWidth') {\n+              setBufferError(\n+                validateGeo('lineWidth', {\n+                  value: props[widthKey],\n+                  units: value,\n+                })\n+              )\n+            }\n           }}\n         >\n           <TextField\n             type=\"number\"\n             label=\"Buffer width\"\n             value={String(props[widthKey])}\n             onChange={value => {\n-              if (widthKey === 'lineWidth') {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MDAwNQ=="}, "originalCommit": {"oid": "8ddacff3a14d526e65ce956598108acf9acb2902"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4796, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}