{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2OTI1NjU4", "number": 6009, "title": "DDF-6008 - Enable Solr Highlighting", "bodyText": "What does this PR do?\nWho is reviewing it?\n@pklinef\n@vinamartin\nSelect relevant component teams:\n@codice/solr\nAsk 2 committers to review/merge the PR and tag them here.\n@andrewkfiedler\n@jlcsmith\nHow should this be tested?\nSubmit a text query with the request property highlight set to true.\nVerify that the response properties contain the highlight key and the value contains field information about the matched data within the fields that matched the query.\nAny background context you want to provide?\nWhat are the relevant tickets?\nFixes: #6008\nScreenshots\n\nChecklist:\n\n Documentation Updated\n Update / Add Threat Dragon models\n Update / Add Unit Tests\n Update / Add Integration Tests\n\nNotes on Review Process\nPlease see Notes on Review Process for further guidance on requirements for merging and abbreviated reviews.\nReview Comment Legend:\n\n\u270f\ufe0f (Pencil) This comment is a nitpick or style suggestion, no action required for approval. This comment should provide a suggestion either as an in line code snippet or a gist.\n\u2753 (Question Mark) This comment is to gain a clearer understanding of design or code choices, clarification is required but action may not be necessary for approval.\n\u2757 (Exclamation Mark) This comment is critical and requires clarification or action before approval.", "createdAt": "2020-04-21T21:45:54Z", "url": "https://github.com/codice/ddf/pull/6009", "merged": true, "mergeCommit": {"oid": "8d566ef5dd523ff0831639b34d9b7532f54f3279"}, "closed": true, "closedAt": "2020-05-07T23:32:18Z", "author": {"login": "derekwilhelm"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZ8MxzgFqTM5NzczNTI4Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfA05rgH2gAyNDA2OTI1NjU4OjcxMWEwMmRhOTdlYjVjNGQ0ZGZiODBlMmI4NzkxYTlhMGQ4OWJjYjY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NzM1Mjg2", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-397735286", "createdAt": "2020-04-21T23:04:22Z", "commit": {"oid": "9e71633a9a31ed06f0fa1fd54e172c51e5a07e6a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzowNDoyMlrOGJcF3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzoyMDo0MlrOGJcgbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MDYyMQ==", "bodyText": "\u2753 Why do you convert to JSON here instead of keeping it a Java object?  If we leave it as a Java object, different transformers and endpoints avoid converting JSON back to Java if they want to serialize to a different format or to a different JSON schema.\nSee examples for other response properties from the Solr provider.  I think this response should be consistent with those response properties.\nhttps://github.com/codice/ddf/blob/73312d1/catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java#L283-L294", "url": "https://github.com/codice/ddf/pull/6009#discussion_r412550621", "createdAt": "2020-04-21T23:04:22Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -311,6 +340,74 @@ private Boolean userSpellcheckIsOn(QueryRequest request) {\n     return userSpellcheckChoice;\n   }\n \n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight = false;\n+    if (request.getProperties().get(HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(HIGHLIGHT_KEY);\n+    }\n+    return userHighlight;\n+  }\n+\n+  private void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.simple.pre\", \"<b>\");\n+    query.setParam(\"hl.tag.pre\", \"<b>\");\n+    query.setParam(\"hl.simple.post\", \"</b>\");\n+    query.setParam(\"hl.tag.post\", \"</b>\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+  }\n+\n+  private void extractHighlighing(QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    Map<String, Map<String, Set<String>>> resultsHighlights = new HashMap<>();\n+    for (String metacardId : highlights.keySet()) {\n+      Map<String, List<String>> fieldHighlight = highlights.get(metacardId);\n+      Map<String, Set<String>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolver.resolveFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey) || isHighlightBlacklisted(solrField)) {\n+            continue;\n+          }\n+          Set<String> consolidatedSet = consolidated.get(normalizedKey);\n+          if (consolidatedSet == null) {\n+            consolidatedSet = new HashSet<>();\n+          }\n+          consolidatedSet.addAll(entry.getValue());\n+          if (!consolidatedSet.isEmpty()) {\n+            consolidated.put(normalizedKey, consolidatedSet);\n+          }\n+        }\n+      }\n+      if (!consolidated.isEmpty()) {\n+        resultsHighlights.put(metacardId, consolidated);\n+      }\n+    }\n+\n+    if (!resultsHighlights.isEmpty()) {\n+      try {\n+        responseProps.put(HIGHLIGHT_KEY, mapper.writeValueAsString(resultsHighlights));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e71633a9a31ed06f0fa1fd54e172c51e5a07e6a"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MzAxOQ==", "bodyText": "\u270f\ufe0f I would also suggest hiding any fields that are not part of the metacard type fields.  That will hide fields like metacard_type_name_txt, metacard_type_obj, and metacard_source_txt.", "url": "https://github.com/codice/ddf/pull/6009#discussion_r412553019", "createdAt": "2020-04-21T23:10:12Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -311,6 +340,74 @@ private Boolean userSpellcheckIsOn(QueryRequest request) {\n     return userSpellcheckChoice;\n   }\n \n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight = false;\n+    if (request.getProperties().get(HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(HIGHLIGHT_KEY);\n+    }\n+    return userHighlight;\n+  }\n+\n+  private void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.simple.pre\", \"<b>\");\n+    query.setParam(\"hl.tag.pre\", \"<b>\");\n+    query.setParam(\"hl.simple.post\", \"</b>\");\n+    query.setParam(\"hl.tag.post\", \"</b>\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+  }\n+\n+  private void extractHighlighing(QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    Map<String, Map<String, Set<String>>> resultsHighlights = new HashMap<>();\n+    for (String metacardId : highlights.keySet()) {\n+      Map<String, List<String>> fieldHighlight = highlights.get(metacardId);\n+      Map<String, Set<String>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolver.resolveFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey) || isHighlightBlacklisted(solrField)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e71633a9a31ed06f0fa1fd54e172c51e5a07e6a"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1NDY5NQ==", "bodyText": "\u270f\ufe0f See my comment about filtering out any field that is not part of the metacard type definition. I don't think you need these changes or the SchemaFields.java changes if you apply that change since metacard attributes should only contain - or . characters in their names. It looks like you only needed this change to filter out internal fields the Solr provider creates that uses only _ as separators.  But those fields should never be returned from the provider.", "url": "https://github.com/codice/ddf/pull/6009#discussion_r412554695", "createdAt": "2020-04-21T23:14:10Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/DynamicSchemaResolver.java", "diffHunk": "@@ -507,12 +507,18 @@ private Serializable getDocValue(String solrFieldName, Object docValue) {\n    * @return the original field name\n    */\n   String resolveFieldName(String solrFieldName) {\n-    int lastIndexOfUndercore = solrFieldName.lastIndexOf(FIRST_CHAR_OF_SUFFIX);\n-\n-    if (lastIndexOfUndercore != -1) {\n-      return solrFieldName.substring(0, lastIndexOfUndercore);\n+    String originalName = solrFieldName;\n+    boolean suffixExists = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e71633a9a31ed06f0fa1fd54e172c51e5a07e6a"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1NzQyMw==", "bodyText": "\u2757 metacard_source is a Solr provider internal field along with metacard_type_name_txt, metacard_type_obj, and probably others I am forgetting.  The provider should be removing these non-metacard fields from the highlights and should not depend on configuration.  This is leaking an implementation detail that should stay hidden in the provider.", "url": "https://github.com/codice/ddf/pull/6009#discussion_r412557423", "createdAt": "2020-04-21T23:20:42Z", "author": {"login": "pklinef"}, "path": "distribution/ddf-common/src/main/resources-filtered/etc/custom.system.properties", "diffHunk": "@@ -92,6 +92,9 @@ solr.username=admin\n # Comma-separated list of metacard types that do not support optimistic updates.\n solr.commit.nrt.metacardTypes=workspace,metacard.query,metacard.list,query-template,attribute-group,resource-note\n \n+# Comma-separated list of metacard fields that should never show up as search result highlights\n+solr.highlight.blacklist=metadata,metacard_source,metacard-tags", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e71633a9a31ed06f0fa1fd54e172c51e5a07e6a"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNjQ4NjIz", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-403648623", "createdAt": "2020-04-30T15:46:22Z", "commit": {"oid": "04c919c72c54c5a6c48bfcc66226933543206ca8"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTo0NjoyMlrOGOvVuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjowOTo1MFrOGOwUOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwODg1OQ==", "bodyText": "\u270f\ufe0f We could protect from accidental mutation if we return an unmodifiable view of the list.\nhttps://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418108859", "createdAt": "2020-04-30T15:46:22Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-api-impl/src/main/java/ddf/catalog/operation/impl/ResultAttributeHighlightImpl.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation.impl;\n+\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ResultAttributeHighlightImpl implements ResultAttributeHighlight {\n+\n+  private String attributeName;\n+\n+  private List<String> highlights;\n+\n+  public ResultAttributeHighlightImpl(String attributeName) {\n+    this.attributeName = attributeName;\n+    highlights = new ArrayList<>();\n+  }\n+\n+  public ResultAttributeHighlightImpl(String attributeName, List<String> highlights) {\n+    this(attributeName);\n+    this.highlights.addAll(highlights);\n+  }\n+\n+  @Override\n+  public String getAttributeName() {\n+    return attributeName;\n+  }\n+\n+  @Override\n+  public List<String> getHighlights() {\n+    return highlights;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c919c72c54c5a6c48bfcc66226933543206ca8"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwOTI3Mg==", "bodyText": "\u270f\ufe0f Same comment about unmodifiableList", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418109272", "createdAt": "2020-04-30T15:46:59Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-api-impl/src/main/java/ddf/catalog/operation/impl/ResultHighlightImpl.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation.impl;\n+\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import ddf.catalog.operation.ResultHighlight;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ResultHighlightImpl implements ResultHighlight {\n+  private String resultId;\n+\n+  private List<ResultAttributeHighlight> attributeHighlights;\n+\n+  /**\n+   * Instantiates a ResultHighlightImpl representing the highlight information for a particular\n+   * query result. The attribute highlight data is available to add to or retrieve via the <code>\n+   * getAttributeHighlights</code> method. This constructor creates an empty attribute highlight\n+   * list, indicating that there are no highlights.\n+   *\n+   * @param resultId The ID of the result for which the contained highlights are for\n+   */\n+  public ResultHighlightImpl(String resultId) {\n+    this.resultId = resultId;\n+    attributeHighlights = new ArrayList<>();\n+  }\n+\n+  /**\n+   * Instantiates a ResultHighlightImpl representing the highlight information for a particular\n+   * query result. Any number of {@link ResultAttributeHighlight}s may be provided to indicate that\n+   * more than one attribute was matched in a query. Additional highlight data may be added to the\n+   * list by first requesting the list of highlights from the <code>getAttributeHighlights</code>\n+   * method.\n+   *\n+   * @param resultId The ID of the result for which the contained highlights are for\n+   * @param attributeHighlights The list of attribute highlights that apply to the result\n+   */\n+  public ResultHighlightImpl(String resultId, List<ResultAttributeHighlight> attributeHighlights) {\n+    this(resultId);\n+    this.attributeHighlights.addAll(attributeHighlights);\n+  }\n+\n+  @Override\n+  public String getResultId() {\n+    return resultId;\n+  }\n+\n+  @Override\n+  public List<ResultAttributeHighlight> getAttributeHighlights() {\n+    return attributeHighlights;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c919c72c54c5a6c48bfcc66226933543206ca8"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMzY1OQ==", "bodyText": "\u270f\ufe0f It seems weird to me that this configuration is in the catalog API since this is related to Catalog Provider implementations which is independent of the catalog framework.  HistorianConfiguration makes a little more sense since you enable and disable it at the catalog framework level.  But I would think that highlight is enabled or disabled at the provider level.  Seems like highlighting is more of a provider concern than a catalog framework concern.  Unless you are thinking we would eventually do catalog framework level highlighting for all results being returned if none are provided by a source.", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418113659", "createdAt": "2020-04-30T15:53:11Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-api/src/main/java/ddf/catalog/configuration/SearchCapabilityConfiguration.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.configuration;\n+\n+/**\n+ * Interface to determine what search capabilities are enabled.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c919c72c54c5a6c48bfcc66226933543206ca8"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNDg1OQ==", "bodyText": "\u270f\ufe0f I think you can combine these 5 lines if you use computeIfAbsent but what you have fine too.\nhttps://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfAbsent-K-java.util.function.Function-", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418124859", "createdAt": "2020-04-30T16:09:50Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -311,6 +350,107 @@ private Boolean userSpellcheckIsOn(QueryRequest request) {\n     return userSpellcheckChoice;\n   }\n \n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight = false;\n+    if (request.getProperties().get(HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(HIGHLIGHT_KEY);\n+    } else if (searchCapabilityConfiguration != null) {\n+      userHighlight = searchCapabilityConfiguration.isHighlightingEnabled();\n+    }\n+    return userHighlight;\n+  }\n+\n+  private void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.simple.pre\", \"<b>\");\n+    query.setParam(\"hl.tag.pre\", \"<b>\");\n+    query.setParam(\"hl.simple.post\", \"</b>\");\n+    query.setParam(\"hl.tag.post\", \"</b>\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+  }\n+\n+  private void extractHighlighing(QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    List<ResultHighlight> resultsHighlights = new ArrayList<>();\n+    for (String metacardId : highlights.keySet()) {\n+\n+      Map<String, List<String>> fieldHighlight = highlights.get(metacardId);\n+      Map<String, Set<String>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolver.resolveFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey)\n+              || isHighlightBlacklisted(solrField)\n+              || !isMetacardAttribute(normalizedKey, metacardId, response)) {\n+            continue;\n+          }\n+          Set<String> consolidatedSet = consolidated.get(normalizedKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04c919c72c54c5a6c48bfcc66226933543206ca8"}, "originalPosition": 175}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2828f5ef708978950f7e1fcbf7c2641b151e0025", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/2828f5ef708978950f7e1fcbf7c2641b151e0025", "committedDate": "2020-05-04T23:37:08Z", "message": "DDF-6008 - Enable Solr Highlighting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fef88920ac1cd17aa3fe50f3ae31242530342db", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/8fef88920ac1cd17aa3fe50f3ae31242530342db", "committedDate": "2020-05-04T23:37:09Z", "message": "User metacardtype to aid blacklist"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b5f8dd22560685c97c8ffdb93f0fcdbc32a58d3", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/3b5f8dd22560685c97c8ffdb93f0fcdbc32a58d3", "committedDate": "2020-05-04T23:37:09Z", "message": "Refactor highlight responses and add configuration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c7b0720c605aaa4eff26bc9f6a8da8b1dd9f1af", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/6c7b0720c605aaa4eff26bc9f6a8da8b1dd9f1af", "committedDate": "2020-05-04T23:37:09Z", "message": "Add unit test, rework configuration option"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1dd1f4106c855ad168dd81d8d3d51caea309e86f", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/1dd1f4106c855ad168dd81d8d3d51caea309e86f", "committedDate": "2020-05-04T23:37:09Z", "message": "Fix property access"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62457b042a2ffcc7b433a3d5d5ac220db6341e35", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/62457b042a2ffcc7b433a3d5d5ac220db6341e35", "committedDate": "2020-05-04T23:37:09Z", "message": "Turn off highlighting after test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ea1209dcc1aaa1f9338544466ac87e528d0e888", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/7ea1209dcc1aaa1f9338544466ac87e528d0e888", "committedDate": "2020-05-05T16:18:09Z", "message": "Revert DynamicSchemaResolver"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "30d5b19afe9ec6e4894da7bc8bb5ad7d16c802d5", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/30d5b19afe9ec6e4894da7bc8bb5ad7d16c802d5", "committedDate": "2020-05-02T11:24:15Z", "message": "Turn off highlighting after test"}, "afterCommit": {"oid": "7ea1209dcc1aaa1f9338544466ac87e528d0e888", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/7ea1209dcc1aaa1f9338544466ac87e528d0e888", "committedDate": "2020-05-05T16:18:09Z", "message": "Revert DynamicSchemaResolver"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/25848a6a548d9481228f3cd571265a0938e10877", "committedDate": "2020-05-05T17:10:29Z", "message": "Move highlight key out of SolrMetacardClientImpl"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTg5NjQy", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-406189642", "createdAt": "2020-05-05T22:08:04Z", "commit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjowODowNFrOGQ9W0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjowODowNFrOGQ9W0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzNTY2NA==", "bodyText": "\u270f\ufe0f Highlighting is missing the t.", "url": "https://github.com/codice/ddf/pull/6009#discussion_r420435664", "createdAt": "2020-05-05T22:08:04Z", "author": {"login": "bellcc"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -311,6 +343,120 @@ private Boolean userSpellcheckIsOn(QueryRequest request) {\n     return userSpellcheckChoice;\n   }\n \n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight;\n+    if (request.getProperties().get(QUERY_HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(QUERY_HIGHLIGHT_KEY);\n+    } else {\n+      userHighlight = isSystemHighlightingEnabled();\n+    }\n+    return userHighlight;\n+  }\n+\n+  protected boolean isSystemHighlightingEnabled() {\n+    return BooleanUtils.toBoolean(accessProperty(HIGHLIGHT_ENABLE_PROPERTY, \"false\"));\n+  }\n+\n+  private void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.simple.pre\", \"<b>\");\n+    query.setParam(\"hl.tag.pre\", \"<b>\");\n+    query.setParam(\"hl.simple.post\", \"</b>\");\n+    query.setParam(\"hl.tag.post\", \"</b>\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+  }\n+\n+  private void extractHighlighing(QueryResponse response, Map<String, Serializable> responseProps) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTg5OTI0", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-406189924", "createdAt": "2020-05-05T22:08:38Z", "commit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTkxNzAz", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-406191703", "createdAt": "2020-05-05T22:12:12Z", "commit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTkyMTg1", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-406192185", "createdAt": "2020-05-05T22:13:12Z", "commit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjoxMzoxMlrOGQ9fkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjoxMzoxMlrOGQ9fkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzNzkwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int firstIndexOfUndercore = solrFieldName.indexOf(FIRST_CHAR_OF_SUFFIX);\n          \n          \n            \n                int firstIndexOfUnderscore = solrFieldName.indexOf(FIRST_CHAR_OF_SUFFIX);", "url": "https://github.com/codice/ddf/pull/6009#discussion_r420437905", "createdAt": "2020-05-05T22:13:12Z", "author": {"login": "stevenmalmgren"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -311,6 +343,120 @@ private Boolean userSpellcheckIsOn(QueryRequest request) {\n     return userSpellcheckChoice;\n   }\n \n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight;\n+    if (request.getProperties().get(QUERY_HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(QUERY_HIGHLIGHT_KEY);\n+    } else {\n+      userHighlight = isSystemHighlightingEnabled();\n+    }\n+    return userHighlight;\n+  }\n+\n+  protected boolean isSystemHighlightingEnabled() {\n+    return BooleanUtils.toBoolean(accessProperty(HIGHLIGHT_ENABLE_PROPERTY, \"false\"));\n+  }\n+\n+  private void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.simple.pre\", \"<b>\");\n+    query.setParam(\"hl.tag.pre\", \"<b>\");\n+    query.setParam(\"hl.simple.post\", \"</b>\");\n+    query.setParam(\"hl.tag.post\", \"</b>\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+  }\n+\n+  private void extractHighlighing(QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    List<ResultHighlight> resultsHighlights = new ArrayList<>();\n+    for (String metacardId : highlights.keySet()) {\n+\n+      Map<String, List<String>> fieldHighlight = highlights.get(metacardId);\n+      Map<String, Set<String>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolveHighlightFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey)\n+              || isHighlightBlacklisted(solrField)\n+              || !isMetacardAttribute(normalizedKey, metacardId, response)) {\n+            continue;\n+          }\n+          Set<String> consolidatedSet = consolidated.get(normalizedKey);\n+          if (consolidatedSet == null) {\n+            consolidatedSet = new HashSet<>();\n+          }\n+          consolidatedSet.addAll(entry.getValue());\n+          if (!consolidatedSet.isEmpty()) {\n+            consolidated.put(normalizedKey, consolidatedSet);\n+          }\n+        }\n+      }\n+      if (!consolidated.isEmpty()) {\n+        List<ResultAttributeHighlight> attributeHighlights = new ArrayList<>();\n+        for (Map.Entry<String, Set<String>> fieldEntry : consolidated.entrySet()) {\n+          attributeHighlights.add(\n+              new ResultAttributeHighlightImpl(\n+                  fieldEntry.getKey(), new ArrayList<>(fieldEntry.getValue())));\n+        }\n+        resultsHighlights.add(new ResultHighlightImpl(metacardId, attributeHighlights));\n+      }\n+    }\n+\n+    if (!resultsHighlights.isEmpty()) {\n+      responseProps.put(QUERY_HIGHLIGHT_KEY, (Serializable) resultsHighlights);\n+    }\n+  }\n+\n+  private String resolveHighlightFieldName(String solrFieldName) {\n+    int firstIndexOfUndercore = solrFieldName.indexOf(FIRST_CHAR_OF_SUFFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877"}, "originalPosition": 190}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTkyNDU0", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-406192454", "createdAt": "2020-05-05T22:13:47Z", "commit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjoxMzo0N1rOGQ9gaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjoxMzo0N1rOGQ9gaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzODEyMQ==", "bodyText": "\u270f\ufe0f typo here or maybe I'm misreading that.  \"for a particular ??\"", "url": "https://github.com/codice/ddf/pull/6009#discussion_r420438121", "createdAt": "2020-05-05T22:13:47Z", "author": {"login": "jlcsmith"}, "path": "catalog/core/catalog-core-api/src/main/java/ddf/catalog/operation/ResultHighlight.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation;\n+\n+import java.util.List;\n+\n+/**\n+ * ResultHighlight represents a list of attributes that matched a given query for a particular as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTkyNTI5", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-406192529", "createdAt": "2020-05-05T22:13:55Z", "commit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTkzOTk2", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-406193996", "createdAt": "2020-05-05T22:16:52Z", "commit": {"oid": "25848a6a548d9481228f3cd571265a0938e10877"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31541e2cb5a8e58804bfee6798c8c9b4272ac061", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/31541e2cb5a8e58804bfee6798c8c9b4272ac061", "committedDate": "2020-05-05T22:23:18Z", "message": "Fix typos"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjU1ODgx", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-406255881", "createdAt": "2020-05-06T01:22:33Z", "commit": {"oid": "31541e2cb5a8e58804bfee6798c8c9b4272ac061"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMToyMjozM1rOGRBLRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwMToyMjozM1rOGRBLRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5ODI0Ng==", "bodyText": "\u2753 I wonder if instead of returning a string with the Solr implementation detail that the highlights are surrounded with <em> if we should return the string without the <em> and instead include start and stop position indexes.  Then clients can decide how to represent that data.", "url": "https://github.com/codice/ddf/pull/6009#discussion_r420498246", "createdAt": "2020-05-06T01:22:33Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-api/src/main/java/ddf/catalog/operation/ResultAttributeHighlight.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation;\n+\n+import java.util.List;\n+\n+/**\n+ * ResultAttributeHighlight represents a specific attribute that matched a query and provides\n+ * indications of what the specific data the query matched on via a list of highlights. The\n+ * individual highlights are meant to be snippets of highlighted data from the attribute's value.\n+ */\n+public interface ResultAttributeHighlight {\n+  String getAttributeName();\n+\n+  List<String> getHighlights();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31541e2cb5a8e58804bfee6798c8c9b4272ac061"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Nzc5MDgw", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-406779080", "createdAt": "2020-05-06T16:22:22Z", "commit": {"oid": "31541e2cb5a8e58804bfee6798c8c9b4272ac061"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2ODU2OTEy", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-406856912", "createdAt": "2020-05-06T17:59:08Z", "commit": {"oid": "31541e2cb5a8e58804bfee6798c8c9b4272ac061"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ec546a83fa60ee6592fd4f5a0d1ce0f1c5cde7d", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/7ec546a83fa60ee6592fd4f5a0d1ce0f1c5cde7d", "committedDate": "2020-05-07T05:17:58Z", "message": "Refactor to return indices instead of strings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6223e6fe8b37552bd7bba0cbe53d38f757f2a39", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/b6223e6fe8b37552bd7bba0cbe53d38f757f2a39", "committedDate": "2020-05-07T09:20:18Z", "message": "Fix edge cases, fix cache IDs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NDEyMDY1", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-407412065", "createdAt": "2020-05-07T12:15:07Z", "commit": {"oid": "b6223e6fe8b37552bd7bba0cbe53d38f757f2a39"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMjoxNTowN1rOGR7s2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoyNjoxN1rOGR-apg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ1NzExMg==", "bodyText": "\u270f\ufe0f Isn't there a StringUtils.isNotBlank?", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421457112", "createdAt": "2020-05-07T12:15:07Z", "author": {"login": "glenhein"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ResultHighlighter.java", "diffHunk": "@@ -255,25 +281,38 @@ private boolean isHighlightBlacklisted(String fieldName) {\n     return !blacklist.isEmpty() || resolver.isPrivateField(fieldName);\n   }\n \n-  private boolean isMetacardAttribute(String fieldName, String metacardId, QueryResponse response) {\n-    MetacardType type = getMetacardType(metacardId, response);\n+  private boolean isMetacardAttribute(String fieldName, String resultId, QueryResponse response) {\n+    MetacardType type = getMetacardType(resultId, response);\n     if (type != null) {\n       return type.getAttributeDescriptor(fieldName) != null;\n     }\n \n     return false;\n   }\n \n-  private Optional<SolrDocument> getResponseDocument(String metacardId, QueryResponse response) {\n+  private String getMetacardId(String resultId, QueryResponse response) {\n+    if (!StringUtils.isBlank(mappedMetacardIdField)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6223e6fe8b37552bd7bba0cbe53d38f757f2a39"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMTYwNg==", "bodyText": "\u270f\ufe0f You could just call the other ctor", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421501606", "createdAt": "2020-05-07T13:26:17Z", "author": {"login": "glenhein"}, "path": "catalog/core/catalog-core-api-impl/src/main/java/ddf/catalog/operation/impl/HighlightImpl.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation.impl;\n+\n+import ddf.catalog.operation.Highlight;\n+import java.util.List;\n+\n+public class HighlightImpl implements Highlight {\n+\n+  private int valueIndex;\n+\n+  private int beginIndex;\n+\n+  private int endIndex;\n+\n+  public HighlightImpl() {}\n+\n+  public HighlightImpl(int beginIndex, int endIndex) {\n+    this.valueIndex = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ec546a83fa60ee6592fd4f5a0d1ce0f1c5cde7d"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NTMzMTM0", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-407533134", "createdAt": "2020-05-07T14:32:51Z", "commit": {"oid": "7ec546a83fa60ee6592fd4f5a0d1ce0f1c5cde7d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNDozMjo1MVrOGSBg1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNDozMjo1MVrOGSBg1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU1MjM0Mg==", "bodyText": "\u270f\ufe0f I wouldn't hold the PR up for this, but we should probably mark this as an experimental interface", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421552342", "createdAt": "2020-05-07T14:32:51Z", "author": {"login": "jlcsmith"}, "path": "catalog/core/catalog-core-api/src/main/java/ddf/catalog/operation/Highlight.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation;\n+\n+/**\n+ * A Highlight represents a specific range of characters in an attribute that matched a query. The\n+ * begin and end indices are referenced to the specific attribute value. The value index refers to\n+ * multi-valued fields and indicates which value the highlight applies to.\n+ */\n+public interface Highlight {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ec546a83fa60ee6592fd4f5a0d1ce0f1c5cde7d"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6690b4807466385a0f7220c6974454a61006eb6", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/e6690b4807466385a0f7220c6974454a61006eb6", "committedDate": "2020-05-07T16:09:47Z", "message": "Mark as experimental and minor cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NjY2Mjky", "url": "https://github.com/codice/ddf/pull/6009#pullrequestreview-407666292", "createdAt": "2020-05-07T17:02:54Z", "commit": {"oid": "e6690b4807466385a0f7220c6974454a61006eb6"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNzowMjo1NVrOGSH5mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNzowNzoyOFrOGSID3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1Njk4NQ==", "bodyText": "\u2753 Static?", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421656985", "createdAt": "2020-05-07T17:02:55Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ResultHighlighter.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.source.solr;\n+\n+import static ddf.catalog.Constants.QUERY_HIGHLIGHT_KEY;\n+import static ddf.catalog.source.solr.DynamicSchemaResolver.FIRST_CHAR_OF_SUFFIX;\n+\n+import com.google.common.collect.Sets;\n+import ddf.catalog.data.MetacardCreationException;\n+import ddf.catalog.data.MetacardType;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.operation.Highlight;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import ddf.catalog.operation.ResultHighlight;\n+import ddf.catalog.operation.impl.HighlightImpl;\n+import ddf.catalog.operation.impl.ResultAttributeHighlightImpl;\n+import ddf.catalog.operation.impl.ResultHighlightImpl;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrDocument;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ResultHighlighter {\n+\n+  public static final String HIGHLIGHT_ENABLE_PROPERTY = \"solr.highlight.enabled\";\n+\n+  public static final String SOLR_HIGHLIGHT_BLACKLIST = \"solr.highlight.blacklist\";\n+\n+  public static final String SOLR_HIGHLIGHT_SNIPPETS = \"solr.highlight.snippets\";\n+\n+  public static final String SOLR_HIGHLIGHT_KEY = \"hl\";\n+\n+  private static final String HIGHLIGHT_PRE_TAG = \"<em>\";\n+\n+  private static final String HIGHLIGHT_POST_TAG = \"</em>\";\n+\n+  private static final Pattern HIGHLIGHT_PATTERN =\n+      Pattern.compile(\n+          HIGHLIGHT_PRE_TAG + \"(((?!\" + HIGHLIGHT_PRE_TAG + \").)*?)\" + HIGHLIGHT_POST_TAG);\n+\n+  private static final Pattern TAG_PATTERN =\n+      Pattern.compile(\"(\" + HIGHLIGHT_PRE_TAG + \"|\" + HIGHLIGHT_POST_TAG + \")\");\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ResultHighlighter.class);\n+\n+  private final Set<String> highlightBlacklist =\n+      Sets.newHashSet(System.getProperty(SOLR_HIGHLIGHT_BLACKLIST, \"\").split(\"\\\\s*,\\\\s*\"));\n+\n+  private int surroundingContextSize = 20;\n+\n+  private DynamicSchemaResolver resolver;\n+\n+  private String mappedMetacardIdField;\n+\n+  public ResultHighlighter(DynamicSchemaResolver resolver) {\n+    this.resolver = resolver;\n+  }\n+\n+  public void setMappedMetacardIdField(String mappedMetacardIdField) {\n+    this.mappedMetacardIdField = mappedMetacardIdField;\n+  }\n+\n+  public void processPreQuery(QueryRequest request, SolrQuery query) {\n+    if (userHighlightIsOn(request)) {\n+      enableHighlighter(query);\n+    }\n+  }\n+\n+  public void processPostQuery(QueryResponse response, Map<String, Serializable> responseProps) {\n+    extractHighlighting(response, responseProps);\n+  }\n+\n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight;\n+    if (request.getProperties().get(QUERY_HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(QUERY_HIGHLIGHT_KEY);\n+    } else {\n+      userHighlight = isSystemHighlightingEnabled();\n+    }\n+    return userHighlight;\n+  }\n+\n+  protected boolean isSystemHighlightingEnabled() {\n+    return BooleanUtils.toBoolean(System.getProperty(HIGHLIGHT_ENABLE_PROPERTY, \"false\"));\n+  }\n+\n+  private String getSnippetSetting() {\n+    return System.getProperty(SOLR_HIGHLIGHT_SNIPPETS, \"20\");\n+  }\n+\n+  protected void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+    query.setParam(\"hl.preserveMulti\", true);\n+    query.setParam(\"hl.snippets\", getSnippetSetting());\n+  }\n+\n+  protected void extractHighlighting(\n+      QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    List<ResultHighlight> resultsHighlights = new ArrayList<>();\n+    for (String resultId : highlights.keySet()) {\n+\n+      Map<String, List<String>> fieldHighlight = highlights.get(resultId);\n+      Map<String, Set<Highlight>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolveHighlightFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey)\n+              || isHighlightBlacklisted(solrField)\n+              || !isMetacardAttribute(normalizedKey, resultId, response)) {\n+            continue;\n+          }\n+          Set<Highlight> consolidatedSet = consolidated.get(normalizedKey);\n+          if (consolidatedSet == null) {\n+            consolidatedSet = new HashSet<>();\n+          }\n+          consolidatedSet.addAll(\n+              createHighlights(\n+                  entry.getValue(),\n+                  getAttributeValue(resultId, normalizedKey + SchemaFields.TEXT_SUFFIX, response)));\n+          if (!consolidatedSet.isEmpty()) {\n+            consolidated.put(normalizedKey, consolidatedSet);\n+          }\n+        }\n+      }\n+      if (!consolidated.isEmpty()) {\n+        List<ResultAttributeHighlight> attributeHighlights = new ArrayList<>();\n+        for (Map.Entry<String, Set<Highlight>> fieldEntry : consolidated.entrySet()) {\n+          attributeHighlights.add(\n+              new ResultAttributeHighlightImpl(\n+                  fieldEntry.getKey(), new ArrayList<>(fieldEntry.getValue())));\n+        }\n+\n+        resultsHighlights.add(\n+            new ResultHighlightImpl(getMetacardId(resultId, response), attributeHighlights));\n+      }\n+    }\n+\n+    if (!resultsHighlights.isEmpty()) {\n+      responseProps.put(QUERY_HIGHLIGHT_KEY, (Serializable) resultsHighlights);\n+    }\n+  }\n+\n+  private List<Highlight> createHighlights(\n+      List<String> highlightResults, Collection<Object> baseValues) {\n+    List<Highlight> highlights = new ArrayList<>();\n+    if (baseValues != null && !baseValues.isEmpty()) {\n+      List<HighlightContext> highlightedValues = new ArrayList<>();\n+      highlightResults\n+          .stream()\n+          .forEach(result -> highlightedValues.addAll(getHighlightedValues(result)));\n+\n+      int index = 0;\n+      for (Object value : baseValues) {\n+        if (value != null) {\n+          highlights.addAll(extractHighlights(value.toString(), highlightedValues, index));\n+        }\n+        index++;\n+      }\n+    }\n+    return highlights;\n+  }\n+\n+  private List<Highlight> extractHighlights(\n+      String text, List<HighlightContext> values, int valueIndex) {\n+    List<Highlight> highlights = new ArrayList<>();\n+    TagIndices sourceTagIndices = new TagIndices(text);\n+    for (HighlightContext context : values) {\n+      int index = -1;\n+      int length = context.highlightedToken.length();\n+      HighlightContext source = new HighlightContext();\n+      source.surroundingContext = text;\n+      source.tokenContextOffset = 0;\n+      source.resolveSurroundingContext(false);\n+      do {\n+        index = source.surroundingContext.indexOf(context.surroundingContext, index + 1);\n+        if (index > -1) {\n+          int beginIndex = index + context.tokenContextOffset;\n+          int endIndex = index + context.tokenContextOffset + length;\n+          if (sourceTagIndices.getStartTagIndices().contains(beginIndex) && !context.embeded) {\n+            continue;\n+          }\n+          int sourceHighlightOffset =\n+              sourceTagIndices.countStartBefore(beginIndex) * HIGHLIGHT_PRE_TAG.length()\n+                  + sourceTagIndices.countEndBefore(beginIndex) * HIGHLIGHT_POST_TAG.length();\n+          beginIndex += sourceHighlightOffset;\n+          endIndex += sourceHighlightOffset;\n+          highlights.add(new HighlightImpl(beginIndex, endIndex, valueIndex));\n+        }\n+      } while (index > -1);\n+    }\n+    return highlights;\n+  }\n+\n+  private List<HighlightContext> getHighlightedValues(String highlightedText) {\n+    List<HighlightContext> values = new ArrayList<>();\n+    Matcher matcher = HIGHLIGHT_PATTERN.matcher(highlightedText);\n+    while (matcher.find()) {\n+      String token = matcher.group(1);\n+      HighlightContext context = new HighlightContext();\n+      context.highlightedToken = token;\n+      context.surroundingContext = highlightedText;\n+      context.tokenContextOffset = matcher.start();\n+      context.embeded = isHighlightEmbeded(highlightedText, matcher.start());\n+      context.resolveSurroundingContext(true);\n+      values.add(context);\n+    }\n+\n+    return values;\n+  }\n+\n+  private boolean isHighlightEmbeded(String text, int highlightIndex) {\n+    if (highlightIndex - HIGHLIGHT_PRE_TAG.length() < 0) {\n+      return false;\n+    } else {\n+      return text.substring(highlightIndex - HIGHLIGHT_PRE_TAG.length(), highlightIndex)\n+          .equals(HIGHLIGHT_PRE_TAG);\n+    }\n+  }\n+\n+  private Collection<Object> getAttributeValue(\n+      String resultId, String fieldName, QueryResponse response) {\n+    Optional<SolrDocument> metacard = getResponseDocument(resultId, response);\n+    if (metacard.isPresent()) {\n+      return metacard.get().getFieldValues(fieldName);\n+    }\n+    return null;\n+  }\n+\n+  private String resolveHighlightFieldName(String solrFieldName) {\n+    int firstIndexOfSuffix = solrFieldName.indexOf(FIRST_CHAR_OF_SUFFIX);\n+\n+    if (firstIndexOfSuffix != -1) {\n+      return solrFieldName.substring(0, firstIndexOfSuffix);\n+    }\n+    return solrFieldName;\n+  }\n+\n+  private boolean isHighlightBlacklisted(String fieldName) {\n+    List<String> blacklist =\n+        highlightBlacklist\n+            .stream()\n+            .filter(item -> fieldName.matches(item))\n+            .collect(Collectors.toList());\n+    return !blacklist.isEmpty() || resolver.isPrivateField(fieldName);\n+  }\n+\n+  private boolean isMetacardAttribute(String fieldName, String resultId, QueryResponse response) {\n+    MetacardType type = getMetacardType(resultId, response);\n+    if (type != null) {\n+      return type.getAttributeDescriptor(fieldName) != null;\n+    }\n+\n+    return false;\n+  }\n+\n+  private String getMetacardId(String resultId, QueryResponse response) {\n+    if (StringUtils.isNotBlank(mappedMetacardIdField)) {\n+      Optional<SolrDocument> document = getResponseDocument(resultId, response);\n+      if (document.isPresent()) {\n+        Object val = document.get().getFirstValue(mappedMetacardIdField);\n+        if (val != null) {\n+          return val.toString();\n+        }\n+      }\n+    }\n+    return resultId;\n+  }\n+\n+  private Optional<SolrDocument> getResponseDocument(String resultId, QueryResponse response) {\n+    return response\n+        .getResults()\n+        .stream()\n+        .filter(doc -> resultId.equals(doc.getFirstValue(Core.ID + SchemaFields.TEXT_SUFFIX)))\n+        .findFirst();\n+  }\n+\n+  private MetacardType getMetacardType(String resultId, QueryResponse response) {\n+    Optional<SolrDocument> metacard = getResponseDocument(resultId, response);\n+    if (metacard.isPresent()) {\n+      try {\n+        return resolver.getMetacardType(metacard.get());\n+      } catch (MetacardCreationException mce) {\n+        LOGGER.debug(\"Unable to read metacard type\", mce);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  class HighlightContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6690b4807466385a0f7220c6974454a61006eb6"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1NzI5MQ==", "bodyText": "\u2753 Static?", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421657291", "createdAt": "2020-05-07T17:03:27Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ResultHighlighter.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.source.solr;\n+\n+import static ddf.catalog.Constants.QUERY_HIGHLIGHT_KEY;\n+import static ddf.catalog.source.solr.DynamicSchemaResolver.FIRST_CHAR_OF_SUFFIX;\n+\n+import com.google.common.collect.Sets;\n+import ddf.catalog.data.MetacardCreationException;\n+import ddf.catalog.data.MetacardType;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.operation.Highlight;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import ddf.catalog.operation.ResultHighlight;\n+import ddf.catalog.operation.impl.HighlightImpl;\n+import ddf.catalog.operation.impl.ResultAttributeHighlightImpl;\n+import ddf.catalog.operation.impl.ResultHighlightImpl;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrDocument;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ResultHighlighter {\n+\n+  public static final String HIGHLIGHT_ENABLE_PROPERTY = \"solr.highlight.enabled\";\n+\n+  public static final String SOLR_HIGHLIGHT_BLACKLIST = \"solr.highlight.blacklist\";\n+\n+  public static final String SOLR_HIGHLIGHT_SNIPPETS = \"solr.highlight.snippets\";\n+\n+  public static final String SOLR_HIGHLIGHT_KEY = \"hl\";\n+\n+  private static final String HIGHLIGHT_PRE_TAG = \"<em>\";\n+\n+  private static final String HIGHLIGHT_POST_TAG = \"</em>\";\n+\n+  private static final Pattern HIGHLIGHT_PATTERN =\n+      Pattern.compile(\n+          HIGHLIGHT_PRE_TAG + \"(((?!\" + HIGHLIGHT_PRE_TAG + \").)*?)\" + HIGHLIGHT_POST_TAG);\n+\n+  private static final Pattern TAG_PATTERN =\n+      Pattern.compile(\"(\" + HIGHLIGHT_PRE_TAG + \"|\" + HIGHLIGHT_POST_TAG + \")\");\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ResultHighlighter.class);\n+\n+  private final Set<String> highlightBlacklist =\n+      Sets.newHashSet(System.getProperty(SOLR_HIGHLIGHT_BLACKLIST, \"\").split(\"\\\\s*,\\\\s*\"));\n+\n+  private int surroundingContextSize = 20;\n+\n+  private DynamicSchemaResolver resolver;\n+\n+  private String mappedMetacardIdField;\n+\n+  public ResultHighlighter(DynamicSchemaResolver resolver) {\n+    this.resolver = resolver;\n+  }\n+\n+  public void setMappedMetacardIdField(String mappedMetacardIdField) {\n+    this.mappedMetacardIdField = mappedMetacardIdField;\n+  }\n+\n+  public void processPreQuery(QueryRequest request, SolrQuery query) {\n+    if (userHighlightIsOn(request)) {\n+      enableHighlighter(query);\n+    }\n+  }\n+\n+  public void processPostQuery(QueryResponse response, Map<String, Serializable> responseProps) {\n+    extractHighlighting(response, responseProps);\n+  }\n+\n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight;\n+    if (request.getProperties().get(QUERY_HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(QUERY_HIGHLIGHT_KEY);\n+    } else {\n+      userHighlight = isSystemHighlightingEnabled();\n+    }\n+    return userHighlight;\n+  }\n+\n+  protected boolean isSystemHighlightingEnabled() {\n+    return BooleanUtils.toBoolean(System.getProperty(HIGHLIGHT_ENABLE_PROPERTY, \"false\"));\n+  }\n+\n+  private String getSnippetSetting() {\n+    return System.getProperty(SOLR_HIGHLIGHT_SNIPPETS, \"20\");\n+  }\n+\n+  protected void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+    query.setParam(\"hl.preserveMulti\", true);\n+    query.setParam(\"hl.snippets\", getSnippetSetting());\n+  }\n+\n+  protected void extractHighlighting(\n+      QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    List<ResultHighlight> resultsHighlights = new ArrayList<>();\n+    for (String resultId : highlights.keySet()) {\n+\n+      Map<String, List<String>> fieldHighlight = highlights.get(resultId);\n+      Map<String, Set<Highlight>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolveHighlightFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey)\n+              || isHighlightBlacklisted(solrField)\n+              || !isMetacardAttribute(normalizedKey, resultId, response)) {\n+            continue;\n+          }\n+          Set<Highlight> consolidatedSet = consolidated.get(normalizedKey);\n+          if (consolidatedSet == null) {\n+            consolidatedSet = new HashSet<>();\n+          }\n+          consolidatedSet.addAll(\n+              createHighlights(\n+                  entry.getValue(),\n+                  getAttributeValue(resultId, normalizedKey + SchemaFields.TEXT_SUFFIX, response)));\n+          if (!consolidatedSet.isEmpty()) {\n+            consolidated.put(normalizedKey, consolidatedSet);\n+          }\n+        }\n+      }\n+      if (!consolidated.isEmpty()) {\n+        List<ResultAttributeHighlight> attributeHighlights = new ArrayList<>();\n+        for (Map.Entry<String, Set<Highlight>> fieldEntry : consolidated.entrySet()) {\n+          attributeHighlights.add(\n+              new ResultAttributeHighlightImpl(\n+                  fieldEntry.getKey(), new ArrayList<>(fieldEntry.getValue())));\n+        }\n+\n+        resultsHighlights.add(\n+            new ResultHighlightImpl(getMetacardId(resultId, response), attributeHighlights));\n+      }\n+    }\n+\n+    if (!resultsHighlights.isEmpty()) {\n+      responseProps.put(QUERY_HIGHLIGHT_KEY, (Serializable) resultsHighlights);\n+    }\n+  }\n+\n+  private List<Highlight> createHighlights(\n+      List<String> highlightResults, Collection<Object> baseValues) {\n+    List<Highlight> highlights = new ArrayList<>();\n+    if (baseValues != null && !baseValues.isEmpty()) {\n+      List<HighlightContext> highlightedValues = new ArrayList<>();\n+      highlightResults\n+          .stream()\n+          .forEach(result -> highlightedValues.addAll(getHighlightedValues(result)));\n+\n+      int index = 0;\n+      for (Object value : baseValues) {\n+        if (value != null) {\n+          highlights.addAll(extractHighlights(value.toString(), highlightedValues, index));\n+        }\n+        index++;\n+      }\n+    }\n+    return highlights;\n+  }\n+\n+  private List<Highlight> extractHighlights(\n+      String text, List<HighlightContext> values, int valueIndex) {\n+    List<Highlight> highlights = new ArrayList<>();\n+    TagIndices sourceTagIndices = new TagIndices(text);\n+    for (HighlightContext context : values) {\n+      int index = -1;\n+      int length = context.highlightedToken.length();\n+      HighlightContext source = new HighlightContext();\n+      source.surroundingContext = text;\n+      source.tokenContextOffset = 0;\n+      source.resolveSurroundingContext(false);\n+      do {\n+        index = source.surroundingContext.indexOf(context.surroundingContext, index + 1);\n+        if (index > -1) {\n+          int beginIndex = index + context.tokenContextOffset;\n+          int endIndex = index + context.tokenContextOffset + length;\n+          if (sourceTagIndices.getStartTagIndices().contains(beginIndex) && !context.embeded) {\n+            continue;\n+          }\n+          int sourceHighlightOffset =\n+              sourceTagIndices.countStartBefore(beginIndex) * HIGHLIGHT_PRE_TAG.length()\n+                  + sourceTagIndices.countEndBefore(beginIndex) * HIGHLIGHT_POST_TAG.length();\n+          beginIndex += sourceHighlightOffset;\n+          endIndex += sourceHighlightOffset;\n+          highlights.add(new HighlightImpl(beginIndex, endIndex, valueIndex));\n+        }\n+      } while (index > -1);\n+    }\n+    return highlights;\n+  }\n+\n+  private List<HighlightContext> getHighlightedValues(String highlightedText) {\n+    List<HighlightContext> values = new ArrayList<>();\n+    Matcher matcher = HIGHLIGHT_PATTERN.matcher(highlightedText);\n+    while (matcher.find()) {\n+      String token = matcher.group(1);\n+      HighlightContext context = new HighlightContext();\n+      context.highlightedToken = token;\n+      context.surroundingContext = highlightedText;\n+      context.tokenContextOffset = matcher.start();\n+      context.embeded = isHighlightEmbeded(highlightedText, matcher.start());\n+      context.resolveSurroundingContext(true);\n+      values.add(context);\n+    }\n+\n+    return values;\n+  }\n+\n+  private boolean isHighlightEmbeded(String text, int highlightIndex) {\n+    if (highlightIndex - HIGHLIGHT_PRE_TAG.length() < 0) {\n+      return false;\n+    } else {\n+      return text.substring(highlightIndex - HIGHLIGHT_PRE_TAG.length(), highlightIndex)\n+          .equals(HIGHLIGHT_PRE_TAG);\n+    }\n+  }\n+\n+  private Collection<Object> getAttributeValue(\n+      String resultId, String fieldName, QueryResponse response) {\n+    Optional<SolrDocument> metacard = getResponseDocument(resultId, response);\n+    if (metacard.isPresent()) {\n+      return metacard.get().getFieldValues(fieldName);\n+    }\n+    return null;\n+  }\n+\n+  private String resolveHighlightFieldName(String solrFieldName) {\n+    int firstIndexOfSuffix = solrFieldName.indexOf(FIRST_CHAR_OF_SUFFIX);\n+\n+    if (firstIndexOfSuffix != -1) {\n+      return solrFieldName.substring(0, firstIndexOfSuffix);\n+    }\n+    return solrFieldName;\n+  }\n+\n+  private boolean isHighlightBlacklisted(String fieldName) {\n+    List<String> blacklist =\n+        highlightBlacklist\n+            .stream()\n+            .filter(item -> fieldName.matches(item))\n+            .collect(Collectors.toList());\n+    return !blacklist.isEmpty() || resolver.isPrivateField(fieldName);\n+  }\n+\n+  private boolean isMetacardAttribute(String fieldName, String resultId, QueryResponse response) {\n+    MetacardType type = getMetacardType(resultId, response);\n+    if (type != null) {\n+      return type.getAttributeDescriptor(fieldName) != null;\n+    }\n+\n+    return false;\n+  }\n+\n+  private String getMetacardId(String resultId, QueryResponse response) {\n+    if (StringUtils.isNotBlank(mappedMetacardIdField)) {\n+      Optional<SolrDocument> document = getResponseDocument(resultId, response);\n+      if (document.isPresent()) {\n+        Object val = document.get().getFirstValue(mappedMetacardIdField);\n+        if (val != null) {\n+          return val.toString();\n+        }\n+      }\n+    }\n+    return resultId;\n+  }\n+\n+  private Optional<SolrDocument> getResponseDocument(String resultId, QueryResponse response) {\n+    return response\n+        .getResults()\n+        .stream()\n+        .filter(doc -> resultId.equals(doc.getFirstValue(Core.ID + SchemaFields.TEXT_SUFFIX)))\n+        .findFirst();\n+  }\n+\n+  private MetacardType getMetacardType(String resultId, QueryResponse response) {\n+    Optional<SolrDocument> metacard = getResponseDocument(resultId, response);\n+    if (metacard.isPresent()) {\n+      try {\n+        return resolver.getMetacardType(metacard.get());\n+      } catch (MetacardCreationException mce) {\n+        LOGGER.debug(\"Unable to read metacard type\", mce);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  class HighlightContext {\n+    String highlightedToken;\n+    String surroundingContext;\n+    int tokenContextOffset;\n+    boolean embeded = false;\n+\n+    public void resolveSurroundingContext(boolean trimContext) {\n+      int index = -1;\n+      int adjustment = 0;\n+      do {\n+        index = surroundingContext.indexOf(HIGHLIGHT_PRE_TAG, index + 1);\n+        if (index != -1 && index < tokenContextOffset) {\n+          adjustment += HIGHLIGHT_PRE_TAG.length();\n+        }\n+      } while (index > -1);\n+\n+      do {\n+        index = surroundingContext.indexOf(HIGHLIGHT_POST_TAG, index + 1);\n+        if (index != -1 && index < tokenContextOffset) {\n+          adjustment += HIGHLIGHT_POST_TAG.length();\n+        }\n+      } while (index > -1);\n+      tokenContextOffset -= adjustment;\n+      surroundingContext = surroundingContext.replaceAll(HIGHLIGHT_PRE_TAG, \"\");\n+      surroundingContext = surroundingContext.replaceAll(HIGHLIGHT_POST_TAG, \"\");\n+\n+      if (trimContext) {\n+        if (surroundingContext.length() > surroundingContextSize * 2) {\n+          int trimStart = Math.max(0, tokenContextOffset - surroundingContextSize);\n+          int trimEnd =\n+              Math.min(surroundingContext.length(), tokenContextOffset + surroundingContextSize);\n+          surroundingContext = surroundingContext.substring(trimStart, trimEnd);\n+          tokenContextOffset -= trimStart;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return new HashCodeBuilder(25, 49)\n+          .append(highlightedToken)\n+          .append(surroundingContext)\n+          .append(tokenContextOffset)\n+          .toHashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+\n+      HighlightContext context = (HighlightContext) o;\n+\n+      return new EqualsBuilder()\n+          .append(highlightedToken, context.highlightedToken)\n+          .append(surroundingContext, context.surroundingContext)\n+          .append(tokenContextOffset, context.tokenContextOffset)\n+          .isEquals();\n+    }\n+  }\n+\n+  class TagIndices {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6690b4807466385a0f7220c6974454a61006eb6"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1ODQ5Mw==", "bodyText": "\u270f\ufe0f Could make unmodifiable to protect against accidental modification.", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421658493", "createdAt": "2020-05-07T17:05:30Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ResultHighlighter.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.source.solr;\n+\n+import static ddf.catalog.Constants.QUERY_HIGHLIGHT_KEY;\n+import static ddf.catalog.source.solr.DynamicSchemaResolver.FIRST_CHAR_OF_SUFFIX;\n+\n+import com.google.common.collect.Sets;\n+import ddf.catalog.data.MetacardCreationException;\n+import ddf.catalog.data.MetacardType;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.operation.Highlight;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import ddf.catalog.operation.ResultHighlight;\n+import ddf.catalog.operation.impl.HighlightImpl;\n+import ddf.catalog.operation.impl.ResultAttributeHighlightImpl;\n+import ddf.catalog.operation.impl.ResultHighlightImpl;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrDocument;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ResultHighlighter {\n+\n+  public static final String HIGHLIGHT_ENABLE_PROPERTY = \"solr.highlight.enabled\";\n+\n+  public static final String SOLR_HIGHLIGHT_BLACKLIST = \"solr.highlight.blacklist\";\n+\n+  public static final String SOLR_HIGHLIGHT_SNIPPETS = \"solr.highlight.snippets\";\n+\n+  public static final String SOLR_HIGHLIGHT_KEY = \"hl\";\n+\n+  private static final String HIGHLIGHT_PRE_TAG = \"<em>\";\n+\n+  private static final String HIGHLIGHT_POST_TAG = \"</em>\";\n+\n+  private static final Pattern HIGHLIGHT_PATTERN =\n+      Pattern.compile(\n+          HIGHLIGHT_PRE_TAG + \"(((?!\" + HIGHLIGHT_PRE_TAG + \").)*?)\" + HIGHLIGHT_POST_TAG);\n+\n+  private static final Pattern TAG_PATTERN =\n+      Pattern.compile(\"(\" + HIGHLIGHT_PRE_TAG + \"|\" + HIGHLIGHT_POST_TAG + \")\");\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ResultHighlighter.class);\n+\n+  private final Set<String> highlightBlacklist =\n+      Sets.newHashSet(System.getProperty(SOLR_HIGHLIGHT_BLACKLIST, \"\").split(\"\\\\s*,\\\\s*\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6690b4807466385a0f7220c6974454a61006eb6"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1ODc5Nw==", "bodyText": "\u270f\ufe0f Make final?", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421658797", "createdAt": "2020-05-07T17:05:59Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ResultHighlighter.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.source.solr;\n+\n+import static ddf.catalog.Constants.QUERY_HIGHLIGHT_KEY;\n+import static ddf.catalog.source.solr.DynamicSchemaResolver.FIRST_CHAR_OF_SUFFIX;\n+\n+import com.google.common.collect.Sets;\n+import ddf.catalog.data.MetacardCreationException;\n+import ddf.catalog.data.MetacardType;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.operation.Highlight;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import ddf.catalog.operation.ResultHighlight;\n+import ddf.catalog.operation.impl.HighlightImpl;\n+import ddf.catalog.operation.impl.ResultAttributeHighlightImpl;\n+import ddf.catalog.operation.impl.ResultHighlightImpl;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrDocument;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ResultHighlighter {\n+\n+  public static final String HIGHLIGHT_ENABLE_PROPERTY = \"solr.highlight.enabled\";\n+\n+  public static final String SOLR_HIGHLIGHT_BLACKLIST = \"solr.highlight.blacklist\";\n+\n+  public static final String SOLR_HIGHLIGHT_SNIPPETS = \"solr.highlight.snippets\";\n+\n+  public static final String SOLR_HIGHLIGHT_KEY = \"hl\";\n+\n+  private static final String HIGHLIGHT_PRE_TAG = \"<em>\";\n+\n+  private static final String HIGHLIGHT_POST_TAG = \"</em>\";\n+\n+  private static final Pattern HIGHLIGHT_PATTERN =\n+      Pattern.compile(\n+          HIGHLIGHT_PRE_TAG + \"(((?!\" + HIGHLIGHT_PRE_TAG + \").)*?)\" + HIGHLIGHT_POST_TAG);\n+\n+  private static final Pattern TAG_PATTERN =\n+      Pattern.compile(\"(\" + HIGHLIGHT_PRE_TAG + \"|\" + HIGHLIGHT_POST_TAG + \")\");\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ResultHighlighter.class);\n+\n+  private final Set<String> highlightBlacklist =\n+      Sets.newHashSet(System.getProperty(SOLR_HIGHLIGHT_BLACKLIST, \"\").split(\"\\\\s*,\\\\s*\"));\n+\n+  private int surroundingContextSize = 20;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6690b4807466385a0f7220c6974454a61006eb6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1OTYxNQ==", "bodyText": "\u270f\ufe0f I would suggest adding a unit test for XML fields and highlighting since we strip XML tags for the value that is indexed.", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421659615", "createdAt": "2020-05-07T17:07:28Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/test/java/ddf/catalog/source/solr/SolrMetacardClientImplTest.java", "diffHunk": "@@ -204,14 +214,92 @@ public void testQuerySpellCheckOn() throws Exception {\n     verify(queryResponse, times(2)).getResults();\n   }\n \n+  @Test\n+  public void testHighlightOn() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6690b4807466385a0f7220c6974454a61006eb6"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "711a02da97eb5c4d4dfb80e2b8791a9a0d89bcb6", "author": {"user": {"login": "derekwilhelm", "name": null}}, "url": "https://github.com/codice/ddf/commit/711a02da97eb5c4d4dfb80e2b8791a9a0d89bcb6", "committedDate": "2020-05-07T17:35:31Z", "message": "make inner classes static"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4935, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}