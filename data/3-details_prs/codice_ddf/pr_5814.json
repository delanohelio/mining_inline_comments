{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMTE2MTE2", "number": 5814, "title": "[2.19.x] DDF-5793 anyGeo search validation refactor and UX improvements", "bodyText": "What does this PR do?\nThis PR improves the validation/error handling/error displaying for anyGeo searches - specifically Line, Point-Radius, and Bounding Box.\nFor details on how the behavior has changed, please see this document:\nUX-changes_updated.pdf\nIt also refactors the way in which the state is set when values are changed by the user, and eliminates the cursor function from location.js entirely. This refactor involved moving the error components and their validation into each separate component (pulling shared logic into the validation.tsx file) rather than using the cursor function and the LocationInput component for most of the error handling. Generic validation logic that existed in base.line.js and 'location.js' were moved into the validation.tsx file.\n\nUPDATE 2/24:\nBased on feedback from @bennuttle and @leo-sakh , The UX for radius and line buffer width has been changed. The minimum buffer has been changed to 1 meter (or its equivalent in the other units). Changes have been made to the inline error and toast message to reflect this minimum.\nLike the other inputs, we now do the validation in the onBlur function rather than the onChange, meaning the user will not see an error message until clicking out of the input box. If the user tries to search with an invalid radius or line buffer width, the search will be prevented.\nI have updated the document above and the screenshots below to reflect this change.\n\nKnown Issues\n\nKeyword: Can't change buffer width or units on the Polygon inside of the Keyword anyGeo search fixed 02/05\nKeyword: Console error when changing polygon value and clicking out fixed 02/05\nKeyword: Does not prevent a search when polygon is invalid exists previously, out of scope for this PR\n\nWho is reviewing it?\n\n@hayleynorton @maryformanek @zta6 @andrewzimmer\nSelect relevant component teams:\n\n@codice/ui\nAsk 2 committers to review/merge the PR and tag them here.\n\n@bdeining\nHow should this be tested?\n\nTest that the new behavior is as defined here:\nUX-changes.pdf\nAny background context you want to provide?\nWhat are the relevant tickets?\nFixes: #5793\nScreenshots\n\nHere are some examples of the new behavior:\nLine\n\n\nPoint Radius\n\n\n\nBounding Box\n\n\nSearch Errors\nThis is showing that when you have multiple errors of the same type, the error message that pops up will inform you about all of them only once (see how the \"Radius must be greater..\"  only shows once)\n\n\nChecklist:\n\n Documentation Updated\n Update / Add Threat Dragon models\n Update / Add Unit Tests\n Update / Add Integration Tests\n\nNotes on Review Process\nPlease see Notes on Review Process for further guidance on requirements for merging and abbreviated reviews.\nReview Comment Legend:\n\n\u270f\ufe0f (Pencil) This comment is a nitpick or style suggestion, no action required for approval. This comment should provide a suggestion either as an in line code snippet or a gist.\n\u2753 (Question Mark) This comment is to gain a clearer understanding of design or code choices, clarification is required but action may not be necessary for approval.\n\u2757 (Exclamation Mark) This comment is critical and requires clarification or action before approval.", "createdAt": "2020-02-05T00:07:14Z", "url": "https://github.com/codice/ddf/pull/5814", "merged": true, "mergeCommit": {"oid": "9dc05f2d2360dfd58f17a3679d90524cac0099e2"}, "closed": true, "closedAt": "2020-03-03T16:08:30Z", "author": {"login": "cassandrabailey293"}, "timelineItems": {"totalCount": 134, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcEBb3JgFqTM1ODU0ODIyNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcJxTB2AFqTM2NzM5MTQ4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTQ4MjI0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-358548224", "createdAt": "2020-02-13T21:02:06Z", "commit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTowMjowNlrOFpjbRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTowMjowNlrOFpjbRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNjM1Nw==", "bodyText": "\u2753 does polygonPoints need to be JSON stringified as well?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379116357", "createdAt": "2020-02-13T21:02:06Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/cesium.polygon.js", "diffHunk": "@@ -72,7 +76,7 @@ class PolygonRenderView extends GeometryRenderView {\n     this.primitive = new Cesium.PolylineCollection()\n     this.cameraMagnitude = this.map.camera.getMagnitude()\n     ;(polygons || []).forEach(polygonPoints => {\n-      if (!polygonPoints || polygonPoints.length < 3) {\n+      if (validateGeo('polygon', polygonPoints).error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTUxNTc0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-358551574", "createdAt": "2020-02-13T21:07:56Z", "commit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTowNzo1NlrOFpjlaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTowNzo1NlrOFpjlaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODk1Mg==", "bodyText": "\u270f\ufe0f If you changed this function to this:\nfunction validateLinePolygon(mode: string, currentValue: string) {\ntry {\nconst parsedCoords = JSON.parse(currentValue)\nif (!is2DArray(parsedCoords)) {\nreturn { error: true, message: 'Not an acceptable value' }\n}\nreturn validateListOfPoints(parsedCoords, mode)\n} catch (e) {\nreturn { error: true, message: 'Not an acceptable value' }\n}\n}\nthen is2DArray could be simplified to:\nfunction is2DArray(coordinates: string) {\nreturn Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n}", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379118952", "createdAt": "2020-02-13T21:07:56Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +45,448 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(key: string, value: any) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, value, 90)\n+    case 'lon':\n+      return validateDDLatLon(LONGITUDE, value, 180)\n+    case 'dmsLat':\n+      return validateDmsLatLon(LATITUDE, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(LONGITUDE, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export const ErrorComponent = (props: any) => {\n+  const { errorState } = props\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        // Handle the case where the user has selected a \"multi\" mode but\n+        // one or more shapes were invalid and therefore eliminated\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    Number.isNaN(Number.parseFloat(point[0])) ||\n+    Number.isNaN(Number.parseFloat(point[1]))\n+  ) {\n+    return true\n+  }\n+  return point[0] > 180 || point[0] < -180 || point[1] > 90 || point[1] < -90\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  const properties = filter.geojson.properties\n+  const bufferWidth = properties.buffer && properties.buffer.width\n+  switch (properties.type) {\n+    case 'Polygon':\n+      if (!Array.isArray(geometry.coordinates[0]) || !geometry.coordinates[0].length) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      } else if (geometry.coordinates[0].length < 4) {\n+        // check for MultiPolygon\n+        geometry.coordinates[0].forEach((shape: number[]) => {\n+          if (shape.length < 4) {\n+            errors.add(\n+              'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+            )\n+          }\n+        })\n+      }\n+      break\n+    case 'LineString':\n+      if (!Array.isArray(geometry.coordinates) || !geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      // Can't just check !bufferWidth because of the case of the string \"0\"\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Line buffer width must be greater than 0')\n+      }\n+      break\n+    case 'Point':\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Radius must be greater than 0')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length === 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const { east, west, north, south } = filter.geojson.properties\n+      if (\n+        [east, west, north, south].some(\n+          direction => direction === '' || direction === undefined\n+        )\n+      ) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    return validateListOfPoints(JSON.parse(currentValue), mode)\n+  } catch (e) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5"}, "originalPosition": 228}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bca96d3fe2f2d977d8e03ab479517d49fae51ff", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/6bca96d3fe2f2d977d8e03ab479517d49fae51ff", "committedDate": "2020-02-13T21:09:13Z", "message": "DDF-5793 address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0cd813b49b248ae9345539851eb38afbf37ff1c", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/d0cd813b49b248ae9345539851eb38afbf37ff1c", "committedDate": "2020-02-13T21:10:32Z", "message": "Update ui/packages/catalog-ui-search/src/main/webapp/js/widgets/openlayers.line.js\n\nCo-Authored-By: Hayley Norton <39737329+hayleynorton@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6b9edfa681536cded7ab5948f87bf7a782bef30", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/a6b9edfa681536cded7ab5948f87bf7a782bef30", "committedDate": "2020-02-13T22:01:08Z", "message": "DDF-5793 do validation after polygon has been constructed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c49fe58012c5737b6235c60c8ced02fcb684f9c0", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/c49fe58012c5737b6235c60c8ced02fcb684f9c0", "committedDate": "2020-02-13T22:29:50Z", "message": "DDF-5793 refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61d3144f463e5f2fbd1e68a7abda04fed03b24b3", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/61d3144f463e5f2fbd1e68a7abda04fed03b24b3", "committedDate": "2020-02-13T22:46:28Z", "message": "DDF-5793 format"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MDk1MzU4", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-359095358", "createdAt": "2020-02-14T17:16:22Z", "commit": {"oid": "61d3144f463e5f2fbd1e68a7abda04fed03b24b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzoxNjoyMlrOFp903w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzoxNjoyMlrOFp903w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0ODg5NQ==", "bodyText": "This case can be removed now that the model is being set upon JSON.parse failure", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379548895", "createdAt": "2020-02-14T17:16:22Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,153 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(\n+        typeof props[geometryKey] === 'string'\n+          ? props[geometryKey]\n+          : JSON.stringify(props[geometryKey])\n+      )\n+      if (props.drawing) {\n+        if (\n+          geometryKey === 'line' &&\n+          (lineWidth === undefined || Number(lineWidth) <= 0)\n+        ) {\n+          setState({ [widthKey]: 1 })\n+        }\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({ [geometryKey]: undefined })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61d3144f463e5f2fbd1e68a7abda04fed03b24b3"}, "originalPosition": 146}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "106c075fb4abce47185637b17e14c1f33d952aea", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/106c075fb4abce47185637b17e14c1f33d952aea", "committedDate": "2020-02-14T20:58:30Z", "message": "DDF-5793 remove uneecessary conditional"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5ODc1NDAz", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-359875403", "createdAt": "2020-02-17T17:02:22Z", "commit": {"oid": "106c075fb4abce47185637b17e14c1f33d952aea"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3023c4bcdc6e4081f83d5cadf69d4ed19c8e904", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/f3023c4bcdc6e4081f83d5cadf69d4ed19c8e904", "committedDate": "2020-02-18T15:52:14Z", "message": "DDF-5793 haurd against undefined model for drawing and remove unnecessary code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06102b4433d4fd283366c845603778ec6fafcddb", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/06102b4433d4fd283366c845603778ec6fafcddb", "committedDate": "2020-02-18T19:22:43Z", "message": "DDF-5793 add multis to validation switch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca6bf32769454fe6b34f95dd2d2c981574797f70", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/ca6bf32769454fe6b34f95dd2d2c981574797f70", "committedDate": "2020-02-18T22:42:40Z", "message": "DDF-5793 ensure distance is a number"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e12533a14084de76392726ef54d2f931d838cdca", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/e12533a14084de76392726ef54d2f931d838cdca", "committedDate": "2020-02-19T19:29:57Z", "message": "DDF-5793 fix polygon/line initial error and Draw clicking issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d37e31dcee779ccdf10f60d73e9a76947c79d32", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/1d37e31dcee779ccdf10f60d73e9a76947c79d32", "committedDate": "2020-02-19T21:20:42Z", "message": "DDF-5793 fix drawing error and stale error messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4f3fe12d6aaeca2f3f4c39fab9a8d15a3264cd7", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/d4f3fe12d6aaeca2f3f4c39fab9a8d15a3264cd7", "committedDate": "2020-02-20T21:43:44Z", "message": "DDF-5793 formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ddacff3a14d526e65ce956598108acf9acb2902", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/8ddacff3a14d526e65ce956598108acf9acb2902", "committedDate": "2020-02-24T18:06:59Z", "message": "DDF-5793 change buffer validation to be specific to units"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da7705ae67f0c5b3bed1e5e4641bd95d39b32236", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/da7705ae67f0c5b3bed1e5e4641bd95d39b32236", "committedDate": "2020-02-24T18:56:01Z", "message": "DDF-5793 add new validation to all point radius options"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0Mzc4NTgy", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-364378582", "createdAt": "2020-02-25T19:15:10Z", "commit": {"oid": "8ddacff3a14d526e65ce956598108acf9acb2902"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxNToxMFrOFuRxdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxNToxMFrOFuRxdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MDAwNQ==", "bodyText": "\u2753 Just curious as to why setting the error state has been removed from the onChange here", "url": "https://github.com/codice/ddf/pull/5814#discussion_r384070005", "createdAt": "2020-02-25T19:15:10Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -134,20 +134,35 @@ const BaseLine = props => {\n             typeof setBufferState === 'function'\n               ? setBufferState(unitKey, value)\n               : setState({ [unitKey]: value })\n+            if (widthKey === 'lineWidth') {\n+              setBufferError(\n+                validateGeo('lineWidth', {\n+                  value: props[widthKey],\n+                  units: value,\n+                })\n+              )\n+            }\n           }}\n         >\n           <TextField\n             type=\"number\"\n             label=\"Buffer width\"\n             value={String(props[widthKey])}\n             onChange={value => {\n-              if (widthKey === 'lineWidth') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ddacff3a14d526e65ce956598108acf9acb2902"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzgwMzE0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-364380314", "createdAt": "2020-02-25T19:17:48Z", "commit": {"oid": "da7705ae67f0c5b3bed1e5e4641bd95d39b32236"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjE5MzUx", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-365219351", "createdAt": "2020-02-26T20:30:16Z", "commit": {"oid": "da7705ae67f0c5b3bed1e5e4641bd95d39b32236"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjU5ODY3", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-365259867", "createdAt": "2020-02-26T21:35:22Z", "commit": {"oid": "da7705ae67f0c5b3bed1e5e4641bd95d39b32236"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98b28abd57796839d7bbfa95bf2ec70efa739dc6", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/98b28abd57796839d7bbfa95bf2ec70efa739dc6", "committedDate": "2020-02-27T21:40:28Z", "message": "DDF-5793 fix unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92f4217f676f735fe116d80fbc3543366dcb6aac", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/92f4217f676f735fe116d80fbc3543366dcb6aac", "committedDate": "2020-02-27T22:43:45Z", "message": "DDF-5793 add min buffer check for polygon and persist buffer errors after drawing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb31b24685213b2c60d45d60ff77fa38f1397b29", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/cb31b24685213b2c60d45d60ff77fa38f1397b29", "committedDate": "2020-02-27T22:44:54Z", "message": "DDF-5793 formt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9af04a73a60444afb470cc4e800bcafc6bb86813", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/9af04a73a60444afb470cc4e800bcafc6bb86813", "committedDate": "2020-02-28T15:45:43Z", "message": "DDF-5793 guard against undefined multiline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ec8a13480af9e07c686143d697811ead81183d2", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/1ec8a13480af9e07c686143d697811ead81183d2", "committedDate": "2020-02-28T16:48:36Z", "message": "DDF-5793 change error messaging for polygon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dc69622b2a78b85ecfb80cf68044b6eb565b6e6", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/6dc69622b2a78b85ecfb80cf68044b6eb565b6e6", "committedDate": "2020-02-28T16:50:06Z", "message": "DDF-5793 format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05821e7c0d36e2552716c9ed8dcafdc635302e02", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/05821e7c0d36e2552716c9ed8dcafdc635302e02", "committedDate": "2020-02-28T18:11:44Z", "message": "DDF-5793 only default drawing buffer for line and change error message for brevity"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74680376f33b0caf1de479abbea737d611fe6039", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/74680376f33b0caf1de479abbea737d611fe6039", "committedDate": "2020-02-28T18:24:04Z", "message": "DDF-5841 delete last coordinate to prevent stale coordinates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2decca30e9748dce772f8f3712bfb1ca819895c4", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/2decca30e9748dce772f8f3712bfb1ca819895c4", "committedDate": "2020-02-28T18:44:39Z", "message": "DDF-5793 formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f494618dd395b5e1e5ce7fde03895e85c27b09d4", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/f494618dd395b5e1e5ce7fde03895e85c27b09d4", "committedDate": "2020-02-28T21:31:33Z", "message": "DDF-5793 fix poly buffer logic and remove line error when set to 1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cefb365fa0f3302a13d48801598e80fb7b13afa4", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/cefb365fa0f3302a13d48801598e80fb7b13afa4", "committedDate": "2020-02-28T21:40:52Z", "message": "DDF-5793 formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MzkxNDg0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-367391484", "createdAt": "2020-03-02T17:37:32Z", "commit": {"oid": "cefb365fa0f3302a13d48801598e80fb7b13afa4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzODY4MTM2", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-353868136", "createdAt": "2020-02-05T16:41:14Z", "commit": {"oid": "f07d5c0275a2e8cbd8cb636c65b14e5ff7e8fb7a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0MToxNVrOFl-7XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0MToxNVrOFl-7XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3MjYzNw==", "bodyText": "The testValidity logic could be moved to a validateLineAndPolygon function in validation.js and this call could be replaced with validateGeo(mode, currentValue)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375372637", "createdAt": "2020-02-05T16:41:15Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,142 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateListOfPoints,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n-  }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n-  }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n-          <TextField\n-            label={label}\n-            value={this.state.value}\n-            onChange={value => {\n-              value = value.trim()\n-              if (value.includes('MULTI')) {\n-                value = this.convertMultiWkt(value.includes('POLYGON'), value)\n-              } else if (value.includes('POLYGON') && value.endsWith('))')) {\n-                value = this.convertWkt(value, 4)\n-              } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n-                value = this.convertWkt(value, 2)\n-              }\n-              this.setState({ value })\n-              const fn = cursor(geometryKey)\n-              try {\n-                fn(JSON.parse(value))\n-              } catch (e) {\n-                // do nothing\n-              }\n-            }}\n-            onBlur={() => this.isValidInput(this.state.value)}\n-            onFocus={value => {\n-              this.setState({ isValid: true })\n-            }}\n-          />\n-          <Units value={props[unitKey]} onChange={cursor(unitKey)}>\n-            <TextField\n-              type=\"number\"\n-              label=\"Buffer width\"\n-              min={0.000001}\n-              value={`${props[widthKey]}`}\n-              onChange={cursor(widthKey)}\n-            />\n-          </Units>\n-        </div>\n-        {this.state.isValid ? (\n-          ''\n-        ) : (\n-          <Invalid>\n-            &nbsp;\n-            <span className=\"fa fa-exclamation-triangle\" />\n-            &nbsp; {this.invalidMessage} &nbsp; &nbsp;\n-            <span className=\"fa fa-times\" onClick={this.removeErrorBox} />\n-          </Invalid>\n-        )}\n-      </React.Fragment>\n-    )\n-  }\n-  removeErrorBox() {\n-    this.setState({ isValid: true })\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  isValidInput(value) {\n-    this.invalidMessage = ''\n-    this.setState({ value, isValid: this.isValidPolygon(value) })\n-  }\n-  is2DArray(coordinates) {\n-    try {\n-      const parsedCoords = JSON.parse(coordinates)\n-      return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n-    } catch (e) {\n-      return false\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  validatePoint(point) {\n-    if (\n-      point.length !== 2 ||\n-      (Number.isNaN(Number.parseFloat(point[0])) &&\n-        Number.isNaN(Number.parseFloat(point[1])))\n-    ) {\n-      return JSON.stringify(point) + ' is not a valid point.'\n-    } else if (\n-      point[0] > 180 ||\n-      point[0] < -180 ||\n-      point[1] > 90 ||\n-      point[1] < -90\n-    ) {\n-      return JSON.stringify(point) + ' is not a valid point.'\n-    }\n-    return ''\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  validateListOfPoints(coordinates) {\n-    let message = ''\n-    const isLine = this.props.mode.includes('line')\n-    let numPoints = isLine ? 2 : 4\n-    if (!this.props.mode.includes('multi')) {\n-      if (coordinates.some(coords => coords.length > 2)) {\n-        message = ''\n-      } else if (coordinates.length < numPoints) {\n-        message = `Minimum of ${numPoints} points needed for ${\n-          isLine ? 'Line' : 'Polygon'\n-        }`\n-      }\n-    }\n-    for (let i = 0; i < coordinates.length; i++) {\n-      if (coordinates[i].length > 2) {\n-        coordinates[i].forEach(coordinate => {\n-          if (this.validatePoint(coordinate)) {\n-            message = this.validatePoint(coordinate)\n-          }\n-        })\n-      } else {\n-        if (this.props.mode.includes('multi')) {\n-          message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n-        } else if (this.validatePoint(coordinates[i])) {\n-          message = this.validatePoint(coordinates[i])\n-        }\n-      }\n-    }\n-    if (message !== '') {\n-      this.invalidMessage = message\n-      throw 'Invalid coordinates.'\n-    }\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+function is2DArray(coordinates) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n   }\n-  isValidPolygon(coordinates) {\n-    if (!this.is2DArray(coordinates)) {\n-      this.invalidMessage = 'Not an acceptable value.'\n-      return false\n+}\n+\n+const BaseLine = props => {\n+  const { label, geometryKey, setState, unitKey, widthKey, mode } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey } = props\n+      setCurrentValue(JSON.stringify(props[geometryKey]))\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  function testValidity() {\n+    if (!is2DArray(currentValue)) {\n+      return { error: true, message: 'Not an acceptable value' }\n     }\n     try {\n-      this.validateListOfPoints(JSON.parse(coordinates))\n-      return true\n+      return validateListOfPoints(JSON.parse(currentValue), mode)\n     } catch (e) {\n-      return false\n+      //do nothing\n     }\n   }\n-  convertWkt(value, numCoords) {\n-    const coordinatePairs = value.match(coordinatePairRegex)\n-    if (!coordinatePairs || coordinatePairs.length < numCoords) {\n-      return value\n-    }\n-    const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n-    return `[[${coordinates.join('],[')}]]`\n-  }\n-  convertMultiWkt(isPolygon, value) {\n-    if (isPolygon && !value.endsWith(')))')) {\n-      return value\n-    } else if (!value.endsWith('))')) {\n-      return value\n-    }\n-    const splitter = isPolygon ? '))' : ')'\n-    const numPoints = isPolygon ? 4 : 2\n-    let shapes = value\n-      .split(splitter)\n-      .map(shape => shape.match(coordinatePairRegex))\n-    shapes = shapes\n-      .filter(shape => shape !== null && shape.length >= numPoints)\n-      .map(shape =>\n-        shape.map(coordinatePair => coordinatePair.replace(' ', ','))\n-      )\n-    return shapes.length === 0\n-      ? value\n-      : shapes.length === 1\n-        ? `[[${shapes[0].join('],[')}]]`\n-        : `[${shapes.map(shapeCoords => `[[${shapeCoords.join('],[')}]]`)}]`\n-  }\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState(geometryKey, undefined)\n+              } else {\n+                setState(geometryKey, JSON.parse(value))\n+              }\n+            } catch (e) {\n+              // do nothing\n+            }\n+          }}\n+          onBlur={() => setBaseLineError(testValidity())}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f07d5c0275a2e8cbd8cb636c65b14e5ff7e8fb7a"}, "originalPosition": 300}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzODcwOTk4", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-353870998", "createdAt": "2020-02-05T16:44:49Z", "commit": {"oid": "f07d5c0275a2e8cbd8cb636c65b14e5ff7e8fb7a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0NDo0OVrOFl_DxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNjo0NDo0OVrOFl_DxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3NDc4OQ==", "bodyText": "this and validateLatLon are functionally the same and could be combined", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375374789", "createdAt": "2020-02-05T16:44:49Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,326 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function hasPointError(point: any[]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f07d5c0275a2e8cbd8cb636c65b14e5ff7e8fb7a"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3abcbef3c16a5cca26709b97cb0adfb4f1381545", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/3abcbef3c16a5cca26709b97cb0adfb4f1381545", "committedDate": "2020-02-05T18:41:49Z", "message": "DDF-5793 anyGeo search validation refactor and UX improvements"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cf2f2382d5fcb32b0abcd622a5455292ed68341d", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/cf2f2382d5fcb32b0abcd622a5455292ed68341d", "committedDate": "2020-02-05T18:36:29Z", "message": "DDF-5793 fix keyword bug onBlur and add defensive code"}, "afterCommit": {"oid": "3abcbef3c16a5cca26709b97cb0adfb4f1381545", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/3abcbef3c16a5cca26709b97cb0adfb4f1381545", "committedDate": "2020-02-05T18:41:49Z", "message": "DDF-5793 anyGeo search validation refactor and UX improvements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzOTg4NjYy", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-353988662", "createdAt": "2020-02-05T19:39:35Z", "commit": {"oid": "3abcbef3c16a5cca26709b97cb0adfb4f1381545"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTozOTozNVrOFmEslg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTozOTozNVrOFmEslg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NzE1OA==", "bodyText": "this and the line above are the value of isNorthingInvalid", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375467158", "createdAt": "2020-02-05T19:39:35Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,326 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateLatLon(lat: string, lon: string) {\n+  const latitude = parseFloat(lat)\n+  const longitude = parseFloat(lon)\n+  return latitude > -90 && latitude < 90 && longitude > -180 && longitude < 180\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // casting to Number() will return NaN if it's not a number, i.e. \"3e\".\n+  //Except for empty string, which is why we have to do this check below\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  // isNaN will try to parse anything into a number\n+  // have to check this because parseFloat will be able to parse things with letters, i.e. \"12.3w\"\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsEasting)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the validate lat lon method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    validateLatLon(lat, lon) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+  if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  } else if (\n+    key === 'utmUpsNorthing' &&\n+    isNaN(utmUpsParts.northing) &&\n+    utmUpsNorthing !== undefined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abcbef3c16a5cca26709b97cb0adfb4f1381545"}, "originalPosition": 316}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzOTg5NDE1", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-353989415", "createdAt": "2020-02-05T19:40:43Z", "commit": {"oid": "3abcbef3c16a5cca26709b97cb0adfb4f1381545"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTo0MDo0M1rOFmEu0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxOTo0MDo0M1rOFmEu0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NzcyOA==", "bodyText": "same here with isEastingInvalid", "url": "https://github.com/codice/ddf/pull/5814#discussion_r375467728", "createdAt": "2020-02-05T19:40:43Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,326 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateLatLon(lat: string, lon: string) {\n+  const latitude = parseFloat(lat)\n+  const longitude = parseFloat(lon)\n+  return latitude > -90 && latitude < 90 && longitude > -180 && longitude < 180\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // casting to Number() will return NaN if it's not a number, i.e. \"3e\".\n+  //Except for empty string, which is why we have to do this check below\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  // isNaN will try to parse anything into a number\n+  // have to check this because parseFloat will be able to parse things with letters, i.e. \"12.3w\"\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsEasting)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the validate lat lon method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    validateLatLon(lat, lon) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+  if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  } else if (\n+    key === 'utmUpsNorthing' &&\n+    isNaN(utmUpsParts.northing) &&\n+    utmUpsNorthing !== undefined\n+  ) {\n+    error = { error: true, message: 'Northing value is invalid' }\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    isNaN(utmUpsParts.easting) &&\n+    utmUpsEasting !== undefined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abcbef3c16a5cca26709b97cb0adfb4f1381545"}, "originalPosition": 322}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58e7c720aad396a916fb2b424f9f372044f7af34", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/58e7c720aad396a916fb2b424f9f372044f7af34", "committedDate": "2020-02-05T19:45:55Z", "message": "DDF-5793 move validation out of base line and add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e2426cccff27d550bf3f4d7778b2d76ccb369d2", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/3e2426cccff27d550bf3f4d7778b2d76ccb369d2", "committedDate": "2020-02-05T20:39:30Z", "message": "DDF-5793 refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14552330ddb958b98a7ccc67e76dcf6460547363", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/14552330ddb958b98a7ccc67e76dcf6460547363", "committedDate": "2020-02-05T23:19:34Z", "message": "DDF-5793 prevent console errors by ensuring line and poly are arrays"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a8e87610d8ce1673cd9d5bfeb4d07cd6c85e3bd", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/0a8e87610d8ce1673cd9d5bfeb4d07cd6c85e3bd", "committedDate": "2020-02-05T23:43:01Z", "message": "DDF-5793 pull reused obj into a ocnstant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfcce8a79783be097b80763b5ba4a2d32aca8694", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/bfcce8a79783be097b80763b5ba4a2d32aca8694", "committedDate": "2020-02-06T19:40:31Z", "message": "DDF-5793 change setState para structure to comply with aoi"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33c47d16ef86299de054b606cfbee45770f1edf1", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/33c47d16ef86299de054b606cfbee45770f1edf1", "committedDate": "2020-02-06T22:12:31Z", "message": "DDF-5793 fix utm ups validation logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a7c538cb7be7446e2a4a5b64e4033325487a011", "author": {"user": {"login": "hayleynorton", "name": "Hayley Norton"}}, "url": "https://github.com/codice/ddf/commit/5a7c538cb7be7446e2a4a5b64e4033325487a011", "committedDate": "2020-02-06T22:37:28Z", "message": "DDF-5793 fixed error messages not disappearing after drawing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/4500feb17d593406ad82091a503f13d2e998283f", "committedDate": "2020-02-06T22:41:58Z", "message": "DDF-5793 prevent empty buffer when drawing line"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjAwODYy", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356200862", "createdAt": "2020-02-10T19:26:33Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOToyNjozM1rOFnyoAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOToyNjozM1rOFnyoAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2ODIyNw==", "bodyText": "\u270f\ufe0f investigate need to pass in this", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377268227", "createdAt": "2020-02-10T19:26:33Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-old.js", "diffHunk": "@@ -235,14 +228,14 @@ module.exports = Backbone.AssociatedModel.extend({\n       this.set('locationType', 'utmUps')\n     }\n     this.drawing = false\n-    store.get('content').turnOffDrawing()\n+    store.get('content').turnOffDrawing(this)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjAyMTIz", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356202123", "createdAt": "2020-02-10T19:28:27Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOToyODoyOFrOFnyr0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOToyODoyOFrOFnyr0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2OTIwMQ==", "bodyText": "\u270f\ufe0f verify radius should be 0 and not ''", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377269201", "createdAt": "2020-02-10T19:28:28Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-serialization.js", "diffHunk": "@@ -98,15 +98,15 @@ const Point = {\n \n     return {\n       mode: 'circle',\n-      locationType: 'latlon',\n+      locationType: 'dd',\n       lat,\n       lon,\n       radius: width,\n       radiusUnits: unit,\n     }\n   },\n   'location->json': location => {\n-    const { lat = 0, lon = 0, radius = 1, radiusUnits = 'meters' } = location\n+    const { lat = '', lon = '', radius = 0, radiusUnits = 'meters' } = location", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjA3NzIx", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356207721", "createdAt": "2020-02-10T19:37:22Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTozNzoyMlrOFny9Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTozNzoyMlrOFny9Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI3MzYwNg==", "bodyText": "\u270f\ufe0f\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (!linePoints || !linePoints[0]) {\n          \n          \n            \n                if (!linePoints || linePoints[0] === undefined) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377273606", "createdAt": "2020-02-10T19:37:22Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/cesium.line.js", "diffHunk": "@@ -53,7 +53,7 @@ class LineRenderView extends GeometryRenderView {\n         json.lineWidth,\n         model.get('lineUnits')\n       ) || 1\n-    if (!linePoints) {\n+    if (!linePoints || !linePoints[0]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjEwNzc2", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356210776", "createdAt": "2020-02-10T19:42:08Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo0MjowOFrOFnzGWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo0MjowOFrOFnzGWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI3NTk5Mg==", "bodyText": "push changes to eliminate this function here", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377275992", "createdAt": "2020-02-10T19:42:08Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,128 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateLinePolygon,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjE3OTM2", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356217936", "createdAt": "2020-02-10T19:53:20Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo1MzoyMFrOFnzcWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo1MzoyMFrOFnzcWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4MTYyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        typeof setBufferState === 'function' ? setBufferState(unitKey, value) : setState({ [unitKey]: value })\n          \n          \n            \n                        typeof setBufferState === 'function' ? setBufferState({ [unitKey]: value }) : setState({ [unitKey]: value })", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377281627", "createdAt": "2020-02-10T19:53:20Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,128 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateLinePolygon,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const { label, geometryKey, setState, setBufferState, unitKey, widthKey, mode, polyType } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey } = props\n+      setCurrentValue(JSON.stringify(props[geometryKey]))\n+      if(props.drawing) {\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({[geometryKey]: undefined})\n+              } else {\n+                setState({[geometryKey]: JSON.parse(value)})\n+              }\n+            } catch (e) {\n+              // do nothing\n+            }\n+          }}\n+          onBlur={() => setBaseLineError(validateLinePolygon(currentValue, mode || polyType))}\n+        />\n+        {getErrorComponent(baseLineError)}\n+        <Units\n+          value={props[unitKey]}\n+          onChange={value => {\n+            typeof setBufferState === 'function' ? setBufferState(unitKey, value) : setState({ [unitKey]: value })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjIwNzA4", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356220708", "createdAt": "2020-02-10T19:57:32Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo1NzozM1rOFnzlBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo1NzozM1rOFnzlBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4Mzg0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          typeof setBufferState === 'function' ? setBufferState(widthKey, value) : setState({ [widthKey]: value })\n          \n          \n            \n                          typeof setBufferState === 'function' ? setBufferState({ [widthKey]: value }) : setState({ [widthKey]: value })", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377283844", "createdAt": "2020-02-10T19:57:33Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,128 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  validateLinePolygon,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const { label, geometryKey, setState, setBufferState, unitKey, widthKey, mode, polyType } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey } = props\n+      setCurrentValue(JSON.stringify(props[geometryKey]))\n+      if(props.drawing) {\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({[geometryKey]: undefined})\n+              } else {\n+                setState({[geometryKey]: JSON.parse(value)})\n+              }\n+            } catch (e) {\n+              // do nothing\n+            }\n+          }}\n+          onBlur={() => setBaseLineError(validateLinePolygon(currentValue, mode || polyType))}\n+        />\n+        {getErrorComponent(baseLineError)}\n+        <Units\n+          value={props[unitKey]}\n+          onChange={value => {\n+            typeof setBufferState === 'function' ? setBufferState(unitKey, value) : setState({ [unitKey]: value })\n+          }}\n+        >\n           <TextField\n-            label={label}\n-            value={this.state.value}\n+            type=\"number\"\n+            label=\"Buffer width\"\n+            value={String(props[widthKey])}\n             onChange={value => {\n-              value = value.trim()\n-              if (value.includes('MULTI')) {\n-                value = this.convertMultiWkt(value.includes('POLYGON'), value)\n-              } else if (value.includes('POLYGON') && value.endsWith('))')) {\n-                value = this.convertWkt(value, 4)\n-              } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n-                value = this.convertWkt(value, 2)\n-              }\n-              this.setState({ value })\n-              const fn = cursor(geometryKey)\n-              try {\n-                fn(JSON.parse(value))\n-              } catch (e) {\n-                // do nothing\n+              if (widthKey === 'lineWidth') {\n+                setBufferError(validateGeo('lineWidth', value))\n               }\n-            }}\n-            onBlur={() => this.isValidInput(this.state.value)}\n-            onFocus={value => {\n-              this.setState({ isValid: true })\n+              typeof setBufferState === 'function' ? setBufferState(widthKey, value) : setState({ [widthKey]: value })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 173}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjI0NzU5", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356224759", "createdAt": "2020-02-10T20:03:56Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowMzo1NlrOFnzw5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowMzo1NlrOFnzw5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4Njg4NQ==", "bodyText": "delete", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377286885", "createdAt": "2020-02-10T20:03:56Z", "author": {"login": "andrewzimmer"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +103,141 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(() => {\n+    console.log(props.drawing)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjI1ODY2", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356225866", "createdAt": "2020-02-10T20:05:44Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowNTo0NVrOFnzz7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowNTo0NVrOFnzz7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4NzY2MA==", "bodyText": "\u270f\ufe0f remove", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377287660", "createdAt": "2020-02-10T20:05:45Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +103,141 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(() => {\n+    console.log(props.drawing)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjI3Mjgy", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356227282", "createdAt": "2020-02-10T20:08:02Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowODowMlrOFnz4Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDowODowMlrOFnz4Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4ODczOQ==", "bodyText": "\u270f\ufe0f investigate converting getErrrorComponent to a functional component", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377288739", "createdAt": "2020-02-10T20:08:02Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +103,141 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(() => {\n+    console.log(props.drawing)\n+    if(props.drawing) {\n+      setDmsError(initialErrorStateWithDefault)\n+    }\n+  }, [props.dmsWest, props.dmsSouth, props.dmsEast, props.dmsNorth])\n+\n+  function validate(key, type, value) {\n+    const label =\n+      key.includes('East') || key.includes('West') ? 'dmsLon' : 'dmsLat'\n+    const { error, message, defaultValue } = validateGeo(label, value)\n+    if (type === 'blur') {\n+      setDmsError({\n+        error: value !== undefined && value.length === 0,\n+        message,\n+        defaultValue,\n+      })\n+    } else if (defaultValue) {\n+      setDmsError({\n+        error,\n+        message,\n+        defaultValue,\n+      })\n+    }\n+    defaultValue ? setState({[key]: defaultValue}) : setState({[key]: value})\n+  }\n+\n+  return (\n+    <div className=\"input-location\">\n+      <DmsLongitude\n+        label=\"West\"\n+        value={dmsWest}\n+        onChange={(value, type) => validate('dmsWest', type, value)}\n+      >\n+        <DirectionInput\n+          options={longitudeDirections}\n+          value={dmsWestDirection}\n+          onChange={value => setState({['dmsWestDirection']: value})}\n+        />\n+      </DmsLongitude>\n+      <DmsLatitude\n+        label=\"South\"\n+        value={dmsSouth}\n+        onChange={(value, type) => validate('dmsSouth', type, value)}\n+      >\n+        <DirectionInput\n+          options={latitudeDirections}\n+          value={dmsSouthDirection}\n+          onChange={value => setState({['dmsSouthDirection']: value})}\n+        />\n+      </DmsLatitude>\n+      <DmsLongitude\n+        label=\"East\"\n+        value={dmsEast}\n+        onChange={(value, type) => validate('dmsEast', type, value)}\n+      >\n+        <DirectionInput\n+          options={longitudeDirections}\n+          value={dmsEastDirection}\n+          onChange={value => setState({['dmsEastDirection']: value})}\n+        />\n+      </DmsLongitude>\n+      <DmsLatitude\n+        label=\"North\"\n+        value={dmsNorth}\n+        onChange={(value, type) => validate('dmsNorth', type, value)}\n+      >\n+        <DirectionInput\n+          options={latitudeDirections}\n+          value={dmsNorthDirection}\n+          onChange={value => setState({['dmsNorthDirection']: value})}\n+        />\n+      </DmsLatitude>\n+      {getErrorComponent(dmsError)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 210}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjMxODQz", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356231843", "createdAt": "2020-02-10T20:15:33Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoxNTozNFrOFn0Frg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoxNTozNFrOFn0Frg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5MjIwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      setBufferState={(key, value) => setState(key, value)}\n          \n          \n            \n                      setBufferState={(key, value) => setState({ [key]: value })}", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377292206", "createdAt": "2020-02-10T20:15:34Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/location.js", "diffHunk": "@@ -84,6 +55,7 @@ const inputs = plugin({\n           setState={({ value, ...data }) => {\n             setState({ keywordValue: value, ...data })\n           }}\n+          setBufferState={(key, value) => setState(key, value)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjM1NjU4", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356235658", "createdAt": "2020-02-10T20:22:12Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyMjoxMlrOFn0SBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyMjoxMlrOFn0SBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NTM2Ng==", "bodyText": "move function to this file?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377295366", "createdAt": "2020-02-10T20:22:12Z", "author": {"login": "andrewzimmer"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -13,8 +13,22 @@\n  *\n  **/\n \n+const React = require('react')\n import { InvalidSearchFormMessage } from '../../../component/announcement/CommonMessages'\n+import styled from 'styled-components'\n const announcement = require('../../../component/announcement/index.jsx')\n+const {\n+  validateInput,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjM2Nzk1", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356236795", "createdAt": "2020-02-10T20:24:08Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyNDowOVrOFn0VfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyNDowOVrOFn0VfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5NjI1Mg==", "bodyText": "\u270f\ufe0f rename or leave comment for significance of extra values", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377296252", "createdAt": "2020-02-10T20:24:09Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjM5NjA1", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356239605", "createdAt": "2020-02-10T20:28:45Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyODo0NlrOFn0eJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoyODo0NlrOFn0eJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5ODQ3MQ==", "bodyText": "can just return whatever validateListOfPoints returns\nalso, \u270f\ufe0f switch order of args for validateListOfPoints for consistency's sake", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377298471", "createdAt": "2020-02-10T20:28:46Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjQxMDc2", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356241076", "createdAt": "2020-02-10T20:31:11Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMToxMVrOFn0ihg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMToxMVrOFn0ihg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5OTU5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      (coord: any) => !coord || coord.toString().length == 0\n          \n          \n            \n                      (coord: any) => !coord || coord.toString().length === 0", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377299590", "createdAt": "2020-02-10T20:31:11Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 214}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjQyMzUx", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356242351", "createdAt": "2020-02-10T20:33:16Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMzoxNlrOFn0mSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMzoxNlrOFn0mSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMDU1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!bufferWidth || bufferWidth == 0) {\n          \n          \n            \n                  if (!bufferWidth || bufferWidth === 0) {\n          \n      \n    \n    \n  \n\nis this second check necessary though?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377300555", "createdAt": "2020-02-10T20:33:16Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 204}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjQyNjc3", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356242677", "createdAt": "2020-02-10T20:33:48Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMzo0OVrOFn0nPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozMzo0OVrOFn0nPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMDc5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    errors.add('Line buffer width must be greater than 0.000001')\n          \n          \n            \n                    errors.add('Line buffer width must be greater than 0')", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377300797", "createdAt": "2020-02-10T20:33:49Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 205}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjQyOTU1", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356242955", "createdAt": "2020-02-10T20:34:16Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNDoxN1rOFn0oFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNDoxN1rOFn0oFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTAxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    errors.add('Radius must be greater than 0.000001')\n          \n          \n            \n                    errors.add('Radius must be greater than 0')\n          \n      \n    \n    \n  \n\nsame for inline messages", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301012", "createdAt": "2020-02-10T20:34:17Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 210}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjQzMTMy", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356243132", "createdAt": "2020-02-10T20:34:33Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNDozM1rOFn0oiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNDozM1rOFn0oiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTEyOQ==", "bodyText": "\u270f\ufe0f\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      (coord: any) => !coord || coord.toString().length == 0\n          \n          \n            \n                      (coord: any) => !coord || coord.toString().length === 0", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301129", "createdAt": "2020-02-10T20:34:33Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 214}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjQ0MTA1", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356244105", "createdAt": "2020-02-10T20:36:13Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNjoxM1rOFn0rSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNjoxM1rOFn0rSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTgzMg==", "bodyText": "could pull filter.geojson.properties into a local variable since it's used in multiple places", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301832", "createdAt": "2020-02-10T20:36:13Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 186}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjQ0MzIw", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356244320", "createdAt": "2020-02-10T20:36:35Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNjozNVrOFn0r4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDozNjozNVrOFn0r4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwMTk4Ng==", "bodyText": "\u270f\ufe0f verify 0 is not an edge case for these guys", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377301986", "createdAt": "2020-02-10T20:36:35Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjQ4ODI1", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356248825", "createdAt": "2020-02-10T20:44:06Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0NDowNlrOFn05jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0NDowNlrOFn05jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNTQ4NQ==", "bodyText": "\u270f\ufe0f I think you can use parseFloat to avoid this ternary, because that gives you NaN  for a blank string", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377305485", "createdAt": "2020-02-10T20:44:06Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 289}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjQ5MzY0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356249364", "createdAt": "2020-02-10T20:45:00Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0NTowMFrOFn07Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0NTowMFrOFn07Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNTkwNg==", "bodyText": "\u270f\ufe0f can remove the second part of the ternary:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!bufferWidth || bufferWidth == 0) {\n          \n          \n            \n                  if (!bufferWidth) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377305906", "createdAt": "2020-02-10T20:45:00Z", "author": {"login": "willwill96"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 204}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjUxMDk3", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356251097", "createdAt": "2020-02-10T20:47:57Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0Nzo1N1rOFn1AgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0Nzo1N1rOFn1AgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNzI2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                (Number.isNaN(Number.parseFloat(point[0])) &&\n          \n          \n            \n                Number.isNaN(Number.parseFloat(point[0])) ||", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377307265", "createdAt": "2020-02-10T20:47:57Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 169}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjUxNTky", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356251592", "createdAt": "2020-02-10T20:48:40Z", "commit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0ODo0MFrOFn1CLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDo0ODo0MFrOFn1CLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNzY5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  message: label + 'cannot be less than 0.000001',\n          \n          \n            \n                  message: label + 'must be greater than 0',", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377307693", "createdAt": "2020-02-10T20:48:40Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,339 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export function validateLinePolygon(currentValue: string, mode: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode) \n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (!geometry.coordinates[0].length || geometry.coordinates[0].length < 4) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  // These checks are to ensure that we only mark a value as \"invalid\" \n+  // if the user has entered something already\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+   if (\n+    key === 'utmUpsNorthing' &&\n+    isNorthingInvalid && !isEastingInvalid\n+  ) {\n+    error = { error: true, message: 'Northing value is invalid' }\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    isEastingInvalid && !isNorthingInvalid\n+  ) {\n+    error = { error: true, message: 'Easting value is invalid' }\n+  } else if (\n+    isUps &&\n+    (!upsValidDistance(northing) || !upsValidDistance(easting))\n+  ) {\n+    error = { error: true, message: 'Invalid UPS distance' }\n+  } else if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  }\n+  return error\n+}\n+\n+function validateRadiusLineBuffer(key: string, value: string) {\n+  const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '\n+  if ((value !== undefined && value.length === 0) || Number(value) < 0.000001) {\n+    return {\n+      error: true,\n+      message: label + 'cannot be less than 0.000001',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4500feb17d593406ad82091a503f13d2e998283f"}, "originalPosition": 352}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f10b676a1596bd4e1e463af3c1a5af18f2f054a", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/5f10b676a1596bd4e1e463af3c1a5af18f2f054a", "committedDate": "2020-02-10T22:53:00Z", "message": "DDF-5793 format and refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/61f20c5e808783f71d91be9dd30437c4f33a2e82", "committedDate": "2020-02-11T15:18:53Z", "message": "DDF-5793 dont pass model into turnOffDrawing and add poly case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzU0ODY2", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356754866", "createdAt": "2020-02-11T15:32:15Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTozMjoxNlrOFoNn1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTozMjoxNlrOFoNn1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxMDU0OA==", "bodyText": "Do we want to do the same thing here as we did with turnOffDrawing and move the setting of attributes on the model to location-old to be consistent?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377710548", "createdAt": "2020-02-11T15:32:16Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/content/content.js", "diffHunk": "@@ -110,7 +110,11 @@ module.exports = Backbone.AssociatedModel.extend({\n   },\n   turnOnDrawing(model) {\n     this.set('drawing', true)\n+    model.set('drawing', true)\n     this.set('drawingModel', model)\n+    if (model.get('mode') === 'line' && !model.get('lineWidth')) {\n+      model.set('lineWidth', 1)\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzU5MDgy", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356759082", "createdAt": "2020-02-11T15:37:10Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTozNzoxMFrOFoN0eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTozNzoxMFrOFoN0eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxMzc4Ng==", "bodyText": "Is it really necessary to have this.drawing = false and this.set('drawing', false) here? If the goal of setting this.drawing was to affect the model, it obviously didn't achieve it since we also have to do this.set. I'm just not sure if that was the goal or if this.drawing serves another purpose", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377713786", "createdAt": "2020-02-11T15:37:10Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/component/location-old/location-old.js", "diffHunk": "@@ -235,14 +228,15 @@ module.exports = Backbone.AssociatedModel.extend({\n       this.set('locationType', 'utmUps')\n     }\n     this.drawing = false\n+    this.set('drawing', false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzY1MDk2", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356765096", "createdAt": "2020-02-11T15:44:04Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo0NDowNVrOFoOHRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo0NDowNVrOFoOHRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxODU5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  console.log(props.drawing)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377718599", "createdAt": "2020-02-11T15:44:05Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +106,149 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(\n+    () => {\n+      console.log(props.drawing)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzY4MDA0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356768004", "createdAt": "2020-02-11T15:47:19Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo0NzoyMFrOFoOP1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo0NzoyMFrOFoOP1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMDc5MA==", "bodyText": "Could we conditionally set label as a local variable in this function instead of passing it as a param (to keep consistent with the dms version of this function)?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377720790", "createdAt": "2020-02-11T15:47:20Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -30,22 +33,49 @@ const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n \n const minimumDifference = 0.0001\n \n-const BoundingBoxLatLon = props => {\n-  const { north, east, south, west, cursor } = props\n-\n-  const { mapEast, mapWest, mapSouth, mapNorth } = props\n-\n+const BoundingBoxLatLonDd = props => {\n+  const {\n+    north,\n+    east,\n+    south,\n+    west,\n+    setState,\n+    mapEast,\n+    mapWest,\n+    mapSouth,\n+    mapNorth,\n+  } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n   const westMax = parseFloat(mapEast) - minimumDifference\n   const eastMin = parseFloat(mapWest) + minimumDifference\n   const northMin = parseFloat(mapSouth) + minimumDifference\n   const southMax = parseFloat(mapNorth) - minimumDifference\n \n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+      }\n+    },\n+    [props.east, props.west, props.south, props.north]\n+  )\n+\n+  function onChangeDd(key, label, value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzY4NTI2", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356768526", "createdAt": "2020-02-11T15:47:55Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo0Nzo1NVrOFoORaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo0Nzo1NVrOFoORaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyMTE5Mw==", "bodyText": "for consistency with DD:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              function validate(key, type, value) {\n          \n          \n            \n              function onChangeDms(key, value, type) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377721193", "createdAt": "2020-02-11T15:47:55Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/bounding-box.js", "diffHunk": "@@ -74,34 +106,149 @@ const BoundingBoxLatLon = props => {\n       />\n       <TextField\n         label=\"North\"\n-        value={north}\n-        onChange={cursor('north')}\n+        value={north !== undefined ? String(north) : north}\n+        onChange={value => onChangeDd('north', 'lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', north))}\n         type=\"number\"\n         step=\"any\"\n         min={northMin || -90}\n         max={90}\n         addon=\"\u00b0\"\n       />\n+      {getErrorComponent(ddError)}\n+    </div>\n+  )\n+}\n+\n+const BoundingBoxLatLonDms = props => {\n+  const {\n+    dmsSouth,\n+    dmsNorth,\n+    dmsWest,\n+    dmsEast,\n+    dmsSouthDirection,\n+    dmsNorthDirection,\n+    dmsWestDirection,\n+    dmsEastDirection,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n+\n+  useEffect(\n+    () => {\n+      console.log(props.drawing)\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+      }\n+    },\n+    [props.dmsWest, props.dmsSouth, props.dmsEast, props.dmsNorth]\n+  )\n+\n+  function validate(key, type, value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzczMTM4", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356773138", "createdAt": "2020-02-11T15:53:10Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo1MzoxMFrOFoOeyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo1MzoxMFrOFoOeyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyNDYxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      <Menu value={mode} onChange={value => setState('mode', value)}>\n          \n          \n            \n                      <Menu value={mode} onChange={value => setState({ ['mode']: value })}>", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377724617", "createdAt": "2020-02-11T15:53:10Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/location.js", "diffHunk": "@@ -103,35 +75,20 @@ const DrawButton = ({ onDraw }) => (\n   </Button>\n )\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n-\n const Root = styled.div`\n   height: ${props => (props.isOpen ? 'auto' : props.theme.minimumButtonSize)};\n `\n \n const Component = CustomElements.registerReact('location')\n-let errors = false\n-let inValidInput = ''\n-let inValidKey = ''\n-let defaultCoord = ''\n const LocationInput = props => {\n-  const { mode, setState, cursor } = props\n+  const { mode, setState } = props\n   const input = inputs[mode] || {}\n   const { Component: Input = null } = input\n-  const removeErrorBox = () => {\n-    setState((errors = false))\n-  }\n   return (\n     <Root isOpen={input.label !== undefined}>\n       <Component>\n         <Dropdown label={input.label || 'Select Location Option'}>\n-          <Menu value={mode} onChange={cursor('mode')}>\n+          <Menu value={mode} onChange={value => setState('mode', value)}>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2Nzc2MTkx", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356776191", "createdAt": "2020-02-11T15:56:32Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo1NjozMlrOFoOoHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTo1NjozMlrOFoOoHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyNzAwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              function validate(key, type, value) {\n          \n          \n            \n              function onChangeDms(key, value, type) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377727006", "createdAt": "2020-02-11T15:56:32Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "diffHunk": "@@ -12,90 +12,213 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n const { Radio, RadioItem } = require('../radio')\n const TextField = require('../text-field')\n-\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+  initialErrorStateWithDefault,\n+} from '../utils/validation'\n const { Units, Zone, Hemisphere, MinimumSpacing } = require('./common')\n-\n const {\n   DmsLatitude,\n   DmsLongitude,\n } = require('../../component/location-new/geo-components/coordinates.js')\n const DirectionInput = require('../../component/location-new/geo-components/direction.js')\n const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n-import styled from 'styled-components'\n-\n-const ErrorBlock = styled.div`\n-  width: 100%;\n-  display: flex;\n-  flex-direction: row;\n-  justify-content: flex-start;\n-  align-items: center;\n-  background: ${({ theme }) => theme.negativeColor};\n-`\n-\n-const WarningIcon = styled.span`\n-  padding: ${({ theme }) => theme.minimumSpacing};\n-`\n-\n-const PointRadiusLatLon = props => {\n-  const { lat, lon, radius, radiusUnits, cursor } = props\n+\n+const PointRadiusLatLonDd = props => {\n+  const { lat, lon, radius, radiusUnits, setState } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.lat, props.lon, props.radius]\n+  )\n+\n+  function onChangeDd(key, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (defaultValue) {\n+      setDdError({ error, message, defaultValue })\n+      setState({ [key]: defaultValue })\n+    } else {\n+      setState({ [key]: value })\n+    }\n+  }\n+\n   return (\n     <div>\n       <TextField\n         type=\"number\"\n         label=\"Latitude\"\n-        value={lat}\n-        onChange={cursor('lat')}\n-        onBlur={props.callback}\n+        value={lat !== undefined ? String(lat) : lat}\n+        onChange={value => onChangeDd('lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', lat))}\n         addon=\"\u00b0\"\n       />\n       <TextField\n         type=\"number\"\n         label=\"Longitude\"\n-        value={lon}\n-        onChange={cursor('lon')}\n+        value={lon !== undefined ? String(lon) : lon}\n+        onChange={value => onChangeDd('lon', value)}\n+        onBlur={() => setDdError(validateGeo('lon', lon))}\n         addon=\"\u00b0\"\n       />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n+      {getErrorComponent(ddError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n         <TextField\n           type=\"number\"\n-          min=\"0\"\n           label=\"Radius\"\n-          value={radius}\n-          onChange={cursor('radius')}\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n         />\n       </Units>\n+      {getErrorComponent(radiusError)}\n     </div>\n   )\n }\n \n-const usngs = require('usng.js')\n-const converter = new usngs.Converter()\n+const PointRadiusLatLonDms = props => {\n+  const {\n+    dmsLat,\n+    dmsLon,\n+    dmsLatDirection,\n+    dmsLonDirection,\n+    radius,\n+    radiusUnits,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n \n-const PointRadiusUsngMgrs = props => {\n-  const { usng, radius, radiusUnits, cursor } = props\n-  let error = false\n-  try {\n-    const result = converter.USNGtoLL(usng, true)\n-    error = isNaN(result.lat) || isNaN(result.lon)\n-  } catch (err) {\n-    error = true\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.dmsLat, props.dmsLon, props.radius]\n+  )\n+\n+  function validate(key, type, value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzgyMDcy", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356782072", "createdAt": "2020-02-11T16:03:09Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjowMzoxMFrOFoO6WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjowMzoxMFrOFoO6WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczMTY3Mg==", "bodyText": "should type=\"number\" be added in here like all the other radius text fields?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377731672", "createdAt": "2020-02-11T16:03:10Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "diffHunk": "@@ -12,90 +12,213 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n const { Radio, RadioItem } = require('../radio')\n const TextField = require('../text-field')\n-\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+  initialErrorStateWithDefault,\n+} from '../utils/validation'\n const { Units, Zone, Hemisphere, MinimumSpacing } = require('./common')\n-\n const {\n   DmsLatitude,\n   DmsLongitude,\n } = require('../../component/location-new/geo-components/coordinates.js')\n const DirectionInput = require('../../component/location-new/geo-components/direction.js')\n const { Direction } = require('../../component/location-new/utils/dms-utils.js')\n-import styled from 'styled-components'\n-\n-const ErrorBlock = styled.div`\n-  width: 100%;\n-  display: flex;\n-  flex-direction: row;\n-  justify-content: flex-start;\n-  align-items: center;\n-  background: ${({ theme }) => theme.negativeColor};\n-`\n-\n-const WarningIcon = styled.span`\n-  padding: ${({ theme }) => theme.minimumSpacing};\n-`\n-\n-const PointRadiusLatLon = props => {\n-  const { lat, lon, radius, radiusUnits, cursor } = props\n+\n+const PointRadiusLatLonDd = props => {\n+  const { lat, lon, radius, radiusUnits, setState } = props\n+  const [ddError, setDdError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDdError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.lat, props.lon, props.radius]\n+  )\n+\n+  function onChangeDd(key, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (defaultValue) {\n+      setDdError({ error, message, defaultValue })\n+      setState({ [key]: defaultValue })\n+    } else {\n+      setState({ [key]: value })\n+    }\n+  }\n+\n   return (\n     <div>\n       <TextField\n         type=\"number\"\n         label=\"Latitude\"\n-        value={lat}\n-        onChange={cursor('lat')}\n-        onBlur={props.callback}\n+        value={lat !== undefined ? String(lat) : lat}\n+        onChange={value => onChangeDd('lat', value)}\n+        onBlur={() => setDdError(validateGeo('lat', lat))}\n         addon=\"\u00b0\"\n       />\n       <TextField\n         type=\"number\"\n         label=\"Longitude\"\n-        value={lon}\n-        onChange={cursor('lon')}\n+        value={lon !== undefined ? String(lon) : lon}\n+        onChange={value => onChangeDd('lon', value)}\n+        onBlur={() => setDdError(validateGeo('lon', lon))}\n         addon=\"\u00b0\"\n       />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n+      {getErrorComponent(ddError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n         <TextField\n           type=\"number\"\n-          min=\"0\"\n           label=\"Radius\"\n-          value={radius}\n-          onChange={cursor('radius')}\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n         />\n       </Units>\n+      {getErrorComponent(radiusError)}\n     </div>\n   )\n }\n \n-const usngs = require('usng.js')\n-const converter = new usngs.Converter()\n+const PointRadiusLatLonDms = props => {\n+  const {\n+    dmsLat,\n+    dmsLon,\n+    dmsLatDirection,\n+    dmsLonDirection,\n+    radius,\n+    radiusUnits,\n+    setState,\n+  } = props\n+  const [dmsError, setDmsError] = useState(initialErrorStateWithDefault)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+  const latitudeDirections = [Direction.North, Direction.South]\n+  const longitudeDirections = [Direction.East, Direction.West]\n \n-const PointRadiusUsngMgrs = props => {\n-  const { usng, radius, radiusUnits, cursor } = props\n-  let error = false\n-  try {\n-    const result = converter.USNGtoLL(usng, true)\n-    error = isNaN(result.lat) || isNaN(result.lon)\n-  } catch (err) {\n-    error = true\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setDmsError(initialErrorStateWithDefault)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.dmsLat, props.dmsLon, props.radius]\n+  )\n+\n+  function validate(key, type, value) {\n+    const { error, message, defaultValue } = validateGeo(key, value)\n+    if (type === 'blur') {\n+      setDmsError({\n+        error: value !== undefined && value.length === 0,\n+        message,\n+        defaultValue,\n+      })\n+    } else if (defaultValue) {\n+      setDmsError({\n+        error,\n+        message,\n+        defaultValue,\n+      })\n+    }\n+    defaultValue\n+      ? setState({ [key]: defaultValue })\n+      : setState({ [key]: value })\n   }\n+\n   return (\n     <div>\n-      <TextField label=\"USNG / MGRS\" value={usng} onChange={cursor('usng')} />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n-        <TextField label=\"Radius\" value={radius} onChange={cursor('radius')} />\n+      <DmsLatitude\n+        label=\"Latitude\"\n+        value={dmsLat}\n+        onChange={(value, type) => validate('dmsLat', type, value)}\n+      >\n+        <DirectionInput\n+          options={latitudeDirections}\n+          value={dmsLatDirection}\n+          onChange={value => setState({ ['dmsLatDirection']: value })}\n+        />\n+      </DmsLatitude>\n+      <DmsLongitude\n+        label=\"Longitude\"\n+        value={dmsLon}\n+        onChange={(value, type) => validate('dmsLon', type, value)}\n+      >\n+        <DirectionInput\n+          options={longitudeDirections}\n+          value={dmsLonDirection}\n+          onChange={value => setState({ ['dmsLonDirection']: value })}\n+        />\n+      </DmsLongitude>\n+      {getErrorComponent(dmsError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n+        <TextField\n+          label=\"Radius\"\n+          type=\"number\"\n+          value={String(radius)}\n+          onChange={value => {\n+            setRadiusError(validateGeo('radius', value))\n+            setState({ ['radius']: value })\n+          }}\n+        />\n       </Units>\n-      {error ? (\n-        <ErrorBlock>\n-          <WarningIcon className=\"fa fa-warning\" />\n-          <span>Invalid USNG / MGRS coords</span>\n-        </ErrorBlock>\n-      ) : null}\n+      {getErrorComponent(radiusError)}\n+    </div>\n+  )\n+}\n+\n+const PointRadiusUsngMgrs = props => {\n+  const { usng, radius, radiusUnits, setState } = props\n+  const [usngError, setUsngError] = useState(initialErrorState)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setUsngError(initialErrorState)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [props.usng, props.radius]\n+  )\n+\n+  return (\n+    <div>\n+      <TextField\n+        label=\"USNG / MGRS\"\n+        value={usng}\n+        onChange={value => setState({ ['usng']: value })}\n+        onBlur={() => setUsngError(validateGeo('usng', usng))}\n+      />\n+      {getErrorComponent(usngError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n+      >\n+        <TextField\n+          label=\"Radius\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 251}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2Nzg2MzM0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356786334", "createdAt": "2020-02-11T16:08:13Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjowODoxM1rOFoPG8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjowODoxM1rOFoPG8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNDg5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      label=\"Radius\"\n          \n          \n            \n                      type=\"number\"\n          \n          \n            \n                      label=\"Radius\"", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377734897", "createdAt": "2020-02-11T16:08:13Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/point-radius.js", "diffHunk": "@@ -108,85 +231,122 @@ const PointRadiusUtmUps = props => {\n     utmUpsHemisphere,\n     radius,\n     radiusUnits,\n-    cursor,\n+    setState,\n   } = props\n+  const [utmError, setUtmError] = useState(initialErrorState)\n+  const [radiusError, setRadiusError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      if (props.drawing) {\n+        setUtmError(initialErrorState)\n+        setRadiusError(initialErrorState)\n+      }\n+    },\n+    [\n+      props.utmUpsEasting,\n+      props.utmUpsNorthing,\n+      props.utmUpsZone,\n+      props.utmUpsHemisphere,\n+      props.radius,\n+    ]\n+  )\n+\n   return (\n     <div>\n       <TextField\n         label=\"Easting\"\n-        value={utmUpsEasting}\n-        onChange={cursor('utmUpsEasting')}\n+        value={\n+          utmUpsEasting !== undefined ? String(utmUpsEasting) : utmUpsEasting\n+        }\n+        onChange={value => setState({ ['utmUpsEasting']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsEasting',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n         addon=\"m\"\n       />\n       <TextField\n         label=\"Northing\"\n-        value={utmUpsNorthing}\n-        onChange={cursor('utmUpsNorthing')}\n+        value={\n+          utmUpsNorthing !== undefined ? String(utmUpsNorthing) : utmUpsNorthing\n+        }\n+        onChange={value => setState({ ['utmUpsNorthing']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsNorthing',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n         addon=\"m\"\n       />\n-      <Zone value={utmUpsZone} onChange={cursor('utmUpsZone')} />\n+      <Zone\n+        value={utmUpsZone}\n+        onChange={value => setState({ ['utmUpsZone']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsZone',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n+      />\n       <Hemisphere\n         value={utmUpsHemisphere}\n-        onChange={cursor('utmUpsHemisphere')}\n+        onChange={value => setState({ ['utmUpsHemisphere']: value })}\n+        onBlur={() =>\n+          setUtmError(\n+            validateGeo(\n+              'utmUpsHemisphere',\n+              utmUpsEasting,\n+              utmUpsNorthing,\n+              utmUpsZone,\n+              utmUpsHemisphere\n+            )\n+          )\n+        }\n       />\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n-        <TextField label=\"Radius\" value={radius} onChange={cursor('radius')} />\n-      </Units>\n-    </div>\n-  )\n-}\n-\n-const PointRadiusDms = props => {\n-  const {\n-    dmsLat,\n-    dmsLon,\n-    dmsLatDirection,\n-    dmsLonDirection,\n-    radius,\n-    radiusUnits,\n-    cursor,\n-  } = props\n-  const latitudeDirections = [Direction.North, Direction.South]\n-  const longitudeDirections = [Direction.East, Direction.West]\n-\n-  return (\n-    <div>\n-      <DmsLatitude label=\"Latitude\" value={dmsLat} onChange={cursor('dmsLat')}>\n-        <DirectionInput\n-          options={latitudeDirections}\n-          value={dmsLatDirection}\n-          onChange={cursor('dmsLatDirection')}\n-        />\n-      </DmsLatitude>\n-      <DmsLongitude\n-        label=\"Longitude\"\n-        value={dmsLon}\n-        onChange={cursor('dmsLon')}\n+      {getErrorComponent(utmError)}\n+      <Units\n+        value={radiusUnits}\n+        onChange={value => setState({ ['radiusUnits']: value })}\n       >\n-        <DirectionInput\n-          options={longitudeDirections}\n-          value={dmsLonDirection}\n-          onChange={cursor('dmsLonDirection')}\n-        />\n-      </DmsLongitude>\n-      <Units value={radiusUnits} onChange={cursor('radiusUnits')}>\n         <TextField\n           label=\"Radius\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 411}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzkzOTU0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356793954", "createdAt": "2020-02-11T16:17:02Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxNzowM1rOFoPdfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxNzowM1rOFoPdfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MDY2OQ==", "bodyText": "\u270f\ufe0f all caps variable names for constants", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377740669", "createdAt": "2020-02-11T16:17:03Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -13,8 +13,22 @@\n  *\n  **/\n \n+const React = require('react')\n import { InvalidSearchFormMessage } from '../../../component/announcement/CommonMessages'\n+import styled from 'styled-components'\n const announcement = require('../../../component/announcement/index.jsx')\n+const {\n+  validateInput,\n+} = require('../../../component/location-new/utils/dms-utils')\n+const usngs = require('usng.js')\n+const converter = new usngs.Converter()\n+const northingOffset = 10000000\n+const latitude = 'latitude'\n+const longitude = 'longitude'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2Nzk1NzQ5", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356795749", "createdAt": "2020-02-11T16:19:10Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxOToxMFrOFoPi6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxOToxMFrOFoPi6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MjA1OQ==", "bodyText": "\u270f\ufe0f arrow function", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377742059", "createdAt": "2020-02-11T16:19:10Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2Nzk1OTM4", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356795938", "createdAt": "2020-02-11T16:19:23Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxOToyM1rOFoPjZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoxOToyM1rOFoPjZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MjE4Mw==", "bodyText": "\u270f\ufe0f arrow function", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377742183", "createdAt": "2020-02-11T16:19:23Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODAwMTcy", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356800172", "createdAt": "2020-02-11T16:24:21Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoyNDoyMlrOFoPwHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjoyNDoyMlrOFoPwHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0NTQzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      message = JSON.stringify(coord) + ' is not a valid point.'\n          \n          \n            \n                      message = JSON.stringify(coord) + ' is not a valid point'", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377745439", "createdAt": "2020-02-11T16:24:22Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODEwNDky", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356810492", "createdAt": "2020-02-11T16:36:31Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNjozMVrOFoQPZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNjozMVrOFoQPZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1MzQ0NQ==", "bodyText": "There was some confusion on this when it first went in so I figured it'd be good to add a comment to explain it\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n          \n          \n            \n                    // Handle the case where the user has selected a \"multi\" mode but one or more shapes were invalid and therefore eliminated\n          \n          \n            \n                    // User should then be prompted to switch to the single-shape mode for the same shape\n          \n          \n            \n                    message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n          \n      \n    \n    \n  \n\nlet me know if that makes sense please \ud83d\ude04", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377753445", "createdAt": "2020-02-11T16:36:31Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODEwNjk0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356810694", "createdAt": "2020-02-11T16:36:46Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNjo0NlrOFoQQAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNjo0NlrOFoQQAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1MzYwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    message = JSON.stringify(coordinate) + ' is not a valid point.'\n          \n          \n            \n                    message = JSON.stringify(coordinate) + ' is not a valid point'", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377753600", "createdAt": "2020-02-11T16:36:46Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODExMjAw", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356811200", "createdAt": "2020-02-11T16:37:23Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNzoyM1rOFoQRgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjozNzoyM1rOFoQRgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1Mzk4NA==", "bodyText": "should just return what validateListOfPoints returns", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377753984", "createdAt": "2020-02-11T16:37:23Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODE2ODI0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356816824", "createdAt": "2020-02-11T16:44:12Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo0NDoxMlrOFoQixw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo0NDoxMlrOFoQixw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc1ODQwNw==", "bodyText": "is2DArray is also doing a JSON.parse of the currentValue, and in the catch it returns false, causing this function to return { error: true, message: 'Not an acceptable value' }. I think we should do the same thing here", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377758407", "createdAt": "2020-02-11T16:44:12Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODE5MDU2", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356819056", "createdAt": "2020-02-11T16:46:57Z", "commit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo0Njo1N1rOFoQpdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo0Njo1N1rOFoQpdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2MDExNg==", "bodyText": "\u270f\ufe0f could just make this one giant return statement", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377760116", "createdAt": "2020-02-11T16:46:57Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f20c5e808783f71d91be9dd30437c4f33a2e82"}, "originalPosition": 185}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f", "committedDate": "2020-02-11T16:47:44Z", "message": "DDF-5793 explictly check for undefined in arrays"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODI1MTIx", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356825121", "createdAt": "2020-02-11T16:54:21Z", "commit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo1NDoyMVrOFoQ8TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo1NDoyMVrOFoQ8TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2NDk0MA==", "bodyText": "\u2757\ufe0f The above code doesn't accept MultiPolygons but this will:\ncase 'Polygon':\n  if (geometry.coordinates[0].length < 4) {\n    // check for MultiPolygon\n    geometry.coordinates[0].forEach((shape: number[]) => {\n    if(shape.length < 4) {\n      errors.add(\n         'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n       )\n    }\n  })\n}\nbreak", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377764940", "createdAt": "2020-02-11T16:54:21Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 206}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODI5MDk2", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356829096", "createdAt": "2020-02-11T16:59:17Z", "commit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo1OToxN1rOFoRIxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNjo1OToxN1rOFoRIxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2ODEzNA==", "bodyText": "Since we're thinking about changing the error message to \"must be greater than 0\" should we also change this to 0?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!bufferWidth || bufferWidth < 0.000001) {\n          \n          \n            \n                  if (!bufferWidth || bufferWidth <= 0) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377768134", "createdAt": "2020-02-11T16:59:17Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODMwNzY0", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356830764", "createdAt": "2020-02-11T17:01:16Z", "commit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzowMToxN1rOFoRNsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzowMToxN1rOFoRNsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc2OTM5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              if ((value !== undefined && value.length === 0) || Number(value) < 0.000001) {\n          \n          \n            \n              if ((value !== undefined && value.length === 0) || Number(value) <= 0) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377769395", "createdAt": "2020-02-11T17:01:17Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  // These checks are to ensure that we only mark a value as \"invalid\"\n+  // if the user has entered something already\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n+  if (key === 'utmUpsNorthing' && isNorthingInvalid && !isEastingInvalid) {\n+    error = { error: true, message: 'Northing value is invalid' }\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    isEastingInvalid &&\n+    !isNorthingInvalid\n+  ) {\n+    error = { error: true, message: 'Easting value is invalid' }\n+  } else if (\n+    isUps &&\n+    (!upsValidDistance(northing) || !upsValidDistance(easting))\n+  ) {\n+    error = { error: true, message: 'Invalid UPS distance' }\n+  } else if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    error = { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  }\n+  return error\n+}\n+\n+function validateRadiusLineBuffer(key: string, value: string) {\n+  const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '\n+  if ((value !== undefined && value.length === 0) || Number(value) < 0.000001) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 354}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd2227d38d99ea6f832643553c2bb915d5da2cd8", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/cd2227d38d99ea6f832643553c2bb915d5da2cd8", "committedDate": "2020-02-11T17:12:39Z", "message": "DDF-5793 refactoring, cleanup, remove this.drawing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODQwNzc1", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356840775", "createdAt": "2020-02-11T17:14:23Z", "commit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNDoyM1rOFoRs0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNDoyM1rOFoRs0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzM2MA==", "bodyText": "\u270f\ufe0f could we switch the order of params here? I just like the concept of maintaining the same order for params that are shared across multiple functions and putting any extra params at the end\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n          \n          \n            \n            function validateDDLatLon(label: string, value: string, defaultCoord: number) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377777360", "createdAt": "2020-02-11T17:14:23Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 237}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODQxMzI3", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356841327", "createdAt": "2020-02-11T17:15:09Z", "commit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNTowOVrOFoRuXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNTowOVrOFoRuXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3Nzc1Ng==", "bodyText": "\u270f\ufe0f see https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(latitude, 90, value)\n          \n          \n            \n                  return validateDDLatLon(latitude, value, 90)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377777756", "createdAt": "2020-02-11T17:15:09Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODQxNTg4", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356841588", "createdAt": "2020-02-11T17:15:32Z", "commit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNTozMlrOFoRvKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoxNTozMlrOFoRvKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3Nzk2Mg==", "bodyText": "\u270f\ufe0f see https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(longitude, 180, value)\n          \n          \n            \n                  return validateDDLatLon(longitude, value, 180)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377777962", "createdAt": "2020-02-11T17:15:32Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODUxMjYw", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356851260", "createdAt": "2020-02-11T17:28:43Z", "commit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoyODo0M1rOFoSNPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzoyODo0M1rOFoSNPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4NTY2Mw==", "bodyText": "\u270f\ufe0f\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                (utmUpsNorthing === undefined || utmUpsEasting === undefined)\n          \n          \n            \n                utmUpsNorthing === undefined || \n          \n          \n            \n                utmUpsEasting === undefined", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377785663", "createdAt": "2020-02-11T17:28:43Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +52,344 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(function(msg) {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(function(err) {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(latitude, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(longitude, 180, value)\n+    case 'dmsLat':\n+      return validateDmsLatLon(latitude, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(longitude, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value, value1, value2, value3)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export function getErrorComponent(errorState: ErrorState) {\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point.'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point.'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    const pointsValid = validateListOfPoints(JSON.parse(currentValue), mode)\n+    return pointsValid === undefined ? initialErrorState : pointsValid\n+  } catch (e) {\n+    return initialErrorState\n+  }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    (Number.isNaN(Number.parseFloat(point[0])) &&\n+      Number.isNaN(Number.parseFloat(point[1])))\n+  ) {\n+    return true\n+  } else if (\n+    point[0] > 180 ||\n+    point[0] < -180 ||\n+    point[1] > 90 ||\n+    point[1] < -90\n+  ) {\n+    return true\n+  }\n+  return false\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const bufferWidth =\n+    filter.geojson.properties.buffer && filter.geojson.properties.buffer.width\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  switch (filter.geojson.properties.type) {\n+    case 'Polygon':\n+      if (\n+        !geometry.coordinates[0].length ||\n+        geometry.coordinates[0].length < 4\n+      ) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      }\n+      break\n+    case 'LineString':\n+      if (!geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      if (!bufferWidth || bufferWidth == 0) {\n+        errors.add('Line buffer width must be greater than 0.000001')\n+      }\n+      break\n+    case 'Point':\n+      if (!bufferWidth || bufferWidth < 0.000001) {\n+        errors.add('Radius must be greater than 0.000001')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length == 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const box = filter.geojson.properties\n+      if (!box.east || !box.west || !box.north || !box.south) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateDDLatLon(label: string, defaultCoord: number, value: string) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === latitude ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (validateInput(value, validator) !== value) {\n+    defaultValue = validateInput(value, validator)\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(\n+  key: string,\n+  utmUpsEasting: string,\n+  utmUpsNorthing: string,\n+  zoneNumber: any,\n+  hemisphere: any\n+) {\n+  let error = { error: false, message: '' }\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+  }\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  const isUps = zoneNumber === 0\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  utmUpsParts.northing =\n+    isUps || northernHemisphere ? northing : northing - northingOffset\n+  // These checks are to ensure that we only mark a value as \"invalid\"\n+  // if the user has entered something already\n+  const isNorthingInvalid =\n+    isNaN(utmUpsParts.northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid =\n+    isNaN(utmUpsParts.easting) && utmUpsEasting !== undefined\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    (utmUpsNorthing === undefined || utmUpsEasting === undefined)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 332}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODczNjMz", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356873633", "createdAt": "2020-02-11T18:01:29Z", "commit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowMTozMFrOFoTR5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowMTozMFrOFoTR5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzIzOQ==", "bodyText": "turns out we don't actually need to maintain state for the current value, so this can be removed", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377803239", "createdAt": "2020-02-11T18:01:30Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,142 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  getErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  return value\n+}\n+\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n+  }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a8256ce29f4b8c77cd348bcc36643c7ea06ac8f"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b6918c636c3a673913fe6da7595f9a4c40761a8", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/6b6918c636c3a673913fe6da7595f9a4c40761a8", "committedDate": "2020-02-11T18:03:22Z", "message": "DDF-5793 address comments and move dms validation into validation file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0c29e4c4da856d792d79c77d379516665cee4c1", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/c0c29e4c4da856d792d79c77d379516665cee4c1", "committedDate": "2020-02-11T19:15:46Z", "message": "DDF-5793 rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a1e42ba11a599cf7e2beea9d53a9be58c1e3c2f", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/0a1e42ba11a599cf7e2beea9d53a9be58c1e3c2f", "committedDate": "2020-02-11T19:55:39Z", "message": "DDF-5793 small refactors and string changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbb71c6f784d8b3225a867dba4c2686236d6918b", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/dbb71c6f784d8b3225a867dba4c2686236d6918b", "committedDate": "2020-02-11T19:56:46Z", "message": "DDF-5793 formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cbe3ae229717f43a32b63c40b193cd6e33739c5", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/1cbe3ae229717f43a32b63c40b193cd6e33739c5", "committedDate": "2020-02-11T20:08:39Z", "message": "Apply suggestions from code review\n\nCo-Authored-By: Hayley Norton <39737329+hayleynorton@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2OTY0Njgw", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356964680", "createdAt": "2020-02-11T20:18:53Z", "commit": {"oid": "1cbe3ae229717f43a32b63c40b193cd6e33739c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoxODo1NFrOFoXqgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoxODo1NFrOFoXqgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTA3Mw==", "bodyText": "if you end up going with this change https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(LATITUDE, 90, value)\n          \n          \n            \n                  return validateDDLatLon(LATITUDE, value, 90)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377875073", "createdAt": "2020-02-11T20:18:54Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +49,444 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, 90, value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cbe3ae229717f43a32b63c40b193cd6e33739c5"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2OTY1Mzg1", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-356965385", "createdAt": "2020-02-11T20:20:00Z", "commit": {"oid": "1cbe3ae229717f43a32b63c40b193cd6e33739c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoyMDowMVrOFoXslg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoyMDowMVrOFoXslg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTYwNg==", "bodyText": "if you end up going with this change https://github.com/codice/ddf/pull/5814/files#r377777360\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return validateDDLatLon(LONGITUDE, 180, value)\n          \n          \n            \n                  return validateDDLatLon(LONGITUDE, value, 180)", "url": "https://github.com/codice/ddf/pull/5814#discussion_r377875606", "createdAt": "2020-02-11T20:20:01Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +49,444 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(\n+  key: string,\n+  value: string,\n+  value1?: any,\n+  value2?: any,\n+  value3?: any\n+) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, 90, value)\n+    case 'lon':\n+      return validateDDLatLon(LONGITUDE, 180, value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cbe3ae229717f43a32b63c40b193cd6e33739c5"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4eaa55e2bd48aa62ccfe1df9743bed4467ccad1e", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/4eaa55e2bd48aa62ccfe1df9743bed4467ccad1e", "committedDate": "2020-02-11T21:31:25Z", "message": "DDF-5793 make ErrorComponent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3f281688a16398afbe2caa3fc9cdbfb3b4a9f0e", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/c3f281688a16398afbe2caa3fc9cdbfb3b4a9f0e", "committedDate": "2020-02-11T21:33:02Z", "message": "DDF-5793 make ErrorComponent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78aa93f9ddf10d47c3c7e57533c9931a4c8227bb", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/78aa93f9ddf10d47c3c7e57533c9931a4c8227bb", "committedDate": "2020-02-11T21:43:58Z", "message": "DDF-5793 errorstate fixes and move model logic out of content.js"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c87f69d2c000de84cf09b17711ae2e31d46f267", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/3c87f69d2c000de84cf09b17711ae2e31d46f267", "committedDate": "2020-02-11T21:47:15Z", "message": "Apply suggestions from code review\n\nCo-Authored-By: Hayley Norton <39737329+hayleynorton@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83b014fb4c46cf8306113c2888f69e3f4e999b16", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/83b014fb4c46cf8306113c2888f69e3f4e999b16", "committedDate": "2020-02-11T22:47:56Z", "message": "DDF-5793 suport multipolygon validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "418b50ce3ebe9b09497f9d11d83c9ccca3569b9d", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/418b50ce3ebe9b09497f9d11d83c9ccca3569b9d", "committedDate": "2020-02-11T23:19:11Z", "message": "DDF-5793 explictly check for empty/undefined bbox"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6ba413a9f606b6c99149d46f1bf59a834c0db56", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/b6ba413a9f606b6c99149d46f1bf59a834c0db56", "committedDate": "2020-02-12T15:30:46Z", "message": "DDF-5793 Merge branch 'DDF-5793-radius-ux-219' of github.com:cassandrabailey293/ddf into DDF-5793-radius-ux-219"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ca72b69e218e778a0c6e25c6124fe9f1f3afb61", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/0ca72b69e218e778a0c6e25c6124fe9f1f3afb61", "committedDate": "2020-02-12T15:31:43Z", "message": "DDF-5793 change equality logic to account for message array"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fca34e8929bda8989eb50b92bfbcd0ce59fcce2", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/8fca34e8929bda8989eb50b92bfbcd0ce59fcce2", "committedDate": "2020-02-12T15:47:17Z", "message": "DDF-5793 fix validation logic for line and radius width"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ce1e431fd9d3452f78e60b07c9439b2d716a714", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/6ce1e431fd9d3452f78e60b07c9439b2d716a714", "committedDate": "2020-02-12T17:11:26Z", "message": "DDF-5793 refactor utm ups params"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad5c7f47b8a0eb3b6ce65e09676e7ea8c0bb0fb4", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/ad5c7f47b8a0eb3b6ce65e09676e7ea8c0bb0fb4", "committedDate": "2020-02-12T18:01:38Z", "message": "DDF-5793 utmups validation refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e20740178ca264a9bf7b97099eb93e74f315d87", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/6e20740178ca264a9bf7b97099eb93e74f315d87", "committedDate": "2020-02-12T18:10:14Z", "message": "DDF-5793 add accidentally deleted function back and protect against negative values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "453380bdba970a6c6ee66a9a5bfe91d1b1e479c3", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/453380bdba970a6c6ee66a9a5bfe91d1b1e479c3", "committedDate": "2020-02-12T18:34:33Z", "message": "DDF-5793 formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2fb8a0b04b74e41438df08c895f5e54ead426e5", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/e2fb8a0b04b74e41438df08c895f5e54ead426e5", "committedDate": "2020-02-12T22:04:10Z", "message": "DDF-5793 default linewidth and allow invalid values in model to do proper validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/7869c022fc1f53cc403556db3270b1cd78a0acd4", "committedDate": "2020-02-13T00:28:45Z", "message": "DDF-5793 move geo filter check earlier to fix non geo searches"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MzQ2NDM3", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-358346437", "createdAt": "2020-02-13T16:07:46Z", "commit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowNzo0N1rOFpZ1aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowNzo0N1rOFpZ1aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTIwOQ==", "bodyText": "\u2753 do we want to correct possible negative inputs here?", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378959209", "createdAt": "2020-02-13T16:07:47Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,146 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(typeof(props[geometryKey]) === 'string' ? props[geometryKey] : JSON.stringify(props[geometryKey]))\n+      if (props.drawing) {\n+        if(lineWidth === undefined || Number(lineWidth) === 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MzQ2Nzkx", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-358346791", "createdAt": "2020-02-13T16:08:11Z", "commit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowODoxMVrOFpZ2Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowODoxMVrOFpZ2Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTQ1NQ==", "bodyText": "Maybe something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          // do nothing\n          \n          \n            \n                          // Set state with invalid value to trigger error messaging", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378959455", "createdAt": "2020-02-13T16:08:11Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/location/base.line.js", "diffHunk": "@@ -12,204 +12,146 @@\n  * <http://www.gnu.org/licenses/lgpl.html>.\n  *\n  **/\n-const React = require('react')\n-\n+import React, { useState, useEffect } from 'react'\n+import {\n+  ErrorComponent,\n+  validateGeo,\n+  initialErrorState,\n+} from '../utils/validation'\n const { Units } = require('./common')\n const TextField = require('../text-field')\n-import styled from 'styled-components'\n \n const coordinatePairRegex = /-?\\d{1,3}(\\.\\d*)?\\s-?\\d{1,3}(\\.\\d*)?/g\n \n-const Invalid = styled.div`\n-  background-color: ${props => props.theme.negativeColor};\n-  height: 100%;\n-  display: block;\n-  overflow: hidden;\n-  color: white;\n-`\n+function buildWktString(coordinates) {\n+  return '[[' + coordinates.join('],[') + ']]'\n+}\n+\n+function convertWktString(value) {\n+  if (value.includes('MULTI')) {\n+    return convertMultiWkt(value.includes('POLYGON'), value)\n+  } else if (value.includes('POLYGON') && value.endsWith('))')) {\n+    return convertWkt(value, 4)\n+  } else if (value.includes('LINESTRING') && value.endsWith(')')) {\n+    return convertWkt(value, 2)\n+  }\n+  return value\n+}\n \n-class BaseLine extends React.Component {\n-  invalidMessage = ''\n-  constructor(props) {\n-    super(props)\n-    const { geometryKey } = props\n-    const value = JSON.stringify(props[geometryKey])\n-    this.state = { value, isValid: true }\n-    this.state.isValid = true\n-    this.is2DArray = this.is2DArray.bind(this)\n-    this.validateListOfPoints = this.validateListOfPoints.bind(this)\n-    this.isValidPolygon = this.isValidPolygon.bind(this)\n-    this.isValidInput = this.isValidInput.bind(this)\n-    this.removeErrorBox = this.removeErrorBox.bind(this)\n+function convertWkt(value, numCoords) {\n+  const coordinatePairs = value.match(coordinatePairRegex)\n+  if (!coordinatePairs || coordinatePairs.length < numCoords) {\n+    return value\n   }\n-  componentWillReceiveProps(props) {\n-    if (document.activeElement !== this.ref) {\n-      const { geometryKey } = props\n-      const value = JSON.stringify(props[geometryKey])\n-      this.setState({ value })\n-    }\n+  const coordinates = coordinatePairs.map(coord => coord.replace(' ', ','))\n+  return buildWktString(coordinates)\n+}\n+\n+function convertMultiWkt(isPolygon, value) {\n+  if (isPolygon && !value.endsWith(')))')) {\n+    return value\n+  } else if (!value.endsWith('))')) {\n+    return value\n   }\n-  render() {\n-    const props = this.props\n-    const { label, cursor, geometryKey, unitKey, widthKey } = props\n-    return (\n-      <React.Fragment>\n-        <div className=\"input-location\">\n+  const splitter = isPolygon ? '))' : ')'\n+  const numPoints = isPolygon ? 4 : 2\n+  let shapes = value\n+    .split(splitter)\n+    .map(shape => shape.match(coordinatePairRegex))\n+  shapes = shapes\n+    .filter(shape => shape !== null && shape.length >= numPoints)\n+    .map(shape => shape.map(coordinatePair => coordinatePair.replace(' ', ',')))\n+  return shapes.length === 0\n+    ? value\n+    : shapes.length === 1\n+      ? buildWktString(shapes[0])\n+      : '[' + shapes.map(shapeCoords => buildWktString(shapeCoords)) + ']'\n+}\n+\n+const BaseLine = props => {\n+  const {\n+    label,\n+    geometryKey,\n+    setState,\n+    setBufferState,\n+    unitKey,\n+    widthKey,\n+    mode,\n+    polyType,\n+  } = props\n+  const [currentValue, setCurrentValue] = useState(\n+    JSON.stringify(props[geometryKey])\n+  )\n+  const [baseLineError, setBaseLineError] = useState(initialErrorState)\n+  const [bufferError, setBufferError] = useState(initialErrorState)\n+\n+  useEffect(\n+    () => {\n+      const { geometryKey, lineWidth } = props\n+      setCurrentValue(typeof(props[geometryKey]) === 'string' ? props[geometryKey] : JSON.stringify(props[geometryKey]))\n+      if (props.drawing) {\n+        if(lineWidth === undefined || Number(lineWidth) === 0) {\n+          setState({ [widthKey]: 1 })\n+        }\n+        setBaseLineError(initialErrorState)\n+        setBufferError(initialErrorState)\n+      }\n+    },\n+    [props.polygon, props.line]\n+  )\n+\n+  return (\n+    <div>\n+      <div className=\"input-location\">\n+        <TextField\n+          label={label}\n+          value={currentValue}\n+          onChange={value => {\n+            value = convertWktString(value.trim())\n+            setCurrentValue(value)\n+            try {\n+              //handle case where user clears input; JSON.parse('') would throw an error and maintain previous state\n+              if (value === '') {\n+                setState({ [geometryKey]: undefined })\n+              } else {\n+                setState({ [geometryKey]: JSON.parse(value) })\n+              }\n+            } catch (e) {\n+              // do nothing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Mzc3NzQ3", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-358377747", "createdAt": "2020-02-13T16:44:23Z", "commit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0NDoyNFrOFpbRhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0NDoyNFrOFpbRhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4Mjc4OQ==", "bodyText": "\u270f\ufe0f just to match the label of the text field\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '\n          \n          \n            \n              const label = key === 'lineWidth' ? 'Buffer width' : 'Radius '", "url": "https://github.com/codice/ddf/pull/5814#discussion_r378982789", "createdAt": "2020-02-13T16:44:24Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/react-component/utils/validation/validation.tsx", "diffHunk": "@@ -38,31 +45,445 @@ export function showErrorMessages(errors: any) {\n }\n \n export function getFilterErrors(filters: any) {\n-  const errors: any[] = []\n+  const errors = new Set()\n+  let geometryErrors = new Set<string>()\n   for (let i = 0; i < filters.length; i++) {\n     const filter = filters[i]\n-    const geometry = filter.geojson && filter.geojson.geometry\n-    if (\n-      geometry &&\n-      geometry.type === 'Polygon' &&\n-      geometry.coordinates[0].length < 4\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body:\n-          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]',\n-      })\n-    }\n-    if (\n-      geometry &&\n-      geometry.type === 'LineString' &&\n-      geometry.coordinates.length < 2\n-    ) {\n-      errors.push({\n-        title: 'Invalid geometry filter',\n-        body: 'Line coordinates must be in the form [[x,y],[x,y], ... ]',\n+    getGeometryErrors(filter).forEach(msg => {\n+      geometryErrors.add(msg)\n+    })\n+  }\n+  geometryErrors.forEach(err => {\n+    errors.add({\n+      title: 'Invalid geometry filter',\n+      body: err,\n+    })\n+  })\n+  return Array.from(errors)\n+}\n+\n+export function validateGeo(key: string, value: any) {\n+  switch (key) {\n+    case 'lat':\n+      return validateDDLatLon(LATITUDE, value, 90)\n+    case 'lon':\n+      return validateDDLatLon(LONGITUDE, value, 180)\n+    case 'dmsLat':\n+      return validateDmsLatLon(LATITUDE, value)\n+    case 'dmsLon':\n+      return validateDmsLatLon(LONGITUDE, value)\n+    case 'usng':\n+      return validateUsng(value)\n+    case 'utmUpsEasting':\n+    case 'utmUpsNorthing':\n+    case 'utmUpsZone':\n+    case 'utmUpsHemisphere':\n+      return validateUtmUps(key, value)\n+    case 'radius':\n+    case 'lineWidth':\n+      return validateRadiusLineBuffer(key, value)\n+    case 'line':\n+    case 'poly':\n+    case 'polygon':\n+      return validateLinePolygon(key, value)\n+    default:\n+  }\n+}\n+\n+export const ErrorComponent = (props: any) => {\n+  const { errorState } = props\n+  return errorState.error ? (\n+    <Invalid>\n+      <WarningIcon className=\"fa fa-warning\" />\n+      <span>{errorState.message}</span>\n+    </Invalid>\n+  ) : null\n+}\n+\n+export function validateListOfPoints(coordinates: any[], mode: string) {\n+  let message = ''\n+  const isLine = mode.includes('line')\n+  const numPoints = isLine ? 2 : 4\n+  if (\n+    !mode.includes('multi') &&\n+    !coordinates.some(coords => coords.length > 2) &&\n+    coordinates.length < numPoints\n+  ) {\n+    message = `Minimum of ${numPoints} points needed for ${\n+      isLine ? 'Line' : 'Polygon'\n+    }`\n+  }\n+  coordinates.forEach(coordinate => {\n+    if (coordinate.length > 2) {\n+      coordinate.forEach((coord: any) => {\n+        if (hasPointError(coord))\n+          message = JSON.stringify(coord) + ' is not a valid point'\n       })\n+    } else {\n+      if (mode.includes('multi')) {\n+        // Handle the case where the user has selected a \"multi\" mode but\n+        // one or more shapes were invalid and therefore eliminated\n+        message = `Switch to ${isLine ? 'Line' : 'Polygon'}`\n+      } else if (hasPointError(coordinate)) {\n+        message = JSON.stringify(coordinate) + ' is not a valid point'\n+      }\n     }\n+  })\n+  return { error: message.length > 0, message }\n+}\n+\n+export const initialErrorState = {\n+  error: false,\n+  message: '',\n+}\n+\n+export const initialErrorStateWithDefault = {\n+  error: false,\n+  message: '',\n+  defaultValue: '',\n+}\n+\n+function is2DArray(coordinates: string) {\n+  try {\n+    const parsedCoords = JSON.parse(coordinates)\n+    return Array.isArray(parsedCoords) && Array.isArray(parsedCoords[0])\n+  } catch (e) {\n+    return false\n+  }\n+}\n+\n+function hasPointError(point: any[]) {\n+  if (\n+    point.length !== 2 ||\n+    Number.isNaN(Number.parseFloat(point[0])) ||\n+    Number.isNaN(Number.parseFloat(point[1]))\n+  ) {\n+    return true\n+  }\n+  return point[0] > 180 || point[0] < -180 || point[1] > 90 || point[1] < -90\n+}\n+\n+function getGeometryErrors(filter: any): Set<string> {\n+  const geometry = filter.geojson && filter.geojson.geometry\n+  const errors = new Set<string>()\n+  if (!geometry) {\n+    return errors\n+  }\n+  const properties = filter.geojson.properties\n+  const bufferWidth = properties.buffer && properties.buffer.width\n+  switch (properties.type) {\n+    case 'Polygon':\n+      if (!Array.isArray(geometry.coordinates[0]) || !geometry.coordinates[0].length) {\n+        errors.add(\n+          'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+        )\n+      } else if (geometry.coordinates[0].length < 4) {\n+        // check for MultiPolygon\n+        geometry.coordinates[0].forEach((shape: number[]) => {\n+          if (shape.length < 4) {\n+            errors.add(\n+              'Polygon coordinates must be in the form [[x,y],[x,y],[x,y],[x,y], ... ]'\n+            )\n+          }\n+        })\n+      }\n+      break\n+    case 'LineString':\n+      if (!Array.isArray(geometry.coordinates) || !geometry.coordinates.length || geometry.coordinates.length < 2) {\n+        errors.add('Line coordinates must be in the form [[x,y],[x,y], ... ]')\n+      }\n+      // Can't just check !bufferWidth because of the case of the string \"0\"\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Line buffer width must be greater than 0')\n+      }\n+      break\n+    case 'Point':\n+      if (bufferWidth === undefined || Number(bufferWidth) <= 0) {\n+        errors.add('Radius must be greater than 0')\n+      }\n+      if (\n+        geometry.coordinates.some(\n+          (coord: any) => !coord || coord.toString().length === 0\n+        )\n+      ) {\n+        errors.add('Coordinates must not be empty')\n+      }\n+      break\n+    case 'BoundingBox':\n+      const { east, west, north, south } = filter.geojson.properties\n+      if (\n+        [east, west, north, south].some(\n+          direction => direction === '' || direction === undefined\n+        )\n+      ) {\n+        errors.add('Bounding box must have valid values')\n+      }\n+      break\n   }\n   return errors\n }\n+\n+function validateLinePolygon(mode: string, currentValue: string) {\n+  if (!is2DArray(currentValue)) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+  try {\n+    return validateListOfPoints(JSON.parse(currentValue), mode)\n+  } catch (e) {\n+    return { error: true, message: 'Not an acceptable value' }\n+  }\n+}\n+\n+function validateDDLatLon(label: string, value: string, defaultCoord: number) {\n+  let message = ''\n+  let defaultValue\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  if (Number(value) > defaultCoord || Number(value) < -1 * defaultCoord) {\n+    defaultValue = Number(value) > 0 ? defaultCoord : -1 * defaultCoord\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateDmsLatLon(label: string, value: string) {\n+  let message = ''\n+  let defaultValue\n+  const validator = label === LATITUDE ? 'dd\u00b0mm\\'ss.s\"' : 'ddd\u00b0mm\\'ss.s\"'\n+  if (value !== undefined && value.length === 0) {\n+    message = getEmptyErrorMessage(label)\n+    return { error: true, message, defaultValue }\n+  }\n+  const dmsValidation = validateDmsInput(value, validator)\n+  if (dmsValidation.error) {\n+    defaultValue = dmsValidation.defaultValue\n+    message = getDefaultingErrorMessage(value, label, defaultValue)\n+    return { error: true, message, defaultValue }\n+  }\n+  return { error: false, message, defaultValue }\n+}\n+\n+function validateUsng(value: string) {\n+  if (value === '') {\n+    return { error: true, message: 'USNG / MGRS coordinates cannot be empty' }\n+  }\n+  const result = converter.USNGtoLL(value, true)\n+  const isInvalid = Number.isNaN(result.lat) || Number.isNaN(result.lon)\n+  return {\n+    error: isInvalid,\n+    message: isInvalid ? 'Invalid USNG / MGRS coordinates' : '',\n+  }\n+}\n+\n+function upsValidDistance(distance: number) {\n+  return distance >= 800000 && distance <= 3200000\n+}\n+\n+function validateUtmUps(key: string, value: any) {\n+  let { utmUpsEasting, utmUpsNorthing, zoneNumber, hemisphere } = value\n+  const northernHemisphere = hemisphere.toUpperCase() === 'NORTHERN'\n+  zoneNumber = Number.parseInt(zoneNumber)\n+  const isUps = zoneNumber === 0\n+  let error = { error: false, message: '' }\n+  // Number('') returns 0, so we can't just blindly cast to number\n+  // since we want to differentiate '' from 0\n+  let easting = utmUpsEasting === '' ? NaN : Number(utmUpsEasting)\n+  let northing = utmUpsNorthing === '' ? NaN : Number(utmUpsNorthing)\n+  const isNorthingInvalid = isNaN(northing) && utmUpsNorthing !== undefined\n+  const isEastingInvalid = isNaN(easting) && utmUpsEasting !== undefined\n+  if (!isNaN(easting)) {\n+    easting = Number.parseFloat(utmUpsEasting)\n+  } else if (\n+    key === 'utmUpsEasting' &&\n+    utmUpsEasting !== undefined &&\n+    !isNorthingInvalid\n+  ) {\n+    return { error: true, message: 'Easting value is invalid' }\n+  }\n+  if (!isNaN(northing)) {\n+    northing = Number.parseFloat(utmUpsNorthing)\n+    northing =\n+      isUps || northernHemisphere ? northing : northing - NORTHING_OFFSET\n+  } else if (\n+    key === 'utmUpsNorthing' &&\n+    utmUpsNorthing !== undefined &&\n+    !isEastingInvalid\n+  ) {\n+    return { error: true, message: 'Northing value is invalid' }\n+  }\n+  if (isUps && (!upsValidDistance(northing) || !upsValidDistance(easting))) {\n+    return { error: true, message: 'Invalid UPS distance' }\n+  }\n+  const utmUpsParts = {\n+    easting,\n+    northing,\n+    zoneNumber,\n+    hemisphere,\n+    northPole: northernHemisphere,\n+  }\n+  // These checks are to ensure that we only mark a value as \"invalid\"\n+  // if the user has entered something already\n+  let { lat, lon } = converter.UTMUPStoLL(utmUpsParts)\n+  lon = lon % 360\n+  if (lon < -180) {\n+    lon = lon + 360\n+  }\n+  if (lon > 180) {\n+    lon = lon - 360\n+  }\n+  // we want to validate using the hasPointError method, but only if they're both defined\n+  // if one or more is undefined, we want to return true\n+  const isLatLonValid =\n+    !hasPointError([lon, lat]) ||\n+    utmUpsNorthing === undefined ||\n+    utmUpsEasting === undefined\n+  if ((isNorthingInvalid && isEastingInvalid) || !isLatLonValid) {\n+    return { error: true, message: 'Invalid UTM/UPS coordinates' }\n+  }\n+  return error\n+}\n+\n+function validateRadiusLineBuffer(key: string, value: string) {\n+  const label = key === 'lineWidth' ? 'Buffer ' : 'Radius '", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7869c022fc1f53cc403556db3270b1cd78a0acd4"}, "originalPosition": 343}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0d37cd5a18c4222c764bbca3ee332064d79b8ab", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/d0d37cd5a18c4222c764bbca3ee332064d79b8ab", "committedDate": "2020-02-13T18:15:29Z", "message": "DDF-5793 fix validation for line and polygon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ba685089da419b6aa2aecf2d7cc1a17ec7380e9", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/3ba685089da419b6aa2aecf2d7cc1a17ec7380e9", "committedDate": "2020-02-13T19:33:19Z", "message": "DDF-5793 allow undefined for dms"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f3059bc7d31f3ad3e60d69636d856b0ab3c26b9", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/3f3059bc7d31f3ad3e60d69636d856b0ab3c26b9", "committedDate": "2020-02-13T19:51:06Z", "message": "DDF-5793 fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df22a1f466fb25f096c416eae40d1508289f7038", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/df22a1f466fb25f096c416eae40d1508289f7038", "committedDate": "2020-02-13T20:05:28Z", "message": "DDF-5793 usng allow undefined"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "822082b1164f1574d78d7b9b3837603bd7e6250e", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/822082b1164f1574d78d7b9b3837603bd7e6250e", "committedDate": "2020-02-13T20:39:41Z", "message": "DDF-5793 only set default buffer width for line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5", "author": {"user": null}, "url": "https://github.com/codice/ddf/commit/a3e38d57c2fa20caef917599a5833cea3d52eca5", "committedDate": "2020-02-13T20:47:39Z", "message": "DDF-5793 fix input to validate geo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTQ2NTY4", "url": "https://github.com/codice/ddf/pull/5814#pullrequestreview-358546568", "createdAt": "2020-02-13T20:59:19Z", "commit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo1OToxOVrOFpjWeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo1OToxOVrOFpjWeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNTEyOA==", "bodyText": "\u2757\ufe0f with polygon here, the error is true for lines with 3 or less points because A minimum of 4 points needed for polygon and the shape won't be drawn on the map\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (polygon !== undefined && !validateGeo('polygon', JSON.stringify(polygon.getCoordinates())).error) {\n          \n          \n            \n                if (polygon !== undefined && !validateGeo('line', JSON.stringify(polygon.getCoordinates())).error) {", "url": "https://github.com/codice/ddf/pull/5814#discussion_r379115128", "createdAt": "2020-02-13T20:59:19Z", "author": {"login": "hayleynorton"}, "path": "ui/packages/catalog-ui-search/src/main/webapp/js/widgets/openlayers.line.js", "diffHunk": "@@ -97,14 +98,14 @@ Draw.LineView = Marionette.View.extend({\n   updatePrimitive(model) {\n     const polygon = this.modelToPolygon(model)\n     // make sure the current model has width and height before drawing\n-    if (polygon && !_.isUndefined(polygon)) {\n+    if (polygon !== undefined && !validateGeo('polygon', JSON.stringify(polygon.getCoordinates())).error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e38d57c2fa20caef917599a5833cea3d52eca5"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4993, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}