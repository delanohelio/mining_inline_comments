{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzODI0NTg3", "number": 5941, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToyMjozNlrODrZ1uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNToyNjozMVrODrstCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2ODM4NzE1OnYy", "diffSide": "RIGHT", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToyMjozNlrOF7u3GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwMDo0NDoyOVrOF7zihw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw==", "bodyText": "I would suggest updating this to allow a blacklist and a whitelist at the same time.  A common strategy for this is have the whitelist take precedence.  Then admins could filter out entire namespaces while letting a few parts of the namespace through the filter.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private void filterAnyTextFieldCache() {\n          \n          \n            \n                Set<String> filteredList = new HashSet<>();\n          \n          \n            \n            \n          \n          \n            \n                ConfigurationStore config = ConfigurationStore.getInstance();\n          \n          \n            \n                List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n          \n          \n            \n                List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n          \n          \n            \n                if (!anyTextFieldWhitelist.isEmpty()) {\n          \n          \n            \n                  for (String whitelistField : anyTextFieldWhitelist) {\n          \n          \n            \n                    String whitelist;\n          \n          \n            \n                    if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      whitelist = whitelistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.addAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(whitelist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } else if (!anyTextFieldBlacklist.isEmpty()) {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                  for (String blacklistField : anyTextFieldBlacklist) {\n          \n          \n            \n                    String blacklist;\n          \n          \n            \n                    if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      blacklist = blacklistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.removeAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(blacklist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } else {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                }\n          \n          \n            \n              private void filterAnyTextFieldCache() {\n          \n          \n            \n                Set<String> filteredList = new HashSet<>();\n          \n          \n            \n            \n          \n          \n            \n                ConfigurationStore config = ConfigurationStore.getInstance();\n          \n          \n            \n                List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n          \n          \n            \n                List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n          \n          \n            \n                \n          \n          \n            \n                if (!anyTextFieldBlacklist.isEmpty()) {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                  for (String blacklistField : anyTextFieldBlacklist) {\n          \n          \n            \n                    String blacklist;\n          \n          \n            \n                    if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      blacklist = blacklistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.removeAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(blacklist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } \n          \n          \n            \n                if (!anyTextFieldWhitelist.isEmpty()) {\n          \n          \n            \n                  for (String whitelistField : anyTextFieldWhitelist) {\n          \n          \n            \n                    String whitelist;\n          \n          \n            \n                    if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      whitelist = whitelistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.addAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(whitelist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } \n          \n          \n            \n                \n          \n          \n            \n                if (anyTextFieldWhitelist.isEmpty() && anyTextFieldBlacklist.isEmpty()) {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                }", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398178073", "createdAt": "2020-03-25T21:22:36Z", "author": {"login": "andrewkfiedler"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,123 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {\n+    Set<String> filteredList = new HashSet<>();\n+\n+    ConfigurationStore config = ConfigurationStore.getInstance();\n+    List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n+    List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n+    if (!anyTextFieldWhitelist.isEmpty()) {\n+      for (String whitelistField : anyTextFieldWhitelist) {\n+        String whitelist;\n+        if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          whitelist = whitelistField;\n+        }\n+        filteredList.addAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(whitelist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else if (!anyTextFieldBlacklist.isEmpty()) {\n+      filteredList.addAll(anyTextFieldsCache);\n+      for (String blacklistField : anyTextFieldBlacklist) {\n+        String blacklist;\n+        if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          blacklist = blacklistField;\n+        }\n+        filteredList.removeAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(blacklist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else {\n+      filteredList.addAll(anyTextFieldsCache);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODIxODE2Mw==", "bodyText": "Your solution would allow non-whitelisted fields to be added to the anyText expansion since it starts with the full list, removes any blacklisted items, and then re-adds any whitelisted items.   That is really an implementation of a blacklist exception.  Wouldn't that be confusing to an admin where they provide a whitelist but still see non-whitelisted fields as part of the queries?", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398218163", "createdAt": "2020-03-25T22:50:10Z", "author": {"login": "derekwilhelm"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,123 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {\n+    Set<String> filteredList = new HashSet<>();\n+\n+    ConfigurationStore config = ConfigurationStore.getInstance();\n+    List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n+    List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n+    if (!anyTextFieldWhitelist.isEmpty()) {\n+      for (String whitelistField : anyTextFieldWhitelist) {\n+        String whitelist;\n+        if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          whitelist = whitelistField;\n+        }\n+        filteredList.addAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(whitelist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else if (!anyTextFieldBlacklist.isEmpty()) {\n+      filteredList.addAll(anyTextFieldsCache);\n+      for (String blacklistField : anyTextFieldBlacklist) {\n+        String blacklist;\n+        if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          blacklist = blacklistField;\n+        }\n+        filteredList.removeAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(blacklist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else {\n+      filteredList.addAll(anyTextFieldsCache);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw=="}, "originalCommit": {"oid": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODIyNjk2Mw==", "bodyText": "Yeah, that's the intention in my solution.  You start with the full list, blacklist things, then add things there are exceptions for.\nI don't think it's confusing, it's a common pattern when both a blacklist and a whitelist are allowed.\nI would argue the current behavior is confusing, since we allow both a blacklist and a whitelist to be defined (with no warnings), and then ultimately only use the whitelist.", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398226963", "createdAt": "2020-03-25T23:14:22Z", "author": {"login": "andrewkfiedler"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,123 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {\n+    Set<String> filteredList = new HashSet<>();\n+\n+    ConfigurationStore config = ConfigurationStore.getInstance();\n+    List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n+    List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n+    if (!anyTextFieldWhitelist.isEmpty()) {\n+      for (String whitelistField : anyTextFieldWhitelist) {\n+        String whitelist;\n+        if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          whitelist = whitelistField;\n+        }\n+        filteredList.addAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(whitelist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else if (!anyTextFieldBlacklist.isEmpty()) {\n+      filteredList.addAll(anyTextFieldsCache);\n+      for (String blacklistField : anyTextFieldBlacklist) {\n+        String blacklist;\n+        if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          blacklist = blacklistField;\n+        }\n+        filteredList.removeAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(blacklist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else {\n+      filteredList.addAll(anyTextFieldsCache);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw=="}, "originalCommit": {"oid": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODIzMzY0MQ==", "bodyText": "If metatypes would allow me to force selecting only one of the lists at a time I would have done it for clarity.  I get your point.  Regardless of solution, it needs to identify to the user what the behavior is.  I will update it to allow both and add a comment to the whitelist description that will indicate it becomes a blacklist exception if both lists are provided instead of a pure whitelist.", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398233641", "createdAt": "2020-03-25T23:34:05Z", "author": {"login": "derekwilhelm"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,123 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {\n+    Set<String> filteredList = new HashSet<>();\n+\n+    ConfigurationStore config = ConfigurationStore.getInstance();\n+    List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n+    List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n+    if (!anyTextFieldWhitelist.isEmpty()) {\n+      for (String whitelistField : anyTextFieldWhitelist) {\n+        String whitelist;\n+        if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          whitelist = whitelistField;\n+        }\n+        filteredList.addAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(whitelist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else if (!anyTextFieldBlacklist.isEmpty()) {\n+      filteredList.addAll(anyTextFieldsCache);\n+      for (String blacklistField : anyTextFieldBlacklist) {\n+        String blacklist;\n+        if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          blacklist = blacklistField;\n+        }\n+        filteredList.removeAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(blacklist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else {\n+      filteredList.addAll(anyTextFieldsCache);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw=="}, "originalCommit": {"oid": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1NDcyNw==", "bodyText": "Sounds good.\nI feel you on the metatypes, they feel like crude tools when it comes to the reality of configurations.\nI might take a bit of time after we merge this into master to see if we can offer a special view in the new Admin UI for this configuration, might help ease the burden on admins.  I've been meaning to see if we can make a simple pattern for replacing the default configuration views.", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398254727", "createdAt": "2020-03-26T00:44:29Z", "author": {"login": "andrewkfiedler"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,123 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {\n+    Set<String> filteredList = new HashSet<>();\n+\n+    ConfigurationStore config = ConfigurationStore.getInstance();\n+    List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n+    List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n+    if (!anyTextFieldWhitelist.isEmpty()) {\n+      for (String whitelistField : anyTextFieldWhitelist) {\n+        String whitelist;\n+        if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          whitelist = whitelistField;\n+        }\n+        filteredList.addAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(whitelist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else if (!anyTextFieldBlacklist.isEmpty()) {\n+      filteredList.addAll(anyTextFieldsCache);\n+      for (String blacklistField : anyTextFieldBlacklist) {\n+        String blacklist;\n+        if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          blacklist = blacklistField;\n+        }\n+        filteredList.removeAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(blacklist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else {\n+      filteredList.addAll(anyTextFieldsCache);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw=="}, "originalCommit": {"oid": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTQ3Nzg0OnYy", "diffSide": "RIGHT", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNToyNjozMVrOF8MaqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzo0NzoyM1rOF8TBrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MjMxMg==", "bodyText": "\u270f\ufe0f Ideally this ConfigurationStore would only have configuration as its responsibility.  I would recommend extracting the anyText field cache related fields, methods, and logic to a new class.", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398662312", "createdAt": "2020-03-26T15:26:31Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,127 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0281f9c3e17201dfa9a40fb245a2df45489d761"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc3MDYwNQ==", "bodyText": "I would be good with this being fixed on the master branch.", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398770605", "createdAt": "2020-03-26T17:47:23Z", "author": {"login": "pklinef"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,127 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MjMxMg=="}, "originalCommit": {"oid": "e0281f9c3e17201dfa9a40fb245a2df45489d761"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4682, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}