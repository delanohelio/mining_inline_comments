{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MTMyMjI0", "number": 6426, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo0OToyNlrOE7rCBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1NDoyN1rOE7rICQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDA2NDY5OnYy", "diffSide": "RIGHT", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo0OToyNlrOH3czXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo0OToyNlrOH3czXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNTYzMA==", "bodyText": "The argument should be distanceSortProperty.", "url": "https://github.com/codice/ddf/pull/6426#discussion_r527905630", "createdAt": "2020-11-20T18:49:26Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,206 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROPERTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROPERTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROPERTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+    final QueryType queryType = getFeatureType.getQuery().get(0);\n+    if (sortingEnabled) {\n+      assertThat(queryType.isSetSortBy(), is(true));\n+      assertThat(queryType.getSortBy().getSortProperty().size(), is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().size(),\n+          is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().get(0),\n+          is(sortProperty));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getSortOrder().value(), is(sortOrder));\n+    } else {\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  private void setupMapper(\n+      String temporalSortProperty, String relevanceSortProperty, String distanceSortProperty) {\n+    final MetacardMapperImpl metacardMapper = new MetacardMapperImpl();\n+    metacardMapper.setSortByTemporalFeatureProperty(temporalSortProperty);\n+    metacardMapper.setSortByDistanceFeatureProperty(relevanceSortProperty);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbc39c5a5cbe25a6e1e0bf8eb1c13cb81f616744"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDA2NTU5OnYy", "diffSide": "RIGHT", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo0OTo0MFrOH3cz3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo0OTo0MFrOH3cz3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNTc1OQ==", "bodyText": "The argument should be relevanceSortProperty.", "url": "https://github.com/codice/ddf/pull/6426#discussion_r527905759", "createdAt": "2020-11-20T18:49:40Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,206 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROPERTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROPERTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROPERTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+    final QueryType queryType = getFeatureType.getQuery().get(0);\n+    if (sortingEnabled) {\n+      assertThat(queryType.isSetSortBy(), is(true));\n+      assertThat(queryType.getSortBy().getSortProperty().size(), is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().size(),\n+          is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().get(0),\n+          is(sortProperty));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getSortOrder().value(), is(sortOrder));\n+    } else {\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  private void setupMapper(\n+      String temporalSortProperty, String relevanceSortProperty, String distanceSortProperty) {\n+    final MetacardMapperImpl metacardMapper = new MetacardMapperImpl();\n+    metacardMapper.setSortByTemporalFeatureProperty(temporalSortProperty);\n+    metacardMapper.setSortByDistanceFeatureProperty(relevanceSortProperty);\n+    metacardMapper.setSortByRelevanceFeatureProperty(distanceSortProperty);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbc39c5a5cbe25a6e1e0bf8eb1c13cb81f616744"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDA3NzM3OnYy", "diffSide": "RIGHT", "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1MzozNlrOH3c7XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1MzozNlrOH3c7XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNzY3Ng==", "bodyText": "\u270f\ufe0f StringUtils is already imported.", "url": "https://github.com/codice/ddf/pull/6426#discussion_r527907676", "createdAt": "2020-11-20T18:53:36Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +69,72 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    if (LOGGER.isDebugEnabled()) {\n+      metacardMapperList.forEach(\n+          m -> {\n+            LOGGER.debug(\n+                \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+                m.getFeatureType(),\n+                incomingPropertyName,\n+                m.getFeatureProperty(incomingPropertyName));\n+          });\n+      LOGGER.debug(\n+          \"Mapping sort property: featureType {}, incomingPropertyName {}\",\n+          featureType,\n+          incomingPropertyName);\n+    }\n+    MetacardMapper metacardToFeaturePropertyMapper =\n+        lookupMetacardAttributeToFeaturePropertyMapper(featureType, metacardMapperList);\n+    String mappedPropertyName = null;\n+\n+    if (metacardToFeaturePropertyMapper != null) {\n+\n+      if (StringUtils.equals(Result.TEMPORAL, incomingPropertyName)\n+          || StringUtils.equals(Metacard.EFFECTIVE, incomingPropertyName)) {\n+        mappedPropertyName =\n+            StringUtils.defaultIfBlank(\n+                metacardToFeaturePropertyMapper.getSortByTemporalFeatureProperty(), null);\n+      } else if (StringUtils.equals(Result.RELEVANCE, incomingPropertyName)) {\n+        mappedPropertyName =\n+            StringUtils.defaultIfBlank(\n+                metacardToFeaturePropertyMapper.getSortByRelevanceFeatureProperty(), null);\n+      } else if (org.apache.commons.lang.StringUtils.equals(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbc39c5a5cbe25a6e1e0bf8eb1c13cb81f616744"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDA4MDA5OnYy", "diffSide": "RIGHT", "path": "catalog/spatial/wfs/spatial-wfs-common/src/test/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSourceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1NDoyN1rOH3c9BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxODo1NDoyN1rOH3c9BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwODEwMA==", "bodyText": "\u270f\ufe0f PROEPRTY -> PROPERTY", "url": "https://github.com/codice/ddf/pull/6426#discussion_r527908100", "createdAt": "2020-11-20T18:54:27Z", "author": {"login": "jrnorth"}, "path": "catalog/spatial/wfs/spatial-wfs-common/src/test/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSourceTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package org.codice.ddf.spatial.ogc.wfs.catalog.common;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+\n+import ddf.catalog.data.ContentType;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.Result;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResourceResponse;\n+import ddf.catalog.operation.SourceResponse;\n+import ddf.catalog.resource.ResourceNotFoundException;\n+import ddf.catalog.resource.ResourceNotSupportedException;\n+import ddf.catalog.source.SourceMonitor;\n+import ddf.catalog.source.UnsupportedQueryException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.xml.namespace.QName;\n+import org.codice.ddf.spatial.ogc.wfs.catalog.mapper.MetacardMapper;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class AbstractWfsSourceTest {\n+  private AbstractWfsSource wfsSource;\n+  private static final String FEATURE_NAME = \"SampleFeature\";\n+  private static final String TEMPORAL_SORT_PROEPRTY = \"myTemporalSortProperty\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbc39c5a5cbe25a6e1e0bf8eb1c13cb81f616744"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4402, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}