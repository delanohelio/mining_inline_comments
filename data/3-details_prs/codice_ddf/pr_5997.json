{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0Mzk0MTg3", "number": 5997, "title": "DDF-5802 Refactor to enable for split catalog", "bodyText": "What does this PR do?\nThis PR does some refactoring, renaming to set ground for the split catalog provider work to come. No new functionality is added.\n\nRename SolrCatalogProvider to SolrCatalogProviderImpl\nAdd hint on query for GazetteerQueryCatalog\nRefactor SolrMetacardClientImpl.query logic (no functional change)\nAdd new method to SolrClientFactory Interface\nAdd clean up steps for itests\n\nThis PR is 1/4 of the work of the original large PR #5813\nThe remaining 3/4 of the work will be on a follow up PR, which are mostly new code and new modules to support the implementation of split catalog provider\nWho is reviewing it?\n@pklinef\n@Lambeaux\n@rzwiefel\n@bdeining\nSelect relevant component teams:\n\nAsk 2 committers to review/merge the PR and tag them here.\n@pklinef\n@bdeining\nHow should this be tested?\nFull CI should do to ensure all regression tests are covered.\nAny background context you want to provide?\nWhat are the relevant tickets?\nFixes: #____\nScreenshots\n\nChecklist:\n\n Documentation Updated\n Update / Add Threat Dragon models\n Update / Add Unit Tests\n Update / Add Integration Tests\n\nNotes on Review Process\nPlease see Notes on Review Process for further guidance on requirements for merging and abbreviated reviews.\nReview Comment Legend:\n\n\u270f\ufe0f (Pencil) This comment is a nitpick or style suggestion, no action required for approval. This comment should provide a suggestion either as an in line code snippet or a gist.\n\u2753 (Question Mark) This comment is to gain a clearer understanding of design or code choices, clarification is required but action may not be necessary for approval.\n\u2757 (Exclamation Mark) This comment is critical and requires clarification or action before approval.", "createdAt": "2020-04-16T14:03:36Z", "url": "https://github.com/codice/ddf/pull/5997", "merged": true, "mergeCommit": {"oid": "5a79b5a3762c2f60c6d0c4ffecb597e825893506"}, "closed": true, "closedAt": "2020-05-12T18:59:31Z", "author": {"login": "lamhuy"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYOEUPgFqTM5NDcyNjIzMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgXK7sgBqjMzMjQ5Nzk0ODA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NzI2MjMz", "url": "https://github.com/codice/ddf/pull/5997#pullrequestreview-394726233", "createdAt": "2020-04-16T15:03:38Z", "commit": {"oid": "c296e9b5f5864410e5efcc770fe88e791d538a11"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNTowMzozOVrOGGp0Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNTowMzozOVrOGGp0Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYyOTc5MQ==", "bodyText": "why is this added to the application definition?", "url": "https://github.com/codice/ddf/pull/5997#discussion_r409629791", "createdAt": "2020-04-16T15:03:39Z", "author": {"login": "bdeining"}, "path": "distribution/ddf-common/src/main/resources-filtered/etc/application-definitions/solr.json", "diffHunk": "@@ -2,6 +2,7 @@\n   \"name\": \"catalog-solr-app\",\n   \"description\": \"The Solr Catalog Provider (SCP) is an implementation of the CatalogProvider interface using Apache Solr ${solr.version} as a data store.\\nThe SCP supports extensible metacards, fast/simple contextual searching, indexes xml attributes/CDATA sections/XML text elements, contains full XPath support, works with an embedded local Solr Server, and also works with a standalone Solr Server.::Solr Catalog\",\n   \"bundleLocations\": [\n+    \"mvn:org.codice.thirdparty/jts/${jts.bundle.version}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c296e9b5f5864410e5efcc770fe88e791d538a11"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NzI2ODIz", "url": "https://github.com/codice/ddf/pull/5997#pullrequestreview-394726823", "createdAt": "2020-04-16T15:04:14Z", "commit": {"oid": "c296e9b5f5864410e5efcc770fe88e791d538a11"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNTowNDoxNVrOGGp2QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNTowNDoxNVrOGGp2QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYzMDI3Mw==", "bodyText": "I think this is used downstream, is it necessary to remove?", "url": "https://github.com/codice/ddf/pull/5997#discussion_r409630273", "createdAt": "2020-04-16T15:04:15Z", "author": {"login": "bdeining"}, "path": "distribution/test/itests/test-itests-common/src/main/java/org/codice/ddf/itests/common/AbstractIntegrationTest.java", "diffHunk": "@@ -329,9 +326,6 @@ public String toString() {\n   public static final DynamicUrl SERVICE_ROOT =\n       new DynamicUrl(SECURE_ROOT, HTTPS_PORT, \"/services\");\n \n-  public static final DynamicUrl INSECURE_SERVICE_ROOT =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c296e9b5f5864410e5efcc770fe88e791d538a11"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTI5NDM1", "url": "https://github.com/codice/ddf/pull/5997#pullrequestreview-396529435", "createdAt": "2020-04-20T14:52:02Z", "commit": {"oid": "8db3c275eade0c7ede8154b5e85eab936cc9259a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NzkzMDE4", "url": "https://github.com/codice/ddf/pull/5997#pullrequestreview-396793018", "createdAt": "2020-04-20T20:36:23Z", "commit": {"oid": "8db3c275eade0c7ede8154b5e85eab936cc9259a"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDozNjoyM1rOGImnoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMToxNDowOFrOGIn9iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY3NDUyOA==", "bodyText": "\u2753 Do you need this method? The gazetteer in blueprint has update-strategy=\"container-managed\" which IIRC means only the setter gets invoked. If you had used component-managed then you would need both.", "url": "https://github.com/codice/ddf/pull/5997#discussion_r411674528", "createdAt": "2020-04-20T20:36:23Z", "author": {"login": "Lambeaux"}, "path": "catalog/spatial/geocoding/spatial-geocoding-offline-catalog/src/main/java/org/codice/ddf/spatial/geocoding/query/GazetteerQueryCatalog.java", "diffHunk": "@@ -358,4 +387,16 @@ private NearbyLocation transformMetacardToNearbyLocation(String location, Metaca\n     }\n     return Optional.empty();\n   }\n+\n+  public void refresh(Map<String, Object> properties) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8db3c275eade0c7ede8154b5e85eab936cc9259a"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY5NjUyMQ==", "bodyText": "\u2753 Per my knowledge of Elasticsearch, an alias is just an alternate name you can use to refer to an index or group of indices in a REST request, but the database itself owns the alias definition as part of configuration. It seems Solr works in a similar fashion:\nhttps://lucene.apache.org/solr/guide/8_1/aliases.html\nThis is a lot more manageable than before, so I'm good with it \ud83d\udc4d but I'm still curious about the necessity for having our Solr client manage Alias creation. Can we not assume that we deployed Solr / Zookeeper with the correct configuration up front? Can we not simply reboot the system or refresh bundles between configuration updates?", "url": "https://github.com/codice/ddf/pull/5997#discussion_r411696521", "createdAt": "2020-04-20T21:14:08Z", "author": {"login": "Lambeaux"}, "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java", "diffHunk": "@@ -64,47 +68,157 @@\n   private final int maximumShardsPerNode =\n       NumberUtils.toInt(System.getProperty(\"solr.cloud.maxShardPerNode\"), 2);\n \n+  private static final String ALIAS_PROP = \"alias\";\n+\n   @Override\n   public org.codice.solr.client.solrj.SolrClient newClient(String core) {\n+    return newClient(core, null);\n+  }\n+\n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+\n     String zookeeperHosts = System.getProperty(\"solr.cloud.zookeeper\");\n+    checkConfig(zookeeperHosts);\n \n-    if (StringUtils.isBlank(zookeeperHosts)) {\n-      LOGGER.warn(\n-          \"Cannot create SolrCloud client without Zookeeper host list system property [solr.cloud.zookeeper] being set.\");\n-      throw new IllegalStateException(\"system property 'solr.cloud.zookeeper' is not configured\");\n-    }\n     LOGGER.debug(\n-        \"Solr({}): Creating a SolrCloud client using Zookeeper hosts [{}]\", core, zookeeperHosts);\n+        \"Solr({}): Creating a Solr Cloud client with configuration using Zookeeper hosts [{}]\",\n+        collection,\n+        zookeeperHosts);\n+\n+    String alias = properties == null ? null : (String) properties.getOrDefault(ALIAS_PROP, null);\n+\n     return new SolrClientAdapter(\n-        core,\n+        collection,\n         () ->\n             AccessController.doPrivileged(\n                 (PrivilegedAction<SolrClient>)\n                     () -> {\n-                      return createSolrCloudClient(zookeeperHosts, core);\n+                      return createSolrCloudClient(zookeeperHosts, collection, alias);\n                     }));\n   }\n \n   @VisibleForTesting\n-  SolrClient createSolrCloudClient(String zookeeperHosts, String collection) {\n+  void addCollectionToAlias(String alias, String collection, CloudSolrClient client) {\n+    if (StringUtils.isBlank(alias) || StringUtils.isBlank(collection)) {\n+      return;\n+    }\n+    try {\n+      List<String> aliasedCollections = getCollectionsInAlias(client, alias);\n+      if (!aliasedCollections.contains(collection)) {\n+        List<String> collections = new ArrayList<>();\n+        collections.addAll(aliasedCollections);\n+        collections.add(collection);\n+        collections.addAll(getCollectionsNotInAlias(client, aliasedCollections, alias));\n+        createAlias(client, collections, alias);\n+      }\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.warn(\"Failed to update alias [{}]\", alias, e);\n+    }\n+  }\n+\n+  private List<String> getCollectionsInAlias(CloudSolrClient client, String alias)\n+      throws SolrServerException, IOException {\n+    CollectionAdminResponse aliasResponse =\n+        new CollectionAdminRequest.ListAliases().process(client);\n+\n+    if (aliasResponse != null) {\n+      Map<String, String> aliases = aliasResponse.getAliases();\n+      if (aliases != null && aliases.containsKey(alias)) {\n+        String[] collections = aliases.get(alias).split(\",\");\n+        return Arrays.asList(collections);\n+      }\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  /**\n+   * Find existing collections in case parallel operations are creating collections\n+   *\n+   * @param client\n+   * @param currentAliases\n+   * @param alias\n+   * @return\n+   * @throws SolrServerException\n+   * @throws IOException\n+   */\n+  private List<String> getCollectionsNotInAlias(\n+      CloudSolrClient client, List<String> currentAliases, String alias)\n+      throws SolrServerException, IOException {\n+    if (StringUtils.isNotBlank(alias)) {\n+      CollectionAdminResponse response = new CollectionAdminRequest.List().process(client);\n+      if (response.getResponse() != null) {\n+        List<String> collections = (List<String>) response.getResponse().get(\"collections\");\n+        return collections == null\n+            ? Collections.emptyList()\n+            : collections\n+                .stream()\n+                .filter(c -> c.startsWith(alias))\n+                .filter(c -> currentAliases.contains(c))\n+                .collect(Collectors.toList());\n+      }\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private void createAlias(CloudSolrClient client, List<String> collections, String alias) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8db3c275eade0c7ede8154b5e85eab936cc9259a"}, "originalPosition": 130}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8db3c275eade0c7ede8154b5e85eab936cc9259a", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/8db3c275eade0c7ede8154b5e85eab936cc9259a", "committedDate": "2020-04-16T15:57:39Z", "message": "DDF-5802 fix rebase"}, "afterCommit": {"oid": "c1d753cee33eea3aaaf68c83195d513f213ac639", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/c1d753cee33eea3aaaf68c83195d513f213ac639", "committedDate": "2020-04-21T18:42:00Z", "message": "DDF-5802 Refactor to enable DDF-5802"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NTk0NDMz", "url": "https://github.com/codice/ddf/pull/5997#pullrequestreview-397594433", "createdAt": "2020-04-21T19:06:29Z", "commit": {"oid": "c14dbada9653d81529d033d8c2e2e845a3fb7ce3"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTowNjoyOVrOGJT_kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTowNjoyOVrOGJT_kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQxNzkzOA==", "bodyText": "\u270f\ufe0f Add JavaDoc.  You can reference the existing method.", "url": "https://github.com/codice/ddf/pull/5997#discussion_r412417938", "createdAt": "2020-04-21T19:06:29Z", "author": {"login": "pklinef"}, "path": "platform/solr/solr-factory/src/main/java/org/codice/solr/factory/SolrClientFactory.java", "diffHunk": "@@ -30,5 +31,7 @@\n    * @return the newly created {@code SolrClient}\n    * @throws IllegalArgumentException if <code>core</code> is <code>null</code>\n    */\n-  public SolrClient newClient(String core);\n+  SolrClient newClient(String core);\n+\n+  SolrClient newClient(String collection, Map<String, Object> properties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c14dbada9653d81529d033d8c2e2e845a3fb7ce3"}, "originalPosition": 15}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c14dbada9653d81529d033d8c2e2e845a3fb7ce3", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/c14dbada9653d81529d033d8c2e2e845a3fb7ce3", "committedDate": "2020-04-21T18:49:21Z", "message": "DDF-5802 clean up"}, "afterCommit": {"oid": "e5f3571c247d985ab230d91a8d3fb73cb18e4ea6", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/e5f3571c247d985ab230d91a8d3fb73cb18e4ea6", "committedDate": "2020-04-21T19:18:55Z", "message": "DDF-5802 Refactor to enable DDF-5802"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5f3571c247d985ab230d91a8d3fb73cb18e4ea6", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/e5f3571c247d985ab230d91a8d3fb73cb18e4ea6", "committedDate": "2020-04-21T19:18:55Z", "message": "DDF-5802 Refactor to enable DDF-5802"}, "afterCommit": {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/d722e54261ec93909a983e315e64f4cd42761ba4", "committedDate": "2020-04-21T19:25:05Z", "message": "DDF-5802 Refactor to enable DDF-5802"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NTI2MDcy", "url": "https://github.com/codice/ddf/pull/5997#pullrequestreview-398526072", "createdAt": "2020-04-22T19:46:49Z", "commit": {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4"}, "state": "APPROVED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxOTo0Njo0OVrOGKIMQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDoyNToyN1rOGKKHpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3MzE1Mg==", "bodyText": "\u270f\ufe0f if we are sure this will not be null you should be able to do if (doRealTimeGet) { since it will be autoboxed. Or if we worked with boolean primitive instead we wouldn't have to worry about the nullness at all.", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413273152", "createdAt": "2020-04-22T19:46:49Z", "author": {"login": "rzwiefel"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -168,15 +171,66 @@ public SourceResponse query(QueryRequest request) throws UnsupportedQueryExcepti\n       return new QueryResponseImpl(request, new ArrayList<>(), true, 0L);\n     }\n \n+    long totalHits = 0;\n+    Map<String, Serializable> responseProps = new HashMap<>();\n+    List<Result> results = new ArrayList<>();\n+\n     SolrFilterDelegate solrFilterDelegate =\n         filterDelegateFactory.newInstance(resolver, request.getProperties());\n     SolrQuery query = getSolrQuery(request, solrFilterDelegate);\n \n-    Map<String, Serializable> responseProps = new HashMap<>();\n+    boolean isFacetedQuery = handleFacetRequest(query, request);\n+    query = handleSuggestionQuery(query, request);\n+    boolean userSpellcheckIsOn = userSpellcheckIsOn(request);\n+\n+    try {\n+      QueryResponse solrResponse;\n+      Boolean doRealTimeGet =\n+          (Boolean) request.getProperties().getOrDefault(DO_REALTIME_GET, false)\n+              || filterAdapter.adapt(request.getQuery(), new RealTimeGetDelegate());\n+\n+      if (BooleanUtils.isTrue(doRealTimeGet)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3NDYwNQ==", "bodyText": "\u270f\ufe0f Feels a little odd to pass this boolean into this method to have it do an if on it, we could just do this in the calling method and have one less boolean paramter to pass through", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413274605", "createdAt": "2020-04-22T19:48:39Z", "author": {"login": "rzwiefel"}, "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -215,92 +272,76 @@ public SourceResponse query(QueryRequest request) throws UnsupportedQueryExcepti\n       }\n     }\n \n-    long totalHits = 0;\n-    List<Result> results = new ArrayList<>();\n-\n-    Boolean userSpellcheckIsOn = userSpellcheckIsOn(request);\n-\n-    try {\n-      QueryResponse solrResponse;\n-      Boolean doRealTimeGet = filterAdapter.adapt(request.getQuery(), new RealTimeGetDelegate());\n+    return query;\n+  }\n \n-      if (doRealTimeGet) {\n-        LOGGER.debug(\"Performing real time query\");\n-        SolrQuery realTimeQuery = getRealTimeQuery(query, solrFilterDelegate.getIds());\n-        solrResponse = client.query(realTimeQuery, METHOD.POST);\n-      } else {\n-        query.setParam(\"spellcheck\", userSpellcheckIsOn);\n-        solrResponse = client.query(query, METHOD.POST);\n+  private void handleFacetResponse(\n+      QueryResponse solrResponse, Map<String, Serializable> responseProps, boolean isFacetedQuery) {\n+    if (isFacetedQuery) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4MzE2Ng==", "bodyText": "\u270f\ufe0f Just an opinion, this might be a little less busy/complex if we just ensure that geocoderCollection is not null in the setter (by either erroring out if set to null or defaulting back to default value)  and then we wouldn't have to always check if the class field is null on every access.", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413283166", "createdAt": "2020-04-22T19:56:54Z", "author": {"login": "rzwiefel"}, "path": "catalog/spatial/geocoding/spatial-geocoding-offline-catalog/src/main/java/org/codice/ddf/spatial/geocoding/query/GazetteerQueryCatalog.java", "diffHunk": "@@ -358,4 +387,8 @@ private NearbyLocation transformMetacardToNearbyLocation(String location, Metaca\n     }\n     return Optional.empty();\n   }\n+\n+  public void setGeocoderCollection(String geocoderCollection) {\n+    this.geocoderCollection = geocoderCollection;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NTQ0Ng==", "bodyText": "\u2753 Is it okay that we're not doing anything with the properties parameter? Could it be deleted if it is not used?", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413285446", "createdAt": "2020-04-22T19:59:42Z", "author": {"login": "rzwiefel"}, "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/HttpSolrClientFactory.java", "diffHunk": "@@ -139,6 +140,12 @@ private static boolean solrCoreExists(SolrClient client, String coreName)\n     return new SolrClientAdapter(core, () -> createSolrHttpClient(solrUrl, core, coreUrl));\n   }\n \n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+    return newClient(collection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4ODU0OA==", "bodyText": "\u270f\ufe0f Just an opinion, firming up the null contracts with the properties parameter could clean up null checks like this and reduce it down to just the getOrDefault call.", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413288548", "createdAt": "2020-04-22T20:02:59Z", "author": {"login": "rzwiefel"}, "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java", "diffHunk": "@@ -64,47 +68,157 @@\n   private final int maximumShardsPerNode =\n       NumberUtils.toInt(System.getProperty(\"solr.cloud.maxShardPerNode\"), 2);\n \n+  private static final String ALIAS_PROP = \"alias\";\n+\n   @Override\n   public org.codice.solr.client.solrj.SolrClient newClient(String core) {\n+    return newClient(core, null);\n+  }\n+\n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+\n     String zookeeperHosts = System.getProperty(\"solr.cloud.zookeeper\");\n+    checkConfig(zookeeperHosts);\n \n-    if (StringUtils.isBlank(zookeeperHosts)) {\n-      LOGGER.warn(\n-          \"Cannot create SolrCloud client without Zookeeper host list system property [solr.cloud.zookeeper] being set.\");\n-      throw new IllegalStateException(\"system property 'solr.cloud.zookeeper' is not configured\");\n-    }\n     LOGGER.debug(\n-        \"Solr({}): Creating a SolrCloud client using Zookeeper hosts [{}]\", core, zookeeperHosts);\n+        \"Solr({}): Creating a Solr Cloud client with configuration using Zookeeper hosts [{}]\",\n+        collection,\n+        zookeeperHosts);\n+\n+    String alias = properties == null ? null : (String) properties.getOrDefault(ALIAS_PROP, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4OTk0Mw==", "bodyText": "\u2753 Just confirming, is silently returning (instead of throwing an exception) what we want here if the alias or collection is null?", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413289943", "createdAt": "2020-04-22T20:04:22Z", "author": {"login": "rzwiefel"}, "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java", "diffHunk": "@@ -64,47 +68,157 @@\n   private final int maximumShardsPerNode =\n       NumberUtils.toInt(System.getProperty(\"solr.cloud.maxShardPerNode\"), 2);\n \n+  private static final String ALIAS_PROP = \"alias\";\n+\n   @Override\n   public org.codice.solr.client.solrj.SolrClient newClient(String core) {\n+    return newClient(core, null);\n+  }\n+\n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+\n     String zookeeperHosts = System.getProperty(\"solr.cloud.zookeeper\");\n+    checkConfig(zookeeperHosts);\n \n-    if (StringUtils.isBlank(zookeeperHosts)) {\n-      LOGGER.warn(\n-          \"Cannot create SolrCloud client without Zookeeper host list system property [solr.cloud.zookeeper] being set.\");\n-      throw new IllegalStateException(\"system property 'solr.cloud.zookeeper' is not configured\");\n-    }\n     LOGGER.debug(\n-        \"Solr({}): Creating a SolrCloud client using Zookeeper hosts [{}]\", core, zookeeperHosts);\n+        \"Solr({}): Creating a Solr Cloud client with configuration using Zookeeper hosts [{}]\",\n+        collection,\n+        zookeeperHosts);\n+\n+    String alias = properties == null ? null : (String) properties.getOrDefault(ALIAS_PROP, null);\n+\n     return new SolrClientAdapter(\n-        core,\n+        collection,\n         () ->\n             AccessController.doPrivileged(\n                 (PrivilegedAction<SolrClient>)\n                     () -> {\n-                      return createSolrCloudClient(zookeeperHosts, core);\n+                      return createSolrCloudClient(zookeeperHosts, collection, alias);\n                     }));\n   }\n \n   @VisibleForTesting\n-  SolrClient createSolrCloudClient(String zookeeperHosts, String collection) {\n+  void addCollectionToAlias(String alias, String collection, CloudSolrClient client) {\n+    if (StringUtils.isBlank(alias) || StringUtils.isBlank(collection)) {\n+      return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5NDQ2NA==", "bodyText": "\u270f\ufe0f This would be a great place to use Optional if you prefer to have the null checks done for you, eg:\nreturn Optional.ofNullable(aliasResponse)\n    .map(CollectionAdminResponse::getAliases)\n    .map(a -> a.get(alias))\n    .map(ca -> ca.split(\",\")\n    .map(Arrays::asList)\n    .orElse(Collections.emptyList());", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413294464", "createdAt": "2020-04-22T20:11:36Z", "author": {"login": "rzwiefel"}, "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java", "diffHunk": "@@ -64,47 +68,157 @@\n   private final int maximumShardsPerNode =\n       NumberUtils.toInt(System.getProperty(\"solr.cloud.maxShardPerNode\"), 2);\n \n+  private static final String ALIAS_PROP = \"alias\";\n+\n   @Override\n   public org.codice.solr.client.solrj.SolrClient newClient(String core) {\n+    return newClient(core, null);\n+  }\n+\n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+\n     String zookeeperHosts = System.getProperty(\"solr.cloud.zookeeper\");\n+    checkConfig(zookeeperHosts);\n \n-    if (StringUtils.isBlank(zookeeperHosts)) {\n-      LOGGER.warn(\n-          \"Cannot create SolrCloud client without Zookeeper host list system property [solr.cloud.zookeeper] being set.\");\n-      throw new IllegalStateException(\"system property 'solr.cloud.zookeeper' is not configured\");\n-    }\n     LOGGER.debug(\n-        \"Solr({}): Creating a SolrCloud client using Zookeeper hosts [{}]\", core, zookeeperHosts);\n+        \"Solr({}): Creating a Solr Cloud client with configuration using Zookeeper hosts [{}]\",\n+        collection,\n+        zookeeperHosts);\n+\n+    String alias = properties == null ? null : (String) properties.getOrDefault(ALIAS_PROP, null);\n+\n     return new SolrClientAdapter(\n-        core,\n+        collection,\n         () ->\n             AccessController.doPrivileged(\n                 (PrivilegedAction<SolrClient>)\n                     () -> {\n-                      return createSolrCloudClient(zookeeperHosts, core);\n+                      return createSolrCloudClient(zookeeperHosts, collection, alias);\n                     }));\n   }\n \n   @VisibleForTesting\n-  SolrClient createSolrCloudClient(String zookeeperHosts, String collection) {\n+  void addCollectionToAlias(String alias, String collection, CloudSolrClient client) {\n+    if (StringUtils.isBlank(alias) || StringUtils.isBlank(collection)) {\n+      return;\n+    }\n+    try {\n+      List<String> aliasedCollections = getCollectionsInAlias(client, alias);\n+      if (!aliasedCollections.contains(collection)) {\n+        List<String> collections = new ArrayList<>();\n+        collections.addAll(aliasedCollections);\n+        collections.add(collection);\n+        collections.addAll(getCollectionsNotInAlias(client, aliasedCollections, alias));\n+        createAlias(client, collections, alias);\n+      }\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.warn(\"Failed to update alias [{}]\", alias, e);\n+    }\n+  }\n+\n+  private List<String> getCollectionsInAlias(CloudSolrClient client, String alias)\n+      throws SolrServerException, IOException {\n+    CollectionAdminResponse aliasResponse =\n+        new CollectionAdminRequest.ListAliases().process(client);\n+\n+    if (aliasResponse != null) {\n+      Map<String, String> aliases = aliasResponse.getAliases();\n+      if (aliases != null && aliases.containsKey(alias)) {\n+        String[] collections = aliases.get(alias).split(\",\");\n+        return Arrays.asList(collections);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwNDc0Mw==", "bodyText": "\u270f\ufe0f Bummer optionals and exceptions dont play well together or you could probably do more with this. But even the latter half could be Optionaled if you'd prefer\nreturn Optional.ofNullable(response)\n    .map(CollectionAdminResponse::getResponse)\n    .map(resp -> resp.get(\"collections\"))\n    .orElse(Collections.emptyList())\n    .stream()\n    .filter(c -> c.startsWith(alias))\n    .filter(c -> currentAliases.contains(c))\n    .collect(Collectors.toList());", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413304743", "createdAt": "2020-04-22T20:25:27Z", "author": {"login": "rzwiefel"}, "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java", "diffHunk": "@@ -64,47 +68,157 @@\n   private final int maximumShardsPerNode =\n       NumberUtils.toInt(System.getProperty(\"solr.cloud.maxShardPerNode\"), 2);\n \n+  private static final String ALIAS_PROP = \"alias\";\n+\n   @Override\n   public org.codice.solr.client.solrj.SolrClient newClient(String core) {\n+    return newClient(core, null);\n+  }\n+\n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+\n     String zookeeperHosts = System.getProperty(\"solr.cloud.zookeeper\");\n+    checkConfig(zookeeperHosts);\n \n-    if (StringUtils.isBlank(zookeeperHosts)) {\n-      LOGGER.warn(\n-          \"Cannot create SolrCloud client without Zookeeper host list system property [solr.cloud.zookeeper] being set.\");\n-      throw new IllegalStateException(\"system property 'solr.cloud.zookeeper' is not configured\");\n-    }\n     LOGGER.debug(\n-        \"Solr({}): Creating a SolrCloud client using Zookeeper hosts [{}]\", core, zookeeperHosts);\n+        \"Solr({}): Creating a Solr Cloud client with configuration using Zookeeper hosts [{}]\",\n+        collection,\n+        zookeeperHosts);\n+\n+    String alias = properties == null ? null : (String) properties.getOrDefault(ALIAS_PROP, null);\n+\n     return new SolrClientAdapter(\n-        core,\n+        collection,\n         () ->\n             AccessController.doPrivileged(\n                 (PrivilegedAction<SolrClient>)\n                     () -> {\n-                      return createSolrCloudClient(zookeeperHosts, core);\n+                      return createSolrCloudClient(zookeeperHosts, collection, alias);\n                     }));\n   }\n \n   @VisibleForTesting\n-  SolrClient createSolrCloudClient(String zookeeperHosts, String collection) {\n+  void addCollectionToAlias(String alias, String collection, CloudSolrClient client) {\n+    if (StringUtils.isBlank(alias) || StringUtils.isBlank(collection)) {\n+      return;\n+    }\n+    try {\n+      List<String> aliasedCollections = getCollectionsInAlias(client, alias);\n+      if (!aliasedCollections.contains(collection)) {\n+        List<String> collections = new ArrayList<>();\n+        collections.addAll(aliasedCollections);\n+        collections.add(collection);\n+        collections.addAll(getCollectionsNotInAlias(client, aliasedCollections, alias));\n+        createAlias(client, collections, alias);\n+      }\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.warn(\"Failed to update alias [{}]\", alias, e);\n+    }\n+  }\n+\n+  private List<String> getCollectionsInAlias(CloudSolrClient client, String alias)\n+      throws SolrServerException, IOException {\n+    CollectionAdminResponse aliasResponse =\n+        new CollectionAdminRequest.ListAliases().process(client);\n+\n+    if (aliasResponse != null) {\n+      Map<String, String> aliases = aliasResponse.getAliases();\n+      if (aliases != null && aliases.containsKey(alias)) {\n+        String[] collections = aliases.get(alias).split(\",\");\n+        return Arrays.asList(collections);\n+      }\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  /**\n+   * Find existing collections in case parallel operations are creating collections\n+   *\n+   * @param client\n+   * @param currentAliases\n+   * @param alias\n+   * @return\n+   * @throws SolrServerException\n+   * @throws IOException\n+   */\n+  private List<String> getCollectionsNotInAlias(\n+      CloudSolrClient client, List<String> currentAliases, String alias)\n+      throws SolrServerException, IOException {\n+    if (StringUtils.isNotBlank(alias)) {\n+      CollectionAdminResponse response = new CollectionAdminRequest.List().process(client);\n+      if (response.getResponse() != null) {\n+        List<String> collections = (List<String>) response.getResponse().get(\"collections\");\n+        return collections == null\n+            ? Collections.emptyList()\n+            : collections\n+                .stream()\n+                .filter(c -> c.startsWith(alias))\n+                .filter(c -> currentAliases.contains(c))\n+                .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4"}, "originalPosition": 124}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "73cd4c4eae78a974d8a79411b6c77f553189e260", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/73cd4c4eae78a974d8a79411b6c77f553189e260", "committedDate": "2020-04-23T16:07:54Z", "message": "DDF-5802 address comments"}, "afterCommit": {"oid": "2ac6a152a64cb7c2690301777d111ca021e7b49b", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/2ac6a152a64cb7c2690301777d111ca021e7b49b", "committedDate": "2020-05-07T20:19:45Z", "message": "DDF-5802 remove new features"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d91e38e2b8f616c884929ee7098533531b6d3f5", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/6d91e38e2b8f616c884929ee7098533531b6d3f5", "committedDate": "2020-05-11T15:31:28Z", "message": "DDF-5802 Refactor to enable DDF-5802"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46c732024bc91146b01b0951e7364b8e747c70ae", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/46c732024bc91146b01b0951e7364b8e747c70ae", "committedDate": "2020-05-11T15:31:29Z", "message": "DDF-5802 address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2ac6a152a64cb7c2690301777d111ca021e7b49b", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/2ac6a152a64cb7c2690301777d111ca021e7b49b", "committedDate": "2020-05-07T20:19:45Z", "message": "DDF-5802 remove new features"}, "afterCommit": {"oid": "3ced11154afb1c4173e71710c58f2d2abf5014ed", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/3ced11154afb1c4173e71710c58f2d2abf5014ed", "committedDate": "2020-05-11T15:34:35Z", "message": "DDF-5802 clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "848c89ca9d29e90c99823b09dc2e4073e5741e3e", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/848c89ca9d29e90c99823b09dc2e4073e5741e3e", "committedDate": "2020-05-11T22:10:24Z", "message": "DDF-5802 remove new features"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5ca1e4128f18961493bffc91a5fc1dd1098054c", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/e5ca1e4128f18961493bffc91a5fc1dd1098054c", "committedDate": "2020-05-11T18:03:10Z", "message": "DDF-5802 update test coverage"}, "afterCommit": {"oid": "848c89ca9d29e90c99823b09dc2e4073e5741e3e", "author": {"user": {"login": "lamhuy", "name": "Jason Lam"}}, "url": "https://github.com/codice/ddf/commit/848c89ca9d29e90c99823b09dc2e4073e5741e3e", "committedDate": "2020-05-11T22:10:24Z", "message": "DDF-5802 remove new features"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4916, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}