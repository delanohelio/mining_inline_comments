{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NTQxOTI4", "number": 1589, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTo1MTozN1rOEppCYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozOToxM1rOEp8UoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDk5NDI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTo1MTozN1rOHbb7yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMTo1OFrOHb6zJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTI3Mw==", "bodyText": "You dropped the \"innies\" requirement it seems...I'm not sure if that is on purpose, or just not needed...but could you add tests to show that they do not get clipped?", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498531273", "createdAt": "2020-10-01T21:51:37Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTc1Mw==", "bodyText": "also how do we know if reads are innes? what do we do with the clipped bases?\n   <-----------------------SSSSSSSSS\n                                SSSSSSS------------------------->\n\n(S being a soft-clipped base....)", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498531753", "createdAt": "2020-10-01T21:52:56Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTI3Mw=="}, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMzY2MQ==", "bodyText": "The explicit \"innie\" requirement is dropped, but this still will not clip outies, because I believe by definition outies cannot be overlapping with reads on opposite strands.  I don't think innie and outie really have meaning for overlapping reads, though I may be confused about this.  There is a test commented as Non overlapping \"outies\" which tests outies.\nPreviously, the \"innie\" requirement was enforced with the logic pos.getAlignmentStart() < neg.getAlignmentEnd(). Combining this with posClipFrom > 0/ negClipFrom > 0 is almost equivalent to the overlapping requirement, except for when the two reads overlap by only a single base.  In this case, the new check of read1.overlaps(read2) will pass, while the old check of pos.getAlignmentStart() < neg.getAlignmentEnd() will not, because instead pos.getAlignmentStart() == neg.getAlignmentEnd().  This is not a behavior change I was intending, as I wasn't aware of this edge case difference until just now.  But I believe the old behavior was actually a bug, since the new behavior is more consistent with my understanding of what is intended.  It doesn't make sense to me that we would clip when two or more bases overlap, but not when only one base overlaps, so I'm guessing that was not intentional.  I have added a test demonstrating this edge case (commented as \"overlap by one base only\"), and have also added the same test on the branch ck_mba_single_overlap_test_example to demonstrate the previous behavior.\nFor your softclipped example, these reads will not go through any additional clipping since they are not overlapping.\nThis is consistent with past behavior, since they would not pass the pos.getAlignmentStart() < neg.getAlignmentEnd() check.", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498813661", "createdAt": "2020-10-02T13:15:31Z", "author": {"login": "kachulis"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTI3Mw=="}, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNjk2Nw==", "bodyText": "\ud83d\udc4d thanks for the explanation", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499036967", "createdAt": "2020-10-02T20:31:58Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTI3Mw=="}, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTAxMzk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjowMToxNlrOHbcIqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDowMDoyNFrOHb6BhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDU2OQ==", "bodyText": "did you mix up 3' and 5' here? or am I confused?", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498534569", "createdAt": "2020-10-01T22:01:16Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDc4Nw==", "bodyText": "5'------------------------------------->3'\n3' <-----------------------------5'", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498534787", "createdAt": "2020-10-01T22:01:59Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDU2OQ=="}, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMjAzOA==", "bodyText": "I think this is correct.  On a forward read, the first base clipped is the 5' most base to clip, and the last base not clipped is the 3' most base not to be clipped.\n3'<SSSSSSSSMMMMMMMMMMMM5'\n         5'MMMMMMMMMMMMSSSSSSSS>3'\n                      ||\n                      ||---> 5' most base to clip\n                      |\n                      |---> 3' most base not to clip\n\nI agree this is pretty confusing to parse, so I will add this ascii art to the comment in the code to help clarify the language", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499012038", "createdAt": "2020-10-02T19:30:47Z", "author": {"login": "kachulis"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDU2OQ=="}, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNDI2MA==", "bodyText": "\ud83d\udc4d yeah, thanks.", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499024260", "createdAt": "2020-10-02T20:00:24Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDU2OQ=="}, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTI2MjM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMDozNDo1M1rOHbejoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDowMTowMlrOHb6CqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDI0MA==", "bodyText": "perhaps these variables need to be renamed, where the first assignment is negFirstBaseToClip (unchanged) and the second is negFirstBaseFrom3PrimeEndToClip?", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498574240", "createdAt": "2020-10-02T00:34:53Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyMzUzMw==", "bodyText": "Agreed these variables could be names more clearly (though I think this should be negFirstBaseFrom5PrimeEndToClip).  I've tried to improve the naming, and added some comments to clarify what all these variables are.", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499023533", "createdAt": "2020-10-02T19:58:38Z", "author": {"login": "kachulis"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDI0MA=="}, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNDU1Mw==", "bodyText": "I think that part of the problem is that pos is overloaded (both POSition and POSitive).... \ud83e\udd37", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499024553", "createdAt": "2020-10-02T20:01:02Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDI0MA=="}, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTI2NjA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMDozNzozOVrOHbel5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMDozNzozOVrOHbel5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDgyMw==", "bodyText": "could this be moved up so it's next to the other stuff that deals with pos?", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498574823", "createdAt": "2020-10-02T00:37:39Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n+        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+\n+        if(posLastUnclipped > 0 && posLastUnclipped < pos.getReadLength()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTQ1MjkxOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMzozMToxMVrOHbgdWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMzozMToxMVrOHbgdWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwNTQwMw==", "bodyText": "1-based position,\n0 if reference position doesn't overlap with read even with softclips converted to matches.", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498605403", "createdAt": "2020-10-02T03:31:11Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n+        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+\n+        if(posLastUnclipped > 0 && posLastUnclipped < pos.getReadLength()) {\n+            clip3PrimeEndOfRead(pos, posLastUnclipped + 1, hardClipReads);\n         }\n-        if(negClipFrom > 0) {\n-            clip3PrimeEndOfRead(neg, negClipFrom, hardClipReads);\n+        if(negFirstBaseToClip > 0) {\n+            clip3PrimeEndOfRead(neg, negFirstBaseToClip, hardClipReads);\n         }\n     }\n \n+    /**\n+     * Gets the read position that corresponds to a particular position on the reference.  If the position on the reference\n+     * falls in a deletion in the alignment of the read, the position before the deletion will be returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDEzMjE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMDozMlrOHb6xAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMDozMlrOHb6xAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNjQxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(negFirstBaseFrom5PrimeEndToClip > 0) {\n          \n          \n            \n                    if (negFirstBaseFrom5PrimeEndToClip > 0) {", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499036419", "createdAt": "2020-10-02T20:30:32Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,69 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n-\n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n+         */\n+\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n+            final int pos5PrimeMostClipped = pos3PrimeMostUnclipped + 1;\n+            clip3PrimeEndOfRead(pos, pos5PrimeMostClipped, hardClipReads);\n         }\n-        if(negClipFrom > 0) {\n-            clip3PrimeEndOfRead(neg, negClipFrom, hardClipReads);\n+\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read.\n+         */\n+\n+        //this is the position counting from the aligned start of the read\n+        final int neg5PrimeMostBaseToClipPositionFromStart = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n+\n+        //this is the position counting from the 5' end of the read\n+        final int negFirstBaseFrom5PrimeEndToClip = neg5PrimeMostBaseToClipPositionFromStart > 0 ? (neg.getReadLength() + 1) - neg5PrimeMostBaseToClipPositionFromStart : 0;\n+\n+        if(negFirstBaseFrom5PrimeEndToClip > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDEzOTI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMzoxNlrOHb61NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMzoxNlrOHb61NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNzQ5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    //this is the position counting from the aligned start of the read\n          \n          \n            \n                    // this is the position counting from the aligned start of the read", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499037492", "createdAt": "2020-10-02T20:33:16Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n          */\n \n-        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n+            final int pos5PrimeMostClipped = pos3PrimeMostUnclipped + 1;\n+            clip3PrimeEndOfRead(pos, pos5PrimeMostClipped, hardClipReads);\n+        }\n \n         /*\n         For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n-         the queried base when the queried base is in a deletion on a negative strand read\n+         the queried base when the queried base is in a deletion on a negative strand read.\n          */\n \n-        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+        //this is the position counting from the aligned start of the read", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDEzOTc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMzoyNlrOHb61eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMzoyNlrOHb61eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNzU2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    //this is the position counting from the 5' end of the read\n          \n          \n            \n                    // this is the position counting from the 5' end of the read", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499037560", "createdAt": "2020-10-02T20:33:26Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n          */\n \n-        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n+            final int pos5PrimeMostClipped = pos3PrimeMostUnclipped + 1;\n+            clip3PrimeEndOfRead(pos, pos5PrimeMostClipped, hardClipReads);\n+        }\n \n         /*\n         For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n-         the queried base when the queried base is in a deletion on a negative strand read\n+         the queried base when the queried base is in a deletion on a negative strand read.\n          */\n \n-        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+        //this is the position counting from the aligned start of the read\n+        final int neg5PrimeMostBaseToClipPositionFromStart = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n \n-        if(posLastUnclipped > 0 && posLastUnclipped < pos.getReadLength()) {\n-            clip3PrimeEndOfRead(pos, posLastUnclipped + 1, hardClipReads);\n-        }\n-        if(negFirstBaseToClip > 0) {\n-            clip3PrimeEndOfRead(neg, negFirstBaseToClip, hardClipReads);\n+        //this is the position counting from the 5' end of the read", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDE1MTk0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozODoyNVrOHb69Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozODoyNVrOHb69Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTUxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n          \n          \n            \n                    if (pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499039519", "createdAt": "2020-10-02T20:38:25Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n          */\n \n-        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDE1MzUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozOTowM1rOHb6-Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozOTowM1rOHb6-Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTc3MQ==", "bodyText": "the 5 looks like an S...\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        3'<SSSSSSSSMMMMMMMMMMMM5'\n          \n          \n            \n                       3' <SSSSSSSSMMMMMMMMMMMM 5'", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499039771", "createdAt": "2020-10-02T20:39:03Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDE1MzkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozOToxM1rOHb6-XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozOToxM1rOHb6-XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTgzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                 5'MMMMMMMMMMMMSSSSSSSS>3'\n          \n          \n            \n                                5' MMMMMMMMMMMMSSSSSSSS> 3'", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499039837", "createdAt": "2020-10-02T20:39:13Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 654, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}