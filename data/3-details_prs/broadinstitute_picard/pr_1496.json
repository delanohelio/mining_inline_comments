{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMDY4Nzc5", "number": 1496, "title": "Bugfix for IdentifyContamiant + small improvements to Fingerprinting", "bodyText": "IdentifyContamiant wrote an incorrect VCF (gasp!) when the minor allele in the haplotype_map matches the reference (as opposed tot he major allele). This PR fixes that. (with a test too!)\n\n\nIdentifyContaminant can also be used to simply extract the fingerprint (in VCF format) from a bam. I've created a new CLP called ExtractFingerprint that does essentially the same as IdentifyContaminant but with the opposite intent (extracting a fingerprint for the intended sample as opposed to the contaminating sample)\n\n\nThe fingerprinting code couldn't function when reads don't have an RG tag, but a lot of data in the wild misses the RG tag and so this PR also enables the user to work with these non-compliant inputs.\n\n\nAnother bug was found in the Tumor-aware part of the code..fixed in this PR", "createdAt": "2020-04-08T20:39:31Z", "url": "https://github.com/broadinstitute/picard/pull/1496", "merged": true, "mergeCommit": {"oid": "5a2e2e23a221355bac2910b2169b93a089c9617a"}, "closed": true, "closedAt": "2020-06-04T22:09:53Z", "author": {"login": "yfarjoun"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXpAqHAFqTM5MzI0NjY1Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoEZhagBqjM0MDg2Nzc3MTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjQ2NjU3", "url": "https://github.com/broadinstitute/picard/pull/1496#pullrequestreview-393246657", "createdAt": "2020-04-14T19:53:10Z", "commit": {"oid": "ec07f3d851b8b4c1dfbec1043c3526b8d469ab8d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1MzoxMFrOGFeeWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1MzoxMFrOGFeeWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5NTM1Mg==", "bodyText": "For public API deprecation, adding a javadoc would be nice.\n/**\n * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n *\n * @deprecated since April 2020 Use {@link #setMaximalPLDifference(String)} instead.\n */", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r408395352", "createdAt": "2020-04-14T19:53:10Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -155,10 +158,15 @@ public void setGenotypingErrorRate(final double genotypingErrorRate) {\n         this.genotypingErrorRate = genotypingErrorRate;\n     }\n \n+    @Deprecated //non-compliant method name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec07f3d851b8b4c1dfbec1043c3526b8d469ab8d"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec07f3d851b8b4c1dfbec1043c3526b8d469ab8d", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/ec07f3d851b8b4c1dfbec1043c3526b8d469ab8d", "committedDate": "2020-04-08T20:47:17Z", "message": "Merge branch 'master' into yf_small_improvements_to_fingerprinting"}, "afterCommit": {"oid": "8023e8a2c05403546998a7fa0a3069f7c0b99338", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/8023e8a2c05403546998a7fa0a3069f7c0b99338", "committedDate": "2020-04-15T20:34:29Z", "message": "- remove max from loglikelihood before converting to probability to protect against an underflow"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4Mjg2MTk3", "url": "https://github.com/broadinstitute/picard/pull/1496#pullrequestreview-408286197", "createdAt": "2020-05-08T14:38:44Z", "commit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "state": "COMMENTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDozODo0NFrOGSn5Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo1ODo1N1rOGSwG2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4MTE2Mg==", "bodyText": "whitespace, here and below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final double[] cappedLogLikelihoods = MathUtil.sum(logLikelihoods,-max);\n          \n          \n            \n                    final double[] cappedLogLikelihoods = MathUtil.sum(logLikelihoods, -max);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422181162", "createdAt": "2020-05-08T14:38:44Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CappedHaplotypeProbabilities.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package picard.fingerprint;\n+\n+import picard.util.MathUtil;\n+\n+public class CappedHaplotypeProbabilities extends HaplotypeProbabilitiesUsingLogLikelihoods {\n+    private final double cap;\n+\n+    // cap should be negative to indicate that you can never be too sure of anything (since the log likelihood is the\n+    //    log probability of an error, it's negative)\n+    public CappedHaplotypeProbabilities(final HaplotypeProbabilities haplotypeProbabilities, double cap) {\n+        super(haplotypeProbabilities.getHaplotype());\n+        this.cap = cap;\n+        final double[] logLikelihoods = haplotypeProbabilities.getLogLikelihoods();\n+        final double max = MathUtil.max(logLikelihoods);\n+        final double[] cappedLogLikelihoods = MathUtil.sum(logLikelihoods,-max);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NzU5MQ==", "bodyText": "IMO it would make this clearer to create a local variable for the expression fingerprintEntry.getValue()", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422197591", "createdAt": "2020-05-08T15:07:04Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -522,6 +531,18 @@ protected int doWork() {\n         }\n     }\n \n+    private void capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n+        for (Map.Entry<FingerprintIdDetails, Fingerprint> fingerprintEntry : fpMap.entrySet()) {\n+            final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5Nzk5OA==", "bodyText": "whitespace missing after , in this method\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());\n          \n          \n            \n                        final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(), fingerprintEntry.getValue().getSource(), fingerprintEntry.getValue().getInfo());", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422197998", "createdAt": "2020-05-08T15:07:41Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -522,6 +531,18 @@ protected int doWork() {\n         }\n     }\n \n+    private void capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n+        for (Map.Entry<FingerprintIdDetails, Fingerprint> fingerprintEntry : fpMap.entrySet()) {\n+            final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5OTM3MQ==", "bodyText": "The code uses keySet() but then only uses get() on it. You should get the same effect by looping over values(). like\n    for (HaplotypeProbabilities probabilities : fingerprintEntry.getValue().values()) {\n        HaplotypeProbabilities cappedHp = new CappedHaplotypeProbabilities(probabilities, -MAX_EFFECT_OF_EACH_HAPLOTYPE_BLOCK);\n        cappedFp.add(cappedHp);\n    }", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422199371", "createdAt": "2020-05-08T15:10:03Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -522,6 +531,18 @@ protected int doWork() {\n         }\n     }\n \n+    private void capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n+        for (Map.Entry<FingerprintIdDetails, Fingerprint> fingerprintEntry : fpMap.entrySet()) {\n+            final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());\n+\n+            for (HaplotypeBlock haplotypeBlock : fingerprintEntry.getValue().keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMDUzMw==", "bodyText": "This code modifies its argument in place. It looks like it replaces every entry with a new entry. If so, IMO a better model would be to create a new map with the new values and return the new map, instead of overwriting the argument.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422200533", "createdAt": "2020-05-08T15:12:21Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -522,6 +531,18 @@ protected int doWork() {\n         }\n     }\n \n+    private void capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n+        for (Map.Entry<FingerprintIdDetails, Fingerprint> fingerprintEntry : fpMap.entrySet()) {\n+            final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());\n+\n+            for (HaplotypeBlock haplotypeBlock : fingerprintEntry.getValue().keySet()) {\n+                HaplotypeProbabilities cappedHp = new CappedHaplotypeProbabilities(fingerprintEntry.getValue().get(haplotypeBlock),-MAX_EFFECT_OF_EACH_HAPLOTYPE_BLOCK);\n+                cappedFp.add(cappedHp);\n+            }\n+            fpMap.put(fingerprintEntry.getKey(), cappedFp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMTExNw==", "bodyText": "It looks like this should be fpMap2. If so, it would be nice to have a test that could've found this error.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422201117", "createdAt": "2020-05-08T15:13:22Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -478,6 +485,8 @@ protected int doWork() {\n         } else {\n             log.info(\"Fingerprinting \" + unrolledFiles2.size() + \" SECOND_INPUT files.\");\n             final Map<FingerprintIdDetails, Fingerprint> fpMap2 = checker.fingerprintFiles(unrolledFiles2, NUM_THREADS, 1, TimeUnit.DAYS);\n+            capFingerprints(fpMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwNDYwMw==", "bodyText": "Not sure if streaming operations makes this code clearer or less clear, but here's one way to do this\n    private Map<FingerprintIdDetails, Fingerprint> capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n        return\n            fpMap.entrySet().stream()\n                    .collect(Collectors.toMap(Map.Entry::getKey, entry -> {\n                        Fingerprint value = entry.getValue();\n                        final Fingerprint cappedFp = new Fingerprint(value.getSample(), value.getSource(), value.getInfo());\n\n                        value.values().stream()\n                                .map(probabilities -> new CappedHaplotypeProbabilities(probabilities, -MAX_EFFECT_OF_EACH_HAPLOTYPE_BLOCK))\n                                .forEach(cappedFp::add);\n                        return cappedFp;\n                    }));\n    }", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422204603", "createdAt": "2020-05-08T15:19:49Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -522,6 +531,18 @@ protected int doWork() {\n         }\n     }\n \n+    private void capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n+        for (Map.Entry<FingerprintIdDetails, Fingerprint> fingerprintEntry : fpMap.entrySet()) {\n+            final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());\n+\n+            for (HaplotypeBlock haplotypeBlock : fingerprintEntry.getValue().keySet()) {\n+                HaplotypeProbabilities cappedHp = new CappedHaplotypeProbabilities(fingerprintEntry.getValue().get(haplotypeBlock),-MAX_EFFECT_OF_EACH_HAPLOTYPE_BLOCK);\n+                cappedFp.add(cappedHp);\n+            }\n+            fpMap.put(fingerprintEntry.getKey(), cappedFp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMDUzMw=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwNTk5OA==", "bodyText": "log can be static\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Log log = Log.getInstance(ExtractFingerprint.class);\n          \n          \n            \n                private static final Log log = Log.getInstance(ExtractFingerprint.class);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422205998", "createdAt": "2020-05-08T15:22:29Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")\n+    public int LOCUS_MAX_READS = 200;\n+\n+    @Argument(doc = \"Extract a fingerprint for the contaminat sample (instead of the contaminant). Setting to true changes the effect of SAMPLE_ALIAS when null. \" +\n+            \"It names the sample in the VCF <SAMPLE>-contaminated, using the SM value from the SAM header.\")\n+    public boolean EXTRACT_CONTAMINATION = false;\n+\n+    @Override\n+    protected boolean requiresReference() {\n+        return true;\n+    }\n+\n+    private final Log log = Log.getInstance(ExtractFingerprint.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwNjY0MA==", "bodyText": "please use { } for all ifs\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!EXTRACT_CONTAMINATION) CONTAMINATION = 1 - CONTAMINATION;\n          \n          \n            \n                    if (!EXTRACT_CONTAMINATION) {\n          \n          \n            \n                        CONTAMINATION = 1 - CONTAMINATION;\n          \n          \n            \n                    }", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422206640", "createdAt": "2020-05-08T15:23:46Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")\n+    public int LOCUS_MAX_READS = 200;\n+\n+    @Argument(doc = \"Extract a fingerprint for the contaminat sample (instead of the contaminant). Setting to true changes the effect of SAMPLE_ALIAS when null. \" +\n+            \"It names the sample in the VCF <SAMPLE>-contaminated, using the SM value from the SAM header.\")\n+    public boolean EXTRACT_CONTAMINATION = false;\n+\n+    @Override\n+    protected boolean requiresReference() {\n+        return true;\n+    }\n+\n+    private final Log log = Log.getInstance(ExtractFingerprint.class);\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        IOUtil.assertFileIsReadable(HAPLOTYPE_MAP);\n+        IOUtil.assertFileIsWritable(OUTPUT);\n+        IOUtil.assertFileIsReadable(referenceSequence.getReferenceFile());\n+\n+        final FingerprintChecker checker = new FingerprintChecker(HAPLOTYPE_MAP);\n+\n+        // if we want the contaminated fingerprint instead, we need to change the value of CONTAMINATION:\n+        if (!EXTRACT_CONTAMINATION) CONTAMINATION = 1 - CONTAMINATION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5MDA2Nw==", "bodyText": "It looks like this can be final\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Set<Path> missingRGFiles = new HashSet<>();\n          \n          \n            \n                private final Set<Path> missingRGFiles = new HashSet<>();", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422290067", "createdAt": "2020-05-08T18:07:42Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -116,6 +113,10 @@ public File getReferenceFasta() {\n \n     private boolean allowDuplicateReads = false;\n     private double pLossofHet = 0;\n+    private int locusMaxReads = 0;\n+    private String defaultSampleID = \"<UNKNOWN>\";\n+\n+    private Set<Path> missingRGFiles = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5NTExMA==", "bodyText": "Since the method you're forwarding to is also deprecated, it seems like this comment should also mention CappedHaplotypeProbabilities", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422295110", "createdAt": "2020-05-08T18:17:35Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -156,12 +157,23 @@ public void setGenotypingErrorRate(final double genotypingErrorRate) {\n     }\n \n     /**\n-     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * Does same thing as {@link #setMaximalPLDifference(int)} but named in the compliant way.\n+     *\n+     * @deprecated use {@link #setMaximalPLDifference(int)} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5NTQwMg==", "bodyText": "Can you use {@link CappedHaplotypeProbabilities} here?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422295402", "createdAt": "2020-05-08T18:18:10Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -156,12 +157,23 @@ public void setGenotypingErrorRate(final double genotypingErrorRate) {\n     }\n \n     /**\n-     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * Does same thing as {@link #setMaximalPLDifference(int)} but named in the compliant way.\n+     *\n+     * @deprecated use {@link #setMaximalPLDifference(int)} instead.\n+     * @since 16/4/2020\n      */\n+    @Deprecated\n     public void setmaximalPLDifference(final int maximalPLDifference) {\n-        this.maximalPLDifference = maximalPLDifference;\n+        setMaximalPLDifference(maximalPLDifference);\n     }\n \n+    /**\n+     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * @deprecated since 04/2020. use CappedHaplotypeProbabilities and explicitly cap your probabilities.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5NTc5MQ==", "bodyText": "Why add a new method name with no contents that is deprecated?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422295791", "createdAt": "2020-05-08T18:18:57Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -156,12 +157,23 @@ public void setGenotypingErrorRate(final double genotypingErrorRate) {\n     }\n \n     /**\n-     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * Does same thing as {@link #setMaximalPLDifference(int)} but named in the compliant way.\n+     *\n+     * @deprecated use {@link #setMaximalPLDifference(int)} instead.\n+     * @since 16/4/2020\n      */\n+    @Deprecated\n     public void setmaximalPLDifference(final int maximalPLDifference) {\n-        this.maximalPLDifference = maximalPLDifference;\n+        setMaximalPLDifference(maximalPLDifference);\n     }\n \n+    /**\n+     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * @deprecated since 04/2020. use CappedHaplotypeProbabilities and explicitly cap your probabilities.\n+     */\n+    @Deprecated\n+    public void setMaximalPLDifference(final int maximalPLDifference) { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5Nzc4Mw==", "bodyText": "unnecessary .toString()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        log.debug(() -> \"At locus \" + info.toString());\n          \n          \n            \n                        log.debug(() -> \"At locus \" + info);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422297783", "createdAt": "2020-05-08T18:23:03Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -522,11 +539,8 @@ public IntervalList getLociToGenotype(final Collection<Fingerprint> fingerprints\n         // Now go through the data at each locus and figure stuff out!\n         for (final SamLocusIterator.LocusInfo info : iterator) {\n \n-            // if statement to avoid string building.\n-            // TODO: replace with lambda version once htsjdk is rev'ed\n-            if (Log.isEnabled(Log.LogLevel.DEBUG)) {\n-                log.debug(\"At locus \" + info.toString());\n-            }\n+            log.debug(() -> \"At locus \" + info.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMzE4Mw==", "bodyText": "If rg == null then fingerprintIdDetailsMap.containsKey(rg) is always true because the if block above adds null to the map. So it seems like the rg == null test is unnecessary.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422303183", "createdAt": "2020-05-08T18:33:33Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -535,22 +549,31 @@ public IntervalList getLociToGenotype(final Collection<Fingerprint> fingerprints\n             final HaplotypeBlock haplotypeBlock = this.haplotypes.getHaplotype(info.getSequenceName(), info.getPosition());\n             final Snp snp = this.haplotypes.getSnp(info.getSequenceName(), info.getPosition());\n \n-            for (final SamLocusIterator.RecordAndOffset rec : info.getRecordAndOffsets()) {\n+            // randomly select locusMaxReads elements from the list\n+            final List<SamLocusIterator.RecordAndOffset> recordAndOffsetList = locusMaxReads == 0 ?\n+                    info.getRecordAndOffsets() :\n+                    MathUtil.randomSublist(info.getRecordAndOffsets(), locusMaxReads, random);\n+\n+            for (final SamLocusIterator.RecordAndOffset rec : recordAndOffsetList) {\n                 final SAMReadGroupRecord rg = rec.getRecord().getReadGroup();\n                 final FingerprintIdDetails details;\n-                if (rg == null || !fingerprintIdDetailsMap.containsKey(rg)) {\n+\n+                // if there's a missing rg tag, add the unknown FP id to the map\n+                if (rg == null && !fingerprintIdDetailsMap.containsKey(null)) {\n+\n                     final FingerprintIdDetails unknownFPDetails = createUnknownFP(samFile, rec.getRecord());\n+\n                     fingerprintIdDetailsMap.put(null, unknownFPDetails);\n \n                     final Fingerprint fp = new Fingerprint(unknownFPDetails.sample, samFile, unknownFPDetails.platformUnit);\n                     fingerprintsByReadGroup.put(unknownFPDetails, fp);\n \n                     for (final HaplotypeBlock h : this.haplotypes.getHaplotypes()) {\n-                        fp.add(new HaplotypeProbabilitiesFromSequence(h));\n+                        fp.add(blockToProbMapper.apply(h));\n                     }\n                 }\n \n-                if (fingerprintIdDetailsMap.containsKey(rg)) {\n+                if (rg == null || fingerprintIdDetailsMap.containsKey(rg)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNDE1NA==", "bodyText": "()s unnecessary for single arg lambda\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = this.fingerprintSamFile(samFile, (h) -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n          \n          \n            \n                    final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = this.fingerprintSamFile(samFile, h -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422304154", "createdAt": "2020-05-08T18:35:22Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -597,77 +620,16 @@ private FingerprintIdDetails createUnknownFP(final Path samFile, final SAMRecord\n      * Generates a per-sample Fingerprint for the contaminant in the supplied SAM file.\n      * Data is aggregated by sample, not read-group.\n      */\n-    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination, final int locusMaxReads) {\n-        final Map<String, Fingerprint> fingerprintsBySample = new HashMap<>();\n-\n-        try (final SamReader in = SamReaderFactory.makeDefault().enable(CACHE_FILE_BASED_INDEXES).open(samFile)) {\n-            checkDictionaryGoodForFingerprinting(in.getFileHeader().getSequenceDictionary());\n-\n-            final SamLocusIterator iterator = new SamLocusIterator(in, haplotypes.getIntervalList(), in.hasIndex());\n-            iterator.setEmitUncoveredLoci(true);\n-            iterator.setMappingQualityScoreCutoff(this.minimumMappingQuality);\n-            iterator.setQualityScoreCutoff(this.minimumBaseQuality);\n-\n-            // In some cases it is useful to allow duplicate reads to be used - the most common is in single-end\n-            // sequence data where the duplicate marking may have been overly aggressive, and there is useful\n-            // non-redundant data in the reads marked as \"duplicates'.\n-            if (this.allowDuplicateReads) {\n-                final List<SamRecordFilter> filters = new ArrayList<>(1);\n-                filters.add(new SecondaryAlignmentFilter());\n-                iterator.setSamFilters(filters);\n-            }\n+    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination) {\n \n-            for (final SAMReadGroupRecord rg : in.getFileHeader().getReadGroups()) {\n-                if (!fingerprintsBySample.containsKey(rg.getSample())) {\n-                    final Fingerprint fingerprint = new Fingerprint(rg.getSample(),\n-                            samFile,\n-                            rg.getSample());\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = this.fingerprintSamFile(samFile, (h) -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNDU0Mw==", "bodyText": "Personally I would use a shorter name here, but if you want to use this long name, then by should be capitalized.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintbySample = Fingerprint.mergeFingerprintsBy(fingerprintIdDetailsFingerprintMap,\n          \n          \n            \n                    final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintBySample = Fingerprint.mergeFingerprintsBy(fingerprintIdDetailsFingerprintMap,", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422304543", "createdAt": "2020-05-08T18:36:12Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -597,77 +620,16 @@ private FingerprintIdDetails createUnknownFP(final Path samFile, final SAMRecord\n      * Generates a per-sample Fingerprint for the contaminant in the supplied SAM file.\n      * Data is aggregated by sample, not read-group.\n      */\n-    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination, final int locusMaxReads) {\n-        final Map<String, Fingerprint> fingerprintsBySample = new HashMap<>();\n-\n-        try (final SamReader in = SamReaderFactory.makeDefault().enable(CACHE_FILE_BASED_INDEXES).open(samFile)) {\n-            checkDictionaryGoodForFingerprinting(in.getFileHeader().getSequenceDictionary());\n-\n-            final SamLocusIterator iterator = new SamLocusIterator(in, haplotypes.getIntervalList(), in.hasIndex());\n-            iterator.setEmitUncoveredLoci(true);\n-            iterator.setMappingQualityScoreCutoff(this.minimumMappingQuality);\n-            iterator.setQualityScoreCutoff(this.minimumBaseQuality);\n-\n-            // In some cases it is useful to allow duplicate reads to be used - the most common is in single-end\n-            // sequence data where the duplicate marking may have been overly aggressive, and there is useful\n-            // non-redundant data in the reads marked as \"duplicates'.\n-            if (this.allowDuplicateReads) {\n-                final List<SamRecordFilter> filters = new ArrayList<>(1);\n-                filters.add(new SecondaryAlignmentFilter());\n-                iterator.setSamFilters(filters);\n-            }\n+    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination) {\n \n-            for (final SAMReadGroupRecord rg : in.getFileHeader().getReadGroups()) {\n-                if (!fingerprintsBySample.containsKey(rg.getSample())) {\n-                    final Fingerprint fingerprint = new Fingerprint(rg.getSample(),\n-                            samFile,\n-                            rg.getSample());\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = this.fingerprintSamFile(samFile, (h) -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n \n-                    for (final HaplotypeBlock h : this.haplotypes.getHaplotypes()) {\n-                        fingerprint.add(new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n-                    }\n-                    fingerprintsBySample.put(rg.getSample(), fingerprint);\n-                }\n-            }\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintbySample = Fingerprint.mergeFingerprintsBy(fingerprintIdDetailsFingerprintMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNDc3OA==", "bodyText": "Since this variable is returned directly it would be better IMO to return here rather than declaring a variable.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422304778", "createdAt": "2020-05-08T18:36:42Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -597,77 +620,16 @@ private FingerprintIdDetails createUnknownFP(final Path samFile, final SAMRecord\n      * Generates a per-sample Fingerprint for the contaminant in the supplied SAM file.\n      * Data is aggregated by sample, not read-group.\n      */\n-    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination, final int locusMaxReads) {\n-        final Map<String, Fingerprint> fingerprintsBySample = new HashMap<>();\n-\n-        try (final SamReader in = SamReaderFactory.makeDefault().enable(CACHE_FILE_BASED_INDEXES).open(samFile)) {\n-            checkDictionaryGoodForFingerprinting(in.getFileHeader().getSequenceDictionary());\n-\n-            final SamLocusIterator iterator = new SamLocusIterator(in, haplotypes.getIntervalList(), in.hasIndex());\n-            iterator.setEmitUncoveredLoci(true);\n-            iterator.setMappingQualityScoreCutoff(this.minimumMappingQuality);\n-            iterator.setQualityScoreCutoff(this.minimumBaseQuality);\n-\n-            // In some cases it is useful to allow duplicate reads to be used - the most common is in single-end\n-            // sequence data where the duplicate marking may have been overly aggressive, and there is useful\n-            // non-redundant data in the reads marked as \"duplicates'.\n-            if (this.allowDuplicateReads) {\n-                final List<SamRecordFilter> filters = new ArrayList<>(1);\n-                filters.add(new SecondaryAlignmentFilter());\n-                iterator.setSamFilters(filters);\n-            }\n+    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination) {\n \n-            for (final SAMReadGroupRecord rg : in.getFileHeader().getReadGroups()) {\n-                if (!fingerprintsBySample.containsKey(rg.getSample())) {\n-                    final Fingerprint fingerprint = new Fingerprint(rg.getSample(),\n-                            samFile,\n-                            rg.getSample());\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = this.fingerprintSamFile(samFile, (h) -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n \n-                    for (final HaplotypeBlock h : this.haplotypes.getHaplotypes()) {\n-                        fingerprint.add(new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n-                    }\n-                    fingerprintsBySample.put(rg.getSample(), fingerprint);\n-                }\n-            }\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintbySample = Fingerprint.mergeFingerprintsBy(fingerprintIdDetailsFingerprintMap,\n+                Fingerprint.getFingerprintIdDetailsStringFunction(CrosscheckMetric.DataType.SAMPLE));\n+\n+        final Map<String,Fingerprint> fingerprintsBySample = fingerprintIdDetailsFingerprintbySample.entrySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNTU5MQ==", "bodyText": "This was added because there is a need to change the default sample ID outside of picard? It's not currently used.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422305591", "createdAt": "2020-05-08T18:38:30Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -931,4 +890,20 @@ public static MatchResults calculateMatchResults(final Fingerprint observedFp, f\n     public void setReferenceFasta(final File referenceFasta) {\n         this.referenceFasta = referenceFasta;\n     }\n+\n+    public int getLocusMaxReads() {\n+        return locusMaxReads;\n+    }\n+\n+    public void setLocusMaxReads(final int locusMaxReads) {\n+        this.locusMaxReads = locusMaxReads;\n+    }\n+\n+    public String getDefaultSampleID() {\n+        return defaultSampleID;\n+    }\n+\n+    public void setDefaultSampleID(final String defaultSampleID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjk1Ng==", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele){\n          \n          \n            \n                    if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele) {", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422306956", "createdAt": "2020-05-08T18:41:14Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "diffHunk": "@@ -137,15 +152,38 @@ private static VariantContext getVariantContext(final ReferenceSequenceFile refe\n                 snp.getPos(),\n                 snp.getPos()).getBases()[0]);\n \n-        final Allele allele1 = Allele.create(snp.getAllele1(), snp.getAllele1() == refAllele);\n-        final Allele allele2 = Allele.create(snp.getAllele2(), snp.getAllele2() == refAllele);\n-        final List<Allele> alleles = Arrays.asList(allele1, allele2);\n+        if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzgwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final double[] PLs =  Arrays.copyOf(haplotypeProbabilities.getLogLikelihoods(),HaplotypeProbabilities.NUM_GENOTYPES);\n          \n          \n            \n                    final double[] PLs =  Arrays.copyOf(haplotypeProbabilities.getLogLikelihoods(), HaplotypeProbabilities.NUM_GENOTYPES);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422307808", "createdAt": "2020-05-08T18:43:00Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "diffHunk": "@@ -137,15 +152,38 @@ private static VariantContext getVariantContext(final ReferenceSequenceFile refe\n                 snp.getPos(),\n                 snp.getPos()).getBases()[0]);\n \n-        final Allele allele1 = Allele.create(snp.getAllele1(), snp.getAllele1() == refAllele);\n-        final Allele allele2 = Allele.create(snp.getAllele2(), snp.getAllele2() == refAllele);\n-        final List<Allele> alleles = Arrays.asList(allele1, allele2);\n+        if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele){\n+            throw new PicardException(\"Don't know how to deal with missing reference allele in fingerprinting map\");\n+        }\n+\n+        final Allele alleleRef;\n+        final Allele alleleAlt;\n+        final int obsRef, obsAlt;\n+        final boolean swap12 = snp.getAllele2() == refAllele;\n+\n+        if (swap12) {\n+            alleleRef = Allele.create(snp.getAllele2(), true);\n+            alleleAlt = Allele.create(snp.getAllele1(), false);\n+            obsRef = haplotypeProbabilities.getObsAllele2();\n+            obsAlt = haplotypeProbabilities.getObsAllele1();\n+        } else {\n+            alleleRef = Allele.create(snp.getAllele1(), true);\n+            alleleAlt = Allele.create(snp.getAllele2(), false);\n+            obsRef = haplotypeProbabilities.getObsAllele1();\n+            obsAlt = haplotypeProbabilities.getObsAllele2();\n+        }\n+\n+        final double[] PLs =  Arrays.copyOf(haplotypeProbabilities.getLogLikelihoods(),HaplotypeProbabilities.NUM_GENOTYPES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwOTMzNQ==", "bodyText": "Is there a reason to use NUM_GENOTYPES here instead of haplotypeProbabilities.getLogLikelihoods().length? Using length would make it clearer what the code is doing; it's copying the entire array.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422309335", "createdAt": "2020-05-08T18:46:02Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "diffHunk": "@@ -137,15 +152,38 @@ private static VariantContext getVariantContext(final ReferenceSequenceFile refe\n                 snp.getPos(),\n                 snp.getPos()).getBases()[0]);\n \n-        final Allele allele1 = Allele.create(snp.getAllele1(), snp.getAllele1() == refAllele);\n-        final Allele allele2 = Allele.create(snp.getAllele2(), snp.getAllele2() == refAllele);\n-        final List<Allele> alleles = Arrays.asList(allele1, allele2);\n+        if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele){\n+            throw new PicardException(\"Don't know how to deal with missing reference allele in fingerprinting map\");\n+        }\n+\n+        final Allele alleleRef;\n+        final Allele alleleAlt;\n+        final int obsRef, obsAlt;\n+        final boolean swap12 = snp.getAllele2() == refAllele;\n+\n+        if (swap12) {\n+            alleleRef = Allele.create(snp.getAllele2(), true);\n+            alleleAlt = Allele.create(snp.getAllele1(), false);\n+            obsRef = haplotypeProbabilities.getObsAllele2();\n+            obsAlt = haplotypeProbabilities.getObsAllele1();\n+        } else {\n+            alleleRef = Allele.create(snp.getAllele1(), true);\n+            alleleAlt = Allele.create(snp.getAllele2(), false);\n+            obsRef = haplotypeProbabilities.getObsAllele1();\n+            obsAlt = haplotypeProbabilities.getObsAllele2();\n+        }\n+\n+        final double[] PLs =  Arrays.copyOf(haplotypeProbabilities.getLogLikelihoods(),HaplotypeProbabilities.NUM_GENOTYPES);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzgwOA=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMxNTczNw==", "bodyText": "You can avoid updating this if the type of LOD_SCORE ever changes by using String.valueOf()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> Double.toString(s.LOD_SCORE + 0), Collectors.toSet())));\n          \n          \n            \n                            .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> String.valueOf(s.LOD_SCORE + 0), Collectors.toSet())));", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422315737", "createdAt": "2020-05-08T18:58:57Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -203,7 +204,8 @@ public void testCheckFingerprintsSam(final File samFile1, final File samFile2, f\n         final List<CrosscheckMetric> metrics = metricsFileReader.getMetrics();\n \n         final Map<Set<String>, Set<String>> collected = metrics.stream()\n-                .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> s.LOD_SCORE.toString(), Collectors.toSet())));\n+//                we sometimes get -0.0, and so the comparison fails...\n+                .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> Double.toString(s.LOD_SCORE + 0), Collectors.toSet())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMDM2Njc4", "url": "https://github.com/broadinstitute/picard/pull/1496#pullrequestreview-410036678", "createdAt": "2020-05-12T13:24:36Z", "commit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "state": "APPROVED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzoyNDozNlrOGUGZOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMzoxM1rOGU289w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcyOTQ2NA==", "bodyText": "This operation is also done in CappedHaplotypeProbabilities, would it make sense to make a method for it in MathUtil?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r423729464", "createdAt": "2020-05-12T13:24:36Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "diffHunk": "@@ -168,11 +169,15 @@ public HaplotypeProbabilitiesUsingLogLikelihoods merge(final HaplotypeProbabilit\n \n     public void setLogLikelihoods(final double[] ll) {\n         ValidationUtils.validateArg(ll.length == NUM_GENOTYPES,\n-                ()->\"logLikelihood must have length 3, found \" + ll.length);\n+                () -> \"logLikelihood must have length 3, found \" + ll.length);\n+\n+//        protect from underflow\n+        double max = MathUtil.max(ll);\n+        final double[] maxRemoved = MathUtil.sum(ll, -max);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzczNzU4MA==", "bodyText": "This looks like a different operation than MathUtil.max(double[]). The usual rule for overloaded methods is that the overloaded method should perform the same operation as the original. The main use of overloads is so you can provide default argument values. Maybe 'maxCap() and 'minCap()?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r423737580", "createdAt": "2020-05-12T13:35:32Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/util/MathUtil.java", "diffHunk": "@@ -168,6 +168,18 @@ public static double max(final double[] nums) {\n         return nums[indexOfMax(nums)];\n     }\n \n+    /**\n+     * Returns the array capped (from below) by the value of scalar\n+     */\n+    public static double[] max(final double[] nums, final double scalar) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzczODIyOQ==", "bodyText": "whitespace typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void     testSummaryAndDetailOutputs() {\n          \n          \n            \n                public void testSummaryAndDetailOutputs() {", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r423738229", "createdAt": "2020-05-12T13:36:23Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -116,7 +119,7 @@ public void testMismatchingSamples2() {\n     }\n \n     @Test\n-    public void testSummaryAndDetailOutputs() {\n+    public void     testSummaryAndDetailOutputs() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMjM0MA==", "bodyText": "Would it be odd for Fingerprint.merge() to return itself? that would make streaming ops like this a bit cleaner to write.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424522340", "createdAt": "2020-05-13T15:19:40Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        checker.setLocusMaxReads(100);\n+        final Fingerprint fingerprint = checker.identifyContaminant(Na12892.toPath(), 1).get(\"NA12892\");\n+        Assert.assertNotNull(fingerprint);\n+\n+        final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");\n+        tempFile.deleteOnExit();\n+\n+        FingerprintUtils.writeFingerPrint(fingerprint,tempFile,SHIFTED_REFERENCE,\n+                \"NA12892\",null);\n+\n+        final Fingerprint NA12892FromVCF = checker.fingerprintFiles(Collections.singleton(tempFile.toPath()), 1, 1, TimeUnit.DAYS)\n+                .values().stream()\n+                .reduce((a, b) -> {\n+                    a.merge(b);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMjY1OQ==", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                   final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n          \n          \n            \n                    final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424522659", "createdAt": "2020-05-13T15:20:02Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMjgyMA==", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");\n          \n          \n            \n                    final File tempFile = File.createTempFile(\"testWriteFingerprint\", \".vcf\");", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424522820", "createdAt": "2020-05-13T15:20:16Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        checker.setLocusMaxReads(100);\n+        final Fingerprint fingerprint = checker.identifyContaminant(Na12892.toPath(), 1).get(\"NA12892\");\n+        Assert.assertNotNull(fingerprint);\n+\n+        final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMzAxOQ==", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FingerprintUtils.writeFingerPrint(fingerprint,tempFile,SHIFTED_REFERENCE,\n          \n          \n            \n                    FingerprintUtils.writeFingerPrint(fingerprint,tempFile, SHIFTED_REFERENCE,\n          \n          \n            \n                                    \"NA12892\", null);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424523019", "createdAt": "2020-05-13T15:20:34Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        checker.setLocusMaxReads(100);\n+        final Fingerprint fingerprint = checker.identifyContaminant(Na12892.toPath(), 1).get(\"NA12892\");\n+        Assert.assertNotNull(fingerprint);\n+\n+        final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");\n+        tempFile.deleteOnExit();\n+\n+        FingerprintUtils.writeFingerPrint(fingerprint,tempFile,SHIFTED_REFERENCE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMzU2OA==", "bodyText": "more whitespace.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Assert.assertTrue(FingerprintChecker.calculateMatchResults(NA12892FromVCF, NA12892_fp).getLOD() >1D);\n          \n          \n            \n                    Assert.assertTrue(FingerprintChecker.calculateMatchResults(NA12892FromVCF, NA12892_fp).getLOD() > 1D);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424523568", "createdAt": "2020-05-13T15:21:17Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        checker.setLocusMaxReads(100);\n+        final Fingerprint fingerprint = checker.identifyContaminant(Na12892.toPath(), 1).get(\"NA12892\");\n+        Assert.assertNotNull(fingerprint);\n+\n+        final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");\n+        tempFile.deleteOnExit();\n+\n+        FingerprintUtils.writeFingerPrint(fingerprint,tempFile,SHIFTED_REFERENCE,\n+                \"NA12892\",null);\n+\n+        final Fingerprint NA12892FromVCF = checker.fingerprintFiles(Collections.singleton(tempFile.toPath()), 1, 1, TimeUnit.DAYS)\n+                .values().stream()\n+                .reduce((a, b) -> {\n+                    a.merge(b);\n+                    return a;\n+                })\n+                .orElseThrow(() -> new IllegalArgumentException(\"Did not find any data for contaminant\"));\n+        Assert.assertNotNull(NA12892FromVCF);\n+\n+        Assert.assertTrue(FingerprintChecker.calculateMatchResults(fingerprint, NA12892FromVCF).getLOD() > 1D);\n+\n+\n+        final Fingerprint NA12891_fp = checker.fingerprintFiles(Collections.singleton(Na12891.toPath()), 1, 1, TimeUnit.DAYS)\n+                .values().stream()\n+                .reduce((a, b) -> {\n+                    a.merge(b);\n+                    return a;\n+                })\n+                .orElseThrow(() -> new IllegalArgumentException(\"Did not find any data for contaminated\"));\n+        Assert.assertNotNull(NA12891_fp);\n+\n+        Assert.assertTrue(FingerprintChecker.calculateMatchResults(NA12891_fp, NA12892FromVCF).getLOD() < -4D);\n+\n+        final Fingerprint NA12892_fp = checker.fingerprintFiles(Collections.singleton(Na12892.toPath()), 1, 1, TimeUnit.DAYS)\n+                .values().stream()\n+                .reduce((a, b) -> {\n+                    a.merge(b);\n+                    return a;\n+                })\n+                .orElseThrow(() -> new IllegalArgumentException(\"Did not find any data for contaminated\"));\n+        Assert.assertNotNull(NA12892_fp);\n+\n+        Assert.assertTrue(FingerprintChecker.calculateMatchResults(NA12892FromVCF, NA12892_fp).getLOD() >1D);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyNTA0Nw==", "bodyText": "unless you're commenting out code, // comments should left align with the current indent line.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424525047", "createdAt": "2020-05-13T15:23:13Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -203,7 +204,8 @@ public void testCheckFingerprintsSam(final File samFile1, final File samFile2, f\n         final List<CrosscheckMetric> metrics = metricsFileReader.getMetrics();\n \n         final Map<Set<String>, Set<String>> collected = metrics.stream()\n-                .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> s.LOD_SCORE.toString(), Collectors.toSet())));\n+//                we sometimes get -0.0, and so the comparison fails...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb83a07ef44e0fc08511355e62183bbddf16d6f0", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/eb83a07ef44e0fc08511355e62183bbddf16d6f0", "committedDate": "2020-05-29T21:27:18Z", "message": "- responding to review\n- found another bug...this time in the implementation of the tumor-aware LOD....\n- this PR includes tests that fail and commented code that will fix them in a subsequent commit"}, "afterCommit": {"oid": "1e2562d57d409510b99a64ed5c18d521d73d6f69", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/1e2562d57d409510b99a64ed5c18d521d73d6f69", "committedDate": "2020-05-29T21:39:30Z", "message": "- this is the bugfix for the tumor normal bug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTEyMTMw", "url": "https://github.com/broadinstitute/picard/pull/1496#pullrequestreview-421912130", "createdAt": "2020-06-01T14:55:30Z", "commit": {"oid": "1e2562d57d409510b99a64ed5c18d521d73d6f69"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDo1NTozMFrOGdNi0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDo1NTozMFrOGdNi0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4Mzc5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns the array capped (from above) by the value of floor\n          \n          \n            \n                 * Returns the array capped (from above) by the value of top", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r433283793", "createdAt": "2020-06-01T14:55:30Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/util/MathUtil.java", "diffHunk": "@@ -251,6 +271,18 @@ public static byte min(final byte[] nums) {\n         return min;\n     }\n \n+    /**\n+     * Returns the array capped (from above) by the value of floor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2562d57d409510b99a64ed5c18d521d73d6f69"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNzEyMzQz", "url": "https://github.com/broadinstitute/picard/pull/1496#pullrequestreview-422712343", "createdAt": "2020-06-02T14:03:58Z", "commit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDowMzo1OFrOGdzP8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxOTo1NzozN1rOGerPlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMTU1NQ==", "bodyText": "must have length 3, or must have length NUM_GENOTYPES?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r433901555", "createdAt": "2020-06-02T14:03:58Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "diffHunk": "@@ -168,11 +169,14 @@ public HaplotypeProbabilitiesUsingLogLikelihoods merge(final HaplotypeProbabilit\n \n     public void setLogLikelihoods(final double[] ll) {\n         ValidationUtils.validateArg(ll.length == NUM_GENOTYPES,\n-                ()->\"logLikelihood must have length 3, found \" + ll.length);\n+                () -> \"logLikelihood must have length 3, found \" + ll.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyNzk3MA==", "bodyText": "Could you add unit tests for this function.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r433927970", "createdAt": "2020-06-02T14:38:33Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/util/MathUtil.java", "diffHunk": "@@ -209,6 +220,15 @@ public static int indexOfMax(final long[] nums) {\n         return index;\n     }\n \n+    /* Find the maximal value of the array and return a new array\n+    consisting of that value subtracted from the original array\n+     */\n+    public static double[] subtractMax(final double[] logLikelihoods) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc0NjU1Mw==", "bodyText": "2020, and in a few other files.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r434746553", "createdAt": "2020-06-03T17:47:18Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc0NzU2OA==", "bodyText": "Is this true that this limits the effect any locus can have, and if so, isn't 200 really a lot?  Why not 30 or 50?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r434747568", "createdAt": "2020-06-03T17:48:58Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2OTEwMA==", "bodyText": "-contamination", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r434769100", "createdAt": "2020-06-03T18:26:16Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")\n+    public int LOCUS_MAX_READS = 200;\n+\n+    @Argument(doc = \"Extract a fingerprint for the contaminat sample (instead of the contaminant). Setting to true changes the effect of SAMPLE_ALIAS when null. \" +\n+            \"It names the sample in the VCF <SAMPLE>-contaminated, using the SM value from the SAM header.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3MDE0MA==", "bodyText": "Would this be better as a try-with-resources block?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r434770140", "createdAt": "2020-06-03T18:28:08Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")\n+    public int LOCUS_MAX_READS = 200;\n+\n+    @Argument(doc = \"Extract a fingerprint for the contaminat sample (instead of the contaminant). Setting to true changes the effect of SAMPLE_ALIAS when null. \" +\n+            \"It names the sample in the VCF <SAMPLE>-contaminated, using the SM value from the SAM header.\")\n+    public boolean EXTRACT_CONTAMINATION = false;\n+\n+    @Override\n+    protected boolean requiresReference() {\n+        return true;\n+    }\n+\n+    private static final Log log = Log.getInstance(ExtractFingerprint.class);\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        IOUtil.assertFileIsReadable(HAPLOTYPE_MAP);\n+        IOUtil.assertFileIsWritable(OUTPUT);\n+        IOUtil.assertFileIsReadable(referenceSequence.getReferenceFile());\n+\n+        final FingerprintChecker checker = new FingerprintChecker(HAPLOTYPE_MAP);\n+\n+        // if we want the contaminated fingerprint instead, we need to change the value of CONTAMINATION:\n+        if (!EXTRACT_CONTAMINATION) {\n+            CONTAMINATION = 1 - CONTAMINATION;\n+        }\n+\n+        checker.setLocusMaxReads(LOCUS_MAX_READS);\n+        checker.setValidationStringency(VALIDATION_STRINGENCY);\n+\n+        if (SAMPLE_ALIAS != null) {\n+            checker.setDefaultSampleID(SAMPLE_ALIAS);\n+        }\n+\n+        final Map<String, Fingerprint> fingerprintMap = checker.identifyContaminant(INPUT.toPath(), CONTAMINATION);\n+\n+        if (fingerprintMap.size() != 1) {\n+            log.error(\"Expected exactly 1 fingerprint, found \" + fingerprintMap.size());\n+            throw new IllegalArgumentException(\"Expected exactly 1 fingerprint in Input file, found \" + fingerprintMap.size());\n+        }\n+\n+        final Map.Entry<String, Fingerprint> soleEntry = fingerprintMap.entrySet().iterator().next();\n+\n+        final String sampleToUse = getSampleToUse(soleEntry.getKey());\n+\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxODk2NQ==", "bodyText": "Why do you have snp.getAllele2() != refAllele?\nIsn't allele1 always the reference allele?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r434818965", "createdAt": "2020-06-03T19:57:37Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "diffHunk": "@@ -137,15 +152,39 @@ private static VariantContext getVariantContext(final ReferenceSequenceFile refe\n                 snp.getPos(),\n                 snp.getPos()).getBases()[0]);\n \n-        final Allele allele1 = Allele.create(snp.getAllele1(), snp.getAllele1() == refAllele);\n-        final Allele allele2 = Allele.create(snp.getAllele2(), snp.getAllele2() == refAllele);\n-        final List<Allele> alleles = Arrays.asList(allele1, allele2);\n+        if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1cc15bc759ed69e4cb7f52c80572067bb63d66f", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/f1cc15bc759ed69e4cb7f52c80572067bb63d66f", "committedDate": "2020-06-04T16:06:22Z", "message": "- A few modifications to programs involved in fingerprinting so that we would be able to process files with reads that lack a rg tag. should not affect results from valid files."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac7eed46b81ce0ffa6ee1ce12eacbdda2f978e8c", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/ac7eed46b81ce0ffa6ee1ce12eacbdda2f978e8c", "committedDate": "2020-06-04T16:06:22Z", "message": "- corrected source of reference sequence"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "320d03e0b2bcd48114827f88307238b5b6df8f47", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/320d03e0b2bcd48114827f88307238b5b6df8f47", "committedDate": "2020-06-04T16:06:23Z", "message": "- no cap on VCF PL"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb6c07e292cb4cb019d3b4fb2de0f0f97ae06139", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/eb6c07e292cb4cb019d3b4fb2de0f0f97ae06139", "committedDate": "2020-06-04T16:06:23Z", "message": "- fix GIANT bug in IdentifyContaminant (haplotypesBlocks that had the reference base as the \"minor\" allele were not converted correctly to VCF)\n- remove cap on PL when dealing with VCF (not sure why it was there in the first place)\n- general cleanups."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b448c3cc538264cd1e2425d1c95bc153b0bab14", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/0b448c3cc538264cd1e2425d1c95bc153b0bab14", "committedDate": "2020-06-04T16:06:23Z", "message": "- test write to VCF"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c0bf1ba11dcb061008b496bb78644210d91b2f8", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/6c0bf1ba11dcb061008b496bb78644210d91b2f8", "committedDate": "2020-06-04T16:06:24Z", "message": "- remove max from loglikelihood before converting to probability to protect against an underflow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "203f49524e40a33704c048ced4e6cddf1599ad72", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/203f49524e40a33704c048ced4e6cddf1599ad72", "committedDate": "2020-06-04T16:06:24Z", "message": "- added deprecation notices"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ab7694b2596f2d4a3fd4ccdd7f1423be9096abc", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/9ab7694b2596f2d4a3fd4ccdd7f1423be9096abc", "committedDate": "2020-06-04T16:06:24Z", "message": "- bringing back the cap on fingerprints...in a more holistic way."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a15b45f3d5a418f78aba3238350ceb55be8470e4", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/a15b45f3d5a418f78aba3238350ceb55be8470e4", "committedDate": "2020-06-04T16:06:25Z", "message": "- checkpointing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "891d2e76ef2231d04d922fe780d28f305b0c750c", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/891d2e76ef2231d04d922fe780d28f305b0c750c", "committedDate": "2020-06-04T16:06:25Z", "message": "- OOPS"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bfb7a5a66dba025d6f9e8876362f2c772c61311", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/9bfb7a5a66dba025d6f9e8876362f2c772c61311", "committedDate": "2020-06-04T16:06:25Z", "message": "- increased test coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f2243826f55e20a9acf92f6ebe8ade592749b1c", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/4f2243826f55e20a9acf92f6ebe8ade592749b1c", "committedDate": "2020-06-04T16:06:25Z", "message": "-adjust test for lack of cap."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eac67cea7e64b8e4e9f9826d6310b13691336d40", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/eac67cea7e64b8e4e9f9826d6310b13691336d40", "committedDate": "2020-06-04T16:06:26Z", "message": "- first round of responding to review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "348ed72a34036ce0bd73d5a69dbcb031a3d3dd72", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/348ed72a34036ce0bd73d5a69dbcb031a3d3dd72", "committedDate": "2020-06-04T16:06:26Z", "message": "- responding to review\n- found another bug...this time in the implementation of the tumor-aware LOD....\n- this PR includes tests that fail and commented code that will fix them in a subsequent commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d20ffc134ed65d26e2f9222c10ca1f697ad51980", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/d20ffc134ed65d26e2f9222c10ca1f697ad51980", "committedDate": "2020-06-04T16:06:26Z", "message": "- this is the bugfix for the tumor normal bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b542e92f527e13ccfe6f9a376c355842c7988170", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/b542e92f527e13ccfe6f9a376c355842c7988170", "committedDate": "2020-06-04T16:06:27Z", "message": "- typo in javaDoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a020edbfca4eb5a5ee42ed42e8078e9551702477", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/a020edbfca4eb5a5ee42ed42e8078e9551702477", "committedDate": "2020-06-04T16:06:27Z", "message": "-responding to review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/2f3365c844b11d8d06413b05d1b1df18bd41601b", "committedDate": "2020-06-01T17:31:24Z", "message": "- typo in javaDoc"}, "afterCommit": {"oid": "a020edbfca4eb5a5ee42ed42e8078e9551702477", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/a020edbfca4eb5a5ee42ed42e8078e9551702477", "committedDate": "2020-06-04T16:06:27Z", "message": "-responding to review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2433, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}