{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyODIyMjMy", "number": 1465, "title": "Removed plain `assert`s and replaced them with ValidationUtil function", "bodyText": "some asserts remain, but they have been fixed in a different PR.\n\nDescription\nGive your PR a concise yet descriptive title\nPlease explain the changes you made here.\nExplain the motivation for making this change. What existing problem does the pull request solve?\nMention any issues fixed, addressed or otherwise related to this pull request, including issue numbers or hard links for issues in other repos.\nYou can delete these instructions once you have written your PR description.\n\nChecklist (never delete this)\nNever delete this, it is our record that procedure was followed. If you find that for whatever reason one of the checklist points doesn't apply to your PR, you can leave it unchecked but please add an explanation below.\nContent\n\n Added or modified tests to cover changes and any new functionality\n Edited the README / documentation (if applicable)\n All tests passing on Travis\n\nReview\n\n Final thumbs-up from reviewer\n Rebase, squash and reword as applicable\n\nFor more detailed guidelines, see https://github.com/broadinstitute/picard/wiki/Guidelines-for-pull-requests", "createdAt": "2020-02-09T12:18:37Z", "url": "https://github.com/broadinstitute/picard/pull/1465", "merged": true, "mergeCommit": {"oid": "d6cb3931b14a02c7efda2ad4277dcbc067becff0"}, "closed": true, "closedAt": "2020-02-20T20:55:24Z", "author": {"login": "yfarjoun"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDC0gcgH2gAyMzcyODIyMjMyOmRhZWFkOTViZjQwODYyOTQwNjExNjc1NTZlOThmYWUyODU4OGU4OTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGRFY5AH2gAyMzcyODIyMjMyOjhhOThhNjFmODM0NjMyMWZmNDY1YjI1NWVhNDY3YmEzMzRiOWRlODk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "daead95bf4086294061167556e98fae28588e890", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/daead95bf4086294061167556e98fae28588e890", "committedDate": "2020-02-10T20:05:01Z", "message": "- removed plain `assert`s and replaced them with ValidationUtil functions.\n- some asserts remain, but they have been fixed in a different PR."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ba675b4fcca99a9e3bfb65b5d3d978f439cea3f", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/8ba675b4fcca99a9e3bfb65b5d3d978f439cea3f", "committedDate": "2020-02-10T20:04:09Z", "message": "Merge branch 'master' into yf_remove_asserts"}, "afterCommit": {"oid": "daead95bf4086294061167556e98fae28588e890", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/daead95bf4086294061167556e98fae28588e890", "committedDate": "2020-02-10T20:05:01Z", "message": "- removed plain `assert`s and replaced them with ValidationUtil functions.\n- some asserts remain, but they have been fixed in a different PR."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzExMTg2", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-356711186", "createdAt": "2020-02-11T14:42:15Z", "commit": {"oid": "daead95bf4086294061167556e98fae28588e890"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo0MjoxNVrOFoLiEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo0NTowM1rOFoLpMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY3NjMwNg==", "bodyText": "In this case, why not throw new PicardException(\"Invalid allele index: \" + alleleIdx);? This doesn't seem like a proper use of validateArg().", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r377676306", "createdAt": "2020-02-11T14:42:15Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -45,7 +47,7 @@\n         public static TruthState getHom(final int alleleIdx) {\n             if (alleleIdx == 0) return HOM_REF;\n             if (alleleIdx == 1) return HOM_VAR1;\n-            assert false;\n+            ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daead95bf4086294061167556e98fae28588e890"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY3NzA2MQ==", "bodyText": "Please reformat the changed lines in the IDE. In this case I would expect to see spaces around the -> operator, and the line length seems long to me.", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r377677061", "createdAt": "2020-02-11T14:43:21Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/analysis/CollectWgsMetricsWithNonZeroCoverage.java", "diffHunk": "@@ -186,7 +187,7 @@ protected WgsMetrics generateWgsMetrics(final IntervalList intervals,\n \n     @Override\n     protected WgsMetricsCollector getCollector(final int coverageCap, final IntervalList intervals) {\n-        assert(coverageCap == this.collector.coverageCap);\n+        ValidationUtils.validateArg(coverageCap == this.collector.coverageCap,()->\"coverageCap has to be the same as the internal coverageCap, found \" + coverageCap + \" and \" + this.collector.coverageCap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daead95bf4086294061167556e98fae28588e890"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY3ODEzMQ==", "bodyText": "Did you mean to delete this class? This seems unrelated to your other changes, and maybe deserves its own PR.", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r377678131", "createdAt": "2020-02-11T14:45:03Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fastq/BamToBfqWriter.java", "diffHunk": "@@ -1,444 +1,446 @@\n-/*\r\n- * The MIT License\r\n- *\r\n- * Copyright (c) 2009 The Broad Institute\r\n- *\r\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n- * of this software and associated documentation files (the \"Software\"), to deal\r\n- * in the Software without restriction, including without limitation the rights\r\n- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n- * copies of the Software, and to permit persons to whom the Software is\r\n- * furnished to do so, subject to the following conditions:\r\n- *\r\n- * The above copyright notice and this permission notice shall be included in\r\n- * all copies or substantial portions of the Software.\r\n- *\r\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n- * THE SOFTWARE.\r\n- */\r\n-package picard.fastq;\r\n-\r\n-import htsjdk.samtools.ReservedTagConstants;\r\n-import htsjdk.samtools.SAMFileHeader;\r\n-import htsjdk.samtools.SAMRecord;\r\n-import htsjdk.samtools.SamReader;\r\n-import htsjdk.samtools.SamReaderFactory;\r\n-import htsjdk.samtools.filter.AggregateFilter;\r\n-import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\r\n-import htsjdk.samtools.filter.FilteringSamIterator;\r\n-import htsjdk.samtools.filter.SamRecordFilter;\r\n-import htsjdk.samtools.filter.TagFilter;\r\n-import htsjdk.samtools.filter.WholeReadClippedFilter;\r\n-import htsjdk.samtools.util.BinaryCodec;\r\n-import htsjdk.samtools.util.CloserUtil;\r\n-import htsjdk.samtools.util.IOUtil;\r\n-import htsjdk.samtools.util.Log;\r\n-import htsjdk.samtools.util.PeekableIterator;\r\n-import picard.PicardException;\r\n-\r\n-import java.io.File;\r\n-import java.util.ArrayList;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-\r\n-/**\r\n- * Class to take unmapped reads in BAM file format and create Maq binary fastq format file(s) --\r\n- * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\r\n- * BAM file having all paired reads together in order.\r\n- */\r\n-public class BamToBfqWriter {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daead95bf4086294061167556e98fae28588e890"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2OTY1MDYw", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-356965060", "createdAt": "2020-02-11T20:19:29Z", "commit": {"oid": "daead95bf4086294061167556e98fae28588e890"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoxOTozMFrOFoXrmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoyMDowN1rOFoXsyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTM1Mg==", "bodyText": "just throw here", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r377875352", "createdAt": "2020-02-11T20:19:30Z", "author": {"login": "lbergelson"}, "path": "src/test/java/picard/fingerprint/CrosscheckFingerprintsTest.java", "diffHunk": "@@ -948,7 +949,7 @@ private void doTest(final String[] args, final File metrics, final int expectedR\n \n             } catch (NoSuchFieldException e) {\n                 e.printStackTrace();\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daead95bf4086294061167556e98fae28588e890"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTY1OA==", "bodyText": "Just throw if we shouldn't be here.", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r377875658", "createdAt": "2020-02-11T20:20:07Z", "author": {"login": "lbergelson"}, "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -56,7 +58,7 @@ public static TruthState getVar(final int allele0idx, final int allele1idx) {\n             if (allele0idx == 1 && allele1idx == 2) return HET_VAR1_VAR2;\n             if (allele0idx == 2 && allele1idx == 1) return HET_VAR1_VAR2;\n \n-            assert false;\n+            ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daead95bf4086294061167556e98fae28588e890"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "433e35081818cac6103490113f3cb48fae50a491", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/433e35081818cac6103490113f3cb48fae50a491", "committedDate": "2020-02-13T11:32:21Z", "message": "- responding to review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MTQ4MjE0", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-358148214", "createdAt": "2020-02-13T11:36:06Z", "commit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMTozNjowNlrOFpQkYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMTozNjowNlrOFpQkYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgwNzM5Mw==", "bodyText": "this is the actual change in the file...everything else is due to newline differences.....", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378807393", "createdAt": "2020-02-13T11:36:06Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fastq/BamToBfqWriter.java", "diffHunk": "@@ -1,444 +1,446 @@\n-/*\r\n- * The MIT License\r\n- *\r\n- * Copyright (c) 2009 The Broad Institute\r\n- *\r\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n- * of this software and associated documentation files (the \"Software\"), to deal\r\n- * in the Software without restriction, including without limitation the rights\r\n- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n- * copies of the Software, and to permit persons to whom the Software is\r\n- * furnished to do so, subject to the following conditions:\r\n- *\r\n- * The above copyright notice and this permission notice shall be included in\r\n- * all copies or substantial portions of the Software.\r\n- *\r\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n- * THE SOFTWARE.\r\n- */\r\n-package picard.fastq;\r\n-\r\n-import htsjdk.samtools.ReservedTagConstants;\r\n-import htsjdk.samtools.SAMFileHeader;\r\n-import htsjdk.samtools.SAMRecord;\r\n-import htsjdk.samtools.SamReader;\r\n-import htsjdk.samtools.SamReaderFactory;\r\n-import htsjdk.samtools.filter.AggregateFilter;\r\n-import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\r\n-import htsjdk.samtools.filter.FilteringSamIterator;\r\n-import htsjdk.samtools.filter.SamRecordFilter;\r\n-import htsjdk.samtools.filter.TagFilter;\r\n-import htsjdk.samtools.filter.WholeReadClippedFilter;\r\n-import htsjdk.samtools.util.BinaryCodec;\r\n-import htsjdk.samtools.util.CloserUtil;\r\n-import htsjdk.samtools.util.IOUtil;\r\n-import htsjdk.samtools.util.Log;\r\n-import htsjdk.samtools.util.PeekableIterator;\r\n-import picard.PicardException;\r\n-\r\n-import java.io.File;\r\n-import java.util.ArrayList;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-\r\n-/**\r\n- * Class to take unmapped reads in BAM file format and create Maq binary fastq format file(s) --\r\n- * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\r\n- * BAM file having all paired reads together in order.\r\n- */\r\n-public class BamToBfqWriter {\r\n-\r\n-    private static final int SEED_REGION_LENGTH = 28;\r\n-    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\r\n-\r\n-    private final File bamFile;\r\n-    private final String outputPrefix;\r\n-    private final String namePrefix;\r\n-    private final int nameTrim;\r\n-    private boolean pairedReads = false;\r\n-    private int wrote = 0;\r\n-    private int increment = 1;\r\n-    private int chunk = 0;\r\n-    private BinaryCodec codec1;\r\n-    private BinaryCodec codec2;\r\n-    private final Log log = Log.getInstance(BamToBfqWriter.class);\r\n-    private final boolean includeNonPfReads;\r\n-    private final boolean clipAdapters;\r\n-    private final Integer basesToWrite;\r\n-\r\n-    /**\r\n-     * Constructor\r\n-     *\r\n-     * @param bamFile        the BAM file to read from\r\n-     * @param outputPrefix   the directory and file prefix for the binary fastq files\r\n-     * @param total          the total number of records that should be written, drawn evenly\r\n-     *                       from throughout the file (null for all).\r\n-     * @param chunk          the maximum number of records that should be written to any one file\r\n-     * @param pairedReads    whether these reads are from  a paired-end run\r\n-     * @param namePrefix     The string to be stripped off the read name\r\n-     *                       before writing to the bfq file. May be null, in which case\r\n-     *                       the name will not be trimmed.\r\n-     * @param includeNonPfReads whether to include non pf-reads\r\n-     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\r\n-     */\r\n-    public BamToBfqWriter(final File bamFile, final String outputPrefix, final Integer total,\r\n-                          final Integer chunk, final boolean pairedReads, String namePrefix,\r\n-                          boolean includeNonPfReads, boolean clipAdapters, Integer basesToWrite) {\r\n-\r\n-        IOUtil.assertFileIsReadable(bamFile);\r\n-        this.bamFile = bamFile;\r\n-        this.outputPrefix = outputPrefix;\r\n-        this.pairedReads = pairedReads;\r\n-        if (total != null) {\r\n-            final double writeable = (double)countWritableRecords();\r\n-            this.increment = (int)Math.floor(writeable/total.doubleValue());\r\n-            if (this.increment == 0) {\r\n-                this.increment = 1;\r\n-            }\r\n-        }\r\n-        if (chunk != null) {\r\n-            this.chunk = chunk;\r\n-        }\r\n-        this.namePrefix = namePrefix;\r\n-        this.nameTrim = namePrefix != null ? namePrefix.length() : 0;\r\n-        this.includeNonPfReads = includeNonPfReads;\r\n-        this.clipAdapters = clipAdapters;\r\n-        this.basesToWrite = basesToWrite;\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor\r\n-     *\r\n-     * @param bamFile   the BAM file to read from\r\n-     * @param outputPrefix   the directory and file prefix for the binary fastq files\r\n-     * @param pairedReads    whether these reads are from  a paired-end run\r\n-     * @param namePrefix     the barcode of the run (to be stripped off the read name\r\n-     *                       before writing to the bfq file)\r\n-     * @param includeNonPfReads whether to include non pf-reads\r\n-     */\r\n-    public BamToBfqWriter(final File bamFile, final String outputPrefix, final boolean pairedReads,\r\n-                          String namePrefix, boolean includeNonPfReads) {\r\n-        this(bamFile, outputPrefix, null, null, pairedReads, namePrefix, includeNonPfReads, true, null);\r\n-    }\r\n- \r\n-    /**\r\n-     * Writes the binary fastq file(s) to the output directory\r\n-     */\r\n-    public void writeBfqFiles() {\r\n-\r\n-        final SamReader reader = SamReaderFactory.makeDefault().open(bamFile);\r\n-        final Iterator<SAMRecord> iterator = reader.iterator();\r\n-\r\n-        // Filter out noise reads and reads that fail the quality filter\r\n-        final TagFilter tagFilter = new TagFilter(ReservedTagConstants.XN, 1);\r\n-        final FailsVendorReadQualityFilter qualityFilter = new FailsVendorReadQualityFilter();\r\n-        final WholeReadClippedFilter clippedFilter = new WholeReadClippedFilter();\r\n-\r\n-\r\n-        if (!pairedReads) {\r\n-            List<SamRecordFilter> filters = new ArrayList<SamRecordFilter>();\r\n-            filters.add(tagFilter);\r\n-            filters.add(clippedFilter);\r\n-            if (!this.includeNonPfReads) {\r\n-                filters.add(qualityFilter);\r\n-            }\r\n-            writeSingleEndBfqs(iterator, filters);\r\n-            codec1.close();\r\n-        }\r\n-        else {\r\n-            writePairedEndBfqs(iterator, tagFilter, qualityFilter, clippedFilter);\r\n-            codec1.close();\r\n-            codec2.close();\r\n-        }\r\n-        log.info(\"Wrote \" + wrote + \" bfq records.\");\r\n-        CloserUtil.close(reader);\r\n-    }\r\n-\r\n-    /**\r\n-     * Path for writing bfqs for paired-end reads\r\n-     *\r\n-     * @param iterator      the iterator witht he SAM Records to write\r\n-     * @param tagFilter     the filter for noise reads\r\n-     * @param qualityFilter the filter for PF reads\r\n-     */\r\n-    private void writePairedEndBfqs(final Iterator<SAMRecord> iterator, final TagFilter tagFilter,\r\n-                                    final FailsVendorReadQualityFilter qualityFilter,\r\n-                                    SamRecordFilter ... otherFilters) {\r\n-        // Open the codecs for writing\r\n-        int fileIndex = 0;\r\n-        initializeNextBfqFiles(fileIndex++);\r\n-\r\n-        int records = 0;\r\n-\r\n-        RECORD_LOOP: while (iterator.hasNext()) {\r\n-            final SAMRecord first = iterator.next();\r\n-            if (!iterator.hasNext()) {\r\n-                throw new PicardException(\"Mismatched number of records in \" + this.bamFile.getAbsolutePath());\r\n-            }\r\n-            final SAMRecord second = iterator.next();\r\n-            if (!second.getReadName().equals(first.getReadName()) ||\r\n-                first.getFirstOfPairFlag() == second.getFirstOfPairFlag()) {\r\n-                throw new PicardException(\"Unmatched read pairs in \" + this.bamFile.getAbsolutePath() +\r\n-                    \": \" + first.getReadName() + \", \" + second.getReadName() + \".\");\r\n-            }\r\n-\r\n-            // If *both* are noise reads, filter them out\r\n-            if (tagFilter.filterOut(first) && tagFilter.filterOut(second))  {\r\n-                continue;\r\n-            }\r\n-\r\n-            // If either fails to pass filter, then exclude them as well\r\n-            if (!includeNonPfReads && (qualityFilter.filterOut(first) || qualityFilter.filterOut(second))) {\r\n-                continue;\r\n-            }\r\n-\r\n-            // If either fails any of the other filters, exclude them both\r\n-            for (SamRecordFilter filter : otherFilters) {\r\n-                if (filter.filterOut(first) || filter.filterOut(second)) {\r\n-                    continue RECORD_LOOP;\r\n-                }\r\n-            }\r\n-\r\n-            // Otherwise, write them out\r\n-            records++;\r\n-            if (records % increment == 0) {\r\n-                first.setReadName(first.getReadName() + \"/1\");\r\n-                writeFastqRecord(first.getFirstOfPairFlag() ? codec1 : codec2, first);\r\n-                second.setReadName(second.getReadName() + \"/2\");\r\n-                writeFastqRecord(second.getFirstOfPairFlag() ? codec1 : codec2, second);\r\n-                wrote++;\r\n-                if (wrote % 1000000 == 0) {\r\n-                    log.info(wrote + \" records written.\");\r\n-                }\r\n-                if (chunk > 0 && wrote % chunk == 0) {\r\n-                    initializeNextBfqFiles(fileIndex++);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Path for writing bfqs for single-end reads\r\n-     *\r\n-     * @param iterator  the iterator with he SAM Records to write\r\n-     * @param filters   the list of filters to be applied\r\n-     */\r\n-    private void writeSingleEndBfqs(final Iterator<SAMRecord> iterator, final List<SamRecordFilter> filters) {\r\n-\r\n-        // Open the codecs for writing\r\n-        int fileIndex = 0;\r\n-        initializeNextBfqFiles(fileIndex++);\r\n-\r\n-        int records = 0;\r\n-\r\n-        final FilteringSamIterator it = new FilteringSamIterator(iterator, new AggregateFilter(filters));\r\n-        while (it.hasNext()) {\r\n-            final SAMRecord record = it.next();\r\n-            records++;\r\n-            if (records % increment == 0) {\r\n-\r\n-                record.setReadName(record.getReadName() + \"/1\");\r\n-                writeFastqRecord(codec1, record);\r\n-                wrote++;\r\n-                if (wrote % 1000000 == 0) {\r\n-                    log.info(wrote + \" records processed.\");\r\n-                }\r\n-                if (chunk > 0 && wrote % chunk == 0) {\r\n-                    initializeNextBfqFiles(fileIndex++);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Closes any the open bfq file(s), if any, and opens the new one(s)\r\n-     *\r\n-     * @param fileIndex the index (counter) of the files to write\r\n-     */\r\n-    private void initializeNextBfqFiles(final int fileIndex) {\r\n-        // Close the codecs if they were writing before\r\n-        if (codec1 != null) {\r\n-            codec1.close();\r\n-            if (pairedReads) {\r\n-                codec2.close();\r\n-            }\r\n-        }\r\n-\r\n-        // Open new file, using the fileIndex.\r\n-        final File bfq1 = getOutputFile(this.outputPrefix , 1, fileIndex);\r\n-        codec1 = new BinaryCodec(IOUtil.openFileForWriting(bfq1));\r\n-        log.info(\"Now writing to file \" + bfq1.getAbsolutePath());\r\n-        if (pairedReads) {\r\n-            final File bfq2 = getOutputFile(this.outputPrefix , 2, fileIndex);\r\n-            codec2 = new BinaryCodec(IOUtil.openFileForWriting(bfq2));\r\n-            log.info(\"Now writing to file \" + bfq2.getAbsolutePath());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Writes out a SAMRecord in Maq fastq format\r\n-     *\r\n-     * @param codec the code to write to\r\n-     * @param rec   the SAMRecord to write\r\n-     */\r\n-    private void writeFastqRecord(final BinaryCodec codec, final SAMRecord rec) {\r\n-\r\n-        // Trim the run barcode off the read name\r\n-        String readName = rec.getReadName();\r\n-        if (namePrefix != null && readName.startsWith(namePrefix)) {\r\n-            readName = readName.substring(nameTrim);\r\n-        }\r\n-        // Writes the length of the read name and then the name (null-terminated)\r\n-        codec.writeString(readName, true, true);\r\n-\r\n-        final char[] seqs = rec.getReadString().toCharArray();\r\n-        final char[] quals = rec.getBaseQualityString().toCharArray();\r\n-\r\n-        int retainedLength = seqs.length;\r\n-        if (clipAdapters){\r\n-            // adjust to a shorter length iff clipping tag exists\r\n-            Integer trimPoint = rec.getIntegerAttribute(ReservedTagConstants.XT);\r\n-            if (trimPoint != null) {\r\n-                assert (rec.getReadLength() == seqs.length);\r\n-                retainedLength = Math.min(seqs.length, Math.max(SEED_REGION_LENGTH, trimPoint -1));\r\n-            }\r\n-        }\r\n-\r\n-        // Write the length of the sequence\r\n-        codec.writeInt(basesToWrite != null ? basesToWrite : seqs.length);\r\n-\r\n-        // Calculate and write the sequence and qualities\r\n-        final byte[] seqsAndQuals = encodeSeqsAndQuals(seqs, quals, retainedLength);\r\n-        codec.writeBytes(seqsAndQuals);\r\n-    }\r\n-\r\n-    private byte[] encodeSeqsAndQuals(char[] seqs, char[] quals, int retainedLength) {\r\n-        final byte[] seqsAndQuals = new byte[basesToWrite == null ? seqs.length : basesToWrite];\r\n-\r\n-        int seedRegionNoCallFixes = 0;\r\n-        for (int i = 0; i < retainedLength && i < seqsAndQuals.length; i++) {\r\n-            int quality = Math.min(quals[i]-33, 63);\r\n-            final int base;\r\n-            switch(seqs[i]) {\r\n-                case 'A':\r\n-                case 'a':\r\n-                    base = 0;\r\n-                    break;\r\n-                case 'C':\r\n-                case 'c':\r\n-                    base = 1;\r\n-                    break;\r\n-                case 'G':\r\n-                case 'g':\r\n-                    base = 2;\r\n-                    break;\r\n-                case 'T':\r\n-                case 't':\r\n-                    base = 3;\r\n-                    break;\r\n-                case 'N':\r\n-                case 'n':\r\n-                case '.':\r\n-                    base = 0;\r\n-                    if (i < SEED_REGION_LENGTH ) {\r\n-                        if (seedRegionNoCallFixes < MAX_SEED_REGION_NOCALL_FIXES) {\r\n-                            quality = 1;\r\n-                            seedRegionNoCallFixes++;\r\n-                        }\r\n-                        else {\r\n-                            quality = 0;\r\n-                        }\r\n-                    }\r\n-                    else {\r\n-                        quality = 1;\r\n-                    }\r\n-                    break;\r\n-                default:\r\n-                    throw new PicardException(\"Unknown base when writing bfq file: \" + seqs[i]);\r\n-            }\r\n-            seqsAndQuals[i] = encodeBaseAndQuality(base, quality);\r\n-        }\r\n-        // rewrite clipped adapter with all A's of quality 1\r\n-        for (int i = retainedLength; i < seqsAndQuals.length; i++) {\r\n-            seqsAndQuals[i] = encodeBaseAndQuality(0, 1);\r\n-        }\r\n-\r\n-        return seqsAndQuals;\r\n-    }\r\n-\r\n-    private byte encodeBaseAndQuality(int base, int quality) {\r\n-        return (byte) ((base << 6) | quality);\r\n-    }\r\n-\r\n-    /**\r\n-     * Count the number of records in the bamFile that could potentially be written\r\n-     *\r\n-     * @return  the number of records in the Bam file\r\n-     */\r\n-    private int countWritableRecords() {\r\n-        int count = 0;\r\n-\r\n-        final SamReader reader = SamReaderFactory.makeDefault().open(this.bamFile);\r\n-        if(!reader.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.queryname)) {\r\n-        \t//this is a fix for issue PIC-274: It looks like BamToBfqWriter requires that the input BAM is queryname sorted, \r\n-        \t//but it doesn't check this early, nor produce an understandable error message.\"\r\n-        \tthrow new PicardException(\"Input file (\" + this.bamFile.getAbsolutePath() +\") needs to be sorted by queryname.\");\r\n-        }\r\n-        final PeekableIterator<SAMRecord> it = new PeekableIterator<SAMRecord>(reader.iterator());\r\n-        if (!this.pairedReads) {\r\n-            // Filter out noise reads and reads that fail the quality filter\r\n-            final List<SamRecordFilter> filters = new ArrayList<SamRecordFilter>();\r\n-            filters.add(new TagFilter(ReservedTagConstants.XN, 1));\r\n-            if (!this.includeNonPfReads) {\r\n-                filters.add(new FailsVendorReadQualityFilter());\r\n-            }\r\n-            final FilteringSamIterator itr = new FilteringSamIterator(it, new AggregateFilter(filters));\r\n-            while (itr.hasNext()) {\r\n-                itr.next();\r\n-                count++;\r\n-            }\r\n-        }\r\n-        else {\r\n-            while (it.hasNext()) {\r\n-                final SAMRecord first = it.next();\r\n-                final SAMRecord second = it.next();\r\n-                // If both are noise reads, filter them out\r\n-                if (first.getAttribute(ReservedTagConstants.XN) != null &&\r\n-                    second.getAttribute(ReservedTagConstants.XN) != null)  {\r\n-                    // skip it\r\n-                }\r\n-                // If either fails to pass filter, then exclude them as well\r\n-                else if (!this.includeNonPfReads && (first.getReadFailsVendorQualityCheckFlag() || second.getReadFailsVendorQualityCheckFlag()) ) {\r\n-                    // skip it\r\n-                }\r\n-                // Otherwise, write them out\r\n-                else {\r\n-                    count++;\r\n-                }\r\n-            }\r\n-        }\r\n-        it.close();\r\n-        CloserUtil.close(reader);\r\n-        return count;\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructs the name for the output file and returns the file\r\n-     *\r\n-     * @param outputPrefix        the directory and file prefix for the output bfq file\r\n-     * @param read                whether this is the file for the first or second read\r\n-     * @param index               used in file name\r\n-     * @return                    a new File object for the bfq file.\r\n-     */\r\n-    private File getOutputFile(final String outputPrefix, final int read, final int index) {\r\n-        final File result = new File(outputPrefix + index + \".\" + read + \".bfq\");\r\n-        IOUtil.assertFileIsWritable(result);\r\n-        return result;\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2009 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package picard.fastq;\n+\n+import htsjdk.samtools.ReservedTagConstants;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.filter.AggregateFilter;\n+import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\n+import htsjdk.samtools.filter.FilteringSamIterator;\n+import htsjdk.samtools.filter.SamRecordFilter;\n+import htsjdk.samtools.filter.TagFilter;\n+import htsjdk.samtools.filter.WholeReadClippedFilter;\n+import htsjdk.samtools.util.BinaryCodec;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.PeekableIterator;\n+import htsjdk.utils.ValidationUtils;\n+import picard.PicardException;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Class to take unmapped reads in BAM file format and create Maq binary fastq format file(s) --\n+ * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\n+ * BAM file having all paired reads together in order.\n+ */\n+public class BamToBfqWriter {\n+\n+    private static final int SEED_REGION_LENGTH = 28;\n+    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\n+\n+    private final File bamFile;\n+    private final String outputPrefix;\n+    private final String namePrefix;\n+    private final int nameTrim;\n+    private boolean pairedReads = false;\n+    private int wrote = 0;\n+    private int increment = 1;\n+    private int chunk = 0;\n+    private BinaryCodec codec1;\n+    private BinaryCodec codec2;\n+    private final Log log = Log.getInstance(BamToBfqWriter.class);\n+    private final boolean includeNonPfReads;\n+    private final boolean clipAdapters;\n+    private final Integer basesToWrite;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile        the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param total          the total number of records that should be written, drawn evenly\n+     *                       from throughout the file (null for all).\n+     * @param chunk          the maximum number of records that should be written to any one file\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     The string to be stripped off the read name\n+     *                       before writing to the bfq file. May be null, in which case\n+     *                       the name will not be trimmed.\n+     * @param includeNonPfReads whether to include non pf-reads\n+     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\n+     */\n+    public BamToBfqWriter(final File bamFile, final String outputPrefix, final Integer total,\n+                          final Integer chunk, final boolean pairedReads, String namePrefix,\n+                          boolean includeNonPfReads, boolean clipAdapters, Integer basesToWrite) {\n+\n+        IOUtil.assertFileIsReadable(bamFile);\n+        this.bamFile = bamFile;\n+        this.outputPrefix = outputPrefix;\n+        this.pairedReads = pairedReads;\n+        if (total != null) {\n+            final double writeable = (double)countWritableRecords();\n+            this.increment = (int)Math.floor(writeable/total.doubleValue());\n+            if (this.increment == 0) {\n+                this.increment = 1;\n+            }\n+        }\n+        if (chunk != null) {\n+            this.chunk = chunk;\n+        }\n+        this.namePrefix = namePrefix;\n+        this.nameTrim = namePrefix != null ? namePrefix.length() : 0;\n+        this.includeNonPfReads = includeNonPfReads;\n+        this.clipAdapters = clipAdapters;\n+        this.basesToWrite = basesToWrite;\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile   the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     the barcode of the run (to be stripped off the read name\n+     *                       before writing to the bfq file)\n+     * @param includeNonPfReads whether to include non pf-reads\n+     */\n+    public BamToBfqWriter(final File bamFile, final String outputPrefix, final boolean pairedReads,\n+                          String namePrefix, boolean includeNonPfReads) {\n+        this(bamFile, outputPrefix, null, null, pairedReads, namePrefix, includeNonPfReads, true, null);\n+    }\n+ \n+    /**\n+     * Writes the binary fastq file(s) to the output directory\n+     */\n+    public void writeBfqFiles() {\n+\n+        final SamReader reader = SamReaderFactory.makeDefault().open(bamFile);\n+        final Iterator<SAMRecord> iterator = reader.iterator();\n+\n+        // Filter out noise reads and reads that fail the quality filter\n+        final TagFilter tagFilter = new TagFilter(ReservedTagConstants.XN, 1);\n+        final FailsVendorReadQualityFilter qualityFilter = new FailsVendorReadQualityFilter();\n+        final WholeReadClippedFilter clippedFilter = new WholeReadClippedFilter();\n+\n+\n+        if (!pairedReads) {\n+            List<SamRecordFilter> filters = new ArrayList<SamRecordFilter>();\n+            filters.add(tagFilter);\n+            filters.add(clippedFilter);\n+            if (!this.includeNonPfReads) {\n+                filters.add(qualityFilter);\n+            }\n+            writeSingleEndBfqs(iterator, filters);\n+            codec1.close();\n+        }\n+        else {\n+            writePairedEndBfqs(iterator, tagFilter, qualityFilter, clippedFilter);\n+            codec1.close();\n+            codec2.close();\n+        }\n+        log.info(\"Wrote \" + wrote + \" bfq records.\");\n+        CloserUtil.close(reader);\n+    }\n+\n+    /**\n+     * Path for writing bfqs for paired-end reads\n+     *\n+     * @param iterator      the iterator witht he SAM Records to write\n+     * @param tagFilter     the filter for noise reads\n+     * @param qualityFilter the filter for PF reads\n+     */\n+    private void writePairedEndBfqs(final Iterator<SAMRecord> iterator, final TagFilter tagFilter,\n+                                    final FailsVendorReadQualityFilter qualityFilter,\n+                                    SamRecordFilter ... otherFilters) {\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        RECORD_LOOP: while (iterator.hasNext()) {\n+            final SAMRecord first = iterator.next();\n+            if (!iterator.hasNext()) {\n+                throw new PicardException(\"Mismatched number of records in \" + this.bamFile.getAbsolutePath());\n+            }\n+            final SAMRecord second = iterator.next();\n+            if (!second.getReadName().equals(first.getReadName()) ||\n+                first.getFirstOfPairFlag() == second.getFirstOfPairFlag()) {\n+                throw new PicardException(\"Unmatched read pairs in \" + this.bamFile.getAbsolutePath() +\n+                    \": \" + first.getReadName() + \", \" + second.getReadName() + \".\");\n+            }\n+\n+            // If *both* are noise reads, filter them out\n+            if (tagFilter.filterOut(first) && tagFilter.filterOut(second))  {\n+                continue;\n+            }\n+\n+            // If either fails to pass filter, then exclude them as well\n+            if (!includeNonPfReads && (qualityFilter.filterOut(first) || qualityFilter.filterOut(second))) {\n+                continue;\n+            }\n+\n+            // If either fails any of the other filters, exclude them both\n+            for (SamRecordFilter filter : otherFilters) {\n+                if (filter.filterOut(first) || filter.filterOut(second)) {\n+                    continue RECORD_LOOP;\n+                }\n+            }\n+\n+            // Otherwise, write them out\n+            records++;\n+            if (records % increment == 0) {\n+                first.setReadName(first.getReadName() + \"/1\");\n+                writeFastqRecord(first.getFirstOfPairFlag() ? codec1 : codec2, first);\n+                second.setReadName(second.getReadName() + \"/2\");\n+                writeFastqRecord(second.getFirstOfPairFlag() ? codec1 : codec2, second);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records written.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Path for writing bfqs for single-end reads\n+     *\n+     * @param iterator  the iterator with he SAM Records to write\n+     * @param filters   the list of filters to be applied\n+     */\n+    private void writeSingleEndBfqs(final Iterator<SAMRecord> iterator, final List<SamRecordFilter> filters) {\n+\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        final FilteringSamIterator it = new FilteringSamIterator(iterator, new AggregateFilter(filters));\n+        while (it.hasNext()) {\n+            final SAMRecord record = it.next();\n+            records++;\n+            if (records % increment == 0) {\n+\n+                record.setReadName(record.getReadName() + \"/1\");\n+                writeFastqRecord(codec1, record);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records processed.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Closes any the open bfq file(s), if any, and opens the new one(s)\n+     *\n+     * @param fileIndex the index (counter) of the files to write\n+     */\n+    private void initializeNextBfqFiles(final int fileIndex) {\n+        // Close the codecs if they were writing before\n+        if (codec1 != null) {\n+            codec1.close();\n+            if (pairedReads) {\n+                codec2.close();\n+            }\n+        }\n+\n+        // Open new file, using the fileIndex.\n+        final File bfq1 = getOutputFile(this.outputPrefix , 1, fileIndex);\n+        codec1 = new BinaryCodec(IOUtil.openFileForWriting(bfq1));\n+        log.info(\"Now writing to file \" + bfq1.getAbsolutePath());\n+        if (pairedReads) {\n+            final File bfq2 = getOutputFile(this.outputPrefix , 2, fileIndex);\n+            codec2 = new BinaryCodec(IOUtil.openFileForWriting(bfq2));\n+            log.info(\"Now writing to file \" + bfq2.getAbsolutePath());\n+        }\n+    }\n+\n+    /**\n+     * Writes out a SAMRecord in Maq fastq format\n+     *\n+     * @param codec the code to write to\n+     * @param rec   the SAMRecord to write\n+     */\n+    private void writeFastqRecord(final BinaryCodec codec, final SAMRecord rec) {\n+\n+        // Trim the run barcode off the read name\n+        String readName = rec.getReadName();\n+        if (namePrefix != null && readName.startsWith(namePrefix)) {\n+            readName = readName.substring(nameTrim);\n+        }\n+        // Writes the length of the read name and then the name (null-terminated)\n+        codec.writeString(readName, true, true);\n+\n+        final char[] seqs = rec.getReadString().toCharArray();\n+        final char[] quals = rec.getBaseQualityString().toCharArray();\n+\n+        int retainedLength = seqs.length;\n+        if (clipAdapters){\n+            // adjust to a shorter length iff clipping tag exists\n+            Integer trimPoint = rec.getIntegerAttribute(ReservedTagConstants.XT);\n+            if (trimPoint != null) {\n+                ValidationUtils.validateArg(rec.getReadLength() == seqs.length, () -> \"length of read and seqs differ. Found \" + rec.getReadLength() + \" and '\" + seqs.length + \".\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "originalPosition": 752}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Mzc5NzM0", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-358379734", "createdAt": "2020-02-13T16:46:51Z", "commit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MzgwOTQx", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-358380941", "createdAt": "2020-02-13T16:48:22Z", "commit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0ODoyMlrOFpbbFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0ODoyMlrOFpbbFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NTIzNg==", "bodyText": "here", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378985236", "createdAt": "2020-02-13T16:48:22Z", "author": {"login": "lbergelson"}, "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -109,8 +111,7 @@ public static CallState getHom(final int alleleIdx) {\n             if (alleleIdx == 2) return HOM_VAR2;\n             if (alleleIdx == 3) return HOM_VAR3;\n \n-            assert false;\n-            return null;\n+            throw new IllegalStateException(\"Shouldn't be here.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MzgwOTk1", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-358380995", "createdAt": "2020-02-13T16:48:26Z", "commit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0ODoyNlrOFpbbOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0ODoyNlrOFpbbOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NTI3NQ==", "bodyText": "to", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378985275", "createdAt": "2020-02-13T16:48:26Z", "author": {"login": "lbergelson"}, "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -124,22 +125,22 @@ public static CallState getHet(int allele0idx, int allele1idx) {\n                 if (allele1idx == 1) return HET_REF_VAR1;\n                 if (allele1idx == 2) return HET_REF_VAR2;\n                 if (allele1idx == 3) return HET_REF_VAR3;\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MzgxMDMw", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-358381030", "createdAt": "2020-02-13T16:48:30Z", "commit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0ODozMFrOFpbbWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0ODozMFrOFpbbWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NTMwNw==", "bodyText": "and", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378985307", "createdAt": "2020-02-13T16:48:30Z", "author": {"login": "lbergelson"}, "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -124,22 +125,22 @@ public static CallState getHet(int allele0idx, int allele1idx) {\n                 if (allele1idx == 1) return HET_REF_VAR1;\n                 if (allele1idx == 2) return HET_REF_VAR2;\n                 if (allele1idx == 3) return HET_REF_VAR3;\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");\n                 return null;\n             }\n \n             //HET CASES\n             if(allele0idx == 1) {\n                 if (allele1idx == 2) return HET_VAR1_VAR2;\n                 if (allele1idx == 3) return HET_VAR1_VAR3;\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MzgxMDYx", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-358381061", "createdAt": "2020-02-13T16:48:32Z", "commit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0ODozMlrOFpbbbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjo0ODozMlrOFpbbbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NTMyNQ==", "bodyText": "here", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378985325", "createdAt": "2020-02-13T16:48:32Z", "author": {"login": "lbergelson"}, "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -124,22 +125,22 @@ public static CallState getHet(int allele0idx, int allele1idx) {\n                 if (allele1idx == 1) return HET_REF_VAR1;\n                 if (allele1idx == 2) return HET_REF_VAR2;\n                 if (allele1idx == 3) return HET_REF_VAR3;\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");\n                 return null;\n             }\n \n             //HET CASES\n             if(allele0idx == 1) {\n                 if (allele1idx == 2) return HET_VAR1_VAR2;\n                 if (allele1idx == 3) return HET_VAR1_VAR3;\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");\n                 return null;\n             }\n \n             if(allele0idx == 2 && allele1idx == 3) return HET_VAR3_VAR4; //special case not a mistake.\n             if(allele0idx == 3 && allele1idx == 4) return HET_VAR3_VAR4;\n \n-            assert false;\n+            ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MzgxMzk1", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-358381395", "createdAt": "2020-02-13T16:48:58Z", "commit": {"oid": "433e35081818cac6103490113f3cb48fae50a491"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e42c92c7f118b8c541f5b815f77473b4f395a9d3", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/e42c92c7f118b8c541f5b815f77473b4f395a9d3", "committedDate": "2020-02-13T18:16:34Z", "message": "- missed a few changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NDU3MjQz", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-358457243", "createdAt": "2020-02-13T18:37:32Z", "commit": {"oid": "e42c92c7f118b8c541f5b815f77473b4f395a9d3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMDc4NDU2", "url": "https://github.com/broadinstitute/picard/pull/1465#pullrequestreview-362078456", "createdAt": "2020-02-20T17:07:23Z", "commit": {"oid": "e42c92c7f118b8c541f5b815f77473b4f395a9d3"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzowNzoyM1rOFsbwRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzowNzo0OVrOFsbxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzNjM5MQ==", "bodyText": "import is now unused?", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r382136391", "createdAt": "2020-02-20T17:07:23Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -1,5 +1,7 @@\n package picard.vcf;\n \n+import htsjdk.utils.ValidationUtils;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42c92c7f118b8c541f5b815f77473b4f395a9d3"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzNjYyNA==", "bodyText": "Also unused import", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r382136624", "createdAt": "2020-02-20T17:07:49Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CrosscheckFingerprintsTest.java", "diffHunk": "@@ -3,6 +3,7 @@\n import htsjdk.samtools.SamReader;\n import htsjdk.samtools.metrics.MetricsFile;\n import htsjdk.samtools.util.IOUtil;\n+import htsjdk.utils.ValidationUtils;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42c92c7f118b8c541f5b815f77473b4f395a9d3"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9057552c3ef3514db56ba66a8963b739c103523", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/e9057552c3ef3514db56ba66a8963b739c103523", "committedDate": "2020-02-20T20:11:57Z", "message": "Merge branch 'master' into yf_remove_asserts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a98a61f8346321ff465b255ea467ba334b9de89", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/8a98a61f8346321ff465b255ea467ba334b9de89", "committedDate": "2020-02-20T20:23:54Z", "message": "- remove unused imports"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2390, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}