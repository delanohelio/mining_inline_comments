{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5NTM3NjUx", "number": 1531, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTo1ODowMFrOEVjmKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xN1QxODo0NDo0NVrOFnLFEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDM4NzYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/annotation/SortGff.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTo1ODowMFrOG8YeCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTo1ODowMFrOG8YeCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2ODY0OA==", "bodyText": "consider adding input and output checking before computing\nIOUtil.assertFileIsReadable(INPUT);\nIOUtil.assertFileIsWritable(OUTPUT);", "url": "https://github.com/broadinstitute/picard/pull/1531#discussion_r465968648", "createdAt": "2020-08-05T19:58:00Z", "author": {"login": "jessicaway"}, "path": "src/main/java/picard/annotation/SortGff.java", "diffHunk": "@@ -0,0 +1,269 @@\n+package picard.annotation;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import htsjdk.tribble.AbstractFeatureReader;\n+import htsjdk.tribble.gff.Gff3Codec;\n+import htsjdk.tribble.gff.Gff3Feature;\n+import htsjdk.tribble.gff.Gff3Writer;\n+import htsjdk.tribble.gff.SequenceRegion;\n+import htsjdk.tribble.readers.LineIterator;\n+import htsjdk.variant.utils.SAMSequenceDictionaryExtractor;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * <h3> Summary </h3>\n+ * <p> This tool sorts a gff3 file by coordinates, so that it can be indexed.\n+ * It additionally adds flush directives where possible, which can significantly reduce the memory footprint of downstream tools.\n+ * Sorting of multiple contigs can be specified by a sequence dictionary; if no sequence dictionary is specified, contigs are sorted lexicographically. </p>\n+ *\n+ * <h3> Usage Examples </h3>\n+ * <h4> 1. Sort gff3 file, add flush directives.  Contigs will be sorted lexicographically.</h4>\n+ * <pre>\n+ * java -jar picard.jar SortGff\n+ *      I=input.gff3\n+ *      O=output.gff3\n+ * </pre>\n+ *\n+ * <h4> 2. Sort gff3 file, add flush directives.  Contigs will be sorted according to order in sequence dictionary</h4>\n+ * <pre>\n+ * java -jar picard.jar SortGff\n+ *      I=input.gff3\n+ *      O=output.gff3\n+ *      SD=dictionary.dict\n+ * </pre>\n+ *\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = SortGff.USAGE_DETAILS,\n+        oneLineSummary = SortGff.USAGE_SUMMARY,\n+        programGroup = OtherProgramGroup.class)\n+public class SortGff extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Sorts a gff3 file, and adds flush directives\";\n+    static final String USAGE_DETAILS = \"<h3> Summary </h3>\\n\" +\n+            \"  <p> This tool sorts a gff3 file by coordinates, so that it can be indexed.\\n\" +\n+            \" It additionally adds flush directives where possible, which can significantly reduce the memory footprint of downstream tools.\\n\" +\n+            \" Sorting of multiple contigs can be specified by a sequence dictionary; if no sequence dictionary is specified, contigs are sorted lexicographically. </p>\\n\" +\n+            \"\\n\" +\n+            \" <h3> Usage Examples </h3>\\n\" +\n+            \" <h4> 1. Sort gff3 file, add flush directives.  Contigs will be sorted lexicographically.</h4>\\n\" +\n+            \" <pre>\\n\" +\n+            \" java -jar picard.jar SortGff\\n\" +\n+            \"      I=input.gff3\\n\" +\n+            \"      O=output.gff3\\n\" +\n+            \" </pre>\\n\" +\n+            \"\\n\" +\n+            \" <h4> 2. Sort gff3 file, add flush directives.  Contigs will be sorted according to order of sequence dictionary</h4>\\n\" +\n+            \" <pre>\\n\" +\n+            \" java -jar picard.jar SortGff\\n\" +\n+            \"      I=input.gff3\\n\" +\n+            \"      O=output.gff3\\n\" +\n+            \"      SD=dictionary.dict\\n\" +\n+            \" </pre>\";\n+\n+    @Argument(doc = \"Input Gff3 file to sort.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Sorted Gff3 output file.\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME)\n+    public File OUTPUT;\n+\n+    @Argument(doc = \"Dictionary to sort contigs by.  If dictionary is not provided, contigs are sorted lexicographically.\", shortName = StandardOptionDefinitions.SEQUENCE_DICTIONARY_SHORT_NAME, optional = true)\n+    public File SEQUENCE_DICTIONARY;\n+\n+    @Argument(doc = \"Number of records to hold in memory before spilling to disk\", optional = true)\n+    public int nRecordsInMemory = 50000;\n+\n+    private final Log log = Log.getInstance(SortGff.class);\n+\n+    private final Map<String, Integer> latestStartMap = new HashMap<>();\n+    private int latestStart = 0;\n+    String latestChrom;\n+\n+    private static class FeatureComparator implements Comparator<Gff3Feature> {\n+        final SAMSequenceDictionary dict;\n+\n+        FeatureComparator(final SAMSequenceDictionary dict) {\n+            this.dict = dict;\n+        }\n+\n+        public int compare(final Gff3Feature f1, final Gff3Feature f2) {\n+            int comp = dict == null ? f1.getContig().compareTo(f2.getContig()) : dict.getSequenceIndex(f1.getContig()) - dict.getSequenceIndex(f2.getContig());\n+            if (comp == 0) {\n+                comp = f1.getStart() - f2.getStart();\n+            }\n+\n+            return comp;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        final Gff3Codec inputCodec = new Gff3Codec(Gff3Codec.DecodeDepth.SHALLOW);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c81b47002a4234edc85c09a18273ddddd7a233e"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc2NjIwMzA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/annotation/SortGff.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xN1QxODo0NDo0NVrOI4q0lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xN1QxODo0NDo0NVrOI4q0lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjI5Mjc1Nw==", "bodyText": "Can this be private?", "url": "https://github.com/broadinstitute/picard/pull/1531#discussion_r596292757", "createdAt": "2021-03-17T18:44:45Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/annotation/SortGff.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package picard.annotation;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import htsjdk.tribble.AbstractFeatureReader;\n+import htsjdk.tribble.gff.Gff3Codec;\n+import htsjdk.tribble.gff.Gff3Feature;\n+import htsjdk.tribble.gff.Gff3Writer;\n+import htsjdk.tribble.gff.SequenceRegion;\n+import htsjdk.tribble.readers.LineIterator;\n+import htsjdk.variant.utils.SAMSequenceDictionaryExtractor;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.OtherProgramGroup;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * <h3> Summary </h3>\n+ * <p> This tool sorts a gff3 file by coordinates, so that it can be indexed.\n+ * It additionally adds flush directives where possible, which can significantly reduce the memory footprint of downstream tools.\n+ * Sorting of multiple contigs can be specified by a sequence dictionary; if no sequence dictionary is specified, contigs are sorted lexicographically. </p>\n+ *\n+ * <h3> Usage Examples </h3>\n+ * <h4> 1. Sort gff3 file, add flush directives.  Contigs will be sorted lexicographically.</h4>\n+ * <pre>\n+ * java -jar picard.jar SortGff\n+ *      I=input.gff3\n+ *      O=output.gff3\n+ * </pre>\n+ *\n+ * <h4> 2. Sort gff3 file, add flush directives.  Contigs will be sorted according to order in sequence dictionary</h4>\n+ * <pre>\n+ * java -jar picard.jar SortGff\n+ *      I=input.gff3\n+ *      O=output.gff3\n+ *      SD=dictionary.dict\n+ * </pre>\n+ *\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = SortGff.USAGE_DETAILS,\n+        oneLineSummary = SortGff.USAGE_SUMMARY,\n+        programGroup = OtherProgramGroup.class)\n+public class SortGff extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Sorts a gff3 file, and adds flush directives\";\n+    static final String USAGE_DETAILS = \"<h3> Summary </h3>\\n\" +\n+            \"  <p> This tool sorts a gff3 file by coordinates, so that it can be indexed.\\n\" +\n+            \" It additionally adds flush directives where possible, which can significantly reduce the memory footprint of downstream tools.\\n\" +\n+            \" Sorting of multiple contigs can be specified by a sequence dictionary; if no sequence dictionary is specified, contigs are sorted lexicographically. </p>\\n\" +\n+            \"\\n\" +\n+            \" <h3> Usage Examples </h3>\\n\" +\n+            \" <h4> 1. Sort gff3 file, add flush directives.  Contigs will be sorted lexicographically.</h4>\\n\" +\n+            \" <pre>\\n\" +\n+            \" java -jar picard.jar SortGff\\n\" +\n+            \"      I=input.gff3\\n\" +\n+            \"      O=output.gff3\\n\" +\n+            \" </pre>\\n\" +\n+            \"\\n\" +\n+            \" <h4> 2. Sort gff3 file, add flush directives.  Contigs will be sorted according to order of sequence dictionary</h4>\\n\" +\n+            \" <pre>\\n\" +\n+            \" java -jar picard.jar SortGff\\n\" +\n+            \"      I=input.gff3\\n\" +\n+            \"      O=output.gff3\\n\" +\n+            \"      SD=dictionary.dict\\n\" +\n+            \" </pre>\";\n+\n+    @Argument(doc = \"Input Gff3 file to sort.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Sorted Gff3 output file.\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME)\n+    public File OUTPUT;\n+\n+    @Argument(doc = \"Dictionary to sort contigs by.  If dictionary is not provided, contigs are sorted lexicographically.\", shortName = StandardOptionDefinitions.SEQUENCE_DICTIONARY_SHORT_NAME, optional = true)\n+    public File SEQUENCE_DICTIONARY;\n+\n+    @Argument(doc = \"Number of records to hold in memory before spilling to disk\", optional = true)\n+    public int nRecordsInMemory = 50000;\n+\n+    private final Log log = Log.getInstance(SortGff.class);\n+\n+    private final Map<String, Integer> latestStartMap = new HashMap<>();\n+    private int latestStart = 0;\n+    String latestChrom;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3321e9d564289e5a543c268073f6cdb5aa473c0"}, "originalPosition": 100}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 615, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}