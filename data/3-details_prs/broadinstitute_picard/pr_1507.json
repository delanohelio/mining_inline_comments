{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2Mzk2NTIw", "number": 1507, "title": "New CheckDuplicateMarking CLP", "bodyText": "added a new (undocumented) CLP that will check that all the records with the same queryname have the same duplicate marking.\nadded tests\nmoved another test into a markduplicates test directory\n\nDescription\nGive your PR a concise yet descriptive title\nPlease explain the changes you made here.\nExplain the motivation for making this change. What existing problem does the pull request solve?\nMention any issues fixed, addressed or otherwise related to this pull request, including issue numbers or hard links for issues in other repos.\nYou can delete these instructions once you have written your PR description.\n\nChecklist (never delete this)\nNever delete this, it is our record that procedure was followed. If you find that for whatever reason one of the checklist points doesn't apply to your PR, you can leave it unchecked but please add an explanation below.\nContent\n\n Added or modified tests to cover changes and any new functionality\n Edited the README / documentation (if applicable)\n All tests passing on Travis\n\nReview\n\n Final thumbs-up from reviewer\n Rebase, squash and reword as applicable\n\nFor more detailed guidelines, see https://github.com/broadinstitute/picard/wiki/Guidelines-for-pull-requests", "createdAt": "2020-05-11T23:13:55Z", "url": "https://github.com/broadinstitute/picard/pull/1507", "merged": true, "mergeCommit": {"oid": "c2e66e97f269ae240f4bbd3d232d105e364214b2"}, "closed": true, "closedAt": "2020-07-10T16:19:41Z", "author": {"login": "yfarjoun"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcg-HC0AFqTQxMTIyMDA3OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABczbxuPAH2gAyNDE2Mzk2NTIwOmU4YWZhNzNiNjM5MTBiZWJlMTY5YzRmNjgyMzAyYjRjNmZhMjc3MjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjIwMDc4", "url": "https://github.com/broadinstitute/picard/pull/1507#pullrequestreview-411220078", "createdAt": "2020-05-13T19:08:56Z", "commit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTowOTozMlrOGU_wtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTozMjozMFrOGVAhVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2OTM2Nw==", "bodyText": "can be final\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static private int NUM_WARNINGS = 100;\n          \n          \n            \n                private static final int NUM_WARNINGS = 100;", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424669367", "createdAt": "2020-05-13T19:09:32Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MjUxNQ==", "bodyText": "Might be clearer to have this if block in a method, ensureSortedBam()", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424672515", "createdAt": "2020-05-13T19:15:13Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MjcwMA==", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return numBadRecords > 0 ? 1:0;\n          \n          \n            \n                        return numBadRecords > 0 ? 1 : 0;", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424672700", "createdAt": "2020-05-13T19:15:35Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MzI0MQ==", "bodyText": "Use error not info if there are bad records, and/or only log if there's an error.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424673241", "createdAt": "2020-05-13T19:16:29Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MzQ1Nw==", "bodyText": "can be static\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n          \n          \n            \n                private static final Log log = Log.getInstance(CheckDuplicateMarking.class);", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424673457", "createdAt": "2020-05-13T19:16:53Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDAxNQ==", "bodyText": "For methods that return boolean, is is usually preferred\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean duplicateMarkingGood(final SAMRecord rec) {\n          \n          \n            \n                private boolean isDuplicateMarkingValid(final SAMRecord rec) {", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424674015", "createdAt": "2020-05-13T19:17:56Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDg5Mw==", "bodyText": "unnecessary return since this will fall through to the return at line 136", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424674893", "createdAt": "2020-05-13T19:19:35Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+            return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NzAzMg==", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try (PrintWriter writer =  OUTPUT==null?\n          \n          \n            \n                    try (PrintWriter writer =  OUTPUT == null ?\n          \n          \n            \n                                    new PrintWriter(NullOutputStream.NULL_OUTPUT_STREAM) :", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424677032", "createdAt": "2020-05-13T19:23:33Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+            return true;\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            numBadRecords++;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer =  OUTPUT==null?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MDI1MQ==", "bodyText": "No case in code to handle PRIMARY_ONLY, is that supported as it's the inverse of the rest?", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424680251", "createdAt": "2020-05-13T19:29:30Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+            return true;\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            numBadRecords++;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer =  OUTPUT==null?\n+                new PrintWriter(NullOutputStream.NULL_OUTPUT_STREAM):\n+                new PrintWriter(new FileWriter(OUTPUT))) {\n+\n+            for (final SAMRecord rec : iterable) {\n+                if (MODE != Mode.ALL && rec.isSecondaryOrSupplementary()) {\n+                    continue;\n+                }\n+\n+                if (MODE == Mode.PRIMARY_MAPPED_ONLY && rec.getReadUnmappedFlag()) {\n+                    continue;\n+                }\n+\n+                if (MODE == Mode.PRIMARY_PROPER_PAIR_ONLY && !rec.getProperPairFlag()) {\n+                    continue;\n+                }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MDk5MQ==", "bodyText": "Reformat new code to follow conventions\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String TEST_FILES_DIR=\"testdata/picard/sam/CheckDuplicateMarking\";\n          \n          \n            \n                private static final String TEST_FILES_DIR = \"testdata/picard/sam/CheckDuplicateMarking\";", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424680991", "createdAt": "2020-05-13T19:30:49Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package picard.sam.markduplicates;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.CheckDuplicateMarking;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckDuplicateMarkingTest {\n+    private static final String TEST_FILES_DIR=\"testdata/picard/sam/CheckDuplicateMarking\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MTgxNQ==", "bodyText": "Is there a reason to move the test but not the class? Normally the test for a class is in the same package as the class being tested.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424681815", "createdAt": "2020-05-13T19:32:30Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/sam/markduplicates/DuplicationMetricsTest.java", "diffHunk": "@@ -22,11 +22,12 @@\n  * THE SOFTWARE.\n  */\n \n-package picard.sam;\n+package picard.sam.markduplicates;\n \n import org.testng.Assert;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n+import picard.sam.DuplicationMetrics;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2OTQwODE3", "url": "https://github.com/broadinstitute/picard/pull/1507#pullrequestreview-436940817", "createdAt": "2020-06-24T19:24:57Z", "commit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOToyNDo1N1rOGof9Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo0OToyOVrOGoinYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExOTc5OQ==", "bodyText": "toString() unnecessary\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String[] args = {\"I=\" + input.toString()};\n          \n          \n            \n                    final String[] args = {\"I=\" + input};", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445119799", "createdAt": "2020-06-24T19:24:57Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package picard.sam.markduplicates;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckDuplicateMarkingTest {\n+    private static final String TEST_FILES_DIR = \"testdata/picard/sam/CheckDuplicateMarking\";\n+\n+    @DataProvider(name = \"checkDuplicateMarkingDataProvider\")\n+    public Object[][] checkDuplicateMarkingDataProvider() {\n+        return new Object[][]{\n+                {Paths.get(TEST_FILES_DIR, \"pass_queryname.sam\"), 0},\n+                {Paths.get(TEST_FILES_DIR, \"pass_coordinate.sam\"), 0},\n+                {Paths.get(TEST_FILES_DIR, \"fail_mate_queryname.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_mate_coordinate.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_queryname_1.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_coordinate_1.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_queryname_2.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_coordinate_2.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_secondary_queryname.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_secondary_coordinate.sam\"), 1},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"checkDuplicateMarkingDataProvider\")\n+    public void testCheckDuplicateMarking(final Path input, int expectedReturn) {\n+        final CheckDuplicateMarking cmdLine = new CheckDuplicateMarking();\n+        final String[] args = {\"I=\" + input.toString()};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzODMwNw==", "bodyText": "it's a minor thing but you can avoid the duplication here by changing this to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            {Paths.get(TEST_FILES_DIR, \"pass_queryname.sam\"), 0},\n          \n          \n            \n                            {\"pass_queryname.sam\", 0},\n          \n      \n    \n    \n  \n\nAnd use Paths.get(TEST_FILES_DIR, input) below.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445138307", "createdAt": "2020-06-24T20:00:40Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package picard.sam.markduplicates;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckDuplicateMarkingTest {\n+    private static final String TEST_FILES_DIR = \"testdata/picard/sam/CheckDuplicateMarking\";\n+\n+    @DataProvider(name = \"checkDuplicateMarkingDataProvider\")\n+    public Object[][] checkDuplicateMarkingDataProvider() {\n+        return new Object[][]{\n+                {Paths.get(TEST_FILES_DIR, \"pass_queryname.sam\"), 0},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzOTY2Mw==", "bodyText": "Does that mean you will move it back? It looks like this wasn't addressed.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445139663", "createdAt": "2020-06-24T20:03:13Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/sam/markduplicates/DuplicationMetricsTest.java", "diffHunk": "@@ -22,11 +22,12 @@\n  * THE SOFTWARE.\n  */\n \n-package picard.sam;\n+package picard.sam.markduplicates;\n \n import org.testng.Assert;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n+import picard.sam.DuplicationMetrics;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MTgxNQ=="}, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1OTQ3Mg==", "bodyText": "If this is done in more than one CLP, it would make sense to move it to CommandLineProgram.\n(Also, it is odd that File is deprecated in SortingCollection but not in SortingLongCollection)", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445159472", "createdAt": "2020-06-24T20:42:03Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MDY2Nw==", "bodyText": "Is it common to create a sorting collection and not call cleanup() on it?", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445160667", "createdAt": "2020-06-24T20:44:16Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()\n+                .map(File::toPath)\n+                .toArray(Path[]::new);\n+\n+        final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+        final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzM2MA==", "bodyText": "could put ternary op inside constructor\n        try (PrintWriter writer = new PrintWriter(OUTPUT != null ? new FileWriter(OUTPUT) : NullOutputStream.NULL_OUTPUT_STREAM)) {", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445163360", "createdAt": "2020-06-24T20:49:29Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()\n+                .map(File::toPath)\n+                .toArray(Path[]::new);\n+\n+        final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+        final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                new BAMRecordCodec(reader.getFileHeader()),\n+                new SAMRecordQueryNameComparator(),\n+                MAX_RECORDS_IN_RAM,\n+                tmpPaths);\n+\n+        for (final SAMRecord rec : reader) {\n+            alignmentSorter.add(rec);\n+            sortProgress.record(rec);\n+        }\n+        return alignmentSorter;\n+    }\n+\n+    private boolean checkAndTallyRecordDuplicateMarking(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            // this case the queryname changed, and thus there's no comparison to make\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            // Here the current queryname is the same, but the duplicate flag doesn't match the first record with that queryname\n+            numBadRecords++;\n+\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer = OUTPUT == null ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 148}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84b0d1d7504a3a43cd698a56be6abd6a648e5c07", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/84b0d1d7504a3a43cd698a56be6abd6a648e5c07", "committedDate": "2020-07-08T14:56:57Z", "message": "- added a new (undocumented) CLP that will check that all the records with the same queryname have the same duplicate marking.\n- added tests\n- moved another test into a markduplicates test directory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82a334593c16f0dc5d804b5631da6ba66bf8d2c1", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/82a334593c16f0dc5d804b5631da6ba66bf8d2c1", "committedDate": "2020-07-08T14:56:57Z", "message": "-responding to review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cf05de2e9608772423c5fa3940c313fc6d56357", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/0cf05de2e9608772423c5fa3940c313fc6d56357", "committedDate": "2020-07-08T14:58:41Z", "message": "- respond to nits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c295d4b128265fcdbbc848945a2738c566a990d", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/4c295d4b128265fcdbbc848945a2738c566a990d", "committedDate": "2020-07-08T14:59:00Z", "message": "oops. wrong operator."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5488339b6f2e252c4b05b677c4793ea726b4bcdc", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/5488339b6f2e252c4b05b677c4793ea726b4bcdc", "committedDate": "2020-07-08T14:54:53Z", "message": "oops. wrong operator."}, "afterCommit": {"oid": "4c295d4b128265fcdbbc848945a2738c566a990d", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/4c295d4b128265fcdbbc848945a2738c566a990d", "committedDate": "2020-07-08T14:59:00Z", "message": "oops. wrong operator."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8afa73b63910bebe169c4f682302b4c6fa27724", "author": {"user": {"login": "yfarjoun", "name": "Yossi Farjoun"}}, "url": "https://github.com/broadinstitute/picard/commit/e8afa73b63910bebe169c4f682302b4c6fa27724", "committedDate": "2020-07-10T04:17:58Z", "message": "Merge branch 'master' into yf_Add_Check_DuplicateMarking"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2440, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}