{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1MTEyNDI5", "number": 1584, "title": "Safely run DownsampleSam multiple times", "bodyText": "If DownsampleSam is run twice on the same file, the results can end up being incorrect.  This is because the ConstantMemory and Chained strategies both employ a hash based sampling which is initialized with a random seed.  If the seed used in two runs is the same, then the hashes associated with each read pair will be the same.\nAs an example of the problem this causes, consider a case where we have Downsampled with the ConstantMemory strategy and a probability of 0.5.  What this means is that a hash is calculated for each read pair, and the hashes are (with appropriate normalization) uniformly distributed between 0 and 1.  All read pairs which hash to values less than 0.5 will pass the downsampling and be included in the output.  We now attempt to downsample the output a second time with ConstantMemory and probability 0.5, and the same seed as in the previous run.  Since the seed is the same, each read pair hashes to the same value, which is always less than 0.5, so all reads pass the downsampling.  The second downsampling has effectively done nothing.\nIf we are using the HighAccuracy strategy, there will be no issue, since this is a shuffle-and-cut strategy, and so compression of the hash-space causes no problems.\nIf we are using the Chained strategy, there will also be no issue.  The chained strategy first uses a hash based downsample to oversample, and then uses a shuffle-and-cut to get down to the correct fraction.  Since previous runs of downsampling can only serve to compress the hash space, the hash based part of this strategy will only end up oversampling.  Since the shuffle-and-cut part of this strategy uses the measured downsampled fraction (instead of the intended downsampled fraction) in its calculations, this strategy will still work, although it's memory footprint improvement over the HighAccuracy strategy will be reduced.\nSo, there are really three possibilities that need to be considered:\n\n\nConstantMemory now, ConstantMemory previously: in this case an earlier run with ConstantMemory strategy will have compressed the hash space by a factor of p_prev (ie, the previously downsampling probability).  We can therefore get the correct downsampling by internally using a value of p_prev * p_now to compare to the hashes.  Multiple previous runs with ConstantMemory strategy can be easily chained together, with each simply compressing the hash space by a factor of its downsampling probability.  Runs which used a different seed should have no effect on the hash space, so do not need to be considered when adjusting the internal probability.\n\n\nConstantMemory now, HighAccuracy previously:  since the HighAccuracy strategy has no effect on the hash space, this will work unchanged.\n\n\nConstantMemory now, Chained previously:  This is a slightly more complicated version of \"ConstantMemory now, ConstantMemory previously\".  The previous Chained run will have compressed the hash space, but the proportion is defined by ChainedDownsamplingIterator.adjustProportion.  We could technically adjust the internally used probability in the same way as \"ConstantMemory now, ConstantMemory previously\", but the fact that it depends on a private method in htsjdk makes me hesitant to do this.  For now, I am throwing an exception in this case.  Perhaps if ChainedDownsamplingIterator.adjustProportion is made public in the future then handling this case as well would be more reasonable.  Of course, when the seed is different there is no problem.\n\n\nThis PR implements all of the above, as well as adds tests of these types of repeated downsampling cases.\n\nChecklist (never delete this)\nNever delete this, it is our record that procedure was followed. If you find that for whatever reason one of the checklist points doesn't apply to your PR, you can leave it unchecked but please add an explanation below.\nContent\n\n Added or modified tests to cover changes and any new functionality\n Edited the README / documentation (if applicable)\n All tests passing on Travis\n\nReview\n\n Final thumbs-up from reviewer\n Rebase, squash and reword as applicable\n\nFor more detailed guidelines, see https://github.com/broadinstitute/picard/wiki/Guidelines-for-pull-requests", "createdAt": "2020-09-29T21:23:43Z", "url": "https://github.com/broadinstitute/picard/pull/1584", "merged": true, "mergeCommit": {"oid": "3d3043c0c25ee89104c2f46eade66f876005d836"}, "closed": true, "closedAt": "2020-10-08T19:24:43Z", "author": {"login": "kachulis"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdN_myPAFqTQ5OTYxNDk5Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQmLaggBqjM4NTY4ODg5MDA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5NjE0OTky", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-499614992", "createdAt": "2020-09-30T16:33:42Z", "commit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjozMzo0M1rOHal_kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjo0NDoxNlrOHamZjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0NzUwNA==", "bodyText": "you might come across a PG that will not have the rs tag...should protect against that.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497647504", "createdAt": "2020-09-30T16:33:43Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +218,28 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final int previousSeed = Integer.parseInt(pg.getAttribute(RANDOM_SEED_TAG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0ODQ2Mw==", "bodyText": "This is too small a space to traverse. I would pull out random seed from a RNG that itself is initialized with the provided seed.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497648463", "createdAt": "2020-09-30T16:35:15Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +218,28 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final int previousSeed = Integer.parseInt(pg.getAttribute(RANDOM_SEED_TAG));\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                RANDOM_SEED *= 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0OTE5NQ==", "bodyText": "also, if you modified the seed, put out a warning that the provided random seed had already been used and that you are using a different seed (and state what it is)", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497649195", "createdAt": "2020-09-30T16:36:20Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +218,28 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final int previousSeed = Integer.parseInt(pg.getAttribute(RANDOM_SEED_TAG));\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                RANDOM_SEED *= 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0ODQ2Mw=="}, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MTUzMw==", "bodyText": "use 0 and MAX_INT as two options.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497651533", "createdAt": "2020-09-30T16:40:04Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +151,52 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MzU4MQ==", "bodyText": "update the doc for the seed argument to reflect some of the logic here.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497653581", "createdAt": "2020-09-30T16:43:18Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -183,6 +187,8 @@\n \n     private final Log log = Log.getInstance(DownsampleSam.class);\n \n+    public static final String RANDOM_SEED_TAG = \"rs\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NDE1OQ==", "bodyText": "please add a test that shows that downsampling twice with 50% actually yields 25%.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497654159", "createdAt": "2020-09-30T16:44:16Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +151,52 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,3)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, HighAccuracy), Arrays.asList(1,1)});\n+\n+        //randomly generate some sequences to test out\n+        final Strategy[] availableStratagies = Strategy.values();\n+        final Random random = new Random(12345);\n+        for (int i =0; i<20; i++) {\n+            final List<Strategy> strategies = new ArrayList<>();\n+            final List<Integer> seeds = new ArrayList<>();\n+\n+            while (strategies.size() < 5) {\n+                final int seed = random.nextInt(3);\n+                final Strategy strategy = availableStratagies[random.nextInt(availableStratagies.length)];\n+\n+                seeds.add(seed);\n+                strategies.add(strategy);\n+            }\n+            rets.add(new Object[]{strategies, seeds});\n+        }\n+\n+        return rets.toArray(new Object[0][]);\n+    }\n+\n+    @Test(dataProvider = \"RepeatedDownsamplingProvider\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTYyNzAw", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-500562700", "createdAt": "2020-10-01T17:21:25Z", "commit": {"oid": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzoyMToyNVrOHbUC3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzozMDoxN1rOHbUWcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg==", "bodyText": "this break will still cause the code to hit the while loop below after having collected a subset of seeds, I'm not sure that's what you intended.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498402012", "createdAt": "2020-10-01T17:21:25Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,42 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random().nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The current seed has been set to \" + RANDOM_SEED + \" to avoid using the \" +\n+                                \"same seed as previously.\");\n+                        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjg5Mw==", "bodyText": "Also, the log message might be incorrect in that case.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498402893", "createdAt": "2020-10-01T17:22:57Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,42 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random().nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The current seed has been set to \" + RANDOM_SEED + \" to avoid using the \" +\n+                                \"same seed as previously.\");\n+                        break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg=="}, "originalCommit": {"oid": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwNjEwNw==", "bodyText": "Since we want DownsampleSam to be deterministic, we need a better solution here. Perhaps an override argument?", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498406107", "createdAt": "2020-10-01T17:28:41Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,42 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random().nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The current seed has been set to \" + RANDOM_SEED + \" to avoid using the \" +\n+                                \"same seed as previously.\");\n+                        break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg=="}, "originalCommit": {"oid": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwNzAyNA==", "bodyText": "expand imports", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498407024", "createdAt": "2020-10-01T17:30:17Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -18,9 +18,12 @@\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n \n+import static htsjdk.samtools.DownsamplingIteratorFactory.Strategy.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDc0ODQ4", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-503474848", "createdAt": "2020-10-07T02:02:17Z", "commit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowMjoxN1rOHdf78Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowMjoxN1rOHdf78Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDAwMQ==", "bodyText": "RANDOM_SEED may be null.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694001", "createdAt": "2020-10-07T02:02:17Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final int USER_SEED = RANDOM_SEED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDc1MDk4", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-503475098", "createdAt": "2020-10-07T02:03:06Z", "commit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowMzowNlrOHdf8qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowMzowNlrOHdf8qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDE4NQ==", "bodyText": "extra space before period...were you going to put a more informative error message here?", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694185", "createdAt": "2020-10-07T02:03:06Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final int USER_SEED = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            final Random rnd = new Random(RANDOM_SEED);\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                final int previousSeed = RANDOM_SEED;\n+                RANDOM_SEED = rnd.nextInt();\n+                log.warn(\"DownsampleSam has been run before on this data with the seed .  The random seed will be changed to avoid using the \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDc1NjI2", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-503475626", "createdAt": "2020-10-07T02:04:47Z", "commit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowNDo0N1rOHdf-nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowNDo0N1rOHdf-nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDY4Nw==", "bodyText": "spaces", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694687", "createdAt": "2020-10-07T02:04:47Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +153,63 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(0,0)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MAX_VALUE,Integer.MAX_VALUE)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MIN_VALUE,Integer.MIN_VALUE)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MIN_VALUE,Integer.MAX_VALUE)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MAX_VALUE,0)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,3)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, HighAccuracy), Arrays.asList(1,1)});\n+\n+        //randomly generate some sequences to test out\n+        final Strategy[] availableStratagies = Strategy.values();\n+        final Random random = new Random(12345);\n+        for (int i =0; i<20; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDc1Njc1", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-503475675", "createdAt": "2020-10-07T02:04:54Z", "commit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowNDo1NFrOHdf-zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowNDo1NFrOHdf-zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDczNQ==", "bodyText": "too many spaces", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694735", "createdAt": "2020-10-07T02:04:54Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +153,63 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDc1ODE3", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-503475817", "createdAt": "2020-10-07T02:05:16Z", "commit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTIzMzQ3", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-504923347", "createdAt": "2020-10-08T15:46:36Z", "commit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0NjozNlrOHek_6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0NjozNlrOHek_6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTUxNA==", "bodyText": "This hash is effectively random since it's the Object.hashCode(), right? but it gives the illusion of being deterministic.\nI think it should be as deterministic as possible, but am not sure what here can be used as a seed. perhaps the collection of PU fields from the RG tags? not sure how you'd like to resolve this,\nbut I don't like hidden randomness.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501825514", "createdAt": "2020-10-08T15:46:36Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTIzNzA1", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-504923705", "createdAt": "2020-10-08T15:46:58Z", "commit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0Njo1OFrOHelBBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0Njo1OFrOHelBBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTc5Nw==", "bodyText": "no need to split this into two lines.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501825797", "createdAt": "2020-10-08T15:46:58Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTI1ODA2", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-504925806", "createdAt": "2020-10-08T15:49:09Z", "commit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0OTowOVrOHelHFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0OTowOVrOHelHFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNzM0OQ==", "bodyText": "final", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501827349", "createdAt": "2020-10-08T15:49:09Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            final Random rnd = new Random(RANDOM_SEED);\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                final int previousSeed = RANDOM_SEED;\n+                RANDOM_SEED = rnd.nextInt();\n+                log.warn(\"DownsampleSam has been run before on this data with the seed \" + RANDOM_SEED + \".  The random seed will be changed to avoid using the \" +\n+                        \"same seed as previously.\");\n+            }\n+            if (!userSeed.equals(RANDOM_SEED)) {\n+                log.warn(\"RANDOM_SEED has been changed to \" + RANDOM_SEED + \".\");\n+            }\n+        }\n+\n+        SAMProgramRecord pgRecord = getPGRecord(header);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTI2ODAw", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-504926800", "createdAt": "2020-10-08T15:50:13Z", "commit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MDY2OTg0", "url": "https://github.com/broadinstitute/picard/pull/1584#pullrequestreview-505066984", "createdAt": "2020-10-08T18:43:39Z", "commit": {"oid": "d0612e8f1c9deffcd0f6c02564c90caab6256c53"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6f8b5facb51f914ab73cfc131dc9bf56914e2e7", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/f6f8b5facb51f914ab73cfc131dc9bf56914e2e7", "committedDate": "2020-10-08T18:48:31Z", "message": "safety check when Downsampling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8739d7a5f23b41c4fc0cf339a4bdf2a449d62f8d", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/8739d7a5f23b41c4fc0cf339a4bdf2a449d62f8d", "committedDate": "2020-10-08T18:48:31Z", "message": "refactor addition of pg line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf348d0024f05fe1a6fdd5cd083f0a572d8bce6e", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/cf348d0024f05fe1a6fdd5cd083f0a572d8bce6e", "committedDate": "2020-10-08T18:48:31Z", "message": "better tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46cb0760acb823a71ec364a3a9804b30732cec47", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/46cb0760acb823a71ec364a3a9804b30732cec47", "committedDate": "2020-10-08T18:48:31Z", "message": "internally adjust probability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fac2638a700d311e2186085aa8327e2cc23d16e2", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/fac2638a700d311e2186085aa8327e2cc23d16e2", "committedDate": "2020-10-08T18:48:31Z", "message": "adjust seed instead of probability, add tag to pg record instead of parsing command line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20a72a75fb71810f2ceed2c88093296a9d819a17", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/20a72a75fb71810f2ceed2c88093296a9d819a17", "committedDate": "2020-10-08T18:48:31Z", "message": "cleanup and fix random seed adjustment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7acdedee3c2ccdfbb5b4719bb450ab2eef2a26da", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/7acdedee3c2ccdfbb5b4719bb450ab2eef2a26da", "committedDate": "2020-10-08T18:48:31Z", "message": "actually add pg record to header"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55da2a0cf7b48f0af383f639395cb3520243f5f7", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/55da2a0cf7b48f0af383f639395cb3520243f5f7", "committedDate": "2020-10-08T18:48:31Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c38cc9faab258a2bdd470187f03117cbd81ea81", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/4c38cc9faab258a2bdd470187f03117cbd81ea81", "committedDate": "2020-10-08T18:48:31Z", "message": "don't need PicardException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dd9edcff2e9443990d927b315cbfe12c0c4e733", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/4dd9edcff2e9443990d927b315cbfe12c0c4e733", "committedDate": "2020-10-08T18:48:31Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f20f43c1963629ce9507981170de5ea7aa8c4998", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/f20f43c1963629ce9507981170de5ea7aa8c4998", "committedDate": "2020-10-08T18:48:31Z", "message": "small cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec7c80b4235ecf34ed837297717af1f13cc44ecf", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/ec7c80b4235ecf34ed837297717af1f13cc44ecf", "committedDate": "2020-10-08T18:48:31Z", "message": "review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8d984816fe56e70b41fffe6333e79277cc10d37", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/b8d984816fe56e70b41fffe6333e79277cc10d37", "committedDate": "2020-10-08T18:48:31Z", "message": "remove extra blank line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80b4042c227f452680de1b8a3d1267d4f1313ac5", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/80b4042c227f452680de1b8a3d1267d4f1313ac5", "committedDate": "2020-10-08T18:48:31Z", "message": "try again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "846572b2b274b48d9c0df6442393366cd489911e", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/846572b2b274b48d9c0df6442393366cd489911e", "committedDate": "2020-10-08T18:48:31Z", "message": "avoid npe"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0612e8f1c9deffcd0f6c02564c90caab6256c53", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/d0612e8f1c9deffcd0f6c02564c90caab6256c53", "committedDate": "2020-10-08T18:22:51Z", "message": "avoid npe"}, "afterCommit": {"oid": "846572b2b274b48d9c0df6442393366cd489911e", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/846572b2b274b48d9c0df6442393366cd489911e", "committedDate": "2020-10-08T18:48:31Z", "message": "avoid npe"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2320, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}