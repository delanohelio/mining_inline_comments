{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NTQxOTI4", "number": 1589, "title": "MBA deletion edge case alternate solution", "bodyText": "This is the alternate solution discuss in #1581.  I think it makes the code a bit cleaner and more understandable.\nChecklist (never delete this)\nNever delete this, it is our record that procedure was followed. If you find that for whatever reason one of the checklist points doesn't apply to your PR, you can leave it unchecked but please add an explanation below.\nContent\n\n Added or modified tests to cover changes and any new functionality\n Edited the README / documentation (if applicable)\n All tests passing on Travis\n\nReview\n\n Final thumbs-up from reviewer\n Rebase, squash and reword as applicable\n\nFor more detailed guidelines, see https://github.com/broadinstitute/picard/wiki/Guidelines-for-pull-requests", "createdAt": "2020-10-01T20:56:47Z", "url": "https://github.com/broadinstitute/picard/pull/1589", "merged": true, "mergeCommit": {"oid": "49f478a92a46ee41e2618bf084dc59c73093a104"}, "closed": true, "closedAt": "2020-10-02T21:35:01Z", "author": {"login": "kachulis"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOdhH0AFqTUwMDc0MzM1MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOsTMpABqjM4MzU2MDI1ODI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzQzMzUx", "url": "https://github.com/broadinstitute/picard/pull/1589#pullrequestreview-500743351", "createdAt": "2020-10-01T21:51:37Z", "commit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTo1MTozN1rOHbb7yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMzozMToxMVrOHbgdWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTI3Mw==", "bodyText": "You dropped the \"innies\" requirement it seems...I'm not sure if that is on purpose, or just not needed...but could you add tests to show that they do not get clipped?", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498531273", "createdAt": "2020-10-01T21:51:37Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTc1Mw==", "bodyText": "also how do we know if reads are innes? what do we do with the clipped bases?\n   <-----------------------SSSSSSSSS\n                                SSSSSSS------------------------->\n\n(S being a soft-clipped base....)", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498531753", "createdAt": "2020-10-01T21:52:56Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTI3Mw=="}, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDU2OQ==", "bodyText": "did you mix up 3' and 5' here? or am I confused?", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498534569", "createdAt": "2020-10-01T22:01:16Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDc4Nw==", "bodyText": "5'------------------------------------->3'\n3' <-----------------------------5'", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498534787", "createdAt": "2020-10-01T22:01:59Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDU2OQ=="}, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDI0MA==", "bodyText": "perhaps these variables need to be renamed, where the first assignment is negFirstBaseToClip (unchanged) and the second is negFirstBaseFrom3PrimeEndToClip?", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498574240", "createdAt": "2020-10-02T00:34:53Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDgyMw==", "bodyText": "could this be moved up so it's next to the other stuff that deals with pos?", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498574823", "createdAt": "2020-10-02T00:37:39Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n+        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+\n+        if(posLastUnclipped > 0 && posLastUnclipped < pos.getReadLength()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwNTQwMw==", "bodyText": "1-based position,\n0 if reference position doesn't overlap with read even with softclips converted to matches.", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498605403", "createdAt": "2020-10-02T03:31:11Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n+        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+\n+        if(posLastUnclipped > 0 && posLastUnclipped < pos.getReadLength()) {\n+            clip3PrimeEndOfRead(pos, posLastUnclipped + 1, hardClipReads);\n         }\n-        if(negClipFrom > 0) {\n-            clip3PrimeEndOfRead(neg, negClipFrom, hardClipReads);\n+        if(negFirstBaseToClip > 0) {\n+            clip3PrimeEndOfRead(neg, negFirstBaseToClip, hardClipReads);\n         }\n     }\n \n+    /**\n+     * Gets the read position that corresponds to a particular position on the reference.  If the position on the reference\n+     * falls in a deletion in the alignment of the read, the position before the deletion will be returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d09e6c0da0417494574bc73373fdf930a64b881"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDI5MDE5", "url": "https://github.com/broadinstitute/picard/pull/1589#pullrequestreview-501429019", "createdAt": "2020-10-02T20:30:32Z", "commit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMDozMlrOHb6xAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMDozMlrOHb6xAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNjQxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(negFirstBaseFrom5PrimeEndToClip > 0) {\n          \n          \n            \n                    if (negFirstBaseFrom5PrimeEndToClip > 0) {", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499036419", "createdAt": "2020-10-02T20:30:32Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,69 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n-\n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n+         */\n+\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n+            final int pos5PrimeMostClipped = pos3PrimeMostUnclipped + 1;\n+            clip3PrimeEndOfRead(pos, pos5PrimeMostClipped, hardClipReads);\n         }\n-        if(negClipFrom > 0) {\n-            clip3PrimeEndOfRead(neg, negClipFrom, hardClipReads);\n+\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read.\n+         */\n+\n+        //this is the position counting from the aligned start of the read\n+        final int neg5PrimeMostBaseToClipPositionFromStart = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n+\n+        //this is the position counting from the 5' end of the read\n+        final int negFirstBaseFrom5PrimeEndToClip = neg5PrimeMostBaseToClipPositionFromStart > 0 ? (neg.getReadLength() + 1) - neg5PrimeMostBaseToClipPositionFromStart : 0;\n+\n+        if(negFirstBaseFrom5PrimeEndToClip > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDMwNDcz", "url": "https://github.com/broadinstitute/picard/pull/1589#pullrequestreview-501430473", "createdAt": "2020-10-02T20:33:16Z", "commit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMzoxNlrOHb61NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMzoxNlrOHb61NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNzQ5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    //this is the position counting from the aligned start of the read\n          \n          \n            \n                    // this is the position counting from the aligned start of the read", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499037492", "createdAt": "2020-10-02T20:33:16Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n          */\n \n-        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n+            final int pos5PrimeMostClipped = pos3PrimeMostUnclipped + 1;\n+            clip3PrimeEndOfRead(pos, pos5PrimeMostClipped, hardClipReads);\n+        }\n \n         /*\n         For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n-         the queried base when the queried base is in a deletion on a negative strand read\n+         the queried base when the queried base is in a deletion on a negative strand read.\n          */\n \n-        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+        //this is the position counting from the aligned start of the read", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDMwNTU0", "url": "https://github.com/broadinstitute/picard/pull/1589#pullrequestreview-501430554", "createdAt": "2020-10-02T20:33:26Z", "commit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMzoyNlrOHb61eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozMzoyNlrOHb61eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNzU2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    //this is the position counting from the 5' end of the read\n          \n          \n            \n                    // this is the position counting from the 5' end of the read", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499037560", "createdAt": "2020-10-02T20:33:26Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n          */\n \n-        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n+            final int pos5PrimeMostClipped = pos3PrimeMostUnclipped + 1;\n+            clip3PrimeEndOfRead(pos, pos5PrimeMostClipped, hardClipReads);\n+        }\n \n         /*\n         For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n-         the queried base when the queried base is in a deletion on a negative strand read\n+         the queried base when the queried base is in a deletion on a negative strand read.\n          */\n \n-        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+        //this is the position counting from the aligned start of the read\n+        final int neg5PrimeMostBaseToClipPositionFromStart = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n \n-        if(posLastUnclipped > 0 && posLastUnclipped < pos.getReadLength()) {\n-            clip3PrimeEndOfRead(pos, posLastUnclipped + 1, hardClipReads);\n-        }\n-        if(negFirstBaseToClip > 0) {\n-            clip3PrimeEndOfRead(neg, negFirstBaseToClip, hardClipReads);\n+        //this is the position counting from the 5' end of the read", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDMzMjQ5", "url": "https://github.com/broadinstitute/picard/pull/1589#pullrequestreview-501433249", "createdAt": "2020-10-02T20:38:25Z", "commit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozODoyNVrOHb69Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozODoyNVrOHb69Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTUxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n          \n          \n            \n                    if (pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499039519", "createdAt": "2020-10-02T20:38:25Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n          */\n \n-        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDMzNTk0", "url": "https://github.com/broadinstitute/picard/pull/1589#pullrequestreview-501433594", "createdAt": "2020-10-02T20:39:03Z", "commit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozOTowM1rOHb6-Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozOTowM1rOHb6-Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTc3MQ==", "bodyText": "the 5 looks like an S...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        3'<SSSSSSSSMMMMMMMMMMMM5'\n          \n          \n            \n                       3' <SSSSSSSSMMMMMMMMMMMM 5'", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499039771", "createdAt": "2020-10-02T20:39:03Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDMzNjgz", "url": "https://github.com/broadinstitute/picard/pull/1589#pullrequestreview-501433683", "createdAt": "2020-10-02T20:39:13Z", "commit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozOToxM1rOHb6-XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDozOToxM1rOHb6-XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTgzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                 5'MMMMMMMMMMMMSSSSSSSS>3'\n          \n          \n            \n                                5' MMMMMMMMMMMMSSSSSSSS> 3'", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499039837", "createdAt": "2020-10-02T20:39:13Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDM0NDUz", "url": "https://github.com/broadinstitute/picard/pull/1589#pullrequestreview-501434453", "createdAt": "2020-10-02T20:40:40Z", "commit": {"oid": "73ea523f7b61f9d74c885409c0313835f7cddeb8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4392e3bdc4b167ab526ac672cf1952088aac07d", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/f4392e3bdc4b167ab526ac672cf1952088aac07d", "committedDate": "2020-10-02T20:48:34Z", "message": "beginning change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e40601a422e4ddecc9c78752d2cf72ac724cb5be", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/e40601a422e4ddecc9c78752d2cf72ac724cb5be", "committedDate": "2020-10-02T20:48:34Z", "message": "get working, tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d05515aa91d7971442be838d1e0eb39fd51b37d", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/2d05515aa91d7971442be838d1e0eb39fd51b37d", "committedDate": "2020-10-02T20:48:34Z", "message": "some cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b3a592c26ac484f2a3cf23f7a8311701bbfd686", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/7b3a592c26ac484f2a3cf23f7a8311701bbfd686", "committedDate": "2020-10-02T20:48:34Z", "message": "more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d728a5a96592147799456a6d64403459be601d64", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/d728a5a96592147799456a6d64403459be601d64", "committedDate": "2020-10-02T20:48:35Z", "message": "another test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2a0aa7bf23538a6bc59ccc745b52486e09de80e", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/d2a0aa7bf23538a6bc59ccc745b52486e09de80e", "committedDate": "2020-10-02T20:48:35Z", "message": "variable name change for clarity"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9722b0a3fe204074e6afa818c211b4a911e686f9", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/9722b0a3fe204074e6afa818c211b4a911e686f9", "committedDate": "2020-10-02T20:48:35Z", "message": "test to demonstrate edge case change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20b20e9f0e515ce6bfc17aae956c3c2f7319aae9", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/20b20e9f0e515ce6bfc17aae956c3c2f7319aae9", "committedDate": "2020-10-02T20:48:35Z", "message": "ascii art"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6cce2bdb473a959774fe686420aed15fe91351f", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/c6cce2bdb473a959774fe686420aed15fe91351f", "committedDate": "2020-10-02T20:48:35Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d001dbef722d595afef93e717bbabe18d4257b6", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/3d001dbef722d595afef93e717bbabe18d4257b6", "committedDate": "2020-10-02T20:48:35Z", "message": "spaces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "187eb788bdd37d098ffcb6e5e4f8047b29962f9e", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/187eb788bdd37d098ffcb6e5e4f8047b29962f9e", "committedDate": "2020-10-02T20:47:13Z", "message": "spaces"}, "afterCommit": {"oid": "3d001dbef722d595afef93e717bbabe18d4257b6", "author": {"user": {"login": "kachulis", "name": null}}, "url": "https://github.com/broadinstitute/picard/commit/3d001dbef722d595afef93e717bbabe18d4257b6", "committedDate": "2020-10-02T20:48:35Z", "message": "spaces"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2328, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}