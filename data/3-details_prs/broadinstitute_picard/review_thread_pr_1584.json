{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1MTEyNDI5", "number": 1584, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjozMzo0M1rOEpHM5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0OTowOVrOErrYTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTQ1MDYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/DownsampleSam.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjozMzo0M1rOHal_kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTowOToxOVrOHbPAsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0NzUwNA==", "bodyText": "you might come across a PG that will not have the rs tag...should protect against that.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497647504", "createdAt": "2020-09-30T16:33:43Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +218,28 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final int previousSeed = Integer.parseInt(pg.getAttribute(RANDOM_SEED_TAG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxOTUzNw==", "bodyText": "done", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498319537", "createdAt": "2020-10-01T15:09:19Z", "author": {"login": "kachulis"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +218,28 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final int previousSeed = Integer.parseInt(pg.getAttribute(RANDOM_SEED_TAG));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0NzUwNA=="}, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTQ1NjY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/DownsampleSam.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjozNToxNVrOHamDTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTowOTo0NVrOHbPCDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0ODQ2Mw==", "bodyText": "This is too small a space to traverse. I would pull out random seed from a RNG that itself is initialized with the provided seed.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497648463", "createdAt": "2020-09-30T16:35:15Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +218,28 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final int previousSeed = Integer.parseInt(pg.getAttribute(RANDOM_SEED_TAG));\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                RANDOM_SEED *= 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0OTE5NQ==", "bodyText": "also, if you modified the seed, put out a warning that the provided random seed had already been used and that you are using a different seed (and state what it is)", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497649195", "createdAt": "2020-09-30T16:36:20Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +218,28 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final int previousSeed = Integer.parseInt(pg.getAttribute(RANDOM_SEED_TAG));\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                RANDOM_SEED *= 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0ODQ2Mw=="}, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxOTg4NA==", "bodyText": "done", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498319884", "createdAt": "2020-10-01T15:09:45Z", "author": {"login": "kachulis"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +218,28 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final int previousSeed = Integer.parseInt(pg.getAttribute(RANDOM_SEED_TAG));\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                RANDOM_SEED *= 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0ODQ2Mw=="}, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTQ3NTcxOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/sam/DownsampleSamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjo0MDowNFrOHamPTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjo0MDowNFrOHamPTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MTUzMw==", "bodyText": "use 0 and MAX_INT as two options.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497651533", "createdAt": "2020-09-30T16:40:04Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +151,52 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTQ4ODMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/DownsampleSam.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjo0MzoxOFrOHamXTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjo0MzoxOFrOHamXTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MzU4MQ==", "bodyText": "update the doc for the seed argument to reflect some of the logic here.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497653581", "createdAt": "2020-09-30T16:43:18Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -183,6 +187,8 @@\n \n     private final Log log = Log.getInstance(DownsampleSam.class);\n \n+    public static final String RANDOM_SEED_TAG = \"rs\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTQ5MTgyOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/sam/DownsampleSamTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNjo0NDoxNlrOHamZjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowNDozMlrOHdf-Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NDE1OQ==", "bodyText": "please add a test that shows that downsampling twice with 50% actually yields 25%.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497654159", "createdAt": "2020-09-30T16:44:16Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +151,52 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,3)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, HighAccuracy), Arrays.asList(1,1)});\n+\n+        //randomly generate some sequences to test out\n+        final Strategy[] availableStratagies = Strategy.values();\n+        final Random random = new Random(12345);\n+        for (int i =0; i<20; i++) {\n+            final List<Strategy> strategies = new ArrayList<>();\n+            final List<Integer> seeds = new ArrayList<>();\n+\n+            while (strategies.size() < 5) {\n+                final int seed = random.nextInt(3);\n+                final Strategy strategy = availableStratagies[random.nextInt(availableStratagies.length)];\n+\n+                seeds.add(seed);\n+                strategies.add(strategy);\n+            }\n+            rets.add(new Object[]{strategies, seeds});\n+        }\n+\n+        return rets.toArray(new Object[0][]);\n+    }\n+\n+    @Test(dataProvider = \"RepeatedDownsamplingProvider\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMzNTIwMw==", "bodyText": "testDownsampleWorker does this in some sense, in that it tests that each downsampling step actually downsamples the data as intended.  I have also added code to test the the cumulative downsampling is as expected.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498335203", "createdAt": "2020-10-01T15:30:43Z", "author": {"login": "kachulis"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +151,52 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,3)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, HighAccuracy), Arrays.asList(1,1)});\n+\n+        //randomly generate some sequences to test out\n+        final Strategy[] availableStratagies = Strategy.values();\n+        final Random random = new Random(12345);\n+        for (int i =0; i<20; i++) {\n+            final List<Strategy> strategies = new ArrayList<>();\n+            final List<Integer> seeds = new ArrayList<>();\n+\n+            while (strategies.size() < 5) {\n+                final int seed = random.nextInt(3);\n+                final Strategy strategy = availableStratagies[random.nextInt(availableStratagies.length)];\n+\n+                seeds.add(seed);\n+                strategies.add(strategy);\n+            }\n+            rets.add(new Object[]{strategies, seeds});\n+        }\n+\n+        return rets.toArray(new Object[0][]);\n+    }\n+\n+    @Test(dataProvider = \"RepeatedDownsamplingProvider\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NDE1OQ=="}, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDYxOQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694619", "createdAt": "2020-10-07T02:04:32Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +151,52 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,3)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, HighAccuracy), Arrays.asList(1,1)});\n+\n+        //randomly generate some sequences to test out\n+        final Strategy[] availableStratagies = Strategy.values();\n+        final Random random = new Random(12345);\n+        for (int i =0; i<20; i++) {\n+            final List<Strategy> strategies = new ArrayList<>();\n+            final List<Integer> seeds = new ArrayList<>();\n+\n+            while (strategies.size() < 5) {\n+                final int seed = random.nextInt(3);\n+                final Strategy strategy = availableStratagies[random.nextInt(availableStratagies.length)];\n+\n+                seeds.add(seed);\n+                strategies.add(strategy);\n+            }\n+            rets.add(new Object[]{strategies, seeds});\n+        }\n+\n+        return rets.toArray(new Object[0][]);\n+    }\n+\n+    @Test(dataProvider = \"RepeatedDownsamplingProvider\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NDE1OQ=="}, "originalCommit": {"oid": "d52442bcf3175dc19588cc2fe724514be89e1396"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDIxNzExOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/DownsampleSam.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzoyMToyNVrOHbUC3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODo0MTo1MVrOHerv-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg==", "bodyText": "this break will still cause the code to hit the while loop below after having collected a subset of seeds, I'm not sure that's what you intended.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498402012", "createdAt": "2020-10-01T17:21:25Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,42 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random().nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The current seed has been set to \" + RANDOM_SEED + \" to avoid using the \" +\n+                                \"same seed as previously.\");\n+                        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjg5Mw==", "bodyText": "Also, the log message might be incorrect in that case.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498402893", "createdAt": "2020-10-01T17:22:57Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,42 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random().nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The current seed has been set to \" + RANDOM_SEED + \" to avoid using the \" +\n+                                \"same seed as previously.\");\n+                        break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg=="}, "originalCommit": {"oid": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwNjEwNw==", "bodyText": "Since we want DownsampleSam to be deterministic, we need a better solution here. Perhaps an override argument?", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498406107", "createdAt": "2020-10-01T17:28:41Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,42 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random().nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The current seed has been set to \" + RANDOM_SEED + \" to avoid using the \" +\n+                                \"same seed as previously.\");\n+                        break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg=="}, "originalCommit": {"oid": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzNjEyMQ==", "bodyText": "sorry, I missed that.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501936121", "createdAt": "2020-10-08T18:41:51Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,42 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random().nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The current seed has been set to \" + RANDOM_SEED + \" to avoid using the \" +\n+                                \"same seed as previously.\");\n+                        break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg=="}, "originalCommit": {"oid": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDI0Nzc0OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/sam/DownsampleSamTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzozMDoxN1rOHbUWcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzozMDoxN1rOHbUWcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwNzAyNA==", "bodyText": "expand imports", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498407024", "createdAt": "2020-10-01T17:30:17Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -18,9 +18,12 @@\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n \n+import static htsjdk.samtools.DownsamplingIteratorFactory.Strategy.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA2NjY2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/DownsampleSam.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowMjoxN1rOHdf78Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODo0Mjo0NVrOHerx1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDAwMQ==", "bodyText": "RANDOM_SEED may be null.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694001", "createdAt": "2020-10-07T02:02:17Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final int USER_SEED = RANDOM_SEED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDQzNA==", "bodyText": "also, no reason to ALL_CAPS the userSeed variable. We usually reserve that for input arguments and statics", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694434", "createdAt": "2020-10-07T02:03:54Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final int USER_SEED = RANDOM_SEED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDAwMQ=="}, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NTQxMw==", "bodyText": "null RANDOM_SEED is checked for earlier, and at this point in the code it can't be null.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501675413", "createdAt": "2020-10-08T12:20:08Z", "author": {"login": "kachulis"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final int USER_SEED = RANDOM_SEED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDAwMQ=="}, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzNjU5OA==", "bodyText": "thanks for pointing that out.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501936598", "createdAt": "2020-10-08T18:42:45Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final int USER_SEED = RANDOM_SEED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDAwMQ=="}, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA2Nzg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/DownsampleSam.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowMzowNlrOHdf8qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowMzowNlrOHdf8qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDE4NQ==", "bodyText": "extra space before period...were you going to put a more informative error message here?", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694185", "createdAt": "2020-10-07T02:03:06Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final int USER_SEED = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            final Random rnd = new Random(RANDOM_SEED);\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                final int previousSeed = RANDOM_SEED;\n+                RANDOM_SEED = rnd.nextInt();\n+                log.warn(\"DownsampleSam has been run before on this data with the seed .  The random seed will be changed to avoid using the \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA3MTYwOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/sam/DownsampleSamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowNDo0N1rOHdf-nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowNDo0N1rOHdf-nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDY4Nw==", "bodyText": "spaces", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694687", "createdAt": "2020-10-07T02:04:47Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +153,63 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(0,0)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MAX_VALUE,Integer.MAX_VALUE)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MIN_VALUE,Integer.MIN_VALUE)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MIN_VALUE,Integer.MAX_VALUE)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MAX_VALUE,0)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,3)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, HighAccuracy), Arrays.asList(1,1)});\n+\n+        //randomly generate some sequences to test out\n+        final Strategy[] availableStratagies = Strategy.values();\n+        final Random random = new Random(12345);\n+        for (int i =0; i<20; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA3MTk2OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/sam/DownsampleSamTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowNDo1NFrOHdf-zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowNDo1NFrOHdf-zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDczNQ==", "bodyText": "too many spaces", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694735", "createdAt": "2020-10-07T02:04:54Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +153,63 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "370a63ce143be5581bc318c375888a0d80a0197f"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MjMzODIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/DownsampleSam.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0NjozNlrOHek_6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxNzo0M1rOHeq3zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTUxNA==", "bodyText": "This hash is effectively random since it's the Object.hashCode(), right? but it gives the illusion of being deterministic.\nI think it should be as deterministic as possible, but am not sure what here can be used as a seed. perhaps the collection of PU fields from the RG tags? not sure how you'd like to resolve this,\nbut I don't like hidden randomness.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501825514", "createdAt": "2020-10-08T15:46:36Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkyMTc0Mg==", "bodyText": "SAMProgramRecord has a hashCode method that avoids dropping into Object.hashCode(), so I believe this should be deterministic.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501921742", "createdAt": "2020-10-08T18:17:43Z", "author": {"login": "kachulis"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTUxNA=="}, "originalCommit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MjM0MDA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/DownsampleSam.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0Njo1OFrOHelBBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxMDowMVrOHeqk-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTc5Nw==", "bodyText": "no need to split this into two lines.", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501825797", "createdAt": "2020-10-08T15:46:58Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNDUxMw==", "bodyText": "I meant the extra variable previousSeed", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501914513", "createdAt": "2020-10-08T18:06:10Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTc5Nw=="}, "originalCommit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNjkyMg==", "bodyText": "that makes more sense", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501916922", "createdAt": "2020-10-08T18:10:01Z", "author": {"login": "kachulis"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTc5Nw=="}, "originalCommit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MjM0OTU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/DownsampleSam.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0OTowOVrOHelHFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo0OTowOVrOHelHFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNzM0OQ==", "bodyText": "final", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501827349", "createdAt": "2020-10-08T15:49:09Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            final Random rnd = new Random(RANDOM_SEED);\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                final int previousSeed = RANDOM_SEED;\n+                RANDOM_SEED = rnd.nextInt();\n+                log.warn(\"DownsampleSam has been run before on this data with the seed \" + RANDOM_SEED + \".  The random seed will be changed to avoid using the \" +\n+                        \"same seed as previously.\");\n+            }\n+            if (!userSeed.equals(RANDOM_SEED)) {\n+                log.warn(\"RANDOM_SEED has been changed to \" + RANDOM_SEED + \".\");\n+            }\n+        }\n+\n+        SAMProgramRecord pgRecord = getPGRecord(header);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fecb519b860215d647fb28464414b458f50283f"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 647, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}