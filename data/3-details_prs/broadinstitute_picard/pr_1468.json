{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1NTI5MDU0", "number": 1468, "title": "GL-859.  Ported CompareGtcFiles from Picard private repo", "bodyText": "Description\nThe tool CompareGtcFiles is a handy tool for comparing Illumina GTC files.\nIt previously lived in the picard private repo.  In this PR we migrate it to the\npicard repo.\n\nChecklist (never delete this)\nNever delete this, it is our record that procedure was followed. If you find that for whatever reason one of the checklist points doesn't apply to your PR, you can leave it unchecked but please add an explanation below.\nContent\n\n Added or modified tests to cover changes and any new functionality\n Edited the README / documentation (if applicable)\n All tests passing on Travis\n\nReview\n\n Final thumbs-up from reviewer\n Rebase, squash and reword as applicable\n\nFor more detailed guidelines, see https://github.com/broadinstitute/picard/wiki/Guidelines-for-pull-requests", "createdAt": "2020-02-14T19:04:27Z", "url": "https://github.com/broadinstitute/picard/pull/1468", "merged": true, "mergeCommit": {"oid": "b3b8fcce46bb8f9a6300c5b83d9dc5b17a9f636f"}, "closed": true, "closedAt": "2020-03-16T18:57:50Z", "author": {"login": "gbggrant"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcEU46vgFqTM1OTE2NzM4MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOSVXZgBqjMxMzQ0NTAxNjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MTY3Mzgx", "url": "https://github.com/broadinstitute/picard/pull/1468#pullrequestreview-359167381", "createdAt": "2020-02-14T19:25:29Z", "commit": {"oid": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOToyNToyOVrOFqBNPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTo0MTo0N1rOFqBorg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNDI4Ng==", "bodyText": "can be final\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<String> errors = new ArrayList<>();\n          \n          \n            \n                private final List<String> errors = new ArrayList<>();", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379604286", "createdAt": "2020-02-14T19:25:29Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNTAwNw==", "bodyText": "Is there a reason to not use Arrays.of() here? I think that would be cleaner than having a static block", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379605007", "createdAt": "2020-02-14T19:27:09Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNjY5Ng==", "bodyText": "These are opened and never closed, using try-with-resources would fix that, although it's a bit awkward since InfiniumGTCFile itself is not AutoCloseable.", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379606696", "createdAt": "2020-02-14T19:30:53Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNzcwNg==", "bodyText": "The java convention is to put a space after //, it would be nice to update the comments in this file to follow that standard. Also in cases like this, where the comment is a punctuated sentence, it should start with a capital letter.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        //report errors and exit 1 if any are detected.\n          \n          \n            \n                        // Report errors and exit 1 if any are detected.", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379607706", "createdAt": "2020-02-14T19:33:17Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+            InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest);\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            //report errors and exit 1 if any are detected.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwODg3MQ==", "bodyText": "It's little confusing that type is used here when this is actually the method name.", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379608871", "createdAt": "2020-02-14T19:35:58Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+            InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest);\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            //report errors and exit 1 if any are detected.\n+            if (!errors.isEmpty()) {\n+                for (String error : errors) {\n+                    log.error(error);\n+                }\n+                return 1;\n+            }\n+        } catch (IOException | IllegalAccessException | InvocationTargetException e) {\n+            throw new PicardException(\"File error: \", e);\n+        }\n+        return 0;\n+    }\n+\n+    private void compareGTCFiles(InfiniumGTCFile gtcFileOne, InfiniumGTCFile gtcFileTwo) throws InvocationTargetException, IllegalAccessException {\n+        //compare all fields we expect won't change.\n+        Method[] methods = gtcFileOne.getClass().getMethods();\n+        for (Method method : methods) {\n+            //skip ignored methods.\n+            if (IGNORED_METHODS.contains(method.getName())) {\n+                continue;\n+            }\n+            //compare all getters\n+            if (method.getName().startsWith(\"get\") && method.getGenericParameterTypes().length == 0) {\n+                //if we have a version and they don't match we just want a warning\n+                //if getter returns an array compare all array values otherwise do an Object compare.\n+                //if getter returns an array of arrays do deep compare\n+                if (method.getName().equals(\"getFileVersion\")) {\n+                    compareVersions(method.invoke(gtcFileOne), method.invoke(gtcFileTwo));\n+                } else if (method.getReturnType().isArray() && method.getReturnType().getComponentType().isArray()) {\n+                    compareArrayOfArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else if (method.getReturnType().isArray()) {\n+                    compareArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else {\n+                    compare(method.invoke(gtcFileOne),\n+                            method.invoke(gtcFileTwo), method.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void compareVersions(Object versionOne, Object versionTwo) {\n+        if (!versionOne.equals(versionTwo)) {\n+            log.warn(String.format(\"File versions do not match ( %s vs %s )\",\n+                    versionOne, versionTwo));\n+        }\n+    }\n+\n+    private void compare(Object objectOne, Object objectTwo, String type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwOTc3Mg==", "bodyText": "These parameters are not necessarily arrays. Maybe Object objectOne, Object objectTwo would be better\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean checkNulls(Object arrayOne, Object arrayTwo, String type) {\n          \n          \n            \n                private boolean checkNulls(Object objectOne, Object objectTwo, String type) {", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379609772", "createdAt": "2020-02-14T19:38:15Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+            InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest);\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            //report errors and exit 1 if any are detected.\n+            if (!errors.isEmpty()) {\n+                for (String error : errors) {\n+                    log.error(error);\n+                }\n+                return 1;\n+            }\n+        } catch (IOException | IllegalAccessException | InvocationTargetException e) {\n+            throw new PicardException(\"File error: \", e);\n+        }\n+        return 0;\n+    }\n+\n+    private void compareGTCFiles(InfiniumGTCFile gtcFileOne, InfiniumGTCFile gtcFileTwo) throws InvocationTargetException, IllegalAccessException {\n+        //compare all fields we expect won't change.\n+        Method[] methods = gtcFileOne.getClass().getMethods();\n+        for (Method method : methods) {\n+            //skip ignored methods.\n+            if (IGNORED_METHODS.contains(method.getName())) {\n+                continue;\n+            }\n+            //compare all getters\n+            if (method.getName().startsWith(\"get\") && method.getGenericParameterTypes().length == 0) {\n+                //if we have a version and they don't match we just want a warning\n+                //if getter returns an array compare all array values otherwise do an Object compare.\n+                //if getter returns an array of arrays do deep compare\n+                if (method.getName().equals(\"getFileVersion\")) {\n+                    compareVersions(method.invoke(gtcFileOne), method.invoke(gtcFileTwo));\n+                } else if (method.getReturnType().isArray() && method.getReturnType().getComponentType().isArray()) {\n+                    compareArrayOfArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else if (method.getReturnType().isArray()) {\n+                    compareArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else {\n+                    compare(method.invoke(gtcFileOne),\n+                            method.invoke(gtcFileTwo), method.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void compareVersions(Object versionOne, Object versionTwo) {\n+        if (!versionOne.equals(versionTwo)) {\n+            log.warn(String.format(\"File versions do not match ( %s vs %s )\",\n+                    versionOne, versionTwo));\n+        }\n+    }\n+\n+    private void compare(Object objectOne, Object objectTwo, String type) {\n+        if (checkNulls(objectOne, objectTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (!objectOne.equals(objectTwo)) {\n+            compareErrors.add(String.format(\"%s does not match ( %s vs %s )\",\n+                    type, objectOne, objectTwo));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void compareArrays(Object arrayOne, Object arrayTwo, String type) {\n+        if (checkNulls(arrayOne, arrayTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+        int differences = arrayDifferences(arrayOne, arrayTwo, type, compareErrors);\n+        if (differences > 0) {\n+            compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private int arrayDifferences(Object arrayOne, Object arrayTwo, String type, List<String> compareErrors) {\n+        int length1 = Array.getLength(arrayOne);\n+        int length2 = Array.getLength(arrayTwo);\n+\n+        int diffCount = 0;\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            for (int i = 0; i < length1; i++) {\n+                //for floats only compare 3 decimal places\n+                if (arrayOne.getClass().getComponentType() == float.class) {\n+                    Float float1 = (float) Array.get(arrayOne, i);\n+                    Float float2 = (float) Array.get(arrayTwo, i);\n+                    if (float1.equals(Float.NaN) || float2.equals(Float.NaN)) {\n+                        if (!float1.equals(float2)) diffCount++;\n+                    } else {\n+                        BigDecimal decimal1 = BigDecimal.valueOf(float1).setScale(3, BigDecimal.ROUND_DOWN);\n+                        BigDecimal decimal2 = BigDecimal.valueOf(float2).setScale(3, BigDecimal.ROUND_DOWN);\n+                        if (!decimal1.equals(decimal2)) {\n+                            diffCount++;\n+                        }\n+                    }\n+                } else if (!Array.get(arrayOne, i).equals(Array.get(arrayTwo, i))) {\n+                    diffCount++;\n+                }\n+            }\n+        }\n+        return diffCount;\n+    }\n+\n+\n+    private void compareArrayOfArrays(Object arrayOfArraysOne, Object arrayOfArraysTwo, String type) {\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (checkNulls(arrayOfArraysOne, arrayOfArraysTwo, type)) return;\n+\n+        int differences = 0;\n+        int length1 = Array.getLength(arrayOfArraysOne);\n+        int length2 = Array.getLength(arrayOfArraysTwo);\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            //iterate over the first array\n+            for (int i = 0; i < length1; i++) {\n+                //iterate over the second array\n+                Object innerArrayOne = Array.get(arrayOfArraysOne, i);\n+                Object innerArrayTwo = Array.get(arrayOfArraysTwo, i);\n+                differences += arrayDifferences(innerArrayOne, innerArrayTwo, type, compareErrors);\n+            }\n+            if (differences > 0) {\n+                compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+            }\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void checkErrors(String type, List<String> compareErrors) {\n+        if (compareErrors.size() > 0) {\n+            errors.addAll(compareErrors);\n+        } else {\n+            log.info(type + \" IDENTICAL\");\n+        }\n+    }\n+\n+    private boolean checkNulls(Object arrayOne, Object arrayTwo, String type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxMDgzMQ==", "bodyText": "This logic is incorrect. If both are null, a warning will be reported. Unless  you want this to fail if both are null, in that case the error message is ingorrect.", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379610831", "createdAt": "2020-02-14T19:40:40Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+            InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest);\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            //report errors and exit 1 if any are detected.\n+            if (!errors.isEmpty()) {\n+                for (String error : errors) {\n+                    log.error(error);\n+                }\n+                return 1;\n+            }\n+        } catch (IOException | IllegalAccessException | InvocationTargetException e) {\n+            throw new PicardException(\"File error: \", e);\n+        }\n+        return 0;\n+    }\n+\n+    private void compareGTCFiles(InfiniumGTCFile gtcFileOne, InfiniumGTCFile gtcFileTwo) throws InvocationTargetException, IllegalAccessException {\n+        //compare all fields we expect won't change.\n+        Method[] methods = gtcFileOne.getClass().getMethods();\n+        for (Method method : methods) {\n+            //skip ignored methods.\n+            if (IGNORED_METHODS.contains(method.getName())) {\n+                continue;\n+            }\n+            //compare all getters\n+            if (method.getName().startsWith(\"get\") && method.getGenericParameterTypes().length == 0) {\n+                //if we have a version and they don't match we just want a warning\n+                //if getter returns an array compare all array values otherwise do an Object compare.\n+                //if getter returns an array of arrays do deep compare\n+                if (method.getName().equals(\"getFileVersion\")) {\n+                    compareVersions(method.invoke(gtcFileOne), method.invoke(gtcFileTwo));\n+                } else if (method.getReturnType().isArray() && method.getReturnType().getComponentType().isArray()) {\n+                    compareArrayOfArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else if (method.getReturnType().isArray()) {\n+                    compareArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else {\n+                    compare(method.invoke(gtcFileOne),\n+                            method.invoke(gtcFileTwo), method.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void compareVersions(Object versionOne, Object versionTwo) {\n+        if (!versionOne.equals(versionTwo)) {\n+            log.warn(String.format(\"File versions do not match ( %s vs %s )\",\n+                    versionOne, versionTwo));\n+        }\n+    }\n+\n+    private void compare(Object objectOne, Object objectTwo, String type) {\n+        if (checkNulls(objectOne, objectTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (!objectOne.equals(objectTwo)) {\n+            compareErrors.add(String.format(\"%s does not match ( %s vs %s )\",\n+                    type, objectOne, objectTwo));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void compareArrays(Object arrayOne, Object arrayTwo, String type) {\n+        if (checkNulls(arrayOne, arrayTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+        int differences = arrayDifferences(arrayOne, arrayTwo, type, compareErrors);\n+        if (differences > 0) {\n+            compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private int arrayDifferences(Object arrayOne, Object arrayTwo, String type, List<String> compareErrors) {\n+        int length1 = Array.getLength(arrayOne);\n+        int length2 = Array.getLength(arrayTwo);\n+\n+        int diffCount = 0;\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            for (int i = 0; i < length1; i++) {\n+                //for floats only compare 3 decimal places\n+                if (arrayOne.getClass().getComponentType() == float.class) {\n+                    Float float1 = (float) Array.get(arrayOne, i);\n+                    Float float2 = (float) Array.get(arrayTwo, i);\n+                    if (float1.equals(Float.NaN) || float2.equals(Float.NaN)) {\n+                        if (!float1.equals(float2)) diffCount++;\n+                    } else {\n+                        BigDecimal decimal1 = BigDecimal.valueOf(float1).setScale(3, BigDecimal.ROUND_DOWN);\n+                        BigDecimal decimal2 = BigDecimal.valueOf(float2).setScale(3, BigDecimal.ROUND_DOWN);\n+                        if (!decimal1.equals(decimal2)) {\n+                            diffCount++;\n+                        }\n+                    }\n+                } else if (!Array.get(arrayOne, i).equals(Array.get(arrayTwo, i))) {\n+                    diffCount++;\n+                }\n+            }\n+        }\n+        return diffCount;\n+    }\n+\n+\n+    private void compareArrayOfArrays(Object arrayOfArraysOne, Object arrayOfArraysTwo, String type) {\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (checkNulls(arrayOfArraysOne, arrayOfArraysTwo, type)) return;\n+\n+        int differences = 0;\n+        int length1 = Array.getLength(arrayOfArraysOne);\n+        int length2 = Array.getLength(arrayOfArraysTwo);\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            //iterate over the first array\n+            for (int i = 0; i < length1; i++) {\n+                //iterate over the second array\n+                Object innerArrayOne = Array.get(arrayOfArraysOne, i);\n+                Object innerArrayTwo = Array.get(arrayOfArraysTwo, i);\n+                differences += arrayDifferences(innerArrayOne, innerArrayTwo, type, compareErrors);\n+            }\n+            if (differences > 0) {\n+                compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+            }\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void checkErrors(String type, List<String> compareErrors) {\n+        if (compareErrors.size() > 0) {\n+            errors.addAll(compareErrors);\n+        } else {\n+            log.info(type + \" IDENTICAL\");\n+        }\n+    }\n+\n+    private boolean checkNulls(Object arrayOne, Object arrayTwo, String type) {\n+        //if one is null we assume a version mismatch\n+        if (arrayOne == null || arrayTwo == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxMTMxMA==", "bodyText": "Is the error here a version mismatch or some other kind of error?", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379611310", "createdAt": "2020-02-14T19:41:47Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+            InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest);\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            //report errors and exit 1 if any are detected.\n+            if (!errors.isEmpty()) {\n+                for (String error : errors) {\n+                    log.error(error);\n+                }\n+                return 1;\n+            }\n+        } catch (IOException | IllegalAccessException | InvocationTargetException e) {\n+            throw new PicardException(\"File error: \", e);\n+        }\n+        return 0;\n+    }\n+\n+    private void compareGTCFiles(InfiniumGTCFile gtcFileOne, InfiniumGTCFile gtcFileTwo) throws InvocationTargetException, IllegalAccessException {\n+        //compare all fields we expect won't change.\n+        Method[] methods = gtcFileOne.getClass().getMethods();\n+        for (Method method : methods) {\n+            //skip ignored methods.\n+            if (IGNORED_METHODS.contains(method.getName())) {\n+                continue;\n+            }\n+            //compare all getters\n+            if (method.getName().startsWith(\"get\") && method.getGenericParameterTypes().length == 0) {\n+                //if we have a version and they don't match we just want a warning\n+                //if getter returns an array compare all array values otherwise do an Object compare.\n+                //if getter returns an array of arrays do deep compare\n+                if (method.getName().equals(\"getFileVersion\")) {\n+                    compareVersions(method.invoke(gtcFileOne), method.invoke(gtcFileTwo));\n+                } else if (method.getReturnType().isArray() && method.getReturnType().getComponentType().isArray()) {\n+                    compareArrayOfArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else if (method.getReturnType().isArray()) {\n+                    compareArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else {\n+                    compare(method.invoke(gtcFileOne),\n+                            method.invoke(gtcFileTwo), method.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void compareVersions(Object versionOne, Object versionTwo) {\n+        if (!versionOne.equals(versionTwo)) {\n+            log.warn(String.format(\"File versions do not match ( %s vs %s )\",\n+                    versionOne, versionTwo));\n+        }\n+    }\n+\n+    private void compare(Object objectOne, Object objectTwo, String type) {\n+        if (checkNulls(objectOne, objectTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (!objectOne.equals(objectTwo)) {\n+            compareErrors.add(String.format(\"%s does not match ( %s vs %s )\",\n+                    type, objectOne, objectTwo));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void compareArrays(Object arrayOne, Object arrayTwo, String type) {\n+        if (checkNulls(arrayOne, arrayTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+        int differences = arrayDifferences(arrayOne, arrayTwo, type, compareErrors);\n+        if (differences > 0) {\n+            compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private int arrayDifferences(Object arrayOne, Object arrayTwo, String type, List<String> compareErrors) {\n+        int length1 = Array.getLength(arrayOne);\n+        int length2 = Array.getLength(arrayTwo);\n+\n+        int diffCount = 0;\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            for (int i = 0; i < length1; i++) {\n+                //for floats only compare 3 decimal places\n+                if (arrayOne.getClass().getComponentType() == float.class) {\n+                    Float float1 = (float) Array.get(arrayOne, i);\n+                    Float float2 = (float) Array.get(arrayTwo, i);\n+                    if (float1.equals(Float.NaN) || float2.equals(Float.NaN)) {\n+                        if (!float1.equals(float2)) diffCount++;\n+                    } else {\n+                        BigDecimal decimal1 = BigDecimal.valueOf(float1).setScale(3, BigDecimal.ROUND_DOWN);\n+                        BigDecimal decimal2 = BigDecimal.valueOf(float2).setScale(3, BigDecimal.ROUND_DOWN);\n+                        if (!decimal1.equals(decimal2)) {\n+                            diffCount++;\n+                        }\n+                    }\n+                } else if (!Array.get(arrayOne, i).equals(Array.get(arrayTwo, i))) {\n+                    diffCount++;\n+                }\n+            }\n+        }\n+        return diffCount;\n+    }\n+\n+\n+    private void compareArrayOfArrays(Object arrayOfArraysOne, Object arrayOfArraysTwo, String type) {\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (checkNulls(arrayOfArraysOne, arrayOfArraysTwo, type)) return;\n+\n+        int differences = 0;\n+        int length1 = Array.getLength(arrayOfArraysOne);\n+        int length2 = Array.getLength(arrayOfArraysTwo);\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            //iterate over the first array\n+            for (int i = 0; i < length1; i++) {\n+                //iterate over the second array\n+                Object innerArrayOne = Array.get(arrayOfArraysOne, i);\n+                Object innerArrayTwo = Array.get(arrayOfArraysTwo, i);\n+                differences += arrayDifferences(innerArrayOne, innerArrayTwo, type, compareErrors);\n+            }\n+            if (differences > 0) {\n+                compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+            }\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void checkErrors(String type, List<String> compareErrors) {\n+        if (compareErrors.size() > 0) {\n+            errors.addAll(compareErrors);\n+        } else {\n+            log.info(type + \" IDENTICAL\");\n+        }\n+    }\n+\n+    private boolean checkNulls(Object arrayOne, Object arrayTwo, String type) {\n+        //if one is null we assume a version mismatch\n+        if (arrayOne == null || arrayTwo == null) {\n+            log.warn(String.format(\"Field %s is not in both files. Version mismatch likely\", type));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e"}, "originalPosition": 225}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMzkzMTc3", "url": "https://github.com/broadinstitute/picard/pull/1468#pullrequestreview-360393177", "createdAt": "2020-02-18T14:43:07Z", "commit": {"oid": "775db8d525bbcb86bf20e37ed5d626e3f9f95f5d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "775db8d525bbcb86bf20e37ed5d626e3f9f95f5d", "author": {"user": {"login": "gbggrant", "name": "George Grant"}}, "url": "https://github.com/broadinstitute/picard/commit/775db8d525bbcb86bf20e37ed5d626e3f9f95f5d", "committedDate": "2020-02-14T20:26:43Z", "message": "Code review responses."}, "afterCommit": {"oid": "1bb9eec9852bbe98cd39680cc35f933b7216ff61", "author": {"user": {"login": "gbggrant", "name": "George Grant"}}, "url": "https://github.com/broadinstitute/picard/commit/1bb9eec9852bbe98cd39680cc35f933b7216ff61", "committedDate": "2020-03-04T21:01:00Z", "message": "Code review responses."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzE5Mzcw", "url": "https://github.com/broadinstitute/picard/pull/1468#pullrequestreview-371319370", "createdAt": "2020-03-09T16:08:46Z", "commit": {"oid": "9ab43c2f7118f8adb05fabb1a662457dcc5f73ce"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowODo0NlrOFzvJrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowODo0NlrOFzvJrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NDIyMQ==", "bodyText": "I thought that NaN didn't equal itself but apparently in Java it does?", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r389794221", "createdAt": "2020-03-09T16:08:46Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static final Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private final List<String> errors = new ArrayList<>();\n+\n+    // Ignored methods\n+    private static final List<String> IGNORED_METHODS = Arrays.asList(\n+        \"getClass\",\n+        \"getAutocallDate\",\n+        \"getImagingDate\",\n+        // This is the number of TOC entries. It will be different with different versions.\n+        \"getNumberOfEntries\",\n+        // We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        \"getSampleName\",\n+        \"getSamplePlate\",\n+        \"getSampleWell\");\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        InfiniumNormalizationManifest infiniumNormalizationManifest = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+        try (InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+             InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest)) {\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            // Report errors and exit 1 if any are detected.\n+            if (!errors.isEmpty()) {\n+                for (String error : errors) {\n+                    log.error(error);\n+                }\n+                return 1;\n+            }\n+        } catch (Exception e) {\n+            throw new PicardException(\"File error: \", e);\n+        }\n+        return 0;\n+    }\n+\n+    private void compareGTCFiles(InfiniumGTCFile gtcFileOne, InfiniumGTCFile gtcFileTwo) throws InvocationTargetException, IllegalAccessException {\n+        // Compare all fields we expect won't change.\n+        Method[] methods = gtcFileOne.getClass().getMethods();\n+        for (Method method : methods) {\n+            // Skip ignored methods.\n+            if (IGNORED_METHODS.contains(method.getName())) {\n+                continue;\n+            }\n+            // Compare all getters\n+            if (method.getName().startsWith(\"get\") && method.getGenericParameterTypes().length == 0) {\n+                // If we have a version and they don't match we just want a warning\n+                // If getter returns an array compare all array values otherwise do an Object compare.\n+                // If getter returns an array of arrays do deep compare\n+                if (method.getName().equals(\"getFileVersion\")) {\n+                    compareVersions(method.invoke(gtcFileOne), method.invoke(gtcFileTwo));\n+                } else if (method.getReturnType().isArray() && method.getReturnType().getComponentType().isArray()) {\n+                    compareArrayOfArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else if (method.getReturnType().isArray()) {\n+                    compareArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else {\n+                    compare(method.invoke(gtcFileOne),\n+                            method.invoke(gtcFileTwo), method.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void compareVersions(Object versionOne, Object versionTwo) {\n+        if (!versionOne.equals(versionTwo)) {\n+            log.warn(String.format(\"File versions do not match ( %s vs %s )\",\n+                    versionOne, versionTwo));\n+        }\n+    }\n+\n+    private void compare(Object objectOne, Object objectTwo, String methodName) {\n+        if (checkNulls(objectOne, objectTwo, methodName)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (!objectOne.equals(objectTwo)) {\n+            compareErrors.add(String.format(\"%s does not match ( %s vs %s )\",\n+                    methodName, objectOne, objectTwo));\n+        }\n+        checkErrors(methodName, compareErrors);\n+    }\n+\n+    private void compareArrays(Object arrayOne, Object arrayTwo, String methodName) {\n+        if (checkNulls(arrayOne, arrayTwo, methodName)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+        int differences = arrayDifferences(arrayOne, arrayTwo, methodName, compareErrors);\n+        if (differences > 0) {\n+            compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", methodName, differences));\n+        }\n+        checkErrors(methodName, compareErrors);\n+    }\n+\n+    private int arrayDifferences(Object arrayOne, Object arrayTwo, String methodName, List<String> compareErrors) {\n+        int length1 = Array.getLength(arrayOne);\n+        int length2 = Array.getLength(arrayTwo);\n+\n+        int diffCount = 0;\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    methodName, length1, length2));\n+        } else {\n+            for (int i = 0; i < length1; i++) {\n+                // For floats only compare 3 decimal places\n+                if (arrayOne.getClass().getComponentType() == float.class) {\n+                    Float float1 = (float) Array.get(arrayOne, i);\n+                    Float float2 = (float) Array.get(arrayTwo, i);\n+                    if (float1.equals(Float.NaN) || float2.equals(Float.NaN)) {\n+                        if (!float1.equals(float2)) diffCount++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ab43c2f7118f8adb05fabb1a662457dcc5f73ce"}, "originalPosition": 166}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c30afc8b8a40323bcb71fe0d989bfc033bd6b9a5", "author": {"user": {"login": "gbggrant", "name": "George Grant"}}, "url": "https://github.com/broadinstitute/picard/commit/c30afc8b8a40323bcb71fe0d989bfc033bd6b9a5", "committedDate": "2020-03-16T18:21:59Z", "message": "Ported CompareGtcFiles from Picard private repo\nMade some classes implement AutoCloseable"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ab43c2f7118f8adb05fabb1a662457dcc5f73ce", "author": {"user": {"login": "gbggrant", "name": "George Grant"}}, "url": "https://github.com/broadinstitute/picard/commit/9ab43c2f7118f8adb05fabb1a662457dcc5f73ce", "committedDate": "2020-03-06T13:27:23Z", "message": "Restore visibility of a method to fix a test."}, "afterCommit": {"oid": "c30afc8b8a40323bcb71fe0d989bfc033bd6b9a5", "author": {"user": {"login": "gbggrant", "name": "George Grant"}}, "url": "https://github.com/broadinstitute/picard/commit/c30afc8b8a40323bcb71fe0d989bfc033bd6b9a5", "committedDate": "2020-03-16T18:21:59Z", "message": "Ported CompareGtcFiles from Picard private repo\nMade some classes implement AutoCloseable"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2393, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}