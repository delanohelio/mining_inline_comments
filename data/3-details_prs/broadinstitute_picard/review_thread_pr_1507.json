{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2Mzk2NTIw", "number": 1507, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTowOTozMlrOD8M2Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo0OToyOVrOEIhicg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDUxNTg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTowOTozMlrOGU_wtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTowOTozMlrOGU_wtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2OTM2Nw==", "bodyText": "can be final\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static private int NUM_WARNINGS = 100;\n          \n          \n            \n                private static final int NUM_WARNINGS = 100;", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424669367", "createdAt": "2020-05-13T19:09:32Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDUzNTM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNToxM1rOGU_9Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNToxM1rOGU_9Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MjUxNQ==", "bodyText": "Might be clearer to have this if block in a method, ensureSortedBam()", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424672515", "createdAt": "2020-05-13T19:15:13Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDUzNjM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNTozNVrOGU_9vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNTozNVrOGU_9vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MjcwMA==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return numBadRecords > 0 ? 1:0;\n          \n          \n            \n                        return numBadRecords > 0 ? 1 : 0;", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424672700", "createdAt": "2020-05-13T19:15:35Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDUzOTcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNjoyOVrOGU__2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNjoyOVrOGU__2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MzI0MQ==", "bodyText": "Use error not info if there are bad records, and/or only log if there's an error.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424673241", "createdAt": "2020-05-13T19:16:29Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDU0MDk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNjo1M1rOGVAAsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNjo1M1rOGVAAsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MzQ1Nw==", "bodyText": "can be static\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n          \n          \n            \n                private static final Log log = Log.getInstance(CheckDuplicateMarking.class);", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424673457", "createdAt": "2020-05-13T19:16:53Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDU0NDQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxNzo1NlrOGVAC3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo1MTo1N1rOGoislA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDAxNQ==", "bodyText": "For methods that return boolean, is is usually preferred\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean duplicateMarkingGood(final SAMRecord rec) {\n          \n          \n            \n                private boolean isDuplicateMarkingValid(final SAMRecord rec) {", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424674015", "createdAt": "2020-05-13T19:17:56Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNjE3Nw==", "bodyText": "but this method is not only a predicate...it also changes a global tally....how about checkAndTallyRecordDuplicateMarking?", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r441126177", "createdAt": "2020-06-16T20:35:39Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDAxNQ=="}, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NDY5Mg==", "bodyText": "Yes, that sounds good to me.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445164692", "createdAt": "2020-06-24T20:51:57Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDAxNQ=="}, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDU0OTc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxOTozNVrOGVAGTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxOTozNVrOGVAGTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDg5Mw==", "bodyText": "unnecessary return since this will fall through to the return at line 136", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424674893", "createdAt": "2020-05-13T19:19:35Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+            return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDU2MjgyOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToyMzozM1rOGVAOqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToyMzozM1rOGVAOqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NzAzMg==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try (PrintWriter writer =  OUTPUT==null?\n          \n          \n            \n                    try (PrintWriter writer =  OUTPUT == null ?\n          \n          \n            \n                                    new PrintWriter(NullOutputStream.NULL_OUTPUT_STREAM) :", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424677032", "createdAt": "2020-05-13T19:23:33Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+            return true;\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            numBadRecords++;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer =  OUTPUT==null?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDU4MjUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToyOTozMFrOGVAbOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0Mzo1MVrOGksd1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MDI1MQ==", "bodyText": "No case in code to handle PRIMARY_ONLY, is that supported as it's the inverse of the rest?", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424680251", "createdAt": "2020-05-13T19:29:30Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+            return true;\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            numBadRecords++;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer =  OUTPUT==null?\n+                new PrintWriter(NullOutputStream.NULL_OUTPUT_STREAM):\n+                new PrintWriter(new FileWriter(OUTPUT))) {\n+\n+            for (final SAMRecord rec : iterable) {\n+                if (MODE != Mode.ALL && rec.isSecondaryOrSupplementary()) {\n+                    continue;\n+                }\n+\n+                if (MODE == Mode.PRIMARY_MAPPED_ONLY && rec.getReadUnmappedFlag()) {\n+                    continue;\n+                }\n+\n+                if (MODE == Mode.PRIMARY_PROPER_PAIR_ONLY && !rec.getProperPairFlag()) {\n+                    continue;\n+                }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzMDQ1Mw==", "bodyText": "it's a bit confusing, but notice that the first if is if NOT EQUALS Mode.ALL", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r441130453", "createdAt": "2020-06-16T20:43:51Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+            return true;\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            numBadRecords++;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer =  OUTPUT==null?\n+                new PrintWriter(NullOutputStream.NULL_OUTPUT_STREAM):\n+                new PrintWriter(new FileWriter(OUTPUT))) {\n+\n+            for (final SAMRecord rec : iterable) {\n+                if (MODE != Mode.ALL && rec.isSecondaryOrSupplementary()) {\n+                    continue;\n+                }\n+\n+                if (MODE == Mode.PRIMARY_MAPPED_ONLY && rec.getReadUnmappedFlag()) {\n+                    continue;\n+                }\n+\n+                if (MODE == Mode.PRIMARY_PROPER_PAIR_ONLY && !rec.getProperPairFlag()) {\n+                    continue;\n+                }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MDI1MQ=="}, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDU4Njg1OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTozMDo0OVrOGVAeHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTozMDo0OVrOGVAeHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MDk5MQ==", "bodyText": "Reformat new code to follow conventions\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String TEST_FILES_DIR=\"testdata/picard/sam/CheckDuplicateMarking\";\n          \n          \n            \n                private static final String TEST_FILES_DIR = \"testdata/picard/sam/CheckDuplicateMarking\";", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424680991", "createdAt": "2020-05-13T19:30:49Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package picard.sam.markduplicates;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.CheckDuplicateMarking;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckDuplicateMarkingTest {\n+    private static final String TEST_FILES_DIR=\"testdata/picard/sam/CheckDuplicateMarking\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDU5MjAxOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/sam/markduplicates/DuplicationMetricsTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTozMjozMFrOGVAhVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDowMToxN1rOGuNl4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MTgxNQ==", "bodyText": "Is there a reason to move the test but not the class? Normally the test for a class is in the same package as the class being tested.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424681815", "createdAt": "2020-05-13T19:32:30Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/sam/markduplicates/DuplicationMetricsTest.java", "diffHunk": "@@ -22,11 +22,12 @@\n  * THE SOFTWARE.\n  */\n \n-package picard.sam;\n+package picard.sam.markduplicates;\n \n import org.testng.Assert;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n+import picard.sam.DuplicationMetrics;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNDU4NQ==", "bodyText": "oops", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r441134585", "createdAt": "2020-06-16T20:51:50Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/markduplicates/DuplicationMetricsTest.java", "diffHunk": "@@ -22,11 +22,12 @@\n  * THE SOFTWARE.\n  */\n \n-package picard.sam;\n+package picard.sam.markduplicates;\n \n import org.testng.Assert;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n+import picard.sam.DuplicationMetrics;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MTgxNQ=="}, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzOTY2Mw==", "bodyText": "Does that mean you will move it back? It looks like this wasn't addressed.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445139663", "createdAt": "2020-06-24T20:03:13Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/sam/markduplicates/DuplicationMetricsTest.java", "diffHunk": "@@ -22,11 +22,12 @@\n  * THE SOFTWARE.\n  */\n \n-package picard.sam;\n+package picard.sam.markduplicates;\n \n import org.testng.Assert;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n+import picard.sam.DuplicationMetrics;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MTgxNQ=="}, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMDM2OA==", "bodyText": "yeah. not sure what happened there...sorry.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451110368", "createdAt": "2020-07-07T20:01:17Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/markduplicates/DuplicationMetricsTest.java", "diffHunk": "@@ -22,11 +22,12 @@\n  * THE SOFTWARE.\n  */\n \n-package picard.sam;\n+package picard.sam.markduplicates;\n \n import org.testng.Assert;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n+import picard.sam.DuplicationMetrics;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MTgxNQ=="}, "originalCommit": {"oid": "90160ba81d12d2e288cb3315197973258b0a3a8e"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzQ2MzE4OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOToyNDo1N1rOGof9Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOToyNDo1N1rOGof9Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExOTc5OQ==", "bodyText": "toString() unnecessary\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String[] args = {\"I=\" + input.toString()};\n          \n          \n            \n                    final String[] args = {\"I=\" + input};", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445119799", "createdAt": "2020-06-24T19:24:57Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package picard.sam.markduplicates;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckDuplicateMarkingTest {\n+    private static final String TEST_FILES_DIR = \"testdata/picard/sam/CheckDuplicateMarking\";\n+\n+    @DataProvider(name = \"checkDuplicateMarkingDataProvider\")\n+    public Object[][] checkDuplicateMarkingDataProvider() {\n+        return new Object[][]{\n+                {Paths.get(TEST_FILES_DIR, \"pass_queryname.sam\"), 0},\n+                {Paths.get(TEST_FILES_DIR, \"pass_coordinate.sam\"), 0},\n+                {Paths.get(TEST_FILES_DIR, \"fail_mate_queryname.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_mate_coordinate.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_queryname_1.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_coordinate_1.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_queryname_2.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_coordinate_2.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_secondary_queryname.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_secondary_coordinate.sam\"), 1},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"checkDuplicateMarkingDataProvider\")\n+    public void testCheckDuplicateMarking(final Path input, int expectedReturn) {\n+        final CheckDuplicateMarking cmdLine = new CheckDuplicateMarking();\n+        final String[] args = {\"I=\" + input.toString()};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzU4MDczOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDowMDo0MFrOGohFgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDowMDo0MFrOGohFgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzODMwNw==", "bodyText": "it's a minor thing but you can avoid the duplication here by changing this to\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            {Paths.get(TEST_FILES_DIR, \"pass_queryname.sam\"), 0},\n          \n          \n            \n                            {\"pass_queryname.sam\", 0},\n          \n      \n    \n    \n  \n\nAnd use Paths.get(TEST_FILES_DIR, input) below.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445138307", "createdAt": "2020-06-24T20:00:40Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package picard.sam.markduplicates;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckDuplicateMarkingTest {\n+    private static final String TEST_FILES_DIR = \"testdata/picard/sam/CheckDuplicateMarking\";\n+\n+    @DataProvider(name = \"checkDuplicateMarkingDataProvider\")\n+    public Object[][] checkDuplicateMarkingDataProvider() {\n+        return new Object[][]{\n+                {Paths.get(TEST_FILES_DIR, \"pass_queryname.sam\"), 0},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzcxMTI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo0MjowM1rOGoiYMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDowODowOVrOGuNy4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1OTQ3Mg==", "bodyText": "If this is done in more than one CLP, it would make sense to move it to CommandLineProgram.\n(Also, it is odd that File is deprecated in SortingCollection but not in SortingLongCollection)", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445159472", "createdAt": "2020-06-24T20:42:03Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMTI0Mw==", "bodyText": "it's done in only two other CLPs....somehow.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451111243", "createdAt": "2020-07-07T20:03:04Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1OTQ3Mg=="}, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMzEzOA==", "bodyText": "hmmm. most CLPs use system property \"java.io.tmpdir\" but I chose to use input variable TMP_DIR...not sure which is right.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451113138", "createdAt": "2020-07-07T20:06:55Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1OTQ3Mg=="}, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMzY5OQ==", "bodyText": "oh...it's the same. I'll use the other.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451113699", "createdAt": "2020-07-07T20:08:09Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1OTQ3Mg=="}, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzcxODkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo0NDoxNlrOGoic2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDoxMDo1MVrOGuN4SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MDY2Nw==", "bodyText": "Is it common to create a sorting collection and not call cleanup() on it?", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445160667", "createdAt": "2020-06-24T20:44:16Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()\n+                .map(File::toPath)\n+                .toArray(Path[]::new);\n+\n+        final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+        final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExNTA4MA==", "bodyText": "done.", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451115080", "createdAt": "2020-07-07T20:10:51Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()\n+                .map(File::toPath)\n+                .toArray(Path[]::new);\n+\n+        final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+        final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MDY2Nw=="}, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzczNTU0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDo0OToyOVrOGoinYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDoxMzo1MVrOGuN9vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzM2MA==", "bodyText": "could put ternary op inside constructor\n        try (PrintWriter writer = new PrintWriter(OUTPUT != null ? new FileWriter(OUTPUT) : NullOutputStream.NULL_OUTPUT_STREAM)) {", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445163360", "createdAt": "2020-06-24T20:49:29Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()\n+                .map(File::toPath)\n+                .toArray(Path[]::new);\n+\n+        final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+        final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                new BAMRecordCodec(reader.getFileHeader()),\n+                new SAMRecordQueryNameComparator(),\n+                MAX_RECORDS_IN_RAM,\n+                tmpPaths);\n+\n+        for (final SAMRecord rec : reader) {\n+            alignmentSorter.add(rec);\n+            sortProgress.record(rec);\n+        }\n+        return alignmentSorter;\n+    }\n+\n+    private boolean checkAndTallyRecordDuplicateMarking(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            // this case the queryname changed, and thus there's no comparison to make\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            // Here the current queryname is the same, but the duplicate flag doesn't match the first record with that queryname\n+            numBadRecords++;\n+\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer = OUTPUT == null ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExNTkxMg==", "bodyText": "no...it's a different constructor..", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451115912", "createdAt": "2020-07-07T20:12:37Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()\n+                .map(File::toPath)\n+                .toArray(Path[]::new);\n+\n+        final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+        final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                new BAMRecordCodec(reader.getFileHeader()),\n+                new SAMRecordQueryNameComparator(),\n+                MAX_RECORDS_IN_RAM,\n+                tmpPaths);\n+\n+        for (final SAMRecord rec : reader) {\n+            alignmentSorter.add(rec);\n+            sortProgress.record(rec);\n+        }\n+        return alignmentSorter;\n+    }\n+\n+    private boolean checkAndTallyRecordDuplicateMarking(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            // this case the queryname changed, and thus there's no comparison to make\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            // Here the current queryname is the same, but the duplicate flag doesn't match the first record with that queryname\n+            numBadRecords++;\n+\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer = OUTPUT == null ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzM2MA=="}, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExNjQ3OQ==", "bodyText": "PrintWriter(Writer) vs.  PrintWriter(OutputStream)", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451116479", "createdAt": "2020-07-07T20:13:51Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()\n+                .map(File::toPath)\n+                .toArray(Path[]::new);\n+\n+        final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+        final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                new BAMRecordCodec(reader.getFileHeader()),\n+                new SAMRecordQueryNameComparator(),\n+                MAX_RECORDS_IN_RAM,\n+                tmpPaths);\n+\n+        for (final SAMRecord rec : reader) {\n+            alignmentSorter.add(rec);\n+            sortProgress.record(rec);\n+        }\n+        return alignmentSorter;\n+    }\n+\n+    private boolean checkAndTallyRecordDuplicateMarking(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            // this case the queryname changed, and thus there's no comparison to make\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            // Here the current queryname is the same, but the duplicate flag doesn't match the first record with that queryname\n+            numBadRecords++;\n+\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer = OUTPUT == null ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzM2MA=="}, "originalCommit": {"oid": "01b6be605398de1ce68034bd312e068bfb9111e4"}, "originalPosition": 148}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 755, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}