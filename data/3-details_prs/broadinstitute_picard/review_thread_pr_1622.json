{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1MDA4MDcw", "number": 1622, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxODoyMjowNFrOFRAclg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0wNFQxNzo0MToyMlrOGeWWMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzMzc3NDMwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CleanSam.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxODoyMjowNFrOIXLoOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xN1QxODo0OTo1M1rOI4rCBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE3ODY4Mg==", "bodyText": "What's so special about 2016 here?  Why not through 2021?", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r561178682", "createdAt": "2021-01-20T18:22:04Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/sam/CleanSam.java", "diffHunk": "@@ -1,7 +1,7 @@\n /*\n  * The MIT License\n  *\n- * Copyright (c) 2010 The Broad Institute\n+ * Copyright (c) 2010 - 2016 The Broad Institute", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d75a90ccdf0fc03ebe967d890c6eced2cf5018ad"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjI5NjE5Nw==", "bodyText": "goes to show when the code was written...I guess.", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r596296197", "createdAt": "2021-03-17T18:49:53Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/sam/CleanSam.java", "diffHunk": "@@ -1,7 +1,7 @@\n /*\n  * The MIT License\n  *\n- * Copyright (c) 2010 The Broad Institute\n+ * Copyright (c) 2010 - 2016 The Broad Institute", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE3ODY4Mg=="}, "originalCommit": {"oid": "d75a90ccdf0fc03ebe967d890c6eced2cf5018ad"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyOTM2OTI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fastq/SamToBfqWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODowNzoxNVrOJByMEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yN1QyMTo0NjoxOFrOJjTAlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1MDY0MA==", "bodyText": "Should this be File samFile? (and elsewhere)", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r605850640", "createdAt": "2021-04-01T18:07:15Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/fastq/SamToBfqWriter.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2009 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package picard.fastq;\n+\n+import htsjdk.samtools.ReservedTagConstants;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.filter.AggregateFilter;\n+import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\n+import htsjdk.samtools.filter.FilteringSamIterator;\n+import htsjdk.samtools.filter.SamRecordFilter;\n+import htsjdk.samtools.filter.TagFilter;\n+import htsjdk.samtools.filter.WholeReadClippedFilter;\n+import htsjdk.samtools.util.BinaryCodec;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.PeekableIterator;\n+import htsjdk.utils.ValidationUtils;\n+import picard.PicardException;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Class to take unmapped reads in SAM/BAM/CRAM file format and create Maq binary fastq format file(s) --\n+ * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\n+ * file having all paired reads together in order.\n+ */\n+public class SamToBfqWriter {\n+\n+    private static final int SEED_REGION_LENGTH = 28;\n+    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\n+\n+    private final File bamFile;\n+    private final String outputPrefix;\n+    private final String namePrefix;\n+    private final int nameTrim;\n+    private final File referenceSequence;\n+    private final boolean pairedReads;\n+    private int wrote = 0;\n+    private int increment = 1;\n+    private int chunk = 0;\n+    private BinaryCodec codec1;\n+    private BinaryCodec codec2;\n+    private final Log log = Log.getInstance(SamToBfqWriter.class);\n+    private final boolean includeNonPfReads;\n+    private final boolean clipAdapters;\n+    private final Integer basesToWrite;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile        the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param total          the total number of records that should be written, drawn evenly\n+     *                       from throughout the file (null for all).\n+     * @param chunk          the maximum number of records that should be written to any one file\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     The string to be stripped off the read name\n+     *                       before writing to the bfq file. May be null, in which case\n+     *                       the name will not be trimmed.\n+     * @param includeNonPfReads whether to include non pf-reads\n+     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\n+     */\n+    public SamToBfqWriter(final File bamFile, final File referenceSequence, final String outputPrefix, final Integer total,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDk5MTM4Mw==", "bodyText": "sure. elsewhere, in this file? or elsewhere in other files?", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r640991383", "createdAt": "2021-05-27T21:46:18Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fastq/SamToBfqWriter.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2009 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package picard.fastq;\n+\n+import htsjdk.samtools.ReservedTagConstants;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.filter.AggregateFilter;\n+import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\n+import htsjdk.samtools.filter.FilteringSamIterator;\n+import htsjdk.samtools.filter.SamRecordFilter;\n+import htsjdk.samtools.filter.TagFilter;\n+import htsjdk.samtools.filter.WholeReadClippedFilter;\n+import htsjdk.samtools.util.BinaryCodec;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.PeekableIterator;\n+import htsjdk.utils.ValidationUtils;\n+import picard.PicardException;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Class to take unmapped reads in SAM/BAM/CRAM file format and create Maq binary fastq format file(s) --\n+ * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\n+ * file having all paired reads together in order.\n+ */\n+public class SamToBfqWriter {\n+\n+    private static final int SEED_REGION_LENGTH = 28;\n+    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\n+\n+    private final File bamFile;\n+    private final String outputPrefix;\n+    private final String namePrefix;\n+    private final int nameTrim;\n+    private final File referenceSequence;\n+    private final boolean pairedReads;\n+    private int wrote = 0;\n+    private int increment = 1;\n+    private int chunk = 0;\n+    private BinaryCodec codec1;\n+    private BinaryCodec codec2;\n+    private final Log log = Log.getInstance(SamToBfqWriter.class);\n+    private final boolean includeNonPfReads;\n+    private final boolean clipAdapters;\n+    private final Integer basesToWrite;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile        the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param total          the total number of records that should be written, drawn evenly\n+     *                       from throughout the file (null for all).\n+     * @param chunk          the maximum number of records that should be written to any one file\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     The string to be stripped off the read name\n+     *                       before writing to the bfq file. May be null, in which case\n+     *                       the name will not be trimmed.\n+     * @param includeNonPfReads whether to include non pf-reads\n+     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\n+     */\n+    public SamToBfqWriter(final File bamFile, final File referenceSequence, final String outputPrefix, final Integer total,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1MDY0MA=="}, "originalCommit": {"oid": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyOTM4MTYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fastq/SamToBfqWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODoxMDo0NVrOJByTrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODoxMDo0NVrOJByTrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1MjU4OA==", "bodyText": "??\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Closes any the open bfq file(s), if any, and opens the new one(s)\n          \n          \n            \n                 * Closes any open bfq file(s), and opens the new one(s)", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r605852588", "createdAt": "2021-04-01T18:10:45Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/fastq/SamToBfqWriter.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2009 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package picard.fastq;\n+\n+import htsjdk.samtools.ReservedTagConstants;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.filter.AggregateFilter;\n+import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\n+import htsjdk.samtools.filter.FilteringSamIterator;\n+import htsjdk.samtools.filter.SamRecordFilter;\n+import htsjdk.samtools.filter.TagFilter;\n+import htsjdk.samtools.filter.WholeReadClippedFilter;\n+import htsjdk.samtools.util.BinaryCodec;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.PeekableIterator;\n+import htsjdk.utils.ValidationUtils;\n+import picard.PicardException;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Class to take unmapped reads in SAM/BAM/CRAM file format and create Maq binary fastq format file(s) --\n+ * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\n+ * file having all paired reads together in order.\n+ */\n+public class SamToBfqWriter {\n+\n+    private static final int SEED_REGION_LENGTH = 28;\n+    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\n+\n+    private final File bamFile;\n+    private final String outputPrefix;\n+    private final String namePrefix;\n+    private final int nameTrim;\n+    private final File referenceSequence;\n+    private final boolean pairedReads;\n+    private int wrote = 0;\n+    private int increment = 1;\n+    private int chunk = 0;\n+    private BinaryCodec codec1;\n+    private BinaryCodec codec2;\n+    private final Log log = Log.getInstance(SamToBfqWriter.class);\n+    private final boolean includeNonPfReads;\n+    private final boolean clipAdapters;\n+    private final Integer basesToWrite;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile        the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param total          the total number of records that should be written, drawn evenly\n+     *                       from throughout the file (null for all).\n+     * @param chunk          the maximum number of records that should be written to any one file\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     The string to be stripped off the read name\n+     *                       before writing to the bfq file. May be null, in which case\n+     *                       the name will not be trimmed.\n+     * @param includeNonPfReads whether to include non pf-reads\n+     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\n+     */\n+    public SamToBfqWriter(final File bamFile, final File referenceSequence, final String outputPrefix, final Integer total,\n+                          final Integer chunk, final boolean pairedReads, String namePrefix,\n+                          boolean includeNonPfReads, boolean clipAdapters, Integer basesToWrite) {\n+\n+        IOUtil.assertFileIsReadable(bamFile);\n+        this.bamFile = bamFile;\n+        this.outputPrefix = outputPrefix;\n+        this.pairedReads = pairedReads;\n+        this.referenceSequence = referenceSequence;\n+        if (total != null) {\n+            final double writeable = countWritableRecords();\n+            this.increment = (int)Math.floor(writeable/total.doubleValue());\n+            if (this.increment == 0) {\n+                this.increment = 1;\n+            }\n+        }\n+        if (chunk != null) {\n+            this.chunk = chunk;\n+        }\n+        this.namePrefix = namePrefix;\n+        this.nameTrim = namePrefix != null ? namePrefix.length() : 0;\n+        this.includeNonPfReads = includeNonPfReads;\n+        this.clipAdapters = clipAdapters;\n+        this.basesToWrite = basesToWrite;\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile   the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     the barcode of the run (to be stripped off the read name\n+     *                       before writing to the bfq file)\n+     * @param includeNonPfReads whether to include non pf-reads\n+     */\n+    public SamToBfqWriter(final File bamFile, final String outputPrefix, final boolean pairedReads,\n+                          String namePrefix, boolean includeNonPfReads) {\n+        this(bamFile, null, outputPrefix, null, null, pairedReads, namePrefix, includeNonPfReads, true, null);\n+    }\n+ \n+    /**\n+     * Writes the binary fastq file(s) to the output directory\n+     */\n+    public void writeBfqFiles() {\n+\n+        final SamReader reader = SamReaderFactory.makeDefault().open(bamFile);\n+        final Iterator<SAMRecord> iterator = reader.iterator();\n+\n+        // Filter out noise reads and reads that fail the quality filter\n+        final TagFilter tagFilter = new TagFilter(ReservedTagConstants.XN, 1);\n+        final FailsVendorReadQualityFilter qualityFilter = new FailsVendorReadQualityFilter();\n+        final WholeReadClippedFilter clippedFilter = new WholeReadClippedFilter();\n+\n+\n+        if (!pairedReads) {\n+            List<SamRecordFilter> filters = new ArrayList<>();\n+            filters.add(tagFilter);\n+            filters.add(clippedFilter);\n+            if (!this.includeNonPfReads) {\n+                filters.add(qualityFilter);\n+            }\n+            writeSingleEndBfqs(iterator, filters);\n+            codec1.close();\n+        }\n+        else {\n+            writePairedEndBfqs(iterator, tagFilter, qualityFilter, clippedFilter);\n+            codec1.close();\n+            codec2.close();\n+        }\n+        log.info(\"Wrote \" + wrote + \" bfq records.\");\n+        CloserUtil.close(reader);\n+    }\n+\n+    /**\n+     * Path for writing bfqs for paired-end reads\n+     *\n+     * @param iterator      the iterator witht he SAM Records to write\n+     * @param tagFilter     the filter for noise reads\n+     * @param qualityFilter the filter for PF reads\n+     */\n+    private void writePairedEndBfqs(final Iterator<SAMRecord> iterator, final TagFilter tagFilter,\n+                                    final FailsVendorReadQualityFilter qualityFilter,\n+                                    SamRecordFilter ... otherFilters) {\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        RECORD_LOOP: while (iterator.hasNext()) {\n+            final SAMRecord first = iterator.next();\n+            if (!iterator.hasNext()) {\n+                throw new PicardException(\"Mismatched number of records in \" + this.bamFile.getAbsolutePath());\n+            }\n+            final SAMRecord second = iterator.next();\n+            if (!second.getReadName().equals(first.getReadName()) ||\n+                first.getFirstOfPairFlag() == second.getFirstOfPairFlag()) {\n+                throw new PicardException(\"Unmatched read pairs in \" + this.bamFile.getAbsolutePath() +\n+                    \": \" + first.getReadName() + \", \" + second.getReadName() + \".\");\n+            }\n+\n+            // If *both* are noise reads, filter them out\n+            if (tagFilter.filterOut(first) && tagFilter.filterOut(second))  {\n+                continue;\n+            }\n+\n+            // If either fails to pass filter, then exclude them as well\n+            if (!includeNonPfReads && (qualityFilter.filterOut(first) || qualityFilter.filterOut(second))) {\n+                continue;\n+            }\n+\n+            // If either fails any of the other filters, exclude them both\n+            for (SamRecordFilter filter : otherFilters) {\n+                if (filter.filterOut(first) || filter.filterOut(second)) {\n+                    continue RECORD_LOOP;\n+                }\n+            }\n+\n+            // Otherwise, write them out\n+            records++;\n+            if (records % increment == 0) {\n+                first.setReadName(first.getReadName() + \"/1\");\n+                writeFastqRecord(first.getFirstOfPairFlag() ? codec1 : codec2, first);\n+                second.setReadName(second.getReadName() + \"/2\");\n+                writeFastqRecord(second.getFirstOfPairFlag() ? codec1 : codec2, second);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records written.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Path for writing bfqs for single-end reads\n+     *\n+     * @param iterator  the iterator with he SAM Records to write\n+     * @param filters   the list of filters to be applied\n+     */\n+    private void writeSingleEndBfqs(final Iterator<SAMRecord> iterator, final List<SamRecordFilter> filters) {\n+\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        final FilteringSamIterator it = new FilteringSamIterator(iterator, new AggregateFilter(filters));\n+        while (it.hasNext()) {\n+            final SAMRecord record = it.next();\n+            records++;\n+            if (records % increment == 0) {\n+\n+                record.setReadName(record.getReadName() + \"/1\");\n+                writeFastqRecord(codec1, record);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records processed.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Closes any the open bfq file(s), if any, and opens the new one(s)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyOTM4NDQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fastq/SamToBfqWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODoxMTozMFrOJByVbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODoxMTozMFrOJByVbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1MzAzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(!reader.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.queryname)) {\n          \n          \n            \n                    if (!reader.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.queryname)) {", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r605853037", "createdAt": "2021-04-01T18:11:30Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/fastq/SamToBfqWriter.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2009 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package picard.fastq;\n+\n+import htsjdk.samtools.ReservedTagConstants;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.filter.AggregateFilter;\n+import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\n+import htsjdk.samtools.filter.FilteringSamIterator;\n+import htsjdk.samtools.filter.SamRecordFilter;\n+import htsjdk.samtools.filter.TagFilter;\n+import htsjdk.samtools.filter.WholeReadClippedFilter;\n+import htsjdk.samtools.util.BinaryCodec;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.PeekableIterator;\n+import htsjdk.utils.ValidationUtils;\n+import picard.PicardException;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Class to take unmapped reads in SAM/BAM/CRAM file format and create Maq binary fastq format file(s) --\n+ * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\n+ * file having all paired reads together in order.\n+ */\n+public class SamToBfqWriter {\n+\n+    private static final int SEED_REGION_LENGTH = 28;\n+    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\n+\n+    private final File bamFile;\n+    private final String outputPrefix;\n+    private final String namePrefix;\n+    private final int nameTrim;\n+    private final File referenceSequence;\n+    private final boolean pairedReads;\n+    private int wrote = 0;\n+    private int increment = 1;\n+    private int chunk = 0;\n+    private BinaryCodec codec1;\n+    private BinaryCodec codec2;\n+    private final Log log = Log.getInstance(SamToBfqWriter.class);\n+    private final boolean includeNonPfReads;\n+    private final boolean clipAdapters;\n+    private final Integer basesToWrite;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile        the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param total          the total number of records that should be written, drawn evenly\n+     *                       from throughout the file (null for all).\n+     * @param chunk          the maximum number of records that should be written to any one file\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     The string to be stripped off the read name\n+     *                       before writing to the bfq file. May be null, in which case\n+     *                       the name will not be trimmed.\n+     * @param includeNonPfReads whether to include non pf-reads\n+     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\n+     */\n+    public SamToBfqWriter(final File bamFile, final File referenceSequence, final String outputPrefix, final Integer total,\n+                          final Integer chunk, final boolean pairedReads, String namePrefix,\n+                          boolean includeNonPfReads, boolean clipAdapters, Integer basesToWrite) {\n+\n+        IOUtil.assertFileIsReadable(bamFile);\n+        this.bamFile = bamFile;\n+        this.outputPrefix = outputPrefix;\n+        this.pairedReads = pairedReads;\n+        this.referenceSequence = referenceSequence;\n+        if (total != null) {\n+            final double writeable = countWritableRecords();\n+            this.increment = (int)Math.floor(writeable/total.doubleValue());\n+            if (this.increment == 0) {\n+                this.increment = 1;\n+            }\n+        }\n+        if (chunk != null) {\n+            this.chunk = chunk;\n+        }\n+        this.namePrefix = namePrefix;\n+        this.nameTrim = namePrefix != null ? namePrefix.length() : 0;\n+        this.includeNonPfReads = includeNonPfReads;\n+        this.clipAdapters = clipAdapters;\n+        this.basesToWrite = basesToWrite;\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile   the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     the barcode of the run (to be stripped off the read name\n+     *                       before writing to the bfq file)\n+     * @param includeNonPfReads whether to include non pf-reads\n+     */\n+    public SamToBfqWriter(final File bamFile, final String outputPrefix, final boolean pairedReads,\n+                          String namePrefix, boolean includeNonPfReads) {\n+        this(bamFile, null, outputPrefix, null, null, pairedReads, namePrefix, includeNonPfReads, true, null);\n+    }\n+ \n+    /**\n+     * Writes the binary fastq file(s) to the output directory\n+     */\n+    public void writeBfqFiles() {\n+\n+        final SamReader reader = SamReaderFactory.makeDefault().open(bamFile);\n+        final Iterator<SAMRecord> iterator = reader.iterator();\n+\n+        // Filter out noise reads and reads that fail the quality filter\n+        final TagFilter tagFilter = new TagFilter(ReservedTagConstants.XN, 1);\n+        final FailsVendorReadQualityFilter qualityFilter = new FailsVendorReadQualityFilter();\n+        final WholeReadClippedFilter clippedFilter = new WholeReadClippedFilter();\n+\n+\n+        if (!pairedReads) {\n+            List<SamRecordFilter> filters = new ArrayList<>();\n+            filters.add(tagFilter);\n+            filters.add(clippedFilter);\n+            if (!this.includeNonPfReads) {\n+                filters.add(qualityFilter);\n+            }\n+            writeSingleEndBfqs(iterator, filters);\n+            codec1.close();\n+        }\n+        else {\n+            writePairedEndBfqs(iterator, tagFilter, qualityFilter, clippedFilter);\n+            codec1.close();\n+            codec2.close();\n+        }\n+        log.info(\"Wrote \" + wrote + \" bfq records.\");\n+        CloserUtil.close(reader);\n+    }\n+\n+    /**\n+     * Path for writing bfqs for paired-end reads\n+     *\n+     * @param iterator      the iterator witht he SAM Records to write\n+     * @param tagFilter     the filter for noise reads\n+     * @param qualityFilter the filter for PF reads\n+     */\n+    private void writePairedEndBfqs(final Iterator<SAMRecord> iterator, final TagFilter tagFilter,\n+                                    final FailsVendorReadQualityFilter qualityFilter,\n+                                    SamRecordFilter ... otherFilters) {\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        RECORD_LOOP: while (iterator.hasNext()) {\n+            final SAMRecord first = iterator.next();\n+            if (!iterator.hasNext()) {\n+                throw new PicardException(\"Mismatched number of records in \" + this.bamFile.getAbsolutePath());\n+            }\n+            final SAMRecord second = iterator.next();\n+            if (!second.getReadName().equals(first.getReadName()) ||\n+                first.getFirstOfPairFlag() == second.getFirstOfPairFlag()) {\n+                throw new PicardException(\"Unmatched read pairs in \" + this.bamFile.getAbsolutePath() +\n+                    \": \" + first.getReadName() + \", \" + second.getReadName() + \".\");\n+            }\n+\n+            // If *both* are noise reads, filter them out\n+            if (tagFilter.filterOut(first) && tagFilter.filterOut(second))  {\n+                continue;\n+            }\n+\n+            // If either fails to pass filter, then exclude them as well\n+            if (!includeNonPfReads && (qualityFilter.filterOut(first) || qualityFilter.filterOut(second))) {\n+                continue;\n+            }\n+\n+            // If either fails any of the other filters, exclude them both\n+            for (SamRecordFilter filter : otherFilters) {\n+                if (filter.filterOut(first) || filter.filterOut(second)) {\n+                    continue RECORD_LOOP;\n+                }\n+            }\n+\n+            // Otherwise, write them out\n+            records++;\n+            if (records % increment == 0) {\n+                first.setReadName(first.getReadName() + \"/1\");\n+                writeFastqRecord(first.getFirstOfPairFlag() ? codec1 : codec2, first);\n+                second.setReadName(second.getReadName() + \"/2\");\n+                writeFastqRecord(second.getFirstOfPairFlag() ? codec1 : codec2, second);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records written.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Path for writing bfqs for single-end reads\n+     *\n+     * @param iterator  the iterator with he SAM Records to write\n+     * @param filters   the list of filters to be applied\n+     */\n+    private void writeSingleEndBfqs(final Iterator<SAMRecord> iterator, final List<SamRecordFilter> filters) {\n+\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        final FilteringSamIterator it = new FilteringSamIterator(iterator, new AggregateFilter(filters));\n+        while (it.hasNext()) {\n+            final SAMRecord record = it.next();\n+            records++;\n+            if (records % increment == 0) {\n+\n+                record.setReadName(record.getReadName() + \"/1\");\n+                writeFastqRecord(codec1, record);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records processed.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Closes any the open bfq file(s), if any, and opens the new one(s)\n+     *\n+     * @param fileIndex the index (counter) of the files to write\n+     */\n+    private void initializeNextBfqFiles(final int fileIndex) {\n+        // Close the codecs if they were writing before\n+        if (codec1 != null) {\n+            codec1.close();\n+            if (pairedReads) {\n+                codec2.close();\n+            }\n+        }\n+\n+        // Open new file, using the fileIndex.\n+        final File bfq1 = getOutputFile(this.outputPrefix , 1, fileIndex);\n+        codec1 = new BinaryCodec(IOUtil.openFileForWriting(bfq1));\n+        log.info(\"Now writing to file \" + bfq1.getAbsolutePath());\n+        if (pairedReads) {\n+            final File bfq2 = getOutputFile(this.outputPrefix , 2, fileIndex);\n+            codec2 = new BinaryCodec(IOUtil.openFileForWriting(bfq2));\n+            log.info(\"Now writing to file \" + bfq2.getAbsolutePath());\n+        }\n+    }\n+\n+    /**\n+     * Writes out a SAMRecord in Maq fastq format\n+     *\n+     * @param codec the code to write to\n+     * @param rec   the SAMRecord to write\n+     */\n+    private void writeFastqRecord(final BinaryCodec codec, final SAMRecord rec) {\n+\n+        // Trim the run barcode off the read name\n+        String readName = rec.getReadName();\n+        if (namePrefix != null && readName.startsWith(namePrefix)) {\n+            readName = readName.substring(nameTrim);\n+        }\n+        // Writes the length of the read name and then the name (null-terminated)\n+        codec.writeString(readName, true, true);\n+\n+        final char[] seqs = rec.getReadString().toCharArray();\n+        final char[] quals = rec.getBaseQualityString().toCharArray();\n+\n+        int retainedLength = seqs.length;\n+        if (clipAdapters){\n+            // adjust to a shorter length iff clipping tag exists\n+            Integer trimPoint = rec.getIntegerAttribute(ReservedTagConstants.XT);\n+            if (trimPoint != null) {\n+                ValidationUtils.validateArg(rec.getReadLength() == seqs.length, () -> \"length of read and seqs differ. Found \" + rec.getReadLength() + \" and '\" + seqs.length + \".\");\n+\n+                retainedLength = Math.min(seqs.length, Math.max(SEED_REGION_LENGTH, trimPoint -1));\n+            }\n+        }\n+\n+        // Write the length of the sequence\n+        codec.writeInt(basesToWrite != null ? basesToWrite : seqs.length);\n+\n+        // Calculate and write the sequence and qualities\n+        final byte[] seqsAndQuals = encodeSeqsAndQuals(seqs, quals, retainedLength);\n+        codec.writeBytes(seqsAndQuals);\n+    }\n+\n+    private byte[] encodeSeqsAndQuals(char[] seqs, char[] quals, int retainedLength) {\n+        final byte[] seqsAndQuals = new byte[basesToWrite == null ? seqs.length : basesToWrite];\n+\n+        int seedRegionNoCallFixes = 0;\n+        for (int i = 0; i < retainedLength && i < seqsAndQuals.length; i++) {\n+            int quality = Math.min(quals[i]-33, 63);\n+            final int base;\n+            switch(seqs[i]) {\n+                case 'A':\n+                case 'a':\n+                    base = 0;\n+                    break;\n+                case 'C':\n+                case 'c':\n+                    base = 1;\n+                    break;\n+                case 'G':\n+                case 'g':\n+                    base = 2;\n+                    break;\n+                case 'T':\n+                case 't':\n+                    base = 3;\n+                    break;\n+                case 'N':\n+                case 'n':\n+                case '.':\n+                    base = 0;\n+                    if (i < SEED_REGION_LENGTH ) {\n+                        if (seedRegionNoCallFixes < MAX_SEED_REGION_NOCALL_FIXES) {\n+                            quality = 1;\n+                            seedRegionNoCallFixes++;\n+                        }\n+                        else {\n+                            quality = 0;\n+                        }\n+                    }\n+                    else {\n+                        quality = 1;\n+                    }\n+                    break;\n+                default:\n+                    throw new PicardException(\"Unknown base when writing bfq file: \" + seqs[i]);\n+            }\n+            seqsAndQuals[i] = encodeBaseAndQuality(base, quality);\n+        }\n+        // rewrite clipped adapter with all A's of quality 1\n+        for (int i = retainedLength; i < seqsAndQuals.length; i++) {\n+            seqsAndQuals[i] = encodeBaseAndQuality(0, 1);\n+        }\n+\n+        return seqsAndQuals;\n+    }\n+\n+    private byte encodeBaseAndQuality(int base, int quality) {\n+        return (byte) ((base << 6) | quality);\n+    }\n+\n+    /**\n+     * Count the number of records in the bamFile that could potentially be written\n+     *\n+     * @return  the number of records in the Bam file\n+     */\n+    private int countWritableRecords() {\n+        int count = 0;\n+\n+        final SamReader reader = SamReaderFactory.makeDefault().referenceSequence(referenceSequence).open(bamFile);\n+        if(!reader.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.queryname)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2"}, "originalPosition": 391}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyOTM5MzcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/CompareSAMs.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODoxNDoxNFrOJBybXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODoxNDoxNFrOJBybXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1NDU1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static final String USAGE_DETAILS = \"This tool initially compares the headers input files. \" +\n          \n          \n            \n                static final String USAGE_DETAILS = \"This tool initially compares the headers of the input files. \" +\n          \n      \n    \n    \n  \n\n??", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r605854556", "createdAt": "2021-04-01T18:14:14Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/sam/CompareSAMs.java", "diffHunk": "@@ -53,8 +53,8 @@\n         programGroup = DiagnosticsAndQCProgramGroup.class)\n @DocumentedFeature\n public class CompareSAMs extends CommandLineProgram {\n-    static final String USAGE_SUMMARY = \"Compare two input \\\".sam\\\" or \\\".bam\\\" files.  \";\n-    static final String USAGE_DETAILS = \"This tool initially compares the headers of SAM or BAM files. \" +\n+    static final String USAGE_SUMMARY = \"Compare two input SAM/BAM/CRAM files.  \";\n+    static final String USAGE_DETAILS = \"This tool initially compares the headers input files. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyOTQyMTQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/sam/SplitSamByNumberOfReads.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODoyMTo0MVrOJByseg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxODoyMTo0MVrOJByseg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1ODkzOA==", "bodyText": "spacing.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    new File(OUTPUT, String.format(\"%s_%04d.%s\", OUT_PREFIX,index,extension)));\n          \n          \n            \n                                    new File(OUTPUT, String.format(\"%s_%04d.%s\", OUT_PREFIX, index, extension)));", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r605858938", "createdAt": "2021-04-01T18:21:41Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/sam/SplitSamByNumberOfReads.java", "diffHunk": "@@ -131,14 +134,16 @@ protected int doWork() {\n         int fileIndex = 1;\n \n         Function<Integer, SAMFileWriter> createWriter = (index) ->\n-                writerFactory.makeSAMOrBAMWriter(header, true, new File(OUTPUT, OUT_PREFIX + \"_\" + String.format(\"%04d\", index) + BamFileIoUtils.BAM_FILE_EXTENSION));\n+                writerFactory.makeSAMOrBAMWriter(header, true,\n+                        new File(OUTPUT, String.format(\"%s_%04d.%s\", OUT_PREFIX,index,extension)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDM0NDc2NTkyOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/sam/CramCompatibilityTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0wNFQxNzo0MToyMlrOKLMfvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wOC0wNVQwMjowNDo1NFrOKLbmpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MjgyNzcwOQ==", "bodyText": "Should this have a deleteOnExit()?", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r682827709", "createdAt": "2021-08-04T17:41:22Z", "author": {"login": "gbggrant"}, "path": "src/test/java/picard/sam/CramCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.SamStreams;\n+import htsjdk.samtools.cram.CRAMException;\n+import htsjdk.samtools.util.IOUtil;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.cmdline.CommandLineProgram;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+public class CramCompatibilityTest {\n+\n+    public static final String CRAM_FILE = \"testdata/picard/sam/test_cram_file_coordinate_sorted.cram\";\n+    public static final String CRAM_FILE_2 = \"testdata/picard/sam/test_cram_file_header_only.cram\";\n+    public static final String CRAM_FILE_ONE_PAIR_MC = \"testdata/picard/sam/MarkDuplicates/one_pair_mc.cram\";\n+\n+    public static final String CRAM_FILE_QUERY_SORTED_UNMAPPED = \"testdata/picard/sam/unmapped_queryname_sorted.cram\";\n+    public static final String CRAM_FILE_QUERY_SORTED = \"testdata/picard/sam/test_cram_file_query_sorted.cram\";\n+\n+    public static final String REFERENCE_FILE = \"testdata/picard/sam/test_cram_file.ref.fa\";\n+    public static final String FASTQ_FILE = \"testdata/picard/sam/fastq2bam/fastq-sanger/5k-v1-Rhodobacter_LW1.sam.fastq\";\n+\n+    public static final String CRAM_UNMAPPED = \"testdata/picard/sam/SamFormatConverterTest/unmapped.cram\";\n+    public static final String CRAM_UNMAPPED_WITH_OQ_TAG = \"testdata/picard/sam/unmapped_with_oq_tag.cram\";\n+\n+    public static final String CRAM_UNMAPPED_PART_1 = \"testdata/picard/sam/unmapped_part_1.cram\";\n+    public static final String CRAM_UNMAPPED_PART_2 = \"testdata/picard/sam/unmapped_part_2.cram\";\n+\n+    public static final String CRAM_SPLIT_UNMAPPED = \"testdata/picard/sam/split_test_unmapped.cram\";\n+\n+    public static final String MBA_ALIGNED_CRAM = \"testdata/picard/sam/MergeBamAlignment/cliptest.aligned.cram\";\n+    public static final String MBA_UNMAPPED_CRAM = \"testdata/picard/sam/MergeBamAlignment/cliptest.unmapped.cram\";\n+    public static final String MBA_REFERENCE = \"testdata/picard/sam/MergeBamAlignment/cliptest.fasta\";\n+\n+    private static final File outputDir = IOUtil.createTempDir(\"testdata/picard/sam/CramCompatibilityTest\", \".tmp\");\n+\n+    @AfterTest\n+    public void tearDown() {\n+        IOUtil.recursiveDelete(outputDir.toPath());\n+    }\n+\n+    @DataProvider(name = \"programArgsForCRAMWithReference\")\n+    public Object[][] getArgsForCRAMWithReference() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\",\n+                        \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\",\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.CleanSam\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + CRAM_FILE_2, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", \"CREATE_INDEX=false\", CRAM_FILE_QUERY_SORTED, REFERENCE_FILE},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED).getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.markduplicates.MarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"MarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.markduplicates.SimpleMarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"SimpleMarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_ONE_PAIR_MC,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.ReorderSam\",\n+                        \"SEQUENCE_DICTIONARY=\" + REFERENCE_FILE,\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.SetNmMdAndUqTags\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.MergeBamAlignment\",\n+                        \"UNMAPPED=\" + new File(MBA_UNMAPPED_CRAM).getAbsolutePath() +\n+                        \" ALIGNED=\" + new File(MBA_ALIGNED_CRAM).getAbsolutePath(),\n+                        null,\n+                        MBA_REFERENCE\n+                },\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_FILE, REFERENCE_FILE}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsForCRAMWithReference\")\n+    public void testShouldWriteCRAMWhenCRAMWithReference(String program,\n+                                                         String parameters,\n+                                                         String cramFile,\n+                                                         String reference) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, reference);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, reference);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    @DataProvider(name  = \"programArgsForCRAMWithoutReferenceToFail\")\n+    public Object[][] getArgsForCRAMWithoutReferenceToFail() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\",\n+                        \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\",\n+                        CRAM_FILE\n+                },\n+                {\"picard.sam.CleanSam\", null, CRAM_FILE},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_FILE},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_FILE},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_FILE\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_FILE},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_FILE},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_FILE},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + CRAM_FILE_2, CRAM_FILE},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", null, CRAM_FILE_QUERY_SORTED},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED).getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED\n+                },\n+                {\"picard.sam.markduplicates.MarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"MarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE},\n+                {\"picard.sam.markduplicates.SimpleMarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"SimpleMarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_ONE_PAIR_MC},\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_FILE}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsForCRAMWithoutReferenceToFail\", expectedExceptions = {CRAMException.class, IllegalArgumentException.class})\n+    public void testShouldFailWhenCRAMWithoutReference(String program,\n+                                                       String parameters,\n+                                                       String cramFile) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, null);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, null);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    // test with CRAMs that don't need reference (unmapped CRAMs for input or output)\n+    @DataProvider(name = \"programArgsWithUnmappedCRAM\")\n+    public Object[][] getArgsWithUnmappedCRAM() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\", \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\", CRAM_UNMAPPED},\n+                {\"picard.sam.CleanSam\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_UNMAPPED\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_UNMAPPED},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_UNMAPPED},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + MBA_UNMAPPED_CRAM, CRAM_UNMAPPED},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", \"CREATE_INDEX=false\", CRAM_UNMAPPED_WITH_OQ_TAG},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED_PART_2).getAbsolutePath(),\n+                        CRAM_UNMAPPED_PART_1\n+                },\n+                {\"picard.sam.FastqToSam\", \"F1=\" + FASTQ_FILE + \" SAMPLE_NAME=s1\", null},\n+                {\"picard.illumina.IlluminaBasecallsToSam\",\n+                        \"BASECALLS_DIR=\" + new File(\"testdata/picard/illumina/25T8B25T/Data/Intensities/BaseCalls\") +\n+                        \" LANE=1 READ_STRUCTURE=25S8S25T RUN_BARCODE=HiMom SAMPLE_ALIAS=HiDad LIBRARY_NAME=HelloWorld SEQUENCING_CENTER=BI\" ,\n+                        null\n+                },\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED_UNMAPPED\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_SPLIT_UNMAPPED}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsWithUnmappedCRAM\")\n+    public void testShouldWriteCRAMWhenUnmappedCRAMWithoutReference(String program,\n+                                                                    String parameters,\n+                                                                    String cramFile) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, null);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, null);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    private File createTempCram(String name) throws IOException {\n+        return createTempFile(name, \".cram\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a472ba6e47bb5ef4af461b1fa3ebd00eebb7a39"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4Mjk5NTU4MA==", "bodyText": "isn't it 2 7 lines below?", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r682995580", "createdAt": "2021-08-04T22:15:43Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/sam/CramCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.SamStreams;\n+import htsjdk.samtools.cram.CRAMException;\n+import htsjdk.samtools.util.IOUtil;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.cmdline.CommandLineProgram;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+public class CramCompatibilityTest {\n+\n+    public static final String CRAM_FILE = \"testdata/picard/sam/test_cram_file_coordinate_sorted.cram\";\n+    public static final String CRAM_FILE_2 = \"testdata/picard/sam/test_cram_file_header_only.cram\";\n+    public static final String CRAM_FILE_ONE_PAIR_MC = \"testdata/picard/sam/MarkDuplicates/one_pair_mc.cram\";\n+\n+    public static final String CRAM_FILE_QUERY_SORTED_UNMAPPED = \"testdata/picard/sam/unmapped_queryname_sorted.cram\";\n+    public static final String CRAM_FILE_QUERY_SORTED = \"testdata/picard/sam/test_cram_file_query_sorted.cram\";\n+\n+    public static final String REFERENCE_FILE = \"testdata/picard/sam/test_cram_file.ref.fa\";\n+    public static final String FASTQ_FILE = \"testdata/picard/sam/fastq2bam/fastq-sanger/5k-v1-Rhodobacter_LW1.sam.fastq\";\n+\n+    public static final String CRAM_UNMAPPED = \"testdata/picard/sam/SamFormatConverterTest/unmapped.cram\";\n+    public static final String CRAM_UNMAPPED_WITH_OQ_TAG = \"testdata/picard/sam/unmapped_with_oq_tag.cram\";\n+\n+    public static final String CRAM_UNMAPPED_PART_1 = \"testdata/picard/sam/unmapped_part_1.cram\";\n+    public static final String CRAM_UNMAPPED_PART_2 = \"testdata/picard/sam/unmapped_part_2.cram\";\n+\n+    public static final String CRAM_SPLIT_UNMAPPED = \"testdata/picard/sam/split_test_unmapped.cram\";\n+\n+    public static final String MBA_ALIGNED_CRAM = \"testdata/picard/sam/MergeBamAlignment/cliptest.aligned.cram\";\n+    public static final String MBA_UNMAPPED_CRAM = \"testdata/picard/sam/MergeBamAlignment/cliptest.unmapped.cram\";\n+    public static final String MBA_REFERENCE = \"testdata/picard/sam/MergeBamAlignment/cliptest.fasta\";\n+\n+    private static final File outputDir = IOUtil.createTempDir(\"testdata/picard/sam/CramCompatibilityTest\", \".tmp\");\n+\n+    @AfterTest\n+    public void tearDown() {\n+        IOUtil.recursiveDelete(outputDir.toPath());\n+    }\n+\n+    @DataProvider(name = \"programArgsForCRAMWithReference\")\n+    public Object[][] getArgsForCRAMWithReference() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\",\n+                        \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\",\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.CleanSam\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + CRAM_FILE_2, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", \"CREATE_INDEX=false\", CRAM_FILE_QUERY_SORTED, REFERENCE_FILE},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED).getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.markduplicates.MarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"MarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.markduplicates.SimpleMarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"SimpleMarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_ONE_PAIR_MC,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.ReorderSam\",\n+                        \"SEQUENCE_DICTIONARY=\" + REFERENCE_FILE,\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.SetNmMdAndUqTags\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.MergeBamAlignment\",\n+                        \"UNMAPPED=\" + new File(MBA_UNMAPPED_CRAM).getAbsolutePath() +\n+                        \" ALIGNED=\" + new File(MBA_ALIGNED_CRAM).getAbsolutePath(),\n+                        null,\n+                        MBA_REFERENCE\n+                },\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_FILE, REFERENCE_FILE}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsForCRAMWithReference\")\n+    public void testShouldWriteCRAMWhenCRAMWithReference(String program,\n+                                                         String parameters,\n+                                                         String cramFile,\n+                                                         String reference) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, reference);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, reference);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    @DataProvider(name  = \"programArgsForCRAMWithoutReferenceToFail\")\n+    public Object[][] getArgsForCRAMWithoutReferenceToFail() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\",\n+                        \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\",\n+                        CRAM_FILE\n+                },\n+                {\"picard.sam.CleanSam\", null, CRAM_FILE},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_FILE},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_FILE},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_FILE\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_FILE},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_FILE},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_FILE},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + CRAM_FILE_2, CRAM_FILE},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", null, CRAM_FILE_QUERY_SORTED},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED).getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED\n+                },\n+                {\"picard.sam.markduplicates.MarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"MarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE},\n+                {\"picard.sam.markduplicates.SimpleMarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"SimpleMarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_ONE_PAIR_MC},\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_FILE}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsForCRAMWithoutReferenceToFail\", expectedExceptions = {CRAMException.class, IllegalArgumentException.class})\n+    public void testShouldFailWhenCRAMWithoutReference(String program,\n+                                                       String parameters,\n+                                                       String cramFile) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, null);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, null);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    // test with CRAMs that don't need reference (unmapped CRAMs for input or output)\n+    @DataProvider(name = \"programArgsWithUnmappedCRAM\")\n+    public Object[][] getArgsWithUnmappedCRAM() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\", \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\", CRAM_UNMAPPED},\n+                {\"picard.sam.CleanSam\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_UNMAPPED\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_UNMAPPED},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_UNMAPPED},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + MBA_UNMAPPED_CRAM, CRAM_UNMAPPED},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", \"CREATE_INDEX=false\", CRAM_UNMAPPED_WITH_OQ_TAG},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED_PART_2).getAbsolutePath(),\n+                        CRAM_UNMAPPED_PART_1\n+                },\n+                {\"picard.sam.FastqToSam\", \"F1=\" + FASTQ_FILE + \" SAMPLE_NAME=s1\", null},\n+                {\"picard.illumina.IlluminaBasecallsToSam\",\n+                        \"BASECALLS_DIR=\" + new File(\"testdata/picard/illumina/25T8B25T/Data/Intensities/BaseCalls\") +\n+                        \" LANE=1 READ_STRUCTURE=25S8S25T RUN_BARCODE=HiMom SAMPLE_ALIAS=HiDad LIBRARY_NAME=HelloWorld SEQUENCING_CENTER=BI\" ,\n+                        null\n+                },\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED_UNMAPPED\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_SPLIT_UNMAPPED}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsWithUnmappedCRAM\")\n+    public void testShouldWriteCRAMWhenUnmappedCRAMWithoutReference(String program,\n+                                                                    String parameters,\n+                                                                    String cramFile) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, null);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, null);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    private File createTempCram(String name) throws IOException {\n+        return createTempFile(name, \".cram\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MjgyNzcwOQ=="}, "originalCommit": {"oid": "1a472ba6e47bb5ef4af461b1fa3ebd00eebb7a39"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzA3NTIzOQ==", "bodyText": "Yes.", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r683075239", "createdAt": "2021-08-05T02:04:54Z", "author": {"login": "gbggrant"}, "path": "src/test/java/picard/sam/CramCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.SamStreams;\n+import htsjdk.samtools.cram.CRAMException;\n+import htsjdk.samtools.util.IOUtil;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.cmdline.CommandLineProgram;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+public class CramCompatibilityTest {\n+\n+    public static final String CRAM_FILE = \"testdata/picard/sam/test_cram_file_coordinate_sorted.cram\";\n+    public static final String CRAM_FILE_2 = \"testdata/picard/sam/test_cram_file_header_only.cram\";\n+    public static final String CRAM_FILE_ONE_PAIR_MC = \"testdata/picard/sam/MarkDuplicates/one_pair_mc.cram\";\n+\n+    public static final String CRAM_FILE_QUERY_SORTED_UNMAPPED = \"testdata/picard/sam/unmapped_queryname_sorted.cram\";\n+    public static final String CRAM_FILE_QUERY_SORTED = \"testdata/picard/sam/test_cram_file_query_sorted.cram\";\n+\n+    public static final String REFERENCE_FILE = \"testdata/picard/sam/test_cram_file.ref.fa\";\n+    public static final String FASTQ_FILE = \"testdata/picard/sam/fastq2bam/fastq-sanger/5k-v1-Rhodobacter_LW1.sam.fastq\";\n+\n+    public static final String CRAM_UNMAPPED = \"testdata/picard/sam/SamFormatConverterTest/unmapped.cram\";\n+    public static final String CRAM_UNMAPPED_WITH_OQ_TAG = \"testdata/picard/sam/unmapped_with_oq_tag.cram\";\n+\n+    public static final String CRAM_UNMAPPED_PART_1 = \"testdata/picard/sam/unmapped_part_1.cram\";\n+    public static final String CRAM_UNMAPPED_PART_2 = \"testdata/picard/sam/unmapped_part_2.cram\";\n+\n+    public static final String CRAM_SPLIT_UNMAPPED = \"testdata/picard/sam/split_test_unmapped.cram\";\n+\n+    public static final String MBA_ALIGNED_CRAM = \"testdata/picard/sam/MergeBamAlignment/cliptest.aligned.cram\";\n+    public static final String MBA_UNMAPPED_CRAM = \"testdata/picard/sam/MergeBamAlignment/cliptest.unmapped.cram\";\n+    public static final String MBA_REFERENCE = \"testdata/picard/sam/MergeBamAlignment/cliptest.fasta\";\n+\n+    private static final File outputDir = IOUtil.createTempDir(\"testdata/picard/sam/CramCompatibilityTest\", \".tmp\");\n+\n+    @AfterTest\n+    public void tearDown() {\n+        IOUtil.recursiveDelete(outputDir.toPath());\n+    }\n+\n+    @DataProvider(name = \"programArgsForCRAMWithReference\")\n+    public Object[][] getArgsForCRAMWithReference() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\",\n+                        \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\",\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.CleanSam\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + CRAM_FILE_2, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", \"CREATE_INDEX=false\", CRAM_FILE_QUERY_SORTED, REFERENCE_FILE},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED).getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.markduplicates.MarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"MarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.markduplicates.SimpleMarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"SimpleMarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_ONE_PAIR_MC,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.ReorderSam\",\n+                        \"SEQUENCE_DICTIONARY=\" + REFERENCE_FILE,\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.SetNmMdAndUqTags\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.MergeBamAlignment\",\n+                        \"UNMAPPED=\" + new File(MBA_UNMAPPED_CRAM).getAbsolutePath() +\n+                        \" ALIGNED=\" + new File(MBA_ALIGNED_CRAM).getAbsolutePath(),\n+                        null,\n+                        MBA_REFERENCE\n+                },\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_FILE, REFERENCE_FILE}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsForCRAMWithReference\")\n+    public void testShouldWriteCRAMWhenCRAMWithReference(String program,\n+                                                         String parameters,\n+                                                         String cramFile,\n+                                                         String reference) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, reference);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, reference);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    @DataProvider(name  = \"programArgsForCRAMWithoutReferenceToFail\")\n+    public Object[][] getArgsForCRAMWithoutReferenceToFail() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\",\n+                        \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\",\n+                        CRAM_FILE\n+                },\n+                {\"picard.sam.CleanSam\", null, CRAM_FILE},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_FILE},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_FILE},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_FILE\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_FILE},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_FILE},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_FILE},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + CRAM_FILE_2, CRAM_FILE},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", null, CRAM_FILE_QUERY_SORTED},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED).getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED\n+                },\n+                {\"picard.sam.markduplicates.MarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"MarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE},\n+                {\"picard.sam.markduplicates.SimpleMarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"SimpleMarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_ONE_PAIR_MC},\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_FILE}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsForCRAMWithoutReferenceToFail\", expectedExceptions = {CRAMException.class, IllegalArgumentException.class})\n+    public void testShouldFailWhenCRAMWithoutReference(String program,\n+                                                       String parameters,\n+                                                       String cramFile) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, null);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, null);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    // test with CRAMs that don't need reference (unmapped CRAMs for input or output)\n+    @DataProvider(name = \"programArgsWithUnmappedCRAM\")\n+    public Object[][] getArgsWithUnmappedCRAM() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\", \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\", CRAM_UNMAPPED},\n+                {\"picard.sam.CleanSam\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_UNMAPPED\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_UNMAPPED},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_UNMAPPED},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + MBA_UNMAPPED_CRAM, CRAM_UNMAPPED},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", \"CREATE_INDEX=false\", CRAM_UNMAPPED_WITH_OQ_TAG},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED_PART_2).getAbsolutePath(),\n+                        CRAM_UNMAPPED_PART_1\n+                },\n+                {\"picard.sam.FastqToSam\", \"F1=\" + FASTQ_FILE + \" SAMPLE_NAME=s1\", null},\n+                {\"picard.illumina.IlluminaBasecallsToSam\",\n+                        \"BASECALLS_DIR=\" + new File(\"testdata/picard/illumina/25T8B25T/Data/Intensities/BaseCalls\") +\n+                        \" LANE=1 READ_STRUCTURE=25S8S25T RUN_BARCODE=HiMom SAMPLE_ALIAS=HiDad LIBRARY_NAME=HelloWorld SEQUENCING_CENTER=BI\" ,\n+                        null\n+                },\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED_UNMAPPED\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_SPLIT_UNMAPPED}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsWithUnmappedCRAM\")\n+    public void testShouldWriteCRAMWhenUnmappedCRAMWithoutReference(String program,\n+                                                                    String parameters,\n+                                                                    String cramFile) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, null);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, null);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    private File createTempCram(String name) throws IOException {\n+        return createTempFile(name, \".cram\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MjgyNzcwOQ=="}, "originalCommit": {"oid": "1a472ba6e47bb5ef4af461b1fa3ebd00eebb7a39"}, "originalPosition": 224}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 680, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}