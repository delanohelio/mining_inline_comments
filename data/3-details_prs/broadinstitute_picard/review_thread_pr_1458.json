{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MDI0ODI4", "number": 1458, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODo0MDoxNFrODbVGNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowOTo0OVrODfmwRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTgzNzk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODo0MDoxNFrOFiwLnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDowNToxOVrOFiyybA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NTMwOA==", "bodyText": "Is there a reason why you don't use System.arrayCopy() here too? Or call setLogLikelihoods()? it would be nice to keep the field final if possible.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r371985308", "createdAt": "2020-01-28T18:40:14Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "diffHunk": "@@ -26,33 +26,46 @@\n \n import picard.util.MathUtil;\n \n-import static java.lang.Math.log10;\n-\n /**\n  * Represents the probability of the underlying haplotype using log likelihoods as the basic datum for each of the SNPs. By convention the\n  * alleles stored for each SNP are in phase.\n  *\n  * @author Tim Fennell\n  * @author Yossi Farjoun\n  */\n-abstract class HaplotypeProbabilitiesUsingLogLikelihoods extends HaplotypeProbabilities {\n+abstract class HaplotypeProbabilitiesUsingLogLikelihoods extends HaplotypeProbabilities implements Cloneable {\n \n     // some derived classes might need to incorporate accumulated data before logLikelihood is usable.\n     // use the getter to allow these classes to calculate the likelihood from the data.\n-    private final double[] loglikelihoods = new double[Genotype.values().length];\n+    // not final so that clone works\n+    private double[] loglikelihoods = new double[Genotype.values().length];\n+\n     private boolean likelihoodsNeedUpdating = true;\n \n     // stored in order to reduce computation we store these partial results.\n     // they need to be recalculated if loglikelihoodNeedsUpdating\n+\n     private double[] likelihoods = new double[Genotype.values().length];\n     private double[] posteriorProbabilities = new double[Genotype.values().length];\n-    private double[] shiftedLogPosteriors = new double[Genotype.values().length];\n \n+    //normalized (likeihood * prior / normalization_factor)\n+    private double[] shiftedLogPosteriors = new double[Genotype.values().length];\n \n     public HaplotypeProbabilitiesUsingLogLikelihoods(final HaplotypeBlock haplotypeBlock) {\n         super(haplotypeBlock);\n     }\n \n+    @Override\n+    public Object clone() throws CloneNotSupportedException {\n+        final HaplotypeProbabilitiesUsingLogLikelihoods c = (HaplotypeProbabilitiesUsingLogLikelihoods)super.clone();\n+        c.likelihoods = this.likelihoods.clone();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685c7ced92998c718b381a551e6edf8bfe8eddd9"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNjM1OA==", "bodyText": "super.clone does a shallow copy...in order to have these arrays be actually different, I need to clone them. I could make new arrays and arrayCopy, but I'm not sure why that is better. I don't think it's possible to keep the field final...not the clone, anyway...but I'm happy to learn something new.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372026358", "createdAt": "2020-01-28T20:01:45Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "diffHunk": "@@ -26,33 +26,46 @@\n \n import picard.util.MathUtil;\n \n-import static java.lang.Math.log10;\n-\n /**\n  * Represents the probability of the underlying haplotype using log likelihoods as the basic datum for each of the SNPs. By convention the\n  * alleles stored for each SNP are in phase.\n  *\n  * @author Tim Fennell\n  * @author Yossi Farjoun\n  */\n-abstract class HaplotypeProbabilitiesUsingLogLikelihoods extends HaplotypeProbabilities {\n+abstract class HaplotypeProbabilitiesUsingLogLikelihoods extends HaplotypeProbabilities implements Cloneable {\n \n     // some derived classes might need to incorporate accumulated data before logLikelihood is usable.\n     // use the getter to allow these classes to calculate the likelihood from the data.\n-    private final double[] loglikelihoods = new double[Genotype.values().length];\n+    // not final so that clone works\n+    private double[] loglikelihoods = new double[Genotype.values().length];\n+\n     private boolean likelihoodsNeedUpdating = true;\n \n     // stored in order to reduce computation we store these partial results.\n     // they need to be recalculated if loglikelihoodNeedsUpdating\n+\n     private double[] likelihoods = new double[Genotype.values().length];\n     private double[] posteriorProbabilities = new double[Genotype.values().length];\n-    private double[] shiftedLogPosteriors = new double[Genotype.values().length];\n \n+    //normalized (likeihood * prior / normalization_factor)\n+    private double[] shiftedLogPosteriors = new double[Genotype.values().length];\n \n     public HaplotypeProbabilitiesUsingLogLikelihoods(final HaplotypeBlock haplotypeBlock) {\n         super(haplotypeBlock);\n     }\n \n+    @Override\n+    public Object clone() throws CloneNotSupportedException {\n+        final HaplotypeProbabilitiesUsingLogLikelihoods c = (HaplotypeProbabilitiesUsingLogLikelihoods)super.clone();\n+        c.likelihoods = this.likelihoods.clone();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NTMwOA=="}, "originalCommit": {"oid": "685c7ced92998c718b381a551e6edf8bfe8eddd9"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODAxMg==", "bodyText": "It's actually, the other way around...I need to get rid of the other arrayCopy and convert that to a clone..but I'll write a test the proves it first.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372028012", "createdAt": "2020-01-28T20:05:19Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "diffHunk": "@@ -26,33 +26,46 @@\n \n import picard.util.MathUtil;\n \n-import static java.lang.Math.log10;\n-\n /**\n  * Represents the probability of the underlying haplotype using log likelihoods as the basic datum for each of the SNPs. By convention the\n  * alleles stored for each SNP are in phase.\n  *\n  * @author Tim Fennell\n  * @author Yossi Farjoun\n  */\n-abstract class HaplotypeProbabilitiesUsingLogLikelihoods extends HaplotypeProbabilities {\n+abstract class HaplotypeProbabilitiesUsingLogLikelihoods extends HaplotypeProbabilities implements Cloneable {\n \n     // some derived classes might need to incorporate accumulated data before logLikelihood is usable.\n     // use the getter to allow these classes to calculate the likelihood from the data.\n-    private final double[] loglikelihoods = new double[Genotype.values().length];\n+    // not final so that clone works\n+    private double[] loglikelihoods = new double[Genotype.values().length];\n+\n     private boolean likelihoodsNeedUpdating = true;\n \n     // stored in order to reduce computation we store these partial results.\n     // they need to be recalculated if loglikelihoodNeedsUpdating\n+\n     private double[] likelihoods = new double[Genotype.values().length];\n     private double[] posteriorProbabilities = new double[Genotype.values().length];\n-    private double[] shiftedLogPosteriors = new double[Genotype.values().length];\n \n+    //normalized (likeihood * prior / normalization_factor)\n+    private double[] shiftedLogPosteriors = new double[Genotype.values().length];\n \n     public HaplotypeProbabilitiesUsingLogLikelihoods(final HaplotypeBlock haplotypeBlock) {\n         super(haplotypeBlock);\n     }\n \n+    @Override\n+    public Object clone() throws CloneNotSupportedException {\n+        final HaplotypeProbabilitiesUsingLogLikelihoods c = (HaplotypeProbabilitiesUsingLogLikelihoods)super.clone();\n+        c.likelihoods = this.likelihoods.clone();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NTMwOA=="}, "originalCommit": {"oid": "685c7ced92998c718b381a551e6edf8bfe8eddd9"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTg0NDIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotype.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODo0MjoxNVrOFiwPjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODo0MjoxNVrOFiwPjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NjMxOA==", "bodyText": "more whitespace, please\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    System.arraycopy(likelihoods,0,c.likelihoods,0,likelihoods.length);\n          \n          \n            \n                    System.arraycopy(likelihoods, 0, c.likelihoods, 0, likelihoods.length);", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r371986318", "createdAt": "2020-01-28T18:42:15Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotype.java", "diffHunk": "@@ -28,10 +28,17 @@\n  * Represents a set of HaplotypeProbabilities that were derived from a single SNP\n  * genotype at a point in time.\n  */\n-public class HaplotypeProbabilitiesFromGenotype extends HaplotypeProbabilities {\n+public class HaplotypeProbabilitiesFromGenotype extends HaplotypeProbabilities implements Cloneable{\n     private final Snp snp;\n     private final double[] likelihoods;\n \n+    @Override\n+    public Object clone() throws CloneNotSupportedException {\n+        HaplotypeProbabilitiesFromGenotype c = (HaplotypeProbabilitiesFromGenotype) super.clone();\n+        System.arraycopy(likelihoods,0,c.likelihoods,0,likelihoods.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685c7ced92998c718b381a551e6edf8bfe8eddd9"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzExMzM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0MTo1MFrOFjPgnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0MTo1MFrOFjPgnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5ODU4OQ==", "bodyText": "I don't think assert is what you want here, since they have no effect unless the code is run with the -ea flag. E.g. if you had a unit test that tried to trigger this assert, it would fail.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372498589", "createdAt": "2020-01-29T16:41:50Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -190,17 +188,19 @@ void assertSnpPartOfHaplotype(final Snp snp) {\n \n     public double scaledEvidenceProbabilityUsingGenotypeFrequencies(final double[] genotypeFrequencies) {\n         final double[] likelihoods = getLikelihoods();\n-        assert (genotypeFrequencies.length == likelihoods.length);\n+        assert (genotypeFrequencies.length == nGeno);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzExNDcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0MjoxMVrOFjPhaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0MjoxMVrOFjPhaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5ODc5NQ==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Genotype g: Genotype.values()){\n          \n          \n            \n                    for (Genotype g : Genotype.values()) {", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372498795", "createdAt": "2020-01-29T16:42:11Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -190,17 +188,19 @@ void assertSnpPartOfHaplotype(final Snp snp) {\n \n     public double scaledEvidenceProbabilityUsingGenotypeFrequencies(final double[] genotypeFrequencies) {\n         final double[] likelihoods = getLikelihoods();\n-        assert (genotypeFrequencies.length == likelihoods.length);\n+        assert (genotypeFrequencies.length == nGeno);\n+        assert (likelihoods.length == nGeno);\n+\n \n         double result = 0;\n-        for (int i = 0; i < likelihoods.length; ++i) {\n-            result += likelihoods[i] * genotypeFrequencies[i];\n+        for (Genotype g: Genotype.values()){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzEyMzU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0NDozNFrOFjPm4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMjo0Nzo0N1rOFjptPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMDE5NQ==", "bodyText": "Is this done because performance was measured and you found that using values().length each time was too slow? It seems like in most cases this wouldn't have a measurable benefit.\nIf you keep it, it should be all caps as it's a static\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static final int nGeno = Genotype.values().length;\n          \n          \n            \n                static final int NUM_GENOTYPE = Genotype.values().length;", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372500195", "createdAt": "2020-01-29T16:44:34Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -272,4 +274,5 @@ public double getLodMostProbableGenotype() {\n             this.v = v;\n         }\n     }\n+    static final int nGeno = Genotype.values().length;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkyNzgwNg==", "bodyText": "not performance, just readability and writability", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372927806", "createdAt": "2020-01-30T12:47:47Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -272,4 +274,5 @@ public double getLodMostProbableGenotype() {\n             this.v = v;\n         }\n     }\n+    static final int nGeno = Genotype.values().length;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMDE5NQ=="}, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzEyNzI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0NTozNVrOFjPpRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0NTozNVrOFjPpRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMDgwNQ==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public HaplotypeProbabilitiesFromContaminatorSequence(HaplotypeProbabilitiesFromContaminatorSequence other){\n          \n          \n            \n                public HaplotypeProbabilitiesFromContaminatorSequence(HaplotypeProbabilitiesFromContaminatorSequence other) {", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372500805", "createdAt": "2020-01-29T16:45:35Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "diffHunk": "@@ -53,10 +59,18 @@ public HaplotypeProbabilitiesFromContaminatorSequence(final HaplotypeBlock haplo\n         this.contamination = contamination;\n     }\n \n-    /**\n-     * Adds a base observation with the observed quality to the evidence for this haplotype\n-     * based on the fact that the SNP is part of the haplotype.\n-     */\n+    public HaplotypeProbabilitiesFromContaminatorSequence(HaplotypeProbabilitiesFromContaminatorSequence other){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzEyOTU0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0NjoxMVrOFjPqsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMjo1MDoxMFrOFjpw_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMTE2OA==", "bodyText": "I would use covariant return types here so you can write\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public HaplotypeProbabilities deepCopy() {\n          \n          \n            \n                public HaplotypeProbabilitiesFromContaminatorSequence deepCopy() {", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372501168", "createdAt": "2020-01-29T16:46:11Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "diffHunk": "@@ -90,16 +104,21 @@ public void addToProbs(final Snp snp, final byte base, final byte qual) {\n \n     //a function needed to update the logLikelihoods from the likelihoodMap.\n     private void updateLikelihoods() {\n-        final double[] ll = new double[Genotype.values().length];\n+        final double[] ll = new double[nGeno];\n         for (final Genotype contGeno : Genotype.values()) {\n             // p(a | g_c) = \\sum_g_m { P(g_m) \\prod_i P(a_i| g_m, g_c)}\n-            ll[contGeno.v] = log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n+            ll[contGeno.v] = Math.log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n         }\n         setLogLikelihoods(ll);\n     }\n \n     @Override\n-    public void merge(final HaplotypeProbabilities other) {\n+    public HaplotypeProbabilities deepCopy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkyODc2NA==", "bodyText": "I didn't know you can do that when @Overrideing...thanks!", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372928764", "createdAt": "2020-01-30T12:50:10Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "diffHunk": "@@ -90,16 +104,21 @@ public void addToProbs(final Snp snp, final byte base, final byte qual) {\n \n     //a function needed to update the logLikelihoods from the likelihoodMap.\n     private void updateLikelihoods() {\n-        final double[] ll = new double[Genotype.values().length];\n+        final double[] ll = new double[nGeno];\n         for (final Genotype contGeno : Genotype.values()) {\n             // p(a | g_c) = \\sum_g_m { P(g_m) \\prod_i P(a_i| g_m, g_c)}\n-            ll[contGeno.v] = log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n+            ll[contGeno.v] = Math.log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n         }\n         setLogLikelihoods(ll);\n     }\n \n     @Override\n-    public void merge(final HaplotypeProbabilities other) {\n+    public HaplotypeProbabilities deepCopy() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMTE2OA=="}, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzEzMTY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0Njo0N1rOFjPsBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMjo1NDozNlrOFjp4Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMTUwOQ==", "bodyText": "This can also use covariant return types", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372501509", "createdAt": "2020-01-29T16:46:47Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "diffHunk": "@@ -90,16 +104,21 @@ public void addToProbs(final Snp snp, final byte base, final byte qual) {\n \n     //a function needed to update the logLikelihoods from the likelihoodMap.\n     private void updateLikelihoods() {\n-        final double[] ll = new double[Genotype.values().length];\n+        final double[] ll = new double[nGeno];\n         for (final Genotype contGeno : Genotype.values()) {\n             // p(a | g_c) = \\sum_g_m { P(g_m) \\prod_i P(a_i| g_m, g_c)}\n-            ll[contGeno.v] = log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n+            ll[contGeno.v] = Math.log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n         }\n         setLogLikelihoods(ll);\n     }\n \n     @Override\n-    public void merge(final HaplotypeProbabilities other) {\n+    public HaplotypeProbabilities deepCopy() {\n+        return new HaplotypeProbabilitiesFromContaminatorSequence(this);\n+    }\n+\n+    @Override\n+    public HaplotypeProbabilities merge(final HaplotypeProbabilities other) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzMDYzOQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372930639", "createdAt": "2020-01-30T12:54:36Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "diffHunk": "@@ -90,16 +104,21 @@ public void addToProbs(final Snp snp, final byte base, final byte qual) {\n \n     //a function needed to update the logLikelihoods from the likelihoodMap.\n     private void updateLikelihoods() {\n-        final double[] ll = new double[Genotype.values().length];\n+        final double[] ll = new double[nGeno];\n         for (final Genotype contGeno : Genotype.values()) {\n             // p(a | g_c) = \\sum_g_m { P(g_m) \\prod_i P(a_i| g_m, g_c)}\n-            ll[contGeno.v] = log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n+            ll[contGeno.v] = Math.log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n         }\n         setLogLikelihoods(ll);\n     }\n \n     @Override\n-    public void merge(final HaplotypeProbabilities other) {\n+    public HaplotypeProbabilities deepCopy() {\n+        return new HaplotypeProbabilitiesFromContaminatorSequence(this);\n+    }\n+\n+    @Override\n+    public HaplotypeProbabilities merge(final HaplotypeProbabilities other) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMTUwOQ=="}, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE0MTI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotype.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0OTozNlrOFjPyRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0OTozNlrOFjPyRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMzExMQ==", "bodyText": "why not\nwhy not\n\n    this(snp, getHaplotype(), likelihoods[0], likelihoods[1], likelihoods[2]);", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372503111", "createdAt": "2020-01-29T16:49:36Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotype.java", "diffHunk": "@@ -24,13 +24,26 @@\n \n package picard.fingerprint;\n \n+import java.util.Arrays;\n+\n /**\n  * Represents a set of HaplotypeProbabilities that were derived from a single SNP\n  * genotype at a point in time.\n  */\n public class HaplotypeProbabilitiesFromGenotype extends HaplotypeProbabilities {\n     private final Snp snp;\n-    private final double[] likelihoods;\n+    private double[] likelihoods;\n+\n+    @Override\n+    public HaplotypeProbabilities deepCopy()  {\n+        return new HaplotypeProbabilitiesFromGenotype(this);\n+    }\n+\n+    public HaplotypeProbabilitiesFromGenotype(final HaplotypeProbabilitiesFromGenotype other){\n+        super(other.getHaplotype());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE0MjM4OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotype.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0OTo1NlrOFjPzBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0OTo1NlrOFjPzBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMzMwMg==", "bodyText": "It looks like this can be final", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372503302", "createdAt": "2020-01-29T16:49:56Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotype.java", "diffHunk": "@@ -24,13 +24,26 @@\n \n package picard.fingerprint;\n \n+import java.util.Arrays;\n+\n /**\n  * Represents a set of HaplotypeProbabilities that were derived from a single SNP\n  * genotype at a point in time.\n  */\n public class HaplotypeProbabilitiesFromGenotype extends HaplotypeProbabilities {\n     private final Snp snp;\n-    private final double[] likelihoods;\n+    private double[] likelihoods;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE0NTU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotypeLikelihoods.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1MDo1MlrOFjP1Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1MDo1MlrOFjP1Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMzgyMg==", "bodyText": "why not\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < alleles.size(); i++) {\n          \n          \n            \n                    for (allele : alleles) {", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372503822", "createdAt": "2020-01-29T16:50:52Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotypeLikelihoods.java", "diffHunk": "@@ -54,11 +58,11 @@ public void addToLogLikelihoods(final Snp snp, final List<Allele> alleles, final\n         assertSnpPartOfHaplotype(snp);\n \n         // only allow biallelic snps\n-        assert (logGenotypeLikelihoods.length == Genotype.values().length);\n+        assert (logGenotypeLikelihoods.length == nGeno);\n         assert (alleles.size() == 2);\n \n         //make sure that alleles are comparable to SNPs\n-        for (int i = 0; i < 2; i++) {\n+        for (int i = 0; i < alleles.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE0NjU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotypeLikelihoods.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1MToxMlrOFjP1vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1MToxMlrOFjP1vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMzk5OQ==", "bodyText": "As I said above I don't think this has any effect in practice.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372503999", "createdAt": "2020-01-29T16:51:12Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotypeLikelihoods.java", "diffHunk": "@@ -54,11 +58,11 @@ public void addToLogLikelihoods(final Snp snp, final List<Allele> alleles, final\n         assertSnpPartOfHaplotype(snp);\n \n         // only allow biallelic snps\n-        assert (logGenotypeLikelihoods.length == Genotype.values().length);\n+        assert (logGenotypeLikelihoods.length == nGeno);\n         assert (alleles.size() == 2);\n \n         //make sure that alleles are comparable to SNPs\n-        for (int i = 0; i < 2; i++) {\n+        for (int i = 0; i < alleles.size(); i++) {\n             assert (alleles.get(i).getBases().length == 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE0ODc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromSequence.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1MTo0OVrOFjP3MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1MTo0OVrOFjP3MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNDM2OA==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this(other.getHaplotype() , other.obsAllele1,other.obsAllele2,other.obsAlleleOther);\n          \n          \n            \n                    this(other.getHaplotype(), other.obsAllele1, other.obsAllele2, other.obsAlleleOther);", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372504368", "createdAt": "2020-01-29T16:51:49Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromSequence.java", "diffHunk": "@@ -36,10 +35,21 @@\n public class HaplotypeProbabilitiesFromSequence extends HaplotypeProbabilitiesUsingLogLikelihoods {\n     protected int obsAllele1, obsAllele2, obsAlleleOther;\n \n+    HaplotypeProbabilitiesFromSequence(final HaplotypeBlock haplotypeBlock, int ob1, int ob2, int obOther) {\n+        this(haplotypeBlock);\n+        obsAllele1 = ob1;\n+        obsAllele2 = ob2;\n+        obsAlleleOther = obOther;\n+    }\n+\n     public HaplotypeProbabilitiesFromSequence(final HaplotypeBlock haplotypeBlock) {\n         super(haplotypeBlock);\n     }\n \n+    public HaplotypeProbabilitiesFromSequence(final HaplotypeProbabilitiesFromSequence other) {\n+        this(other.getHaplotype() , other.obsAllele1,other.obsAllele2,other.obsAlleleOther);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE2MTEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilityOfNormalGivenTumor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1NToxOFrOFjP_Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1NToxOFrOFjP_Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNjQwMg==", "bodyText": "This seems dangerous to me. For one, it's not thread safe. It also introduces state which is never cleared, e.g. a memory leak, if the code is ever used in a non-CLP situation.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372506402", "createdAt": "2020-01-29T16:55:18Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilityOfNormalGivenTumor.java", "diffHunk": "@@ -51,12 +58,13 @@ public TransitionMatrix(double pLoH) {\n                     {0, 0, 1}}; //normal is hom_var => tumor must be the same\n         }\n \n-        public double[][] getTransitionMatrix() {\n+        double[][] getTransitionMatrix() {\n             return transitionMatrix;\n         }\n     }\n \n     private final HaplotypeProbabilities hpOfTumor;\n+    @SuppressWarnings(\"MismatchedQueryAndUpdateOfCollection\")\n     static private Map<Double, TransitionMatrix> transitionMatrixMap = new CollectionUtil.DefaultingMap<>(TransitionMatrix::new, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE2NjY1OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/util/MiscTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1Njo0N1rOFjQCpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzoxMDozMlrOFjqTrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNzMwMg==", "bodyText": "What is this testing? It doesn't cover any code that we've written. It can't assert anything about the behavior of a system picard will be run on, only the behavior of the system where the test is run.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372507302", "createdAt": "2020-01-29T16:56:47Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/util/MiscTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package picard.util;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+\n+public class MiscTest {\n+\n+    @Test\n+    public void canWriteToDevNull() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzNzI5Ng==", "bodyText": "This was at the bottom of the Fingerprinting test for some reason...so I moved it out....I think that at some point in the past there were questions about the ability to write to /dev/null and so a test was added (possibly by me) in the wrong place...", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372937296", "createdAt": "2020-01-30T13:09:42Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/util/MiscTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package picard.util;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+\n+public class MiscTest {\n+\n+    @Test\n+    public void canWriteToDevNull() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNzMwMg=="}, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzNzY0NQ==", "bodyText": "Ah, I see the problem..I forgot to remove it from where I found it..so it looks like I just added it out of the blue...", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372937645", "createdAt": "2020-01-30T13:10:32Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/util/MiscTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package picard.util;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+\n+public class MiscTest {\n+\n+    @Test\n+    public void canWriteToDevNull() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNzMwMg=="}, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE3MTQ4OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/util/MiscTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1ODowOVrOFjQFyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzoxMDo0MVrOFjqT8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwODEwNA==", "bodyText": "If you really want to do this, it would be simpler to write\nFiles.write(Paths.get(\"/dev/null\"), \"Just a test\".getBytes());", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372508104", "createdAt": "2020-01-29T16:58:09Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/util/MiscTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package picard.util;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+\n+public class MiscTest {\n+\n+    @Test\n+    public void canWriteToDevNull() throws IOException {\n+        File f = new File(\"/dev/null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzNzcxNQ==", "bodyText": "not new code.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372937715", "createdAt": "2020-01-30T13:10:41Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/util/MiscTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package picard.util;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+\n+public class MiscTest {\n+\n+    @Test\n+    public void canWriteToDevNull() throws IOException {\n+        File f = new File(\"/dev/null\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwODEwNA=="}, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE3Nzg0OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1OTo1OVrOFjQJ4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDozODoxN1rOFlWUwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwOTE1Mw==", "bodyText": "I think a more idiomatic way to write this is\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();\n          \n          \n            \n                    final Path na12891_r1 = Paths.get(TEST_DATA_DIR).resolve(\"NA12891.over.fingerprints.r1.sam\");", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372509153", "createdAt": "2020-01-29T16:59:59Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -223,6 +229,145 @@ public void testQueryable(final File vcf, boolean expectedQueryable) {\n         }\n     }\n \n+\n+    @DataProvider()\n+    Object[][] mergeIsDafeProvider() {\n+        return new Object[][]{\n+                new Object[]{new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D)},\n+                new Object[]{\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), .05),\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D), 0.05)},\n+                new Object[]{new HaplotypeProbabilitiesFromSequence(hb, 5, 0, 1), new HaplotypeProbabilitiesFromSequence(hb, 3, 2, 1)},\n+                new Object[]{new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 0, 1), new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 1, 0)},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeHaplotypeProbabilitiesIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final HaplotypeProbabilities merged1 = hp1.deepCopy().merge(hp2);\n+        final HaplotypeProbabilities merged2 = hp1.deepCopy().merge(hp2);\n+\n+        Assert.assertEquals(merged1.getLikelihoods(),merged2.getLikelihoods());\n+    }\n+\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeFingerprintIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final Fingerprint fpA = new Fingerprint(\"test2\",null,\"none\");\n+        final Fingerprint fpB = new Fingerprint(\"test2\",null,\"none\");\n+\n+        final Fingerprint fp1 = new Fingerprint(\"test1\",null,\"none\");\n+        fp1.add(hp1);\n+\n+        final Fingerprint fp2 = new Fingerprint(\"test1\",null,\"none\");\n+        fp2.add(hp2);\n+\n+        fpA.merge(fp1);\n+        fpB.merge(fp1);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+\n+        fpA.merge(fp2);\n+        fpB.merge(fp2);\n+        fpB.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertNotEquals(fpA.get(hb), fpB.get(hb));\n+        }\n+\n+        fpA.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testMergeIsSafeFromSequence() {\n+        final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzOTA0Nw==", "bodyText": "since TEST_DATA_DIR is a File, it's actually more lengthy as I need to stick a getAbsoluteFileName() in there as well....I'll do it if you prefer though.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372939047", "createdAt": "2020-01-30T13:13:42Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -223,6 +229,145 @@ public void testQueryable(final File vcf, boolean expectedQueryable) {\n         }\n     }\n \n+\n+    @DataProvider()\n+    Object[][] mergeIsDafeProvider() {\n+        return new Object[][]{\n+                new Object[]{new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D)},\n+                new Object[]{\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), .05),\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D), 0.05)},\n+                new Object[]{new HaplotypeProbabilitiesFromSequence(hb, 5, 0, 1), new HaplotypeProbabilitiesFromSequence(hb, 3, 2, 1)},\n+                new Object[]{new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 0, 1), new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 1, 0)},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeHaplotypeProbabilitiesIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final HaplotypeProbabilities merged1 = hp1.deepCopy().merge(hp2);\n+        final HaplotypeProbabilities merged2 = hp1.deepCopy().merge(hp2);\n+\n+        Assert.assertEquals(merged1.getLikelihoods(),merged2.getLikelihoods());\n+    }\n+\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeFingerprintIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final Fingerprint fpA = new Fingerprint(\"test2\",null,\"none\");\n+        final Fingerprint fpB = new Fingerprint(\"test2\",null,\"none\");\n+\n+        final Fingerprint fp1 = new Fingerprint(\"test1\",null,\"none\");\n+        fp1.add(hp1);\n+\n+        final Fingerprint fp2 = new Fingerprint(\"test1\",null,\"none\");\n+        fp2.add(hp2);\n+\n+        fpA.merge(fp1);\n+        fpB.merge(fp1);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+\n+        fpA.merge(fp2);\n+        fpB.merge(fp2);\n+        fpB.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertNotEquals(fpA.get(hb), fpB.get(hb));\n+        }\n+\n+        fpA.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testMergeIsSafeFromSequence() {\n+        final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwOTE1Mw=="}, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcwNzM5NA==", "bodyText": "Oh, I thought it was String. If it's File then you can write:\n        final Path na12891_r1 = TEST_DATA_DIR.toPath().resolve(\"NA12891.over.fingerprints.r1.sam\");\n\nI don't know why you'd need to use getAbsoluteFileName() in this code.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374707394", "createdAt": "2020-02-04T14:38:17Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -223,6 +229,145 @@ public void testQueryable(final File vcf, boolean expectedQueryable) {\n         }\n     }\n \n+\n+    @DataProvider()\n+    Object[][] mergeIsDafeProvider() {\n+        return new Object[][]{\n+                new Object[]{new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D)},\n+                new Object[]{\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), .05),\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D), 0.05)},\n+                new Object[]{new HaplotypeProbabilitiesFromSequence(hb, 5, 0, 1), new HaplotypeProbabilitiesFromSequence(hb, 3, 2, 1)},\n+                new Object[]{new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 0, 1), new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 1, 0)},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeHaplotypeProbabilitiesIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final HaplotypeProbabilities merged1 = hp1.deepCopy().merge(hp2);\n+        final HaplotypeProbabilities merged2 = hp1.deepCopy().merge(hp2);\n+\n+        Assert.assertEquals(merged1.getLikelihoods(),merged2.getLikelihoods());\n+    }\n+\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeFingerprintIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final Fingerprint fpA = new Fingerprint(\"test2\",null,\"none\");\n+        final Fingerprint fpB = new Fingerprint(\"test2\",null,\"none\");\n+\n+        final Fingerprint fp1 = new Fingerprint(\"test1\",null,\"none\");\n+        fp1.add(hp1);\n+\n+        final Fingerprint fp2 = new Fingerprint(\"test1\",null,\"none\");\n+        fp2.add(hp2);\n+\n+        fpA.merge(fp1);\n+        fpB.merge(fp1);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+\n+        fpA.merge(fp2);\n+        fpB.merge(fp2);\n+        fpB.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertNotEquals(fpA.get(hb), fpB.get(hb));\n+        }\n+\n+        fpA.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testMergeIsSafeFromSequence() {\n+        final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwOTE1Mw=="}, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE4MzAxOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNzowMTozMlrOFjQNRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNzowMTozMlrOFjQNRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUxMDAyMw==", "bodyText": "In general, if you have an assert in a for, you need to assert that the thing you're looping over has at least one item, otherwise the test will pass when the for never executes.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372510023", "createdAt": "2020-01-29T17:01:32Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -223,6 +229,145 @@ public void testQueryable(final File vcf, boolean expectedQueryable) {\n         }\n     }\n \n+\n+    @DataProvider()\n+    Object[][] mergeIsDafeProvider() {\n+        return new Object[][]{\n+                new Object[]{new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D)},\n+                new Object[]{\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), .05),\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D), 0.05)},\n+                new Object[]{new HaplotypeProbabilitiesFromSequence(hb, 5, 0, 1), new HaplotypeProbabilitiesFromSequence(hb, 3, 2, 1)},\n+                new Object[]{new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 0, 1), new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 1, 0)},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeHaplotypeProbabilitiesIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final HaplotypeProbabilities merged1 = hp1.deepCopy().merge(hp2);\n+        final HaplotypeProbabilities merged2 = hp1.deepCopy().merge(hp2);\n+\n+        Assert.assertEquals(merged1.getLikelihoods(),merged2.getLikelihoods());\n+    }\n+\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeFingerprintIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final Fingerprint fpA = new Fingerprint(\"test2\",null,\"none\");\n+        final Fingerprint fpB = new Fingerprint(\"test2\",null,\"none\");\n+\n+        final Fingerprint fp1 = new Fingerprint(\"test1\",null,\"none\");\n+        fp1.add(hp1);\n+\n+        final Fingerprint fp2 = new Fingerprint(\"test1\",null,\"none\");\n+        fp2.add(hp2);\n+\n+        fpA.merge(fp1);\n+        fpB.merge(fp1);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+\n+        fpA.merge(fp2);\n+        fpB.merge(fp2);\n+        fpB.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertNotEquals(fpA.get(hb), fpB.get(hb));\n+        }\n+\n+        fpA.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testMergeIsSafeFromSequence() {\n+        final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();\n+        final Path na12891_r2 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r2.sam\").toPath();\n+        final Path na12892_r1 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.r1.sam\").toPath();\n+        final Path na12892_r2 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.r2.sam\").toPath();\n+\n+        final List<Path> listOfFiles = Arrays.asList(na12891_r1, na12891_r2, na12892_r1, na12892_r2);\n+\n+        final FingerprintChecker checker = new FingerprintChecker(SUBSETTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = checker.fingerprintFiles(listOfFiles, 1, 0, TimeUnit.DAYS);\n+\n+        final Fingerprint combinedFp = new Fingerprint(\"test\", null, null);\n+        fingerprintIdDetailsFingerprintMap.values().forEach(combinedFp::merge);\n+\n+        final Fingerprint combinedFp2 = new Fingerprint(\"test2\", null, null);\n+        fingerprintIdDetailsFingerprintMap.values().forEach(combinedFp2::merge);\n+\n+        for (final HaplotypeBlock block : combinedFp.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzM2MjgxOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo0MToyOVrOFlWcYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo0MToyOVrOFlWcYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcwOTM0Ng==", "bodyText": "Using Objects.equals(haplotypeBlock, that.haplotypeBlock) would help here.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374709346", "createdAt": "2020-02-04T14:41:29Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -63,7 +64,29 @@ public HaplotypeBlock getHaplotype() {\n      * Returns the posterior probabilities using the population frequency as a prior.\n      */\n     public double[] getPosteriorProbabilities() {\n-        return pNormalizeVector(multiply(getLikelihoods(), getPriorProbablities()));\n+        return MathUtil.pNormalizeVector(MathUtil.multiply(getLikelihoods(), getPriorProbablities()));\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        final HaplotypeProbabilities that = (HaplotypeProbabilities) o;\n+\n+        if (haplotypeBlock != null ? !haplotypeBlock.equals(that.haplotypeBlock) : that.haplotypeBlock != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzM4NDYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo0Njo1NFrOFlWp9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTo1MjowM1rOFmIdIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMjgyMw==", "bodyText": "This seems like a bug, that equals() uses getLikelihoods() but hashCode() does not.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374712823", "createdAt": "2020-02-04T14:46:54Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -63,7 +64,29 @@ public HaplotypeBlock getHaplotype() {\n      * Returns the posterior probabilities using the population frequency as a prior.\n      */\n     public double[] getPosteriorProbabilities() {\n-        return pNormalizeVector(multiply(getLikelihoods(), getPriorProbablities()));\n+        return MathUtil.pNormalizeVector(MathUtil.multiply(getLikelihoods(), getPriorProbablities()));\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        final HaplotypeProbabilities that = (HaplotypeProbabilities) o;\n+\n+        if (haplotypeBlock != null ? !haplotypeBlock.equals(that.haplotypeBlock) : that.haplotypeBlock != null) {\n+            return false;\n+        }\n+        return Arrays.equals(getLikelihoods(), that.getLikelihoods());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return haplotypeBlock != null ? haplotypeBlock.hashCode() : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc2NzY5Mg==", "bodyText": "yeah...this is on purpose since likelihood is mutable...I figured it's better to not use it in the hash, but I need it in the equals...", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374767692", "createdAt": "2020-02-04T16:09:51Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -63,7 +64,29 @@ public HaplotypeBlock getHaplotype() {\n      * Returns the posterior probabilities using the population frequency as a prior.\n      */\n     public double[] getPosteriorProbabilities() {\n-        return pNormalizeVector(multiply(getLikelihoods(), getPriorProbablities()));\n+        return MathUtil.pNormalizeVector(MathUtil.multiply(getLikelihoods(), getPriorProbablities()));\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        final HaplotypeProbabilities that = (HaplotypeProbabilities) o;\n+\n+        if (haplotypeBlock != null ? !haplotypeBlock.equals(that.haplotypeBlock) : that.haplotypeBlock != null) {\n+            return false;\n+        }\n+        return Arrays.equals(getLikelihoods(), that.getLikelihoods());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return haplotypeBlock != null ? haplotypeBlock.hashCode() : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMjgyMw=="}, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyODczOQ==", "bodyText": "OK, that's fine, it's true that you can hash two non-equal objects to the same value.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r375528739", "createdAt": "2020-02-05T21:52:03Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -63,7 +64,29 @@ public HaplotypeBlock getHaplotype() {\n      * Returns the posterior probabilities using the population frequency as a prior.\n      */\n     public double[] getPosteriorProbabilities() {\n-        return pNormalizeVector(multiply(getLikelihoods(), getPriorProbablities()));\n+        return MathUtil.pNormalizeVector(MathUtil.multiply(getLikelihoods(), getPriorProbablities()));\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        final HaplotypeProbabilities that = (HaplotypeProbabilities) o;\n+\n+        if (haplotypeBlock != null ? !haplotypeBlock.equals(that.haplotypeBlock) : that.haplotypeBlock != null) {\n+            return false;\n+        }\n+        return Arrays.equals(getLikelihoods(), that.getLikelihoods());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return haplotypeBlock != null ? haplotypeBlock.hashCode() : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMjgyMw=="}, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzM4NTE0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo0NzowMlrOFlWqPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNjoxODo0MlrOFlaWLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMjg5Mg==", "bodyText": "Is it required that HaplotypeProbabilities is hash-able and comparable? This means that all subclasses must properly implement these too.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374712892", "createdAt": "2020-02-04T14:47:02Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -63,7 +64,29 @@ public HaplotypeBlock getHaplotype() {\n      * Returns the posterior probabilities using the population frequency as a prior.\n      */\n     public double[] getPosteriorProbabilities() {\n-        return pNormalizeVector(multiply(getLikelihoods(), getPriorProbablities()));\n+        return MathUtil.pNormalizeVector(MathUtil.multiply(getLikelihoods(), getPriorProbablities()));\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc3MzI5NQ==", "bodyText": "hmmm.\nI use it for testing....I guess I could make a utility function that compares? would that be preferable since I only need it for testing?", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374773295", "createdAt": "2020-02-04T16:18:42Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -63,7 +64,29 @@ public HaplotypeBlock getHaplotype() {\n      * Returns the posterior probabilities using the population frequency as a prior.\n      */\n     public double[] getPosteriorProbabilities() {\n-        return pNormalizeVector(multiply(getLikelihoods(), getPriorProbablities()));\n+        return MathUtil.pNormalizeVector(MathUtil.multiply(getLikelihoods(), getPriorProbablities()));\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMjg5Mg=="}, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzM4OTAzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo0Nzo1NVrOFlWspA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo0Nzo1NVrOFlWspA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMzUwOA==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ValidationUtils.validateArg(genotypeFrequencies.length == NUM_GENOTYPES,\"provided genotype frequencies must be length 3\");\n          \n          \n            \n                    ValidationUtils.validateArg(genotypeFrequencies.length == NUM_GENOTYPES, \"provided genotype frequencies must be length 3\");", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374713508", "createdAt": "2020-02-04T14:47:55Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -190,17 +213,18 @@ void assertSnpPartOfHaplotype(final Snp snp) {\n \n     public double scaledEvidenceProbabilityUsingGenotypeFrequencies(final double[] genotypeFrequencies) {\n         final double[] likelihoods = getLikelihoods();\n-        assert (genotypeFrequencies.length == likelihoods.length);\n+        ValidationUtils.validateArg(genotypeFrequencies.length == NUM_GENOTYPES,\"provided genotype frequencies must be length 3\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzM5MDQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo0ODoxNlrOFlWtgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo0ODoxNlrOFlWtgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMzcyOA==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ValidationUtils.validateArg(contamination <= 1.0, ()->\"contamination must be <=1, found \" + contamination);\n          \n          \n            \n                    ValidationUtils.validateArg(contamination <= 1.0, () -> \"contamination must be <=1, found \" + contamination);", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374713728", "createdAt": "2020-02-04T14:48:16Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "diffHunk": "@@ -42,21 +41,31 @@\n \n     // for each model (contGenotype, mainGenotype) there's a likelihood of the data. These need to be collected separately\n     // and only collated once all the data is in.\n-    double[][] likelihoodMap = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n+    private final double[][] likelihoodMap = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n \n     public HaplotypeProbabilitiesFromContaminatorSequence(final HaplotypeBlock haplotypeBlock, final double contamination) {\n         super(haplotypeBlock);\n \n-        assert (contamination <= 1.0);\n-        assert (contamination >= 0.0);\n+        ValidationUtils.validateArg(contamination <= 1.0, ()->\"contamination must be <=1, found \" + contamination);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNzQzNDQwOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/CrosscheckReadGroupFingerprintsTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo1OToxMlrOFlXJAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNjoxMzo0NlrOFlaJuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyMDc2OQ==", "bodyText": "Does this annotation do anything? If it's a no-op it can be removed.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374720769", "createdAt": "2020-02-04T14:59:12Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CrosscheckReadGroupFingerprintsTest.java", "diffHunk": "@@ -102,7 +102,8 @@ public void testCrossCheckRGs(final File file1, final File file2, final boolean\n         doTest(args, metrics, expectedRetVal, expectedNMetrics * expectedNMetrics , CrosscheckMetric.DataType.READGROUP, expectAllMatch);\n     }\n \n-    @DataProvider(name = \"bamFilesLBs\")\n+\n+    @DataProvider()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc2OTgxOQ==", "bodyText": "without the \"name\" the default is the name of the function itself....so, yes it is providing data...", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374769819", "createdAt": "2020-02-04T16:13:18Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/fingerprint/CrosscheckReadGroupFingerprintsTest.java", "diffHunk": "@@ -102,7 +102,8 @@ public void testCrossCheckRGs(final File file1, final File file2, final boolean\n         doTest(args, metrics, expectedRetVal, expectedNMetrics * expectedNMetrics , CrosscheckMetric.DataType.READGROUP, expectAllMatch);\n     }\n \n-    @DataProvider(name = \"bamFilesLBs\")\n+\n+    @DataProvider()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyMDc2OQ=="}, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc3MDEwNw==", "bodyText": "I guess I can remove the parens though", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374770107", "createdAt": "2020-02-04T16:13:46Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/fingerprint/CrosscheckReadGroupFingerprintsTest.java", "diffHunk": "@@ -102,7 +102,8 @@ public void testCrossCheckRGs(final File file1, final File file2, final boolean\n         doTest(args, metrics, expectedRetVal, expectedNMetrics * expectedNMetrics , CrosscheckMetric.DataType.READGROUP, expectAllMatch);\n     }\n \n-    @DataProvider(name = \"bamFilesLBs\")\n+\n+    @DataProvider()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyMDc2OQ=="}, "originalCommit": {"oid": "873979705895a8fabfbcd0c281add5e2b3224d6e"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjU0NzY0OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/FingerprintingTestUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTo1NDoyMlrOFmIhHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTo1NDoyMlrOFmIhHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTc1OQ==", "bodyText": "I think this is cleaner given that it's only used by a test. Also, can you reformat this file in the IDE? It's missing a few whitespaces.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r375529759", "createdAt": "2020-02-05T21:54:22Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintingTestUtils.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package picard.fingerprint;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class FingerprintingTestUtils {\n+\n+    public static boolean areHaplotypeProbabilitiesEqual(final HaplotypeProbabilities lhs, final HaplotypeProbabilities rhs){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0985e669414fd759812284a7c6c0d76e834b29a8"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjU1MTc2OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/FingerprintingTestUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTo1NTo0M1rOFmIjlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTo1NTo0M1rOFmIjlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMDM4OQ==", "bodyText": "Given that this is only used as an argument to assertTrue() you could add another static method  assertHaplotypeProbabilitiesEqual() which calls this one.\nOr assertFPHaplotypeProbabilitiesEqual(fp1, fp2) since that's how it's used.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r375530389", "createdAt": "2020-02-05T21:55:43Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintingTestUtils.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package picard.fingerprint;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class FingerprintingTestUtils {\n+\n+    public static boolean areHaplotypeProbabilitiesEqual(final HaplotypeProbabilities lhs, final HaplotypeProbabilities rhs){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0985e669414fd759812284a7c6c0d76e834b29a8"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjU2MDcxOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTo1ODo0OFrOFmIpQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowODo1MFrOFpZ4Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMTg0Mg==", "bodyText": "Does it make more sense to assert that its' the same as combinedFp2?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Assert.assertNotEquals(combinedFp.keySet().size(), 0);\n          \n          \n            \n                    Assert.assertEquals(combinedFp.keySet().size(), combinedFp2.size());\n          \n      \n    \n    \n  \n\nIn either case if you had an assert that compared Fingerprints then you can assert this there instead and avoid the duplication for each of the test cases here.", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r375531842", "createdAt": "2020-02-05T21:58:48Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -223,6 +230,173 @@ public void testQueryable(final File vcf, boolean expectedQueryable) {\n         }\n     }\n \n+    @DataProvider()\n+    Object[][] mergeIsDafeProvider() {\n+        final HaplotypeProbabilitiesFromSequence hp1 = new HaplotypeProbabilitiesFromSequence(hb);\n+        final HaplotypeProbabilitiesFromSequence hp2 = new HaplotypeProbabilitiesFromSequence(hb);\n+\n+        addObservation(hp1, hb, 5, hb.getFirstSnp().getAllele1());\n+        addObservation(hp1, hb, 1, (byte) (hb.getFirstSnp().getAllele1() + 1));\n+        addObservation(hp2, hb, 3, hb.getFirstSnp().getAllele1());\n+        addObservation(hp2, hb, 2, hb.getFirstSnp().getAllele2());\n+\n+        final HaplotypeProbabilitiesFromContaminatorSequence hpcs1 = new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1);\n+        final HaplotypeProbabilitiesFromContaminatorSequence hpcs2 = new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1);\n+\n+        addObservation(hpcs1, hb, 5, hb.getFirstSnp().getAllele1());\n+        addObservation(hpcs1, hb, 1, (byte)(hb.getFirstSnp().getAllele1()+1));\n+        addObservation(hpcs2, hb, 3, hb.getFirstSnp().getAllele1());\n+        addObservation(hpcs2, hb, 1, hb.getFirstSnp().getAllele1());\n+\n+\n+        return new Object[][]{\n+                new Object[]{new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D)},\n+                new Object[]{\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), .05),\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D), 0.05)},\n+                new Object[]{hp1,hp2},\n+                new Object[]{hpcs1,hpcs2},\n+        };\n+    }\n+\n+    private static void addObservation(final HaplotypeProbabilitiesFromSequence haplotypeProb, final HaplotypeBlock haplotypeBlock, final int count, final byte allele) {\n+        for (int i = 0; i < count; i++) {\n+            haplotypeProb.addToProbs(haplotypeBlock.getFirstSnp(), allele, (byte) 30);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeHaplotypeProbabilitiesIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final HaplotypeProbabilities merged1 = hp1.deepCopy().merge(hp2);\n+        final HaplotypeProbabilities merged2 = hp1.deepCopy().merge(hp2);\n+\n+        Assert.assertEquals(merged1.getLikelihoods(),merged2.getLikelihoods());\n+    }\n+\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeFingerprintIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final Fingerprint fpA = new Fingerprint(\"test2\",null,\"none\");\n+        final Fingerprint fpB = new Fingerprint(\"test2\",null,\"none\");\n+\n+        final Fingerprint fp1 = new Fingerprint(\"test1\",null,\"none\");\n+        fp1.add(hp1);\n+\n+        final Fingerprint fp2 = new Fingerprint(\"test1\",null,\"none\");\n+        fp2.add(hp2);\n+\n+        fpA.merge(fp1);\n+        fpB.merge(fp1);\n+\n+        Assert.assertNotEquals(fpA.keySet().size(), 0);\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+\n+        fpA.merge(fp2);\n+        fpB.merge(fp2);\n+        fpB.merge(fp2);\n+\n+        Assert.assertNotEquals(fpA.keySet().size(), 0);\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertNotEquals(fpA.get(hb), fpB.get(hb));\n+        }\n+\n+        fpA.merge(fp2);\n+\n+        Assert.assertNotEquals(fpA.keySet().size(), 0);\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+    }\n+\n+    @Test\n+    public void testMergeIsSafeFromSequence() {\n+        final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();\n+        final Path na12891_r2 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r2.sam\").toPath();\n+        final Path na12892_r1 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.r1.sam\").toPath();\n+        final Path na12892_r2 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.r2.sam\").toPath();\n+\n+        final List<Path> listOfFiles = Arrays.asList(na12891_r1, na12891_r2, na12892_r1, na12892_r2);\n+        final FingerprintChecker checker = new FingerprintChecker(SUBSETTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = checker.fingerprintFiles(listOfFiles, 1, 0, TimeUnit.DAYS);\n+\n+        final Fingerprint combinedFp = new Fingerprint(\"test\", null, null);\n+        fingerprintIdDetailsFingerprintMap.values().forEach(combinedFp::merge);\n+\n+        final Fingerprint combinedFp2 = new Fingerprint(\"test2\", null, null);\n+        fingerprintIdDetailsFingerprintMap.values().forEach(combinedFp2::merge);\n+\n+        Assert.assertNotEquals(combinedFp.keySet().size(), 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0985e669414fd759812284a7c6c0d76e834b29a8"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTg3OA==", "bodyText": "Now that you've refactored into assertFingerPrintHPsAreEqual() this assert is no longer necessary, as the refactored code has the assert:\n        Assert.assertEquals(lhs.keySet().size(), rhs.keySet().size());\n\nOr, if you believe it is still necessary, you can move it into the refactored code, instead of repeating it before every call to assertFingerPrintHPsAreEqual().", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r378959878", "createdAt": "2020-02-13T16:08:50Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -223,6 +230,173 @@ public void testQueryable(final File vcf, boolean expectedQueryable) {\n         }\n     }\n \n+    @DataProvider()\n+    Object[][] mergeIsDafeProvider() {\n+        final HaplotypeProbabilitiesFromSequence hp1 = new HaplotypeProbabilitiesFromSequence(hb);\n+        final HaplotypeProbabilitiesFromSequence hp2 = new HaplotypeProbabilitiesFromSequence(hb);\n+\n+        addObservation(hp1, hb, 5, hb.getFirstSnp().getAllele1());\n+        addObservation(hp1, hb, 1, (byte) (hb.getFirstSnp().getAllele1() + 1));\n+        addObservation(hp2, hb, 3, hb.getFirstSnp().getAllele1());\n+        addObservation(hp2, hb, 2, hb.getFirstSnp().getAllele2());\n+\n+        final HaplotypeProbabilitiesFromContaminatorSequence hpcs1 = new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1);\n+        final HaplotypeProbabilitiesFromContaminatorSequence hpcs2 = new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1);\n+\n+        addObservation(hpcs1, hb, 5, hb.getFirstSnp().getAllele1());\n+        addObservation(hpcs1, hb, 1, (byte)(hb.getFirstSnp().getAllele1()+1));\n+        addObservation(hpcs2, hb, 3, hb.getFirstSnp().getAllele1());\n+        addObservation(hpcs2, hb, 1, hb.getFirstSnp().getAllele1());\n+\n+\n+        return new Object[][]{\n+                new Object[]{new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D)},\n+                new Object[]{\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), .05),\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D), 0.05)},\n+                new Object[]{hp1,hp2},\n+                new Object[]{hpcs1,hpcs2},\n+        };\n+    }\n+\n+    private static void addObservation(final HaplotypeProbabilitiesFromSequence haplotypeProb, final HaplotypeBlock haplotypeBlock, final int count, final byte allele) {\n+        for (int i = 0; i < count; i++) {\n+            haplotypeProb.addToProbs(haplotypeBlock.getFirstSnp(), allele, (byte) 30);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeHaplotypeProbabilitiesIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final HaplotypeProbabilities merged1 = hp1.deepCopy().merge(hp2);\n+        final HaplotypeProbabilities merged2 = hp1.deepCopy().merge(hp2);\n+\n+        Assert.assertEquals(merged1.getLikelihoods(),merged2.getLikelihoods());\n+    }\n+\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeFingerprintIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final Fingerprint fpA = new Fingerprint(\"test2\",null,\"none\");\n+        final Fingerprint fpB = new Fingerprint(\"test2\",null,\"none\");\n+\n+        final Fingerprint fp1 = new Fingerprint(\"test1\",null,\"none\");\n+        fp1.add(hp1);\n+\n+        final Fingerprint fp2 = new Fingerprint(\"test1\",null,\"none\");\n+        fp2.add(hp2);\n+\n+        fpA.merge(fp1);\n+        fpB.merge(fp1);\n+\n+        Assert.assertNotEquals(fpA.keySet().size(), 0);\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+\n+        fpA.merge(fp2);\n+        fpB.merge(fp2);\n+        fpB.merge(fp2);\n+\n+        Assert.assertNotEquals(fpA.keySet().size(), 0);\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertNotEquals(fpA.get(hb), fpB.get(hb));\n+        }\n+\n+        fpA.merge(fp2);\n+\n+        Assert.assertNotEquals(fpA.keySet().size(), 0);\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+    }\n+\n+    @Test\n+    public void testMergeIsSafeFromSequence() {\n+        final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();\n+        final Path na12891_r2 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r2.sam\").toPath();\n+        final Path na12892_r1 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.r1.sam\").toPath();\n+        final Path na12892_r2 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.r2.sam\").toPath();\n+\n+        final List<Path> listOfFiles = Arrays.asList(na12891_r1, na12891_r2, na12892_r1, na12892_r2);\n+        final FingerprintChecker checker = new FingerprintChecker(SUBSETTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = checker.fingerprintFiles(listOfFiles, 1, 0, TimeUnit.DAYS);\n+\n+        final Fingerprint combinedFp = new Fingerprint(\"test\", null, null);\n+        fingerprintIdDetailsFingerprintMap.values().forEach(combinedFp::merge);\n+\n+        final Fingerprint combinedFp2 = new Fingerprint(\"test2\", null, null);\n+        fingerprintIdDetailsFingerprintMap.values().forEach(combinedFp2::merge);\n+\n+        Assert.assertNotEquals(combinedFp.keySet().size(), 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMTg0Mg=="}, "originalCommit": {"oid": "0985e669414fd759812284a7c6c0d76e834b29a8"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NDY3Mzk3OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/FingerprintingTestUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowOTo0OVrOFpZ6eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNjowOTo0OVrOFpZ6eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk2MDUwNA==", "bodyText": "code should be indented, also missing whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Assert.assertTrue(lhs.containsKey(block),\"HaplotypeBlock was missing from lhs\" + block);\n          \n          \n            \n                        Assert.assertTrue(lhs.containsKey(block), \"HaplotypeBlock was missing from lhs\" + block);", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r378960504", "createdAt": "2020-02-13T16:09:49Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintingTestUtils.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package picard.fingerprint;\n+\n+import org.testng.Assert;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class FingerprintingTestUtils {\n+\n+    public static boolean areHaplotypeProbabilitiesEqual(final HaplotypeProbabilities lhs, final HaplotypeProbabilities rhs) {\n+        if (lhs == rhs) {\n+            return true;\n+        }\n+        if (lhs == null || rhs == null || lhs.getClass() != rhs.getClass()) {\n+            return false;\n+        }\n+\n+        if (!Objects.equals(lhs.getHaplotype(), rhs.getHaplotype())) {\n+            return false;\n+        }\n+\n+        return Arrays.equals(lhs.getLikelihoods(), rhs.getLikelihoods());\n+    }\n+\n+    public static void assertHaplotypeProbabilitiesEqual(final HaplotypeProbabilities lhs, final HaplotypeProbabilities rhs) {\n+        Assert.assertTrue(areHaplotypeProbabilitiesEqual(lhs, rhs),\n+                \"Expected HaplotypeProbabilities to be equal, but they differ: \" +\n+                lhs + \", \" + rhs);\n+    }\n+\n+    public static void assertFingerPrintHPsAreEqual(final Fingerprint lhs, final Fingerprint rhs) {\n+        Assert.assertEquals(lhs.keySet().size(), rhs.keySet().size());\n+\n+        for (final HaplotypeBlock block : lhs.keySet()) {\n+        Assert.assertTrue(lhs.containsKey(block),\"HaplotypeBlock was missing from lhs\" + block);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5649583033c47cb4e92a469c5622f5ecd73e65b"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 700, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}