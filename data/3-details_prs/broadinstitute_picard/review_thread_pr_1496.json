{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMDY4Nzc5", "number": 1496, "reviewThreads": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1MzoxMFrODxzHUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxOTo1NzozN1rOECTO5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTQ0Mjc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1MzoxMFrOGFeeWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1MzoxMFrOGFeeWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5NTM1Mg==", "bodyText": "For public API deprecation, adding a javadoc would be nice.\n/**\n * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n *\n * @deprecated since April 2020 Use {@link #setMaximalPLDifference(String)} instead.\n */", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r408395352", "createdAt": "2020-04-14T19:53:10Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -155,10 +158,15 @@ public void setGenotypingErrorRate(final double genotypingErrorRate) {\n         this.genotypingErrorRate = genotypingErrorRate;\n     }\n \n+    @Deprecated //non-compliant method name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec07f3d851b8b4c1dfbec1043c3526b8d469ab8d"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODQwMDQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/CappedHaplotypeProbabilities.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDozODo0NFrOGSn5Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDozODo0NFrOGSn5Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4MTE2Mg==", "bodyText": "whitespace, here and below\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final double[] cappedLogLikelihoods = MathUtil.sum(logLikelihoods,-max);\n          \n          \n            \n                    final double[] cappedLogLikelihoods = MathUtil.sum(logLikelihoods, -max);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422181162", "createdAt": "2020-05-08T14:38:44Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CappedHaplotypeProbabilities.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package picard.fingerprint;\n+\n+import picard.util.MathUtil;\n+\n+public class CappedHaplotypeProbabilities extends HaplotypeProbabilitiesUsingLogLikelihoods {\n+    private final double cap;\n+\n+    // cap should be negative to indicate that you can never be too sure of anything (since the log likelihood is the\n+    //    log probability of an error, it's negative)\n+    public CappedHaplotypeProbabilities(final HaplotypeProbabilities haplotypeProbabilities, double cap) {\n+        super(haplotypeProbabilities.getHaplotype());\n+        this.cap = cap;\n+        final double[] logLikelihoods = haplotypeProbabilities.getLogLikelihoods();\n+        final double max = MathUtil.max(logLikelihoods);\n+        final double[] cappedLogLikelihoods = MathUtil.sum(logLikelihoods,-max);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODUwNzg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNTowNzowNFrOGSo5Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNTowNzowNFrOGSo5Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NzU5MQ==", "bodyText": "IMO it would make this clearer to create a local variable for the expression fingerprintEntry.getValue()", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422197591", "createdAt": "2020-05-08T15:07:04Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -522,6 +531,18 @@ protected int doWork() {\n         }\n     }\n \n+    private void capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n+        for (Map.Entry<FingerprintIdDetails, Fingerprint> fingerprintEntry : fpMap.entrySet()) {\n+            final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODUxMDUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNTowNzo0MVrOGSo67g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNTowNzo0MVrOGSo67g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5Nzk5OA==", "bodyText": "whitespace missing after , in this method\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());\n          \n          \n            \n                        final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(), fingerprintEntry.getValue().getSource(), fingerprintEntry.getValue().getInfo());", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422197998", "createdAt": "2020-05-08T15:07:41Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -522,6 +531,18 @@ protected int doWork() {\n         }\n     }\n \n+    private void capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n+        for (Map.Entry<FingerprintIdDetails, Fingerprint> fingerprintEntry : fpMap.entrySet()) {\n+            final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODUxOTEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToxMDowM1rOGSpASw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToxMDowM1rOGSpASw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5OTM3MQ==", "bodyText": "The code uses keySet() but then only uses get() on it. You should get the same effect by looping over values(). like\n    for (HaplotypeProbabilities probabilities : fingerprintEntry.getValue().values()) {\n        HaplotypeProbabilities cappedHp = new CappedHaplotypeProbabilities(probabilities, -MAX_EFFECT_OF_EACH_HAPLOTYPE_BLOCK);\n        cappedFp.add(cappedHp);\n    }", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422199371", "createdAt": "2020-05-08T15:10:03Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -522,6 +531,18 @@ protected int doWork() {\n         }\n     }\n \n+    private void capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n+        for (Map.Entry<FingerprintIdDetails, Fingerprint> fingerprintEntry : fpMap.entrySet()) {\n+            final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());\n+\n+            for (HaplotypeBlock haplotypeBlock : fingerprintEntry.getValue().keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODUyNjE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToxMjoyMVrOGSpE1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToxOTo0OVrOGSpUuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMDUzMw==", "bodyText": "This code modifies its argument in place. It looks like it replaces every entry with a new entry. If so, IMO a better model would be to create a new map with the new values and return the new map, instead of overwriting the argument.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422200533", "createdAt": "2020-05-08T15:12:21Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -522,6 +531,18 @@ protected int doWork() {\n         }\n     }\n \n+    private void capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n+        for (Map.Entry<FingerprintIdDetails, Fingerprint> fingerprintEntry : fpMap.entrySet()) {\n+            final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());\n+\n+            for (HaplotypeBlock haplotypeBlock : fingerprintEntry.getValue().keySet()) {\n+                HaplotypeProbabilities cappedHp = new CappedHaplotypeProbabilities(fingerprintEntry.getValue().get(haplotypeBlock),-MAX_EFFECT_OF_EACH_HAPLOTYPE_BLOCK);\n+                cappedFp.add(cappedHp);\n+            }\n+            fpMap.put(fingerprintEntry.getKey(), cappedFp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwNDYwMw==", "bodyText": "Not sure if streaming operations makes this code clearer or less clear, but here's one way to do this\n    private Map<FingerprintIdDetails, Fingerprint> capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n        return\n            fpMap.entrySet().stream()\n                    .collect(Collectors.toMap(Map.Entry::getKey, entry -> {\n                        Fingerprint value = entry.getValue();\n                        final Fingerprint cappedFp = new Fingerprint(value.getSample(), value.getSource(), value.getInfo());\n\n                        value.values().stream()\n                                .map(probabilities -> new CappedHaplotypeProbabilities(probabilities, -MAX_EFFECT_OF_EACH_HAPLOTYPE_BLOCK))\n                                .forEach(cappedFp::add);\n                        return cappedFp;\n                    }));\n    }", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422204603", "createdAt": "2020-05-08T15:19:49Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -522,6 +531,18 @@ protected int doWork() {\n         }\n     }\n \n+    private void capFingerprints(final Map<FingerprintIdDetails, Fingerprint> fpMap) {\n+        for (Map.Entry<FingerprintIdDetails, Fingerprint> fingerprintEntry : fpMap.entrySet()) {\n+            final Fingerprint cappedFp = new Fingerprint(fingerprintEntry.getValue().getSample(),fingerprintEntry.getValue().getSource(),fingerprintEntry.getValue().getInfo());\n+\n+            for (HaplotypeBlock haplotypeBlock : fingerprintEntry.getValue().keySet()) {\n+                HaplotypeProbabilities cappedHp = new CappedHaplotypeProbabilities(fingerprintEntry.getValue().get(haplotypeBlock),-MAX_EFFECT_OF_EACH_HAPLOTYPE_BLOCK);\n+                cappedFp.add(cappedHp);\n+            }\n+            fpMap.put(fingerprintEntry.getKey(), cappedFp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMDUzMw=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODUyOTg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToxMzoyMlrOGSpHHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToxMzoyNFrOGUZLXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMTExNw==", "bodyText": "It looks like this should be fpMap2. If so, it would be nice to have a test that could've found this error.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422201117", "createdAt": "2020-05-08T15:13:22Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -478,6 +485,8 @@ protected int doWork() {\n         } else {\n             log.info(\"Fingerprinting \" + unrolledFiles2.size() + \" SECOND_INPUT files.\");\n             final Map<FingerprintIdDetails, Fingerprint> fpMap2 = checker.fingerprintFiles(unrolledFiles2, NUM_THREADS, 1, TimeUnit.DAYS);\n+            capFingerprints(fpMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzNzIxNA==", "bodyText": "OMG!", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424037214", "createdAt": "2020-05-12T21:13:24Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/CrosscheckFingerprints.java", "diffHunk": "@@ -478,6 +485,8 @@ protected int doWork() {\n         } else {\n             log.info(\"Fingerprinting \" + unrolledFiles2.size() + \" SECOND_INPUT files.\");\n             final Map<FingerprintIdDetails, Fingerprint> fpMap2 = checker.fingerprintFiles(unrolledFiles2, NUM_THREADS, 1, TimeUnit.DAYS);\n+            capFingerprints(fpMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMTExNw=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODU2MTQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToyMjoyOVrOGSpaLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToyMjoyOVrOGSpaLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwNTk5OA==", "bodyText": "log can be static\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Log log = Log.getInstance(ExtractFingerprint.class);\n          \n          \n            \n                private static final Log log = Log.getInstance(ExtractFingerprint.class);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422205998", "createdAt": "2020-05-08T15:22:29Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")\n+    public int LOCUS_MAX_READS = 200;\n+\n+    @Argument(doc = \"Extract a fingerprint for the contaminat sample (instead of the contaminant). Setting to true changes the effect of SAMPLE_ALIAS when null. \" +\n+            \"It names the sample in the VCF <SAMPLE>-contaminated, using the SM value from the SAM header.\")\n+    public boolean EXTRACT_CONTAMINATION = false;\n+\n+    @Override\n+    protected boolean requiresReference() {\n+        return true;\n+    }\n+\n+    private final Log log = Log.getInstance(ExtractFingerprint.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODU2NTM3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToyMzo0NlrOGSpcsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToyMzo0NlrOGSpcsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwNjY0MA==", "bodyText": "please use { } for all ifs\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!EXTRACT_CONTAMINATION) CONTAMINATION = 1 - CONTAMINATION;\n          \n          \n            \n                    if (!EXTRACT_CONTAMINATION) {\n          \n          \n            \n                        CONTAMINATION = 1 - CONTAMINATION;\n          \n          \n            \n                    }", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422206640", "createdAt": "2020-05-08T15:23:46Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")\n+    public int LOCUS_MAX_READS = 200;\n+\n+    @Argument(doc = \"Extract a fingerprint for the contaminat sample (instead of the contaminant). Setting to true changes the effect of SAMPLE_ALIAS when null. \" +\n+            \"It names the sample in the VCF <SAMPLE>-contaminated, using the SM value from the SAM header.\")\n+    public boolean EXTRACT_CONTAMINATION = false;\n+\n+    @Override\n+    protected boolean requiresReference() {\n+        return true;\n+    }\n+\n+    private final Log log = Log.getInstance(ExtractFingerprint.class);\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        IOUtil.assertFileIsReadable(HAPLOTYPE_MAP);\n+        IOUtil.assertFileIsWritable(OUTPUT);\n+        IOUtil.assertFileIsReadable(referenceSequence.getReferenceFile());\n+\n+        final FingerprintChecker checker = new FingerprintChecker(HAPLOTYPE_MAP);\n+\n+        // if we want the contaminated fingerprint instead, we need to change the value of CONTAMINATION:\n+        if (!EXTRACT_CONTAMINATION) CONTAMINATION = 1 - CONTAMINATION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTA4NTg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODowNzo0MlrOGSuikw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODowNzo0MlrOGSuikw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5MDA2Nw==", "bodyText": "It looks like this can be final\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Set<Path> missingRGFiles = new HashSet<>();\n          \n          \n            \n                private final Set<Path> missingRGFiles = new HashSet<>();", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422290067", "createdAt": "2020-05-08T18:07:42Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -116,6 +113,10 @@ public File getReferenceFasta() {\n \n     private boolean allowDuplicateReads = false;\n     private double pLossofHet = 0;\n+    private int locusMaxReads = 0;\n+    private String defaultSampleID = \"<UNKNOWN>\";\n+\n+    private Set<Path> missingRGFiles = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTExODQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODoxNzozNVrOGSu2Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODoxNzozNVrOGSu2Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5NTExMA==", "bodyText": "Since the method you're forwarding to is also deprecated, it seems like this comment should also mention CappedHaplotypeProbabilities", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422295110", "createdAt": "2020-05-08T18:17:35Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -156,12 +157,23 @@ public void setGenotypingErrorRate(final double genotypingErrorRate) {\n     }\n \n     /**\n-     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * Does same thing as {@link #setMaximalPLDifference(int)} but named in the compliant way.\n+     *\n+     * @deprecated use {@link #setMaximalPLDifference(int)} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTEyMDMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODoxODoxMFrOGSu3ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODoxODoxMFrOGSu3ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5NTQwMg==", "bodyText": "Can you use {@link CappedHaplotypeProbabilities} here?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422295402", "createdAt": "2020-05-08T18:18:10Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -156,12 +157,23 @@ public void setGenotypingErrorRate(final double genotypingErrorRate) {\n     }\n \n     /**\n-     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * Does same thing as {@link #setMaximalPLDifference(int)} but named in the compliant way.\n+     *\n+     * @deprecated use {@link #setMaximalPLDifference(int)} instead.\n+     * @since 16/4/2020\n      */\n+    @Deprecated\n     public void setmaximalPLDifference(final int maximalPLDifference) {\n-        this.maximalPLDifference = maximalPLDifference;\n+        setMaximalPLDifference(maximalPLDifference);\n     }\n \n+    /**\n+     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * @deprecated since 04/2020. use CappedHaplotypeProbabilities and explicitly cap your probabilities.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTEyMjgxOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODoxODo1N1rOGSu47w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNjoxNDoyMlrOGbSjlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5NTc5MQ==", "bodyText": "Why add a new method name with no contents that is deprecated?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422295791", "createdAt": "2020-05-08T18:18:57Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -156,12 +157,23 @@ public void setGenotypingErrorRate(final double genotypingErrorRate) {\n     }\n \n     /**\n-     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * Does same thing as {@link #setMaximalPLDifference(int)} but named in the compliant way.\n+     *\n+     * @deprecated use {@link #setMaximalPLDifference(int)} instead.\n+     * @since 16/4/2020\n      */\n+    @Deprecated\n     public void setmaximalPLDifference(final int maximalPLDifference) {\n-        this.maximalPLDifference = maximalPLDifference;\n+        setMaximalPLDifference(maximalPLDifference);\n     }\n \n+    /**\n+     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * @deprecated since 04/2020. use CappedHaplotypeProbabilities and explicitly cap your probabilities.\n+     */\n+    @Deprecated\n+    public void setMaximalPLDifference(final int maximalPLDifference) { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzODYxMw==", "bodyText": "evolution", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424038613", "createdAt": "2020-05-12T21:16:18Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -156,12 +157,23 @@ public void setGenotypingErrorRate(final double genotypingErrorRate) {\n     }\n \n     /**\n-     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * Does same thing as {@link #setMaximalPLDifference(int)} but named in the compliant way.\n+     *\n+     * @deprecated use {@link #setMaximalPLDifference(int)} instead.\n+     * @since 16/4/2020\n      */\n+    @Deprecated\n     public void setmaximalPLDifference(final int maximalPLDifference) {\n-        this.maximalPLDifference = maximalPLDifference;\n+        setMaximalPLDifference(maximalPLDifference);\n     }\n \n+    /**\n+     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * @deprecated since 04/2020. use CappedHaplotypeProbabilities and explicitly cap your probabilities.\n+     */\n+    @Deprecated\n+    public void setMaximalPLDifference(final int maximalPLDifference) { }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5NTc5MQ=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI2ODc1OQ==", "bodyText": "I'll just remove these as they don't do anything....better to have a compile error than a slient noop", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r431268759", "createdAt": "2020-05-27T16:14:22Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -156,12 +157,23 @@ public void setGenotypingErrorRate(final double genotypingErrorRate) {\n     }\n \n     /**\n-     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * Does same thing as {@link #setMaximalPLDifference(int)} but named in the compliant way.\n+     *\n+     * @deprecated use {@link #setMaximalPLDifference(int)} instead.\n+     * @since 16/4/2020\n      */\n+    @Deprecated\n     public void setmaximalPLDifference(final int maximalPLDifference) {\n-        this.maximalPLDifference = maximalPLDifference;\n+        setMaximalPLDifference(maximalPLDifference);\n     }\n \n+    /**\n+     * Sets the maximal difference in PL scores considered when reading PLs from a VCF.\n+     * @deprecated since 04/2020. use CappedHaplotypeProbabilities and explicitly cap your probabilities.\n+     */\n+    @Deprecated\n+    public void setMaximalPLDifference(final int maximalPLDifference) { }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5NTc5MQ=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTEzNDYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODoyMzowM1rOGSvAtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODoyMzowM1rOGSvAtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI5Nzc4Mw==", "bodyText": "unnecessary .toString()\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        log.debug(() -> \"At locus \" + info.toString());\n          \n          \n            \n                        log.debug(() -> \"At locus \" + info);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422297783", "createdAt": "2020-05-08T18:23:03Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -522,11 +539,8 @@ public IntervalList getLociToGenotype(final Collection<Fingerprint> fingerprints\n         // Now go through the data at each locus and figure stuff out!\n         for (final SamLocusIterator.LocusInfo info : iterator) {\n \n-            // if statement to avoid string building.\n-            // TODO: replace with lambda version once htsjdk is rev'ed\n-            if (Log.isEnabled(Log.LogLevel.DEBUG)) {\n-                log.debug(\"At locus \" + info.toString());\n-            }\n+            log.debug(() -> \"At locus \" + info.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTE2OTA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODozMzozM1rOGSvVzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODozMzozM1rOGSvVzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwMzE4Mw==", "bodyText": "If rg == null then fingerprintIdDetailsMap.containsKey(rg) is always true because the if block above adds null to the map. So it seems like the rg == null test is unnecessary.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422303183", "createdAt": "2020-05-08T18:33:33Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -535,22 +549,31 @@ public IntervalList getLociToGenotype(final Collection<Fingerprint> fingerprints\n             final HaplotypeBlock haplotypeBlock = this.haplotypes.getHaplotype(info.getSequenceName(), info.getPosition());\n             final Snp snp = this.haplotypes.getSnp(info.getSequenceName(), info.getPosition());\n \n-            for (final SamLocusIterator.RecordAndOffset rec : info.getRecordAndOffsets()) {\n+            // randomly select locusMaxReads elements from the list\n+            final List<SamLocusIterator.RecordAndOffset> recordAndOffsetList = locusMaxReads == 0 ?\n+                    info.getRecordAndOffsets() :\n+                    MathUtil.randomSublist(info.getRecordAndOffsets(), locusMaxReads, random);\n+\n+            for (final SamLocusIterator.RecordAndOffset rec : recordAndOffsetList) {\n                 final SAMReadGroupRecord rg = rec.getRecord().getReadGroup();\n                 final FingerprintIdDetails details;\n-                if (rg == null || !fingerprintIdDetailsMap.containsKey(rg)) {\n+\n+                // if there's a missing rg tag, add the unknown FP id to the map\n+                if (rg == null && !fingerprintIdDetailsMap.containsKey(null)) {\n+\n                     final FingerprintIdDetails unknownFPDetails = createUnknownFP(samFile, rec.getRecord());\n+\n                     fingerprintIdDetailsMap.put(null, unknownFPDetails);\n \n                     final Fingerprint fp = new Fingerprint(unknownFPDetails.sample, samFile, unknownFPDetails.platformUnit);\n                     fingerprintsByReadGroup.put(unknownFPDetails, fp);\n \n                     for (final HaplotypeBlock h : this.haplotypes.getHaplotypes()) {\n-                        fp.add(new HaplotypeProbabilitiesFromSequence(h));\n+                        fp.add(blockToProbMapper.apply(h));\n                     }\n                 }\n \n-                if (fingerprintIdDetailsMap.containsKey(rg)) {\n+                if (rg == null || fingerprintIdDetailsMap.containsKey(rg)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTE3NTYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODozNToyMlrOGSvZmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODozNToyMlrOGSvZmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNDE1NA==", "bodyText": "()s unnecessary for single arg lambda\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = this.fingerprintSamFile(samFile, (h) -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n          \n          \n            \n                    final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = this.fingerprintSamFile(samFile, h -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422304154", "createdAt": "2020-05-08T18:35:22Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -597,77 +620,16 @@ private FingerprintIdDetails createUnknownFP(final Path samFile, final SAMRecord\n      * Generates a per-sample Fingerprint for the contaminant in the supplied SAM file.\n      * Data is aggregated by sample, not read-group.\n      */\n-    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination, final int locusMaxReads) {\n-        final Map<String, Fingerprint> fingerprintsBySample = new HashMap<>();\n-\n-        try (final SamReader in = SamReaderFactory.makeDefault().enable(CACHE_FILE_BASED_INDEXES).open(samFile)) {\n-            checkDictionaryGoodForFingerprinting(in.getFileHeader().getSequenceDictionary());\n-\n-            final SamLocusIterator iterator = new SamLocusIterator(in, haplotypes.getIntervalList(), in.hasIndex());\n-            iterator.setEmitUncoveredLoci(true);\n-            iterator.setMappingQualityScoreCutoff(this.minimumMappingQuality);\n-            iterator.setQualityScoreCutoff(this.minimumBaseQuality);\n-\n-            // In some cases it is useful to allow duplicate reads to be used - the most common is in single-end\n-            // sequence data where the duplicate marking may have been overly aggressive, and there is useful\n-            // non-redundant data in the reads marked as \"duplicates'.\n-            if (this.allowDuplicateReads) {\n-                final List<SamRecordFilter> filters = new ArrayList<>(1);\n-                filters.add(new SecondaryAlignmentFilter());\n-                iterator.setSamFilters(filters);\n-            }\n+    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination) {\n \n-            for (final SAMReadGroupRecord rg : in.getFileHeader().getReadGroups()) {\n-                if (!fingerprintsBySample.containsKey(rg.getSample())) {\n-                    final Fingerprint fingerprint = new Fingerprint(rg.getSample(),\n-                            samFile,\n-                            rg.getSample());\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = this.fingerprintSamFile(samFile, (h) -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTE3ODEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODozNjoxMlrOGSvbHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODozNjoxMlrOGSvbHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNDU0Mw==", "bodyText": "Personally I would use a shorter name here, but if you want to use this long name, then by should be capitalized.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintbySample = Fingerprint.mergeFingerprintsBy(fingerprintIdDetailsFingerprintMap,\n          \n          \n            \n                    final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintBySample = Fingerprint.mergeFingerprintsBy(fingerprintIdDetailsFingerprintMap,", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422304543", "createdAt": "2020-05-08T18:36:12Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -597,77 +620,16 @@ private FingerprintIdDetails createUnknownFP(final Path samFile, final SAMRecord\n      * Generates a per-sample Fingerprint for the contaminant in the supplied SAM file.\n      * Data is aggregated by sample, not read-group.\n      */\n-    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination, final int locusMaxReads) {\n-        final Map<String, Fingerprint> fingerprintsBySample = new HashMap<>();\n-\n-        try (final SamReader in = SamReaderFactory.makeDefault().enable(CACHE_FILE_BASED_INDEXES).open(samFile)) {\n-            checkDictionaryGoodForFingerprinting(in.getFileHeader().getSequenceDictionary());\n-\n-            final SamLocusIterator iterator = new SamLocusIterator(in, haplotypes.getIntervalList(), in.hasIndex());\n-            iterator.setEmitUncoveredLoci(true);\n-            iterator.setMappingQualityScoreCutoff(this.minimumMappingQuality);\n-            iterator.setQualityScoreCutoff(this.minimumBaseQuality);\n-\n-            // In some cases it is useful to allow duplicate reads to be used - the most common is in single-end\n-            // sequence data where the duplicate marking may have been overly aggressive, and there is useful\n-            // non-redundant data in the reads marked as \"duplicates'.\n-            if (this.allowDuplicateReads) {\n-                final List<SamRecordFilter> filters = new ArrayList<>(1);\n-                filters.add(new SecondaryAlignmentFilter());\n-                iterator.setSamFilters(filters);\n-            }\n+    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination) {\n \n-            for (final SAMReadGroupRecord rg : in.getFileHeader().getReadGroups()) {\n-                if (!fingerprintsBySample.containsKey(rg.getSample())) {\n-                    final Fingerprint fingerprint = new Fingerprint(rg.getSample(),\n-                            samFile,\n-                            rg.getSample());\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = this.fingerprintSamFile(samFile, (h) -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n \n-                    for (final HaplotypeBlock h : this.haplotypes.getHaplotypes()) {\n-                        fingerprint.add(new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n-                    }\n-                    fingerprintsBySample.put(rg.getSample(), fingerprint);\n-                }\n-            }\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintbySample = Fingerprint.mergeFingerprintsBy(fingerprintIdDetailsFingerprintMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTE3OTU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODozNjo0MlrOGSvcCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODozNjo0MlrOGSvcCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNDc3OA==", "bodyText": "Since this variable is returned directly it would be better IMO to return here rather than declaring a variable.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422304778", "createdAt": "2020-05-08T18:36:42Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -597,77 +620,16 @@ private FingerprintIdDetails createUnknownFP(final Path samFile, final SAMRecord\n      * Generates a per-sample Fingerprint for the contaminant in the supplied SAM file.\n      * Data is aggregated by sample, not read-group.\n      */\n-    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination, final int locusMaxReads) {\n-        final Map<String, Fingerprint> fingerprintsBySample = new HashMap<>();\n-\n-        try (final SamReader in = SamReaderFactory.makeDefault().enable(CACHE_FILE_BASED_INDEXES).open(samFile)) {\n-            checkDictionaryGoodForFingerprinting(in.getFileHeader().getSequenceDictionary());\n-\n-            final SamLocusIterator iterator = new SamLocusIterator(in, haplotypes.getIntervalList(), in.hasIndex());\n-            iterator.setEmitUncoveredLoci(true);\n-            iterator.setMappingQualityScoreCutoff(this.minimumMappingQuality);\n-            iterator.setQualityScoreCutoff(this.minimumBaseQuality);\n-\n-            // In some cases it is useful to allow duplicate reads to be used - the most common is in single-end\n-            // sequence data where the duplicate marking may have been overly aggressive, and there is useful\n-            // non-redundant data in the reads marked as \"duplicates'.\n-            if (this.allowDuplicateReads) {\n-                final List<SamRecordFilter> filters = new ArrayList<>(1);\n-                filters.add(new SecondaryAlignmentFilter());\n-                iterator.setSamFilters(filters);\n-            }\n+    public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination) {\n \n-            for (final SAMReadGroupRecord rg : in.getFileHeader().getReadGroups()) {\n-                if (!fingerprintsBySample.containsKey(rg.getSample())) {\n-                    final Fingerprint fingerprint = new Fingerprint(rg.getSample(),\n-                            samFile,\n-                            rg.getSample());\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = this.fingerprintSamFile(samFile, (h) -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n \n-                    for (final HaplotypeBlock h : this.haplotypes.getHaplotypes()) {\n-                        fingerprint.add(new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n-                    }\n-                    fingerprintsBySample.put(rg.getSample(), fingerprint);\n-                }\n-            }\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintbySample = Fingerprint.mergeFingerprintsBy(fingerprintIdDetailsFingerprintMap,\n+                Fingerprint.getFingerprintIdDetailsStringFunction(CrosscheckMetric.DataType.SAMPLE));\n+\n+        final Map<String,Fingerprint> fingerprintsBySample = fingerprintIdDetailsFingerprintbySample.entrySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTE4NDQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODozODozMFrOGSvfNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzozMToxNVrOGXA_cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNTU5MQ==", "bodyText": "This was added because there is a need to change the default sample ID outside of picard? It's not currently used.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422305591", "createdAt": "2020-05-08T18:38:30Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -931,4 +890,20 @@ public static MatchResults calculateMatchResults(final Fingerprint observedFp, f\n     public void setReferenceFasta(final File referenceFasta) {\n         this.referenceFasta = referenceFasta;\n     }\n+\n+    public int getLocusMaxReads() {\n+        return locusMaxReads;\n+    }\n+\n+    public void setLocusMaxReads(final int locusMaxReads) {\n+        this.locusMaxReads = locusMaxReads;\n+    }\n+\n+    public String getDefaultSampleID() {\n+        return defaultSampleID;\n+    }\n+\n+    public void setDefaultSampleID(final String defaultSampleID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MTE2OQ==", "bodyText": "picard/fingerprint/ExtractFingerprint.java:102\nthe getter isn't used, but I thought that if I'm using a setter I should probably have a getter....happy to remove it.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424041169", "createdAt": "2020-05-12T21:21:48Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -931,4 +890,20 @@ public static MatchResults calculateMatchResults(final Fingerprint observedFp, f\n     public void setReferenceFasta(final File referenceFasta) {\n         this.referenceFasta = referenceFasta;\n     }\n+\n+    public int getLocusMaxReads() {\n+        return locusMaxReads;\n+    }\n+\n+    public void setLocusMaxReads(final int locusMaxReads) {\n+        this.locusMaxReads = locusMaxReads;\n+    }\n+\n+    public String getDefaultSampleID() {\n+        return defaultSampleID;\n+    }\n+\n+    public void setDefaultSampleID(final String defaultSampleID) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNTU5MQ=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4NjY3NQ==", "bodyText": "It's OK", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r426786675", "createdAt": "2020-05-18T17:31:15Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintChecker.java", "diffHunk": "@@ -931,4 +890,20 @@ public static MatchResults calculateMatchResults(final Fingerprint observedFp, f\n     public void setReferenceFasta(final File referenceFasta) {\n         this.referenceFasta = referenceFasta;\n     }\n+\n+    public int getLocusMaxReads() {\n+        return locusMaxReads;\n+    }\n+\n+    public void setLocusMaxReads(final int locusMaxReads) {\n+        this.locusMaxReads = locusMaxReads;\n+    }\n+\n+    public String getDefaultSampleID() {\n+        return defaultSampleID;\n+    }\n+\n+    public void setDefaultSampleID(final String defaultSampleID) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNTU5MQ=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 316}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTE5MzM3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0MToxNFrOGSvkjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0MToxNFrOGSvkjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjk1Ng==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele){\n          \n          \n            \n                    if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele) {", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422306956", "createdAt": "2020-05-08T18:41:14Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "diffHunk": "@@ -137,15 +152,38 @@ private static VariantContext getVariantContext(final ReferenceSequenceFile refe\n                 snp.getPos(),\n                 snp.getPos()).getBases()[0]);\n \n-        final Allele allele1 = Allele.create(snp.getAllele1(), snp.getAllele1() == refAllele);\n-        final Allele allele2 = Allele.create(snp.getAllele2(), snp.getAllele2() == refAllele);\n-        final List<Allele> alleles = Arrays.asList(allele1, allele2);\n+        if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTE5ODgzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo0MzowMFrOGSvn4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToyMjo1OVrOGUZc4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzgwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final double[] PLs =  Arrays.copyOf(haplotypeProbabilities.getLogLikelihoods(),HaplotypeProbabilities.NUM_GENOTYPES);\n          \n          \n            \n                    final double[] PLs =  Arrays.copyOf(haplotypeProbabilities.getLogLikelihoods(), HaplotypeProbabilities.NUM_GENOTYPES);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422307808", "createdAt": "2020-05-08T18:43:00Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "diffHunk": "@@ -137,15 +152,38 @@ private static VariantContext getVariantContext(final ReferenceSequenceFile refe\n                 snp.getPos(),\n                 snp.getPos()).getBases()[0]);\n \n-        final Allele allele1 = Allele.create(snp.getAllele1(), snp.getAllele1() == refAllele);\n-        final Allele allele2 = Allele.create(snp.getAllele2(), snp.getAllele2() == refAllele);\n-        final List<Allele> alleles = Arrays.asList(allele1, allele2);\n+        if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele){\n+            throw new PicardException(\"Don't know how to deal with missing reference allele in fingerprinting map\");\n+        }\n+\n+        final Allele alleleRef;\n+        final Allele alleleAlt;\n+        final int obsRef, obsAlt;\n+        final boolean swap12 = snp.getAllele2() == refAllele;\n+\n+        if (swap12) {\n+            alleleRef = Allele.create(snp.getAllele2(), true);\n+            alleleAlt = Allele.create(snp.getAllele1(), false);\n+            obsRef = haplotypeProbabilities.getObsAllele2();\n+            obsAlt = haplotypeProbabilities.getObsAllele1();\n+        } else {\n+            alleleRef = Allele.create(snp.getAllele1(), true);\n+            alleleAlt = Allele.create(snp.getAllele2(), false);\n+            obsRef = haplotypeProbabilities.getObsAllele1();\n+            obsAlt = haplotypeProbabilities.getObsAllele2();\n+        }\n+\n+        final double[] PLs =  Arrays.copyOf(haplotypeProbabilities.getLogLikelihoods(),HaplotypeProbabilities.NUM_GENOTYPES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwOTMzNQ==", "bodyText": "Is there a reason to use NUM_GENOTYPES here instead of haplotypeProbabilities.getLogLikelihoods().length? Using length would make it clearer what the code is doing; it's copying the entire array.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422309335", "createdAt": "2020-05-08T18:46:02Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "diffHunk": "@@ -137,15 +152,38 @@ private static VariantContext getVariantContext(final ReferenceSequenceFile refe\n                 snp.getPos(),\n                 snp.getPos()).getBases()[0]);\n \n-        final Allele allele1 = Allele.create(snp.getAllele1(), snp.getAllele1() == refAllele);\n-        final Allele allele2 = Allele.create(snp.getAllele2(), snp.getAllele2() == refAllele);\n-        final List<Allele> alleles = Arrays.asList(allele1, allele2);\n+        if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele){\n+            throw new PicardException(\"Don't know how to deal with missing reference allele in fingerprinting map\");\n+        }\n+\n+        final Allele alleleRef;\n+        final Allele alleleAlt;\n+        final int obsRef, obsAlt;\n+        final boolean swap12 = snp.getAllele2() == refAllele;\n+\n+        if (swap12) {\n+            alleleRef = Allele.create(snp.getAllele2(), true);\n+            alleleAlt = Allele.create(snp.getAllele1(), false);\n+            obsRef = haplotypeProbabilities.getObsAllele2();\n+            obsAlt = haplotypeProbabilities.getObsAllele1();\n+        } else {\n+            alleleRef = Allele.create(snp.getAllele1(), true);\n+            alleleAlt = Allele.create(snp.getAllele2(), false);\n+            obsRef = haplotypeProbabilities.getObsAllele1();\n+            obsAlt = haplotypeProbabilities.getObsAllele2();\n+        }\n+\n+        final double[] PLs =  Arrays.copyOf(haplotypeProbabilities.getLogLikelihoods(),HaplotypeProbabilities.NUM_GENOTYPES);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzgwOA=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MTY5OA==", "bodyText": "shorter? but OK.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424041698", "createdAt": "2020-05-12T21:22:59Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "diffHunk": "@@ -137,15 +152,38 @@ private static VariantContext getVariantContext(final ReferenceSequenceFile refe\n                 snp.getPos(),\n                 snp.getPos()).getBases()[0]);\n \n-        final Allele allele1 = Allele.create(snp.getAllele1(), snp.getAllele1() == refAllele);\n-        final Allele allele2 = Allele.create(snp.getAllele2(), snp.getAllele2() == refAllele);\n-        final List<Allele> alleles = Arrays.asList(allele1, allele2);\n+        if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele){\n+            throw new PicardException(\"Don't know how to deal with missing reference allele in fingerprinting map\");\n+        }\n+\n+        final Allele alleleRef;\n+        final Allele alleleAlt;\n+        final int obsRef, obsAlt;\n+        final boolean swap12 = snp.getAllele2() == refAllele;\n+\n+        if (swap12) {\n+            alleleRef = Allele.create(snp.getAllele2(), true);\n+            alleleAlt = Allele.create(snp.getAllele1(), false);\n+            obsRef = haplotypeProbabilities.getObsAllele2();\n+            obsAlt = haplotypeProbabilities.getObsAllele1();\n+        } else {\n+            alleleRef = Allele.create(snp.getAllele1(), true);\n+            alleleAlt = Allele.create(snp.getAllele2(), false);\n+            obsRef = haplotypeProbabilities.getObsAllele1();\n+            obsAlt = haplotypeProbabilities.getObsAllele2();\n+        }\n+\n+        final double[] PLs =  Arrays.copyOf(haplotypeProbabilities.getLogLikelihoods(),HaplotypeProbabilities.NUM_GENOTYPES);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzgwOA=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTI0OTIxOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODo1ODo1N1rOGSwG2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMToyNToxM1rOGUZhOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMxNTczNw==", "bodyText": "You can avoid updating this if the type of LOD_SCORE ever changes by using String.valueOf()\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> Double.toString(s.LOD_SCORE + 0), Collectors.toSet())));\n          \n          \n            \n                            .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> String.valueOf(s.LOD_SCORE + 0), Collectors.toSet())));", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r422315737", "createdAt": "2020-05-08T18:58:57Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -203,7 +204,8 @@ public void testCheckFingerprintsSam(final File samFile1, final File samFile2, f\n         final List<CrosscheckMetric> metrics = metricsFileReader.getMetrics();\n \n         final Map<Set<String>, Set<String>> collected = metrics.stream()\n-                .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> s.LOD_SCORE.toString(), Collectors.toSet())));\n+//                we sometimes get -0.0, and so the comparison fails...\n+                .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> Double.toString(s.LOD_SCORE + 0), Collectors.toSet())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0MjgxMA==", "bodyText": "odd case to worry about...but OK.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424042810", "createdAt": "2020-05-12T21:25:13Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -203,7 +204,8 @@ public void testCheckFingerprintsSam(final File samFile1, final File samFile2, f\n         final List<CrosscheckMetric> metrics = metricsFileReader.getMetrics();\n \n         final Map<Set<String>, Set<String>> collected = metrics.stream()\n-                .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> s.LOD_SCORE.toString(), Collectors.toSet())));\n+//                we sometimes get -0.0, and so the comparison fails...\n+                .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> Double.toString(s.LOD_SCORE + 0), Collectors.toSet())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMxNTczNw=="}, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODcyMjk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzoyNDozNlrOGUGZOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzoyNDozNlrOGUGZOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzcyOTQ2NA==", "bodyText": "This operation is also done in CappedHaplotypeProbabilities, would it make sense to make a method for it in MathUtil?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r423729464", "createdAt": "2020-05-12T13:24:36Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "diffHunk": "@@ -168,11 +169,15 @@ public HaplotypeProbabilitiesUsingLogLikelihoods merge(final HaplotypeProbabilit\n \n     public void setLogLikelihoods(final double[] ll) {\n         ValidationUtils.validateArg(ll.length == NUM_GENOTYPES,\n-                ()->\"logLikelihood must have length 3, found \" + ll.length);\n+                () -> \"logLikelihood must have length 3, found \" + ll.length);\n+\n+//        protect from underflow\n+        double max = MathUtil.max(ll);\n+        final double[] maxRemoved = MathUtil.sum(ll, -max);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODc3NDYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/util/MathUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzozNTozMlrOGUG47A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzozNTozMlrOGUG47A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzczNzU4MA==", "bodyText": "This looks like a different operation than MathUtil.max(double[]). The usual rule for overloaded methods is that the overloaded method should perform the same operation as the original. The main use of overloads is so you can provide default argument values. Maybe 'maxCap() and 'minCap()?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r423737580", "createdAt": "2020-05-12T13:35:32Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/util/MathUtil.java", "diffHunk": "@@ -168,6 +168,18 @@ public static double max(final double[] nums) {\n         return nums[indexOfMax(nums)];\n     }\n \n+    /**\n+     * Returns the array capped (from below) by the value of scalar\n+     */\n+    public static double[] max(final double[] nums, final double scalar) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODc3ODU1OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzozNjoyM1rOGUG7dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMzozNjoyM1rOGUG7dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzczODIyOQ==", "bodyText": "whitespace typo\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void     testSummaryAndDetailOutputs() {\n          \n          \n            \n                public void testSummaryAndDetailOutputs() {", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r423738229", "createdAt": "2020-05-12T13:36:23Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -116,7 +119,7 @@ public void testMismatchingSamples2() {\n     }\n \n     @Test\n-    public void testSummaryAndDetailOutputs() {\n+    public void     testSummaryAndDetailOutputs() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd0f393166439fde9dda25cf8b2fcdb190548291"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzYxNjk3OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToxOTo0MFrOGU2yZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNjoyOTowOVrOGbTJgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMjM0MA==", "bodyText": "Would it be odd for Fingerprint.merge() to return itself? that would make streaming ops like this a bit cleaner to write.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424522340", "createdAt": "2020-05-13T15:19:40Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        checker.setLocusMaxReads(100);\n+        final Fingerprint fingerprint = checker.identifyContaminant(Na12892.toPath(), 1).get(\"NA12892\");\n+        Assert.assertNotNull(fingerprint);\n+\n+        final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");\n+        tempFile.deleteOnExit();\n+\n+        FingerprintUtils.writeFingerPrint(fingerprint,tempFile,SHIFTED_REFERENCE,\n+                \"NA12892\",null);\n+\n+        final Fingerprint NA12892FromVCF = checker.fingerprintFiles(Collections.singleton(tempFile.toPath()), 1, 1, TimeUnit.DAYS)\n+                .values().stream()\n+                .reduce((a, b) -> {\n+                    a.merge(b);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3ODQ2Ng==", "bodyText": "good idea.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r431278466", "createdAt": "2020-05-27T16:29:09Z", "author": {"login": "yfarjoun"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        checker.setLocusMaxReads(100);\n+        final Fingerprint fingerprint = checker.identifyContaminant(Na12892.toPath(), 1).get(\"NA12892\");\n+        Assert.assertNotNull(fingerprint);\n+\n+        final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");\n+        tempFile.deleteOnExit();\n+\n+        FingerprintUtils.writeFingerPrint(fingerprint,tempFile,SHIFTED_REFERENCE,\n+                \"NA12892\",null);\n+\n+        final Fingerprint NA12892FromVCF = checker.fingerprintFiles(Collections.singleton(tempFile.toPath()), 1, 1, TimeUnit.DAYS)\n+                .values().stream()\n+                .reduce((a, b) -> {\n+                    a.merge(b);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMjM0MA=="}, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzYxODgzOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMDowMlrOGU2zow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMDowMlrOGU2zow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMjY1OQ==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                   final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n          \n          \n            \n                    final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424522659", "createdAt": "2020-05-13T15:20:02Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzYxOTg2OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMDoxNlrOGU20RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMDoxNlrOGU20RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMjgyMA==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");\n          \n          \n            \n                    final File tempFile = File.createTempFile(\"testWriteFingerprint\", \".vcf\");", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424522820", "createdAt": "2020-05-13T15:20:16Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        checker.setLocusMaxReads(100);\n+        final Fingerprint fingerprint = checker.identifyContaminant(Na12892.toPath(), 1).get(\"NA12892\");\n+        Assert.assertNotNull(fingerprint);\n+\n+        final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzYyMDk3OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMDozNFrOGU21Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMDozNFrOGU21Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMzAxOQ==", "bodyText": "whitespace\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FingerprintUtils.writeFingerPrint(fingerprint,tempFile,SHIFTED_REFERENCE,\n          \n          \n            \n                    FingerprintUtils.writeFingerPrint(fingerprint,tempFile, SHIFTED_REFERENCE,\n          \n          \n            \n                                    \"NA12892\", null);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424523019", "createdAt": "2020-05-13T15:20:34Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        checker.setLocusMaxReads(100);\n+        final Fingerprint fingerprint = checker.identifyContaminant(Na12892.toPath(), 1).get(\"NA12892\");\n+        Assert.assertNotNull(fingerprint);\n+\n+        final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");\n+        tempFile.deleteOnExit();\n+\n+        FingerprintUtils.writeFingerPrint(fingerprint,tempFile,SHIFTED_REFERENCE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzYyNDQ2OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMToxN1rOGU23MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMToxN1rOGU23MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMzU2OA==", "bodyText": "more whitespace.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Assert.assertTrue(FingerprintChecker.calculateMatchResults(NA12892FromVCF, NA12892_fp).getLOD() >1D);\n          \n          \n            \n                    Assert.assertTrue(FingerprintChecker.calculateMatchResults(NA12892FromVCF, NA12892_fp).getLOD() > 1D);", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424523568", "createdAt": "2020-05-13T15:21:17Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/CheckFingerprintTest.java", "diffHunk": "@@ -181,6 +185,62 @@ public void testIdentifyContaminant() {\n         Assert.assertTrue(FingerprintChecker.calculateMatchResults(fpContaminant, fpContaminated).getLOD() < -4D);\n     }\n \n+    @Test\n+    public void testFPToVC() throws IOException {\n+\n+        final File Na12892 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.shifted.for.crams.r1.sam\");\n+        final File Na12891 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.shifted.for.crams.r1.sam\");\n+\n+       final FingerprintChecker checker = new FingerprintChecker(SHIFTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        checker.setLocusMaxReads(100);\n+        final Fingerprint fingerprint = checker.identifyContaminant(Na12892.toPath(), 1).get(\"NA12892\");\n+        Assert.assertNotNull(fingerprint);\n+\n+        final File tempFile = File.createTempFile(\"testWriteFingerprint\",\".vcf\");\n+        tempFile.deleteOnExit();\n+\n+        FingerprintUtils.writeFingerPrint(fingerprint,tempFile,SHIFTED_REFERENCE,\n+                \"NA12892\",null);\n+\n+        final Fingerprint NA12892FromVCF = checker.fingerprintFiles(Collections.singleton(tempFile.toPath()), 1, 1, TimeUnit.DAYS)\n+                .values().stream()\n+                .reduce((a, b) -> {\n+                    a.merge(b);\n+                    return a;\n+                })\n+                .orElseThrow(() -> new IllegalArgumentException(\"Did not find any data for contaminant\"));\n+        Assert.assertNotNull(NA12892FromVCF);\n+\n+        Assert.assertTrue(FingerprintChecker.calculateMatchResults(fingerprint, NA12892FromVCF).getLOD() > 1D);\n+\n+\n+        final Fingerprint NA12891_fp = checker.fingerprintFiles(Collections.singleton(Na12891.toPath()), 1, 1, TimeUnit.DAYS)\n+                .values().stream()\n+                .reduce((a, b) -> {\n+                    a.merge(b);\n+                    return a;\n+                })\n+                .orElseThrow(() -> new IllegalArgumentException(\"Did not find any data for contaminated\"));\n+        Assert.assertNotNull(NA12891_fp);\n+\n+        Assert.assertTrue(FingerprintChecker.calculateMatchResults(NA12891_fp, NA12892FromVCF).getLOD() < -4D);\n+\n+        final Fingerprint NA12892_fp = checker.fingerprintFiles(Collections.singleton(Na12892.toPath()), 1, 1, TimeUnit.DAYS)\n+                .values().stream()\n+                .reduce((a, b) -> {\n+                    a.merge(b);\n+                    return a;\n+                })\n+                .orElseThrow(() -> new IllegalArgumentException(\"Did not find any data for contaminated\"));\n+        Assert.assertNotNull(NA12892_fp);\n+\n+        Assert.assertTrue(FingerprintChecker.calculateMatchResults(NA12892FromVCF, NA12892_fp).getLOD() >1D);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MzYzMzU0OnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMzoxM1rOGU289w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNToyMzoxM1rOGU289w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyNTA0Nw==", "bodyText": "unless you're commenting out code, // comments should left align with the current indent line.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r424525047", "createdAt": "2020-05-13T15:23:13Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -203,7 +204,8 @@ public void testCheckFingerprintsSam(final File samFile1, final File samFile2, f\n         final List<CrosscheckMetric> metrics = metricsFileReader.getMetrics();\n \n         final Map<Set<String>, Set<String>> collected = metrics.stream()\n-                .collect(Collectors.groupingBy(s -> CollectionUtil.makeSet(s.LEFT_GROUP_VALUE, s.RIGHT_GROUP_VALUE), Collectors.mapping(s -> s.LOD_SCORE.toString(), Collectors.toSet())));\n+//                we sometimes get -0.0, and so the comparison fails...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e687e1ab780bf8e8c6d58a689227fffd272dc5"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODk1NjA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/util/MathUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDo1NTozMFrOGdNi0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDo1NTozMFrOGdNi0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4Mzc5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns the array capped (from above) by the value of floor\n          \n          \n            \n                 * Returns the array capped (from above) by the value of top", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r433283793", "createdAt": "2020-06-01T14:55:30Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/util/MathUtil.java", "diffHunk": "@@ -251,6 +271,18 @@ public static byte min(final byte[] nums) {\n         return min;\n     }\n \n+    /**\n+     * Returns the array capped (from above) by the value of floor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e2562d57d409510b99a64ed5c18d521d73d6f69"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjgxMzg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDowMzo1OFrOGdzP8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDo1MDoyM1rOGfJxkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMTU1NQ==", "bodyText": "must have length 3, or must have length NUM_GENOTYPES?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r433901555", "createdAt": "2020-06-02T14:03:58Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "diffHunk": "@@ -168,11 +169,14 @@ public HaplotypeProbabilitiesUsingLogLikelihoods merge(final HaplotypeProbabilit\n \n     public void setLogLikelihoods(final double[] ll) {\n         ValidationUtils.validateArg(ll.length == NUM_GENOTYPES,\n-                ()->\"logLikelihood must have length 3, found \" + ll.length);\n+                () -> \"logLikelihood must have length 3, found \" + ll.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMxOTE4Nw==", "bodyText": "it's the same. I just don't like magic numbers in the code...I mind them less in error messages, but I'm happy to change it.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r435319187", "createdAt": "2020-06-04T14:50:23Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "diffHunk": "@@ -168,11 +169,14 @@ public HaplotypeProbabilitiesUsingLogLikelihoods merge(final HaplotypeProbabilit\n \n     public void setLogLikelihoods(final double[] ll) {\n         ValidationUtils.validateArg(ll.length == NUM_GENOTYPES,\n-                ()->\"logLikelihood must have length 3, found \" + ll.length);\n+                () -> \"logLikelihood must have length 3, found \" + ll.length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMTU1NQ=="}, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjk3MzE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/util/MathUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDozODozM1rOGd03Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDo1MzozMFrOGfJ67A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyNzk3MA==", "bodyText": "Could you add unit tests for this function.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r433927970", "createdAt": "2020-06-02T14:38:33Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/util/MathUtil.java", "diffHunk": "@@ -209,6 +220,15 @@ public static int indexOfMax(final long[] nums) {\n         return index;\n     }\n \n+    /* Find the maximal value of the array and return a new array\n+    consisting of that value subtracted from the original array\n+     */\n+    public static double[] subtractMax(final double[] logLikelihoods) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyMTU4MA==", "bodyText": "sure.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r435321580", "createdAt": "2020-06-04T14:53:30Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/util/MathUtil.java", "diffHunk": "@@ -209,6 +220,15 @@ public static int indexOfMax(final long[] nums) {\n         return index;\n     }\n \n+    /* Find the maximal value of the array and return a new array\n+    consisting of that value subtracted from the original array\n+     */\n+    public static double[] subtractMax(final double[] logLikelihoods) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyNzk3MA=="}, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODAzODM3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzo0NzoxOFrOGem0uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDo1NDo0OFrOGfJ--Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc0NjU1Mw==", "bodyText": "2020, and in a few other files.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r434746553", "createdAt": "2020-06-03T17:47:18Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyMjYxNw==", "bodyText": "Only changing new files.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r435322617", "createdAt": "2020-06-04T14:54:48Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc0NjU1Mw=="}, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODA0NDY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzo0ODo1OFrOGem4sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDo1NjoxOFrOGfKDig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc0NzU2OA==", "bodyText": "Is this true that this limits the effect any locus can have, and if so, isn't 200 really a lot?  Why not 30 or 50?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r434747568", "createdAt": "2020-06-03T17:48:58Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyMzc4Ng==", "bodyText": "ok. going with 50. :-)", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r435323786", "createdAt": "2020-06-04T14:56:18Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc0NzU2OA=="}, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODE3MzA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODoyNjoxNlrOGeoMzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDo1ODozNVrOGfKKpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2OTEwMA==", "bodyText": "-contamination", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r434769100", "createdAt": "2020-06-03T18:26:16Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")\n+    public int LOCUS_MAX_READS = 200;\n+\n+    @Argument(doc = \"Extract a fingerprint for the contaminat sample (instead of the contaminant). Setting to true changes the effect of SAMPLE_ALIAS when null. \" +\n+            \"It names the sample in the VCF <SAMPLE>-contaminated, using the SM value from the SAM header.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyNTYwNQ==", "bodyText": "oops.", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r435325605", "createdAt": "2020-06-04T14:58:35Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")\n+    public int LOCUS_MAX_READS = 200;\n+\n+    @Argument(doc = \"Extract a fingerprint for the contaminat sample (instead of the contaminant). Setting to true changes the effect of SAMPLE_ALIAS when null. \" +\n+            \"It names the sample in the VCF <SAMPLE>-contaminated, using the SM value from the SAM header.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2OTEwMA=="}, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODE3OTI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODoyODowOFrOGeoQ3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDo1OToxN1rOGfKMnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3MDE0MA==", "bodyText": "Would this be better as a try-with-resources block?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r434770140", "createdAt": "2020-06-03T18:28:08Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")\n+    public int LOCUS_MAX_READS = 200;\n+\n+    @Argument(doc = \"Extract a fingerprint for the contaminat sample (instead of the contaminant). Setting to true changes the effect of SAMPLE_ALIAS when null. \" +\n+            \"It names the sample in the VCF <SAMPLE>-contaminated, using the SM value from the SAM header.\")\n+    public boolean EXTRACT_CONTAMINATION = false;\n+\n+    @Override\n+    protected boolean requiresReference() {\n+        return true;\n+    }\n+\n+    private static final Log log = Log.getInstance(ExtractFingerprint.class);\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        IOUtil.assertFileIsReadable(HAPLOTYPE_MAP);\n+        IOUtil.assertFileIsWritable(OUTPUT);\n+        IOUtil.assertFileIsReadable(referenceSequence.getReferenceFile());\n+\n+        final FingerprintChecker checker = new FingerprintChecker(HAPLOTYPE_MAP);\n+\n+        // if we want the contaminated fingerprint instead, we need to change the value of CONTAMINATION:\n+        if (!EXTRACT_CONTAMINATION) {\n+            CONTAMINATION = 1 - CONTAMINATION;\n+        }\n+\n+        checker.setLocusMaxReads(LOCUS_MAX_READS);\n+        checker.setValidationStringency(VALIDATION_STRINGENCY);\n+\n+        if (SAMPLE_ALIAS != null) {\n+            checker.setDefaultSampleID(SAMPLE_ALIAS);\n+        }\n+\n+        final Map<String, Fingerprint> fingerprintMap = checker.identifyContaminant(INPUT.toPath(), CONTAMINATION);\n+\n+        if (fingerprintMap.size() != 1) {\n+            log.error(\"Expected exactly 1 fingerprint, found \" + fingerprintMap.size());\n+            throw new IllegalArgumentException(\"Expected exactly 1 fingerprint in Input file, found \" + fingerprintMap.size());\n+        }\n+\n+        final Map.Entry<String, Fingerprint> soleEntry = fingerprintMap.entrySet().iterator().next();\n+\n+        final String sampleToUse = getSampleToUse(soleEntry.getKey());\n+\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyNjEwOQ==", "bodyText": "what needs to be closed here?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r435326109", "createdAt": "2020-06-04T14:59:17Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/ExtractFingerprint.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2018 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package picard.fingerprint;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+/**\n+ * Program to create a fingerprint for the <b>contaminating</b> sample when the level of contamination is both known and\n+ * uniform in the genome.\n+ *\n+ * @author Yossi Farjoun\n+ */\n+@CommandLineProgramProperties(\n+        summary = \"Computes/Extracts the fingerprint genotype likelihoods from the supplied SAM/BAM/VCF file.\" +\n+                \"It is given as a list of PLs at the fingerprinting sites.\",\n+        oneLineSummary = \"Computes a fingerprint from the supplied SAM/BAM file.\",\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+public class ExtractFingerprint extends CommandLineProgram {\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME, doc = \"Input SAM or BAM file.\")\n+    public File INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc = \"Output fingerprint file (VCF).\")\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"H\", doc = \"A file of haplotype information. The file lists a set of SNPs, optionally arranged in high-LD blocks, to be used for fingerprinting. See \" +\n+            \"https://software.broadinstitute.org/gatk/documentation/article?id=9526 for details.\")\n+    public File HAPLOTYPE_MAP;\n+\n+    @Argument(shortName = \"C\", doc = \"A value of estimated contamination in the input. A non-zero value will cause the program to provide a better estimate of the fingerprint in the presence of contaminating reads\",\n+            minValue = 0D, maxValue = 1D)\n+    public double CONTAMINATION;\n+\n+    @Argument(doc = \"The sample alias to associate with the resulting fingerprint. When null, <SAMPLE> is extracted from the input file and \\\"<SAMPLE>\\\" is used. \" +\n+            \"If argument EXTRACT_CONTAMINATION=true the resulting samplename will be \\\"<SAMPLE>-contamination\\\" (if not provided).\", optional = true)\n+    public String SAMPLE_ALIAS = null;\n+\n+    @Argument(doc = \"The maximum number of reads to use as evidence for any given locus. This is provided as a way to limit the \" +\n+            \"effect that any given locus may have.\")\n+    public int LOCUS_MAX_READS = 200;\n+\n+    @Argument(doc = \"Extract a fingerprint for the contaminat sample (instead of the contaminant). Setting to true changes the effect of SAMPLE_ALIAS when null. \" +\n+            \"It names the sample in the VCF <SAMPLE>-contaminated, using the SM value from the SAM header.\")\n+    public boolean EXTRACT_CONTAMINATION = false;\n+\n+    @Override\n+    protected boolean requiresReference() {\n+        return true;\n+    }\n+\n+    private static final Log log = Log.getInstance(ExtractFingerprint.class);\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        IOUtil.assertFileIsReadable(HAPLOTYPE_MAP);\n+        IOUtil.assertFileIsWritable(OUTPUT);\n+        IOUtil.assertFileIsReadable(referenceSequence.getReferenceFile());\n+\n+        final FingerprintChecker checker = new FingerprintChecker(HAPLOTYPE_MAP);\n+\n+        // if we want the contaminated fingerprint instead, we need to change the value of CONTAMINATION:\n+        if (!EXTRACT_CONTAMINATION) {\n+            CONTAMINATION = 1 - CONTAMINATION;\n+        }\n+\n+        checker.setLocusMaxReads(LOCUS_MAX_READS);\n+        checker.setValidationStringency(VALIDATION_STRINGENCY);\n+\n+        if (SAMPLE_ALIAS != null) {\n+            checker.setDefaultSampleID(SAMPLE_ALIAS);\n+        }\n+\n+        final Map<String, Fingerprint> fingerprintMap = checker.identifyContaminant(INPUT.toPath(), CONTAMINATION);\n+\n+        if (fingerprintMap.size() != 1) {\n+            log.error(\"Expected exactly 1 fingerprint, found \" + fingerprintMap.size());\n+            throw new IllegalArgumentException(\"Expected exactly 1 fingerprint in Input file, found \" + fingerprintMap.size());\n+        }\n+\n+        final Map.Entry<String, Fingerprint> soleEntry = fingerprintMap.entrySet().iterator().next();\n+\n+        final String sampleToUse = getSampleToUse(soleEntry.getKey());\n+\n+        try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3MDE0MA=="}, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODQ3NzE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxOTo1NzozN1rOGerPlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjowMjo1NFrOGfNG1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxODk2NQ==", "bodyText": "Why do you have snp.getAllele2() != refAllele?\nIsn't allele1 always the reference allele?", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r434818965", "createdAt": "2020-06-03T19:57:37Z", "author": {"login": "fleharty"}, "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "diffHunk": "@@ -137,15 +152,39 @@ private static VariantContext getVariantContext(final ReferenceSequenceFile refe\n                 snp.getPos(),\n                 snp.getPos()).getBases()[0]);\n \n-        final Allele allele1 = Allele.create(snp.getAllele1(), snp.getAllele1() == refAllele);\n-        final Allele allele2 = Allele.create(snp.getAllele2(), snp.getAllele2() == refAllele);\n-        final List<Allele> alleles = Arrays.asList(allele1, allele2);\n+        if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3Mzc4Mw==", "bodyText": "not in the haplotype DB file. in order to deal with snps that are phased in trans. Technically, the columns are MAJOR_ALLELE and MINOR_ALLELE, so you see, the reference could be the minor allele....", "url": "https://github.com/broadinstitute/picard/pull/1496#discussion_r435373783", "createdAt": "2020-06-04T16:02:54Z", "author": {"login": "yfarjoun"}, "path": "src/main/java/picard/fingerprint/FingerprintUtils.java", "diffHunk": "@@ -137,15 +152,39 @@ private static VariantContext getVariantContext(final ReferenceSequenceFile refe\n                 snp.getPos(),\n                 snp.getPos()).getBases()[0]);\n \n-        final Allele allele1 = Allele.create(snp.getAllele1(), snp.getAllele1() == refAllele);\n-        final Allele allele2 = Allele.create(snp.getAllele2(), snp.getAllele2() == refAllele);\n-        final List<Allele> alleles = Arrays.asList(allele1, allele2);\n+        if (snp.getAllele1() != refAllele && snp.getAllele2() != refAllele) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxODk2NQ=="}, "originalCommit": {"oid": "2f3365c844b11d8d06413b05d1b1df18bd41601b"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 748, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}