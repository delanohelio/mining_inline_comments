{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNTUwNDUw", "number": 1463, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDoxNjo0OFrODdd-Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTowNTo1NFrODde1bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjI2MzMwOnYy", "diffSide": "RIGHT", "path": "src/test/java/picard/arrays/illumina/CombineGenotypingArrayVcfsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDoxNjo0OFrOFmFy-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDowNToyN1rOFmLahg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4NTE3Nw==", "bodyText": "Could use Arrays.asList(inputVcf1, inputVcf2);", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375485177", "createdAt": "2020-02-05T20:16:48Z", "author": {"login": "pshapiro4broad"}, "path": "src/test/java/picard/arrays/illumina/CombineGenotypingArrayVcfsTest.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package picard.arrays.illumina;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import picard.arrays.CombineGenotypingArrayVcfs;\n+import picard.vcf.VcfTestUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class CombineGenotypingArrayVcfsTest {\n+    private static final Path TEST_DATA_DIR = Paths.get(\"testdata/picard/arrays/\");\n+\n+    @Test()\n+    public void testCombineGenotypingArrayVcfs() throws IOException {\n+        final CombineGenotypingArrayVcfs combineGenotypingArrayVcfs = new CombineGenotypingArrayVcfs();\n+        final File inputVcf1 = TEST_DATA_DIR.resolve(\"input.vcf\").toFile();\n+        final File inputVcf2 = TEST_DATA_DIR.resolve(\"input2.vcf\").toFile();\n+        final List<File> inputs = new ArrayList<File>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NzIyMg==", "bodyText": "It's true.", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375577222", "createdAt": "2020-02-06T00:05:27Z", "author": {"login": "gbggrant"}, "path": "src/test/java/picard/arrays/illumina/CombineGenotypingArrayVcfsTest.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package picard.arrays.illumina;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import picard.arrays.CombineGenotypingArrayVcfs;\n+import picard.vcf.VcfTestUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class CombineGenotypingArrayVcfsTest {\n+    private static final Path TEST_DATA_DIR = Paths.get(\"testdata/picard/arrays/\");\n+\n+    @Test()\n+    public void testCombineGenotypingArrayVcfs() throws IOException {\n+        final CombineGenotypingArrayVcfs combineGenotypingArrayVcfs = new CombineGenotypingArrayVcfs();\n+        final File inputVcf1 = TEST_DATA_DIR.resolve(\"input.vcf\").toFile();\n+        final File inputVcf2 = TEST_DATA_DIR.resolve(\"input2.vcf\").toFile();\n+        final List<File> inputs = new ArrayList<File>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4NTE3Nw=="}, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjI5MTU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDoyNjo1NVrOFmGEXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDowNjoxMFrOFmLbSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4OTYyOQ==", "bodyText": "can be replaced with\n            genotypes.addAll(vc.getGenotypes());", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375489629", "createdAt": "2020-02-05T20:26:55Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +\n+                    \"and combines them into a single VCF. \" +\n+                    \"The input VCFs must have the same sequence dictionary and same list of variant loci. \" +\n+                    \"The input VCFs must not share sample Ids. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar VcfToAdpc \\\\<br />\" +\n+                    \"      INPUT=input1.vcf \\\\<br />\" +\n+                    \"      INPUT=input2.vcf \\\\<br />\" +\n+                    \"      OUTPUT=output.vcf\" +\n+                    \"</pre>\";\n+\n+    @Argument(shortName= StandardOptionDefinitions.INPUT_SHORT_NAME,  doc=\"Input VCF file(s).\")\n+    public List<File> INPUT;\n+\n+    @Argument(shortName=StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc=\"Output VCF file.\")\n+    public File OUTPUT;\n+\n+    private final Log log = Log.getInstance(CombineGenotypingArrayVcfs.class);\n+\n+    final private ProgressLogger progressLogger = new ProgressLogger(log, 10000);\n+\n+    public CombineGenotypingArrayVcfs() {\n+        CREATE_INDEX = true;\n+    }\n+\n+    // These items will be removed from the merged header\n+    private final Set<String> sampleSpecificHeaders = new HashSet<String>(Arrays.asList(\n+            InfiniumVcfFields.ANALYSIS_VERSION_NUMBER,\n+            InfiniumVcfFields.AUTOCALL_DATE,\n+            InfiniumVcfFields.AUTOCALL_GENDER,\n+            InfiniumVcfFields.CHIP_WELL_BARCODE,\n+            InfiniumVcfFields.EXPECTED_GENDER,\n+            InfiniumVcfFields.FINGERPRINT_GENDER,\n+            InfiniumVcfFields.IMAGING_DATE,\n+            InfiniumVcfFields.P_95_GREEN,\n+            InfiniumVcfFields.P_95_RED,\n+            InfiniumVcfFields.SAMPLE_ALIAS,\n+            InfiniumVcfFields.SCANNER_NAME,\n+            \"Biotin(Bgnd)\", \"Biotin(High)\",\n+            \"DNP(Bgnd)\", \"DNP(High)\", \"Extension(A)\", \"Extension(C)\", \"Extension(G)\", \"Extension(T)\",\n+            \"Hyb(High)\", \"Hyb(Low)\", \"Hyb(Medium)\", \"NP(A)\", \"NP(C)\", \"NP(G)\", \"NP(T)\",\n+            \"NSB(Bgnd)Blue\", \"NSB(Bgnd)Green\", \"NSB(Bgnd)Purple\", \"NSB(Bgnd)Red\", \"Restore\",\n+            \"String(MM)\", \"String(PM)\", \"TargetRemoval\",\n+            \"fileDate\"));\n+\n+\n+    @Override\n+    public int doWork() {\n+        log.info(\"Checking inputs.\");\n+        final List<File> UNROLLED_INPUT = IOUtil.unrollFiles(INPUT, IOUtil.VCF_EXTENSIONS);\n+        for (final File f: UNROLLED_INPUT) IOUtil.assertFileIsReadable(f);\n+        IOUtil.assertFileIsWritable(OUTPUT);\n+\n+        final SAMSequenceDictionary sequenceDictionary = VCFFileReader.getSequenceDictionary(UNROLLED_INPUT.get(0));\n+\n+        final List<String> sampleList = new ArrayList<String>();\n+        final Collection<CloseableIterator<VariantContext>> iteratorCollection = new ArrayList<>(UNROLLED_INPUT.size());\n+        final Collection<VCFHeader> headers = new HashSet<VCFHeader>(UNROLLED_INPUT.size());\n+\n+        Set<String> sampleNames = new HashSet<>();\n+\n+        for (final File file : UNROLLED_INPUT) {\n+            final VCFFileReader fileReader = new VCFFileReader(file, false);\n+            final VCFHeader fileHeader = fileReader.getFileHeader();\n+\n+            for (final String sampleName : fileHeader.getSampleNamesInOrder()) {\n+                if (!sampleNames.add(sampleName)) {\n+                    throw new IllegalArgumentException(\"Input file \" + file.getAbsolutePath() + \" contains a sample entry (\" + sampleName + \") that appears in another input file.\");\n+                }\n+                sampleList.add(sampleName);\n+            }\n+\n+            headers.add(fileHeader);\n+            iteratorCollection.add(fileReader.iterator());\n+        }\n+\n+        if (CREATE_INDEX && sequenceDictionary == null) {\n+            throw new PicardException(\"A sequence dictionary must be available (either through the input file or by setting it explicitly) when creating indexed output.\");\n+        }\n+\n+        final VariantContextWriterBuilder builder = new VariantContextWriterBuilder()\n+                .setOutputFile(OUTPUT)\n+                .setReferenceDictionary(sequenceDictionary);\n+        if (CREATE_INDEX) {\n+            builder.setOption(Options.INDEX_ON_THE_FLY);\n+        }\n+        final VariantContextWriter writer = builder.build();\n+\n+        Set<VCFHeaderLine> headerLines = VCFUtils.smartMergeHeaders(headers, false);\n+        headerLines.removeIf(line -> sampleSpecificHeaders.contains(line.getKey()));\n+        writer.writeHeader(new VCFHeader(headerLines, sampleList));\n+\n+        int closedIteratorCount = 0;\n+        while (closedIteratorCount == 0) {\n+            List<VariantContext> variantContexts = new ArrayList<>();\n+            for (final CloseableIterator<VariantContext> iterator: iteratorCollection) {\n+                if (iterator.hasNext()) {\n+                    variantContexts.add(iterator.next());\n+                } else {\n+                    closedIteratorCount++;\n+                }\n+            }\n+            if (closedIteratorCount == 0) {\n+                progressLogger.record(variantContexts.get(0).getContig(), variantContexts.get(0).getStart());\n+                writer.add(merge(variantContexts));\n+            }\n+        }\n+        if (closedIteratorCount != iteratorCollection.size()) {\n+            throw new PicardException(\"Mismatch in number of variants among input VCFs\");\n+        }\n+        writer.close();\n+        return 0;\n+    }\n+\n+    /**\n+     * Merges multiple VariantContexts all for the same locus into a single hybrid.\n+     *\n+     * @param variantContexts           list of VCs\n+     * @return new VariantContext       representing the merge of variantContexts\n+     */\n+    public static VariantContext merge(final List<VariantContext> variantContexts) {\n+        if ( variantContexts == null || variantContexts.isEmpty() )\n+            return null;\n+\n+        // establish the baseline info from the first VC\n+        final VariantContext first = variantContexts.get(0);\n+        final String name = first.getSource();\n+\n+        final Set<String> filters = new HashSet<>();\n+\n+        int depth = 0;\n+        double log10PError = CommonInfo.NO_LOG10_PERROR;\n+        boolean anyVCHadFiltersApplied = false;\n+        GenotypesContext genotypes = GenotypesContext.create();\n+\n+        // Go through all the VCs, verify that the loci and ID and other attributes agree.\n+        final Map<String, Object> firstAttributes = first.getAttributes();\n+        for (final VariantContext vc : variantContexts ) {\n+            if ((vc.getStart() != first.getStart()) || (!vc.getContig().equals(first.getContig()))) {\n+                throw new PicardException(\"Mismatch in loci among input VCFs\");\n+            }\n+            if (!vc.getID().equals(first.getID())) {\n+                throw new PicardException(\"Mismatch in ID field among input VCFs\");\n+            }\n+            if (!vc.getReference().equals(first.getReference())) {\n+                throw new PicardException(\"Mismatch in REF allele among input VCFs\");\n+            }\n+            checkThatAllelesMatch(vc, first);\n+\n+            for (final Genotype g : vc.getGenotypes()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NzQxOA==", "bodyText": "So true.", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375577418", "createdAt": "2020-02-06T00:06:10Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +\n+                    \"and combines them into a single VCF. \" +\n+                    \"The input VCFs must have the same sequence dictionary and same list of variant loci. \" +\n+                    \"The input VCFs must not share sample Ids. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar VcfToAdpc \\\\<br />\" +\n+                    \"      INPUT=input1.vcf \\\\<br />\" +\n+                    \"      INPUT=input2.vcf \\\\<br />\" +\n+                    \"      OUTPUT=output.vcf\" +\n+                    \"</pre>\";\n+\n+    @Argument(shortName= StandardOptionDefinitions.INPUT_SHORT_NAME,  doc=\"Input VCF file(s).\")\n+    public List<File> INPUT;\n+\n+    @Argument(shortName=StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc=\"Output VCF file.\")\n+    public File OUTPUT;\n+\n+    private final Log log = Log.getInstance(CombineGenotypingArrayVcfs.class);\n+\n+    final private ProgressLogger progressLogger = new ProgressLogger(log, 10000);\n+\n+    public CombineGenotypingArrayVcfs() {\n+        CREATE_INDEX = true;\n+    }\n+\n+    // These items will be removed from the merged header\n+    private final Set<String> sampleSpecificHeaders = new HashSet<String>(Arrays.asList(\n+            InfiniumVcfFields.ANALYSIS_VERSION_NUMBER,\n+            InfiniumVcfFields.AUTOCALL_DATE,\n+            InfiniumVcfFields.AUTOCALL_GENDER,\n+            InfiniumVcfFields.CHIP_WELL_BARCODE,\n+            InfiniumVcfFields.EXPECTED_GENDER,\n+            InfiniumVcfFields.FINGERPRINT_GENDER,\n+            InfiniumVcfFields.IMAGING_DATE,\n+            InfiniumVcfFields.P_95_GREEN,\n+            InfiniumVcfFields.P_95_RED,\n+            InfiniumVcfFields.SAMPLE_ALIAS,\n+            InfiniumVcfFields.SCANNER_NAME,\n+            \"Biotin(Bgnd)\", \"Biotin(High)\",\n+            \"DNP(Bgnd)\", \"DNP(High)\", \"Extension(A)\", \"Extension(C)\", \"Extension(G)\", \"Extension(T)\",\n+            \"Hyb(High)\", \"Hyb(Low)\", \"Hyb(Medium)\", \"NP(A)\", \"NP(C)\", \"NP(G)\", \"NP(T)\",\n+            \"NSB(Bgnd)Blue\", \"NSB(Bgnd)Green\", \"NSB(Bgnd)Purple\", \"NSB(Bgnd)Red\", \"Restore\",\n+            \"String(MM)\", \"String(PM)\", \"TargetRemoval\",\n+            \"fileDate\"));\n+\n+\n+    @Override\n+    public int doWork() {\n+        log.info(\"Checking inputs.\");\n+        final List<File> UNROLLED_INPUT = IOUtil.unrollFiles(INPUT, IOUtil.VCF_EXTENSIONS);\n+        for (final File f: UNROLLED_INPUT) IOUtil.assertFileIsReadable(f);\n+        IOUtil.assertFileIsWritable(OUTPUT);\n+\n+        final SAMSequenceDictionary sequenceDictionary = VCFFileReader.getSequenceDictionary(UNROLLED_INPUT.get(0));\n+\n+        final List<String> sampleList = new ArrayList<String>();\n+        final Collection<CloseableIterator<VariantContext>> iteratorCollection = new ArrayList<>(UNROLLED_INPUT.size());\n+        final Collection<VCFHeader> headers = new HashSet<VCFHeader>(UNROLLED_INPUT.size());\n+\n+        Set<String> sampleNames = new HashSet<>();\n+\n+        for (final File file : UNROLLED_INPUT) {\n+            final VCFFileReader fileReader = new VCFFileReader(file, false);\n+            final VCFHeader fileHeader = fileReader.getFileHeader();\n+\n+            for (final String sampleName : fileHeader.getSampleNamesInOrder()) {\n+                if (!sampleNames.add(sampleName)) {\n+                    throw new IllegalArgumentException(\"Input file \" + file.getAbsolutePath() + \" contains a sample entry (\" + sampleName + \") that appears in another input file.\");\n+                }\n+                sampleList.add(sampleName);\n+            }\n+\n+            headers.add(fileHeader);\n+            iteratorCollection.add(fileReader.iterator());\n+        }\n+\n+        if (CREATE_INDEX && sequenceDictionary == null) {\n+            throw new PicardException(\"A sequence dictionary must be available (either through the input file or by setting it explicitly) when creating indexed output.\");\n+        }\n+\n+        final VariantContextWriterBuilder builder = new VariantContextWriterBuilder()\n+                .setOutputFile(OUTPUT)\n+                .setReferenceDictionary(sequenceDictionary);\n+        if (CREATE_INDEX) {\n+            builder.setOption(Options.INDEX_ON_THE_FLY);\n+        }\n+        final VariantContextWriter writer = builder.build();\n+\n+        Set<VCFHeaderLine> headerLines = VCFUtils.smartMergeHeaders(headers, false);\n+        headerLines.removeIf(line -> sampleSpecificHeaders.contains(line.getKey()));\n+        writer.writeHeader(new VCFHeader(headerLines, sampleList));\n+\n+        int closedIteratorCount = 0;\n+        while (closedIteratorCount == 0) {\n+            List<VariantContext> variantContexts = new ArrayList<>();\n+            for (final CloseableIterator<VariantContext> iterator: iteratorCollection) {\n+                if (iterator.hasNext()) {\n+                    variantContexts.add(iterator.next());\n+                } else {\n+                    closedIteratorCount++;\n+                }\n+            }\n+            if (closedIteratorCount == 0) {\n+                progressLogger.record(variantContexts.get(0).getContig(), variantContexts.get(0).getStart());\n+                writer.add(merge(variantContexts));\n+            }\n+        }\n+        if (closedIteratorCount != iteratorCollection.size()) {\n+            throw new PicardException(\"Mismatch in number of variants among input VCFs\");\n+        }\n+        writer.close();\n+        return 0;\n+    }\n+\n+    /**\n+     * Merges multiple VariantContexts all for the same locus into a single hybrid.\n+     *\n+     * @param variantContexts           list of VCs\n+     * @return new VariantContext       representing the merge of variantContexts\n+     */\n+    public static VariantContext merge(final List<VariantContext> variantContexts) {\n+        if ( variantContexts == null || variantContexts.isEmpty() )\n+            return null;\n+\n+        // establish the baseline info from the first VC\n+        final VariantContext first = variantContexts.get(0);\n+        final String name = first.getSource();\n+\n+        final Set<String> filters = new HashSet<>();\n+\n+        int depth = 0;\n+        double log10PError = CommonInfo.NO_LOG10_PERROR;\n+        boolean anyVCHadFiltersApplied = false;\n+        GenotypesContext genotypes = GenotypesContext.create();\n+\n+        // Go through all the VCs, verify that the loci and ID and other attributes agree.\n+        final Map<String, Object> firstAttributes = first.getAttributes();\n+        for (final VariantContext vc : variantContexts ) {\n+            if ((vc.getStart() != first.getStart()) || (!vc.getContig().equals(first.getContig()))) {\n+                throw new PicardException(\"Mismatch in loci among input VCFs\");\n+            }\n+            if (!vc.getID().equals(first.getID())) {\n+                throw new PicardException(\"Mismatch in ID field among input VCFs\");\n+            }\n+            if (!vc.getReference().equals(first.getReference())) {\n+                throw new PicardException(\"Mismatch in REF allele among input VCFs\");\n+            }\n+            checkThatAllelesMatch(vc, first);\n+\n+            for (final Genotype g : vc.getGenotypes()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4OTYyOQ=="}, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjMwMjQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDozMDozMlrOFmGLCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTowNTo0OFrOFoZDoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ5MTMzNw==", "bodyText": "Could use try-with-resources here to avoid explicit close() below.", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375491337", "createdAt": "2020-02-05T20:30:32Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +\n+                    \"and combines them into a single VCF. \" +\n+                    \"The input VCFs must have the same sequence dictionary and same list of variant loci. \" +\n+                    \"The input VCFs must not share sample Ids. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar VcfToAdpc \\\\<br />\" +\n+                    \"      INPUT=input1.vcf \\\\<br />\" +\n+                    \"      INPUT=input2.vcf \\\\<br />\" +\n+                    \"      OUTPUT=output.vcf\" +\n+                    \"</pre>\";\n+\n+    @Argument(shortName= StandardOptionDefinitions.INPUT_SHORT_NAME,  doc=\"Input VCF file(s).\")\n+    public List<File> INPUT;\n+\n+    @Argument(shortName=StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc=\"Output VCF file.\")\n+    public File OUTPUT;\n+\n+    private final Log log = Log.getInstance(CombineGenotypingArrayVcfs.class);\n+\n+    final private ProgressLogger progressLogger = new ProgressLogger(log, 10000);\n+\n+    public CombineGenotypingArrayVcfs() {\n+        CREATE_INDEX = true;\n+    }\n+\n+    // These items will be removed from the merged header\n+    private final Set<String> sampleSpecificHeaders = new HashSet<String>(Arrays.asList(\n+            InfiniumVcfFields.ANALYSIS_VERSION_NUMBER,\n+            InfiniumVcfFields.AUTOCALL_DATE,\n+            InfiniumVcfFields.AUTOCALL_GENDER,\n+            InfiniumVcfFields.CHIP_WELL_BARCODE,\n+            InfiniumVcfFields.EXPECTED_GENDER,\n+            InfiniumVcfFields.FINGERPRINT_GENDER,\n+            InfiniumVcfFields.IMAGING_DATE,\n+            InfiniumVcfFields.P_95_GREEN,\n+            InfiniumVcfFields.P_95_RED,\n+            InfiniumVcfFields.SAMPLE_ALIAS,\n+            InfiniumVcfFields.SCANNER_NAME,\n+            \"Biotin(Bgnd)\", \"Biotin(High)\",\n+            \"DNP(Bgnd)\", \"DNP(High)\", \"Extension(A)\", \"Extension(C)\", \"Extension(G)\", \"Extension(T)\",\n+            \"Hyb(High)\", \"Hyb(Low)\", \"Hyb(Medium)\", \"NP(A)\", \"NP(C)\", \"NP(G)\", \"NP(T)\",\n+            \"NSB(Bgnd)Blue\", \"NSB(Bgnd)Green\", \"NSB(Bgnd)Purple\", \"NSB(Bgnd)Red\", \"Restore\",\n+            \"String(MM)\", \"String(PM)\", \"TargetRemoval\",\n+            \"fileDate\"));\n+\n+\n+    @Override\n+    public int doWork() {\n+        log.info(\"Checking inputs.\");\n+        final List<File> UNROLLED_INPUT = IOUtil.unrollFiles(INPUT, IOUtil.VCF_EXTENSIONS);\n+        for (final File f: UNROLLED_INPUT) IOUtil.assertFileIsReadable(f);\n+        IOUtil.assertFileIsWritable(OUTPUT);\n+\n+        final SAMSequenceDictionary sequenceDictionary = VCFFileReader.getSequenceDictionary(UNROLLED_INPUT.get(0));\n+\n+        final List<String> sampleList = new ArrayList<String>();\n+        final Collection<CloseableIterator<VariantContext>> iteratorCollection = new ArrayList<>(UNROLLED_INPUT.size());\n+        final Collection<VCFHeader> headers = new HashSet<VCFHeader>(UNROLLED_INPUT.size());\n+\n+        Set<String> sampleNames = new HashSet<>();\n+\n+        for (final File file : UNROLLED_INPUT) {\n+            final VCFFileReader fileReader = new VCFFileReader(file, false);\n+            final VCFHeader fileHeader = fileReader.getFileHeader();\n+\n+            for (final String sampleName : fileHeader.getSampleNamesInOrder()) {\n+                if (!sampleNames.add(sampleName)) {\n+                    throw new IllegalArgumentException(\"Input file \" + file.getAbsolutePath() + \" contains a sample entry (\" + sampleName + \") that appears in another input file.\");\n+                }\n+                sampleList.add(sampleName);\n+            }\n+\n+            headers.add(fileHeader);\n+            iteratorCollection.add(fileReader.iterator());\n+        }\n+\n+        if (CREATE_INDEX && sequenceDictionary == null) {\n+            throw new PicardException(\"A sequence dictionary must be available (either through the input file or by setting it explicitly) when creating indexed output.\");\n+        }\n+\n+        final VariantContextWriterBuilder builder = new VariantContextWriterBuilder()\n+                .setOutputFile(OUTPUT)\n+                .setReferenceDictionary(sequenceDictionary);\n+        if (CREATE_INDEX) {\n+            builder.setOption(Options.INDEX_ON_THE_FLY);\n+        }\n+        final VariantContextWriter writer = builder.build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg5Nzg4OQ==", "bodyText": "Yes.", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r377897889", "createdAt": "2020-02-11T21:05:48Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +\n+                    \"and combines them into a single VCF. \" +\n+                    \"The input VCFs must have the same sequence dictionary and same list of variant loci. \" +\n+                    \"The input VCFs must not share sample Ids. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar VcfToAdpc \\\\<br />\" +\n+                    \"      INPUT=input1.vcf \\\\<br />\" +\n+                    \"      INPUT=input2.vcf \\\\<br />\" +\n+                    \"      OUTPUT=output.vcf\" +\n+                    \"</pre>\";\n+\n+    @Argument(shortName= StandardOptionDefinitions.INPUT_SHORT_NAME,  doc=\"Input VCF file(s).\")\n+    public List<File> INPUT;\n+\n+    @Argument(shortName=StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc=\"Output VCF file.\")\n+    public File OUTPUT;\n+\n+    private final Log log = Log.getInstance(CombineGenotypingArrayVcfs.class);\n+\n+    final private ProgressLogger progressLogger = new ProgressLogger(log, 10000);\n+\n+    public CombineGenotypingArrayVcfs() {\n+        CREATE_INDEX = true;\n+    }\n+\n+    // These items will be removed from the merged header\n+    private final Set<String> sampleSpecificHeaders = new HashSet<String>(Arrays.asList(\n+            InfiniumVcfFields.ANALYSIS_VERSION_NUMBER,\n+            InfiniumVcfFields.AUTOCALL_DATE,\n+            InfiniumVcfFields.AUTOCALL_GENDER,\n+            InfiniumVcfFields.CHIP_WELL_BARCODE,\n+            InfiniumVcfFields.EXPECTED_GENDER,\n+            InfiniumVcfFields.FINGERPRINT_GENDER,\n+            InfiniumVcfFields.IMAGING_DATE,\n+            InfiniumVcfFields.P_95_GREEN,\n+            InfiniumVcfFields.P_95_RED,\n+            InfiniumVcfFields.SAMPLE_ALIAS,\n+            InfiniumVcfFields.SCANNER_NAME,\n+            \"Biotin(Bgnd)\", \"Biotin(High)\",\n+            \"DNP(Bgnd)\", \"DNP(High)\", \"Extension(A)\", \"Extension(C)\", \"Extension(G)\", \"Extension(T)\",\n+            \"Hyb(High)\", \"Hyb(Low)\", \"Hyb(Medium)\", \"NP(A)\", \"NP(C)\", \"NP(G)\", \"NP(T)\",\n+            \"NSB(Bgnd)Blue\", \"NSB(Bgnd)Green\", \"NSB(Bgnd)Purple\", \"NSB(Bgnd)Red\", \"Restore\",\n+            \"String(MM)\", \"String(PM)\", \"TargetRemoval\",\n+            \"fileDate\"));\n+\n+\n+    @Override\n+    public int doWork() {\n+        log.info(\"Checking inputs.\");\n+        final List<File> UNROLLED_INPUT = IOUtil.unrollFiles(INPUT, IOUtil.VCF_EXTENSIONS);\n+        for (final File f: UNROLLED_INPUT) IOUtil.assertFileIsReadable(f);\n+        IOUtil.assertFileIsWritable(OUTPUT);\n+\n+        final SAMSequenceDictionary sequenceDictionary = VCFFileReader.getSequenceDictionary(UNROLLED_INPUT.get(0));\n+\n+        final List<String> sampleList = new ArrayList<String>();\n+        final Collection<CloseableIterator<VariantContext>> iteratorCollection = new ArrayList<>(UNROLLED_INPUT.size());\n+        final Collection<VCFHeader> headers = new HashSet<VCFHeader>(UNROLLED_INPUT.size());\n+\n+        Set<String> sampleNames = new HashSet<>();\n+\n+        for (final File file : UNROLLED_INPUT) {\n+            final VCFFileReader fileReader = new VCFFileReader(file, false);\n+            final VCFHeader fileHeader = fileReader.getFileHeader();\n+\n+            for (final String sampleName : fileHeader.getSampleNamesInOrder()) {\n+                if (!sampleNames.add(sampleName)) {\n+                    throw new IllegalArgumentException(\"Input file \" + file.getAbsolutePath() + \" contains a sample entry (\" + sampleName + \") that appears in another input file.\");\n+                }\n+                sampleList.add(sampleName);\n+            }\n+\n+            headers.add(fileHeader);\n+            iteratorCollection.add(fileReader.iterator());\n+        }\n+\n+        if (CREATE_INDEX && sequenceDictionary == null) {\n+            throw new PicardException(\"A sequence dictionary must be available (either through the input file or by setting it explicitly) when creating indexed output.\");\n+        }\n+\n+        final VariantContextWriterBuilder builder = new VariantContextWriterBuilder()\n+                .setOutputFile(OUTPUT)\n+                .setReferenceDictionary(sequenceDictionary);\n+        if (CREATE_INDEX) {\n+            builder.setOption(Options.INDEX_ON_THE_FLY);\n+        }\n+        final VariantContextWriter writer = builder.build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ5MTMzNw=="}, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjMwNjcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDozMTo1NlrOFmGNnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDowNjo1NFrOFmLcGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ5MTk5Ng==", "bodyText": "Can be replaced with assertFilesAreReadable\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (final File f: UNROLLED_INPUT) IOUtil.assertFileIsReadable(f);\n          \n          \n            \n                   IOUtil.assertFilesAreReadable(UNROLLED_INPUT);", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375491996", "createdAt": "2020-02-05T20:31:56Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +\n+                    \"and combines them into a single VCF. \" +\n+                    \"The input VCFs must have the same sequence dictionary and same list of variant loci. \" +\n+                    \"The input VCFs must not share sample Ids. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar VcfToAdpc \\\\<br />\" +\n+                    \"      INPUT=input1.vcf \\\\<br />\" +\n+                    \"      INPUT=input2.vcf \\\\<br />\" +\n+                    \"      OUTPUT=output.vcf\" +\n+                    \"</pre>\";\n+\n+    @Argument(shortName= StandardOptionDefinitions.INPUT_SHORT_NAME,  doc=\"Input VCF file(s).\")\n+    public List<File> INPUT;\n+\n+    @Argument(shortName=StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc=\"Output VCF file.\")\n+    public File OUTPUT;\n+\n+    private final Log log = Log.getInstance(CombineGenotypingArrayVcfs.class);\n+\n+    final private ProgressLogger progressLogger = new ProgressLogger(log, 10000);\n+\n+    public CombineGenotypingArrayVcfs() {\n+        CREATE_INDEX = true;\n+    }\n+\n+    // These items will be removed from the merged header\n+    private final Set<String> sampleSpecificHeaders = new HashSet<String>(Arrays.asList(\n+            InfiniumVcfFields.ANALYSIS_VERSION_NUMBER,\n+            InfiniumVcfFields.AUTOCALL_DATE,\n+            InfiniumVcfFields.AUTOCALL_GENDER,\n+            InfiniumVcfFields.CHIP_WELL_BARCODE,\n+            InfiniumVcfFields.EXPECTED_GENDER,\n+            InfiniumVcfFields.FINGERPRINT_GENDER,\n+            InfiniumVcfFields.IMAGING_DATE,\n+            InfiniumVcfFields.P_95_GREEN,\n+            InfiniumVcfFields.P_95_RED,\n+            InfiniumVcfFields.SAMPLE_ALIAS,\n+            InfiniumVcfFields.SCANNER_NAME,\n+            \"Biotin(Bgnd)\", \"Biotin(High)\",\n+            \"DNP(Bgnd)\", \"DNP(High)\", \"Extension(A)\", \"Extension(C)\", \"Extension(G)\", \"Extension(T)\",\n+            \"Hyb(High)\", \"Hyb(Low)\", \"Hyb(Medium)\", \"NP(A)\", \"NP(C)\", \"NP(G)\", \"NP(T)\",\n+            \"NSB(Bgnd)Blue\", \"NSB(Bgnd)Green\", \"NSB(Bgnd)Purple\", \"NSB(Bgnd)Red\", \"Restore\",\n+            \"String(MM)\", \"String(PM)\", \"TargetRemoval\",\n+            \"fileDate\"));\n+\n+\n+    @Override\n+    public int doWork() {\n+        log.info(\"Checking inputs.\");\n+        final List<File> UNROLLED_INPUT = IOUtil.unrollFiles(INPUT, IOUtil.VCF_EXTENSIONS);\n+        for (final File f: UNROLLED_INPUT) IOUtil.assertFileIsReadable(f);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NzYyNg==", "bodyText": "That's a good point.", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375577626", "createdAt": "2020-02-06T00:06:54Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +\n+                    \"and combines them into a single VCF. \" +\n+                    \"The input VCFs must have the same sequence dictionary and same list of variant loci. \" +\n+                    \"The input VCFs must not share sample Ids. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar VcfToAdpc \\\\<br />\" +\n+                    \"      INPUT=input1.vcf \\\\<br />\" +\n+                    \"      INPUT=input2.vcf \\\\<br />\" +\n+                    \"      OUTPUT=output.vcf\" +\n+                    \"</pre>\";\n+\n+    @Argument(shortName= StandardOptionDefinitions.INPUT_SHORT_NAME,  doc=\"Input VCF file(s).\")\n+    public List<File> INPUT;\n+\n+    @Argument(shortName=StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc=\"Output VCF file.\")\n+    public File OUTPUT;\n+\n+    private final Log log = Log.getInstance(CombineGenotypingArrayVcfs.class);\n+\n+    final private ProgressLogger progressLogger = new ProgressLogger(log, 10000);\n+\n+    public CombineGenotypingArrayVcfs() {\n+        CREATE_INDEX = true;\n+    }\n+\n+    // These items will be removed from the merged header\n+    private final Set<String> sampleSpecificHeaders = new HashSet<String>(Arrays.asList(\n+            InfiniumVcfFields.ANALYSIS_VERSION_NUMBER,\n+            InfiniumVcfFields.AUTOCALL_DATE,\n+            InfiniumVcfFields.AUTOCALL_GENDER,\n+            InfiniumVcfFields.CHIP_WELL_BARCODE,\n+            InfiniumVcfFields.EXPECTED_GENDER,\n+            InfiniumVcfFields.FINGERPRINT_GENDER,\n+            InfiniumVcfFields.IMAGING_DATE,\n+            InfiniumVcfFields.P_95_GREEN,\n+            InfiniumVcfFields.P_95_RED,\n+            InfiniumVcfFields.SAMPLE_ALIAS,\n+            InfiniumVcfFields.SCANNER_NAME,\n+            \"Biotin(Bgnd)\", \"Biotin(High)\",\n+            \"DNP(Bgnd)\", \"DNP(High)\", \"Extension(A)\", \"Extension(C)\", \"Extension(G)\", \"Extension(T)\",\n+            \"Hyb(High)\", \"Hyb(Low)\", \"Hyb(Medium)\", \"NP(A)\", \"NP(C)\", \"NP(G)\", \"NP(T)\",\n+            \"NSB(Bgnd)Blue\", \"NSB(Bgnd)Green\", \"NSB(Bgnd)Purple\", \"NSB(Bgnd)Red\", \"Restore\",\n+            \"String(MM)\", \"String(PM)\", \"TargetRemoval\",\n+            \"fileDate\"));\n+\n+\n+    @Override\n+    public int doWork() {\n+        log.info(\"Checking inputs.\");\n+        final List<File> UNROLLED_INPUT = IOUtil.unrollFiles(INPUT, IOUtil.VCF_EXTENSIONS);\n+        for (final File f: UNROLLED_INPUT) IOUtil.assertFileIsReadable(f);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ5MTk5Ng=="}, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjM5Nzk0OnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTowMzozMFrOFmHFfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTozOTozMVrOFoaHiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwNjMwMw==", "bodyText": "Is it worth documenting here or in a comment when one would use this instead of MergeVcfs? They do seem pretty different but the names are similar.", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375506303", "createdAt": "2020-02-05T21:03:30Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxNTI3Mg==", "bodyText": "Not sure if I want to address this in the documentation.  I'll add a comment.  MergeVcfs doesn't support the use case here.  Where we have multiple input VCFs each with a different sample name.  There used to be a tool in GATK 3 (not implemented in 4) called CombineVariants that did support this use case, but it merged duplicate sites, so we implemented this tool.", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r377915272", "createdAt": "2020-02-11T21:39:31Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwNjMwMw=="}, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjM5OTIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTowMzo1NFrOFmHGNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDoyNzoxMlrOFmLyGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwNjQ4Ng==", "bodyText": "I think this should be\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                \"java -jar picard.jar VcfToAdpc \\\\<br />\" +\n          \n          \n            \n                                \"java -jar picard.jar CombineGenotypingArrayVcfs \\\\<br />\" +", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375506486", "createdAt": "2020-02-05T21:03:54Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +\n+                    \"and combines them into a single VCF. \" +\n+                    \"The input VCFs must have the same sequence dictionary and same list of variant loci. \" +\n+                    \"The input VCFs must not share sample Ids. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar VcfToAdpc \\\\<br />\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MzI1Ng==", "bodyText": "Yeah, I cut and pasted an example usage obviously.", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375583256", "createdAt": "2020-02-06T00:27:12Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +\n+                    \"and combines them into a single VCF. \" +\n+                    \"The input VCFs must have the same sequence dictionary and same list of variant loci. \" +\n+                    \"The input VCFs must not share sample Ids. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar VcfToAdpc \\\\<br />\" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwNjQ4Ng=="}, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjQwMjcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTowNTowOVrOFmHIXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMTowNTozNFrOFoZDJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwNzAzOQ==", "bodyText": "Is there a reason why you didn't bring over the comment from picard-private's CombineVcfs?", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375507039", "createdAt": "2020-02-05T21:05:09Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg5Nzc2NA==", "bodyText": "No, was trying to capture it in the usage.  But I've added the comments now.", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r377897764", "createdAt": "2020-02-11T21:05:34Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwNzAzOQ=="}, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjQwNDkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTowNTo1NFrOFmHJqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDoyNzo0NVrOFmLynA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwNzM3MA==", "bodyText": "sort modifiers\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final private ProgressLogger progressLogger = new ProgressLogger(log, 10000);\n          \n          \n            \n                private final ProgressLogger progressLogger = new ProgressLogger(log, 10000);", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375507370", "createdAt": "2020-02-05T21:05:54Z", "author": {"login": "pshapiro4broad"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +\n+                    \"and combines them into a single VCF. \" +\n+                    \"The input VCFs must have the same sequence dictionary and same list of variant loci. \" +\n+                    \"The input VCFs must not share sample Ids. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar VcfToAdpc \\\\<br />\" +\n+                    \"      INPUT=input1.vcf \\\\<br />\" +\n+                    \"      INPUT=input2.vcf \\\\<br />\" +\n+                    \"      OUTPUT=output.vcf\" +\n+                    \"</pre>\";\n+\n+    @Argument(shortName= StandardOptionDefinitions.INPUT_SHORT_NAME,  doc=\"Input VCF file(s).\")\n+    public List<File> INPUT;\n+\n+    @Argument(shortName=StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc=\"Output VCF file.\")\n+    public File OUTPUT;\n+\n+    private final Log log = Log.getInstance(CombineGenotypingArrayVcfs.class);\n+\n+    final private ProgressLogger progressLogger = new ProgressLogger(log, 10000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MzM4OA==", "bodyText": "hmm.", "url": "https://github.com/broadinstitute/picard/pull/1463#discussion_r375583388", "createdAt": "2020-02-06T00:27:45Z", "author": {"login": "gbggrant"}, "path": "src/main/java/picard/arrays/CombineGenotypingArrayVcfs.java", "diffHunk": "@@ -0,0 +1,270 @@\n+package picard.arrays;\n+\n+import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.samtools.util.CloseableIterator;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.variant.variantcontext.CommonInfo;\n+import htsjdk.variant.variantcontext.Genotype;\n+import htsjdk.variant.variantcontext.GenotypesContext;\n+import htsjdk.variant.variantcontext.VariantContext;\n+import htsjdk.variant.variantcontext.VariantContextBuilder;\n+import htsjdk.variant.variantcontext.VariantContextUtils;\n+import htsjdk.variant.variantcontext.writer.Options;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriter;\n+import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;\n+import htsjdk.variant.vcf.VCFConstants;\n+import htsjdk.variant.vcf.VCFFileReader;\n+import htsjdk.variant.vcf.VCFHeader;\n+import htsjdk.variant.vcf.VCFHeaderLine;\n+import htsjdk.variant.vcf.VCFUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.arrays.illumina.InfiniumVcfFields;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+/**\n+ * A simple program to combine multiple genotyping array VCF files into one VCF\n+ *\n+ */\n+@CommandLineProgramProperties(\n+        summary = CombineGenotypingArrayVcfs.USAGE_DETAILS,\n+        oneLineSummary = \"Program to combine multiple genotyping array VCF files into one VCF.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+@DocumentedFeature\n+public class CombineGenotypingArrayVcfs extends CommandLineProgram {\n+    static final String USAGE_DETAILS =\n+            \"CombineGenotypingArrayVcfs takes one or more VCF files, as generated by GtcToVcf \" +\n+                    \"and combines them into a single VCF. \" +\n+                    \"The input VCFs must have the same sequence dictionary and same list of variant loci. \" +\n+                    \"The input VCFs must not share sample Ids. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar VcfToAdpc \\\\<br />\" +\n+                    \"      INPUT=input1.vcf \\\\<br />\" +\n+                    \"      INPUT=input2.vcf \\\\<br />\" +\n+                    \"      OUTPUT=output.vcf\" +\n+                    \"</pre>\";\n+\n+    @Argument(shortName= StandardOptionDefinitions.INPUT_SHORT_NAME,  doc=\"Input VCF file(s).\")\n+    public List<File> INPUT;\n+\n+    @Argument(shortName=StandardOptionDefinitions.OUTPUT_SHORT_NAME, doc=\"Output VCF file.\")\n+    public File OUTPUT;\n+\n+    private final Log log = Log.getInstance(CombineGenotypingArrayVcfs.class);\n+\n+    final private ProgressLogger progressLogger = new ProgressLogger(log, 10000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwNzM3MA=="}, "originalCommit": {"oid": "76e9d1fa33e1ab3277993e3d19d79c8b5e37ef16"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 705, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}