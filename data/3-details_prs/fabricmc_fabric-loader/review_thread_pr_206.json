{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3MzYwMTQz", "number": 206, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNTowMzoxNFrODivIEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNDoyNzo1MlrODusgQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzUwMjg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNTowMzoxNFrOFuJiTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNjo0MDoyOVrOFufu_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw==", "bodyText": "I suggest considering method inheritance here.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r383935053", "createdAt": "2020-02-25T15:03:14Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNzA4OQ==", "bodyText": "Player suggested to use tiny remapper for this (need exposing).\nEven then I think it would be best for loom to handle it, I dont know of an easy / quick way to do it here.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r383937089", "createdAt": "2020-02-25T15:06:24Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzODcyMA==", "bodyText": "Imo loom does not suffice, given if you raise visibility of a method from protected to public in net.minecraft.block.Block, other mods may still override that method and have it as protected, causing a runtime error.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r383938720", "createdAt": "2020-02-25T15:08:55Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3ODc4OQ==", "bodyText": "Widening superclass method accessibility does not cause a run time error.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384278789", "createdAt": "2020-02-26T05:16:19Z", "author": {"login": "kvverti"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4MjgzNA==", "bodyText": "Well, when the mod that raised the method to public calls the protected method, the runtime illegal access error occurs.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384282834", "createdAt": "2020-02-26T05:35:26Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4NTM5NA==", "bodyText": "That would be a compile time error in the development environment, not a run time error. (Just tested, not even a compile error) Calling an overriding protected method by virtual dispatch over a public superclass method does not in itself cause a run time error.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384285394", "createdAt": "2020-02-26T05:46:36Z", "author": {"login": "kvverti"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4NzIwNQ==", "bodyText": "Mind send class files that I can test? Too lazy to generate with asm", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384287205", "createdAt": "2020-02-26T05:54:37Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDQ4OA==", "bodyText": "Here is a Gist.\nPlace the files in the appropriate package structure, then compile and run using the following steps.\n\nSet access of Super#m to protected\n$ javac p/Super.java q/Sub.java\nSet access of Super#m to public\n$ javac p/Super.java\n$ javac access/AccessTest.java access/UseM.java\n$ java access.AccessTest\n\nYou should get the output\nSubclass\nSubclass", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384294488", "createdAt": "2020-02-26T06:23:45Z", "author": {"login": "kvverti"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NzI4Ng==", "bodyText": "Unfortunately GitHub will not allow me to upload a zip of the class files", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384297286", "createdAt": "2020-02-26T06:35:00Z", "author": {"login": "kvverti"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5ODc1MQ==", "bodyText": "Should be fine as removing final doesn't affect subclasses and protected still works.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384298751", "createdAt": "2020-02-26T06:40:29Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTgzMDExOnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNjo0Mjo0MFrOFufxbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNjo0Mjo0MFrOFufxbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5OTM3Mw==", "bodyText": "extra semicolon", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384299373", "createdAt": "2020-02-26T06:42:40Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tpublic enum Access {\n+\t\tDEFAULT(false, false, false),\n+\t\tPROTECTED(true, false, false),\n+\t\tPROTECTED_STRIP_FINAL(true, false, true),\n+\t\tPUBLIC(false, true, false),\n+\t\tPUBLIC_STRIP_FINAL(false, true, true),\n+\t\tSTRIP_FINAL(false, false, true);\n+\n+\t\tprivate final boolean makeProtected;\n+\t\tprivate final boolean makePublic;\n+\t\tprivate final boolean stripFinal;\n+\n+\t\tAccess(boolean makeProtected, boolean makePublic, boolean stripFinal) {\n+\t\t\tthis.makeProtected = makeProtected;\n+\t\t\tthis.makePublic = makePublic;\n+\t\t\tthis.stripFinal = stripFinal;\n+\t\t}\n+\n+\t\tpublic Access makePublic() {\n+\t\t\treturn stripFinal ? PUBLIC_STRIP_FINAL : PUBLIC;\n+\t\t}\n+\n+\t\tpublic Access makeProtected() {\n+\t\t\tif (makePublic) return this;\n+\t\t\treturn stripFinal ? PROTECTED_STRIP_FINAL : PROTECTED;\n+\t\t}\n+\n+\t\tpublic Access stripFinal() {\n+\t\t\tif (makePublic) {\n+\t\t\t\treturn PUBLIC_STRIP_FINAL;\n+\t\t\t} else if (makeProtected) {\n+\t\t\t\treturn PROTECTED_STRIP_FINAL;\n+\t\t\t}\n+\n+\t\t\treturn STRIP_FINAL;\n+\t\t}\n+\n+\t\tpublic int apply(int access) {\n+\t\t\tif (makePublic) {\n+\t\t\t\taccess = (access & ~7) | Opcodes.ACC_PUBLIC;\n+\t\t\t} else if (makeProtected) {\n+\t\t\t\tif ((access & Opcodes.ACC_PUBLIC) == 0) {\n+\t\t\t\t\t//Only make it protected if not public\n+\t\t\t\t\taccess = (access & ~7) | Opcodes.ACC_PROTECTED;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (stripFinal) {\n+\t\t\t\taccess = access & ~Opcodes.ACC_FINAL;;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTY0NTk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/FabricTransformer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNTo1MToxOVrOFuxHkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTozNDoyOVrOF5BMSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MzU3MA==", "bodyText": "This check may not be reached outside of dev env. Scroll up; you need to change the condition check for transformAccess local var to check for existence in access widener as well!", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384583570", "createdAt": "2020-02-26T15:51:19Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/FabricTransformer.java", "diffHunk": "@@ -56,6 +58,11 @@\n \t\tClassVisitor visitor = classWriter;\n \t\tint visitorCount = 0;\n \n+\t\tif (isMinecraftClass && FabricLoader.INSTANCE.getAccessWidener().getTargets().contains(name)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5MjQ1Mg==", "bodyText": "Ah yes, good spot.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384592452", "createdAt": "2020-02-26T16:03:20Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/FabricTransformer.java", "diffHunk": "@@ -56,6 +58,11 @@\n \t\tClassVisitor visitor = classWriter;\n \t\tint visitorCount = 0;\n \n+\t\tif (isMinecraftClass && FabricLoader.INSTANCE.getAccessWidener().getTargets().contains(name)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MzU3MA=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjY4MA==", "bodyText": "https://github.com/FabricMC/fabric-loader/pull/206/files#diff-357f0c28bb837e6ad9c13252885f47bcR52 Still needs to be fixed.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395332680", "createdAt": "2020-03-19T21:34:29Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/FabricTransformer.java", "diffHunk": "@@ -56,6 +58,11 @@\n \t\tClassVisitor visitor = classWriter;\n \t\tint visitorCount = 0;\n \n+\t\tif (isMinecraftClass && FabricLoader.INSTANCE.getAccessWidener().getTargets().contains(name)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MzU3MA=="}, "originalCommit": {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDA4MDkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxOTo1OTo1OFrOF4-WAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNjo1MVrOF4-4Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NjAxOA==", "bodyText": "The method could still have package visibility.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395286018", "createdAt": "2020-03-19T19:59:58Z", "author": {"login": "kvverti"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -195,21 +195,46 @@ public Access getMethodAccess(EntryTriple entryTriple) {\n \t\treturn classes;\n \t}\n \n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d06c704b1cf9d09b9f9c689f9a70d33698486ca9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDgwMw==", "bodyText": "I think ive fixed this now.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395294803", "createdAt": "2020-03-19T20:16:51Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -195,21 +195,46 @@ public Access getMethodAccess(EntryTriple entryTriple) {\n \t\treturn classes;\n \t}\n \n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NjAxOA=="}, "originalCommit": {"oid": "d06c704b1cf9d09b9f9c689f9a70d33698486ca9"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDA5MDg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDowMzoxMVrOF4-cig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTo1OTozMVrOF5B16Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NzY5MA==", "bodyText": "Classes can only be either public or package private.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395287690", "createdAt": "2020-03-19T20:03:11Z", "author": {"login": "kvverti"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -195,21 +195,46 @@ public Access getMethodAccess(EntryTriple entryTriple) {\n \t\treturn classes;\n \t}\n \n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n \tpublic interface Access {\n \t\tAccess makeAccessible();\n \n \t\tAccess makeExtendable();\n \n \t\tAccess makeMutable();\n \n-\t\tIntUnaryOperator getOperator();\n+\t\tint apply(int i);\n \t}\n \n \tpublic enum ClassAccess implements Access {\n \t\tDEFAULT(i -> i),\n-\t\tACCESSIBLE(i -> ((i & Opcodes.ACC_PRIVATE) != 0 ? Opcodes.ACC_FINAL : 0) | (i & ~7) | Opcodes.ACC_PUBLIC), //Make public, add final if private\n-\t\tEXTENDABLE(i -> ((i & ~7) | Opcodes.ACC_PUBLIC) & ~Opcodes.ACC_FINAL), //Make public and strip final\n-\t\tACCESSIBLE_EXTENDABLE(i -> ((i & ~7) | Opcodes.ACC_PUBLIC) & ~Opcodes.ACC_FINAL); //Make public and strip final\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makeProtected(removeFinal(i))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d06c704b1cf9d09b9f9c689f9a70d33698486ca9"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDUwNg==", "bodyText": "Nested class accessibility is defined in the InnerClasses attribute. This is used by the compiler to enforce access requirements for nested classes.\nJVMS-4.7.6", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395294506", "createdAt": "2020-03-19T20:16:17Z", "author": {"login": "kvverti"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -195,21 +195,46 @@ public Access getMethodAccess(EntryTriple entryTriple) {\n \t\treturn classes;\n \t}\n \n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n \tpublic interface Access {\n \t\tAccess makeAccessible();\n \n \t\tAccess makeExtendable();\n \n \t\tAccess makeMutable();\n \n-\t\tIntUnaryOperator getOperator();\n+\t\tint apply(int i);\n \t}\n \n \tpublic enum ClassAccess implements Access {\n \t\tDEFAULT(i -> i),\n-\t\tACCESSIBLE(i -> ((i & Opcodes.ACC_PRIVATE) != 0 ? Opcodes.ACC_FINAL : 0) | (i & ~7) | Opcodes.ACC_PUBLIC), //Make public, add final if private\n-\t\tEXTENDABLE(i -> ((i & ~7) | Opcodes.ACC_PUBLIC) & ~Opcodes.ACC_FINAL), //Make public and strip final\n-\t\tACCESSIBLE_EXTENDABLE(i -> ((i & ~7) | Opcodes.ACC_PUBLIC) & ~Opcodes.ACC_FINAL); //Make public and strip final\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makeProtected(removeFinal(i))),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NzY5MA=="}, "originalCommit": {"oid": "d06c704b1cf9d09b9f9c689f9a70d33698486ca9"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzMzNw==", "bodyText": "This is handled by visitInnerClass", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395343337", "createdAt": "2020-03-19T21:59:31Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -195,21 +195,46 @@ public Access getMethodAccess(EntryTriple entryTriple) {\n \t\treturn classes;\n \t}\n \n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n \tpublic interface Access {\n \t\tAccess makeAccessible();\n \n \t\tAccess makeExtendable();\n \n \t\tAccess makeMutable();\n \n-\t\tIntUnaryOperator getOperator();\n+\t\tint apply(int i);\n \t}\n \n \tpublic enum ClassAccess implements Access {\n \t\tDEFAULT(i -> i),\n-\t\tACCESSIBLE(i -> ((i & Opcodes.ACC_PRIVATE) != 0 ? Opcodes.ACC_FINAL : 0) | (i & ~7) | Opcodes.ACC_PUBLIC), //Make public, add final if private\n-\t\tEXTENDABLE(i -> ((i & ~7) | Opcodes.ACC_PUBLIC) & ~Opcodes.ACC_FINAL), //Make public and strip final\n-\t\tACCESSIBLE_EXTENDABLE(i -> ((i & ~7) | Opcodes.ACC_PUBLIC) & ~Opcodes.ACC_FINAL); //Make public and strip final\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makeProtected(removeFinal(i))),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NzY5MA=="}, "originalCommit": {"oid": "d06c704b1cf9d09b9f9c689f9a70d33698486ca9"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDEzNzk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxNzo1N1rOF4-6eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoxODozN1rOF4-72g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NTM1Mg==", "bodyText": "The method could still be package private...\nYou need if((i & Opcodes.ACC_PUBLIC) != 0)", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395295352", "createdAt": "2020-03-19T20:17:57Z", "author": {"login": "kvverti"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -200,7 +200,7 @@ private static int makePublic(int i) {\n \t}\n \n \tprivate static int makeProtected(int i) {\n-\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\tif ((i & ~Opcodes.ACC_PUBLIC) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc16c9b6011567950f2a1cfcca91e717d6dfacbf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NTcwNg==", "bodyText": "ah yeah, thanks :D", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395295706", "createdAt": "2020-03-19T20:18:37Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -200,7 +200,7 @@ private static int makePublic(int i) {\n \t}\n \n \tprivate static int makeProtected(int i) {\n-\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\tif ((i & ~Opcodes.ACC_PUBLIC) == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NTM1Mg=="}, "originalCommit": {"oid": "dc16c9b6011567950f2a1cfcca91e717d6dfacbf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDM2OTc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTozNTo0NVrOF5BOgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTo1NjozOVrOF5Bw_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzI0OA==", "bodyText": "Why no flexible namespace support but rather enforces the current namespace? Seems to me that it won't work in both dev and production", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395333248", "createdAt": "2020-03-19T21:35:45Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MDU0OQ==", "bodyText": "Humm, good point, ill have to bring over the remapper. Might almost be worth making this a lib now..", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395340549", "createdAt": "2020-03-19T21:52:47Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzI0OA=="}, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MjA3OA==", "bodyText": "Actaully no, this is fine. In dev everything is named and at runtime everything is intermediary it matches the mod classes. No need to change this.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395342078", "createdAt": "2020-03-19T21:56:39Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzI0OA=="}, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDM4MDE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTozOTozNFrOF5BVJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwMDoxNTo0MVrOF5Eh8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDk1MQ==", "bodyText": "Hmm, a class cannot be private, so makeFinalIfPrivate is pointless\nhttps://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1-200-E.1\n(private is not an option in this list)", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395334951", "createdAt": "2020-03-19T21:39:34Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NTAxMA==", "bodyText": "What does private class get compiled down to? package private?", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395345010", "createdAt": "2020-03-19T22:03:34Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDk1MQ=="}, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1MjUwOQ==", "bodyText": "package private I think, which guarantees the enclosing class' access to it as same-level class\n#206 (comment)", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395352509", "createdAt": "2020-03-19T22:22:26Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDk1MQ=="}, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NzM3Ng==", "bodyText": "Ok, I think we will need to remove this then.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395387376", "createdAt": "2020-03-20T00:15:41Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDk1MQ=="}, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDM4MzUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTo0MDo0OVrOF5BXZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTo1NDoxOFrOF5BtZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNTUyNw==", "bodyText": "guess this interface can extend IntUnaryOperator", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395335527", "createdAt": "2020-03-19T21:40:49Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MTE1Ng==", "bodyText": "I dont think there is much gain in doing so tbh.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395341156", "createdAt": "2020-03-19T21:54:18Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNTUyNw=="}, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDM5MTUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTo0NDowNVrOF5Bcww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowMToyOVrOF5B5Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjg5OQ==", "bodyText": "What if I want to make a field accessible as a subclass (protected) but not exposed to other users?", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395336899", "createdAt": "2020-03-19T21:44:05Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makePublic(removeFinal(i))),\n+\t\tACCESSIBLE_EXTENDABLE(i -> makePublic(removeFinal(i)));\n+\n+\t\tprivate final IntUnaryOperator operator;\n+\n+\t\tClassAccess(IntUnaryOperator operator) {\n+\t\t\tthis.operator = operator;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeAccessible() {\n+\t\t\tif (this == EXTENDABLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn ACCESSIBLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeExtendable() {\n+\t\t\tif (this == ACCESSIBLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn EXTENDABLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeMutable() {\n+\t\t\tthrow new UnsupportedOperationException(\"Classes cannot be made mutable\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int apply(int i) {\n+\t\t\treturn operator.applyAsInt(i);\n+\t\t}\n+\t}\n+\n+\tpublic enum MethodAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))), //Make public, add final if private\n+\t\tEXTENDABLE(i -> makeProtected(removeFinal(i))), //Make protected and strip final\n+\t\tACCESSIBLE_EXTENDABLE(i -> makePublic(removeFinal(i))); //Make public and strip final\n+\n+\t\tprivate final IntUnaryOperator operator;\n+\n+\t\tMethodAccess(IntUnaryOperator operator) {\n+\t\t\tthis.operator = operator;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeAccessible() {\n+\t\t\tif (this == EXTENDABLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn ACCESSIBLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeExtendable() {\n+\t\t\tif (this == ACCESSIBLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn EXTENDABLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeMutable() {\n+\t\t\tthrow new UnsupportedOperationException(\"Methods cannot be made mutable\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int apply(int i) {\n+\t\t\treturn operator.applyAsInt(i);\n+\t\t}\n+\t}\n+\n+\tpublic enum FieldAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(i)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDE4Mw==", "bodyText": "extendable doesnt really fit for fields, so I think this is fine.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395344183", "createdAt": "2020-03-19T22:01:29Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makePublic(removeFinal(i))),\n+\t\tACCESSIBLE_EXTENDABLE(i -> makePublic(removeFinal(i)));\n+\n+\t\tprivate final IntUnaryOperator operator;\n+\n+\t\tClassAccess(IntUnaryOperator operator) {\n+\t\t\tthis.operator = operator;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeAccessible() {\n+\t\t\tif (this == EXTENDABLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn ACCESSIBLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeExtendable() {\n+\t\t\tif (this == ACCESSIBLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn EXTENDABLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeMutable() {\n+\t\t\tthrow new UnsupportedOperationException(\"Classes cannot be made mutable\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int apply(int i) {\n+\t\t\treturn operator.applyAsInt(i);\n+\t\t}\n+\t}\n+\n+\tpublic enum MethodAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))), //Make public, add final if private\n+\t\tEXTENDABLE(i -> makeProtected(removeFinal(i))), //Make protected and strip final\n+\t\tACCESSIBLE_EXTENDABLE(i -> makePublic(removeFinal(i))); //Make public and strip final\n+\n+\t\tprivate final IntUnaryOperator operator;\n+\n+\t\tMethodAccess(IntUnaryOperator operator) {\n+\t\t\tthis.operator = operator;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeAccessible() {\n+\t\t\tif (this == EXTENDABLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn ACCESSIBLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeExtendable() {\n+\t\t\tif (this == ACCESSIBLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn EXTENDABLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeMutable() {\n+\t\t\tthrow new UnsupportedOperationException(\"Methods cannot be made mutable\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int apply(int i) {\n+\t\t\treturn operator.applyAsInt(i);\n+\t\t}\n+\t}\n+\n+\tpublic enum FieldAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(i)),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjg5OQ=="}, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 317}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDM5MjYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTo0NDozMVrOF5BdgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODozNTowMlrOF7pCRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNzA4OA==", "bodyText": "How about method being accessible by subclass but not other outer classes?", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395337088", "createdAt": "2020-03-19T21:44:31Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makePublic(removeFinal(i))),\n+\t\tACCESSIBLE_EXTENDABLE(i -> makePublic(removeFinal(i)));\n+\n+\t\tprivate final IntUnaryOperator operator;\n+\n+\t\tClassAccess(IntUnaryOperator operator) {\n+\t\t\tthis.operator = operator;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeAccessible() {\n+\t\t\tif (this == EXTENDABLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn ACCESSIBLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeExtendable() {\n+\t\t\tif (this == ACCESSIBLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn EXTENDABLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeMutable() {\n+\t\t\tthrow new UnsupportedOperationException(\"Classes cannot be made mutable\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int apply(int i) {\n+\t\t\treturn operator.applyAsInt(i);\n+\t\t}\n+\t}\n+\n+\tpublic enum MethodAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))), //Make public, add final if private", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NzI1MQ==", "bodyText": "Im not 100% sure what you mean? I dont think its an issue due to it actaully using the bridge method.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395387251", "createdAt": "2020-03-20T00:15:14Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makePublic(removeFinal(i))),\n+\t\tACCESSIBLE_EXTENDABLE(i -> makePublic(removeFinal(i)));\n+\n+\t\tprivate final IntUnaryOperator operator;\n+\n+\t\tClassAccess(IntUnaryOperator operator) {\n+\t\t\tthis.operator = operator;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeAccessible() {\n+\t\t\tif (this == EXTENDABLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn ACCESSIBLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeExtendable() {\n+\t\t\tif (this == ACCESSIBLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn EXTENDABLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeMutable() {\n+\t\t\tthrow new UnsupportedOperationException(\"Classes cannot be made mutable\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int apply(int i) {\n+\t\t\treturn operator.applyAsInt(i);\n+\t\t}\n+\t}\n+\n+\tpublic enum MethodAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))), //Make public, add final if private", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNzA4OA=="}, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA4MjYzMA==", "bodyText": "I think ill just remove makeFinalIfPrivate it sounds like its going to cause more issues than it will fix.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r398082630", "createdAt": "2020-03-25T18:35:02Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makePublic(removeFinal(i))),\n+\t\tACCESSIBLE_EXTENDABLE(i -> makePublic(removeFinal(i)));\n+\n+\t\tprivate final IntUnaryOperator operator;\n+\n+\t\tClassAccess(IntUnaryOperator operator) {\n+\t\t\tthis.operator = operator;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeAccessible() {\n+\t\t\tif (this == EXTENDABLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn ACCESSIBLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeExtendable() {\n+\t\t\tif (this == ACCESSIBLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn EXTENDABLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeMutable() {\n+\t\t\tthrow new UnsupportedOperationException(\"Classes cannot be made mutable\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int apply(int i) {\n+\t\t\treturn operator.applyAsInt(i);\n+\t\t}\n+\t}\n+\n+\tpublic enum MethodAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))), //Make public, add final if private", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNzA4OA=="}, "originalCommit": {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MjY2OTI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjo1Njo1NlrOF9zPGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzoxMDoyNFrOF9zv9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0NjkwNQ==", "bodyText": "The package should have lowercased name", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r400346905", "createdAt": "2020-03-30T16:56:56Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "639f5fd767e4f5a7a82ff83c3d28f9bcc79406b9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1NTMxOA==", "bodyText": "Done", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r400355318", "createdAt": "2020-03-30T17:10:24Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0NjkwNQ=="}, "originalCommit": {"oid": "639f5fd767e4f5a7a82ff83c3d28f9bcc79406b9"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MjY5MDI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/launch/FabricTweaker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzowMjowM1rOF9zcOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzoxNjo1MlrOF9z_vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1MDI2Nw==", "bodyText": "This seems a bit redundant to me to call a method on the loader's instance, and then require the loader again as a param.\nCouldn't we just make the loader one of the ctor params for the AccessWideners since we won't usually be passing multiple instances of loader into the same game.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r400350267", "createdAt": "2020-03-30T17:02:03Z", "author": {"login": "i509VCB"}, "path": "src/main/java/net/fabricmc/loader/launch/FabricTweaker.java", "diffHunk": "@@ -122,6 +122,8 @@ public void injectIntoClassLoader(LaunchClassLoader launchClassLoader) {\n \t\t\t}\n \t\t}\n \n+\t\tFabricLoader.INSTANCE.getAccessWidener().loadFromMods(FabricLoader.INSTANCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "639f5fd767e4f5a7a82ff83c3d28f9bcc79406b9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1OTM1Ng==", "bodyText": "Done.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r400359356", "createdAt": "2020-03-30T17:16:52Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/launch/FabricTweaker.java", "diffHunk": "@@ -122,6 +122,8 @@ public void injectIntoClassLoader(LaunchClassLoader launchClassLoader) {\n \t\t\t}\n \t\t}\n \n+\t\tFabricLoader.INSTANCE.getAccessWidener().loadFromMods(FabricLoader.INSTANCE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1MDI2Nw=="}, "originalCommit": {"oid": "639f5fd767e4f5a7a82ff83c3d28f9bcc79406b9"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjM3NDkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/metadata/LoaderModMetadata.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMjozNDoyOVrOGAuV5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMjozNDoyOVrOGAuV5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQxMjQ1Mg==", "bodyText": "Maye something indicating nullability (not required, this is internal impl)", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r403412452", "createdAt": "2020-04-04T02:34:29Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/metadata/LoaderModMetadata.java", "diffHunk": "@@ -36,6 +36,7 @@ default String getOldStyleLanguageAdapter() {\n \tMap<String, String> getLanguageAdapterDefinitions();\n \tCollection<NestedJarEntry> getJars();\n \tCollection<String> getMixinConfigs(EnvType type);\n+\tString getAccessWidener();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjM3NTc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accesswidener/AccessWidener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMjozNTo1M1rOGAuWSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNDoyODo0OVrOGAyPiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQxMjU1NQ==", "bodyText": "Can we just do dynamic namespace remapping instead, which the mapping parser already allows? We cannot always assume that we run in intermediary.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r403412555", "createdAt": "2020-04-04T02:35:53Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accesswidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accesswidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tprivate final FabricLoader fabricLoader;\n+\n+\tpublic AccessWidener(FabricLoader fabricLoader) {\n+\t\tthis.fabricLoader = fabricLoader;\n+\t}\n+\n+\tpublic void loadFromMods() {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ3NjM2Mw==", "bodyText": "The namespace matches the same as the mod's classes. When we do runtime remapping of mods then this can be done.\nI dont see a reason for it now.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r403476363", "createdAt": "2020-04-04T14:28:49Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/accesswidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accesswidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tprivate final FabricLoader fabricLoader;\n+\n+\tpublic AccessWidener(FabricLoader fabricLoader) {\n+\t\tthis.fabricLoader = fabricLoader;\n+\t}\n+\n+\tpublic void loadFromMods() {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQxMjU1NQ=="}, "originalCommit": {"oid": "ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjM3NjEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/accesswidener/AccessWidenerVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMjozNjo0NFrOGAuWgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMjozNjo0NFrOGAuWgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQxMjYwOA==", "bodyText": "Remember to bump this to 8 later", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r403412608", "createdAt": "2020-04-04T02:36:44Z", "author": {"login": "liach"}, "path": "src/main/java/net/fabricmc/loader/transformer/accesswidener/AccessWidenerVisitor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accesswidener;\n+\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.FieldVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidenerVisitor extends ClassVisitor {\n+\tprivate final AccessWidener accessWidener;\n+\n+\tprivate String className;\n+\n+\tpublic AccessWidenerVisitor(int api, ClassVisitor classVisitor, AccessWidener accessWidener) {\n+\t\tsuper(api, classVisitor);\n+\t\tthis.accessWidener = accessWidener;\n+\t}\n+\n+\t@Override\n+\tpublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+\t\tclassName = name;\n+\t\tsuper.visit(\n+\t\t\t\tversion,\n+\t\t\t\taccessWidener.getClassAccess(name).applyAsInt(access),\n+\t\t\t\tname,\n+\t\t\t\tsignature,\n+\t\t\t\tsuperName,\n+\t\t\t\tinterfaces\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void visitInnerClass(String name, String outerName, String innerName, int access) {\n+\t\tsuper.visitInnerClass(\n+\t\t\t\tname,\n+\t\t\t\touterName,\n+\t\t\t\tinnerName,\n+\t\t\t\taccessWidener.getClassAccess(name).applyAsInt(access)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n+\t\treturn super.visitField(\n+\t\t\t\taccessWidener.getFieldAccess(new EntryTriple(className, name, descriptor)).applyAsInt(access),\n+\t\t\t\tname,\n+\t\t\t\tdescriptor,\n+\t\t\t\tsignature,\n+\t\t\t\tvalue\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n+\t\treturn new AccessWidenerMethodVisitor(super.visitMethod(\n+\t\t\t\taccessWidener.getMethodAccess(new EntryTriple(className, name, descriptor)).applyAsInt(access),\n+\t\t\t\tname,\n+\t\t\t\tdescriptor,\n+\t\t\t\tsignature,\n+\t\t\t\texceptions\n+\t\t));\n+\t}\n+\n+\tprivate class AccessWidenerMethodVisitor extends MethodVisitor {\n+\t\tAccessWidenerMethodVisitor(MethodVisitor methodVisitor) {\n+\t\t\tsuper(Opcodes.ASM7, methodVisitor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjkwMjQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/net/fabricmc/loader/transformer/FabricTransformer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNDoyNzo1MlrOGAyPIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQxNDoyNzo1MlrOGAyPIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ3NjI1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tvisitor = new AccessWidenerVisitor(Opcodes.ASM7, visitor, FabricLoader.INSTANCE.getAccessWidener());\n          \n          \n            \n            \t\t\tvisitor = new AccessWidenerVisitor(Opcodes.ASM8, visitor, FabricLoader.INSTANCE.getAccessWidener());\n          \n      \n    \n    \n  \n\nThis will need doing when the ASM8 PR is merged.", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r403476256", "createdAt": "2020-04-04T14:27:52Z", "author": {"login": "modmuss50"}, "path": "src/main/java/net/fabricmc/loader/transformer/FabricTransformer.java", "diffHunk": "@@ -56,6 +59,11 @@\n \t\tClassVisitor visitor = classWriter;\n \t\tint visitorCount = 0;\n \n+\t\tif (applyAccessWidener) {\n+\t\t\tvisitor = new AccessWidenerVisitor(Opcodes.ASM7, visitor, FabricLoader.INSTANCE.getAccessWidener());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3283, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}