{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMzIxNDY1", "number": 2167, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozODo0N1rOEykJCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzowNjozMlrOEylk1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDU2Mzk1OnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/parts/Armor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozODo0N1rOHpR_WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozODo0N1rOHpR_WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0ODQwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Armor a = (Armor)campaign.getWarehouse().findSparePart(part -> {\n          \n          \n            \n                    Armor a = (Armor) campaign.getWarehouse().findSparePart(part -> {", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513048408", "createdAt": "2020-10-27T21:38:47Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/parts/Armor.java", "diffHunk": "@@ -565,7 +565,7 @@ public boolean isEnoughSpareArmorAvailable() {\n     }\n \n     public int getAmountAvailable() {\n-        Armor a = (Armor)campaign.findSparePart(part -> {\n+        Armor a = (Armor)campaign.getWarehouse().findSparePart(part -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDU2NDIzOnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/parts/Armor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozODo1M1rOHpR_jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozODo1M1rOHpR_jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0ODQ2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Armor a = (Armor)campaign.getWarehouse().findSparePart(part -> {\n          \n          \n            \n                    Armor a = (Armor) campaign.getWarehouse().findSparePart(part -> {", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513048461", "createdAt": "2020-10-27T21:38:53Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/parts/Armor.java", "diffHunk": "@@ -576,7 +576,7 @@ public int getAmountAvailable() {\n     }\n \n     public void changeAmountAvailable(int amount) {\n-        Armor a = (Armor)campaign.findSparePart(part -> {\n+        Armor a = (Armor)campaign.getWarehouse().findSparePart(part -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDU2NTMxOnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/parts/BaArmor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozOToxMFrOHpSALw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozOToxMFrOHpSALw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0ODYyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    BaArmor a = (BaArmor)campaign.getWarehouse().findSparePart(part -> {\n          \n          \n            \n                    BaArmor a = (BaArmor) campaign.getWarehouse().findSparePart(part -> {", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513048623", "createdAt": "2020-10-27T21:39:10Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/parts/BaArmor.java", "diffHunk": "@@ -153,7 +153,7 @@ public Part getNewPart() {\n     }\n \n     public int getAmountAvailable() {\n-        BaArmor a = (BaArmor)campaign.findSparePart(part -> {\n+        BaArmor a = (BaArmor)campaign.getWarehouse().findSparePart(part -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDU2NTc3OnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/parts/BaArmor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozOToxNVrOHpSAbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozOToxNVrOHpSAbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0ODY4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    BaArmor a = (BaArmor)campaign.getWarehouse().findSparePart(part -> {\n          \n          \n            \n                    BaArmor a = (BaArmor) campaign.getWarehouse().findSparePart(part -> {", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513048685", "createdAt": "2020-10-27T21:39:15Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/parts/BaArmor.java", "diffHunk": "@@ -166,7 +166,7 @@ public int getAmountAvailable() {\n \n     @Override\n     public void changeAmountAvailable(int amount) {\n-        BaArmor a = (BaArmor)campaign.findSparePart(part -> {\n+        BaArmor a = (BaArmor)campaign.getWarehouse().findSparePart(part -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDU3NTg1OnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/parts/ProtomekArmor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo0MjowM1rOHpSGDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo0MjowM1rOHpSGDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1MDEyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ProtomekArmor a = (ProtomekArmor)campaign.getWarehouse().findSparePart(part -> {\n          \n          \n            \n                    ProtomekArmor a = (ProtomekArmor) campaign.getWarehouse().findSparePart(part -> {", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513050126", "createdAt": "2020-10-27T21:42:03Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/parts/ProtomekArmor.java", "diffHunk": "@@ -123,7 +123,7 @@ public Part getNewPart() {\n     }\n \n     public int getAmountAvailable() {\n-        ProtomekArmor a = (ProtomekArmor)campaign.findSparePart(part -> {\n+        ProtomekArmor a = (ProtomekArmor)campaign.getWarehouse().findSparePart(part -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDU3NjUwOnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/parts/ProtomekArmor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo0MjoxNlrOHpSGcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo0MjoxNlrOHpSGcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1MDIyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ProtomekArmor a = (ProtomekArmor)campaign.getWarehouse().findSparePart(part -> {\n          \n          \n            \n                    ProtomekArmor a = (ProtomekArmor) campaign.getWarehouse().findSparePart(part -> {", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513050226", "createdAt": "2020-10-27T21:42:16Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/parts/ProtomekArmor.java", "diffHunk": "@@ -135,7 +135,7 @@ public int getAmountAvailable() {\n     }\n \n     public void changeAmountAvailable(int amount) {\n-        ProtomekArmor a = (ProtomekArmor)campaign.findSparePart(part -> {\n+        ProtomekArmor a = (ProtomekArmor)campaign.getWarehouse().findSparePart(part -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDU3NzQyOnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/parts/SVArmor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo0MjozMlrOHpSHAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo0MjozMlrOHpSHAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1MDM2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    SVArmor a = (SVArmor)campaign.getWarehouse().findSparePart(part -> {\n          \n          \n            \n                    SVArmor a = (SVArmor) campaign.getWarehouse().findSparePart(part -> {", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513050368", "createdAt": "2020-10-27T21:42:32Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/parts/SVArmor.java", "diffHunk": "@@ -131,7 +131,7 @@ public Part getNewPart() {\n     }\n \n     public int getAmountAvailable() {\n-        SVArmor a = (SVArmor)campaign.findSparePart(part -> {\n+        SVArmor a = (SVArmor)campaign.getWarehouse().findSparePart(part -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDU3NzcyOnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/parts/SVArmor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo0MjozOFrOHpSHKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo0MjozOFrOHpSHKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1MDQxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    SVArmor a = (SVArmor)campaign.getWarehouse().findSparePart(part -> {\n          \n          \n            \n                    SVArmor a = (SVArmor) campaign.getWarehouse().findSparePart(part -> {", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513050410", "createdAt": "2020-10-27T21:42:38Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/parts/SVArmor.java", "diffHunk": "@@ -141,7 +141,7 @@ public int getAmountAvailable() {\n     }\n \n     public void changeAmountAvailable(int amount) {\n-        SVArmor a = (SVArmor)campaign.findSparePart(part -> {\n+        SVArmor a = (SVArmor)campaign.getWarehouse().findSparePart(part -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYwMjUzOnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/EventSpy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1MDozMFrOHpSVpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1MDozMFrOHpSVpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NDExOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n          \n          \n            \n             * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513054118", "createdAt": "2020-10-27T21:50:30Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/EventSpy.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYwMjg1OnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/EventSpy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1MDozNVrOHpSV0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1MjoyOVrOHpSZWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NDE2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n          \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513054162", "createdAt": "2020-10-27T21:50:35Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/EventSpy.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NTA2NA==", "bodyText": "Double spacing is an accessibility issue.", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513055064", "createdAt": "2020-10-27T21:52:29Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/EventSpy.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NDE2Mg=="}, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYwNzQ3OnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/EventSpy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1MjoxMFrOHpSYrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1MjoxMFrOHpSYrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NDg5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return The list of events which occurred, in order\n          \n          \n            \n                 * @return The list of events which occurred, in the order", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513054894", "createdAt": "2020-10-27T21:52:10Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/EventSpy.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.MMEvent;\n+import megamek.common.event.Subscribe;\n+import mekhq.campaign.event.*;\n+\n+/**\n+ * Provides a list of events captured during its lifetime.\n+ * Use this as part of a try-with-resources block.\n+ *\n+ * If you need to listen to a new event, add a handler to this\n+ * class.\n+ */\n+public class EventSpy implements AutoCloseable {\n+    private final List<MMEvent> events = new ArrayList<>();\n+\n+    /**\n+     * Creates a new EventSpy and registers it with\n+     * MekHQ's event bus.\n+     */\n+    public EventSpy() {\n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Deregisters this instance from MekHQ's event bus.\n+     */\n+    public void close() {\n+        MekHQ.unregisterHandler(this);\n+    }\n+\n+    /**\n+     * Gets the list of events which occurred.\n+     * @return The list of events which occurred, in order", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYxNTcwOnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1NDo0OVrOHpSdjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1NDo0OVrOHpSdjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NjE0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n          \n          \n            \n             * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513056141", "createdAt": "2020-10-27T21:54:49Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYxNjAwOnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1NDo1NFrOHpSdwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1NDo1NFrOHpSdwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NjE5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n          \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513056193", "createdAt": "2020-10-27T21:54:54Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYyMzEzOnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1NzoyNVrOHpSiIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1NzoyNVrOHpSiIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NzMxMw==", "bodyText": "This can almost certainly be simplified into a single line.", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513057313", "createdAt": "2020-10-27T21:57:25Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign;\n+\n+import org.junit.Test;\n+\n+import megamek.common.AmmoType;\n+import megamek.common.Entity;\n+import megamek.common.EquipmentType;\n+import megamek.common.Mech;\n+import mekhq.EventSpy;\n+import mekhq.campaign.event.PartChangedEvent;\n+import mekhq.campaign.event.PartNewEvent;\n+import mekhq.campaign.event.PartRemovedEvent;\n+import mekhq.campaign.parts.AmmoStorage;\n+import mekhq.campaign.parts.Armor;\n+import mekhq.campaign.parts.MekLocation;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.unit.Unit;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class WarehouseTest {\n+    @Test\n+    public void testWarehouseSimplePartActions() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // A new warehouse is empty\n+        assertTrue(warehouse.getParts().isEmpty());\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockId));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockId));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYyNTAxOnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1ODowNlrOHpSjSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1ODowNlrOHpSjSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NzYxMQ==", "bodyText": "This can almost certainly be simplified into a single line of test with the explanation before.", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513057611", "createdAt": "2020-10-27T21:58:06Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign;\n+\n+import org.junit.Test;\n+\n+import megamek.common.AmmoType;\n+import megamek.common.Entity;\n+import megamek.common.EquipmentType;\n+import megamek.common.Mech;\n+import mekhq.EventSpy;\n+import mekhq.campaign.event.PartChangedEvent;\n+import mekhq.campaign.event.PartNewEvent;\n+import mekhq.campaign.event.PartRemovedEvent;\n+import mekhq.campaign.parts.AmmoStorage;\n+import mekhq.campaign.parts.Armor;\n+import mekhq.campaign.parts.MekLocation;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.unit.Unit;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class WarehouseTest {\n+    @Test\n+    public void testWarehouseSimplePartActions() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // A new warehouse is empty\n+        assertTrue(warehouse.getParts().isEmpty());\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockId));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYyNTY0OnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1ODoxOVrOHpSjpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1ODoxOVrOHpSjpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NzcwMQ==", "bodyText": "Same here", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513057701", "createdAt": "2020-10-27T21:58:19Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign;\n+\n+import org.junit.Test;\n+\n+import megamek.common.AmmoType;\n+import megamek.common.Entity;\n+import megamek.common.EquipmentType;\n+import megamek.common.Mech;\n+import mekhq.EventSpy;\n+import mekhq.campaign.event.PartChangedEvent;\n+import mekhq.campaign.event.PartNewEvent;\n+import mekhq.campaign.event.PartRemovedEvent;\n+import mekhq.campaign.parts.AmmoStorage;\n+import mekhq.campaign.parts.Armor;\n+import mekhq.campaign.parts.MekLocation;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.unit.Unit;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class WarehouseTest {\n+    @Test\n+    public void testWarehouseSimplePartActions() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // A new warehouse is empty\n+        assertTrue(warehouse.getParts().isEmpty());\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockId));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockId));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart.getId() > 0);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockPart.getId()));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYyNjE5OnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1ODozNFrOHpSkAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1ODozNFrOHpSkAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1Nzc5NQ==", "bodyText": "And here", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513057795", "createdAt": "2020-10-27T21:58:34Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign;\n+\n+import org.junit.Test;\n+\n+import megamek.common.AmmoType;\n+import megamek.common.Entity;\n+import megamek.common.EquipmentType;\n+import megamek.common.Mech;\n+import mekhq.EventSpy;\n+import mekhq.campaign.event.PartChangedEvent;\n+import mekhq.campaign.event.PartNewEvent;\n+import mekhq.campaign.event.PartRemovedEvent;\n+import mekhq.campaign.parts.AmmoStorage;\n+import mekhq.campaign.parts.Armor;\n+import mekhq.campaign.parts.MekLocation;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.unit.Unit;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class WarehouseTest {\n+    @Test\n+    public void testWarehouseSimplePartActions() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // A new warehouse is empty\n+        assertTrue(warehouse.getParts().isEmpty());\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockId));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockId));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart.getId() > 0);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockPart.getId()));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockPart.getId()));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYyNjY3OnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1ODo0M1rOHpSkSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1ODo0M1rOHpSkSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1Nzg2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // ...that is not the same as our previous part\n          \n          \n            \n                    // ... that is not the same as our previous part", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513057865", "createdAt": "2020-10-27T21:58:43Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign;\n+\n+import org.junit.Test;\n+\n+import megamek.common.AmmoType;\n+import megamek.common.Entity;\n+import megamek.common.EquipmentType;\n+import megamek.common.Mech;\n+import mekhq.EventSpy;\n+import mekhq.campaign.event.PartChangedEvent;\n+import mekhq.campaign.event.PartNewEvent;\n+import mekhq.campaign.event.PartRemovedEvent;\n+import mekhq.campaign.parts.AmmoStorage;\n+import mekhq.campaign.parts.Armor;\n+import mekhq.campaign.parts.MekLocation;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.unit.Unit;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class WarehouseTest {\n+    @Test\n+    public void testWarehouseSimplePartActions() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // A new warehouse is empty\n+        assertTrue(warehouse.getParts().isEmpty());\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockId));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockId));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart.getId() > 0);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockPart.getId()));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockPart.getId()));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddSecondNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart0 = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart0.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart0).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart0);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart0.getId() > 0);\n+\n+        // Create a second mock part without an ID\n+        Part mockPart1 = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart1.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart1).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart1);\n+\n+        // We should have been assigned an ID...\n+        assertTrue(mockPart1.getId() > 0);\n+\n+        // ...that is not the same as our previous part", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDYzMDIwOnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1OTo0OVrOHpSmbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNDozMToxM1rOHpZrCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1ODQxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ArrayList<Part> mockChildParts = new ArrayList<>();\n          \n          \n            \n                    List<Part> mockChildParts = new ArrayList<>();", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513058415", "createdAt": "2020-10-27T21:59:49Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign;\n+\n+import org.junit.Test;\n+\n+import megamek.common.AmmoType;\n+import megamek.common.Entity;\n+import megamek.common.EquipmentType;\n+import megamek.common.Mech;\n+import mekhq.EventSpy;\n+import mekhq.campaign.event.PartChangedEvent;\n+import mekhq.campaign.event.PartNewEvent;\n+import mekhq.campaign.event.PartRemovedEvent;\n+import mekhq.campaign.parts.AmmoStorage;\n+import mekhq.campaign.parts.Armor;\n+import mekhq.campaign.parts.MekLocation;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.unit.Unit;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class WarehouseTest {\n+    @Test\n+    public void testWarehouseSimplePartActions() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // A new warehouse is empty\n+        assertTrue(warehouse.getParts().isEmpty());\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockId));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockId));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart.getId() > 0);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockPart.getId()));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockPart.getId()));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddSecondNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart0 = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart0.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart0).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart0);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart0.getId() > 0);\n+\n+        // Create a second mock part without an ID\n+        Part mockPart1 = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart1.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart1).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart1);\n+\n+        // We should have been assigned an ID...\n+        assertTrue(mockPart1.getId() > 0);\n+\n+        // ...that is not the same as our previous part\n+        assertNotEquals(mockPart0.getId(), mockPart1.getId());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddPartEvent() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        try (EventSpy eventSpy = new EventSpy()) {\n+            // Add the mock part to our warehouse\n+            warehouse.addPart(mockPart);\n+\n+            // This part never existed so there should be\n+            // a PartNewEvent fired.\n+            assertTrue(eventSpy.getEvents()\n+                    .stream()\n+                    .filter(e -> e instanceof PartNewEvent)\n+                    .filter(e -> mockPart == ((PartNewEvent) e).getPart())\n+                    .findAny()\n+                    .isPresent());\n+\n+            // Add the part again, simulating being say removed from a\n+            // unit or something\n+            warehouse.addPart(mockPart);\n+\n+            // There should be only ONE event as we did not add\n+            // this part to the warehouse\n+            assertEquals(1,\n+                    eventSpy.getEvents()\n+                            .stream()\n+                            .filter(e -> e instanceof PartNewEvent)\n+                            .filter(e -> mockPart == ((PartNewEvent) e).getPart())\n+                            .count());\n+        }\n+    }\n+\n+    @Test\n+    public void testWarehouseRemovePart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        try (EventSpy eventSpy = new EventSpy()) {\n+            // Ensure we can't remove a part that doesn't exist\n+            assertFalse(warehouse.removePart(mockPart));\n+\n+            // If we didn't remove a part, we should have no event\n+            assertFalse(eventSpy.getEvents()\n+                    .stream()\n+                    .filter(e -> e instanceof PartRemovedEvent)\n+                    .findAny()\n+                    .isPresent());\n+\n+            // Add the mock part to our warehouse\n+            warehouse.addPart(mockPart);\n+\n+            // Ensure we can then remove the part\n+            assertTrue(warehouse.removePart(mockPart));\n+\n+            // There should be an event where we removed the mock part\n+            assertEquals(1,\n+                    eventSpy.getEvents()\n+                            .stream()\n+                            .filter(e -> e instanceof PartRemovedEvent)\n+                            .filter(e -> mockPart == ((PartRemovedEvent) e).getPart())\n+                            .count());\n+        }\n+    }\n+\n+    @Test\n+    public void testWarehouseRemoveChildParts() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Add a parent part to the warehouse\n+        Part mockParentPart = createMockPart(1);\n+        warehouse.addPart(mockParentPart);\n+\n+        // Create child parts for the parent part\n+        ArrayList<Part> mockChildParts = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2Njk0MA==", "bodyText": "I'm mocking an ArrayList:\n\n  \n    \n      mekhq/MekHQ/src/mekhq/campaign/parts/Part.java\n    \n    \n         Line 1458\n      in\n      fc47919\n    \n    \n    \n    \n\n        \n          \n           public ArrayList<Part> getChildParts() {", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513166940", "createdAt": "2020-10-28T04:01:26Z", "author": {"login": "sixlettervariables"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign;\n+\n+import org.junit.Test;\n+\n+import megamek.common.AmmoType;\n+import megamek.common.Entity;\n+import megamek.common.EquipmentType;\n+import megamek.common.Mech;\n+import mekhq.EventSpy;\n+import mekhq.campaign.event.PartChangedEvent;\n+import mekhq.campaign.event.PartNewEvent;\n+import mekhq.campaign.event.PartRemovedEvent;\n+import mekhq.campaign.parts.AmmoStorage;\n+import mekhq.campaign.parts.Armor;\n+import mekhq.campaign.parts.MekLocation;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.unit.Unit;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class WarehouseTest {\n+    @Test\n+    public void testWarehouseSimplePartActions() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // A new warehouse is empty\n+        assertTrue(warehouse.getParts().isEmpty());\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockId));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockId));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart.getId() > 0);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockPart.getId()));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockPart.getId()));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddSecondNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart0 = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart0.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart0).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart0);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart0.getId() > 0);\n+\n+        // Create a second mock part without an ID\n+        Part mockPart1 = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart1.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart1).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart1);\n+\n+        // We should have been assigned an ID...\n+        assertTrue(mockPart1.getId() > 0);\n+\n+        // ...that is not the same as our previous part\n+        assertNotEquals(mockPart0.getId(), mockPart1.getId());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddPartEvent() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        try (EventSpy eventSpy = new EventSpy()) {\n+            // Add the mock part to our warehouse\n+            warehouse.addPart(mockPart);\n+\n+            // This part never existed so there should be\n+            // a PartNewEvent fired.\n+            assertTrue(eventSpy.getEvents()\n+                    .stream()\n+                    .filter(e -> e instanceof PartNewEvent)\n+                    .filter(e -> mockPart == ((PartNewEvent) e).getPart())\n+                    .findAny()\n+                    .isPresent());\n+\n+            // Add the part again, simulating being say removed from a\n+            // unit or something\n+            warehouse.addPart(mockPart);\n+\n+            // There should be only ONE event as we did not add\n+            // this part to the warehouse\n+            assertEquals(1,\n+                    eventSpy.getEvents()\n+                            .stream()\n+                            .filter(e -> e instanceof PartNewEvent)\n+                            .filter(e -> mockPart == ((PartNewEvent) e).getPart())\n+                            .count());\n+        }\n+    }\n+\n+    @Test\n+    public void testWarehouseRemovePart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        try (EventSpy eventSpy = new EventSpy()) {\n+            // Ensure we can't remove a part that doesn't exist\n+            assertFalse(warehouse.removePart(mockPart));\n+\n+            // If we didn't remove a part, we should have no event\n+            assertFalse(eventSpy.getEvents()\n+                    .stream()\n+                    .filter(e -> e instanceof PartRemovedEvent)\n+                    .findAny()\n+                    .isPresent());\n+\n+            // Add the mock part to our warehouse\n+            warehouse.addPart(mockPart);\n+\n+            // Ensure we can then remove the part\n+            assertTrue(warehouse.removePart(mockPart));\n+\n+            // There should be an event where we removed the mock part\n+            assertEquals(1,\n+                    eventSpy.getEvents()\n+                            .stream()\n+                            .filter(e -> e instanceof PartRemovedEvent)\n+                            .filter(e -> mockPart == ((PartRemovedEvent) e).getPart())\n+                            .count());\n+        }\n+    }\n+\n+    @Test\n+    public void testWarehouseRemoveChildParts() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Add a parent part to the warehouse\n+        Part mockParentPart = createMockPart(1);\n+        warehouse.addPart(mockParentPart);\n+\n+        // Create child parts for the parent part\n+        ArrayList<Part> mockChildParts = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1ODQxNQ=="}, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MzI3Mg==", "bodyText": "Then this is an issue in the base method. Unless required any List methods should return list, not ArrayList", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513173272", "createdAt": "2020-10-28T04:27:25Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign;\n+\n+import org.junit.Test;\n+\n+import megamek.common.AmmoType;\n+import megamek.common.Entity;\n+import megamek.common.EquipmentType;\n+import megamek.common.Mech;\n+import mekhq.EventSpy;\n+import mekhq.campaign.event.PartChangedEvent;\n+import mekhq.campaign.event.PartNewEvent;\n+import mekhq.campaign.event.PartRemovedEvent;\n+import mekhq.campaign.parts.AmmoStorage;\n+import mekhq.campaign.parts.Armor;\n+import mekhq.campaign.parts.MekLocation;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.unit.Unit;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class WarehouseTest {\n+    @Test\n+    public void testWarehouseSimplePartActions() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // A new warehouse is empty\n+        assertTrue(warehouse.getParts().isEmpty());\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockId));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockId));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart.getId() > 0);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockPart.getId()));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockPart.getId()));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddSecondNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart0 = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart0.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart0).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart0);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart0.getId() > 0);\n+\n+        // Create a second mock part without an ID\n+        Part mockPart1 = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart1.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart1).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart1);\n+\n+        // We should have been assigned an ID...\n+        assertTrue(mockPart1.getId() > 0);\n+\n+        // ...that is not the same as our previous part\n+        assertNotEquals(mockPart0.getId(), mockPart1.getId());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddPartEvent() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        try (EventSpy eventSpy = new EventSpy()) {\n+            // Add the mock part to our warehouse\n+            warehouse.addPart(mockPart);\n+\n+            // This part never existed so there should be\n+            // a PartNewEvent fired.\n+            assertTrue(eventSpy.getEvents()\n+                    .stream()\n+                    .filter(e -> e instanceof PartNewEvent)\n+                    .filter(e -> mockPart == ((PartNewEvent) e).getPart())\n+                    .findAny()\n+                    .isPresent());\n+\n+            // Add the part again, simulating being say removed from a\n+            // unit or something\n+            warehouse.addPart(mockPart);\n+\n+            // There should be only ONE event as we did not add\n+            // this part to the warehouse\n+            assertEquals(1,\n+                    eventSpy.getEvents()\n+                            .stream()\n+                            .filter(e -> e instanceof PartNewEvent)\n+                            .filter(e -> mockPart == ((PartNewEvent) e).getPart())\n+                            .count());\n+        }\n+    }\n+\n+    @Test\n+    public void testWarehouseRemovePart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        try (EventSpy eventSpy = new EventSpy()) {\n+            // Ensure we can't remove a part that doesn't exist\n+            assertFalse(warehouse.removePart(mockPart));\n+\n+            // If we didn't remove a part, we should have no event\n+            assertFalse(eventSpy.getEvents()\n+                    .stream()\n+                    .filter(e -> e instanceof PartRemovedEvent)\n+                    .findAny()\n+                    .isPresent());\n+\n+            // Add the mock part to our warehouse\n+            warehouse.addPart(mockPart);\n+\n+            // Ensure we can then remove the part\n+            assertTrue(warehouse.removePart(mockPart));\n+\n+            // There should be an event where we removed the mock part\n+            assertEquals(1,\n+                    eventSpy.getEvents()\n+                            .stream()\n+                            .filter(e -> e instanceof PartRemovedEvent)\n+                            .filter(e -> mockPart == ((PartRemovedEvent) e).getPart())\n+                            .count());\n+        }\n+    }\n+\n+    @Test\n+    public void testWarehouseRemoveChildParts() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Add a parent part to the warehouse\n+        Part mockParentPart = createMockPart(1);\n+        warehouse.addPart(mockParentPart);\n+\n+        // Create child parts for the parent part\n+        ArrayList<Part> mockChildParts = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1ODQxNQ=="}, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3NDI4MQ==", "bodyText": "Sure, just not the scope of this PR.", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513174281", "createdAt": "2020-10-28T04:31:13Z", "author": {"login": "sixlettervariables"}, "path": "MekHQ/unittests/mekhq/campaign/WarehouseTest.java", "diffHunk": "@@ -0,0 +1,1020 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign;\n+\n+import org.junit.Test;\n+\n+import megamek.common.AmmoType;\n+import megamek.common.Entity;\n+import megamek.common.EquipmentType;\n+import megamek.common.Mech;\n+import mekhq.EventSpy;\n+import mekhq.campaign.event.PartChangedEvent;\n+import mekhq.campaign.event.PartNewEvent;\n+import mekhq.campaign.event.PartRemovedEvent;\n+import mekhq.campaign.parts.AmmoStorage;\n+import mekhq.campaign.parts.Armor;\n+import mekhq.campaign.parts.MekLocation;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.unit.Unit;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+public class WarehouseTest {\n+    @Test\n+    public void testWarehouseSimplePartActions() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // A new warehouse is empty\n+        assertTrue(warehouse.getParts().isEmpty());\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockId));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockId));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart.getId() > 0);\n+\n+        // The part should be returned when we get it by ID\n+        assertEquals(mockPart, warehouse.getPart(mockPart.getId()));\n+\n+        // forEachPart should have our part\n+        warehouse.forEachPart(p -> {\n+            // There should only be one part in the warehouse\n+            // and it should be our part\n+            assertEquals(mockPart, p);\n+        });\n+\n+        // getParts should return the part\n+        assertTrue(warehouse.getParts().contains(mockPart));\n+\n+        // The part should also be removed when we request it\n+        assertTrue(warehouse.removePart(mockPart));\n+\n+        // And the part should no longer be in the warehouse\n+        assertNull(warehouse.getPart(mockPart.getId()));\n+\n+        // We should not run over any part once removed\n+        warehouse.forEachPart(p -> {\n+            assertTrue(false);\n+        });\n+\n+        // getParts should no longer contain anything\n+        assertTrue(warehouse.getParts().isEmpty());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddSecondNewPart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part without an ID\n+        Part mockPart0 = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart0.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart0).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart0);\n+\n+        // We should have been assigned an ID\n+        assertTrue(mockPart0.getId() > 0);\n+\n+        // Create a second mock part without an ID\n+        Part mockPart1 = mock(Part.class, RETURNS_DEEP_STUBS);\n+        when(mockPart1.getId()).thenCallRealMethod();\n+        doCallRealMethod().when(mockPart1).setId(anyInt());\n+\n+        // Add the mock part to our warehouse\n+        warehouse.addPart(mockPart1);\n+\n+        // We should have been assigned an ID...\n+        assertTrue(mockPart1.getId() > 0);\n+\n+        // ...that is not the same as our previous part\n+        assertNotEquals(mockPart0.getId(), mockPart1.getId());\n+    }\n+\n+    @Test\n+    public void testWarehouseAddPartEvent() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        try (EventSpy eventSpy = new EventSpy()) {\n+            // Add the mock part to our warehouse\n+            warehouse.addPart(mockPart);\n+\n+            // This part never existed so there should be\n+            // a PartNewEvent fired.\n+            assertTrue(eventSpy.getEvents()\n+                    .stream()\n+                    .filter(e -> e instanceof PartNewEvent)\n+                    .filter(e -> mockPart == ((PartNewEvent) e).getPart())\n+                    .findAny()\n+                    .isPresent());\n+\n+            // Add the part again, simulating being say removed from a\n+            // unit or something\n+            warehouse.addPart(mockPart);\n+\n+            // There should be only ONE event as we did not add\n+            // this part to the warehouse\n+            assertEquals(1,\n+                    eventSpy.getEvents()\n+                            .stream()\n+                            .filter(e -> e instanceof PartNewEvent)\n+                            .filter(e -> mockPart == ((PartNewEvent) e).getPart())\n+                            .count());\n+        }\n+    }\n+\n+    @Test\n+    public void testWarehouseRemovePart() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Create a mock part\n+        int mockId = 10;\n+        Part mockPart = mock(Part.class);\n+        when(mockPart.getId()).thenReturn(mockId);\n+\n+        try (EventSpy eventSpy = new EventSpy()) {\n+            // Ensure we can't remove a part that doesn't exist\n+            assertFalse(warehouse.removePart(mockPart));\n+\n+            // If we didn't remove a part, we should have no event\n+            assertFalse(eventSpy.getEvents()\n+                    .stream()\n+                    .filter(e -> e instanceof PartRemovedEvent)\n+                    .findAny()\n+                    .isPresent());\n+\n+            // Add the mock part to our warehouse\n+            warehouse.addPart(mockPart);\n+\n+            // Ensure we can then remove the part\n+            assertTrue(warehouse.removePart(mockPart));\n+\n+            // There should be an event where we removed the mock part\n+            assertEquals(1,\n+                    eventSpy.getEvents()\n+                            .stream()\n+                            .filter(e -> e instanceof PartRemovedEvent)\n+                            .filter(e -> mockPart == ((PartRemovedEvent) e).getPart())\n+                            .count());\n+        }\n+    }\n+\n+    @Test\n+    public void testWarehouseRemoveChildParts() {\n+        Warehouse warehouse = new Warehouse();\n+\n+        // Add a parent part to the warehouse\n+        Part mockParentPart = createMockPart(1);\n+        warehouse.addPart(mockParentPart);\n+\n+        // Create child parts for the parent part\n+        ArrayList<Part> mockChildParts = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1ODQxNQ=="}, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDcwNDE4OnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/Warehouse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjoyNTo1NFrOHpTSOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjoyNTo1NFrOHpTSOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2OTYyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n          \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513069627", "createdAt": "2020-10-27T22:25:54Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/Warehouse.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDcwNDQ5OnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/Warehouse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjoyNjowMVrOHpTSag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjoyNjowMVrOHpTSag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2OTY3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n          \n          \n            \n             * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513069674", "createdAt": "2020-10-27T22:26:01Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/Warehouse.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDcyNjExOnYy", "diffSide": "RIGHT", "path": "MekHQ/src/mekhq/campaign/Warehouse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjozNDo0M1rOHpTf1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjozNDo0M1rOHpTf1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3MzExMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // ...we did not merge parts, so fall through to the\n          \n          \n            \n                        // ... we did not merge parts, so fall through to the", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513073111", "createdAt": "2020-10-27T22:34:43Z", "author": {"login": "Windchild292"}, "path": "MekHQ/src/mekhq/campaign/Warehouse.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import megamek.common.annotations.Nullable;\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.event.PartChangedEvent;\n+import mekhq.campaign.event.PartNewEvent;\n+import mekhq.campaign.event.PartRemovedEvent;\n+import mekhq.campaign.parts.AmmoStorage;\n+import mekhq.campaign.parts.Armor;\n+import mekhq.campaign.parts.Part;\n+\n+/**\n+ * Stores parts for a Campaign.\n+ */\n+public class Warehouse {\n+    private final TreeMap<Integer, Part> parts = new TreeMap<>();\n+\n+    /**\n+     * Adds a part to the warehouse.\n+     * @param part The part to add to the warehouse.\n+     * @return The part added to the warehouse.\n+     */\n+    public Part addPart(Part part) {\n+        return addPart(part, false);\n+    }\n+\n+    /**\n+     * Adds a part to the warehouse, optionally merging it with\n+     * any existing spare part.\n+     * @param part The part to add to the warehouse.\n+     * @param mergeWithExisting If true and the part is spare, it may\n+     *                          be merged with an existing spare part.\n+     * @return The part itself or the spare part it was merged with.\n+     */\n+    public Part addPart(Part part, boolean mergeWithExisting) {\n+        Objects.requireNonNull(part);\n+\n+        if (mergeWithExisting && part.isSpare()) {\n+            Part mergedPart = mergePartWithExisting(part);\n+\n+            // CAW: intentional reference equality\n+            if (mergedPart != part) {\n+                // We've merged parts, so let interested parties know we've\n+                // updated the merged part.\n+                MekHQ.triggerEvent(new PartChangedEvent(mergedPart));\n+\n+                // Check if the part being added exists, and if so\n+                // remove it from the warehouse\n+                if (part.getId() > 0) {\n+                    removePart(part);\n+                }\n+\n+                return mergedPart;\n+            }\n+\n+            // ...we did not merge parts, so fall through to the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDc5ODkzOnYy", "diffSide": "RIGHT", "path": "MekHQ/unittests/mekhq/EventSpy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzowNjozMlrOHpULsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzowNjozMlrOHpULsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDMzOA==", "bodyText": "This is a perfect example of an accessibility issue where the comment is split over two lines. One line would be best, even if it goes slightly over the expected length, when only a single word is split to make it . This is irregardless of screen size, because this actually leads to far longer comprehension.", "url": "https://github.com/MegaMek/mekhq/pull/2167#discussion_r513084338", "createdAt": "2020-10-27T23:06:32Z", "author": {"login": "Windchild292"}, "path": "MekHQ/unittests/mekhq/EventSpy.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.MMEvent;\n+import megamek.common.event.Subscribe;\n+import mekhq.campaign.event.*;\n+\n+/**\n+ * Provides a list of events captured during its lifetime.\n+ * Use this as part of a try-with-resources block.\n+ *\n+ * If you need to listen to a new event, add a handler to this\n+ * class.\n+ */\n+public class EventSpy implements AutoCloseable {\n+    private final List<MMEvent> events = new ArrayList<>();\n+\n+    /**\n+     * Creates a new EventSpy and registers it with\n+     * MekHQ's event bus.\n+     */\n+    public EventSpy() {\n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Deregisters this instance from MekHQ's event bus.\n+     */\n+    public void close() {\n+        MekHQ.unregisterHandler(this);\n+    }\n+\n+    /**\n+     * Gets the list of events which occurred.\n+     * @return The list of events which occurred, in order\n+     *         received.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c883a5f8c0085c74e8f448ecd3c0f9c04227b067"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2142, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}