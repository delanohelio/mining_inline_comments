{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NzQyMjgy", "number": 2077, "title": "Standardizing MRMS Options", "bodyText": "This standardizes MRMS into immediately using MassRepairConfiguredOptions. This is required for a few future MRMS stories.", "createdAt": "2020-09-30T19:38:38Z", "url": "https://github.com/MegaMek/mekhq/pull/2077", "merged": true, "mergeCommit": {"oid": "26f6d5d0f1f8953baef290017e841681708d74fc"}, "closed": true, "closedAt": "2020-10-03T18:38:43Z", "author": {"login": "Windchild292"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOBvWeAH2gAyNDk1NzQyMjgyOjNkODQ1ZDk0OWM2MDBmYjdkY2M0NmVmMzkyMmYwYzMzNmQ0ZjNlM2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdO-yXTAH2gAyNDk1NzQyMjgyOjRjYmZlMDM4NTQwOGVmMjdkM2NkOWY5MDhhMTkyZjQ2ZmVlNzU0MWI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3d845d949c600fb7dcc46ef3922f0c336d4f3e3e", "author": {"user": {"login": "Windchild292", "name": "Justin Bowen"}}, "url": "https://github.com/MegaMek/mekhq/commit/3d845d949c600fb7dcc46ef3922f0c336d4f3e3e", "committedDate": "2020-09-30T19:13:48Z", "message": "Standardizing MRMS Options"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53658aba26652dbbac7a25dc1ea79ab44079a59b", "author": {"user": {"login": "Windchild292", "name": "Justin Bowen"}}, "url": "https://github.com/MegaMek/mekhq/commit/53658aba26652dbbac7a25dc1ea79ab44079a59b", "committedDate": "2020-09-30T19:25:49Z", "message": "Merge remote-tracking branch 'upstream/master' into dev_Windchild_MRMSOptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2d0988f7f69fa06002d7aeb19d68606a313d9e4", "author": {"user": {"login": "Windchild292", "name": "Justin Bowen"}}, "url": "https://github.com/MegaMek/mekhq/commit/c2d0988f7f69fa06002d7aeb19d68606a313d9e4", "committedDate": "2020-10-03T17:37:06Z", "message": "Fixing merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae5fb7e9fcec99a93a19afdab481d116899c125f", "author": {"user": {"login": "Windchild292", "name": "Justin Bowen"}}, "url": "https://github.com/MegaMek/mekhq/commit/ae5fb7e9fcec99a93a19afdab481d116899c125f", "committedDate": "2020-10-03T17:38:55Z", "message": "Logger standardization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTYzNzM0", "url": "https://github.com/MegaMek/mekhq/pull/2077#pullrequestreview-501563734", "createdAt": "2020-10-03T18:04:15Z", "commit": {"oid": "ae5fb7e9fcec99a93a19afdab481d116899c125f"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODowNDoxNVrOHcC2vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxODowNTo0OFrOHcC3TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2ODk1OQ==", "bodyText": "If this should be immutable then prefer Collections.emptyList(). (realizing this was perhaps inherited code)", "url": "https://github.com/MegaMek/mekhq/pull/2077#discussion_r499168959", "createdAt": "2020-10-03T18:04:15Z", "author": {"login": "sixlettervariables"}, "path": "MekHQ/src/mekhq/service/MassRepairConfiguredOptions.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package mekhq.service;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.CampaignOptions;\n+import mekhq.gui.dialog.MassRepairSalvageDialog;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class MassRepairConfiguredOptions {\n+    //region Variable Declarations\n+    private boolean useExtraTime;\n+    private boolean useRushJob;\n+    private boolean allowCarryover;\n+    private boolean optimizeToCompleteToday;\n+    private boolean useAssignedTechsFirst;\n+    private boolean scrapImpossible;\n+    private boolean replacePodParts;\n+    private List<MassRepairOption> massRepairOptions;\n+    private transient boolean hasActiveMassRepairOption;\n+    //endregion Variable Declarations\n+\n+    //region Constructors\n+    public MassRepairConfiguredOptions(Campaign campaign) {\n+        setup(campaign.getCampaignOptions());\n+    }\n+\n+    public MassRepairConfiguredOptions(MassRepairSalvageDialog massRepairSalvageDialog) {\n+        setup(massRepairSalvageDialog);\n+    }\n+    //endregion Constructors\n+\n+    //region Initialization\n+    public void setup(CampaignOptions options) {\n+        setUseExtraTime(options.massRepairUseExtraTime());\n+        setUseRushJob(options.massRepairUseRushJob());\n+        setAllowCarryover(options.massRepairAllowCarryover());\n+        setOptimizeToCompleteToday(options.massRepairOptimizeToCompleteToday());\n+        setScrapImpossible(options.massRepairScrapImpossible());\n+        setUseAssignedTechsFirst(options.massRepairUseAssignedTechsFirst());\n+        setReplacePodParts(options.massRepairReplacePod());\n+        setMassRepairOptions(options.getMassRepairOptions());\n+        for (MassRepairOption mro : getMassRepairOptions()) {\n+            if (mro.isActive()) {\n+                hasActiveMassRepairOption = true;\n+                break;\n+            }\n+        }\n+    }\n+\n+    public void setup(MassRepairSalvageDialog dlg) {\n+        setUseExtraTime(dlg.getUseExtraTimeBox().isSelected());\n+        setUseRushJob(dlg.getUseRushJobBox().isSelected());\n+        setAllowCarryover(dlg.getAllowCarryoverBox().isSelected());\n+        setOptimizeToCompleteToday(dlg.getOptimizeToCompleteTodayBox().isSelected());\n+\n+        if (dlg.getScrapImpossibleBox() != null) {\n+            setScrapImpossible(dlg.getScrapImpossibleBox().isSelected());\n+        }\n+\n+        if (dlg.getUseAssignedTechsFirstBox() != null) {\n+            setUseAssignedTechsFirst(dlg.getUseAssignedTechsFirstBox().isSelected());\n+        }\n+\n+        if (dlg.getReplacePodPartsBox() != null) {\n+            setReplacePodParts(dlg.getReplacePodPartsBox().isSelected());\n+        }\n+\n+        setMassRepairOptions(new ArrayList<>());\n+        for (int i = 0; i < MassRepairOption.VALID_REPAIR_TYPES.length; i++) {\n+            int type = MassRepairOption.VALID_REPAIR_TYPES[i];\n+\n+            MassRepairSalvageDialog.MassRepairOptionControl mroc = dlg.getMassRepairOptionControlMap().get(type);\n+\n+            if (mroc == null) {\n+                continue;\n+            }\n+\n+            MassRepairOption mro = new MassRepairOption(type, mroc.getActiveBox().isSelected(),\n+                    mroc.getMinSkillCBox().getSelectedIndex(), mroc.getMaxSkillCBox().getSelectedIndex(),\n+                    (Integer) mroc.getMinBTHSpn().getValue(), (Integer) mroc.getMaxBTHSpn().getValue());\n+\n+            if (mro.isActive()) {\n+                setHasActiveMassRepairOption(true);\n+            }\n+\n+            getMassRepairOptions().add(mro);\n+        }\n+    }\n+    //endregion Initialization\n+\n+    //region Getters/Setters\n+    public boolean isUseExtraTime() {\n+        return useExtraTime;\n+    }\n+\n+    public void setUseExtraTime(boolean useExtraTime) {\n+        this.useExtraTime = useExtraTime;\n+    }\n+\n+    public boolean isUseRushJob() {\n+        return useRushJob;\n+    }\n+\n+    public void setUseRushJob(boolean useRushJob) {\n+        this.useRushJob = useRushJob;\n+    }\n+\n+    public boolean isAllowCarryover() {\n+        return allowCarryover;\n+    }\n+\n+    public void setAllowCarryover(boolean allowCarryover) {\n+        this.allowCarryover = allowCarryover;\n+    }\n+\n+    public boolean isOptimizeToCompleteToday() {\n+        return optimizeToCompleteToday;\n+    }\n+\n+    public void setOptimizeToCompleteToday(boolean optimizeToCompleteToday) {\n+        this.optimizeToCompleteToday = optimizeToCompleteToday;\n+    }\n+\n+    public boolean isUseAssignedTechsFirst() {\n+        return useAssignedTechsFirst;\n+    }\n+\n+    public void setUseAssignedTechsFirst(boolean useAssignedTechsFirst) {\n+        this.useAssignedTechsFirst = useAssignedTechsFirst;\n+    }\n+\n+    public boolean isScrapImpossible() {\n+        return scrapImpossible;\n+    }\n+\n+    public void setScrapImpossible(boolean scrapImpossible) {\n+        this.scrapImpossible = scrapImpossible;\n+    }\n+\n+    public boolean isReplacePodParts() {\n+        return replacePodParts;\n+    }\n+\n+    public void setReplacePodParts(boolean replacePodParts) {\n+        this.replacePodParts = replacePodParts;\n+    }\n+\n+    public List<MassRepairOption> getMassRepairOptions() {\n+        return massRepairOptions;\n+    }\n+\n+    public void setMassRepairOptions(List<MassRepairOption> massRepairOptions) {\n+        this.massRepairOptions = massRepairOptions;\n+    }\n+\n+    public boolean hasActiveMassRepairOption() {\n+        return hasActiveMassRepairOption;\n+    }\n+\n+    public void setHasActiveMassRepairOption(boolean hasActiveMassRepairOption) {\n+        this.hasActiveMassRepairOption = hasActiveMassRepairOption;\n+    }\n+    //endregion Getters/Setters\n+\n+    public List<MassRepairOption> getActiveMassRepairOptions() {\n+        if (!hasActiveMassRepairOption()) {\n+            return new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae5fb7e9fcec99a93a19afdab481d116899c125f"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE2OTEwMA==", "bodyText": "Should this instead be debug?", "url": "https://github.com/MegaMek/mekhq/pull/2077#discussion_r499169100", "createdAt": "2020-10-03T18:05:48Z", "author": {"login": "sixlettervariables"}, "path": "MekHQ/src/mekhq/service/MassRepairOption.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2020 - The MegaMek Team. All Rights Reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+package mekhq.service;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.parts.Part;\n+import mekhq.campaign.personnel.SkillType;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class MassRepairOption {\n+    //region Variable Declarations\n+    private int type;\n+    private boolean active;\n+    private int skillMin;\n+    private int skillMax;\n+    private int bthMin;\n+    private int bthMax;\n+\n+    public static final int[] VALID_REPAIR_TYPES = new int[] { Part.REPAIR_PART_TYPE.ARMOR, Part.REPAIR_PART_TYPE.AMMO,\n+            Part.REPAIR_PART_TYPE.WEAPON, Part.REPAIR_PART_TYPE.GENERAL_LOCATION, Part.REPAIR_PART_TYPE.ENGINE,\n+            Part.REPAIR_PART_TYPE.GYRO, Part.REPAIR_PART_TYPE.ACTUATOR, Part.REPAIR_PART_TYPE.ELECTRONICS,\n+            Part.REPAIR_PART_TYPE.POD_SPACE, Part.REPAIR_PART_TYPE.GENERAL };\n+    //endregion Variable Declarations\n+\n+    //region Constructors\n+    public MassRepairOption(int type) {\n+        this (type, false, SkillType.EXP_ULTRA_GREEN, SkillType.EXP_ELITE, 4, 4);\n+    }\n+\n+    public MassRepairOption(int type, boolean active, int skillMin, int skillMax, int bthMin, int bthMax) {\n+        this.type = type;\n+        this.active = active;\n+        this.skillMin = skillMin;\n+        this.skillMax = skillMax;\n+        this.bthMin = bthMin;\n+        this.bthMax = bthMax;\n+    }\n+    //endregion Constructors\n+\n+    //region Getters/Setters\n+    public int getType() {\n+        return type;\n+    }\n+\n+    public void setType(int type) {\n+        this.type = type;\n+    }\n+\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    public void setActive(boolean active) {\n+        this.active = active;\n+    }\n+\n+    public int getSkillMin() {\n+        return skillMin;\n+    }\n+\n+    public void setSkillMin(int skillMin) {\n+        this.skillMin = skillMin;\n+    }\n+\n+    public int getSkillMax() {\n+        return skillMax;\n+    }\n+\n+    public void setSkillMax(int skillMax) {\n+        this.skillMax = skillMax;\n+    }\n+\n+    public int getBthMin() {\n+        return bthMin;\n+    }\n+\n+    public void setBthMin(int bthMin) {\n+        this.bthMin = bthMin;\n+    }\n+\n+    public int getBthMax() {\n+        return bthMax;\n+    }\n+\n+    public void setBthMax(int bthMax) {\n+        this.bthMax = bthMax;\n+    }\n+    //endregion Getters/Setters\n+\n+    //region File IO\n+    public void writeToXML(PrintWriter pw1, int indent) {\n+        MekHqXmlUtil.writeSimpleXMLOpenIndentedLine(pw1, indent++, \"massRepairOption\");\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"type\", getType());\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"active\", isActive() ? 1 : 0);\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"skillMin\", getSkillMin());\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"skillMax\", getSkillMax());\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"btnMin\", getBthMin());\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"btnMax\", getBthMax());\n+        MekHqXmlUtil.writeSimpleXMLCloseIndentedLine(pw1, --indent, \"massRepairOption\");\n+    }\n+\n+    public static List<MassRepairOption> parseListFromXML(Node wn2) {\n+        List<MassRepairOption> massRepairOptions = new ArrayList<>();\n+        NodeList mroList = wn2.getChildNodes();\n+\n+        for (int mroIdx = 0; mroIdx < mroList.getLength(); mroIdx++) {\n+            Node mroNode = mroList.item(mroIdx);\n+\n+            if (mroNode.getNodeType() != Node.ELEMENT_NODE) {\n+                continue;\n+            }\n+\n+            try {\n+                MassRepairOption mro = parseFromXML(mroNode);\n+                if ((mro.getType() == -1) || (mro.getType() >= VALID_REPAIR_TYPES.length)) {\n+                    MekHQ.getLogger().error(\"Attempted to load MassRepairOption with illegal type id of \" + mro.getType());\n+                } else {\n+                    massRepairOptions.add(mro);\n+                }\n+            } catch (Exception e) {\n+                MekHQ.getLogger().error(\"Failed to parse MassRepairOption from XML\", e);\n+            }\n+        }\n+\n+        return massRepairOptions;\n+    }\n+\n+    public static MassRepairOption parseFromXML(Node mroNode) {\n+        MassRepairOption mro = new MassRepairOption(-1);\n+\n+        NodeList mroItemList = mroNode.getChildNodes();\n+        for (int mroItemIdx = 0; mroItemIdx < mroItemList.getLength(); mroItemIdx++) {\n+            Node mroItemNode = mroItemList.item(mroItemIdx);\n+\n+            if (mroItemNode.getNodeType() != Node.ELEMENT_NODE) {\n+                continue;\n+            }\n+\n+            if (mroItemNode.getNodeName().equalsIgnoreCase(\"type\")) {\n+                mro.setType(Integer.parseInt(mroItemNode.getTextContent().trim()));\n+            } else if (mroItemNode.getNodeName().equalsIgnoreCase(\"active\")) {\n+                mro.setActive(Integer.parseInt(mroItemNode.getTextContent().trim()) == 1);\n+            } else if (mroItemNode.getNodeName().equalsIgnoreCase(\"skillMin\")) {\n+                mro.setSkillMin(Integer.parseInt(mroItemNode.getTextContent().trim()));\n+            } else if (mroItemNode.getNodeName().equalsIgnoreCase(\"skillMax\")) {\n+                mro.setSkillMax(Integer.parseInt(mroItemNode.getTextContent().trim()));\n+            } else if (mroItemNode.getNodeName().equalsIgnoreCase(\"btnMin\")) {\n+                mro.setBthMin(Integer.parseInt(mroItemNode.getTextContent().trim()));\n+            } else if (mroItemNode.getNodeName().equalsIgnoreCase(\"btnMax\")) {\n+                mro.setBthMax(Integer.parseInt(mroItemNode.getTextContent().trim()));\n+            }\n+\n+            MekHQ.getLogger().info(String.format(\"massRepairOption %d.%s\\n\\t%s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae5fb7e9fcec99a93a19afdab481d116899c125f"}, "originalPosition": 175}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cbfe0385408ef27d3cd9f908a192f46fee7541b", "author": {"user": {"login": "Windchild292", "name": "Justin Bowen"}}, "url": "https://github.com/MegaMek/mekhq/commit/4cbfe0385408ef27d3cd9f908a192f46fee7541b", "committedDate": "2020-10-03T18:21:18Z", "message": "Applying changes from review"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4239, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}