{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzNDQwNTM4", "number": 368, "title": "DisableIfArgument", "bodyText": "Closes #313\n\nPR checklist\nThe following checklist shall help the PR's author, the reviewers and maintainers to ensure the quality of this project.\nIt is based on our contributors guidelines, especially the \"writing code\" section.\nIt shall help to check for completion of the listed points.\nIf a point does not apply to the given PR's changes, the corresponding entry can be simply marked as done.\nDocumentation (general)\n\n There is documentation (Javadoc and site documentation; added or updated)\n There is implementation information to describe why a non-obvious source code / solution got implemented\n Site documentation has its own .adoc file in the docs folder, e.g. docs/report-entries.adoc\n Only one sentence per line (especially in .adoc files)\n Javadoc uses formal style, while sites documentation may use informal style (see #265)\n\nDocumentation (new extension)\n\n The docs/docs-nav.yml navigation has an entry for the new extension\n The package-info.java contains information about the new extension\n\nCode\n\n Code adheres to code style, naming conventions etc.\n Successful tests cover all changes\n There are checks which validate correct / false usage / configuration of a functionality and there are tests to verify those checks (see #164)\n Tests use AssertJ or our own PioneerAssert (which are based on AssertJ)\n\nContributing\n\n A prepared commit message exists\n The list of contributions inside README.md mentions the new contribution (real name optional)\n\n\nI hereby agree to the terms of the JUnit Pioneer Contributor License Agreement.", "createdAt": "2020-10-31T14:14:13Z", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368", "merged": true, "mergeCommit": {"oid": "b49ff0a82081530681aba7c7a3071d65f14d0ad2"}, "closed": true, "closedAt": "2021-05-29T12:48:46Z", "author": {"login": "Michael1993"}, "timelineItems": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMlDpkAH2gAyNTEzNDQwNTM4OmQ5OWU3NGIwYWQ1OWIwZjg3NzcyNjQ1ZTFiOTEzODU1YjQxYjc0MTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABebf11SAH2gAyNTEzNDQwNTM4OjI3YmQ0ZmJlZjRjYzM0NDc5YWYxYjY5ZTY5ODBlYTg2MGVlM2MzODc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d99e74b0ad59b0f87772645e1b913855b41b7413", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/d99e74b0ad59b0f87772645e1b913855b41b7413", "committedDate": "2020-09-26T07:14:48Z", "message": "Created PoC extension for disabling parameterized tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62bf604755b6462546e631b2009391eabcd344ca", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/62bf604755b6462546e631b2009391eabcd344ca", "committedDate": "2020-10-31T13:38:41Z", "message": "Merge branch 'master' into issue313/explore-invocation-interceptor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d223cfd1596489d15221c2e71e75590e361cbfb6", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/d223cfd1596489d15221c2e71e75590e361cbfb6", "committedDate": "2020-10-31T14:09:24Z", "message": "Replaced value() with contains() and matches()\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9574ea83dce2b4c14a0913e17b146b9b4366ec11", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/9574ea83dce2b4c14a0913e17b146b9b4366ec11", "committedDate": "2020-10-31T14:09:57Z", "message": "Disable based on containing and RegEx\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0168cc15df4ba7d5fc3b7ddc9e1ce7fd83a84b42", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0168cc15df4ba7d5fc3b7ddc9e1ce7fd83a84b42", "committedDate": "2020-10-31T14:10:08Z", "message": "Updated tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4e357622f56e41347b140e3b60c3534f4d65f08", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c4e357622f56e41347b140e3b60c3534f4d65f08", "committedDate": "2020-10-31T14:10:32Z", "message": "Spotless, no :(\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9f46c8d6d6290c2bbc72f07e5e87e90a6a92a78", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/f9f46c8d6d6290c2bbc72f07e5e87e90a6a92a78", "committedDate": "2020-11-02T17:18:03Z", "message": "Add documentation based on DisableIfDisplayName\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81fddd97f9565848f2bc59aafc8ffb116c66d5a4", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/81fddd97f9565848f2bc59aafc8ffb116c66d5a4", "committedDate": "2020-11-02T17:18:28Z", "message": "README.md updated to include contribution\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98663ed3122bc85a65555e745c89c374f5e2f9c2", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/98663ed3122bc85a65555e745c89c374f5e2f9c2", "committedDate": "2020-11-02T17:19:37Z", "message": "Simplify orElseThrow\n(no, not because this will make Sonar consider it 100% covered, why would you think that?)\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cfc8c11f960cc91bc8a6e0cace0bdda64cf404b", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/2cfc8c11f960cc91bc8a6e0cace0bdda64cf404b", "committedDate": "2020-11-02T17:20:02Z", "message": "Update tests to include a poem (Oscar Wilde: Requiescat)\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b85e3e0be0cb5bf66d562916c155cea3d847d995", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b85e3e0be0cb5bf66d562916c155cea3d847d995", "committedDate": "2020-11-02T17:24:14Z", "message": "Update package-info.java with the new addition\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5643ebf0da2b99ec1998471fc2a67a60c693ca6c", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/5643ebf0da2b99ec1998471fc2a67a60c693ca6c", "committedDate": "2020-11-02T17:25:48Z", "message": "Fix comma typo\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1", "committedDate": "2020-11-02T17:28:11Z", "message": "Add references to contribution\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzE3NDI1", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#pullrequestreview-522717425", "createdAt": "2020-11-03T17:19:08Z", "commit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzoxOTowOVrOHs45Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzo0NToxOVrOHs55Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzMTU5MA==", "bodyText": "Why (almost) all uppercase?\nedit: I see - we do it everywhere.... /edit", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516831590", "createdAt": "2020-11-03T17:19:09Z", "author": {"login": "Bukama"}, "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzMzc2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n          \n          \n            \n            Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation, `@DisableIfParameter` is validated before each execution of a parameterized test .\n          \n      \n    \n    \n  \n\nAside the wrong space, I think this is better to understand.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516833764", "createdAt": "2020-11-03T17:22:11Z", "author": {"login": "Bukama"}, "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNDkwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.\n          \n          \n            \n            As a consequence, instead of disabling the entire set of parameterized tests, each test is evaluated and possibly disabled individually.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516834905", "createdAt": "2020-11-03T17:24:00Z", "author": {"login": "Bukama"}, "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNzUyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The first invocation because the first parameter contains \"bright\".\n          \n          \n            \n            The second invocation because the second parameter contains \"dust\".\n          \n          \n            \n            The first invocation got disabled, because the first parameter contains \"bright\".\n          \n          \n            \n            The second execution got skipped, because the other parameter contains \"dust\".", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516837524", "createdAt": "2020-11-03T17:28:06Z", "author": {"login": "Bukama"}, "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose parameter contains \"she\"\n+@DisableIfParameter(contains = \"she\")\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Tread lightly, she is near\",\n+        \"Under the snow,\",\n+        \"Speak gently, she can hear\",\n+        \"The daisies grow.\"\n+})\n+void interceptContains(String line) {\n+}\n+----\n+\n+The test `interceptContains` ordinarily would run four times, but because the first and third lines contain the word \"she\", those invocations get disabled.\n+\n+You can specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfParameter(contains = { \"bright\", \"dust\" })\n+@ParameterizedTest\n+@CsvSource(delimiter = ';', value = {\n+        \"All her bright golden hair;Tarnished with rust,\",\n+        \"She that was young and fair;Fallen to dust.\"\n+})\n+void interceptContainsAny(String line, String line2) {\n+}\n+----\n+\n+`DisableIfParameter` will disable the test invocation if any parameter value matches any value from `contains`.\n+In this case, the test `interceptContainsAny` should have run two times, but both invocations got disabled.\n+The first invocation because the first parameter contains \"bright\".\n+The second invocation because the second parameter contains \"dust\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNzk2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If substrings are not powerful enough, you can also use regular expressions:\n          \n          \n            \n            If substrings are not powerful enough, you can also use regular expressions, using the `matches` value:", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516837966", "createdAt": "2020-11-03T17:28:51Z", "author": {"login": "Bukama"}, "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose parameter contains \"she\"\n+@DisableIfParameter(contains = \"she\")\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Tread lightly, she is near\",\n+        \"Under the snow,\",\n+        \"Speak gently, she can hear\",\n+        \"The daisies grow.\"\n+})\n+void interceptContains(String line) {\n+}\n+----\n+\n+The test `interceptContains` ordinarily would run four times, but because the first and third lines contain the word \"she\", those invocations get disabled.\n+\n+You can specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfParameter(contains = { \"bright\", \"dust\" })\n+@ParameterizedTest\n+@CsvSource(delimiter = ';', value = {\n+        \"All her bright golden hair;Tarnished with rust,\",\n+        \"She that was young and fair;Fallen to dust.\"\n+})\n+void interceptContainsAny(String line, String line2) {\n+}\n+----\n+\n+`DisableIfParameter` will disable the test invocation if any parameter value matches any value from `contains`.\n+In this case, the test `interceptContainsAny` should have run two times, but both invocations got disabled.\n+The first invocation because the first parameter contains \"bright\".\n+The second invocation because the second parameter contains \"dust\".\n+\n+If substrings are not powerful enough, you can also use regular expressions:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzOTEzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can use both, in which case a test is disabled if any parameter value contains a substring _or_ matches an expression:\n          \n          \n            \n            You can also combine both options.\n          \n          \n            \n            When doing so, test is disabled if any parameter value contains a substring _or_ matches an expression:", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516839130", "createdAt": "2020-11-03T17:30:44Z", "author": {"login": "Bukama"}, "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose parameter contains \"she\"\n+@DisableIfParameter(contains = \"she\")\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Tread lightly, she is near\",\n+        \"Under the snow,\",\n+        \"Speak gently, she can hear\",\n+        \"The daisies grow.\"\n+})\n+void interceptContains(String line) {\n+}\n+----\n+\n+The test `interceptContains` ordinarily would run four times, but because the first and third lines contain the word \"she\", those invocations get disabled.\n+\n+You can specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfParameter(contains = { \"bright\", \"dust\" })\n+@ParameterizedTest\n+@CsvSource(delimiter = ';', value = {\n+        \"All her bright golden hair;Tarnished with rust,\",\n+        \"She that was young and fair;Fallen to dust.\"\n+})\n+void interceptContainsAny(String line, String line2) {\n+}\n+----\n+\n+`DisableIfParameter` will disable the test invocation if any parameter value matches any value from `contains`.\n+In this case, the test `interceptContainsAny` should have run two times, but both invocations got disabled.\n+The first invocation because the first parameter contains \"bright\".\n+The second invocation because the second parameter contains \"dust\".\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose parameter ends with 'knew' or 'grew'\n+@DisableIfParameter(matches = { \".*knew\", \".*grew\" })\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Lily-like, white as snow,\",\n+        \"She hardly knew\",\n+        \"She was a woman, so\",\n+        \"Sweetly she grew\"\n+})\n+void interceptMatches(String value) {\n+}\n+----\n+\n+The second invocation has a parameter that ends with \"knew\", so it gets disabled.\n+The fourth invocation has a parameter that ends with \"grew\", so it gets disabled.\n+\n+Just like with `contains`, if any parameter value matches any expression from `matches`, the invocation gets disabled.\n+\n+You can use both, in which case a test is disabled if any parameter value contains a substring _or_ matches an expression:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzOTg3NQ==", "bodyText": "To align this tests with the others, and because the regex is not so easy to read like the ones above I would suggest to also add an explanation, which tests are executed and which are not.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516839875", "createdAt": "2020-11-03T17:31:59Z", "author": {"login": "Bukama"}, "path": "docs/disable-if-parameter.adoc", "diffHunk": "@@ -0,0 +1,83 @@\n+:page-title: Disable Parameterized Test Based on Parameter Values\n+:page-description: Extends JUnit Jupiter with `@DisableIfParameter`, which selectively disables parameterized tests\n+\n+The `@DisableIfParameter` annotation can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfParameter` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose parameter contains \"she\"\n+@DisableIfParameter(contains = \"she\")\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Tread lightly, she is near\",\n+        \"Under the snow,\",\n+        \"Speak gently, she can hear\",\n+        \"The daisies grow.\"\n+})\n+void interceptContains(String line) {\n+}\n+----\n+\n+The test `interceptContains` ordinarily would run four times, but because the first and third lines contain the word \"she\", those invocations get disabled.\n+\n+You can specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfParameter(contains = { \"bright\", \"dust\" })\n+@ParameterizedTest\n+@CsvSource(delimiter = ';', value = {\n+        \"All her bright golden hair;Tarnished with rust,\",\n+        \"She that was young and fair;Fallen to dust.\"\n+})\n+void interceptContainsAny(String line, String line2) {\n+}\n+----\n+\n+`DisableIfParameter` will disable the test invocation if any parameter value matches any value from `contains`.\n+In this case, the test `interceptContainsAny` should have run two times, but both invocations got disabled.\n+The first invocation because the first parameter contains \"bright\".\n+The second invocation because the second parameter contains \"dust\".\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose parameter ends with 'knew' or 'grew'\n+@DisableIfParameter(matches = { \".*knew\", \".*grew\" })\n+@ParameterizedTest\n+@ValueSource(strings = {\n+        \"Lily-like, white as snow,\",\n+        \"She hardly knew\",\n+        \"She was a woman, so\",\n+        \"Sweetly she grew\"\n+})\n+void interceptMatches(String value) {\n+}\n+----\n+\n+The second invocation has a parameter that ends with \"knew\", so it gets disabled.\n+The fourth invocation has a parameter that ends with \"grew\", so it gets disabled.\n+\n+Just like with `contains`, if any parameter value matches any expression from `matches`, the invocation gets disabled.\n+\n+You can use both, in which case a test is disabled if any parameter value contains a substring _or_ matches an expression:\n+\n+[source,java]\n+----\n+@ParameterizedTest\n+@DisableIfParameter(\n+        contains = { \"sonnet\", \"life\" },\n+        matches = \"^.*(.+)\\\\1.*$\")\n+@ValueSource(strings = {\n+        \"Peace, Peace, she cannot hear\",\n+        \"Lyre or sonnet,\",\n+        \"All my life\u2019s buried here,\",\n+        \"Heap earth upon it.\"\n+})\n+void interceptBoth(String value) {\n+}\n+----", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MzE1MQ==", "bodyText": "To me the messages is misleading. If the annotation is present, e.g. with contains, then for me it is specified, but as an empty set. I would rephrase to something like \"specified with at least one element, but both are empty\"", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516843151", "createdAt": "2020-11-03T17:37:32Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/params/DisableIfParameterExtension.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import static java.lang.String.format;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+import org.opentest4j.TestAbortedException;\n+\n+class DisableIfParameterExtension implements InvocationInterceptor {\n+\n+\t@Override\n+\tpublic void interceptTestTemplateMethod(Invocation<Void> invocation,\n+\t\t\tReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {\n+\t\tMethod testMethod = extensionContext.getRequiredTestMethod();\n+\t\tDisableIfParameter annotation = AnnotationSupport\n+\t\t\t\t.findAnnotation(testMethod, DisableIfParameter.class)\n+\t\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"@DisableIfParameter is missing\"));\n+\t\tif (annotation.contains().length == 0 && annotation.matches().length == 0)\n+\t\t\tthrow new ExtensionConfigurationException(\n+\t\t\t\tformat(\"%s requires that either `contains` or `matches` is specified, but both are empty.\",\n+\t\t\t\t\tDisableIfParameter.class.getSimpleName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NDEzNA==", "bodyText": "To other reviewers: I asked @Michael1993 to add those comments, while we was working on the extension on stream, because the two checks look realy the same, but differ in one word in the middle of them, which I didn't mention at the beginning. With the comments I think its more readable.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516844134", "createdAt": "2020-11-03T17:39:08Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/params/DisableIfParameterExtension.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import static java.lang.String.format;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+import org.opentest4j.TestAbortedException;\n+\n+class DisableIfParameterExtension implements InvocationInterceptor {\n+\n+\t@Override\n+\tpublic void interceptTestTemplateMethod(Invocation<Void> invocation,\n+\t\t\tReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {\n+\t\tMethod testMethod = extensionContext.getRequiredTestMethod();\n+\t\tDisableIfParameter annotation = AnnotationSupport\n+\t\t\t\t.findAnnotation(testMethod, DisableIfParameter.class)\n+\t\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"@DisableIfParameter is missing\"));\n+\t\tif (annotation.contains().length == 0 && annotation.matches().length == 0)\n+\t\t\tthrow new ExtensionConfigurationException(\n+\t\t\t\tformat(\"%s requires that either `contains` or `matches` is specified, but both are empty.\",\n+\t\t\t\t\tDisableIfParameter.class.getSimpleName()));\n+\t\t// Check if any argument contains any element from 'contains'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0NzkwNw==", "bodyText": "I'm confused why\n\nyou don't check for the particular exceptions you throw\nWhy sonar claims full coverage (speaking of the part with the three different exceptions)\n\n\ud83e\udd37\u200d\u2642\ufe0f", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r516847907", "createdAt": "2020-11-03T17:45:19Z", "author": {"login": "Bukama"}, "path": "src/test/java/org/junitpioneer/jupiter/params/DisableIfParameterExtensionTests.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+/**\n+ * Oscar Wilde: Requiescat is in the public domain\n+ */\n+@DisplayName(\"DisableIfParameterExtension\")\n+class DisableIfParameterExtensionTests {\n+\n+\t@Nested\n+\t@DisplayName(\"when configured correctly\")\n+\tclass CorrectConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"disables tests when parameter contains any value from the 'contains' array\")\n+\t\tvoid interceptContains() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(CorrectConfigTestCases.class, \"interceptContains\",\n+\t\t\t\t\t\tString.class);\n+\n+\t\t\tassertThat(results).hasNumberOfSucceededTests(2).hasNumberOfAbortedTests(2);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"disables tests when any parameter contains any value from the 'contains' array\")\n+\t\tvoid interceptContainsAny() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(CorrectConfigTestCases.class, \"interceptContainsAny\",\n+\t\t\t\t\t\tString.class, String.class);\n+\n+\t\t\tassertThat(results).hasNumberOfAbortedTests(2);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"disables tests when parameter matches any regex from the 'matches' array\")\n+\t\tvoid interceptMatches() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(CorrectConfigTestCases.class, \"interceptMatches\",\n+\t\t\t\t\t\tString.class);\n+\n+\t\t\tassertThat(results).hasNumberOfSucceededTests(2).hasNumberOfAbortedTests(2);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"disables tests when any parameter matches any regex from the 'matches' array\")\n+\t\tvoid interceptMatchesAny() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(CorrectConfigTestCases.class, \"interceptMatchesAny\",\n+\t\t\t\t\t\tString.class, String.class);\n+\n+\t\t\tassertThat(results).hasNumberOfAbortedTests(2);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"disables tests if parameter matches regex from 'matches' or contains value from 'contains'\")\n+\t\tvoid interceptMatchesAndContains() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(CorrectConfigTestCases.class, \"interceptBoth\", String.class);\n+\n+\t\t\tassertThat(results).hasNumberOfSucceededTests(1).hasNumberOfAbortedTests(3);\n+\t\t}\n+\n+\t}\n+\n+\t@Nested\n+\t@DisplayName(\"when not configured correctly\")\n+\tclass MisconfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"throws an exception if both 'matches' and 'contains' is missing\")\n+\t\tvoid missingValues() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigTestCases.class, \"missingValues\", String.class);\n+\n+\t\t\tassertThat(results).hasNumberOfFailedTests(3);\n+\t\t}\n+\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NjQ0Njkx", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#pullrequestreview-525644691", "createdAt": "2020-11-07T10:48:40Z", "commit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QxMDo0ODo0MFrOHvHQ6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QxMToxMTo0OVrOHvHYyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE2NDEzNw==", "bodyText": "Two suggestions:\n\n\nSince we are dealing with parameterized tests and also the annotation uses the term \"parameter\", we might want to adopt this instead of \"argument\" (even if the invocation context says getArguments()).\n\n\nMore a matter of taste, but you could split things up into several methods.\n\n\nExample:\n@Override\npublic void interceptTestTemplateMethod(Invocation<Void> invocation,\n\t\tReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {\n\tMethod testMethod = extensionContext.getRequiredTestMethod();\n\tDisableIfParameter annotation = AnnotationSupport\n\t\t\t.findAnnotation(testMethod, DisableIfParameter.class)\n\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"@DisableIfParameter is missing\"));\n\tif (annotation.contains().length == 0 && annotation.matches().length == 0)\n\t\tthrow new ExtensionConfigurationException(\n\t\t\tformat(\"%s requires that either `contains` or `matches` is specified, but both are empty.\",\n\t\t\t\tDisableIfParameter.class.getSimpleName()));\n\ttestContains(invocationContext, annotation);\n\ttestMatches(invocationContext, annotation);\n\tinvocation.proceed();\n}\n\nprivate void testMatches(ReflectiveInvocationContext<Method> invocationContext, DisableIfParameter annotation) {\n\tPredicate<Object> matchesParam = param -> Arrays\n\t\t\t.stream(annotation.matches())\n\t\t\t.anyMatch(param.toString()::matches);\n\tString matchesMessage = \"One or more parameters matched a regular expression from the `matches` array.\";\n\ttestParams(invocationContext, matchesParam, matchesMessage);\n}\n\nprivate void testContains(ReflectiveInvocationContext<Method> invocationContext, DisableIfParameter annotation) {\n\tPredicate<Object> containsParam = param -> Arrays\n\t\t\t.stream(annotation.contains())\n\t\t\t.anyMatch(param.toString()::contains);\n\tString containsMessage = \"One or more parameters contained a value from the `contains` array.\";\n\ttestParams(invocationContext, containsParam, containsMessage);\n}\n\nprivate void testParams(ReflectiveInvocationContext<Method> invocationContext, Predicate<Object> predicate,\n\t\tString message) {\n\tif (invocationContext.getArguments().stream().anyMatch(predicate))\n\t\tthrow new TestAbortedException(message);\n}", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r519164137", "createdAt": "2020-11-07T10:48:40Z", "author": {"login": "beatngu13"}, "path": "src/main/java/org/junitpioneer/jupiter/params/DisableIfParameterExtension.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import static java.lang.String.format;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+import org.opentest4j.TestAbortedException;\n+\n+class DisableIfParameterExtension implements InvocationInterceptor {\n+\n+\t@Override\n+\tpublic void interceptTestTemplateMethod(Invocation<Void> invocation,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE2NTQ0NQ==", "bodyText": "Kudos for using <em> instead of <i>! \ud83d\udc4d", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r519165445", "createdAt": "2020-11-07T11:03:40Z", "author": {"login": "beatngu13"}, "path": "src/main/java/org/junitpioneer/jupiter/params/DisableIfParameter.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @DisableIfParameter} is a JUnit Jupiter extension that can\n+ * be used to selectively disable a {@link org.junit.jupiter.params.ParameterizedTest}\n+ * based on their parameter values as defined by {@link Object#toString()}.\n+ *\n+ * <p>The extension utilizes Jupiter's {@link org.junit.jupiter.api.extension.InvocationInterceptor}.\n+ * It's important to note that since it's marked as {@link org.apiguardian.api.API.Status#EXPERIMENTAL}\n+ * it might be removed without prior notice.\n+ * Unlike {@link org.junit.jupiter.api.Disabled} annotations, this extension doesn't disable the whole test method.\n+ * With {@code DisableIfParameter}, it is possible to selectively disable tests out of the plethora\n+ * of dynamically registered parameterized tests.</p>\n+ *\n+ * <p>If neither {@link DisableIfParameter#contains() contains} nor\n+ * {@link DisableIfParameter#matches() matches} is configured, the extension will throw an exception.\n+ * It is possible to configure both, in which case the test gets disabled if at least one substring\n+ * was found <em>or</em> at least one regular expression matched.</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE2NTc0Nw==", "bodyText": "Does it make sense to add minimal Javadoc referring to String#contains and String#matches?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r519165747", "createdAt": "2020-11-07T11:07:01Z", "author": {"login": "beatngu13"}, "path": "src/main/java/org/junitpioneer/jupiter/params/DisableIfParameter.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter.params;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @DisableIfParameter} is a JUnit Jupiter extension that can\n+ * be used to selectively disable a {@link org.junit.jupiter.params.ParameterizedTest}\n+ * based on their parameter values as defined by {@link Object#toString()}.\n+ *\n+ * <p>The extension utilizes Jupiter's {@link org.junit.jupiter.api.extension.InvocationInterceptor}.\n+ * It's important to note that since it's marked as {@link org.apiguardian.api.API.Status#EXPERIMENTAL}\n+ * it might be removed without prior notice.\n+ * Unlike {@link org.junit.jupiter.api.Disabled} annotations, this extension doesn't disable the whole test method.\n+ * With {@code DisableIfParameter}, it is possible to selectively disable tests out of the plethora\n+ * of dynamically registered parameterized tests.</p>\n+ *\n+ * <p>If neither {@link DisableIfParameter#contains() contains} nor\n+ * {@link DisableIfParameter#matches() matches} is configured, the extension will throw an exception.\n+ * It is possible to configure both, in which case the test gets disabled if at least one substring\n+ * was found <em>or</em> at least one regular expression matched.</p>\n+ *\n+ * @see DisableIfParameterExtension\n+ */\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.RUNTIME)\n+@ExtendWith(DisableIfParameterExtension.class)\n+public @interface DisableIfParameter {\n+\n+\tString[] contains() default {};\n+\n+\tString[] matches() default {};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE2NjE1NA==", "bodyText": "I like that you refer to parameterized tests, maybe adapt the title here as well (i.e. \"Disable Parameterized Test Based on Display Name\").", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r519166154", "createdAt": "2020-11-07T11:11:49Z", "author": {"login": "beatngu13"}, "path": "docs/docs-nav.yml", "diffHunk": "@@ -12,6 +12,8 @@\n         url: /docs/default-locale-timezone/\n       - title: \"Disable Based on DisplayName\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10e4d8a6d3909a8d2cd6223ebe0a1546c21e9be1"}, "originalPosition": 2}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbe9dd0fb827e72d3852c2ceabbcc202f3f2d295", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/bbe9dd0fb827e72d3852c2ceabbcc202f3f2d295", "committedDate": "2020-11-10T18:54:39Z", "message": "Update code and documentation according to feedback\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26fdcb591aea3299723ccd2e6af508f6eb489c25", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/26fdcb591aea3299723ccd2e6af508f6eb489c25", "committedDate": "2020-11-24T21:22:26Z", "message": "In progress DisableIfParameter\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MTYzMDM4", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#pullrequestreview-545163038", "createdAt": "2020-12-04T17:37:16Z", "commit": {"oid": "bbe9dd0fb827e72d3852c2ceabbcc202f3f2d295"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff66f8592cca97e484900ffee71b8323b3e5be3e", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/ff66f8592cca97e484900ffee71b8323b3e5be3e", "committedDate": "2020-12-22T18:42:43Z", "message": "No parameters can not be disabled.\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b8d27b496dbd165a19f300e2e53c01fbe7b114c", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/4b8d27b496dbd165a19f300e2e53c01fbe7b114c", "committedDate": "2021-03-23T15:33:55Z", "message": "Update DisableIfParameter based on feedback\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3459d95011d0b0bb8e5d1a459096d79a333fead", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c3459d95011d0b0bb8e5d1a459096d79a333fead", "committedDate": "2021-03-23T15:40:20Z", "message": "Merge remote-tracking branch 'origin/main' into issue313/explore-invocation-interceptor\n\n# Conflicts:\n#\tREADME.md\n#\tdocs/docs-nav.yml\n#\tsrc/main/java/org/junitpioneer/jupiter/params/DisableIfNameExtension.java\n#\tsrc/test/java/org/junitpioneer/jupiter/params/DisabledIfNameExtensionTests.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5bd7ca05d5163e2dfadb1fb2e46de2ebc5c499f", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/a5bd7ca05d5163e2dfadb1fb2e46de2ebc5c499f", "committedDate": "2021-03-23T16:03:32Z", "message": "Update tests and formatting\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0e08e328c118396f5647b2be435ba26c6d150df", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b0e08e328c118396f5647b2be435ba26c6d150df", "committedDate": "2021-03-23T16:22:49Z", "message": "Update tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bb3765f7b96897e88fcf564ba5692187c39622e", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/8bb3765f7b96897e88fcf564ba5692187c39622e", "committedDate": "2021-03-23T17:16:25Z", "message": "Invalid input returns exception\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6903f5b84c35b650aabc6e003249ae402c62f003", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6903f5b84c35b650aabc6e003249ae402c62f003", "committedDate": "2021-03-23T17:28:08Z", "message": "Invalid input returns exception, try #2\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b6886d0b08891c97f83bd452fa5fb5b0c94ba009", "committedDate": "2021-03-23T17:45:15Z", "message": "Add another test\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NzgyMDM1", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#pullrequestreview-619782035", "createdAt": "2021-03-24T14:23:13Z", "commit": {"oid": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNDoyMzoxM1rOI8tHiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNDozMjoxM1rOI8trYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUyNDY4MA==", "bodyText": "I call this OK, cause the PR is from 2020 :D", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r600524680", "createdAt": "2021-03-24T14:23:13Z", "author": {"login": "Bukama"}, "path": "README.md", "diffHunk": "@@ -125,7 +125,7 @@ The least we can do is to thank them and list some of their accomplishments here\n * [Ignat Simonenko](https://github.com/simonenkoi) fixed a noteworthy bug in the default locale extension (#146 / #161)\n * [Mark R\u00f6sler](https://github.com/Hancho2009) contributed the [environment variable extension](https://junit-pioneer.org/docs/environment-variables/) (#167 / #174 and #241 / #242)\n * [Matthias B\u00fcnger](https://github.com/Bukama) opened, vetted, and groomed countless issues and PRs and contributed multiple refactorings (e.g. #165 / #168) and fixes (e.g. #190 / #200) before getting promoted to maintainer\n-* [Mih\u00e1ly Verh\u00e1s](https://github.com/Michael1993) contributed [the StdIO extension](https://junit-pioneer.org/docs/standard-input-output/) (#34 / #227), [the ReportEntryExtension](https://junit-pioneer.org/docs/report-entries/) (#134, #179 / #183, #216, #294), [the CartesianProductTestExtension](https://junit-pioneer.org/docs/cartesian-product/) (#321, #362 / #68, #354), added tests to other extensions (#164 / #272), the Pioneer assertions and contributed to multiple issues (e.g. #217 / #298) and PRs (e.g. #253, #307)\n+* [Mih\u00e1ly Verh\u00e1s](https://github.com/Michael1993) contributed [the StdIO extension](https://junit-pioneer.org/docs/standard-input-output/) (#34 / #227), [the ReportEntryExtension](https://junit-pioneer.org/docs/report-entries/) (#134, #179 / #183, #216, #294), [the CartesianProductTestExtension](https://junit-pioneer.org/docs/cartesian-product/) (#321, #362 / #68, #354), [the DisableIfParameterExtension](https://junit-pioneer.org/docs/disable-parameterized-tests/) (#313, #368) added tests to other extensions (#164 / #272), the Pioneer assertions and contributed to multiple issues (e.g. #217 / #298) and PRs (e.g. #253, #307)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUyODk1Mw==", "bodyText": "Correct placeholder", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r600528953", "createdAt": "2021-03-24T14:27:18Z", "author": {"login": "Bukama"}, "path": "docs/disable-parameterized-tests.adoc", "diffHunk": "@@ -0,0 +1,250 @@\n+:page-title: Disable Parameterized Test\n+:page-description: Extends JUnit Jupiter with multiple extensions, which selectively disables parameterized tests\n+\n+JUnit Pioneer offers multiple extensions for selectively disabling parameterized tests.\n+These are as follows:\n+\n+- DisableIfDisplayName\n+- DisableIfParameter\n+\n+== DisableIfDisplayName\n+\n+\n+The `@DisableIfDisplayName` annotation can be used to selectively disable parameterized tests based on their display names, which are dynamically registered on runtime.\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfDisplayName` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test (name) can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose display name contains \"disable\"\n+@DisableIfDisplayName(contains = \"disable\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,3,4,5\n+\t// Not disabled: 6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void testExecutionDisabled(String reason) {\n+\tif (reason.contains(\"disable\"))\n+\t\tfail(\"Test should've been disabled \" + reason);\n+}\n+----\n+\n+You can also specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfDisplayName(contains = {\"1\", \"2\"})\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(ints = { 1, 2, 3, 4, 5 })\n+void testDisplayNameString(int num) {\n+\tif (num == 1 || num == 2)\n+\t\tfail(\"Test should've been disabled for \" + num);\n+}\n+----\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose display name\n+// contains \"disable \" or \"disabled \"\n+@DisableIfDisplayName(matches = \".*disabled?\\\\s.*\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,4,5\n+\t// Not disabled: 3,6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void single(String reason) {\n+\t// ...\n+}\n+----\n+\n+Using both `matches` and `contains` in a single annotation is no longer permitted as of {VERSION_OR_DATE_PLACHOLDER}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUzMDQ4MQ==", "bodyText": "I would add (yes add, not move) the information about case-sensetive to the general information about the disableIfParameter too, cause important.\nSo the general information and here an example for it", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r600530481", "createdAt": "2021-03-24T14:28:44Z", "author": {"login": "Bukama"}, "path": "docs/disable-parameterized-tests.adoc", "diffHunk": "@@ -0,0 +1,250 @@\n+:page-title: Disable Parameterized Test\n+:page-description: Extends JUnit Jupiter with multiple extensions, which selectively disables parameterized tests\n+\n+JUnit Pioneer offers multiple extensions for selectively disabling parameterized tests.\n+These are as follows:\n+\n+- DisableIfDisplayName\n+- DisableIfParameter\n+\n+== DisableIfDisplayName\n+\n+\n+The `@DisableIfDisplayName` annotation can be used to selectively disable parameterized tests based on their display names, which are dynamically registered on runtime.\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfDisplayName` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test (name) can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose display name contains \"disable\"\n+@DisableIfDisplayName(contains = \"disable\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,3,4,5\n+\t// Not disabled: 6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void testExecutionDisabled(String reason) {\n+\tif (reason.contains(\"disable\"))\n+\t\tfail(\"Test should've been disabled \" + reason);\n+}\n+----\n+\n+You can also specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfDisplayName(contains = {\"1\", \"2\"})\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(ints = { 1, 2, 3, 4, 5 })\n+void testDisplayNameString(int num) {\n+\tif (num == 1 || num == 2)\n+\t\tfail(\"Test should've been disabled for \" + num);\n+}\n+----\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose display name\n+// contains \"disable \" or \"disabled \"\n+@DisableIfDisplayName(matches = \".*disabled?\\\\s.*\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,4,5\n+\t// Not disabled: 3,6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void single(String reason) {\n+\t// ...\n+}\n+----\n+\n+Using both `matches` and `contains` in a single annotation is no longer permitted as of {VERSION_OR_DATE_PLACHOLDER}.\n+\n+== DisableIfParameter\n+\n+This extension can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The extension comes with three annotations, covering different use-cases:\n+\n+- `@DisableIfAnyParameter`, non-repeatable\n+- `@DisableIfAllParameters`, non-repeatable\n+- `@DisableIfParameter`, repeatable\n+\n+The annotations are only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation, the extension evaluates each execution of a parameterized test.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test is possibly disabled individually.\n+All three annotations require that you specify one of two parameters, `contains` *or* `matches`.\n+`@DisableIfAnyParameter` will disable test executions if *any* argument either contains or matches any of the given strings.\n+`@DisableIfAllParameters` will disable test executions if *all* arguments either contain or match any of the given strings.\n+`@DisableIfParameter` will disable test executions if a *specified* argument either contains or matches any of the given strings.\n+\n+=== Using `contains`\n+\n+[source,java]\n+----\n+@DisableIfAllParameters(contains = \"the\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAllContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAllContains` ordinarily would run four times, but the second execution gets disabled because both arguments contain \"the\" (the second argument as part of \"there\").\n+Using the same test with a different annotation would look like this:\n+\n+[source,java]\n+----\n+@DisableIfAnyParameter(contains = \"Then\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAnyContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAnyContains` ordinarily would run four times, but the second and third executions get disabled because an argument contains \"Then\".\n+The last execution does not get disabled, because the extension is case-sensitive.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUzMjU5MQ==", "bodyText": "I personally like to write this .. starting from 0 (zero) to show that I don't have a typo.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r600532591", "createdAt": "2021-03-24T14:30:48Z", "author": {"login": "Bukama"}, "path": "docs/disable-parameterized-tests.adoc", "diffHunk": "@@ -0,0 +1,250 @@\n+:page-title: Disable Parameterized Test\n+:page-description: Extends JUnit Jupiter with multiple extensions, which selectively disables parameterized tests\n+\n+JUnit Pioneer offers multiple extensions for selectively disabling parameterized tests.\n+These are as follows:\n+\n+- DisableIfDisplayName\n+- DisableIfParameter\n+\n+== DisableIfDisplayName\n+\n+\n+The `@DisableIfDisplayName` annotation can be used to selectively disable parameterized tests based on their display names, which are dynamically registered on runtime.\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfDisplayName` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test (name) can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose display name contains \"disable\"\n+@DisableIfDisplayName(contains = \"disable\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,3,4,5\n+\t// Not disabled: 6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void testExecutionDisabled(String reason) {\n+\tif (reason.contains(\"disable\"))\n+\t\tfail(\"Test should've been disabled \" + reason);\n+}\n+----\n+\n+You can also specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfDisplayName(contains = {\"1\", \"2\"})\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(ints = { 1, 2, 3, 4, 5 })\n+void testDisplayNameString(int num) {\n+\tif (num == 1 || num == 2)\n+\t\tfail(\"Test should've been disabled for \" + num);\n+}\n+----\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose display name\n+// contains \"disable \" or \"disabled \"\n+@DisableIfDisplayName(matches = \".*disabled?\\\\s.*\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,4,5\n+\t// Not disabled: 3,6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void single(String reason) {\n+\t// ...\n+}\n+----\n+\n+Using both `matches` and `contains` in a single annotation is no longer permitted as of {VERSION_OR_DATE_PLACHOLDER}.\n+\n+== DisableIfParameter\n+\n+This extension can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The extension comes with three annotations, covering different use-cases:\n+\n+- `@DisableIfAnyParameter`, non-repeatable\n+- `@DisableIfAllParameters`, non-repeatable\n+- `@DisableIfParameter`, repeatable\n+\n+The annotations are only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation, the extension evaluates each execution of a parameterized test.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test is possibly disabled individually.\n+All three annotations require that you specify one of two parameters, `contains` *or* `matches`.\n+`@DisableIfAnyParameter` will disable test executions if *any* argument either contains or matches any of the given strings.\n+`@DisableIfAllParameters` will disable test executions if *all* arguments either contain or match any of the given strings.\n+`@DisableIfParameter` will disable test executions if a *specified* argument either contains or matches any of the given strings.\n+\n+=== Using `contains`\n+\n+[source,java]\n+----\n+@DisableIfAllParameters(contains = \"the\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAllContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAllContains` ordinarily would run four times, but the second execution gets disabled because both arguments contain \"the\" (the second argument as part of \"there\").\n+Using the same test with a different annotation would look like this:\n+\n+[source,java]\n+----\n+@DisableIfAnyParameter(contains = \"Then\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAnyContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAnyContains` ordinarily would run four times, but the second and third executions get disabled because an argument contains \"Then\".\n+The last execution does not get disabled, because the extension is case-sensitive.\n+\n+You can specify more than one substring at a time:\n+\n+[source, java]\n+----\n+@DisableIfAnyParameter(contains = { \"Then\", \"then\" })\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAnyContains(String line, String line2) {\n+}\n+----\n+\n+The extension disables the second, third and fourth executions because an argument contains either \"Then\" or \"then\".\n+\n+`@DisableIfParameter` requires you to target a specific parameter.\n+You can do this in three ways:\n+\n+- By a `name` https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html#isNamePresent--[if parameter naming information is present].\n+- By an explicit `index`, starting from 0.\n+- By an implicit index.\n+\n+Using both `name` and `index` in a single `@DisableIfParameter` annotation is not permitted.\n+\n+==== Targeting by `name`\n+\n+If naming information is included during compilation, you can target parameters by their name.\n+\n+[source, java]\n+----\n+@DisableIfParameter(name = \"line2\", contains = \"swift\")\n+@ParameterizedTest\n+@CsvSource({\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\"\n+})\n+void targetName(String line, String line2) {\n+}\n+----\n+\n+The test gets executed two times because we explicitly targeted the second parameter, which never contains the word \"swift\".\n+\n+==== Targeting by `index`\n+\n+You can target your parameters with their index, starting from 0.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDUzMzg1Nw==", "bodyText": "I would add some kind of theader here, because the not is not a note for the particular example above", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/368#discussion_r600533857", "createdAt": "2021-03-24T14:32:13Z", "author": {"login": "Bukama"}, "path": "docs/disable-parameterized-tests.adoc", "diffHunk": "@@ -0,0 +1,250 @@\n+:page-title: Disable Parameterized Test\n+:page-description: Extends JUnit Jupiter with multiple extensions, which selectively disables parameterized tests\n+\n+JUnit Pioneer offers multiple extensions for selectively disabling parameterized tests.\n+These are as follows:\n+\n+- DisableIfDisplayName\n+- DisableIfParameter\n+\n+== DisableIfDisplayName\n+\n+\n+The `@DisableIfDisplayName` annotation can be used to selectively disable parameterized tests based on their display names, which are dynamically registered on runtime.\n+The annotation is only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation , `@DisableIfDisplayName` is validated before each parameterized test execution.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test (name) can be evaluated and possibly disabled individually.\n+\n+[source,java]\n+----\n+// disable invocations whose display name contains \"disable\"\n+@DisableIfDisplayName(contains = \"disable\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,3,4,5\n+\t// Not disabled: 6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void testExecutionDisabled(String reason) {\n+\tif (reason.contains(\"disable\"))\n+\t\tfail(\"Test should've been disabled \" + reason);\n+}\n+----\n+\n+You can also specify more than one substring at a time:\n+\n+[source,java]\n+----\n+@DisableIfDisplayName(contains = {\"1\", \"2\"})\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(ints = { 1, 2, 3, 4, 5 })\n+void testDisplayNameString(int num) {\n+\tif (num == 1 || num == 2)\n+\t\tfail(\"Test should've been disabled for \" + num);\n+}\n+----\n+\n+If substrings are not powerful enough, you can also use regular expressions:\n+\n+[source,java]\n+----\n+// disable invocations whose display name\n+// contains \"disable \" or \"disabled \"\n+@DisableIfDisplayName(matches = \".*disabled?\\\\s.*\")\n+@ParameterizedTest(name = \"See if enabled with {0}\")\n+@ValueSource(\n+\t// Disabled: 1,2,4,5\n+\t// Not disabled: 3,6\n+\tstrings = {\n+\t\t\"disable who\", // 1\n+\t\t\"you, disable you\", // 2\n+\t\t\"why am I disabled\", // 3\n+\t\t\"what has been disabled must stay disabled\", // 4\n+\t\t\"fine disable me all you want\", // 5\n+\t\t\"not those one, though!\" // 6\n+\t}\n+)\n+void single(String reason) {\n+\t// ...\n+}\n+----\n+\n+Using both `matches` and `contains` in a single annotation is no longer permitted as of {VERSION_OR_DATE_PLACHOLDER}.\n+\n+== DisableIfParameter\n+\n+This extension can be used to selectively disable parameterized tests based on their parameter values (converted with `toString()`).\n+The extension comes with three annotations, covering different use-cases:\n+\n+- `@DisableIfAnyParameter`, non-repeatable\n+- `@DisableIfAllParameters`, non-repeatable\n+- `@DisableIfParameter`, repeatable\n+\n+The annotations are only supported on test method level for parameterized tests.\n+Unlike the `@Disabled` API provided in JUnit Jupiter, which disables the test on first encounter of the annotation, the extension evaluates each execution of a parameterized test.\n+As a consequence, instead of disabling the entire set of parameterized tests, each test is possibly disabled individually.\n+All three annotations require that you specify one of two parameters, `contains` *or* `matches`.\n+`@DisableIfAnyParameter` will disable test executions if *any* argument either contains or matches any of the given strings.\n+`@DisableIfAllParameters` will disable test executions if *all* arguments either contain or match any of the given strings.\n+`@DisableIfParameter` will disable test executions if a *specified* argument either contains or matches any of the given strings.\n+\n+=== Using `contains`\n+\n+[source,java]\n+----\n+@DisableIfAllParameters(contains = \"the\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAllContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAllContains` ordinarily would run four times, but the second execution gets disabled because both arguments contain \"the\" (the second argument as part of \"there\").\n+Using the same test with a different annotation would look like this:\n+\n+[source,java]\n+----\n+@DisableIfAnyParameter(contains = \"Then\")\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAnyContains(String line, String line2) {\n+}\n+----\n+\n+The test `disableAnyContains` ordinarily would run four times, but the second and third executions get disabled because an argument contains \"Then\".\n+The last execution does not get disabled, because the extension is case-sensitive.\n+\n+You can specify more than one substring at a time:\n+\n+[source, java]\n+----\n+@DisableIfAnyParameter(contains = { \"Then\", \"then\" })\n+@ParameterizedTest\n+@CsvSource(value = {\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\",\n+\t\t\"Then let them toll the passing-bell,;Then of your servitude be free,\",\n+\t\t\"The clock may stop, its hands fall still,;And time be over then for me!\"\n+}, delimiter = ';')\n+void disableAnyContains(String line, String line2) {\n+}\n+----\n+\n+The extension disables the second, third and fourth executions because an argument contains either \"Then\" or \"then\".\n+\n+`@DisableIfParameter` requires you to target a specific parameter.\n+You can do this in three ways:\n+\n+- By a `name` https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html#isNamePresent--[if parameter naming information is present].\n+- By an explicit `index`, starting from 0.\n+- By an implicit index.\n+\n+Using both `name` and `index` in a single `@DisableIfParameter` annotation is not permitted.\n+\n+==== Targeting by `name`\n+\n+If naming information is included during compilation, you can target parameters by their name.\n+\n+[source, java]\n+----\n+@DisableIfParameter(name = \"line2\", contains = \"swift\")\n+@ParameterizedTest\n+@CsvSource({\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\"\n+})\n+void targetName(String line, String line2) {\n+}\n+----\n+\n+The test gets executed two times because we explicitly targeted the second parameter, which never contains the word \"swift\".\n+\n+==== Targeting by `index`\n+\n+You can target your parameters with their index, starting from 0.\n+\n+[source, java]\n+----\n+@DisableIfParameter(index = 1, contains = \"swift\")\n+@ParameterizedTest\n+@CsvSource({\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\"\n+})\n+void targetIndex(String line, String line2) {\n+}\n+----\n+\n+Again, the test gets executed two times, because we targeted the second parameter.\n+\n+==== Targeting by implicit index\n+\n+You can opt to not specify `index` or `name` and use annotation order to specify what parameter to target.\n+In this case the first `@DisableIfParameter` targets the first parameter, the second annotation the second parameter, etc.\n+This is mainly for convenience when you have a test method with a single parameter.\n+Using this method to target parameters when your test has multiple parameters is discouraged.\n+\n+[source, java]\n+----\n+@DisableIfParameter(contains = \"gibberish\")\n+@DisableIfParameter(contains = \"gladly\")\n+@ParameterizedTest\n+@CsvSource({\n+\t\t\"If the swift moment I entreat:;Tarry a while! You are so fair!\",\n+\t\t\"Then forge the shackles to my feet,;Then I will gladly perish there!\"\n+})\n+void targetByOrder(String line, String line2) {\n+}\n+----\n+\n+The test gets executed once.\n+The second execution is disabled because the second argument contains \"gladly\".\n+\n+=== Using `matches`\n+\n+If substrings are not powerful enough, you can also use regular expressions, with the `matches` value.\n+\n+[source,java]\n+----\n+// disable invocations whose parameter ends with 'knew' or 'grew'\n+@DisableIfParameter(matches = { \".*knew\", \".*grew\" })\n+@ParameterizedTest\n+@ValueSource(strings = {\n+\t\t\"Lily-like, white as snow,\",\n+\t\t\"She hardly knew\",\n+\t\t\"She was a woman, so\",\n+\t\t\"Sweetly she grew\"\n+})\n+void interceptMatches(String value) {\n+}\n+----\n+\n+These test invocations get disabled:\n+\n+* The second invocation, because it has a parameter that matches \".*knew\" - ends with knew.\n+* The fourth invocation, because it has a parameter that matches \".*grew\" - ends with grew.\n+\n+Just like with `contains`, if any parameter value matches any expression from `matches`, the invocation gets disabled.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6886d0b08891c97f83bd452fa5fb5b0c94ba009"}, "originalPosition": 245}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87637cbe979349587671a0a5d0a373283cb7054b", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/87637cbe979349587671a0a5d0a373283cb7054b", "committedDate": "2021-04-06T15:47:03Z", "message": "Update docs\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c32440b0fe1f8671b71c4413bb91af8609d0349", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6c32440b0fe1f8671b71c4413bb91af8609d0349", "committedDate": "2021-04-08T20:41:38Z", "message": "Merge branch 'main' into issue313/explore-invocation-interceptor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf6d5dc08453f6d850088e31c7735a9b7dbb8443", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/cf6d5dc08453f6d850088e31c7735a9b7dbb8443", "committedDate": "2021-04-08T23:05:27Z", "message": "Trigger checks again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faf3d609d64ad511955b7d6ed5b1e9f4b1f8dc62", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/faf3d609d64ad511955b7d6ed5b1e9f4b1f8dc62", "committedDate": "2021-04-17T13:18:02Z", "message": "Add JavaDoc on annotations\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d99b67b0c85b27c5284d5bb676aa21437a30085", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6d99b67b0c85b27c5284d5bb676aa21437a30085", "committedDate": "2021-04-17T13:22:53Z", "message": "More JavaDoc updates\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "612030f71ebc1d4275f21e1aee995978c16c7ca3", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/612030f71ebc1d4275f21e1aee995978c16c7ca3", "committedDate": "2021-04-18T08:53:34Z", "message": "Minor documentation polish\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b90527495c9f8281ee88fb5bf21eb2196c94e9f7", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b90527495c9f8281ee88fb5bf21eb2196c94e9f7", "committedDate": "2021-04-21T08:09:07Z", "message": "Merge branch 'main' into issue313/explore-invocation-interceptor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "960051f6bb6e4a8618a26a3d57920d40ffc6099e", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/960051f6bb6e4a8618a26a3d57920d40ffc6099e", "committedDate": "2021-05-18T17:03:47Z", "message": "Merge branch 'main' into issue313/explore-invocation-interceptor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76aa6d8f8152490b6e976f88fb29e90135e0938d", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/76aa6d8f8152490b6e976f88fb29e90135e0938d", "committedDate": "2021-05-18T19:38:44Z", "message": "Edit documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fad9b5df4d5de9f2516d367765927b3b169c8b2", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/4fad9b5df4d5de9f2516d367765927b3b169c8b2", "committedDate": "2021-05-18T19:40:07Z", "message": "Moving code around"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "058a1a2d448b7faeac390c417e952f2c4756ddc2", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/058a1a2d448b7faeac390c417e952f2c4756ddc2", "committedDate": "2021-05-18T20:13:08Z", "message": "Rename \"Parameter\" to \"Argument\""}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f8c3311ad18fe20f1d8af9cde5b327f6e5bda00", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/7f8c3311ad18fe20f1d8af9cde5b327f6e5bda00", "committedDate": "2021-05-29T11:47:13Z", "message": "Merge branch 'main' of https://github.com/junit-pioneer/junit-pioneer into issue313/explore-invocation-interceptor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27bd4fbef4cc34479af1b69e6980ea860ee3c387", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/27bd4fbef4cc34479af1b69e6980ea860ee3c387", "committedDate": "2021-05-29T11:50:12Z", "message": "Add since in javadoc"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3685, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}