{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2OTg3MzQz", "number": 294, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODoyMDozMlrOEOlC-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDozNDo1N1rOES-2jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzIyNDg5OnYy", "diffSide": "RIGHT", "path": "docs/report-entries.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODoyMDozMlrOGxzeWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzo1NjoxMlrOGyezbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg3Njc2MQ==", "bodyText": "Including the numbers?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r454876761", "createdAt": "2020-07-15T08:20:32Z", "author": {"login": "Bukama"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,31 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.\n+For example, if you have a `@ParameterizedTest` like the following:\n+\n+[source, java]\n+----\n+@ParameterizedTest\n+@MethodSource(\"params\")\n+@ReportEntry(\"{1} - {0}\")\n+void test(String line, int number) {\n+    // YOUR TEST CODE HERE\n+}\n+\n+Stream<Arguments> params() {\n+    return Stream.of(\n+            Arguments.of(\"Hello\", 1),\n+            Arguments.of(\"World\", 2);\n+    );\n+}\n+\n+----\n+Then the extension will publish `{1} - Hello` and `{2} - World`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "714be7ce2964c863252e239b500383723a100243"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4OTY0MQ==", "bodyText": "I mucked it up again, dang.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r454889641", "createdAt": "2020-07-15T08:42:02Z", "author": {"login": "Michael1993"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,31 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.\n+For example, if you have a `@ParameterizedTest` like the following:\n+\n+[source, java]\n+----\n+@ParameterizedTest\n+@MethodSource(\"params\")\n+@ReportEntry(\"{1} - {0}\")\n+void test(String line, int number) {\n+    // YOUR TEST CODE HERE\n+}\n+\n+Stream<Arguments> params() {\n+    return Stream.of(\n+            Arguments.of(\"Hello\", 1),\n+            Arguments.of(\"World\", 2);\n+    );\n+}\n+\n+----\n+Then the extension will publish `{1} - Hello` and `{2} - World`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg3Njc2MQ=="}, "originalCommit": {"oid": "714be7ce2964c863252e239b500383723a100243"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU4NjY2OQ==", "bodyText": "Fixed.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r455586669", "createdAt": "2020-07-16T07:56:12Z", "author": {"login": "Michael1993"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,31 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.\n+For example, if you have a `@ParameterizedTest` like the following:\n+\n+[source, java]\n+----\n+@ParameterizedTest\n+@MethodSource(\"params\")\n+@ReportEntry(\"{1} - {0}\")\n+void test(String line, int number) {\n+    // YOUR TEST CODE HERE\n+}\n+\n+Stream<Arguments> params() {\n+    return Stream.of(\n+            Arguments.of(\"Hello\", 1),\n+            Arguments.of(\"World\", 2);\n+    );\n+}\n+\n+----\n+Then the extension will publish `{1} - Hello` and `{2} - World`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg3Njc2MQ=="}, "originalCommit": {"oid": "714be7ce2964c863252e239b500383723a100243"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDUwMzg4OnYy", "diffSide": "RIGHT", "path": "docs/report-entries.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxMToyMzoxN1rOGzuu1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxNzozNTozOFrOGzxEtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NjIxNQ==", "bodyText": "I would add an hint like \"Inside the report entry the parameter values can be reported in any order\".\nQuestion from my side: Can they be reported multiple times, e.g. {1} - {1} - {0} - {0}, ?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456896215", "createdAt": "2020-07-19T11:23:17Z", "author": {"login": "Bukama"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,31 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNDU4MA==", "bodyText": "Yes, they can be reported multiple times, I'll update the tests (and the documentation) to reflect that.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456934580", "createdAt": "2020-07-19T17:35:38Z", "author": {"login": "Michael1993"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,31 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NjIxNQ=="}, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDUwNzUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxMToyODoxOVrOGzuwug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQyMTo1OToxNFrOGzyp-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NjY5OA==", "bodyText": "This seems that this message only works if the method has one parameter less than the ReportEntry? What if there are multiple missing?  This misconfiguration should also be mentioned in the docs, as the error messages is only clear (to me) when knowing the  context.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456896698", "createdAt": "2020-07-19T11:28:19Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -16,26 +16,62 @@\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_FAILURE;\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_SUCCESS;\n \n+import java.lang.reflect.Method;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Stream;\n \n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestWatcher;\n \n-class ReportEntryExtension implements TestWatcher, BeforeEachCallback {\n+class ReportEntryExtension implements TestWatcher, BeforeEachCallback, InvocationInterceptor {\n+\n+\tprivate static final ExtensionContext.Namespace NAMESPACE = ExtensionContext.Namespace\n+\t\t\t.create(ReportEntryExtension.class);\n+\n+\tprivate static final String KEY = \"ReportEntry\";\n \n \t@Override\n \tpublic void beforeEach(ExtensionContext context) {\n-\t\tfindAnnotations(context).forEach(ReportEntryExtension::verifyKeyValueAreNotBlank);\n+\t\tfindAnnotations(context).forEach(entry -> verifyReportEntry(context, entry));\n \t}\n \n \tprivate Stream<ReportEntry> findAnnotations(ExtensionContext context) {\n \t\treturn PioneerAnnotationUtils.findAllEnclosingRepeatableAnnotations(context, ReportEntry.class);\n \t}\n \n+\tprivate static void verifyReportEntry(ExtensionContext context, ReportEntry entry) {\n+\t\tverifyParameterCount(context, entry);\n+\t\tverifyKeyValueAreNotBlank(entry);\n+\t\tverifyKeyNotParameterized(entry);\n+\t}\n+\n+\tprivate static void verifyKeyNotParameterized(ReportEntry entry) {\n+\t\tif (entry.key().matches(\".*\\\\{([0-9])+}.*\")) {\n+\t\t\tString message = \"Report entry can not have variables in the key: { key=\\\"%s\\\" value=\\\"%s\\\" }\";\n+\t\t\tthrow new ExtensionConfigurationException(format(message, entry.key(), entry.value()));\n+\t\t}\n+\t}\n+\n+\tprivate static void verifyParameterCount(ExtensionContext context, ReportEntry entry) {\n+\t\tMatcher matcher = Pattern.compile(\"\\\\{([0-9])+}\").matcher(entry.value());\n+\t\tint variableCount = 0;\n+\t\twhile (matcher.find())\n+\t\t\tvariableCount++;\n+\n+\t\tif (context.getRequiredTestMethod().getParameterCount() < variableCount) {\n+\t\t\tString message = \"Report entry contains unresolved variable(s): { key=\\\"%s\\\" value=\\\"%s\\\" }\";\n+\t\t\tthrow new ExtensionConfigurationException(format(message, entry.key(), entry.value()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTk0NA==", "bodyText": "Why does it seem that way? I don't see it. Could you elaborate?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456935944", "createdAt": "2020-07-19T17:49:58Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -16,26 +16,62 @@\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_FAILURE;\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_SUCCESS;\n \n+import java.lang.reflect.Method;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Stream;\n \n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestWatcher;\n \n-class ReportEntryExtension implements TestWatcher, BeforeEachCallback {\n+class ReportEntryExtension implements TestWatcher, BeforeEachCallback, InvocationInterceptor {\n+\n+\tprivate static final ExtensionContext.Namespace NAMESPACE = ExtensionContext.Namespace\n+\t\t\t.create(ReportEntryExtension.class);\n+\n+\tprivate static final String KEY = \"ReportEntry\";\n \n \t@Override\n \tpublic void beforeEach(ExtensionContext context) {\n-\t\tfindAnnotations(context).forEach(ReportEntryExtension::verifyKeyValueAreNotBlank);\n+\t\tfindAnnotations(context).forEach(entry -> verifyReportEntry(context, entry));\n \t}\n \n \tprivate Stream<ReportEntry> findAnnotations(ExtensionContext context) {\n \t\treturn PioneerAnnotationUtils.findAllEnclosingRepeatableAnnotations(context, ReportEntry.class);\n \t}\n \n+\tprivate static void verifyReportEntry(ExtensionContext context, ReportEntry entry) {\n+\t\tverifyParameterCount(context, entry);\n+\t\tverifyKeyValueAreNotBlank(entry);\n+\t\tverifyKeyNotParameterized(entry);\n+\t}\n+\n+\tprivate static void verifyKeyNotParameterized(ReportEntry entry) {\n+\t\tif (entry.key().matches(\".*\\\\{([0-9])+}.*\")) {\n+\t\t\tString message = \"Report entry can not have variables in the key: { key=\\\"%s\\\" value=\\\"%s\\\" }\";\n+\t\t\tthrow new ExtensionConfigurationException(format(message, entry.key(), entry.value()));\n+\t\t}\n+\t}\n+\n+\tprivate static void verifyParameterCount(ExtensionContext context, ReportEntry entry) {\n+\t\tMatcher matcher = Pattern.compile(\"\\\\{([0-9])+}\").matcher(entry.value());\n+\t\tint variableCount = 0;\n+\t\twhile (matcher.find())\n+\t\t\tvariableCount++;\n+\n+\t\tif (context.getRequiredTestMethod().getParameterCount() < variableCount) {\n+\t\t\tString message = \"Report entry contains unresolved variable(s): { key=\\\"%s\\\" value=\\\"%s\\\" }\";\n+\t\t\tthrow new ExtensionConfigurationException(format(message, entry.key(), entry.value()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NjY5OA=="}, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MzI4MA==", "bodyText": "Because there is one key/value reported and an exception thrown, so no more are tested. Or do I have a mind bug?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456943280", "createdAt": "2020-07-19T19:04:29Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -16,26 +16,62 @@\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_FAILURE;\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_SUCCESS;\n \n+import java.lang.reflect.Method;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Stream;\n \n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestWatcher;\n \n-class ReportEntryExtension implements TestWatcher, BeforeEachCallback {\n+class ReportEntryExtension implements TestWatcher, BeforeEachCallback, InvocationInterceptor {\n+\n+\tprivate static final ExtensionContext.Namespace NAMESPACE = ExtensionContext.Namespace\n+\t\t\t.create(ReportEntryExtension.class);\n+\n+\tprivate static final String KEY = \"ReportEntry\";\n \n \t@Override\n \tpublic void beforeEach(ExtensionContext context) {\n-\t\tfindAnnotations(context).forEach(ReportEntryExtension::verifyKeyValueAreNotBlank);\n+\t\tfindAnnotations(context).forEach(entry -> verifyReportEntry(context, entry));\n \t}\n \n \tprivate Stream<ReportEntry> findAnnotations(ExtensionContext context) {\n \t\treturn PioneerAnnotationUtils.findAllEnclosingRepeatableAnnotations(context, ReportEntry.class);\n \t}\n \n+\tprivate static void verifyReportEntry(ExtensionContext context, ReportEntry entry) {\n+\t\tverifyParameterCount(context, entry);\n+\t\tverifyKeyValueAreNotBlank(entry);\n+\t\tverifyKeyNotParameterized(entry);\n+\t}\n+\n+\tprivate static void verifyKeyNotParameterized(ReportEntry entry) {\n+\t\tif (entry.key().matches(\".*\\\\{([0-9])+}.*\")) {\n+\t\t\tString message = \"Report entry can not have variables in the key: { key=\\\"%s\\\" value=\\\"%s\\\" }\";\n+\t\t\tthrow new ExtensionConfigurationException(format(message, entry.key(), entry.value()));\n+\t\t}\n+\t}\n+\n+\tprivate static void verifyParameterCount(ExtensionContext context, ReportEntry entry) {\n+\t\tMatcher matcher = Pattern.compile(\"\\\\{([0-9])+}\").matcher(entry.value());\n+\t\tint variableCount = 0;\n+\t\twhile (matcher.find())\n+\t\t\tvariableCount++;\n+\n+\t\tif (context.getRequiredTestMethod().getParameterCount() < variableCount) {\n+\t\t\tString message = \"Report entry contains unresolved variable(s): { key=\\\"%s\\\" value=\\\"%s\\\" }\";\n+\t\t\tthrow new ExtensionConfigurationException(format(message, entry.key(), entry.value()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NjY5OA=="}, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0NTY4MQ==", "bodyText": "No, I see what you mean. This is incorrect. Will fix shortly.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456945681", "createdAt": "2020-07-19T19:27:39Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -16,26 +16,62 @@\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_FAILURE;\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_SUCCESS;\n \n+import java.lang.reflect.Method;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Stream;\n \n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestWatcher;\n \n-class ReportEntryExtension implements TestWatcher, BeforeEachCallback {\n+class ReportEntryExtension implements TestWatcher, BeforeEachCallback, InvocationInterceptor {\n+\n+\tprivate static final ExtensionContext.Namespace NAMESPACE = ExtensionContext.Namespace\n+\t\t\t.create(ReportEntryExtension.class);\n+\n+\tprivate static final String KEY = \"ReportEntry\";\n \n \t@Override\n \tpublic void beforeEach(ExtensionContext context) {\n-\t\tfindAnnotations(context).forEach(ReportEntryExtension::verifyKeyValueAreNotBlank);\n+\t\tfindAnnotations(context).forEach(entry -> verifyReportEntry(context, entry));\n \t}\n \n \tprivate Stream<ReportEntry> findAnnotations(ExtensionContext context) {\n \t\treturn PioneerAnnotationUtils.findAllEnclosingRepeatableAnnotations(context, ReportEntry.class);\n \t}\n \n+\tprivate static void verifyReportEntry(ExtensionContext context, ReportEntry entry) {\n+\t\tverifyParameterCount(context, entry);\n+\t\tverifyKeyValueAreNotBlank(entry);\n+\t\tverifyKeyNotParameterized(entry);\n+\t}\n+\n+\tprivate static void verifyKeyNotParameterized(ReportEntry entry) {\n+\t\tif (entry.key().matches(\".*\\\\{([0-9])+}.*\")) {\n+\t\t\tString message = \"Report entry can not have variables in the key: { key=\\\"%s\\\" value=\\\"%s\\\" }\";\n+\t\t\tthrow new ExtensionConfigurationException(format(message, entry.key(), entry.value()));\n+\t\t}\n+\t}\n+\n+\tprivate static void verifyParameterCount(ExtensionContext context, ReportEntry entry) {\n+\t\tMatcher matcher = Pattern.compile(\"\\\\{([0-9])+}\").matcher(entry.value());\n+\t\tint variableCount = 0;\n+\t\twhile (matcher.find())\n+\t\t\tvariableCount++;\n+\n+\t\tif (context.getRequiredTestMethod().getParameterCount() < variableCount) {\n+\t\t\tString message = \"Report entry contains unresolved variable(s): { key=\\\"%s\\\" value=\\\"%s\\\" }\";\n+\t\t\tthrow new ExtensionConfigurationException(format(message, entry.key(), entry.value()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NjY5OA=="}, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2MDUwNQ==", "bodyText": "Should be fixed now.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456960505", "createdAt": "2020-07-19T21:59:14Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -16,26 +16,62 @@\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_FAILURE;\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_SUCCESS;\n \n+import java.lang.reflect.Method;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Stream;\n \n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestWatcher;\n \n-class ReportEntryExtension implements TestWatcher, BeforeEachCallback {\n+class ReportEntryExtension implements TestWatcher, BeforeEachCallback, InvocationInterceptor {\n+\n+\tprivate static final ExtensionContext.Namespace NAMESPACE = ExtensionContext.Namespace\n+\t\t\t.create(ReportEntryExtension.class);\n+\n+\tprivate static final String KEY = \"ReportEntry\";\n \n \t@Override\n \tpublic void beforeEach(ExtensionContext context) {\n-\t\tfindAnnotations(context).forEach(ReportEntryExtension::verifyKeyValueAreNotBlank);\n+\t\tfindAnnotations(context).forEach(entry -> verifyReportEntry(context, entry));\n \t}\n \n \tprivate Stream<ReportEntry> findAnnotations(ExtensionContext context) {\n \t\treturn PioneerAnnotationUtils.findAllEnclosingRepeatableAnnotations(context, ReportEntry.class);\n \t}\n \n+\tprivate static void verifyReportEntry(ExtensionContext context, ReportEntry entry) {\n+\t\tverifyParameterCount(context, entry);\n+\t\tverifyKeyValueAreNotBlank(entry);\n+\t\tverifyKeyNotParameterized(entry);\n+\t}\n+\n+\tprivate static void verifyKeyNotParameterized(ReportEntry entry) {\n+\t\tif (entry.key().matches(\".*\\\\{([0-9])+}.*\")) {\n+\t\t\tString message = \"Report entry can not have variables in the key: { key=\\\"%s\\\" value=\\\"%s\\\" }\";\n+\t\t\tthrow new ExtensionConfigurationException(format(message, entry.key(), entry.value()));\n+\t\t}\n+\t}\n+\n+\tprivate static void verifyParameterCount(ExtensionContext context, ReportEntry entry) {\n+\t\tMatcher matcher = Pattern.compile(\"\\\\{([0-9])+}\").matcher(entry.value());\n+\t\tint variableCount = 0;\n+\t\twhile (matcher.find())\n+\t\t\tvariableCount++;\n+\n+\t\tif (context.getRequiredTestMethod().getParameterCount() < variableCount) {\n+\t\t\tString message = \"Report entry contains unresolved variable(s): { key=\\\"%s\\\" value=\\\"%s\\\" }\";\n+\t\t\tthrow new ExtensionConfigurationException(format(message, entry.key(), entry.value()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NjY5OA=="}, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDUwOTYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxMTozMToxMlrOGzuxzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxOToyMDoxOFrOGzxtDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5Njk3NQ==", "bodyText": "Shouldn't there be a start of line and end of line symbol in the regEx?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456896975", "createdAt": "2020-07-19T11:31:12Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -60,16 +96,35 @@ public void testAborted(ExtensionContext context, Throwable cause) {\n \n \t@Override\n \tpublic void testFailed(ExtensionContext context, Throwable cause) {\n-\t\tpublishOnConditions(context, ALWAYS, ON_FAILURE);\n+\t\tif (!(cause instanceof ExtensionConfigurationException)) {\n+\t\t\tpublishOnConditions(context, ALWAYS, ON_FAILURE);\n+\t\t}\n \t}\n \n \tprivate void publishOnConditions(ExtensionContext context, ReportEntry.PublishCondition... conditions) {\n \t\tfindAnnotations(context)\n \t\t\t\t.filter(entry -> Arrays.asList(conditions).contains(entry.when()))\n-\t\t\t\t// we filter for empty keys/values because this is called if the test failed -\n-\t\t\t\t// even if it's due to bad extension configuration (but we don't publish for those)\n-\t\t\t\t.filter(entry -> !entry.key().isEmpty() && !entry.value().isEmpty())\n-\t\t\t\t.forEach(entry -> context.publishReportEntry(entry.key(), entry.value()));\n+\t\t\t\t.forEach(entry -> context.publishReportEntry(entry.key(), parseVariables(entry.value(), context)));\n+\t}\n+\n+\tprivate String parseVariables(String value, ExtensionContext context) {\n+\t\tif (!value.matches(\".*\\\\{.*}.*\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5NzI2OA==", "bodyText": "I don't understand the regex. The \\\\ means you check for \\ (first backslash is to escape second baskslash), but why even check for a baskslash? Then inside the curly braces you check for any character which may or may not be there (there can be no character between the curly braces). But I think (look below in line 117) you search for numeric (interger) values. So why you don't check for them inside the regex?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456897268", "createdAt": "2020-07-19T11:34:27Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -60,16 +96,35 @@ public void testAborted(ExtensionContext context, Throwable cause) {\n \n \t@Override\n \tpublic void testFailed(ExtensionContext context, Throwable cause) {\n-\t\tpublishOnConditions(context, ALWAYS, ON_FAILURE);\n+\t\tif (!(cause instanceof ExtensionConfigurationException)) {\n+\t\t\tpublishOnConditions(context, ALWAYS, ON_FAILURE);\n+\t\t}\n \t}\n \n \tprivate void publishOnConditions(ExtensionContext context, ReportEntry.PublishCondition... conditions) {\n \t\tfindAnnotations(context)\n \t\t\t\t.filter(entry -> Arrays.asList(conditions).contains(entry.when()))\n-\t\t\t\t// we filter for empty keys/values because this is called if the test failed -\n-\t\t\t\t// even if it's due to bad extension configuration (but we don't publish for those)\n-\t\t\t\t.filter(entry -> !entry.key().isEmpty() && !entry.value().isEmpty())\n-\t\t\t\t.forEach(entry -> context.publishReportEntry(entry.key(), entry.value()));\n+\t\t\t\t.forEach(entry -> context.publishReportEntry(entry.key(), parseVariables(entry.value(), context)));\n+\t}\n+\n+\tprivate String parseVariables(String value, ExtensionContext context) {\n+\t\tif (!value.matches(\".*\\\\{.*}.*\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5Njk3NQ=="}, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTgyMA==", "bodyText": "We don't really care where we find the regex inside the String so there is no need for boundary matchers.\n{ and } are 'special' characters in regexes (quantifiers?). For example a{5} means exactly five a characters. Because of this, the opening { needs to be \"escaped\" in the regex. Normally this would be done with \\{ however, in Java, \\ is an escape character already (e.g.: \\n is newline). So, we have to put \\\\ in the regex - first, to escape from the String, then to escape from the regex. Worse than Alcatraz, really.\nThis is an early return, checking for a negative - if there are no curly braces in the value, we return immediately because there are no variables in the @ReportEntry value. If there are, we try to parse them and throw an exception if they cannot be parsed. An argument could be made that empty curly braces, i.e.: {} should not throw an exception - if you think that should be changed, let me know.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456935820", "createdAt": "2020-07-19T17:48:41Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -60,16 +96,35 @@ public void testAborted(ExtensionContext context, Throwable cause) {\n \n \t@Override\n \tpublic void testFailed(ExtensionContext context, Throwable cause) {\n-\t\tpublishOnConditions(context, ALWAYS, ON_FAILURE);\n+\t\tif (!(cause instanceof ExtensionConfigurationException)) {\n+\t\t\tpublishOnConditions(context, ALWAYS, ON_FAILURE);\n+\t\t}\n \t}\n \n \tprivate void publishOnConditions(ExtensionContext context, ReportEntry.PublishCondition... conditions) {\n \t\tfindAnnotations(context)\n \t\t\t\t.filter(entry -> Arrays.asList(conditions).contains(entry.when()))\n-\t\t\t\t// we filter for empty keys/values because this is called if the test failed -\n-\t\t\t\t// even if it's due to bad extension configuration (but we don't publish for those)\n-\t\t\t\t.filter(entry -> !entry.key().isEmpty() && !entry.value().isEmpty())\n-\t\t\t\t.forEach(entry -> context.publishReportEntry(entry.key(), entry.value()));\n+\t\t\t\t.forEach(entry -> context.publishReportEntry(entry.key(), parseVariables(entry.value(), context)));\n+\t}\n+\n+\tprivate String parseVariables(String value, ExtensionContext context) {\n+\t\tif (!value.matches(\".*\\\\{.*}.*\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5Njk3NQ=="}, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0NDkwOQ==", "bodyText": "I should stop reviewing, of course \\\\{ is the regex and not \\{ \ud83e\udd26", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r456944909", "createdAt": "2020-07-19T19:20:18Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -60,16 +96,35 @@ public void testAborted(ExtensionContext context, Throwable cause) {\n \n \t@Override\n \tpublic void testFailed(ExtensionContext context, Throwable cause) {\n-\t\tpublishOnConditions(context, ALWAYS, ON_FAILURE);\n+\t\tif (!(cause instanceof ExtensionConfigurationException)) {\n+\t\t\tpublishOnConditions(context, ALWAYS, ON_FAILURE);\n+\t\t}\n \t}\n \n \tprivate void publishOnConditions(ExtensionContext context, ReportEntry.PublishCondition... conditions) {\n \t\tfindAnnotations(context)\n \t\t\t\t.filter(entry -> Arrays.asList(conditions).contains(entry.when()))\n-\t\t\t\t// we filter for empty keys/values because this is called if the test failed -\n-\t\t\t\t// even if it's due to bad extension configuration (but we don't publish for those)\n-\t\t\t\t.filter(entry -> !entry.key().isEmpty() && !entry.value().isEmpty())\n-\t\t\t\t.forEach(entry -> context.publishReportEntry(entry.key(), entry.value()));\n+\t\t\t\t.forEach(entry -> context.publishReportEntry(entry.key(), parseVariables(entry.value(), context)));\n+\t}\n+\n+\tprivate String parseVariables(String value, ExtensionContext context) {\n+\t\tif (!value.matches(\".*\\\\{.*}.*\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5Njk3NQ=="}, "originalCommit": {"oid": "dccf86090cda246d3876550dd57d5f5be483403e"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MzMwODgyOnYy", "diffSide": "RIGHT", "path": "docs/report-entries.adoc", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDoxMjozN1rOG4dAkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo0MDo0NlrOG9iZuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0ODcyMw==", "bodyText": "Can you mention and link to the format you're using here? (Is it String::format or MessageFormat?)", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r461848723", "createdAt": "2020-07-28T20:12:37Z", "author": {"login": "nipafx"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,32 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf381e45ea72a9a371c50f9ff29c8627e1da5cb"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxODc1Nw==", "bodyText": "As far as I see - this is still open right?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r466518757", "createdAt": "2020-08-06T16:00:39Z", "author": {"login": "Bukama"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,32 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0ODcyMw=="}, "originalCommit": {"oid": "8bf381e45ea72a9a371c50f9ff29c8627e1da5cb"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg5NzY1MA==", "bodyText": "Did I misunderstand? I did mention that the format of the variables is in line with JUnit's @ParameterizedTest naming", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r466897650", "createdAt": "2020-08-07T08:26:09Z", "author": {"login": "Michael1993"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,32 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0ODcyMw=="}, "originalCommit": {"oid": "8bf381e45ea72a9a371c50f9ff29c8627e1da5cb"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3OTk2MA==", "bodyText": "The way I understood Nicolais question is that he wanted to see you mention String::format or MessageFormat, but maybe I missunderstood him.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r467179960", "createdAt": "2020-08-07T17:40:46Z", "author": {"login": "Bukama"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,32 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0ODcyMw=="}, "originalCommit": {"oid": "8bf381e45ea72a9a371c50f9ff29c8627e1da5cb"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MzMxMjYyOnYy", "diffSide": "RIGHT", "path": "docs/report-entries.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDoxMzoxMlrOG4dCcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQwODoxNzowNVrOG6cisA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0OTIwMQ==", "bodyText": "For small parameter sets, @CsvSource is more succinct and easier to read. Can you switch to it?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r461849201", "createdAt": "2020-07-28T20:13:12Z", "author": {"login": "nipafx"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,32 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.\n+Inside the report entry, the parameters can be referenced in any order and multiple times.\n+For example, if you have a `@ParameterizedTest` like the following:\n+\n+[source, java]\n+----\n+@ParameterizedTest\n+@MethodSource(\"params\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf381e45ea72a9a371c50f9ff29c8627e1da5cb"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkzODIyNA==", "bodyText": "Changed to @CsvSource", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r463938224", "createdAt": "2020-08-01T08:17:05Z", "author": {"login": "Michael1993"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,32 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.\n+Inside the report entry, the parameters can be referenced in any order and multiple times.\n+For example, if you have a `@ParameterizedTest` like the following:\n+\n+[source, java]\n+----\n+@ParameterizedTest\n+@MethodSource(\"params\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0OTIwMQ=="}, "originalCommit": {"oid": "8bf381e45ea72a9a371c50f9ff29c8627e1da5cb"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MzMxNTMzOnYy", "diffSide": "RIGHT", "path": "docs/report-entries.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDoxMzo0MlrOG4dECQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDoxMzo0MlrOG4dECQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0OTYwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then the extension will publish `21 - Hello - 21` and `42 - World - 42`.\n          \n          \n            \n            Then the extension will publish `\"21 - Hello - 21\"` and `\"42 - World - 42\"`.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r461849609", "createdAt": "2020-07-28T20:13:42Z", "author": {"login": "nipafx"}, "path": "docs/report-entries.adoc", "diffHunk": "@@ -110,4 +110,32 @@ The extension will publish your report entry if the test fails.\n ON_ABORTED::\n The extension will publish your report entry if the test was aborted (for example because of an https://junit.org/junit5/docs/current/user-guide/#writing-tests-assumptions[Assumption]).\n \n-Entries will always be published after the test finished.\n\\ No newline at end of file\n+Entries will always be published after the test finished.\n+\n+=== Publishing test parameters\n+\n+You can access `@ParameterizedTest` parameter values and publish them with the `@ReportEntry` annotation.\n+Add a number (starting from zero) between curly braces to reference the parameter with that index.\n+Inside the report entry, the parameters can be referenced in any order and multiple times.\n+For example, if you have a `@ParameterizedTest` like the following:\n+\n+[source, java]\n+----\n+@ParameterizedTest\n+@MethodSource(\"params\")\n+@ReportEntry(\"{1} - {0} - {1}\")\n+void test(String line, int number) {\n+    // YOUR TEST CODE HERE\n+}\n+\n+Stream<Arguments> params() {\n+    return Stream.of(\n+            Arguments.of(\"Hello\", 21),\n+            Arguments.of(\"World\", 42);\n+    );\n+}\n+\n+----\n+Then the extension will publish `21 - Hello - 21` and `42 - World - 42`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf381e45ea72a9a371c50f9ff29c8627e1da5cb"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MzM5NTk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDozNDo1N1rOG4dztA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQwODoxNzo0NlrOG6cizg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2MTgxMg==", "bodyText": "Maybe extract matches(\".*\\\\{[0-9]+}.*\") into a method?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r461861812", "createdAt": "2020-07-28T20:34:57Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -16,33 +16,78 @@\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_FAILURE;\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_SUCCESS;\n \n+import java.lang.reflect.Method;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Stream;\n \n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestWatcher;\n \n-class ReportEntryExtension implements TestWatcher, BeforeEachCallback {\n+class ReportEntryExtension implements TestWatcher, BeforeEachCallback, InvocationInterceptor {\n+\n+\tprivate static final ExtensionContext.Namespace NAMESPACE = ExtensionContext.Namespace\n+\t\t\t.create(ReportEntryExtension.class);\n+\n+\tprivate static final String KEY = \"ReportEntry\";\n \n \t@Override\n \tpublic void beforeEach(ExtensionContext context) {\n-\t\tfindAnnotations(context).forEach(ReportEntryExtension::verifyKeyValueAreNotBlank);\n+\t\tfindAnnotations(context).forEach(entry -> verifyReportEntry(context, entry));\n \t}\n \n \tprivate Stream<ReportEntry> findAnnotations(ExtensionContext context) {\n \t\treturn PioneerAnnotationUtils.findAllEnclosingRepeatableAnnotations(context, ReportEntry.class);\n \t}\n \n+\tprivate static void verifyReportEntry(ExtensionContext context, ReportEntry entry) {\n+\t\tverifyParameterCount(context, entry);\n+\t\tverifyKeyValueAreNotBlank(entry);\n+\t\tverifyKeyNotParameterized(entry);\n+\t}\n+\n+\tprivate static void verifyParameterCount(ExtensionContext context, ReportEntry entry) {\n+\t\tboolean valueReferencesNumberedParameter = entry.value().matches(\".*\\\\{[0-9]+}.*\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690ddcc1cf53d65acad1e60cc4f08582fad9a537"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkzODI1NA==", "bodyText": "Agree, extracted and slightly refactored.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/294#discussion_r463938254", "createdAt": "2020-08-01T08:17:46Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/ReportEntryExtension.java", "diffHunk": "@@ -16,33 +16,78 @@\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_FAILURE;\n import static org.junitpioneer.jupiter.ReportEntry.PublishCondition.ON_SUCCESS;\n \n+import java.lang.reflect.Method;\n import java.util.Arrays;\n+import java.util.List;\n import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.stream.Stream;\n \n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestWatcher;\n \n-class ReportEntryExtension implements TestWatcher, BeforeEachCallback {\n+class ReportEntryExtension implements TestWatcher, BeforeEachCallback, InvocationInterceptor {\n+\n+\tprivate static final ExtensionContext.Namespace NAMESPACE = ExtensionContext.Namespace\n+\t\t\t.create(ReportEntryExtension.class);\n+\n+\tprivate static final String KEY = \"ReportEntry\";\n \n \t@Override\n \tpublic void beforeEach(ExtensionContext context) {\n-\t\tfindAnnotations(context).forEach(ReportEntryExtension::verifyKeyValueAreNotBlank);\n+\t\tfindAnnotations(context).forEach(entry -> verifyReportEntry(context, entry));\n \t}\n \n \tprivate Stream<ReportEntry> findAnnotations(ExtensionContext context) {\n \t\treturn PioneerAnnotationUtils.findAllEnclosingRepeatableAnnotations(context, ReportEntry.class);\n \t}\n \n+\tprivate static void verifyReportEntry(ExtensionContext context, ReportEntry entry) {\n+\t\tverifyParameterCount(context, entry);\n+\t\tverifyKeyValueAreNotBlank(entry);\n+\t\tverifyKeyNotParameterized(entry);\n+\t}\n+\n+\tprivate static void verifyParameterCount(ExtensionContext context, ReportEntry entry) {\n+\t\tboolean valueReferencesNumberedParameter = entry.value().matches(\".*\\\\{[0-9]+}.*\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2MTgxMg=="}, "originalCommit": {"oid": "690ddcc1cf53d65acad1e60cc4f08582fad9a537"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4279, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}