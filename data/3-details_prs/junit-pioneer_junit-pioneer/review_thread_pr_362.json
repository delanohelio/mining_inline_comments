{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MTc5MzI1", "number": 362, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzo0NTowNVrOExoe7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMDoxMjoxNlrOFIScAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDc4OTU2OnYy", "diffSide": "RIGHT", "path": "docs/cartesian-product.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzo0NTowNVrOHn3LSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzo0NTowNVrOHn3LSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MDUyMw==", "bodyText": "First line has an upper T the other two a lower one.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r511560523", "createdAt": "2020-10-25T07:45:05Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -25,7 +25,7 @@ The extension takes the test data parameter values and runs the test for every p\n You can supply test parameters to `@CartesianProductTest` in multiple ways.\n \n  - The annotation can have a `String[]` value (see <<Supplying CartesianProductTest with a `String[]`>>)\n- - the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>)\n+ - the test method can be annotated with `@CartesianValueSource` or range source annotations (see <<Annotating your test method>>)\n  - the test class can have a static factory method providing the arguments (see <<Writing a static factory method for the parameters>>)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDc5MTkwOnYy", "diffSide": "RIGHT", "path": "docs/cartesian-product.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzo0ODoxMVrOHn3McA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToyMTowN1rOHoUuVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MDgxNg==", "bodyText": "A bit below there is link to ValueSources of JUnit (can't comment that unchanged line), but the link only opens the user guide but not the anker of that sub topic", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r511560816", "createdAt": "2020-10-25T07:48:11Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -78,7 +78,7 @@ To demonstrate with a table:\n | 8th test  | \"1\"            | \"1\"            | \"1\"\n |===\n \n-== Annotating your test method with @CartesianValueSource\n+== Annotating your test method\n \n If you don't only supply string values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n `@CartesianValueSource` is used to define the possible inputs of a single test parameter - as annotations are listed top-to-bottom, they provide parameter values left-to-right.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NDYzMA==", "bodyText": "https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-sources-ValueSource This is the link. It absolutely should open the user guide at the proper anchor.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r512044630", "createdAt": "2020-10-26T15:21:07Z", "author": {"login": "Michael1993"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -78,7 +78,7 @@ To demonstrate with a table:\n | 8th test  | \"1\"            | \"1\"            | \"1\"\n |===\n \n-== Annotating your test method with @CartesianValueSource\n+== Annotating your test method\n \n If you don't only supply string values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n `@CartesianValueSource` is used to define the possible inputs of a single test parameter - as annotations are listed top-to-bottom, they provide parameter values left-to-right.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MDgxNg=="}, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDc5Mjg2OnYy", "diffSide": "RIGHT", "path": "docs/cartesian-product.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzo0OTozOFrOHn3M7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNVQwNzo0OTozOFrOHn3M7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTU2MDk0Mw==", "bodyText": "Note: We have to check this link (and the one below) after site deployment, as of now in the PR it points to https://github.com/junit-pioneer/junit-pioneer/blob/d0ef6d0e6d307246a54747055866f12973d9971c/docs/range-sources.adoc but I know that it some kind of relative link.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r511560943", "createdAt": "2020-10-25T07:49:38Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -113,6 +113,38 @@ To demonstrate with a table:\n | 6th test  | 4                 | \"B\"\n |===\n \n+Alternatively, you can annotate your test method with link:range-sources.adoc[range source annotations].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzIwNjM5OnYy", "diffSide": "RIGHT", "path": "docs/cartesian-product.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNzozMlrOH5VhZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxNzozMlrOH5VhZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MzQ5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is not like `@ParameterizedTest` where you have to define all inputs in a single `@ArgumentsSource`.\n          \n          \n            \n            This is _not_ like `@ParameterizedTest`, where you have to define all inputs in a single `@ArgumentsSource`.\n          \n      \n    \n    \n  \n\n\ud83d\ude01", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529883493", "createdAt": "2020-11-24T21:17:32Z", "author": {"login": "nipafx"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -113,6 +113,38 @@ To demonstrate with a table:\n | 6th test  | 4                 | \"B\"\n |===\n \n+Alternatively, you can annotate your test method with link:range-sources.adoc[range source annotations].\n+For _this purpose only_, range sources are repeatable.\n+When you annotate your `@CartesianProductTest` with a range source, you specify the inputs to a single test parameter.\n+This is not like `@ParameterizedTest` where you have to define all inputs in a single `@ArgumentsSource`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzIxMDg3OnYy", "diffSide": "RIGHT", "path": "docs/cartesian-product.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxODo1NlrOH5VkIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToxODo1NlrOH5VkIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NDE5Mw==", "bodyText": "Asciidoc source blocks and tab indentation, please. :)", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529884193", "createdAt": "2020-11-24T21:18:56Z", "author": {"login": "nipafx"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -113,6 +113,38 @@ To demonstrate with a table:\n | 6th test  | 4                 | \"B\"\n |===\n \n+Alternatively, you can annotate your test method with link:range-sources.adoc[range source annotations].\n+For _this purpose only_, range sources are repeatable.\n+When you annotate your `@CartesianProductTest` with a range source, you specify the inputs to a single test parameter.\n+This is not like `@ParameterizedTest` where you have to define all inputs in a single `@ArgumentsSource`.\n+\n+```java\n+@CartesianProductTest\n+@ShortRangeSource(from = 1, to = 3, step = 1)\n+@LongRangeSource(from = 0L, to = 2L, step = 1, closed = true)\n+void testShortAndLong(short s, long l) {\n+    // passing test code\n+}\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzI0Njg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/params/ByteRangeSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToyODo0N1rOH5V4wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToyODo0N1rOH5V4wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4OTQ3Mg==", "bodyText": "As these annotations are now repeatable and can be used with Cartesian products, I think they need some more changes:\n\nexplain their dual use in their Javadoc (including a link to Cartesian product docu)\nexplain where they can be repeated and where they can't", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529889472", "createdAt": "2020-11-24T21:28:47Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/params/ByteRangeSource.java", "diffHunk": "@@ -36,6 +37,7 @@\n @Documented\n @ArgumentsSource(RangeSourceArgumentsProvider.class)\n @RangeClass(ByteRange.class)\n+@Repeatable(ByteRangeSource.ByteRangeSources.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzI1MDMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/params/RangeSourceArgumentsProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToyOTo0M1rOH5V6tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToyOTo0M1rOH5V6tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4OTk3NA==", "bodyText": "This message may be more helpful if we explain why, even though the annotation is repeatable, it can only occur once on @ParameterizedTests.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529889974", "createdAt": "2020-11-24T21:29:43Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/params/RangeSourceArgumentsProvider.java", "diffHunk": "@@ -63,17 +78,16 @@\n \t\t\tthrow new IllegalArgumentException(message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzI1OTcxOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTozMjozNFrOH5V__Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTozMjozNFrOH5V__Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MTMyNQ==", "bodyText": "This looks great!", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529891325", "createdAt": "2020-11-24T21:32:34Z", "author": {"login": "nipafx"}, "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -590,4 +671,41 @@ void distinctInputsFactory(TimeUnit unit, String string) {\n         //@formatter:on\n \t}\n \n+\tstatic class ArgumentsSourceTestCases {\n+\n+\t\t@CartesianProductTest\n+\t\t@IntRangeSource(from = 1, to = 4, closed = true)\n+\t\t@IntRangeSource(from = 2, to = 4, step = 2, closed = true)\n+\t\t@ReportEntry(\"{0},{1}\")\n+\t\tvoid basicIntRangeSource(int i, int j) {\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzI2MTI0OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTozMzowMlrOH5WA5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTozMzowMlrOH5WA5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5MTU1OA==", "bodyText": "If this works with @CartesianValueSource, there should be a test for that.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529891558", "createdAt": "2020-11-24T21:33:02Z", "author": {"login": "nipafx"}, "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -590,4 +671,41 @@ void distinctInputsFactory(TimeUnit unit, String string) {\n         //@formatter:on\n \t}\n \n+\tstatic class ArgumentsSourceTestCases {\n+\n+\t\t@CartesianProductTest\n+\t\t@IntRangeSource(from = 1, to = 4, closed = true)\n+\t\t@IntRangeSource(from = 2, to = 4, step = 2, closed = true)\n+\t\t@ReportEntry(\"{0},{1}\")\n+\t\tvoid basicIntRangeSource(int i, int j) {\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@IntRangeSource(from = 0, to = 4)\n+\t\t@ValueSource(ints = { 2, 4 })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzI3NzYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/PioneerAnnotationUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTozODoxNVrOH5WKlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxOTo0NDozNVrOIKHLzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDAzOA==", "bodyText": "Without looking into this, I'm a but surprised that there's a combination of annotation search parameters that we don't already cover. Can you help me understand how this is different from the other methods?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529894038", "createdAt": "2020-11-24T21:38:15Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/PioneerAnnotationUtils.java", "diffHunk": "@@ -117,6 +121,39 @@ public static boolean isAnyRepeatableAnnotationPresent(ExtensionContext context,\n \t\treturn findAnnotations(context, annotationType, true, true);\n \t}\n \n+\t/**\n+\t * Returns the annotations <em>present</em> on the {@code AnnotatedElement}\n+\t * that are annotated with the specified annotation. The meta-annotation can be <em>present</em>,\n+\t * <em>indirectly present</em>, <em>meta-present</em>, or <em>enclosing present</em>.\n+\t */\n+\tpublic static <A extends Annotation> List<Annotation> findAnnotatedAnnotations(AnnotatedElement element,\n+\t\t\tClass<A> annotation) {\n+\t\treturn Arrays\n+\t\t\t\t.stream(element.getDeclaredAnnotations())\n+\t\t\t\t// flatten @Repeatable aggregator annotations\n+\t\t\t\t.flatMap(PioneerAnnotationUtils::flatten)\n+\t\t\t\t.filter(a -> !(findOnElement(a.annotationType(), annotation, true).isEmpty()))\n+\t\t\t\t.collect(Collectors.toList());\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMjgyNA==", "bodyText": "JUnits AnnotationSupport and our own PioneerAnnotationUtils has a lot of methods for getting specific annotations directly. We can not get annotations based on a criteria. I wanted to get all annotations on a test method that are themselves annotated with @ArgumentsSource. So, that's what this does - returns all annotations on an AnnotatedElement that are annotated with a given annotation.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r532802824", "createdAt": "2020-11-30T18:17:28Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/PioneerAnnotationUtils.java", "diffHunk": "@@ -117,6 +121,39 @@ public static boolean isAnyRepeatableAnnotationPresent(ExtensionContext context,\n \t\treturn findAnnotations(context, annotationType, true, true);\n \t}\n \n+\t/**\n+\t * Returns the annotations <em>present</em> on the {@code AnnotatedElement}\n+\t * that are annotated with the specified annotation. The meta-annotation can be <em>present</em>,\n+\t * <em>indirectly present</em>, <em>meta-present</em>, or <em>enclosing present</em>.\n+\t */\n+\tpublic static <A extends Annotation> List<Annotation> findAnnotatedAnnotations(AnnotatedElement element,\n+\t\t\tClass<A> annotation) {\n+\t\treturn Arrays\n+\t\t\t\t.stream(element.getDeclaredAnnotations())\n+\t\t\t\t// flatten @Repeatable aggregator annotations\n+\t\t\t\t.flatMap(PioneerAnnotationUtils::flatten)\n+\t\t\t\t.filter(a -> !(findOnElement(a.annotationType(), annotation, true).isEmpty()))\n+\t\t\t\t.collect(Collectors.toList());\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDAzOA=="}, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ3NDM4MA==", "bodyText": "Got it now. \ud83d\udc4d\ud83c\udffe", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r547474380", "createdAt": "2020-12-22T19:44:35Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/PioneerAnnotationUtils.java", "diffHunk": "@@ -117,6 +121,39 @@ public static boolean isAnyRepeatableAnnotationPresent(ExtensionContext context,\n \t\treturn findAnnotations(context, annotationType, true, true);\n \t}\n \n+\t/**\n+\t * Returns the annotations <em>present</em> on the {@code AnnotatedElement}\n+\t * that are annotated with the specified annotation. The meta-annotation can be <em>present</em>,\n+\t * <em>indirectly present</em>, <em>meta-present</em>, or <em>enclosing present</em>.\n+\t */\n+\tpublic static <A extends Annotation> List<Annotation> findAnnotatedAnnotations(AnnotatedElement element,\n+\t\t\tClass<A> annotation) {\n+\t\treturn Arrays\n+\t\t\t\t.stream(element.getDeclaredAnnotations())\n+\t\t\t\t// flatten @Repeatable aggregator annotations\n+\t\t\t\t.flatMap(PioneerAnnotationUtils::flatten)\n+\t\t\t\t.filter(a -> !(findOnElement(a.annotationType(), annotation, true).isEmpty()))\n+\t\t\t\t.collect(Collectors.toList());\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDAzOA=="}, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzI4MzA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/CartesianValueArgumentsProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTozOTo0N1rOH5WNxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoxMDozMFrOH8HcuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDg1Mw==", "bodyText": "Did you check newer Eclipse versions work with this?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529894853", "createdAt": "2020-11-24T21:39:47Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianValueArgumentsProvider.java", "diffHunk": "@@ -13,28 +13,29 @@\n import static java.util.stream.Collectors.toList;\n \n import java.lang.reflect.Array;\n-import java.util.Arrays;\n import java.util.List;\n import java.util.function.Consumer;\n import java.util.stream.IntStream;\n import java.util.stream.Stream;\n \n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n import org.junit.platform.commons.PreconditionViolationException;\n \n /**\n  * This is basically a copy of ValueSourceArgumentsProvider,\n  * except it does NOT support {@code @ParameterizedTest}.\n  */\n-class CartesianValueArgumentsProvider implements Consumer<CartesianValueSource> {\n+class CartesianValueArgumentsProvider implements Consumer<CartesianValueSource>, ArgumentsProvider {\n \n \tprivate Object[] arguments;\n \n \t@Override\n \tpublic void accept(CartesianValueSource source) {\n \t\t// @formatter:off\n \t\tList<Object> arrays =\n-\t\t\t\t// Declaration of <Object> is necessary due to a bug in Eclipse Photon.\n-\t\t\t\tStream.<Object> of(\n+\t\t\t\tStream.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkwNjM5Nw==", "bodyText": "Hm, I can't remember. I think I did, but I forgot to write it down. \ud83e\udd26", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r530906397", "createdAt": "2020-11-26T09:56:54Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianValueArgumentsProvider.java", "diffHunk": "@@ -13,28 +13,29 @@\n import static java.util.stream.Collectors.toList;\n \n import java.lang.reflect.Array;\n-import java.util.Arrays;\n import java.util.List;\n import java.util.function.Consumer;\n import java.util.stream.IntStream;\n import java.util.stream.Stream;\n \n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n import org.junit.platform.commons.PreconditionViolationException;\n \n /**\n  * This is basically a copy of ValueSourceArgumentsProvider,\n  * except it does NOT support {@code @ParameterizedTest}.\n  */\n-class CartesianValueArgumentsProvider implements Consumer<CartesianValueSource> {\n+class CartesianValueArgumentsProvider implements Consumer<CartesianValueSource>, ArgumentsProvider {\n \n \tprivate Object[] arguments;\n \n \t@Override\n \tpublic void accept(CartesianValueSource source) {\n \t\t// @formatter:off\n \t\tList<Object> arrays =\n-\t\t\t\t// Declaration of <Object> is necessary due to a bug in Eclipse Photon.\n-\t\t\t\tStream.<Object> of(\n+\t\t\t\tStream.of(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDg1Mw=="}, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5ODY0OQ==", "bodyText": "I will revert it just to be safe - but we should check it sometime.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r532798649", "createdAt": "2020-11-30T18:10:30Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianValueArgumentsProvider.java", "diffHunk": "@@ -13,28 +13,29 @@\n import static java.util.stream.Collectors.toList;\n \n import java.lang.reflect.Array;\n-import java.util.Arrays;\n import java.util.List;\n import java.util.function.Consumer;\n import java.util.stream.IntStream;\n import java.util.stream.Stream;\n \n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n import org.junit.platform.commons.PreconditionViolationException;\n \n /**\n  * This is basically a copy of ValueSourceArgumentsProvider,\n  * except it does NOT support {@code @ParameterizedTest}.\n  */\n-class CartesianValueArgumentsProvider implements Consumer<CartesianValueSource> {\n+class CartesianValueArgumentsProvider implements Consumer<CartesianValueSource>, ArgumentsProvider {\n \n \tprivate Object[] arguments;\n \n \t@Override\n \tpublic void accept(CartesianValueSource source) {\n \t\t// @formatter:off\n \t\tList<Object> arrays =\n-\t\t\t\t// Declaration of <Object> is necessary due to a bug in Eclipse Photon.\n-\t\t\t\tStream.<Object> of(\n+\t\t\t\tStream.of(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDg1Mw=="}, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzMwMTY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTo0NDo1M1rOH5WYjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTo0NDo1M1rOH5WYjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NzYxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tcatch (Exception e) {\n          \n          \n            \n            \t\t\tthrow new ExtensionConfigurationException(\"Could not provide arguments because of exception.\", e);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tcatch (Exception ex) {\n          \n          \n            \n            \t\t\tthrow new ExtensionConfigurationException(\"Could not provide arguments because of exception.\", ex);\n          \n          \n            \n            \t\t}", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529897613", "createdAt": "2020-11-24T21:44:53Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -94,17 +102,50 @@ private static void ensureNoInputConflicts(CartesianProductTest annotation,\n \t\treturn sets;\n \t}\n \n-\tprivate List<List<?>> getSetsFromRepeatableAnnotation(List<CartesianValueSource> valueSources) {\n+\tprivate List<List<?>> getSetsFromArgumentsSources(List<? extends Annotation> argumentsSources,\n+\t\t\tExtensionContext context) {\n \t\tList<List<?>> sets = new ArrayList<>();\n-\t\tfor (CartesianValueSource source : valueSources) {\n-\t\t\tCartesianValueArgumentsProvider provider = new CartesianValueArgumentsProvider();\n-\t\t\tprovider.accept(source);\n-\t\t\tList<Object> collect = provider.provideArguments().distinct().collect(toList());\n-\t\t\tsets.add(collect);\n+\t\tfor (Annotation source : argumentsSources) {\n+\t\t\tsets.add(getSetFromAnnotation(context, source));\n \t\t}\n \t\treturn sets;\n \t}\n \n+\tprivate List<Object> getSetFromAnnotation(ExtensionContext context, Annotation source) {\n+\t\ttry {\n+\t\t\tArgumentsProvider provider = initializeArgumentsProvider(source);\n+\t\t\treturn provideArguments(context, source, provider);\n+\t\t}\n+\t\tcatch (Exception e) {\n+\t\t\tthrow new ExtensionConfigurationException(\"Could not provide arguments because of exception.\", e);\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzMxNjYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTo0OTowNVrOH5Whqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwODowNToyOFrOIBMJFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5OTk0Nw==", "bodyText": "Is Annotation source a ...Rangesource? If so, can you rename the variable(s) accordingly?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529899947", "createdAt": "2020-11-24T21:49:05Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -94,17 +102,50 @@ private static void ensureNoInputConflicts(CartesianProductTest annotation,\n \t\treturn sets;\n \t}\n \n-\tprivate List<List<?>> getSetsFromRepeatableAnnotation(List<CartesianValueSource> valueSources) {\n+\tprivate List<List<?>> getSetsFromArgumentsSources(List<? extends Annotation> argumentsSources,\n+\t\t\tExtensionContext context) {\n \t\tList<List<?>> sets = new ArrayList<>();\n-\t\tfor (CartesianValueSource source : valueSources) {\n-\t\t\tCartesianValueArgumentsProvider provider = new CartesianValueArgumentsProvider();\n-\t\t\tprovider.accept(source);\n-\t\t\tList<Object> collect = provider.provideArguments().distinct().collect(toList());\n-\t\t\tsets.add(collect);\n+\t\tfor (Annotation source : argumentsSources) {\n+\t\t\tsets.add(getSetFromAnnotation(context, source));\n \t\t}\n \t\treturn sets;\n \t}\n \n+\tprivate List<Object> getSetFromAnnotation(ExtensionContext context, Annotation source) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkxMjQ4NQ==", "bodyText": "Not a RangeSource - it is an Annotation that is itself annotated with @ArgumentsSource.\nIt works like this (basically copying ParameterizedTest, btw):\n\nYour test is a CartesianProductTest\nThis test has annotations on it that are annotated with @ArgumentsSource\nThe @ArgumentsSource defines an ArgumentsProvider (class) that must implement AnnotationConsumer<A extends Annotation> (in our case this should be CartesianAnnotationConsumer instead)\nWe instantiate the ArgumentsProvider (must have no-args constructor)\nWe call the ArgumentsProvider#accept(Annotation) method with the original annotation\nWe call ArgumentsProvider#provideArguments(ExtensionContext context)\n\nEasy-peasy, right?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r530912485", "createdAt": "2020-11-26T10:05:49Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -94,17 +102,50 @@ private static void ensureNoInputConflicts(CartesianProductTest annotation,\n \t\treturn sets;\n \t}\n \n-\tprivate List<List<?>> getSetsFromRepeatableAnnotation(List<CartesianValueSource> valueSources) {\n+\tprivate List<List<?>> getSetsFromArgumentsSources(List<? extends Annotation> argumentsSources,\n+\t\t\tExtensionContext context) {\n \t\tList<List<?>> sets = new ArrayList<>();\n-\t\tfor (CartesianValueSource source : valueSources) {\n-\t\t\tCartesianValueArgumentsProvider provider = new CartesianValueArgumentsProvider();\n-\t\t\tprovider.accept(source);\n-\t\t\tList<Object> collect = provider.provideArguments().distinct().collect(toList());\n-\t\t\tsets.add(collect);\n+\t\tfor (Annotation source : argumentsSources) {\n+\t\t\tsets.add(getSetFromAnnotation(context, source));\n \t\t}\n \t\treturn sets;\n \t}\n \n+\tprivate List<Object> getSetFromAnnotation(ExtensionContext context, Annotation source) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5OTk0Nw=="}, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODExODQyMQ==", "bodyText": "After re-reading this >7 day later, I feel like I need to demonstrate with an example:\n@ArgumentsSource(ExampleArgumentsProvider.class)\n@interface ExampleSourceAnnotation {\n   int intValue();\n}\n\nclass ExampleArgumentsProvider implements ArgumentsProvider, CartesianAnnotationConsumer<ExampleSourceAnnotation> {\n  int i;\n\n  void accept(ExampleSourceAnnotation annotation) {\n    /* do something with intValue() */\n    i = annotation.intValue();\n  }\n\n  Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n    /* `accept` was already called so `i` should have a value */\n    return Stream.of(Arguments.of(i));\n  }\n}\nSo, if we have a CartesianProductTest, annotated with ExampleSourceAnnotation, we store the annotation, instantiate ExampleArgumentsProvider (with no-arg constructor), 'feed it' the ExampleSourceAnnotation and call provideArguments to get the set for our test.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r538118421", "createdAt": "2020-12-08T08:05:28Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -94,17 +102,50 @@ private static void ensureNoInputConflicts(CartesianProductTest annotation,\n \t\treturn sets;\n \t}\n \n-\tprivate List<List<?>> getSetsFromRepeatableAnnotation(List<CartesianValueSource> valueSources) {\n+\tprivate List<List<?>> getSetsFromArgumentsSources(List<? extends Annotation> argumentsSources,\n+\t\t\tExtensionContext context) {\n \t\tList<List<?>> sets = new ArrayList<>();\n-\t\tfor (CartesianValueSource source : valueSources) {\n-\t\t\tCartesianValueArgumentsProvider provider = new CartesianValueArgumentsProvider();\n-\t\t\tprovider.accept(source);\n-\t\t\tList<Object> collect = provider.provideArguments().distinct().collect(toList());\n-\t\t\tsets.add(collect);\n+\t\tfor (Annotation source : argumentsSources) {\n+\t\t\tsets.add(getSetFromAnnotation(context, source));\n \t\t}\n \t\treturn sets;\n \t}\n \n+\tprivate List<Object> getSetFromAnnotation(ExtensionContext context, Annotation source) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5OTk0Nw=="}, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzM0ODE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTo1NDowMFrOH5W2WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNDoxODozMFrOH6dQXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwNTI0MA==", "bodyText": "This should be...\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (Arrays.asList(provider.getClass().getInterfaces()).contains(Consumer.class)) {\n          \n          \n            \n            \t\tif (provider instanceof Consumer) {\n          \n      \n    \n    \n  \n\n... but, it's not? (One test fails after the change.)", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529905240", "createdAt": "2020-11-24T21:54:00Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -94,17 +102,50 @@ private static void ensureNoInputConflicts(CartesianProductTest annotation,\n \t\treturn sets;\n \t}\n \n-\tprivate List<List<?>> getSetsFromRepeatableAnnotation(List<CartesianValueSource> valueSources) {\n+\tprivate List<List<?>> getSetsFromArgumentsSources(List<? extends Annotation> argumentsSources,\n+\t\t\tExtensionContext context) {\n \t\tList<List<?>> sets = new ArrayList<>();\n-\t\tfor (CartesianValueSource source : valueSources) {\n-\t\t\tCartesianValueArgumentsProvider provider = new CartesianValueArgumentsProvider();\n-\t\t\tprovider.accept(source);\n-\t\t\tList<Object> collect = provider.provideArguments().distinct().collect(toList());\n-\t\t\tsets.add(collect);\n+\t\tfor (Annotation source : argumentsSources) {\n+\t\t\tsets.add(getSetFromAnnotation(context, source));\n \t\t}\n \t\treturn sets;\n \t}\n \n+\tprivate List<Object> getSetFromAnnotation(ExtensionContext context, Annotation source) {\n+\t\ttry {\n+\t\t\tArgumentsProvider provider = initializeArgumentsProvider(source);\n+\t\t\treturn provideArguments(context, source, provider);\n+\t\t}\n+\t\tcatch (Exception e) {\n+\t\t\tthrow new ExtensionConfigurationException(\"Could not provide arguments because of exception.\", e);\n+\t\t}\n+\t}\n+\n+\tprivate ArgumentsProvider initializeArgumentsProvider(Annotation source) {\n+\t\tArgumentsSource providerAnnotation = AnnotationSupport\n+\t\t\t\t.findAnnotation(source.annotationType(), ArgumentsSource.class)\n+\t\t\t\t// never happens, we already know these annotations are annotated with @ArgumentsSource\n+\t\t\t\t.orElseThrow(() -> new PreconditionViolationException(format(\n+\t\t\t\t\t\"%s was not annotated with @ArgumentsSource but should have been.\", source.annotationType())));\n+\t\treturn ReflectionSupport.newInstance(providerAnnotation.value());\n+\t}\n+\n+\tprivate List<Object> provideArguments(ExtensionContext context, Annotation source, ArgumentsProvider provider)\n+\t\t\tthrows Exception {\n+\t\tif (Arrays.asList(provider.getClass().getInterfaces()).contains(Consumer.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1ODc4Mw==", "bodyText": "ArgumentsProviders used by annotations belonging to JUnit's @ParameterizedTest (e.g.: @ValueSource) implement Consumer through AnnotationConsumer. We will fix this with defining CartesianAnnotationConsumer.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r531058783", "createdAt": "2020-11-26T14:18:30Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -94,17 +102,50 @@ private static void ensureNoInputConflicts(CartesianProductTest annotation,\n \t\treturn sets;\n \t}\n \n-\tprivate List<List<?>> getSetsFromRepeatableAnnotation(List<CartesianValueSource> valueSources) {\n+\tprivate List<List<?>> getSetsFromArgumentsSources(List<? extends Annotation> argumentsSources,\n+\t\t\tExtensionContext context) {\n \t\tList<List<?>> sets = new ArrayList<>();\n-\t\tfor (CartesianValueSource source : valueSources) {\n-\t\t\tCartesianValueArgumentsProvider provider = new CartesianValueArgumentsProvider();\n-\t\t\tprovider.accept(source);\n-\t\t\tList<Object> collect = provider.provideArguments().distinct().collect(toList());\n-\t\t\tsets.add(collect);\n+\t\tfor (Annotation source : argumentsSources) {\n+\t\t\tsets.add(getSetFromAnnotation(context, source));\n \t\t}\n \t\treturn sets;\n \t}\n \n+\tprivate List<Object> getSetFromAnnotation(ExtensionContext context, Annotation source) {\n+\t\ttry {\n+\t\t\tArgumentsProvider provider = initializeArgumentsProvider(source);\n+\t\t\treturn provideArguments(context, source, provider);\n+\t\t}\n+\t\tcatch (Exception e) {\n+\t\t\tthrow new ExtensionConfigurationException(\"Could not provide arguments because of exception.\", e);\n+\t\t}\n+\t}\n+\n+\tprivate ArgumentsProvider initializeArgumentsProvider(Annotation source) {\n+\t\tArgumentsSource providerAnnotation = AnnotationSupport\n+\t\t\t\t.findAnnotation(source.annotationType(), ArgumentsSource.class)\n+\t\t\t\t// never happens, we already know these annotations are annotated with @ArgumentsSource\n+\t\t\t\t.orElseThrow(() -> new PreconditionViolationException(format(\n+\t\t\t\t\t\"%s was not annotated with @ArgumentsSource but should have been.\", source.annotationType())));\n+\t\treturn ReflectionSupport.newInstance(providerAnnotation.value());\n+\t}\n+\n+\tprivate List<Object> provideArguments(ExtensionContext context, Annotation source, ArgumentsProvider provider)\n+\t\t\tthrows Exception {\n+\t\tif (Arrays.asList(provider.getClass().getInterfaces()).contains(Consumer.class)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwNTI0MA=="}, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzM1MjU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTo1NDozOFrOH5W5Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTo1NDozOFrOH5W5Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwNTk4Mw==", "bodyText": "Note to self: Take a close look at this when you're more awake. :)", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r529905983", "createdAt": "2020-11-24T21:54:38Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -94,17 +102,50 @@ private static void ensureNoInputConflicts(CartesianProductTest annotation,\n \t\treturn sets;\n \t}\n \n-\tprivate List<List<?>> getSetsFromRepeatableAnnotation(List<CartesianValueSource> valueSources) {\n+\tprivate List<List<?>> getSetsFromArgumentsSources(List<? extends Annotation> argumentsSources,\n+\t\t\tExtensionContext context) {\n \t\tList<List<?>> sets = new ArrayList<>();\n-\t\tfor (CartesianValueSource source : valueSources) {\n-\t\t\tCartesianValueArgumentsProvider provider = new CartesianValueArgumentsProvider();\n-\t\t\tprovider.accept(source);\n-\t\t\tList<Object> collect = provider.provideArguments().distinct().collect(toList());\n-\t\t\tsets.add(collect);\n+\t\tfor (Annotation source : argumentsSources) {\n+\t\t\tsets.add(getSetFromAnnotation(context, source));\n \t\t}\n \t\treturn sets;\n \t}\n \n+\tprivate List<Object> getSetFromAnnotation(ExtensionContext context, Annotation source) {\n+\t\ttry {\n+\t\t\tArgumentsProvider provider = initializeArgumentsProvider(source);\n+\t\t\treturn provideArguments(context, source, provider);\n+\t\t}\n+\t\tcatch (Exception e) {\n+\t\t\tthrow new ExtensionConfigurationException(\"Could not provide arguments because of exception.\", e);\n+\t\t}\n+\t}\n+\n+\tprivate ArgumentsProvider initializeArgumentsProvider(Annotation source) {\n+\t\tArgumentsSource providerAnnotation = AnnotationSupport\n+\t\t\t\t.findAnnotation(source.annotationType(), ArgumentsSource.class)\n+\t\t\t\t// never happens, we already know these annotations are annotated with @ArgumentsSource\n+\t\t\t\t.orElseThrow(() -> new PreconditionViolationException(format(\n+\t\t\t\t\t\"%s was not annotated with @ArgumentsSource but should have been.\", source.annotationType())));\n+\t\treturn ReflectionSupport.newInstance(providerAnnotation.value());\n+\t}\n+\n+\tprivate List<Object> provideArguments(ExtensionContext context, Annotation source, ArgumentsProvider provider)\n+\t\t\tthrows Exception {\n+\t\tif (Arrays.asList(provider.getClass().getInterfaces()).contains(Consumer.class)) {\n+\t\t\t((Consumer<Annotation>) provider).accept(source);\n+\t\t\treturn provider\n+\t\t\t\t\t.provideArguments(context)\n+\t\t\t\t\t.map(Arguments::get)\n+\t\t\t\t\t.flatMap(Arrays::stream)\n+\t\t\t\t\t.distinct()\n+\t\t\t\t\t.collect(toList());\n+\t\t} else {\n+\t\t\tthrow new PreconditionViolationException(\n+\t\t\t\tformat(\"%s does not implement the Consumer<T> interface.\", provider.getClass()));\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ef6d0e6d307246a54747055866f12973d9971c"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTgyNDY4OnYy", "diffSide": "RIGHT", "path": "docs/cartesian-product.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMTo0Mjo0MlrOH_jCiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo0MTo1NVrOIA3icQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NjQyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Just like with `@CartesianValueSource` annotations get assigned to parameters in order.\n          \n          \n            \n            Just like with `@CartesianValueSource`, annotations get assigned to parameters in order.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r536396424", "createdAt": "2020-12-04T21:42:42Z", "author": {"login": "scordio"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -119,6 +119,53 @@ To demonstrate with a table:\n | 6th test  | 4                 | \"B\"\n |===\n \n+Alternatively, you can annotate your test method with link:range-sources.adoc[range source annotations].\n+For _this purpose only_, range sources are repeatable.\n+When you annotate your `@CartesianProductTest` with a range source, you specify the inputs to a single test parameter.\n+This is _not_ like `@ParameterizedTest` where you have to define all inputs in a single `@ArgumentsSource`.\n+\n+[source,java]\n+----\n+@CartesianProductTest\n+@ShortRangeSource(from = 1, to = 3, step = 1)\n+@LongRangeSource(from = 0L, to = 2L, step = 1, closed = true)\n+void testShortAndLong(short s, long l) {\n+\t// passing test code\n+}\n+----\n+\n+Just like with `@CartesianValueSource` annotations get assigned to parameters in order.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44daf751369eac90fff57276f6ff9c1d70e89201"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4MDg0OQ==", "bodyText": "Fixed. \ud83d\udc4d", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r537780849", "createdAt": "2020-12-07T19:41:55Z", "author": {"login": "Michael1993"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -119,6 +119,53 @@ To demonstrate with a table:\n | 6th test  | 4                 | \"B\"\n |===\n \n+Alternatively, you can annotate your test method with link:range-sources.adoc[range source annotations].\n+For _this purpose only_, range sources are repeatable.\n+When you annotate your `@CartesianProductTest` with a range source, you specify the inputs to a single test parameter.\n+This is _not_ like `@ParameterizedTest` where you have to define all inputs in a single `@ArgumentsSource`.\n+\n+[source,java]\n+----\n+@CartesianProductTest\n+@ShortRangeSource(from = 1, to = 3, step = 1)\n+@LongRangeSource(from = 0L, to = 2L, step = 1, closed = true)\n+void testShortAndLong(short s, long l) {\n+\t// passing test code\n+}\n+----\n+\n+Just like with `@CartesianValueSource` annotations get assigned to parameters in order.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NjQyNA=="}, "originalCommit": {"oid": "44daf751369eac90fff57276f6ff9c1d70e89201"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTkwMjA2OnYy", "diffSide": "RIGHT", "path": "docs/cartesian-product.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMjowMDoyNVrOH_jyrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo0MjoxNVrOIA3jZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwODc0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t// .addAll(letters).add(\"Alpha\", \"Omega\")\n          \n          \n            \n            \t\t// .addAll(letters)\n          \n          \n            \n            \t\t.add(\"Alpha\", \"Omega\")", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r536408748", "createdAt": "2020-12-04T22:00:25Z", "author": {"login": "scordio"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -138,8 +185,7 @@ static CartesianProductTest.Sets nFold() {\n \treturn new CartesianProductTest.Sets()\n \t\t// e.g. with a `List<String> letters`,\n \t\t// you can use `addAll`:\n-\t\t// .addAll(letters)\n-\t\t.add(\"Alpha\", \"Omega\")\n+\t\t// .addAll(letters).add(\"Alpha\", \"Omega\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44daf751369eac90fff57276f6ff9c1d70e89201"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4MTA5NQ==", "bodyText": "Good catch! \ud83d\udc4d\nFixed.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r537781095", "createdAt": "2020-12-07T19:42:15Z", "author": {"login": "Michael1993"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -138,8 +185,7 @@ static CartesianProductTest.Sets nFold() {\n \treturn new CartesianProductTest.Sets()\n \t\t// e.g. with a `List<String> letters`,\n \t\t// you can use `addAll`:\n-\t\t// .addAll(letters)\n-\t\t.add(\"Alpha\", \"Omega\")\n+\t\t// .addAll(letters).add(\"Alpha\", \"Omega\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwODc0OA=="}, "originalCommit": {"oid": "44daf751369eac90fff57276f6ff9c1d70e89201"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MjMyNjExOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/params/RangeSourceArgumentsProvider.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMDowMzozOVrOIKHsXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxOToyMDowOFrOISQgIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4MjcxNw==", "bodyText": "Will this find meta-annotations? I doubt it would. Does this make sense?\n@IntRangeSource(from = 0, to = 10)\npublic @interface FromZeroToTen { }\n\n@CartesianProductTest\n@FromZeroToTen\nvoid test(int i) {\n}\nIf it does, we need to make sure that we find such annotations. Please use/extend org.junitpioneer.jupiter.params.PioneerAnnotationUtils if it's suitable - as painful as that may be.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r547482717", "createdAt": "2020-12-22T20:03:39Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/params/RangeSourceArgumentsProvider.java", "diffHunk": "@@ -41,20 +44,34 @@\n  * @see DoubleRangeSource\n  * @see FloatRangeSource\n  */\n-class RangeSourceArgumentsProvider implements ArgumentsProvider {\n+class RangeSourceArgumentsProvider implements ArgumentsProvider, CartesianAnnotationConsumer<Annotation> {\n+\n+\tprivate Annotation argumentsSource;\n \n \t@Override\n \tpublic Stream<? extends Arguments> provideArguments(ExtensionContext context) throws Exception {\n \t\t// since it's a method annotation, the element will always be present\n-\t\tList<Annotation> argumentsSources = context\n-\t\t\t\t.getElement()\n-\t\t\t\t.map(method -> Arrays\n-\t\t\t\t\t\t.stream(method.getAnnotations())\n-\t\t\t\t\t\t.filter(annotations -> Arrays\n-\t\t\t\t\t\t\t\t.stream(annotations.annotationType().getAnnotationsByType(ArgumentsSource.class))\n-\t\t\t\t\t\t\t\t.anyMatch(annotation -> getClass().equals(annotation.value())))\n-\t\t\t\t\t\t.collect(Collectors.toList()))\n-\t\t\t\t.orElseThrow(IllegalStateException::new);\n+\t\tif (argumentsSource == null)\n+\t\t\tinitArgumentsSource(context);\n+\t\tClass<? extends Annotation> argumentsSourceClass = argumentsSource.annotationType();\n+\t\tClass<? extends Range> rangeClass = argumentsSourceClass.getAnnotation(RangeClass.class).value();\n+\n+\t\tRange<?> range = (Range<?>) rangeClass.getConstructors()[0].newInstance(argumentsSource);\n+\t\trange.validate();\n+\t\treturn asStream(range).map(Arguments::of);\n+\t}\n+\n+\tprivate void initArgumentsSource(ExtensionContext context) {\n+\t\t// since it's a method annotation, the element will always be present\n+\t\tAnnotatedElement element = context.getElement().orElseThrow(IllegalStateException::new);\n+\n+\t\tverifyNoContainerAnnotationIsPresent(element);\n+\t\tList<Annotation> argumentsSources = Stream\n+\t\t\t\t.of(element.getAnnotations())\n+\t\t\t\t.filter(annotations -> Arrays\n+\t\t\t\t\t\t.stream(annotations.annotationType().getAnnotationsByType(ArgumentsSource.class))\n+\t\t\t\t\t\t.anyMatch(annotation -> getClass().equals(annotation.value())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018ee0cb06802e19652e50f4914f3b7cd0907727"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg3MzcwOA==", "bodyText": "All range sources have @Target(ElementType.METHOD) on them. No meta-annotations can exist. If you want, I can update this in a separate PR later, because this one is getting really bloated.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r548873708", "createdAt": "2020-12-25T13:37:15Z", "author": {"login": "Michael1993"}, "path": "src/main/java/org/junitpioneer/jupiter/params/RangeSourceArgumentsProvider.java", "diffHunk": "@@ -41,20 +44,34 @@\n  * @see DoubleRangeSource\n  * @see FloatRangeSource\n  */\n-class RangeSourceArgumentsProvider implements ArgumentsProvider {\n+class RangeSourceArgumentsProvider implements ArgumentsProvider, CartesianAnnotationConsumer<Annotation> {\n+\n+\tprivate Annotation argumentsSource;\n \n \t@Override\n \tpublic Stream<? extends Arguments> provideArguments(ExtensionContext context) throws Exception {\n \t\t// since it's a method annotation, the element will always be present\n-\t\tList<Annotation> argumentsSources = context\n-\t\t\t\t.getElement()\n-\t\t\t\t.map(method -> Arrays\n-\t\t\t\t\t\t.stream(method.getAnnotations())\n-\t\t\t\t\t\t.filter(annotations -> Arrays\n-\t\t\t\t\t\t\t\t.stream(annotations.annotationType().getAnnotationsByType(ArgumentsSource.class))\n-\t\t\t\t\t\t\t\t.anyMatch(annotation -> getClass().equals(annotation.value())))\n-\t\t\t\t\t\t.collect(Collectors.toList()))\n-\t\t\t\t.orElseThrow(IllegalStateException::new);\n+\t\tif (argumentsSource == null)\n+\t\t\tinitArgumentsSource(context);\n+\t\tClass<? extends Annotation> argumentsSourceClass = argumentsSource.annotationType();\n+\t\tClass<? extends Range> rangeClass = argumentsSourceClass.getAnnotation(RangeClass.class).value();\n+\n+\t\tRange<?> range = (Range<?>) rangeClass.getConstructors()[0].newInstance(argumentsSource);\n+\t\trange.validate();\n+\t\treturn asStream(range).map(Arguments::of);\n+\t}\n+\n+\tprivate void initArgumentsSource(ExtensionContext context) {\n+\t\t// since it's a method annotation, the element will always be present\n+\t\tAnnotatedElement element = context.getElement().orElseThrow(IllegalStateException::new);\n+\n+\t\tverifyNoContainerAnnotationIsPresent(element);\n+\t\tList<Annotation> argumentsSources = Stream\n+\t\t\t\t.of(element.getAnnotations())\n+\t\t\t\t.filter(annotations -> Arrays\n+\t\t\t\t\t\t.stream(annotations.annotationType().getAnnotationsByType(ArgumentsSource.class))\n+\t\t\t\t\t\t.anyMatch(annotation -> getClass().equals(annotation.value())))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4MjcxNw=="}, "originalCommit": {"oid": "018ee0cb06802e19652e50f4914f3b7cd0907727"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjAxNTY1MA==", "bodyText": "True. We should probably discuss on an issue first whether this makes sense.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r556015650", "createdAt": "2021-01-12T19:20:08Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/params/RangeSourceArgumentsProvider.java", "diffHunk": "@@ -41,20 +44,34 @@\n  * @see DoubleRangeSource\n  * @see FloatRangeSource\n  */\n-class RangeSourceArgumentsProvider implements ArgumentsProvider {\n+class RangeSourceArgumentsProvider implements ArgumentsProvider, CartesianAnnotationConsumer<Annotation> {\n+\n+\tprivate Annotation argumentsSource;\n \n \t@Override\n \tpublic Stream<? extends Arguments> provideArguments(ExtensionContext context) throws Exception {\n \t\t// since it's a method annotation, the element will always be present\n-\t\tList<Annotation> argumentsSources = context\n-\t\t\t\t.getElement()\n-\t\t\t\t.map(method -> Arrays\n-\t\t\t\t\t\t.stream(method.getAnnotations())\n-\t\t\t\t\t\t.filter(annotations -> Arrays\n-\t\t\t\t\t\t\t\t.stream(annotations.annotationType().getAnnotationsByType(ArgumentsSource.class))\n-\t\t\t\t\t\t\t\t.anyMatch(annotation -> getClass().equals(annotation.value())))\n-\t\t\t\t\t\t.collect(Collectors.toList()))\n-\t\t\t\t.orElseThrow(IllegalStateException::new);\n+\t\tif (argumentsSource == null)\n+\t\t\tinitArgumentsSource(context);\n+\t\tClass<? extends Annotation> argumentsSourceClass = argumentsSource.annotationType();\n+\t\tClass<? extends Range> rangeClass = argumentsSourceClass.getAnnotation(RangeClass.class).value();\n+\n+\t\tRange<?> range = (Range<?>) rangeClass.getConstructors()[0].newInstance(argumentsSource);\n+\t\trange.validate();\n+\t\treturn asStream(range).map(Arguments::of);\n+\t}\n+\n+\tprivate void initArgumentsSource(ExtensionContext context) {\n+\t\t// since it's a method annotation, the element will always be present\n+\t\tAnnotatedElement element = context.getElement().orElseThrow(IllegalStateException::new);\n+\n+\t\tverifyNoContainerAnnotationIsPresent(element);\n+\t\tList<Annotation> argumentsSources = Stream\n+\t\t\t\t.of(element.getAnnotations())\n+\t\t\t\t.filter(annotations -> Arrays\n+\t\t\t\t\t\t.stream(annotations.annotationType().getAnnotationsByType(ArgumentsSource.class))\n+\t\t\t\t\t\t.anyMatch(annotation -> getClass().equals(annotation.value())))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4MjcxNw=="}, "originalCommit": {"oid": "018ee0cb06802e19652e50f4914f3b7cd0907727"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MjM0Mzg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/junitpioneer/jupiter/params/RangeSourceArgumentsProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMDowOTo1MFrOIKH2jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMDowOTo1MFrOIKH2jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4NTMyNg==", "bodyText": "I just saw this code in PioneerAnnotationUtils, no need to repeat it here. Just expose there and add (reflectively) to the params variant.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r547485326", "createdAt": "2020-12-22T20:09:50Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/params/RangeSourceArgumentsProvider.java", "diffHunk": "@@ -63,17 +80,36 @@\n \t\t\tthrow new IllegalArgumentException(message);\n \t\t}\n \n-\t\tAnnotation argumentsSource = argumentsSources.get(0);\n-\t\tClass<? extends Annotation> argumentsSourceClass = argumentsSource.annotationType();\n-\t\tClass<? extends Range> rangeClass = argumentsSourceClass.getAnnotation(RangeClass.class).value();\n+\t\targumentsSource = argumentsSources.get(0);\n+\t}\n \n-\t\tRange<?> range = (Range) rangeClass.getConstructors()[0].newInstance(argumentsSource);\n-\t\trange.validate();\n-\t\treturn asStream(range).map(Arguments::of);\n+\tprivate void verifyNoContainerAnnotationIsPresent(AnnotatedElement element) {\n+\t\tif (Stream.of(element.getAnnotations()).anyMatch(this::isContainerAnnotation))\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"Range source annotation should not be repeated for @ParameterizedTest. @ParameterizedTest should have exactly one argument source.\");\n+\t}\n+\n+\tprivate boolean isContainerAnnotation(Annotation annotation) {\n+\t\t// See https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.3\n+\t\treturn Stream\n+\t\t\t\t.of(annotation.annotationType().getMethods())\n+\t\t\t\t.anyMatch(method -> method.getName().equals(\"value\") && method.getReturnType().isArray()\n+\t\t\t\t\t\t&& method.getReturnType().getComponentType().isAnnotation()\n+\t\t\t\t\t\t&& declaresContainer(method.getReturnType().getComponentType(), annotation));\n \t}\n \n-\tprivate Stream<?> asStream(Range r) {\n+\tprivate static boolean declaresContainer(Class<?> componentType, Annotation annotation) {\n+\t\tRepeatable repeatable = componentType.getAnnotation(Repeatable.class);\n+\t\treturn repeatable != null && repeatable.value().equals(annotation.annotationType());\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018ee0cb06802e19652e50f4914f3b7cd0907727"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MjM1MDExOnYy", "diffSide": "RIGHT", "path": "docs/cartesian-product.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMDoxMjoxNlrOIKH6PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMDoxMjoxNlrOIKH6PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4NjI2OA==", "bodyText": "Please document how to create ArgumentsProvider (as promised in CartesianAnnotationConsumer).", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/362#discussion_r547486268", "createdAt": "2020-12-22T20:12:16Z", "author": {"login": "nipafx"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -119,6 +119,53 @@ To demonstrate with a table:\n | 6th test  | 4                 | \"B\"\n |===\n \n+Alternatively, you can annotate your test method with link:range-sources.adoc[range source annotations].\n+For _this purpose only_, range sources are repeatable.\n+When you annotate your `@CartesianProductTest` with a range source, you specify the inputs to a single test parameter.\n+This is _not_ like `@ParameterizedTest` where you have to define all inputs in a single `@ArgumentsSource`.\n+\n+[source,java]\n+----\n+@CartesianProductTest\n+@ShortRangeSource(from = 1, to = 3, step = 1)\n+@LongRangeSource(from = 0L, to = 2L, step = 1, closed = true)\n+void testShortAndLong(short s, long l) {\n+\t// passing test code\n+}\n+----\n+\n+Just like with `@CartesianValueSource`, annotations get assigned to parameters in order.\n+The first annotation from the top gets assigned to the first parameter, the second annotation to the second parameter and so on.\n+\n+The test `testShortAndLong` is executed exactly six times.\n+The first parameter can have any of the two values `1`, `2`.\n+The second parameter can have any of the three values `0L`, `1L` or `2L`.\n+`@CartesianProductTest` tests for all input combinations, that's `2 \u00d7 3`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `s` | value of `l`\n+| 1st test  | 1            | 0L\n+| 2nd test  | 1            | 1L\n+| 3rd test  | 1            | 2L\n+| 4th test  | 2            | 0L\n+| 5th test  | 2            | 1L\n+| 6th test  | 2            | 2L\n+|===\n+\n+For more information, please see the link:range-sources.adoc[separate documentation about range sources].\n+You can combine range sources with `@CartesianValueSource`, it works as you'd expect:\n+\n+[source, java]\n+----\n+@CartesianProductTest\n+@ShortRangeSource(from = 1, to = 3)\n+@CartesianValueSource(strings = { \"text one\", \"text two\" })\n+void mixAndMatchTest(short number, String text) {\n+\t// passing test code\n+}\n+----\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018ee0cb06802e19652e50f4914f3b7cd0907727"}, "originalPosition": 70}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4152, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}