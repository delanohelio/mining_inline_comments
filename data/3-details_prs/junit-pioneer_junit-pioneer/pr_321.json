{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4MDY5NTg1", "number": 321, "title": "CartesianProductTestExtension from JUnit examples", "bodyText": "Opened to let us move forward with #68\n\nPR checklist\nThe following checklist shall help the PR's author, the reviewers and maintainers to ensure the quality of this project.\nIt is based on our contributors guidelines, especially the \"writing code\" section.\nIt shall help to check for completion of the listed points.\nIf a point does not apply to the given PR's changes, the corresponding entry can be simply marked as done.\nDocumentation (general)\n\n There is documentation (Javadoc and site documentation; added or updated)\n There is implementation information to describe why a non-obvious source code / solution got implemented\n Site documentation has its own .adoc file in the docs folder, e.g. docs/report-entries.adoc\n Only one sentence per line (especially in .adoc files)\n Javadoc uses formal style, while sites documentation may use informal style (see #265)\n\nDocumentation (new extension)\n\n The docs/docs-nav.yml navigation has an entry for the new extension\n The package-info.java contains information about the new extension\n\nCode\n\n Code adheres to code style, naming conventions etc.\n Successful tests cover all changes\n There are checks which validate correct / false usage / configuration of a functionality and there are tests to verify those checks (see #164)\n Tests use AssertJ or our own PioneerAssert (which are based on AssertJ)\n\nContributing\n\n A prepared commit message exists\n The list of contributions inside README.md mentions the new contribution (real name optional)\n\n\nI hereby agree to the terms of the JUnit Pioneer Contributor License Agreement.", "createdAt": "2020-08-14T16:16:56Z", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321", "merged": true, "mergeCommit": {"oid": "9eb8e265fe180627ec110f8e6f75b9770d182a7f"}, "closed": true, "closedAt": "2020-10-06T18:48:06Z", "author": {"login": "Michael1993"}, "timelineItems": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6PJ9wgH2gAyNDY4MDY5NTg1OmJiZGU0ODRjNGQxN2FjOTY1ZmIyNTZkODAxZjhjNWJjM2Y3ZjcwNzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdP86_NAH2gAyNDY4MDY5NTg1OjZjMGJlOTEwZmMxY2ZkMDdmY2RkZDM4YzhlM2MyZTdmMDNlZDkxYTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bbde484c4d17ac965fb256d801f8c5bc3f7f7078", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/bbde484c4d17ac965fb256d801f8c5bc3f7f7078", "committedDate": "2020-07-31T07:33:09Z", "message": "WIP\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0df73816b69ae2e9eb8d47794c3fa93a5d23b4b2", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0df73816b69ae2e9eb8d47794c3fa93a5d23b4b2", "committedDate": "2020-08-14T12:46:38Z", "message": "Initial commit - copied sources from JUnit 5 examples.\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8ceb12666aefa67231e7bddac437309b5623f98", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/e8ceb12666aefa67231e7bddac437309b5623f98", "committedDate": "2020-08-14T16:14:44Z", "message": "Some more tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb0f012c79607aee5ab0bb3748caad98a9915b1e", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/bb0f012c79607aee5ab0bb3748caad98a9915b1e", "committedDate": "2020-08-14T16:15:40Z", "message": "spotless\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edbf0fd89c684880ac2bc92c19933653bbe8d994", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/edbf0fd89c684880ac2bc92c19933653bbe8d994", "committedDate": "2020-08-14T16:56:56Z", "message": "WIP config tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd8d33aa312c85d71f8594139980ca124bccdeea", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/dd8d33aa312c85d71f8594139980ca124bccdeea", "committedDate": "2020-08-14T16:58:11Z", "message": "Merge branch 'master' into issue/68-cartesian-product-extension"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c04e10b6fd059c826369639bc081461dff9f48e", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/8c04e10b6fd059c826369639bc081461dff9f48e", "committedDate": "2020-08-14T20:26:55Z", "message": "More tests and an ugly new utility method\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5f0b28f6d1d8368bb7dce08cf1d7ed1b8163c85", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c5f0b28f6d1d8368bb7dce08cf1d7ed1b8163c85", "committedDate": "2020-08-14T22:52:24Z", "message": "Added docs and more tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c18b6c2a6ced73af067de99cc0945ce78e499bb8", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c18b6c2a6ced73af067de99cc0945ce78e499bb8", "committedDate": "2020-08-14T23:14:30Z", "message": "Added some javadoc (also spotless)\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/698ac4bf39168ad9b31f8e961daea5f14c21e6e7", "committedDate": "2020-08-15T13:30:31Z", "message": "added `factory()` for specifying static factory name, refactored documentation\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDQ5MjA5", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#pullrequestreview-468049209", "createdAt": "2020-08-16T09:39:01Z", "commit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQwOTozOTowMVrOHBRDxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxMDoxNToxNVrOHBRRgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDExNw==", "bodyText": "There's no example for this factory() annotation parameter. It is mentions some times in the docs but nowhere to see.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471090117", "createdAt": "2020-08-16T09:39:01Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,122 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+[#_static-factory-example]\n+```java", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDM1NQ==", "bodyText": "Which method is meant by \"this\"? The method which provides the values or the test method? A sub headline would help to catch up the reader after this (long but relevant) example and get him back on track. I had to read it several times until I know what the section is about.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471090355", "createdAt": "2020-08-16T09:41:09Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,122 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+There are a couple conditions this method has to fulfill to qualify:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDY5Nw==", "bodyText": "I would introduce the set far before in the section when you write about proving values. Show there that you can provide Strings or a CartesianProductTest.Sets. Or even more better: Design the extension that they always get such a CartesianProductTest.Sets and the String this is just a reduced wrapper for small and easy test cases.\nAs of now you throw in a core feature of the extension in a subsentence of a foot note.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471090697", "createdAt": "2020-08-16T09:45:04Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,122 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+There are a couple conditions this method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets` ^1^\n+- must register values for every parameter exactly once ^2^\n+\n+1: This is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, above>>).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDgzNA==", "bodyText": "Would keep them together and not put a foot note into a foot note when booth are about invalid parameters. Provide an own subsection for misconfiguration and link to this subsection in the list above", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471090834", "createdAt": "2020-08-16T09:46:26Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,122 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+There are a couple conditions this method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets` ^1^\n+- must register values for every parameter exactly once ^2^\n+\n+1: This is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, above>>).\n+\n+2: If you register too few, too many, or conflicting ^3^ parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+\n+3: For example, if your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit) and you register too much sets in your factory method:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MDk3Mg==", "bodyText": "A link is formatted as [link text](url) isnt it?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471090972", "createdAt": "2020-08-16T09:47:45Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,122 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+There are a couple conditions this method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets` ^1^\n+- must register values for every parameter exactly once ^2^\n+\n+1: This is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, above>>).\n+\n+2: If you register too few, too many, or conflicting ^3^ parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+\n+3: For example, if your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit) and you register too much sets in your factory method:\n+```java\n+@CartesianProductTest\n+void confusing(String a, TestInfo info) {\n+    // completely valid test\n+}\n+\n+static CartesianProductTest.Sets confusing() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"A\", \"B\", \"C\")\n+        .add(1, 2, 3);\n+}\n+```\n+\n+== Combining `@CartesianProductTest` with `@Test`\n+\n+If `@CartesianProductTest` is combined with `@Test` or `TestTemplate`-based mechanisms (like `@RepeatedTest` or `@ParameterizedTest`), the test engine will execute it according to each annotation (i.e. more than once).\n+This is most likely unwanted and will probably lead to the following exception/failure message:\n+\n+> org.junit.jupiter.api.extension.ParameterResolutionException:\n+> No ParameterResolver registered for parameter [...]\n+\n+This is because `@Test` does not know what to do with the parameter(s) of the `@CartesianProductTest`.\n+\n+== Thread-Safety\n+\n+This extension is safe to use during https://junit.org/junit5/docs/current/user-guide/#writing-tests-parallel-execution[parallel test execution].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTEzNg==", "bodyText": "As mentioned above, when changing this to CartesianProductTest.Setswould be more type save, wouldn't it?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471091136", "createdAt": "2020-08-16T09:49:37Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductResolver.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.ParameterContext;\n+import org.junit.jupiter.api.extension.ParameterResolver;\n+\n+public class CartesianProductResolver implements ParameterResolver {\n+\n+\tprivate final List<?> parameters;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTM5Mw==", "bodyText": "I don't like the name factory, because it doesn't tell what is generated. Rename to TestSetFactoryMethod or something like this. Also Javadoc is missing.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471091393", "createdAt": "2020-08-16T09:52:03Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.TestTemplate;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @CartesianProductTest} is a JUnit Jupiter extension that marks\n+ * a test to be executed with all possible input combinations.\n+ *\n+ * <p>Methods annotated with this annotation <b>MUST NOT</b> be annotated with {@code Test},\n+ * because it will throw an exception.\n+ * </p>\n+ *\n+ * <p>Methods annotated with this annotation are different from {@code ParameterizedTest}s because\n+ * they can not have {@code ArgumentsSource}s - those are completely disregarded. Instead a\n+ * String array must be provided (for methods with only String parameters) or a static factory method\n+ * with the same name as the test method must exist.\n+ * </p>\n+ *\n+ * @since ???\n+ */\n+@TestTemplate\n+@ExtendWith(CartesianProductTestExtension.class)\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface CartesianProductTest {\n+\n+\t/**\n+\t * Specifies {@code String} values for all inputs simultaneously.\n+\t */\n+\tString[] value() default {};\n+\n+\tString factory() default \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTUzOQ==", "bodyText": "Why as an inner class and not as a public Tuple class or something like this? Could be a way to provide a dynamic class for test data tuples.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471091539", "createdAt": "2020-08-16T09:53:43Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.TestTemplate;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @CartesianProductTest} is a JUnit Jupiter extension that marks\n+ * a test to be executed with all possible input combinations.\n+ *\n+ * <p>Methods annotated with this annotation <b>MUST NOT</b> be annotated with {@code Test},\n+ * because it will throw an exception.\n+ * </p>\n+ *\n+ * <p>Methods annotated with this annotation are different from {@code ParameterizedTest}s because\n+ * they can not have {@code ArgumentsSource}s - those are completely disregarded. Instead a\n+ * String array must be provided (for methods with only String parameters) or a static factory method\n+ * with the same name as the test method must exist.\n+ * </p>\n+ *\n+ * @since ???\n+ */\n+@TestTemplate\n+@ExtendWith(CartesianProductTestExtension.class)\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface CartesianProductTest {\n+\n+\t/**\n+\t * Specifies {@code String} values for all inputs simultaneously.\n+\t */\n+\tString[] value() default {};\n+\n+\tString factory() default \"\";\n+\n+\tclass Sets {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTYwNA==", "bodyText": "Why not using our Pioneer annotation methods? (Whole class)", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471091604", "createdAt": "2020-08-16T09:54:28Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n+import static org.junit.platform.commons.support.ReflectionSupport.invokeMethod;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;\n+\n+class CartesianProductTestExtension implements TestTemplateInvocationContextProvider {\n+\n+\t@Override\n+\tpublic boolean supportsTestTemplate(ExtensionContext context) {\n+\t\treturn findAnnotation(context.getTestMethod(), CartesianProductTest.class).isPresent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTk0Mw==", "bodyText": "Start with an upper letter after the parameter name", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471091943", "createdAt": "2020-08-16T09:57:25Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -44,4 +48,32 @@ private PioneerUtils() {\n \t\t}\n \t}\n \n+\t/**\n+\t * Find the first {@link Method} of the supplied class or interface that\n+\t * meets the specified criteria, beginning with the specified class or\n+\t * interface and traversing its enclosing classes until such a method is\n+\t * found or the top level class is reached.\n+\t *\n+\t * <p>The algorithm does not search for methods in {@link java.lang.Object}.\n+\t *\n+\t * @param clazz the class or interface in which to find the method; never {@code null}\n+\t * @param methodName the name of the method to find; never {@code null} or empty\n+\t * @param parameterTypes the types of parameters accepted by the method, if any;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MjQ1Mg==", "bodyText": "If I understand this right the declaration of the CartesianProductTest.Sets must be in the same test class or a parent class. Why force the users to use such test data structure instead allowing them to define the test data in a complete different class?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471092452", "createdAt": "2020-08-16T10:03:09Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n+import static org.junit.platform.commons.support.ReflectionSupport.invokeMethod;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;\n+\n+class CartesianProductTestExtension implements TestTemplateInvocationContextProvider {\n+\n+\t@Override\n+\tpublic boolean supportsTestTemplate(ExtensionContext context) {\n+\t\treturn findAnnotation(context.getTestMethod(), CartesianProductTest.class).isPresent();\n+\t}\n+\n+\t@Override\n+\tpublic Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(ExtensionContext context) {\n+\t\tList<List<?>> sets = computeSets(context.getRequiredTestMethod());\n+\t\treturn cartesianProduct(sets).stream().map(CartesianProductTestInvocationContext::new);\n+\t}\n+\n+\tprivate List<List<?>> computeSets(Method testMethod) {\n+\t\tCartesianProductTest annotation = findAnnotation(testMethod, CartesianProductTest.class)\n+\t\t\t\t.orElseThrow(() -> new AssertionError(\"@CartesianProductTest not found\"));\n+\t\t// Compute A \u2a2f A \u2a2f ... \u2a2f A from single source \"set\"\n+\t\tif (annotation.value().length > 0) {\n+\t\t\tList<String> strings = Arrays.asList(annotation.value());\n+\t\t\tList<List<?>> sets = new ArrayList<>();\n+\t\t\tfor (int i = 0; i < testMethod.getParameterTypes().length; i++) {\n+\t\t\t\tsets.add(strings);\n+\t\t\t}\n+\t\t\treturn sets;\n+\t\t}\n+\t\t// No single entry supplied? Try the sets factory method instead...\n+\t\tString factoryMethod = annotation.factory().isEmpty() ? testMethod.getName() : annotation.factory();\n+\n+\t\treturn invokeSetsFactory(testMethod, factoryMethod).getSets();\n+\t}\n+\n+\tprivate CartesianProductTest.Sets invokeSetsFactory(Method testMethod, String factoryMethodName) {\n+\t\tClass<?> declaringClass = testMethod.getDeclaringClass();\n+\t\tMethod factory = PioneerUtils\n+\t\t\t\t.findMethodCurrentOrEnclosing(declaringClass, factoryMethodName)\n+\t\t\t\t.orElseThrow(() -> new AssertionError(\"Method `CartesianProductTest.Sets \" + factoryMethodName\n+\t\t\t\t\t\t+ \"()` not found in \" + declaringClass + \"or any enclosing class\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5Mjg2Ng==", "bodyText": "According never null: You can't ensure that the user does not pass null. The underlying methods may check this and throw an exception. So remove this in the parameter description and a @throws section where you describe the exception which is thrown when one of the parameters is null.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471092866", "createdAt": "2020-08-16T10:07:13Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -44,4 +48,32 @@ private PioneerUtils() {\n \t\t}\n \t}\n \n+\t/**\n+\t * Find the first {@link Method} of the supplied class or interface that\n+\t * meets the specified criteria, beginning with the specified class or\n+\t * interface and traversing its enclosing classes until such a method is\n+\t * found or the top level class is reached.\n+\t *\n+\t * <p>The algorithm does not search for methods in {@link java.lang.Object}.\n+\t *\n+\t * @param clazz the class or interface in which to find the method; never {@code null}\n+\t * @param methodName the name of the method to find; never {@code null} or empty\n+\t * @param parameterTypes the types of parameters accepted by the method, if any;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTk0Mw=="}, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzE2MQ==", "bodyText": "Linebreaks for each .add like in nFold.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471093161", "createdAt": "2020-08-16T10:10:12Z", "author": {"login": "Bukama"}, "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+public class CartesianProductTestExtensionTests {\n+\n+\t@Nested\n+\tclass StandardBehaviouralTests {\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\" })\n+\t\t@DisplayName(\"Does nothing if there are no parameters\")\n+\t\tvoid empty() {\n+\t\t}\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\", \"2\" })\n+\t\t@DisplayName(\"Runs for each parameter once for single parameter\")\n+\t\tvoid singleParameter(String param) {\n+\t\t\tint value = Integer.parseInt(param);\n+\t\t\tAssertions.assertThat(value).isBetween(0, 2);\n+\t\t}\n+\n+\t\t@CartesianProductTest({ \"0\", \"1\" })\n+\t\tvoid threeBits(String a, String b, String c) {\n+\t\t\tint value = Integer.parseUnsignedInt(a + b + c, 2);\n+\t\t\tAssertions.assertThat(value).isBetween(0b000, 0b111);\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@DisplayName(\"S \u2a2f T \u2a2f U\")\n+\t\tvoid nFold(String string, Class<?> type, TimeUnit unit, TestInfo info) {\n+\t\t\tAssertions.assertThat(string).endsWith(\"a\");\n+\t\t\tAssertions.assertThat(type).isInterface();\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t\tAssertions.assertThat(info.getTags()).isEmpty();\n+\t\t}\n+\n+\t\t@CartesianProductTest(factory = \"supplyValues\")\n+\t\t@DisplayName(\"Can have an explicit factory method over the implicit one\")\n+\t\tvoid explicitFactory(String string, TimeUnit unit) {\n+\t\t\tAssertions.assertThat(string).isIn(\"War\", \"Peace\");\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t}\n+\n+\t}\n+\n+\tstatic CartesianProductTest.Sets nFold() {\n+\t\treturn new CartesianProductTest.Sets()\n+\t\t\t\t.add(\"Alpha\", \"Omega\")\n+\t\t\t\t.add(Runnable.class, Comparable.class, TestInfo.class)\n+\t\t\t\t.add(TimeUnit.DAYS, TimeUnit.HOURS);\n+\t}\n+\n+\tstatic CartesianProductTest.Sets supplyValues() {\n+\t\treturn new CartesianProductTest.Sets().add(\"War\", \"Peace\").add(TimeUnit.SECONDS, TimeUnit.DAYS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzI0MQ==", "bodyText": "What does nFold mean?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471093241", "createdAt": "2020-08-16T10:11:06Z", "author": {"login": "Bukama"}, "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+public class CartesianProductTestExtensionTests {\n+\n+\t@Nested\n+\tclass StandardBehaviouralTests {\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\" })\n+\t\t@DisplayName(\"Does nothing if there are no parameters\")\n+\t\tvoid empty() {\n+\t\t}\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\", \"2\" })\n+\t\t@DisplayName(\"Runs for each parameter once for single parameter\")\n+\t\tvoid singleParameter(String param) {\n+\t\t\tint value = Integer.parseInt(param);\n+\t\t\tAssertions.assertThat(value).isBetween(0, 2);\n+\t\t}\n+\n+\t\t@CartesianProductTest({ \"0\", \"1\" })\n+\t\tvoid threeBits(String a, String b, String c) {\n+\t\t\tint value = Integer.parseUnsignedInt(a + b + c, 2);\n+\t\t\tAssertions.assertThat(value).isBetween(0b000, 0b111);\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@DisplayName(\"S \u2a2f T \u2a2f U\")\n+\t\tvoid nFold(String string, Class<?> type, TimeUnit unit, TestInfo info) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzM0OQ==", "bodyText": "You could put the Test fails, when into a @DisplayName of the @Nested class.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471093349", "createdAt": "2020-08-16T10:12:17Z", "author": {"login": "Bukama"}, "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+public class CartesianProductTestExtensionTests {\n+\n+\t@Nested\n+\tclass StandardBehaviouralTests {\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\" })\n+\t\t@DisplayName(\"Does nothing if there are no parameters\")\n+\t\tvoid empty() {\n+\t\t}\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\", \"2\" })\n+\t\t@DisplayName(\"Runs for each parameter once for single parameter\")\n+\t\tvoid singleParameter(String param) {\n+\t\t\tint value = Integer.parseInt(param);\n+\t\t\tAssertions.assertThat(value).isBetween(0, 2);\n+\t\t}\n+\n+\t\t@CartesianProductTest({ \"0\", \"1\" })\n+\t\tvoid threeBits(String a, String b, String c) {\n+\t\t\tint value = Integer.parseUnsignedInt(a + b + c, 2);\n+\t\t\tAssertions.assertThat(value).isBetween(0b000, 0b111);\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@DisplayName(\"S \u2a2f T \u2a2f U\")\n+\t\tvoid nFold(String string, Class<?> type, TimeUnit unit, TestInfo info) {\n+\t\t\tAssertions.assertThat(string).endsWith(\"a\");\n+\t\t\tAssertions.assertThat(type).isInterface();\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t\tAssertions.assertThat(info.getTags()).isEmpty();\n+\t\t}\n+\n+\t\t@CartesianProductTest(factory = \"supplyValues\")\n+\t\t@DisplayName(\"Can have an explicit factory method over the implicit one\")\n+\t\tvoid explicitFactory(String string, TimeUnit unit) {\n+\t\t\tAssertions.assertThat(string).isIn(\"War\", \"Peace\");\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t}\n+\n+\t}\n+\n+\tstatic CartesianProductTest.Sets nFold() {\n+\t\treturn new CartesianProductTest.Sets()\n+\t\t\t\t.add(\"Alpha\", \"Omega\")\n+\t\t\t\t.add(Runnable.class, Comparable.class, TestInfo.class)\n+\t\t\t\t.add(TimeUnit.DAYS, TimeUnit.HOURS);\n+\t}\n+\n+\tstatic CartesianProductTest.Sets supplyValues() {\n+\t\treturn new CartesianProductTest.Sets().add(\"War\", \"Peace\").add(TimeUnit.SECONDS, TimeUnit.DAYS);\n+\t}\n+\n+\t@Nested\n+\tclass BadConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when there is no factory method\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzU0MA==", "bodyText": "Can a message be provided (and asserted) in such case?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471093540", "createdAt": "2020-08-16T10:14:41Z", "author": {"login": "Bukama"}, "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+public class CartesianProductTestExtensionTests {\n+\n+\t@Nested\n+\tclass StandardBehaviouralTests {\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\" })\n+\t\t@DisplayName(\"Does nothing if there are no parameters\")\n+\t\tvoid empty() {\n+\t\t}\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\", \"2\" })\n+\t\t@DisplayName(\"Runs for each parameter once for single parameter\")\n+\t\tvoid singleParameter(String param) {\n+\t\t\tint value = Integer.parseInt(param);\n+\t\t\tAssertions.assertThat(value).isBetween(0, 2);\n+\t\t}\n+\n+\t\t@CartesianProductTest({ \"0\", \"1\" })\n+\t\tvoid threeBits(String a, String b, String c) {\n+\t\t\tint value = Integer.parseUnsignedInt(a + b + c, 2);\n+\t\t\tAssertions.assertThat(value).isBetween(0b000, 0b111);\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@DisplayName(\"S \u2a2f T \u2a2f U\")\n+\t\tvoid nFold(String string, Class<?> type, TimeUnit unit, TestInfo info) {\n+\t\t\tAssertions.assertThat(string).endsWith(\"a\");\n+\t\t\tAssertions.assertThat(type).isInterface();\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t\tAssertions.assertThat(info.getTags()).isEmpty();\n+\t\t}\n+\n+\t\t@CartesianProductTest(factory = \"supplyValues\")\n+\t\t@DisplayName(\"Can have an explicit factory method over the implicit one\")\n+\t\tvoid explicitFactory(String string, TimeUnit unit) {\n+\t\t\tAssertions.assertThat(string).isIn(\"War\", \"Peace\");\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t}\n+\n+\t}\n+\n+\tstatic CartesianProductTest.Sets nFold() {\n+\t\treturn new CartesianProductTest.Sets()\n+\t\t\t\t.add(\"Alpha\", \"Omega\")\n+\t\t\t\t.add(Runnable.class, Comparable.class, TestInfo.class)\n+\t\t\t\t.add(TimeUnit.DAYS, TimeUnit.HOURS);\n+\t}\n+\n+\tstatic CartesianProductTest.Sets supplyValues() {\n+\t\treturn new CartesianProductTest.Sets().add(\"War\", \"Peace\").add(TimeUnit.SECONDS, TimeUnit.DAYS);\n+\t}\n+\n+\t@Nested\n+\tclass BadConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when there is no factory method\")\n+\t\tvoid throwsForMissingFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"noFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"not found\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when the factory is not static\")\n+\t\tvoid throwsForNonStaticFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"nonStaticFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"must be static\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when the factory does not return Sets\")\n+\t\tvoid throwsForWrongReturnValueFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"wrongReturnFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"must return\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails if the factory does not produce enough parameters\")\n+\t\tvoid throwsForTooFewFactoryMethodParameters() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"incompleteFactory\", int.class,\n+\t\t\t\t\t\tString.class, TimeUnit.class);\n+\n+\t\t\tassertThat(results).hasNumberOfDynamicallyRegisteredTests(3).hasNumberOfFailedTests(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MzYzMg==", "bodyText": "Why is it possible to generate a message when there a too much parameters, but not too less (see test above)?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r471093632", "createdAt": "2020-08-16T10:15:15Z", "author": {"login": "Bukama"}, "path": "src/test/java/org/junitpioneer/jupiter/CartesianProductTestExtensionTests.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junitpioneer.testkit.assertion.PioneerAssert.assertThat;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junitpioneer.testkit.ExecutionResults;\n+import org.junitpioneer.testkit.PioneerTestKit;\n+\n+public class CartesianProductTestExtensionTests {\n+\n+\t@Nested\n+\tclass StandardBehaviouralTests {\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\" })\n+\t\t@DisplayName(\"Does nothing if there are no parameters\")\n+\t\tvoid empty() {\n+\t\t}\n+\n+\t\t@CartesianProductTest(value = { \"0\", \"1\", \"2\" })\n+\t\t@DisplayName(\"Runs for each parameter once for single parameter\")\n+\t\tvoid singleParameter(String param) {\n+\t\t\tint value = Integer.parseInt(param);\n+\t\t\tAssertions.assertThat(value).isBetween(0, 2);\n+\t\t}\n+\n+\t\t@CartesianProductTest({ \"0\", \"1\" })\n+\t\tvoid threeBits(String a, String b, String c) {\n+\t\t\tint value = Integer.parseUnsignedInt(a + b + c, 2);\n+\t\t\tAssertions.assertThat(value).isBetween(0b000, 0b111);\n+\t\t}\n+\n+\t\t@CartesianProductTest\n+\t\t@DisplayName(\"S \u2a2f T \u2a2f U\")\n+\t\tvoid nFold(String string, Class<?> type, TimeUnit unit, TestInfo info) {\n+\t\t\tAssertions.assertThat(string).endsWith(\"a\");\n+\t\t\tAssertions.assertThat(type).isInterface();\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t\tAssertions.assertThat(info.getTags()).isEmpty();\n+\t\t}\n+\n+\t\t@CartesianProductTest(factory = \"supplyValues\")\n+\t\t@DisplayName(\"Can have an explicit factory method over the implicit one\")\n+\t\tvoid explicitFactory(String string, TimeUnit unit) {\n+\t\t\tAssertions.assertThat(string).isIn(\"War\", \"Peace\");\n+\t\t\tAssertions.assertThat(unit.name()).endsWith(\"S\");\n+\t\t}\n+\n+\t}\n+\n+\tstatic CartesianProductTest.Sets nFold() {\n+\t\treturn new CartesianProductTest.Sets()\n+\t\t\t\t.add(\"Alpha\", \"Omega\")\n+\t\t\t\t.add(Runnable.class, Comparable.class, TestInfo.class)\n+\t\t\t\t.add(TimeUnit.DAYS, TimeUnit.HOURS);\n+\t}\n+\n+\tstatic CartesianProductTest.Sets supplyValues() {\n+\t\treturn new CartesianProductTest.Sets().add(\"War\", \"Peace\").add(TimeUnit.SECONDS, TimeUnit.DAYS);\n+\t}\n+\n+\t@Nested\n+\tclass BadConfigurationTests {\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when there is no factory method\")\n+\t\tvoid throwsForMissingFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"noFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"not found\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when the factory is not static\")\n+\t\tvoid throwsForNonStaticFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"nonStaticFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"must be static\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails when the factory does not return Sets\")\n+\t\tvoid throwsForWrongReturnValueFactoryMethod() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"wrongReturnFactory\", int.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"must return\");\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails if the factory does not produce enough parameters\")\n+\t\tvoid throwsForTooFewFactoryMethodParameters() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"incompleteFactory\", int.class,\n+\t\t\t\t\t\tString.class, TimeUnit.class);\n+\n+\t\t\tassertThat(results).hasNumberOfDynamicallyRegisteredTests(3).hasNumberOfFailedTests(3);\n+\t\t}\n+\n+\t\t@Test\n+\t\t@DisplayName(\"Test fails if the factory produces too much parameters\")\n+\t\tvoid throwsForTooManyFactoryMethodParameters() {\n+\t\t\tExecutionResults results = PioneerTestKit\n+\t\t\t\t\t.executeTestMethodWithParameterTypes(BadConfigurationTest.class, \"bloatedFactory\", int.class,\n+\t\t\t\t\t\tString.class);\n+\n+\t\t\tassertThat(results)\n+\t\t\t\t\t.hasSingleFailedContainer()\n+\t\t\t\t\t.withExceptionInstanceOf(AssertionError.class)\n+\t\t\t\t\t.hasMessageContaining(\"must register values for each parameter\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bec357c0770adfc4f16176c94899cba50ec5edb", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0bec357c0770adfc4f16176c94899cba50ec5edb", "committedDate": "2020-08-18T08:34:11Z", "message": "Rewrote documentation, added new test\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/05dba570d277621c69a402a11a2f3cde1fb3a662", "committedDate": "2020-08-18T08:43:07Z", "message": "Fix bad test and weird formatting things\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNzE0ODM3", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#pullrequestreview-471714837", "createdAt": "2020-08-20T15:11:52Z", "commit": {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNToxMTo1MlrOHEGRPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNToyNDowNFrOHEGxog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1OTA2OA==", "bodyText": "giving a value\n\nWith a single value there is no Cartesian product (or to be exactly: The CP only has one row). Would change it to plural, e.g. \"by giving values to. These values are input for all parameters.\" or something like that.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474059068", "createdAt": "2020-08-20T15:11:52Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1OTI2Mw==", "bodyText": "values", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474059263", "createdAt": "2020-08-20T15:12:12Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MDA0NA==", "bodyText": "Would add an introduction sentence like \"If you don't only supply String values to your test method like in the example above...\"", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474060044", "createdAt": "2020-08-20T15:13:26Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MDU2Mw==", "bodyText": "Capital I after :", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474060563", "createdAt": "2020-08-20T15:14:05Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MTczOQ==", "bodyText": "As you describe the input of nFold here this should be moved up to be in place with the example and after that show the possibility to use an individual name for the data provider method (without further explanation)", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474061739", "createdAt": "2020-08-20T15:15:46Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void aTestMethodThatNeedsArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MjY5Ng==", "bodyText": "\"There are some conditions\" or \"There are a couple of conditions\" or \"There are several conditions\"", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474062696", "createdAt": "2020-08-20T15:17:10Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void aTestMethodThatNeedsArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+=== Conditions for the static factory method\n+\n+There are a couple conditions the static factory method has to fulfill to qualify:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MzcxNA==", "bodyText": "This line reads like there is missing something at the end. Would change it to \"The following example shows...\" or something like this.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474063714", "createdAt": "2020-08-20T15:18:41Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,150 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+Sometimes you want to test not only for specific inputs but also combinations of those inputs.\n+`@CartesianProductTest` combines all test inputs and runs a test for each combination.\n+\n+[#_basic_use]\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination it can have.\n+\n+```java\n+@CartesianProductTest({\"0\", \"1\"})\n+void threeBits(String a, String b, String c) {\n+    int value = Integer.parseUnsignedInt(a + b + c, 2);\n+    Assertions.assertThat(value).isBetween(0b000, 0b111);\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the value \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a` | value of `b` | value of `c`\n+| 1st test  | 0            | 0            | 0\n+| 2nd test  | 0            | 0            | 1\n+| 3rd test  | 0            | 1            | 0\n+| 4th test  | 0            | 1            | 1\n+| 5th test  | 1            | 0            | 0\n+| 6th test  | 1            | 0            | 1\n+| 7th test  | 1            | 1            | 0\n+| 8th test  | 1            | 1            | 1\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+`@CartesianProductTest` can have a static factory method supplying the test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void aTestMethodThatNeedsArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+=== Conditions for the static factory method\n+\n+There are a couple conditions the static factory method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets`\n+- must register values for every parameter exactly once\n+- must register values in order\n+\n+=== Returning wrong `Sets` in the static factory method\n+\n+If you register too few, too many, or conflicting parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+For example, if your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit), and you register too many sets in your factory method:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2NDI0NQ==", "bodyText": "Remove as you don't know. The changelog will show the version the extension comes available.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474064245", "createdAt": "2020-08-20T15:19:22Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.TestTemplate;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @CartesianProductTest} is a JUnit Jupiter extension that marks\n+ * a test to be executed with all possible input combinations.\n+ *\n+ * <p>Methods annotated with this annotation <b>MUST NOT</b> be annotated with {@code Test},\n+ * because it will throw an exception.\n+ * </p>\n+ *\n+ * <p>Methods annotated with this annotation are different from {@code ParameterizedTest}s because\n+ * they can not have {@code ArgumentsSource}s - those are completely disregarded. Instead a\n+ * String array must be provided (for methods with only String parameters) or a static factory method\n+ * with the same name as the test method must exist.\n+ * </p>\n+ *\n+ * @since ???", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05dba570d277621c69a402a11a2f3cde1fb3a662"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2NjU2MA==", "bodyText": "I see the Sets thing as a dataholder class and in itself has nothing to do with the Cartesian production interface. I personally don't like to squeeze a general class/interface into a specific one.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474066560", "createdAt": "2020-08-20T15:22:45Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.TestTemplate;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @CartesianProductTest} is a JUnit Jupiter extension that marks\n+ * a test to be executed with all possible input combinations.\n+ *\n+ * <p>Methods annotated with this annotation <b>MUST NOT</b> be annotated with {@code Test},\n+ * because it will throw an exception.\n+ * </p>\n+ *\n+ * <p>Methods annotated with this annotation are different from {@code ParameterizedTest}s because\n+ * they can not have {@code ArgumentsSource}s - those are completely disregarded. Instead a\n+ * String array must be provided (for methods with only String parameters) or a static factory method\n+ * with the same name as the test method must exist.\n+ * </p>\n+ *\n+ * @since ???\n+ */\n+@TestTemplate\n+@ExtendWith(CartesianProductTestExtension.class)\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface CartesianProductTest {\n+\n+\t/**\n+\t * Specifies {@code String} values for all inputs simultaneously.\n+\t */\n+\tString[] value() default {};\n+\n+\tString factory() default \"\";\n+\n+\tclass Sets {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTUzOQ=="}, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2NzM2Mg==", "bodyText": "Then you argue to throw Pioneer Annotations out, because we can use the JUnit things. The idea was Pioneer Annotation was to encapsulate the JUnit thing with our own, improved methods. But I'll leave it to you / the others which way we use.\nSame for TestKit or PioneerAssertions \ud83e\udd37\u200d\u2642\ufe0f", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r474067362", "createdAt": "2020-08-20T15:24:04Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n+import static org.junit.platform.commons.support.ReflectionSupport.invokeMethod;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;\n+\n+class CartesianProductTestExtension implements TestTemplateInvocationContextProvider {\n+\n+\t@Override\n+\tpublic boolean supportsTestTemplate(ExtensionContext context) {\n+\t\treturn findAnnotation(context.getTestMethod(), CartesianProductTest.class).isPresent();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTYwNA=="}, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06d45a7219280730d6228b4f6eeb35139f15f99f", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/06d45a7219280730d6228b4f6eeb35139f15f99f", "committedDate": "2020-08-21T14:33:10Z", "message": "Create our own `CartesianValueSource` for supplying parameter values to `CartesianProductTest`\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15ce2f2e79a03e6633d1066a289895c8e6d50e7c", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/15ce2f2e79a03e6633d1066a289895c8e6d50e7c", "committedDate": "2020-08-21T16:09:06Z", "message": "Rewrote documentation again.\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "096f41ed7fd92b2c70b5add05b5d3309fb351291", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/096f41ed7fd92b2c70b5add05b5d3309fb351291", "committedDate": "2020-08-21T16:22:45Z", "message": "Making SONAR happy\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25bfc9013ed08e55012c5cf94a0dbaa8ab542753", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/25bfc9013ed08e55012c5cf94a0dbaa8ab542753", "committedDate": "2020-08-24T09:24:15Z", "message": "Remove duplicate elements from inputs\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "088288c5575fc73f60536539d869f11f84a9cc07", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/088288c5575fc73f60536539d869f11f84a9cc07", "committedDate": "2020-08-24T09:25:20Z", "message": "spotless\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6", "committedDate": "2020-08-24T09:32:54Z", "message": "Added some explanation about the extension removing duplicates\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NTkyNDE5", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#pullrequestreview-474592419", "createdAt": "2020-08-25T15:22:56Z", "commit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNToyMjo1N1rOHGdWJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTo1ODoxMVrOHGe2_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNDMxMQ==", "bodyText": "For a better transition between the theoretical part and the extension I would change this to something like:\nSometimes its useful to test all possible combinations of parameters set. Normally this results in a lot of written test data parameters. For a more comfortable way you may use the CartesianProductTest extension. The extension takes the test data parameter values and runs....\nThe basic usage of the extension (with the parameter sets) are describe below anyway.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476534311", "createdAt": "2020-08-25T15:22:57Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzNzY1Ng==", "bodyText": "I don't know which words I should choose, but this sentence lacks some kind of introduction, like to \"There are multiple ways to pass test data to the extension.\". As of now you (or at least I) fall \"into\" this sentences without knowing what to expect.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476537656", "createdAt": "2020-08-25T15:27:11Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzODUxMQ==", "bodyText": "The Cartesian product works with sets, so the extension does. (more fluent I think)", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476538511", "createdAt": "2020-08-25T15:28:25Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0MDA1OA==", "bodyText": "You should add if the duplicates get removed automatically (most probably as Set can't work with duplicates). To emphasize that I would remove the final Cartesian product (you described above how it is created) and change the line to the (automatically) \"real/reduced\" input, e.g.\nIf your input is { 1, 1, 3, 4 } and { 2, 2, 3 } the input sets get reduced to  { { 1, 3, 4 }, { 2, 3 } }.\nI would change If you need that functionality to If you need to pass the same parameters multiple times, you might.. to make clear what you mean with functionality.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476540058", "createdAt": "2020-08-25T15:30:37Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NDIwNQ==", "bodyText": "I don't like the wording of \"a value\". I know it's because value is the default name of the annotation variable, but \"a value\" mislead to \"a single value\", which is false, because you are passing String arrays.\nWhat about something like \"Supplying (simple) sets of Strings to the extension\"?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476544205", "createdAt": "2020-08-25T15:36:17Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NTY0NQ==", "bodyText": "No , before and- this is no enumeration", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476545645", "createdAt": "2020-08-25T15:38:25Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NzAyNA==", "bodyText": "Change ; to ,, because that's .. is a subordinate clause.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476547024", "createdAt": "2020-08-25T15:40:17Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0Nzk5Mw==", "bodyText": "_Instead of only suppliying string values to your ... you can annotate ... with CartesianValueSource [to do what <- thats missing]\nOr written in another way: If I don't supply string values I don't supply them. Period. Starting a sentence like this makes the reader feel that there are (bad) consequences if not doing so.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476547993", "createdAt": "2020-08-25T15:41:46Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0OTM3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n          \n          \n            \n            This is annotation might look familiar (it mimics JUnits `@ValueSource`), but it works differently.....[insert explanation].\n          \n      \n    \n    \n  \n\nOr explanation below at end of subsection.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476549377", "createdAt": "2020-08-25T15:43:51Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MDk1OQ==", "bodyText": "left-to-right or top-to-bottom: The or irritates me. Is there any forced order or not? You example seems like the order of the annotation must match the parameter order? Are the names of \"ints\" and \"strings\" fixed or forced too?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476550959", "createdAt": "2020-08-25T15:46:10Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MTQ3Mw==", "bodyText": ";to ,", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476551473", "createdAt": "2020-08-25T15:46:58Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MjA3NA==", "bodyText": "Move this up to the explanation (or add a subsubsection / some sentences) here to explain the differences.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476552074", "createdAt": "2020-08-25T15:47:55Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MjU3Mg==", "bodyText": "Remove the \"finally,\"", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476552572", "createdAt": "2020-08-25T15:48:44Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NDAwMg==", "bodyText": "What about a more fluent sentence like: To create a set with test data, instantiate a new CartesianProductTest.Sets(), use the add()... and return the created object.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476554002", "createdAt": "2020-08-25T15:50:50Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: Instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NDI0Ng==", "bodyText": "again", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476554246", "createdAt": "2020-08-25T15:51:12Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: Instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NTQ0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Remember, you can reuse the same argument provider if you explicitly give its name to `@CartesianProductTest`.\n          \n          \n            \n            Remember, you can reuse the same argument provider method, by explicitly pass its name to the  `@CartesianProductTest` `factory` attribute.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476555440", "createdAt": "2020-08-25T15:52:56Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: Instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+Remember, you can reuse the same argument provider if you explicitly give its name to `@CartesianProductTest`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NjY2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - must have the same name as the test method or its name must be specified via `factory()`\n          \n          \n            \n            - must have the same name as the test method (or its name must be specified via `factory()`)\n          \n      \n    \n    \n  \n\nYou are listing conditions of the method. So the same name is only in default case (as you described above)  and I would put the note about the factory() method as a reminder in brackets here.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476556664", "createdAt": "2020-08-25T15:54:41Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: Instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+Remember, you can reuse the same argument provider if you explicitly give its name to `@CartesianProductTest`.\n+\n+```java\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingSameArguments(String string, int i) {\n+    // different passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+=== Conditions for the static factory method\n+\n+There are multiple conditions the static factory method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzI5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Combining `@CartesianProductTest` with `@Test`\n          \n          \n            \n            == Warning: Don't combine `@CartesianProductTest` with `@Test`!", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476557297", "createdAt": "2020-08-25T15:55:36Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+You can use `@CartesianProductTest` and define test parameter sets to run the same test on the cartesian product.\n+This means that `@CartesianProductTest` takes the possible test parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+`@CartesianProductTest` works with sets.\n+This means that duplicate elements get removed.\n+If your input is `{ 1, 1, 3, 4 }` and `{ 2, 2, 3 }` their cartesian product is `{ { 1, 2 }, { 1, 3 }, { 3, 2 }, { 3, 3 }, { 4, 2 }, { 4, 3 } }`.\n+This is because otherwise the test would run with the same parameters multiple times.\n+If you need that functionality, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying a value to CartesianProductTest\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters, and the test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply String values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+This is annotation might look familiar - it mimics JUnits `@ValueSource`.\n+It is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right or top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations; that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+Please note that `@CartesianValueSource` is not compatible with `@ParameterizedTest`.\n+\n+== Writing a static factory method for the parameters\n+\n+Finally, if your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+The way to use it: Instantiate it (`new CartesianProductTest.Sets()`), then use the `add()` method to register values for the parameters (see <<_static-factory-example, the example>>).\n+\n+[#_static-factory-example]\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations; that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+Remember, you can reuse the same argument provider if you explicitly give its name to `@CartesianProductTest`.\n+\n+```java\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingSameArguments(String string, int i) {\n+    // different passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+=== Conditions for the static factory method\n+\n+There are multiple conditions the static factory method has to fulfill to qualify:\n+\n+- must have the same name as the test method or its name must be specified via `factory()`\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets`\n+- must register values for every parameter exactly once\n+- must register values in order\n+\n+=== Returning wrong `Sets` in the static factory method\n+\n+If you register too few, too many, or conflicting parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+Conflicting parameters meaning your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit), and you register too many sets in your factory method.\n+\n+Examples of badly configured tests/static factory method:\n+```java\n+@CartesianProductTest(factory = \"resolveParameters\")\n+void tooFewParameters(String string, int i, boolean b) {\n+    // fails because the boolean parameter is not resolved\n+}\n+\n+@CartesianProductTest(factory = \"resolveParameters\")\n+void tooManyParameters(String string) {\n+    // fails because we try to supply a non-existent integer parameter\n+}\n+\n+@CartesianProductTest(factory = \"resolveParameters\")\n+void wrongOrderParameters(int i, String string) {\n+    // fails because the static factory method declared parameter sets in the wrong order\n+}\n+\n+@CartesianProductTest(factory = \"resolveParameters\")\n+void conflictingParameters(String string, TestInfo info) {\n+    // fails because both the factory method and JUnit tries to inject TestInfo\n+    // OR\n+    // fails because the static factory method tries to inject int instead of TestInfo\n+}\n+\n+static CartesianProductTest.Sets resolveParameters() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"A\", \"B\", \"C\")\n+        .add(1, 2, 3);\n+}\n+```\n+\n+== Combining `@CartesianProductTest` with `@Test`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTEwMA==", "bodyText": "_ Spotless what did you do here?_", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r476559100", "createdAt": "2020-08-25T15:58:11Z", "author": {"login": "Bukama"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianValueArgumentsProvider.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.platform.commons.util.Preconditions;\n+\n+/**\n+ * This is basically a copy of ValueSourceArgumentsProvider,\n+ * except it does NOT support {@code @ParameterizedTest}.\n+ */\n+class CartesianValueArgumentsProvider implements Consumer<CartesianValueSource> {\n+\n+\tprivate Object[] arguments;\n+\n+\t@Override\n+\tpublic void accept(CartesianValueSource source) {\n+\t\t// @formatter:off\n+        List<Object> arrays =\n+                // Declaration of <Object> is necessary due to a bug in Eclipse Photon.\n+                Stream.<Object> of(\n+                        source.shorts(),\n+                        source.bytes(),\n+                        source.ints(),\n+                        source.longs(),\n+                        source.floats(),\n+                        source.doubles(),\n+                        source.chars(),\n+                        source.booleans(),\n+                        source.strings(),\n+                        source.classes()\n+                )\n+                .filter(array -> Array.getLength(array) > 0)\n+                .collect(toList());\n+        // @formatter:on\n+\n+\t\tPreconditions\n+\t\t\t\t.condition(arrays.size() == 1, () -> \"Exactly one type of input must be provided in the @\"\n+\t\t\t\t\t\t+ CartesianValueSource.class.getSimpleName() + \" annotation, but there were \" + arrays.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "705b70c44678d3b3e9bc6eb2265e4ca0e39d75a6"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9a4864879b738a08bc9bcbba41c0dab39f3ed4d", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/a9a4864879b738a08bc9bcbba41c0dab39f3ed4d", "committedDate": "2020-08-29T11:07:35Z", "message": "Documentation updates following suggestions\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MjA4NDYy", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#pullrequestreview-478208462", "createdAt": "2020-08-30T14:32:07Z", "commit": {"oid": "a9a4864879b738a08bc9bcbba41c0dab39f3ed4d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQxNDozMjowOFrOHJjRQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMFQxNDozMjowOFrOHJjRQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc3NzA5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Sometimes its useful to test all possible combinations of parameters set.\n          \n          \n            \n            Sometimes its useful to test all possible combinations of parameters sets.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r479777091", "createdAt": "2020-08-30T14:32:08Z", "author": {"login": "Bukama"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes its useful to test all possible combinations of parameters set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9a4864879b738a08bc9bcbba41c0dab39f3ed4d"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "733d9249d8e9827ecc08102ca31d95ca0d347afd", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/733d9249d8e9827ecc08102ca31d95ca0d347afd", "committedDate": "2020-08-30T16:31:40Z", "message": "Fixing typo\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21c18d6a7edbc50c933b7f547045f5523517dd08", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/21c18d6a7edbc50c933b7f547045f5523517dd08", "committedDate": "2020-09-08T17:55:25Z", "message": "Merge branch 'master' into issue/68-cartesian-product-extension"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDY3MTQ0", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#pullrequestreview-484467144", "createdAt": "2020-09-08T20:24:06Z", "commit": {"oid": "733d9249d8e9827ecc08102ca31d95ca0d347afd"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoyNDowNlrOHOsxIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0NjowOVrOHOtbhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTU4NQ==", "bodyText": "\"the free encyclopedia\" seems a bit patronizing, I think most people know that small project already. \ud83d\ude09", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485175585", "createdAt": "2020-09-08T20:24:06Z", "author": {"login": "nipafx"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "733d9249d8e9827ecc08102ca31d95ca0d347afd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTcwNA==", "bodyText": "Love this! \u2764\ufe0f \ud83d\udc4d", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485175704", "createdAt": "2020-09-08T20:24:23Z", "author": {"login": "nipafx"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "733d9249d8e9827ecc08102ca31d95ca0d347afd"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjM4OQ==", "bodyText": "I think the section Basic Use could do with a simple, working code snippet.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485176389", "createdAt": "2020-09-08T20:25:44Z", "author": {"login": "nipafx"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes it's useful to test all possible combinations of parameter sets.\n+Normally, this results in a lot of written test data parameters.\n+For a more comfortable way you may use the `@CartesianProductTest` extension.\n+The extension takes the test data parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "733d9249d8e9827ecc08102ca31d95ca0d347afd"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODA4MA==", "bodyText": "The section header talks about single sets, which made me expect a way to define sets of all types (e.g. a single set of ints), but the text only mentions String arrays. Does this work for all kinds of arrays? If so/not, this should be stated explicitly.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485178080", "createdAt": "2020-09-08T20:29:23Z", "author": {"login": "nipafx"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes it's useful to test all possible combinations of parameter sets.\n+Normally, this results in a lot of written test data parameters.\n+For a more comfortable way you may use the `@CartesianProductTest` extension.\n+The extension takes the test data parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+\n+You can supply test parameters to `@CartesianProductTest` in multiple ways.\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+Just like the mathematical Cartesian product, `@CartesianProductTest` works with sets.\n+Duplicate elements get removed automatically.\n+If your input is `{ 1, 1, 3 }` and `{ 2, 2 }` the extension will consider their Cartesian product `{ { 1, 2 }, { 3, 2 } }`.\n+Otherwise, the test would run with the same parameters multiple times.\n+If you need to pass the same parameters multiple times, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying CartesianProductTest with a single set\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "733d9249d8e9827ecc08102ca31d95ca0d347afd"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MDE3Nw==", "bodyText": "Good connection to something the reader (may) already know! \ud83d\udc4d Add a link to the user guide or docs to drive it home.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485180177", "createdAt": "2020-09-08T20:33:34Z", "author": {"login": "nipafx"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes it's useful to test all possible combinations of parameter sets.\n+Normally, this results in a lot of written test data parameters.\n+For a more comfortable way you may use the `@CartesianProductTest` extension.\n+The extension takes the test data parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+\n+You can supply test parameters to `@CartesianProductTest` in multiple ways.\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+Just like the mathematical Cartesian product, `@CartesianProductTest` works with sets.\n+Duplicate elements get removed automatically.\n+If your input is `{ 1, 1, 3 }` and `{ 2, 2 }` the extension will consider their Cartesian product `{ { 1, 2 }, { 3, 2 } }`.\n+Otherwise, the test would run with the same parameters multiple times.\n+If you need to pass the same parameters multiple times, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying CartesianProductTest with a single set\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters.\n+The test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations, that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply string values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+`@CartesianValueSource` is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right/top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+This annotation might look familiar - it mimics JUnits `@ValueSource`, except `@CartesianValueSource` is repeatable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "733d9249d8e9827ecc08102ca31d95ca0d347afd"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NjE1OQ==", "bodyText": "This made me think, I could not have TestInfo or TestReporter params in my test method signature.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485186159", "createdAt": "2020-09-08T20:45:38Z", "author": {"login": "nipafx"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes it's useful to test all possible combinations of parameter sets.\n+Normally, this results in a lot of written test data parameters.\n+For a more comfortable way you may use the `@CartesianProductTest` extension.\n+The extension takes the test data parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+\n+You can supply test parameters to `@CartesianProductTest` in multiple ways.\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+Just like the mathematical Cartesian product, `@CartesianProductTest` works with sets.\n+Duplicate elements get removed automatically.\n+If your input is `{ 1, 1, 3 }` and `{ 2, 2 }` the extension will consider their Cartesian product `{ { 1, 2 }, { 3, 2 } }`.\n+Otherwise, the test would run with the same parameters multiple times.\n+If you need to pass the same parameters multiple times, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying CartesianProductTest with a single set\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters.\n+The test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations, that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply string values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+`@CartesianValueSource` is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right/top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+This annotation might look familiar - it mimics JUnits `@ValueSource`, except `@CartesianValueSource` is repeatable.\n+It also does NOT work with `@ParameterizedTest`.\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations, that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+If your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+To create the test data, instantiate a `new CartesianProductTest.Sets()` then use the `add()` method to register the values for the parameters.\n+\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations, that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+Remember, you can reuse the same argument provider method, by explicitly passing its name to `@CartesianProductTest`'s `factory` attribute.\n+\n+```java\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingSameArguments(String string, int i) {\n+    // different passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+=== Conditions for the static factory method\n+\n+There are multiple conditions the static factory method has to fulfill to qualify:\n+\n+- must have the same name as the test method (or its name must be specified via `factory()`)\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets`\n+- must register values for every parameter exactly once\n+- must register values in order\n+\n+=== Returning wrong `Sets` in the static factory method\n+\n+If you register too few, too many, or conflicting parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+Conflicting parameters meaning your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit), and you register too many sets in your factory method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "733d9249d8e9827ecc08102ca31d95ca0d347afd"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NjQzNw==", "bodyText": "If TestInfo or TestReporter works with correct configurations, that may be worth a mention as well.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r485186437", "createdAt": "2020-09-08T20:46:09Z", "author": {"login": "nipafx"}, "path": "docs/cartesian-product.adoc", "diffHunk": "@@ -0,0 +1,222 @@\n+:page-title: Testing all test parameter combinations (Cartesian product)\n+:page-description: Extends JUnit Jupiter with `@CartesianProductTest`, a special `@ParameterizedTest` which tests all combinations of its input\n+\n+From Wikipedia, the free encyclopedia:\n+\n+> In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A \u00d7 B, is the set of all ordered pairs (a, b) where a is in A and b is in B.\n+> In terms of set-builder notation, that is `A \u00d7 B = {(a,b) | a \u2208 A and b \u2208 B}`\n+> +[...]+\n+> One can similarly define the Cartesian product of n sets, also known as an n-fold Cartesian product, which can be represented by an n-dimensional array, where each element is an n-tuple.\n+\n+What does all this mean?\n+\n+The cartesian product of sets is all the possible combinations where you take a single element from each set.\n+If you have two sets, `{ 1, 2 }` and `{ 3, 4 }`, their cartesian product is `{ { 1, 3 }, { 1, 4 }, { 2, 3 }, { 2, 4 } }`.\n+\n+Sometimes it's useful to test all possible combinations of parameter sets.\n+Normally, this results in a lot of written test data parameters.\n+For a more comfortable way you may use the `@CartesianProductTest` extension.\n+The extension takes the test data parameter values and runs the test for every possible combination of them.\n+\n+== Basic Use\n+\n+`@CartesianProductTest` is used _instead_ of `@Test` or other such annotations (e.g. `@RepeatedTest`).\n+\n+You can supply test parameters to `@CartesianProductTest` in multiple ways.\n+The annotation can have a value (see <<Supplying a value to CartesianProductTest>>), the test method can be annotated with `@CartesianValueSource` (see <<Annotating your test method with @CartesianValueSource>>), or the test class can have a static factory method (see <<Writing a static factory method for the parameters>>) providing the arguments.\n+\n+Just like the mathematical Cartesian product, `@CartesianProductTest` works with sets.\n+Duplicate elements get removed automatically.\n+If your input is `{ 1, 1, 3 }` and `{ 2, 2 }` the extension will consider their Cartesian product `{ { 1, 2 }, { 3, 2 } }`.\n+Otherwise, the test would run with the same parameters multiple times.\n+If you need to pass the same parameters multiple times, you might want to look into https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests[repeated tests].\n+\n+== Supplying CartesianProductTest with a single set\n+\n+If all your test parameters are strings, you can supply all input parameters simultaneously by giving a string array value to `@CartesianProductTest`.\n+This value is the input for all parameters.\n+The test will try every combination of its elements.\n+\n+```java\n+@CartesianProductTest({ \"0\", \"1\" })\n+void threeBits(String a, String b, String c) {\n+    // passing test code\n+}\n+```\n+\n+The test `threeBits` is executed exactly eight times, because all three input parameters can have the values \"0\" or \"1\".\n+`@CartesianProductTest` tests for all input combinations, that's `2 \u00d7 2 \u00d7 2`, so eight tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `a`   | value of `b`   | value of `c`\n+| 1st test  | \"0\"            | \"0\"            | \"0\"\n+| 2nd test  | \"0\"            | \"0\"            | \"1\"\n+| 3rd test  | \"0\"            | \"1\"            | \"0\"\n+| 4th test  | \"0\"            | \"1\"            | \"1\"\n+| 5th test  | \"1\"            | \"0\"            | \"0\"\n+| 6th test  | \"1\"            | \"0\"            | \"1\"\n+| 7th test  | \"1\"            | \"1\"            | \"0\"\n+| 8th test  | \"1\"            | \"1\"            | \"1\"\n+|===\n+\n+== Annotating your test method with @CartesianValueSource\n+\n+If you don't only supply string values to your test method like in the example above, you can annotate your method with `@CartesianValueSource`.\n+`@CartesianValueSource` is used to define the possible inputs of a single test parameter.\n+You define the parameter values in order (left-to-right/top-to-bottom) and the test will try every combination those values can have.\n+\n+```java\n+@CartesianProductTest\n+@CartesianValueSource(ints = { 1, 2, 4 })\n+@CartesianValueSource(strings = { \"A\", \"B\" })\n+void annotated(int number, String character) {\n+    // passing test code\n+}\n+```\n+\n+This annotation might look familiar - it mimics JUnits `@ValueSource`, except `@CartesianValueSource` is repeatable.\n+It also does NOT work with `@ParameterizedTest`.\n+\n+The test `annotated` is executed exactly six times.\n+The first parameter can have any of the three values `1`, `2` or `4`.\n+The second parameter can have any of the two values `A` or `B`.\n+`@CartesianProductTest` tests for all input combinations, that's `3 \u00d7 2`, so six tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test | value of `number` | value of `character`\n+| 1st test  | 1                 | \"A\"\n+| 2nd test  | 1                 | \"B\"\n+| 3rd test  | 2                 | \"A\"\n+| 4th test  | 2                 | \"B\"\n+| 5th test  | 4                 | \"A\"\n+| 6th test  | 4                 | \"B\"\n+|===\n+\n+== Writing a static factory method for the parameters\n+\n+If your tests require special inputs that `@CartesianValueSource` is not able to supply, you can define a static factory method to supply your test parameters.\n+By default, this method must have the same name as the test method, but you can specify a different name with the `factory()` annotation parameter.\n+This method must return `CartesianProductTest.Sets`.\n+`CartesianProductTest.Sets` is a helper class, specifically for creating sets for `@CartesianProductTest`.\n+To create the test data, instantiate a `new CartesianProductTest.Sets()` then use the `add()` method to register the values for the parameters.\n+\n+```java\n+@CartesianProductTest\n+void nFold(String string, Class<?> clazz, TimeUnit unit) {\n+    // passing test code\n+}\n+\n+static CartesianProductTest.Sets nFold() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Alpha\", \"Omega\")\n+        .add(Runnable.class, Cloneable.class, Predicate.class)\n+        .add(TimeUnit.DAYS, TimeUnit.HOURS);\n+}\n+```\n+\n+The test `nFold` is executed exactly twelve times.\n+The first parameter can have any of the two values `\"Alpha\"` or `\"Omega\"`.\n+The second parameter can have any of the three values `Runnable.class`, `Cloneable.class` or `Predicate.class`.\n+The third parameter can have any of the two values `TimeUnit.DAYS` or `TimeUnit.HOURS`.\n+`@CartesianProductTest` tests for all input combinations, that's `2 \u00d7 3 \u00d7 2`, so twelve tests in total.\n+\n+To demonstrate with a table:\n+|===\n+| # of test  | value of `string` | value of `clazz` | value of `unit`\n+| 1st test   | \"Alpha\"           | Runnable.class   | TimeUnit.DAYS\n+| 2nd test   | \"Alpha\"           | Runnable.class   | TimeUnit.HOURS\n+| 3rd test   | \"Alpha\"           | Cloneable.class  | TimeUnit.DAYS\n+| 4th test   | \"Alpha\"           | Cloneable.class  | TimeUnit.HOURS\n+| 5th test   | \"Alpha\"           | Predicate.class  | TimeUnit.DAYS\n+| 6th test   | \"Alpha\"           | Predicate.class  | TimeUnit.HOURS\n+| 7th test   | \"Omega\"           | Runnable.class   | TimeUnit.DAYS\n+| 8th test   | \"Omega\"           | Runnable.class   | TimeUnit.HOURS\n+| 9th test   | \"Omega\"           | Cloneable.class  | TimeUnit.DAYS\n+| 10th test  | \"Omega\"           | Cloneable.class  | TimeUnit.HOURS\n+| 11th test  | \"Omega\"           | Predicate.class  | TimeUnit.DAYS\n+| 12th test  | \"Omega\"           | Predicate.class  | TimeUnit.HOURS\n+|===\n+\n+Remember, you can reuse the same argument provider method, by explicitly passing its name to `@CartesianProductTest`'s `factory` attribute.\n+\n+```java\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingArguments(String string, int i) {\n+    // passing test code\n+}\n+\n+@CartesianProductTest(factory = \"provideArguments\")\n+void testNeedingSameArguments(String string, int i) {\n+    // different passing test code\n+}\n+\n+static CartesianProductTest.Sets provideArguments() {\n+    return new CartesianProductTest.Sets()\n+        .add(\"Mercury\", \"Earth\", \"Venus\")\n+        .add(1, 12, 144);\n+}\n+```\n+\n+=== Conditions for the static factory method\n+\n+There are multiple conditions the static factory method has to fulfill to qualify:\n+\n+- must have the same name as the test method (or its name must be specified via `factory()`)\n+- must be `static`\n+- must have **no** parameters\n+- must return `CartesianProductTest.Sets`\n+- must register values for every parameter exactly once\n+- must register values in order\n+\n+=== Returning wrong `Sets` in the static factory method\n+\n+If you register too few, too many, or conflicting parameters, you will get an `org.junit.jupiter.api.extension.ParameterResolutionException`.\n+Conflicting parameters meaning your test method has a `TestInfo` or `TestReporter` (or any other parameter that is automatically injected by JUnit), and you register too many sets in your factory method.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NjE1OQ=="}, "originalCommit": {"oid": "733d9249d8e9827ecc08102ca31d95ca0d347afd"}, "originalPosition": 177}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f82643ccf72fdada563b0bf4b4549a671e3a102f", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/f82643ccf72fdada563b0bf4b4549a671e3a102f", "committedDate": "2020-09-09T09:36:40Z", "message": "Merge branch 'master' into issue/68-cartesian-product-extension"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b041892c3d99347be85163c69025d4e45fbc2c3", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/2b041892c3d99347be85163c69025d4e45fbc2c3", "committedDate": "2020-09-20T13:22:42Z", "message": "CartesianProductTest display names should align with ParameterizedTest display names\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f04e74c62249db4476ddf1e57341f08cf751892", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/5f04e74c62249db4476ddf1e57341f08cf751892", "committedDate": "2020-09-20T13:23:00Z", "message": "Applying suggestions to documentation\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae17e0f43e1d873a934649fea7a7e21165fa7748", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/ae17e0f43e1d873a934649fea7a7e21165fa7748", "committedDate": "2020-09-20T13:23:44Z", "message": "Merge branch 'master' into issue/68-cartesian-product-extension"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "916c0e5d5c95005ae7447afba13aa57403a64d4a", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/916c0e5d5c95005ae7447afba13aa57403a64d4a", "committedDate": "2020-09-26T09:11:35Z", "message": "Small documentation improvements (subject to Mihaly's approval)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b76351dceb0ae3e619ab6a74b1eb36964d9e2cc1", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b76351dceb0ae3e619ab6a74b1eb36964d9e2cc1", "committedDate": "2020-09-26T09:25:44Z", "message": "Merge branch 'master' into issue/68-cartesian-product-extension"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb836ff1adbd68c00a358ec7a2bf7bec7c921bd9", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/cb836ff1adbd68c00a358ec7a2bf7bec7c921bd9", "committedDate": "2020-09-26T09:26:58Z", "message": "Replace AssertionError with ExtensionConfigurationException\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c94cd6fbc526097f996e7cda8e80ff9e52949704", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c94cd6fbc526097f996e7cda8e80ff9e52949704", "committedDate": "2020-09-26T09:35:45Z", "message": "Fix modular build?\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6daad3d71bbed16d30b5c0d58283d0cce2ab81a", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b6daad3d71bbed16d30b5c0d58283d0cce2ab81a", "committedDate": "2020-09-26T09:40:11Z", "message": "Replace AssertionError with ExtensionConfigurationException in tests\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "118c3e1f40383b1a850a4edfa949b1d5a8c01470", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/118c3e1f40383b1a850a4edfa949b1d5a8c01470", "committedDate": "2020-09-26T09:46:44Z", "message": "Fix comment and JavaDoc\n\nSigned-off-by: Mihaly Verhas <misi.verhas@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7186f694b0d818d856b1f9e84e1ef6838a58cbd1", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/7186f694b0d818d856b1f9e84e1ef6838a58cbd1", "committedDate": "2020-09-26T09:49:34Z", "message": "Merge branch 'master' into issue/68-cartesian-product-extension"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99003da041688209f876d47233f1a12ab68d46f6", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/99003da041688209f876d47233f1a12ab68d46f6", "committedDate": "2020-09-26T10:40:11Z", "message": "Validate input of CartesianProductTests with ReportEntry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ef09b6a0768c10f13b2cba0d8a2d983012fe5f2", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6ef09b6a0768c10f13b2cba0d8a2d983012fe5f2", "committedDate": "2020-09-26T13:11:36Z", "message": "Add ExtensionConfigurationException to conflicting arguments sources."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72d01df5c9e74f136e2f8f6cb4b630f5f6e73579", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/72d01df5c9e74f136e2f8f6cb4b630f5f6e73579", "committedDate": "2020-09-26T14:29:31Z", "message": "Added a sentence about different parameter sources conflicting in the documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3776202cf25626c4305911780682a67e405f591", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/d3776202cf25626c4305911780682a67e405f591", "committedDate": "2020-09-26T18:44:00Z", "message": "Added an option to change display name of tests created by a CartesianProductTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "722abb0da5265fe04f01a4f87e107194891c52a9", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/722abb0da5265fe04f01a4f87e107194891c52a9", "committedDate": "2020-09-26T21:15:55Z", "message": "Fix Java 9+ calls to List.of to be Arrays.asList"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f22aaae5ccad2a43f558b798b9b32bf6388eda23", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/f22aaae5ccad2a43f558b798b9b32bf6388eda23", "committedDate": "2020-09-26T22:49:32Z", "message": "Fix creaky things"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfd855593a6364c4ab3085ee8df940c451a8cb3b", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/cfd855593a6364c4ab3085ee8df940c451a8cb3b", "committedDate": "2020-09-26T23:09:11Z", "message": "Add missing test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f70f8cd7ef6df7831d0b395697b800d043b392b", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0f70f8cd7ef6df7831d0b395697b800d043b392b", "committedDate": "2020-09-26T23:13:47Z", "message": "no star imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8f3dc487f68d97135153352b70662bb06029ccf", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c8f3dc487f68d97135153352b70662bb06029ccf", "committedDate": "2020-09-27T15:51:14Z", "message": "Added documentation about customizing Display Names of CartesianProductTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a802ca8074b2a09b298b43d909fc5e131fe39fe4", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/a802ca8074b2a09b298b43d909fc5e131fe39fe4", "committedDate": "2020-09-29T18:48:07Z", "message": "Small edits in tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b620344d08515cc2ec5ddf49cb7057145fd40fe4", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b620344d08515cc2ec5ddf49cb7057145fd40fe4", "committedDate": "2020-09-29T19:23:48Z", "message": "Reduce visibility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c07302c61c24cbfccad3ad99ad8655a653ac19d", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6c07302c61c24cbfccad3ad99ad8655a653ac19d", "committedDate": "2020-09-29T19:24:16Z", "message": "Small refactorings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cd5f1963e61c482ea96f97524fc13045d8e4239", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/7cd5f1963e61c482ea96f97524fc13045d8e4239", "committedDate": "2020-09-29T19:24:44Z", "message": "DEATH TO SPACES! \u2620"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4Nzg2OTU4", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#pullrequestreview-498786958", "createdAt": "2020-09-29T18:57:55Z", "commit": {"oid": "c8f3dc487f68d97135153352b70662bb06029ccf"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxODo1Nzo1NVrOHZ8fSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOTowNzoyN1rOHZ8z_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk2NzQ5OA==", "bodyText": "Can we get a little more detail on how to use the extension and a link to the website with details?", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r496967498", "createdAt": "2020-09-29T18:57:55Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.TestTemplate;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+/**\n+ * {@code @CartesianProductTest} is a JUnit Jupiter extension that marks\n+ * a test to be executed with all possible input combinations.\n+ *\n+ * <p>Methods annotated with this annotation should not be annotated with {@code Test}.\n+ * </p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f3dc487f68d97135153352b70662bb06029ccf"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3MDU4MA==", "bodyText": "The advantage of our annotation methods is that they make it easy to find meta annotations that are _indirectly present: (if a supertype of the element is annotated), meta-present (if an annotation that is present on the element is itself annotated), or _enclosing-present (if an enclosing type [think opposite of @Nested] is annotated). As I see it, only meta-present is relevant here, but that should indeed be allowed. Not sure if AnnotationSupport.findAnnotation does that.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r496970580", "createdAt": "2020-09-29T19:03:23Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n+import static org.junit.platform.commons.support.ReflectionSupport.invokeMethod;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;\n+\n+class CartesianProductTestExtension implements TestTemplateInvocationContextProvider {\n+\n+\t@Override\n+\tpublic boolean supportsTestTemplate(ExtensionContext context) {\n+\t\treturn findAnnotation(context.getTestMethod(), CartesianProductTest.class).isPresent();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA5MTYwNA=="}, "originalCommit": {"oid": "698ac4bf39168ad9b31f8e961daea5f14c21e6e7"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3MjA5OA==", "bodyText": "What if sets.getSets().size() == testMethod.getParameterCount(), but one of the parameters is resolved by JUnit itself? Then we should still see the exception.", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r496972098", "createdAt": "2020-09-29T19:06:08Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestExtension.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static java.lang.String.format;\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n+import static org.junit.platform.commons.support.AnnotationSupport.findRepeatableAnnotations;\n+import static org.junit.platform.commons.support.ReflectionSupport.invokeMethod;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.ParameterResolutionException;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContext;\n+import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;\n+\n+class CartesianProductTestExtension implements TestTemplateInvocationContextProvider {\n+\n+\t@Override\n+\tpublic boolean supportsTestTemplate(ExtensionContext context) {\n+\t\treturn findAnnotation(context.getTestMethod(), CartesianProductTest.class).isPresent();\n+\t}\n+\n+\t@Override\n+\tpublic Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(ExtensionContext context) {\n+\t\tList<List<?>> sets = computeSets(context);\n+\t\tCartesianProductTestNameFormatter formatter = createNameFormatter(context);\n+\t\treturn cartesianProduct(sets)\n+\t\t\t\t.stream()\n+\t\t\t\t.map(params -> new CartesianProductTestInvocationContext(params, formatter));\n+\t}\n+\n+\tprivate CartesianProductTestNameFormatter createNameFormatter(ExtensionContext context) {\n+\t\tCartesianProductTest annotation = findAnnotation(context.getRequiredTestMethod(), CartesianProductTest.class)\n+\t\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"@CartesianProductTest not found\"));\n+\t\tString pattern = annotation.name();\n+\t\tif (pattern.isEmpty())\n+\t\t\tthrow new ExtensionConfigurationException(\"CartesianProductTest can not have a non-empty display name\");\n+\t\tString displayName = context.getDisplayName();\n+\t\treturn new CartesianProductTestNameFormatter(pattern, displayName);\n+\t}\n+\n+\tprivate List<List<?>> computeSets(ExtensionContext context) {\n+\t\tMethod testMethod = context.getRequiredTestMethod();\n+\t\tCartesianProductTest annotation = findAnnotation(testMethod, CartesianProductTest.class)\n+\t\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"@CartesianProductTest not found\"));\n+\t\tList<CartesianValueSource> valueSources = findRepeatableAnnotations(testMethod, CartesianValueSource.class);\n+\t\tensureNoInputConflicts(annotation, valueSources);\n+\t\t// Compute A \u2a2f A \u2a2f ... \u2a2f A from single source \"set\"\n+\t\tif (annotation.value().length > 0) {\n+\t\t\treturn getSetsFromValue(testMethod, annotation);\n+\t\t}\n+\t\t// Try finding the @CartesianValueSource annotation\n+\t\tif (!valueSources.isEmpty()) {\n+\t\t\treturn getSetsFromRepeatableAnnotation(valueSources);\n+\t\t}\n+\t\t// Try the sets static factory method\n+\t\treturn getSetsFromStaticFactory(testMethod, annotation.factory());\n+\t}\n+\n+\tprivate static void ensureNoInputConflicts(CartesianProductTest annotation,\n+\t\t\tList<CartesianValueSource> valueSources) {\n+\t\tboolean hasValue = annotation.value().length != 0;\n+\t\tboolean hasFactory = !annotation.factory().isEmpty();\n+\t\tboolean hasValueSources = !valueSources.isEmpty();\n+\t\tif (hasValue && hasFactory || hasValue && hasValueSources || hasFactory && hasValueSources) {\n+\t\t\tthrow new ExtensionConfigurationException(\n+\t\t\t\t\"CartesianProductTest can only take exactly one type of arguments source\");\n+\t\t}\n+\t}\n+\n+\tprivate List<List<?>> getSetsFromValue(Method testMethod, CartesianProductTest annotation) {\n+\t\tList<List<?>> sets = new ArrayList<>();\n+\t\tList<String> strings = Arrays.stream(annotation.value()).distinct().collect(toList());\n+\t\tfor (int i = 0; i < testMethod.getParameterTypes().length; i++) {\n+\t\t\tsets.add(strings);\n+\t\t}\n+\t\treturn sets;\n+\t}\n+\n+\tprivate List<List<?>> getSetsFromRepeatableAnnotation(List<CartesianValueSource> valueSources) {\n+\t\tList<List<?>> sets = new ArrayList<>();\n+\t\tfor (CartesianValueSource source : valueSources) {\n+\t\t\tCartesianValueArgumentsProvider provider = new CartesianValueArgumentsProvider();\n+\t\t\tprovider.accept(source);\n+\t\t\tList<Object> collect = provider.provideArguments().distinct().collect(toList());\n+\t\t\tsets.add(collect);\n+\t\t}\n+\t\treturn sets;\n+\t}\n+\n+\tprivate List<List<?>> getSetsFromStaticFactory(Method testMethod, String explicitFactoryName) {\n+\t\tif (explicitFactoryName.isEmpty())\n+\t\t\treturn invokeSetsFactory(testMethod, testMethod.getName()).getSets();\n+\t\telse\n+\t\t\treturn invokeSetsFactory(testMethod, explicitFactoryName).getSets();\n+\t}\n+\n+\tprivate CartesianProductTest.Sets invokeSetsFactory(Method testMethod, String factoryMethodName) {\n+\t\tClass<?> declaringClass = testMethod.getDeclaringClass();\n+\t\tMethod factory = PioneerUtils\n+\t\t\t\t.findMethodCurrentOrEnclosing(declaringClass, factoryMethodName)\n+\t\t\t\t.orElseThrow(() -> new ExtensionConfigurationException(\"Method `CartesianProductTest.Sets \"\n+\t\t\t\t\t\t+ factoryMethodName + \"()` not found in \" + declaringClass + \"or any enclosing class\"));\n+\t\tString method = \"Method `\" + factory + \"`\";\n+\t\tif (!Modifier.isStatic(factory.getModifiers())) {\n+\t\t\tthrow new ExtensionConfigurationException(method + \" must be static\");\n+\t\t}\n+\t\tif (!CartesianProductTest.Sets.class.isAssignableFrom(factory.getReturnType())) {\n+\t\t\tthrow new ExtensionConfigurationException(method + \" must return `CartesianProductTest.Sets`\");\n+\t\t}\n+\t\tCartesianProductTest.Sets sets = (CartesianProductTest.Sets) invokeMethod(factory, null);\n+\t\tif (sets.getSets().size() > testMethod.getParameterCount()) {\n+\t\t\tthrow new ParameterResolutionException(format(\n+\t\t\t\t\"%s must register values for each parameter exactly once. Expected [%d] parameter sets, but got [%d]\",\n+\t\t\t\tmethod, testMethod.getParameterCount(), sets.getSets().size()));\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f3dc487f68d97135153352b70662bb06029ccf"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3Mjc5OQ==", "bodyText": "I really like it that this is its own class. \ud83d\udc4d", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/321#discussion_r496972799", "createdAt": "2020-09-29T19:07:27Z", "author": {"login": "nipafx"}, "path": "src/main/java/org/junitpioneer/jupiter/CartesianProductTestNameFormatter.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static java.util.stream.Collectors.joining;\n+import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_PLACEHOLDER;\n+import static org.junit.jupiter.params.ParameterizedTest.DISPLAY_NAME_PLACEHOLDER;\n+import static org.junit.jupiter.params.ParameterizedTest.INDEX_PLACEHOLDER;\n+\n+import java.text.MessageFormat;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+\n+import org.junit.jupiter.api.extension.ExtensionConfigurationException;\n+\n+class CartesianProductTestNameFormatter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f3dc487f68d97135153352b70662bb06029ccf"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0860c8e6c86aeb499de8a51293c2a49434252ac1", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/0860c8e6c86aeb499de8a51293c2a49434252ac1", "committedDate": "2020-09-29T19:32:56Z", "message": "DEATH TO SPOTLESS! \u2620 \u2620 \u2620"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dec19903d8879268e1aa3fca96fa751eefa4f7b5", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/dec19903d8879268e1aa3fca96fa751eefa4f7b5", "committedDate": "2020-10-04T14:30:37Z", "message": "Add comment about why equality is not checked"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c7d1d05b73b25826ed60ce0c7b1b07ab7009e97", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6c7d1d05b73b25826ed60ce0c7b1b07ab7009e97", "committedDate": "2020-10-04T14:49:14Z", "message": "Add/expand basic documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c89cf05ba600a1b365902b2d1e5a7a1032593051", "author": {"user": {"login": "Michael1993", "name": "Mih\u00e1ly Verh\u00e1s"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/c89cf05ba600a1b365902b2d1e5a7a1032593051", "committedDate": "2020-10-04T14:49:38Z", "message": "Merge branch 'issue/68-cartesian-product-extension' of https://github.com/Michael1993/junit-pioneer into issue/68-cartesian-product-extension"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26c0bbb8059f0f1e43149670ba43b30712e0b993", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/26c0bbb8059f0f1e43149670ba43b30712e0b993", "committedDate": "2020-10-06T18:39:30Z", "message": "Improve Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c0be910fc1cfd07fcddd38c8e3c2e7f03ed91a7", "author": {"user": {"login": "nipafx", "name": "Nicolai Parlog"}}, "url": "https://github.com/junit-pioneer/junit-pioneer/commit/6c0be910fc1cfd07fcddd38c8e3c2e7f03ed91a7", "committedDate": "2020-10-06T18:44:50Z", "message": "Fix Javadoc"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3829, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}