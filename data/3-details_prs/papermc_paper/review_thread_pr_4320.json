{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MDk2NjQ2", "number": 4320, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjoxNzo1NlrOEkge5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjoxOToyMlrOEkgg1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzE2MzkwOnYy", "diffSide": "RIGHT", "path": "Spigot-Server-Patches/0580-Only-consider-chunks-Loaded-if-at-BORDER-status.patch", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjoxNzo1NlrOHTfRwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzozNDo0MlrOHTig1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5NzQ0MA==", "bodyText": "Empty if statement", "url": "https://github.com/PaperMC/Paper/pull/4320#discussion_r490197440", "createdAt": "2020-09-17T12:17:56Z", "author": {"login": "unisteven"}, "path": "Spigot-Server-Patches/0580-Only-consider-chunks-Loaded-if-at-BORDER-status.patch", "diffHunk": "@@ -0,0 +1,158 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Aikar <aikar@aikar.co>\n+Date: Sat, 12 Sep 2020 22:20:55 -0400\n+Subject: [PATCH] Only consider chunks Loaded if at BORDER status\n+\n+This greatly improves performance as it drastically reduces the amount\n+of Entities and Tile Entities that are \"registered\" into the world, as\n+purely \"cached\" chunks will no longer have their entities hanging out in the world.\n+\n+Additionally this fixes our Entity Add To World and Entity Remove From World events\n+\n+Those events have not been firing correctly since MC changed how chunks work here.\n+\n+Now the server will only consider a chunk \"loaded\" if it's got a ticket putting\n+it at level 33 or lower, which matches the public Bukkit API.\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 299d7d7a55532930e2d4340a6cfe77a5fd8a0a0c..15c0a06139bffc6a7f83a1d47f2a708f14d264ec 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -791,6 +791,7 @@ public class Chunk implements IChunkAccess {\n+         int chunkX = this.loc.x;\n+         int chunkZ = this.loc.z;\n+         ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();\n++        chunkProvider.playerChunkMap.loadChunk(this); // Paper - move load logic from the entering full status to when it enters border status instead\n+         for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {\n+             for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {\n+                 Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);\n+@@ -862,6 +863,11 @@ public class Chunk implements IChunkAccess {\n+         this.loadedTicketLevel = false;\n+         this.resetNeighbours();\n+         // Paper end\n++        // Paper start - move unload logic from the actual full unload to be when it leaves border status\n++        chunkProvider.playerChunkMap.loadedChunks.remove(loc.longKey);\n++        setLoaded(false);\n++        this.world.unloadChunk(this);\n++        // Paper end\n+     }\n+     // CraftBukkit end\n+ \n+diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+index 45c142c227bc258bbd5c8c03c6012663dccf8f3f..d119d68bb69baecdd7b896e6efb41251fa226adb 100644\n+--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java\n++++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+@@ -19,6 +19,7 @@ import java.util.function.Supplier;\n+ import javax.annotation.Nullable;\n+ import com.destroystokyo.paper.exception.ServerInternalException;\n+ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper\n++import it.unimi.dsi.fastutil.longs.LongIterator; // Paper\n+ import org.apache.logging.log4j.LogManager;\n+ import org.apache.logging.log4j.Logger;\n+ \n+@@ -822,7 +823,9 @@ public class ChunkProviderServer extends IChunkProvider {\n+             //List<PlayerChunk> list = Lists.newArrayList(this.playerChunkMap.f()); // Paper\n+             //Collections.shuffle(list); // Paper\n+             // Paper - moved up\n+-            final int[] chunksTicked = {0}; this.playerChunkMap.forEachVisibleChunk((playerchunk) -> { // Paper - safe iterator incase chunk loads, also no wrapping\n++            final int[] chunksTicked = {0};\n++            for (LongIterator iterator = this.playerChunkMap.loadedChunks.iterator() ; iterator.hasNext() ; ) { // Paper - iterate only loaded chunks\n++                PlayerChunk playerchunk = this.playerChunkMap.getVisibleChunk(iterator.nextLong());// Paper - iterate only loaded chunks\n+                 Optional<Chunk> optional = ((Either) playerchunk.a().getNow(PlayerChunk.UNLOADED_CHUNK)).left();\n+ \n+                 if (optional.isPresent()) {\n+@@ -850,7 +853,7 @@ public class ChunkProviderServer extends IChunkProvider {\n+                         }\n+                     }\n+                 }\n+-            });\n++            };// Paper - use for instead of forEachVisibleChunk\n+             this.world.getMethodProfiler().enter(\"customSpawners\");\n+             if (flag1) {\n+                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index fcd3388d88aad6e897b73e2c823267ada327cbda..3f7da1a74eb881ddc30b20143c20fe162543c20f 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -1021,16 +1021,18 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                 this.a(i, playerchunk);\n+             } else {\n+                 if (this.pendingUnload.remove(i, playerchunk) && ichunkaccess != null) {\n++                    // Paper start - coment out and move to ChunkUnloadEvent\n+                     if (ichunkaccess instanceof Chunk) {\n+-                        ((Chunk) ichunkaccess).setLoaded(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50fd75caaf393aaff6bb57b2773569529116ca3"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI1MDQ1NA==", "bodyText": "we try to keep diff minimal, if they add something else here, it may then be needed to keep the chunk check.", "url": "https://github.com/PaperMC/Paper/pull/4320#discussion_r490250454", "createdAt": "2020-09-17T13:34:42Z", "author": {"login": "aikar"}, "path": "Spigot-Server-Patches/0580-Only-consider-chunks-Loaded-if-at-BORDER-status.patch", "diffHunk": "@@ -0,0 +1,158 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Aikar <aikar@aikar.co>\n+Date: Sat, 12 Sep 2020 22:20:55 -0400\n+Subject: [PATCH] Only consider chunks Loaded if at BORDER status\n+\n+This greatly improves performance as it drastically reduces the amount\n+of Entities and Tile Entities that are \"registered\" into the world, as\n+purely \"cached\" chunks will no longer have their entities hanging out in the world.\n+\n+Additionally this fixes our Entity Add To World and Entity Remove From World events\n+\n+Those events have not been firing correctly since MC changed how chunks work here.\n+\n+Now the server will only consider a chunk \"loaded\" if it's got a ticket putting\n+it at level 33 or lower, which matches the public Bukkit API.\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 299d7d7a55532930e2d4340a6cfe77a5fd8a0a0c..15c0a06139bffc6a7f83a1d47f2a708f14d264ec 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -791,6 +791,7 @@ public class Chunk implements IChunkAccess {\n+         int chunkX = this.loc.x;\n+         int chunkZ = this.loc.z;\n+         ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();\n++        chunkProvider.playerChunkMap.loadChunk(this); // Paper - move load logic from the entering full status to when it enters border status instead\n+         for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {\n+             for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {\n+                 Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);\n+@@ -862,6 +863,11 @@ public class Chunk implements IChunkAccess {\n+         this.loadedTicketLevel = false;\n+         this.resetNeighbours();\n+         // Paper end\n++        // Paper start - move unload logic from the actual full unload to be when it leaves border status\n++        chunkProvider.playerChunkMap.loadedChunks.remove(loc.longKey);\n++        setLoaded(false);\n++        this.world.unloadChunk(this);\n++        // Paper end\n+     }\n+     // CraftBukkit end\n+ \n+diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+index 45c142c227bc258bbd5c8c03c6012663dccf8f3f..d119d68bb69baecdd7b896e6efb41251fa226adb 100644\n+--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java\n++++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+@@ -19,6 +19,7 @@ import java.util.function.Supplier;\n+ import javax.annotation.Nullable;\n+ import com.destroystokyo.paper.exception.ServerInternalException;\n+ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper\n++import it.unimi.dsi.fastutil.longs.LongIterator; // Paper\n+ import org.apache.logging.log4j.LogManager;\n+ import org.apache.logging.log4j.Logger;\n+ \n+@@ -822,7 +823,9 @@ public class ChunkProviderServer extends IChunkProvider {\n+             //List<PlayerChunk> list = Lists.newArrayList(this.playerChunkMap.f()); // Paper\n+             //Collections.shuffle(list); // Paper\n+             // Paper - moved up\n+-            final int[] chunksTicked = {0}; this.playerChunkMap.forEachVisibleChunk((playerchunk) -> { // Paper - safe iterator incase chunk loads, also no wrapping\n++            final int[] chunksTicked = {0};\n++            for (LongIterator iterator = this.playerChunkMap.loadedChunks.iterator() ; iterator.hasNext() ; ) { // Paper - iterate only loaded chunks\n++                PlayerChunk playerchunk = this.playerChunkMap.getVisibleChunk(iterator.nextLong());// Paper - iterate only loaded chunks\n+                 Optional<Chunk> optional = ((Either) playerchunk.a().getNow(PlayerChunk.UNLOADED_CHUNK)).left();\n+ \n+                 if (optional.isPresent()) {\n+@@ -850,7 +853,7 @@ public class ChunkProviderServer extends IChunkProvider {\n+                         }\n+                     }\n+                 }\n+-            });\n++            };// Paper - use for instead of forEachVisibleChunk\n+             this.world.getMethodProfiler().enter(\"customSpawners\");\n+             if (flag1) {\n+                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index fcd3388d88aad6e897b73e2c823267ada327cbda..3f7da1a74eb881ddc30b20143c20fe162543c20f 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -1021,16 +1021,18 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                 this.a(i, playerchunk);\n+             } else {\n+                 if (this.pendingUnload.remove(i, playerchunk) && ichunkaccess != null) {\n++                    // Paper start - coment out and move to ChunkUnloadEvent\n+                     if (ichunkaccess instanceof Chunk) {\n+-                        ((Chunk) ichunkaccess).setLoaded(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5NzQ0MA=="}, "originalCommit": {"oid": "a50fd75caaf393aaff6bb57b2773569529116ca3"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzE2ODg2OnYy", "diffSide": "RIGHT", "path": "Spigot-Server-Patches/0580-Only-consider-chunks-Loaded-if-at-BORDER-status.patch", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjoxOToyMlrOHTfUzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzozNzo0OVrOHTipyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5ODIyMA==", "bodyText": "Commented out code could be removed.", "url": "https://github.com/PaperMC/Paper/pull/4320#discussion_r490198220", "createdAt": "2020-09-17T12:19:22Z", "author": {"login": "unisteven"}, "path": "Spigot-Server-Patches/0580-Only-consider-chunks-Loaded-if-at-BORDER-status.patch", "diffHunk": "@@ -0,0 +1,158 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Aikar <aikar@aikar.co>\n+Date: Sat, 12 Sep 2020 22:20:55 -0400\n+Subject: [PATCH] Only consider chunks Loaded if at BORDER status\n+\n+This greatly improves performance as it drastically reduces the amount\n+of Entities and Tile Entities that are \"registered\" into the world, as\n+purely \"cached\" chunks will no longer have their entities hanging out in the world.\n+\n+Additionally this fixes our Entity Add To World and Entity Remove From World events\n+\n+Those events have not been firing correctly since MC changed how chunks work here.\n+\n+Now the server will only consider a chunk \"loaded\" if it's got a ticket putting\n+it at level 33 or lower, which matches the public Bukkit API.\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 299d7d7a55532930e2d4340a6cfe77a5fd8a0a0c..15c0a06139bffc6a7f83a1d47f2a708f14d264ec 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -791,6 +791,7 @@ public class Chunk implements IChunkAccess {\n+         int chunkX = this.loc.x;\n+         int chunkZ = this.loc.z;\n+         ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();\n++        chunkProvider.playerChunkMap.loadChunk(this); // Paper - move load logic from the entering full status to when it enters border status instead\n+         for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {\n+             for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {\n+                 Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);\n+@@ -862,6 +863,11 @@ public class Chunk implements IChunkAccess {\n+         this.loadedTicketLevel = false;\n+         this.resetNeighbours();\n+         // Paper end\n++        // Paper start - move unload logic from the actual full unload to be when it leaves border status\n++        chunkProvider.playerChunkMap.loadedChunks.remove(loc.longKey);\n++        setLoaded(false);\n++        this.world.unloadChunk(this);\n++        // Paper end\n+     }\n+     // CraftBukkit end\n+ \n+diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+index 45c142c227bc258bbd5c8c03c6012663dccf8f3f..d119d68bb69baecdd7b896e6efb41251fa226adb 100644\n+--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java\n++++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+@@ -19,6 +19,7 @@ import java.util.function.Supplier;\n+ import javax.annotation.Nullable;\n+ import com.destroystokyo.paper.exception.ServerInternalException;\n+ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper\n++import it.unimi.dsi.fastutil.longs.LongIterator; // Paper\n+ import org.apache.logging.log4j.LogManager;\n+ import org.apache.logging.log4j.Logger;\n+ \n+@@ -822,7 +823,9 @@ public class ChunkProviderServer extends IChunkProvider {\n+             //List<PlayerChunk> list = Lists.newArrayList(this.playerChunkMap.f()); // Paper\n+             //Collections.shuffle(list); // Paper\n+             // Paper - moved up\n+-            final int[] chunksTicked = {0}; this.playerChunkMap.forEachVisibleChunk((playerchunk) -> { // Paper - safe iterator incase chunk loads, also no wrapping\n++            final int[] chunksTicked = {0};\n++            for (LongIterator iterator = this.playerChunkMap.loadedChunks.iterator() ; iterator.hasNext() ; ) { // Paper - iterate only loaded chunks\n++                PlayerChunk playerchunk = this.playerChunkMap.getVisibleChunk(iterator.nextLong());// Paper - iterate only loaded chunks\n+                 Optional<Chunk> optional = ((Either) playerchunk.a().getNow(PlayerChunk.UNLOADED_CHUNK)).left();\n+ \n+                 if (optional.isPresent()) {\n+@@ -850,7 +853,7 @@ public class ChunkProviderServer extends IChunkProvider {\n+                         }\n+                     }\n+                 }\n+-            });\n++            };// Paper - use for instead of forEachVisibleChunk\n+             this.world.getMethodProfiler().enter(\"customSpawners\");\n+             if (flag1) {\n+                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index fcd3388d88aad6e897b73e2c823267ada327cbda..3f7da1a74eb881ddc30b20143c20fe162543c20f 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -1021,16 +1021,18 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                 this.a(i, playerchunk);\n+             } else {\n+                 if (this.pendingUnload.remove(i, playerchunk) && ichunkaccess != null) {\n++                    // Paper start - coment out and move to ChunkUnloadEvent\n+                     if (ichunkaccess instanceof Chunk) {\n+-                        ((Chunk) ichunkaccess).setLoaded(false);\n++                        //((Chunk) ichunkaccess).setLoaded(false);\n+                     }\n+ \n+                     //this.saveChunk(ichunkaccess);// Paper - delay\n+-                    if (this.loadedChunks.remove(i) && ichunkaccess instanceof Chunk) {\n+-                        Chunk chunk = (Chunk) ichunkaccess;\n+-\n+-                        this.world.unloadChunk(chunk);\n+-                    }\n++//                    if (this.loadedChunks.remove(i) && ichunkaccess instanceof Chunk) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50fd75caaf393aaff6bb57b2773569529116ca3"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI1Mjc0NQ==", "bodyText": "That is not how we do things, so that it can improve chance of conflict and see exactly what was moved.", "url": "https://github.com/PaperMC/Paper/pull/4320#discussion_r490252745", "createdAt": "2020-09-17T13:37:49Z", "author": {"login": "aikar"}, "path": "Spigot-Server-Patches/0580-Only-consider-chunks-Loaded-if-at-BORDER-status.patch", "diffHunk": "@@ -0,0 +1,158 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Aikar <aikar@aikar.co>\n+Date: Sat, 12 Sep 2020 22:20:55 -0400\n+Subject: [PATCH] Only consider chunks Loaded if at BORDER status\n+\n+This greatly improves performance as it drastically reduces the amount\n+of Entities and Tile Entities that are \"registered\" into the world, as\n+purely \"cached\" chunks will no longer have their entities hanging out in the world.\n+\n+Additionally this fixes our Entity Add To World and Entity Remove From World events\n+\n+Those events have not been firing correctly since MC changed how chunks work here.\n+\n+Now the server will only consider a chunk \"loaded\" if it's got a ticket putting\n+it at level 33 or lower, which matches the public Bukkit API.\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 299d7d7a55532930e2d4340a6cfe77a5fd8a0a0c..15c0a06139bffc6a7f83a1d47f2a708f14d264ec 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -791,6 +791,7 @@ public class Chunk implements IChunkAccess {\n+         int chunkX = this.loc.x;\n+         int chunkZ = this.loc.z;\n+         ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();\n++        chunkProvider.playerChunkMap.loadChunk(this); // Paper - move load logic from the entering full status to when it enters border status instead\n+         for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {\n+             for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {\n+                 Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);\n+@@ -862,6 +863,11 @@ public class Chunk implements IChunkAccess {\n+         this.loadedTicketLevel = false;\n+         this.resetNeighbours();\n+         // Paper end\n++        // Paper start - move unload logic from the actual full unload to be when it leaves border status\n++        chunkProvider.playerChunkMap.loadedChunks.remove(loc.longKey);\n++        setLoaded(false);\n++        this.world.unloadChunk(this);\n++        // Paper end\n+     }\n+     // CraftBukkit end\n+ \n+diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+index 45c142c227bc258bbd5c8c03c6012663dccf8f3f..d119d68bb69baecdd7b896e6efb41251fa226adb 100644\n+--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java\n++++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+@@ -19,6 +19,7 @@ import java.util.function.Supplier;\n+ import javax.annotation.Nullable;\n+ import com.destroystokyo.paper.exception.ServerInternalException;\n+ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper\n++import it.unimi.dsi.fastutil.longs.LongIterator; // Paper\n+ import org.apache.logging.log4j.LogManager;\n+ import org.apache.logging.log4j.Logger;\n+ \n+@@ -822,7 +823,9 @@ public class ChunkProviderServer extends IChunkProvider {\n+             //List<PlayerChunk> list = Lists.newArrayList(this.playerChunkMap.f()); // Paper\n+             //Collections.shuffle(list); // Paper\n+             // Paper - moved up\n+-            final int[] chunksTicked = {0}; this.playerChunkMap.forEachVisibleChunk((playerchunk) -> { // Paper - safe iterator incase chunk loads, also no wrapping\n++            final int[] chunksTicked = {0};\n++            for (LongIterator iterator = this.playerChunkMap.loadedChunks.iterator() ; iterator.hasNext() ; ) { // Paper - iterate only loaded chunks\n++                PlayerChunk playerchunk = this.playerChunkMap.getVisibleChunk(iterator.nextLong());// Paper - iterate only loaded chunks\n+                 Optional<Chunk> optional = ((Either) playerchunk.a().getNow(PlayerChunk.UNLOADED_CHUNK)).left();\n+ \n+                 if (optional.isPresent()) {\n+@@ -850,7 +853,7 @@ public class ChunkProviderServer extends IChunkProvider {\n+                         }\n+                     }\n+                 }\n+-            });\n++            };// Paper - use for instead of forEachVisibleChunk\n+             this.world.getMethodProfiler().enter(\"customSpawners\");\n+             if (flag1) {\n+                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index fcd3388d88aad6e897b73e2c823267ada327cbda..3f7da1a74eb881ddc30b20143c20fe162543c20f 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -1021,16 +1021,18 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                 this.a(i, playerchunk);\n+             } else {\n+                 if (this.pendingUnload.remove(i, playerchunk) && ichunkaccess != null) {\n++                    // Paper start - coment out and move to ChunkUnloadEvent\n+                     if (ichunkaccess instanceof Chunk) {\n+-                        ((Chunk) ichunkaccess).setLoaded(false);\n++                        //((Chunk) ichunkaccess).setLoaded(false);\n+                     }\n+ \n+                     //this.saveChunk(ichunkaccess);// Paper - delay\n+-                    if (this.loadedChunks.remove(i) && ichunkaccess instanceof Chunk) {\n+-                        Chunk chunk = (Chunk) ichunkaccess;\n+-\n+-                        this.world.unloadChunk(chunk);\n+-                    }\n++//                    if (this.loadedChunks.remove(i) && ichunkaccess instanceof Chunk) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5ODIyMA=="}, "originalCommit": {"oid": "a50fd75caaf393aaff6bb57b2773569529116ca3"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1810, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}