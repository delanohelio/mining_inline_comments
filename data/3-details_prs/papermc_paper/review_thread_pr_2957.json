{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MzA2Mjgy", "number": 2957, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwNzo0OTozMVrODgIDeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwNzo0OTozMVrODgIDeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDEyOTg1OnYy", "diffSide": "RIGHT", "path": "Spigot-Server-Patches/0004-MC-Utils.patch", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQwNzo0OTozMVrOFqMjYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQwMjo1NToxNVrOFqRfXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc5MDE3Nw==", "bodyText": "mimic doesn't have a k at the end", "url": "https://github.com/PaperMC/Paper/pull/2957#discussion_r379790177", "createdAt": "2020-02-15T07:49:31Z", "author": {"login": "metalshark"}, "path": "Spigot-Server-Patches/0004-MC-Utils.patch", "diffHunk": "@@ -2387,15 +2387,13 @@ index 000000000..9fa88d79d\n +    }\n +\n +    // assumes the sets have the same comparator, and if this comparator is null then assume T is Comparable\n-+    public static <T> void mergeSortedSets(final java.util.function.Consumer<T> consumer, final java.util.SortedSet<T>...sets) {\n-+        java.util.Comparator<? super T> comparator = sets[0].comparator();\n-+        if (comparator == null) {\n-+            comparator = (java.util.Comparator)java.util.Comparator.naturalOrder();\n-+        }\n++    public static <T> void mergeSortedSets(final java.util.function.Consumer<T> consumer, final java.util.Comparator<? super T> comparator, final java.util.SortedSet<T>...sets) {\n +        final it.unimi.dsi.fastutil.objects.ObjectRBTreeSet<T> all = new it.unimi.dsi.fastutil.objects.ObjectRBTreeSet<>(comparator);\n-+        // note: this is done in log(n!) ~ nlogn time. It could be improved if it were to mimic what mergesort does.\n++        // note: this is done in log(n!) ~ nlogn time. It could be improved if it were to mimick what mergesort does.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc3ff1f4c0ebdb9147d85207c10b0c1e788fd7a3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MTA2OQ==", "bodyText": "I guess", "url": "https://github.com/PaperMC/Paper/pull/2957#discussion_r379871069", "createdAt": "2020-02-16T02:55:15Z", "author": {"login": "Spottedleaf"}, "path": "Spigot-Server-Patches/0004-MC-Utils.patch", "diffHunk": "@@ -2387,15 +2387,13 @@ index 000000000..9fa88d79d\n +    }\n +\n +    // assumes the sets have the same comparator, and if this comparator is null then assume T is Comparable\n-+    public static <T> void mergeSortedSets(final java.util.function.Consumer<T> consumer, final java.util.SortedSet<T>...sets) {\n-+        java.util.Comparator<? super T> comparator = sets[0].comparator();\n-+        if (comparator == null) {\n-+            comparator = (java.util.Comparator)java.util.Comparator.naturalOrder();\n-+        }\n++    public static <T> void mergeSortedSets(final java.util.function.Consumer<T> consumer, final java.util.Comparator<? super T> comparator, final java.util.SortedSet<T>...sets) {\n +        final it.unimi.dsi.fastutil.objects.ObjectRBTreeSet<T> all = new it.unimi.dsi.fastutil.objects.ObjectRBTreeSet<>(comparator);\n-+        // note: this is done in log(n!) ~ nlogn time. It could be improved if it were to mimic what mergesort does.\n++        // note: this is done in log(n!) ~ nlogn time. It could be improved if it were to mimick what mergesort does.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc5MDE3Nw=="}, "originalCommit": {"oid": "bc3ff1f4c0ebdb9147d85207c10b0c1e788fd7a3"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1616, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}