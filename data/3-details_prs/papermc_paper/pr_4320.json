{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MDk2NjQ2", "number": 4320, "title": "Only consider chunks Loaded if at BORDER status", "bodyText": "DOWNLOAD LINK: https://cdn.discordapp.com/attachments/748269415497465927/754945012080312370/loaded-chunks-r2.jar\nWhile initial smoke test looks to be ok, this build presents a high risk of entity and tile entity lost if there is a bug that I did not see in my own testing.\nIt is super imperative that you have backups before testing this!\n\nThis greatly improves performance as it drastically reduces the amount\nof Entities and Tile Entities that are \"registered\" into the world, as\npurely \"cached\" chunks will no longer have their entities hanging out in the world.\nAdditionally this fixes our Entity Add To World and Entity Remove From World events\nThose events have not been firing correctly since MC changed how chunks work here.\nNow the server will only consider a chunk \"loaded\" if it's got a ticket putting\nit at level 33 or lower, which matches the public Bukkit API.\n\nBefore this, there are a ton of chunks in memory in a 'cached' state, they aren't considered \"loaded\" in the api, they arent in any players view distance, are not force loaded.\nWhen they are loaded and unloaded don't align with our expectation of \"load/unload\" events.\nLeaving A LOT of extra entities in memory. meaning more entities to iterate for ticking (which will then be \"skipped\" because not in correct chunk\") same with tile entities. also same issue applies for iterating chunks too, iterating far more than will end up being ticked resulting in a lot of checks to then skip it.\nThis change cuts it out so the iteration only operates on stuff in a loaded state now.", "createdAt": "2020-09-13T02:28:15Z", "url": "https://github.com/PaperMC/Paper/pull/4320", "merged": true, "mergeCommit": {"oid": "bd648dfb472289fb6ac7a4554c11f46b759f7a74"}, "closed": true, "closedAt": "2020-09-19T16:54:06Z", "author": {"login": "aikar"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJwB0ZgFqTQ5MDUzMTY4Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdKdBJvgBqjM3ODUzMjE2Njg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwNTMxNjgy", "url": "https://github.com/PaperMC/Paper/pull/4320#pullrequestreview-490531682", "createdAt": "2020-09-17T12:17:56Z", "commit": {"oid": "a50fd75caaf393aaff6bb57b2773569529116ca3"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjoxNzo1NlrOHTfRwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjoxOToyMlrOHTfUzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5NzQ0MA==", "bodyText": "Empty if statement", "url": "https://github.com/PaperMC/Paper/pull/4320#discussion_r490197440", "createdAt": "2020-09-17T12:17:56Z", "author": {"login": "unisteven"}, "path": "Spigot-Server-Patches/0580-Only-consider-chunks-Loaded-if-at-BORDER-status.patch", "diffHunk": "@@ -0,0 +1,158 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Aikar <aikar@aikar.co>\n+Date: Sat, 12 Sep 2020 22:20:55 -0400\n+Subject: [PATCH] Only consider chunks Loaded if at BORDER status\n+\n+This greatly improves performance as it drastically reduces the amount\n+of Entities and Tile Entities that are \"registered\" into the world, as\n+purely \"cached\" chunks will no longer have their entities hanging out in the world.\n+\n+Additionally this fixes our Entity Add To World and Entity Remove From World events\n+\n+Those events have not been firing correctly since MC changed how chunks work here.\n+\n+Now the server will only consider a chunk \"loaded\" if it's got a ticket putting\n+it at level 33 or lower, which matches the public Bukkit API.\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 299d7d7a55532930e2d4340a6cfe77a5fd8a0a0c..15c0a06139bffc6a7f83a1d47f2a708f14d264ec 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -791,6 +791,7 @@ public class Chunk implements IChunkAccess {\n+         int chunkX = this.loc.x;\n+         int chunkZ = this.loc.z;\n+         ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();\n++        chunkProvider.playerChunkMap.loadChunk(this); // Paper - move load logic from the entering full status to when it enters border status instead\n+         for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {\n+             for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {\n+                 Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);\n+@@ -862,6 +863,11 @@ public class Chunk implements IChunkAccess {\n+         this.loadedTicketLevel = false;\n+         this.resetNeighbours();\n+         // Paper end\n++        // Paper start - move unload logic from the actual full unload to be when it leaves border status\n++        chunkProvider.playerChunkMap.loadedChunks.remove(loc.longKey);\n++        setLoaded(false);\n++        this.world.unloadChunk(this);\n++        // Paper end\n+     }\n+     // CraftBukkit end\n+ \n+diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+index 45c142c227bc258bbd5c8c03c6012663dccf8f3f..d119d68bb69baecdd7b896e6efb41251fa226adb 100644\n+--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java\n++++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+@@ -19,6 +19,7 @@ import java.util.function.Supplier;\n+ import javax.annotation.Nullable;\n+ import com.destroystokyo.paper.exception.ServerInternalException;\n+ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper\n++import it.unimi.dsi.fastutil.longs.LongIterator; // Paper\n+ import org.apache.logging.log4j.LogManager;\n+ import org.apache.logging.log4j.Logger;\n+ \n+@@ -822,7 +823,9 @@ public class ChunkProviderServer extends IChunkProvider {\n+             //List<PlayerChunk> list = Lists.newArrayList(this.playerChunkMap.f()); // Paper\n+             //Collections.shuffle(list); // Paper\n+             // Paper - moved up\n+-            final int[] chunksTicked = {0}; this.playerChunkMap.forEachVisibleChunk((playerchunk) -> { // Paper - safe iterator incase chunk loads, also no wrapping\n++            final int[] chunksTicked = {0};\n++            for (LongIterator iterator = this.playerChunkMap.loadedChunks.iterator() ; iterator.hasNext() ; ) { // Paper - iterate only loaded chunks\n++                PlayerChunk playerchunk = this.playerChunkMap.getVisibleChunk(iterator.nextLong());// Paper - iterate only loaded chunks\n+                 Optional<Chunk> optional = ((Either) playerchunk.a().getNow(PlayerChunk.UNLOADED_CHUNK)).left();\n+ \n+                 if (optional.isPresent()) {\n+@@ -850,7 +853,7 @@ public class ChunkProviderServer extends IChunkProvider {\n+                         }\n+                     }\n+                 }\n+-            });\n++            };// Paper - use for instead of forEachVisibleChunk\n+             this.world.getMethodProfiler().enter(\"customSpawners\");\n+             if (flag1) {\n+                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index fcd3388d88aad6e897b73e2c823267ada327cbda..3f7da1a74eb881ddc30b20143c20fe162543c20f 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -1021,16 +1021,18 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                 this.a(i, playerchunk);\n+             } else {\n+                 if (this.pendingUnload.remove(i, playerchunk) && ichunkaccess != null) {\n++                    // Paper start - coment out and move to ChunkUnloadEvent\n+                     if (ichunkaccess instanceof Chunk) {\n+-                        ((Chunk) ichunkaccess).setLoaded(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50fd75caaf393aaff6bb57b2773569529116ca3"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5ODIyMA==", "bodyText": "Commented out code could be removed.", "url": "https://github.com/PaperMC/Paper/pull/4320#discussion_r490198220", "createdAt": "2020-09-17T12:19:22Z", "author": {"login": "unisteven"}, "path": "Spigot-Server-Patches/0580-Only-consider-chunks-Loaded-if-at-BORDER-status.patch", "diffHunk": "@@ -0,0 +1,158 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Aikar <aikar@aikar.co>\n+Date: Sat, 12 Sep 2020 22:20:55 -0400\n+Subject: [PATCH] Only consider chunks Loaded if at BORDER status\n+\n+This greatly improves performance as it drastically reduces the amount\n+of Entities and Tile Entities that are \"registered\" into the world, as\n+purely \"cached\" chunks will no longer have their entities hanging out in the world.\n+\n+Additionally this fixes our Entity Add To World and Entity Remove From World events\n+\n+Those events have not been firing correctly since MC changed how chunks work here.\n+\n+Now the server will only consider a chunk \"loaded\" if it's got a ticket putting\n+it at level 33 or lower, which matches the public Bukkit API.\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 299d7d7a55532930e2d4340a6cfe77a5fd8a0a0c..15c0a06139bffc6a7f83a1d47f2a708f14d264ec 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -791,6 +791,7 @@ public class Chunk implements IChunkAccess {\n+         int chunkX = this.loc.x;\n+         int chunkZ = this.loc.z;\n+         ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();\n++        chunkProvider.playerChunkMap.loadChunk(this); // Paper - move load logic from the entering full status to when it enters border status instead\n+         for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {\n+             for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {\n+                 Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);\n+@@ -862,6 +863,11 @@ public class Chunk implements IChunkAccess {\n+         this.loadedTicketLevel = false;\n+         this.resetNeighbours();\n+         // Paper end\n++        // Paper start - move unload logic from the actual full unload to be when it leaves border status\n++        chunkProvider.playerChunkMap.loadedChunks.remove(loc.longKey);\n++        setLoaded(false);\n++        this.world.unloadChunk(this);\n++        // Paper end\n+     }\n+     // CraftBukkit end\n+ \n+diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+index 45c142c227bc258bbd5c8c03c6012663dccf8f3f..d119d68bb69baecdd7b896e6efb41251fa226adb 100644\n+--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java\n++++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+@@ -19,6 +19,7 @@ import java.util.function.Supplier;\n+ import javax.annotation.Nullable;\n+ import com.destroystokyo.paper.exception.ServerInternalException;\n+ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper\n++import it.unimi.dsi.fastutil.longs.LongIterator; // Paper\n+ import org.apache.logging.log4j.LogManager;\n+ import org.apache.logging.log4j.Logger;\n+ \n+@@ -822,7 +823,9 @@ public class ChunkProviderServer extends IChunkProvider {\n+             //List<PlayerChunk> list = Lists.newArrayList(this.playerChunkMap.f()); // Paper\n+             //Collections.shuffle(list); // Paper\n+             // Paper - moved up\n+-            final int[] chunksTicked = {0}; this.playerChunkMap.forEachVisibleChunk((playerchunk) -> { // Paper - safe iterator incase chunk loads, also no wrapping\n++            final int[] chunksTicked = {0};\n++            for (LongIterator iterator = this.playerChunkMap.loadedChunks.iterator() ; iterator.hasNext() ; ) { // Paper - iterate only loaded chunks\n++                PlayerChunk playerchunk = this.playerChunkMap.getVisibleChunk(iterator.nextLong());// Paper - iterate only loaded chunks\n+                 Optional<Chunk> optional = ((Either) playerchunk.a().getNow(PlayerChunk.UNLOADED_CHUNK)).left();\n+ \n+                 if (optional.isPresent()) {\n+@@ -850,7 +853,7 @@ public class ChunkProviderServer extends IChunkProvider {\n+                         }\n+                     }\n+                 }\n+-            });\n++            };// Paper - use for instead of forEachVisibleChunk\n+             this.world.getMethodProfiler().enter(\"customSpawners\");\n+             if (flag1) {\n+                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index fcd3388d88aad6e897b73e2c823267ada327cbda..3f7da1a74eb881ddc30b20143c20fe162543c20f 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -1021,16 +1021,18 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                 this.a(i, playerchunk);\n+             } else {\n+                 if (this.pendingUnload.remove(i, playerchunk) && ichunkaccess != null) {\n++                    // Paper start - coment out and move to ChunkUnloadEvent\n+                     if (ichunkaccess instanceof Chunk) {\n+-                        ((Chunk) ichunkaccess).setLoaded(false);\n++                        //((Chunk) ichunkaccess).setLoaded(false);\n+                     }\n+ \n+                     //this.saveChunk(ichunkaccess);// Paper - delay\n+-                    if (this.loadedChunks.remove(i) && ichunkaccess instanceof Chunk) {\n+-                        Chunk chunk = (Chunk) ichunkaccess;\n+-\n+-                        this.world.unloadChunk(chunk);\n+-                    }\n++//                    if (this.loadedChunks.remove(i) && ichunkaccess instanceof Chunk) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a50fd75caaf393aaff6bb57b2773569529116ca3"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98934c11abb58070873332b73ff7ed3e982df59d", "author": {"user": {"login": "aikar", "name": "Daniel Ennis"}}, "url": "https://github.com/PaperMC/Paper/commit/98934c11abb58070873332b73ff7ed3e982df59d", "committedDate": "2020-09-19T16:44:29Z", "message": "Only consider chunks Loaded if at BORDER status\n\nThis greatly improves performance as it drastically reduces the amount\nof Entities and Tile Entities that are \"registered\" into the world, as\npurely \"cached\" chunks will no longer have their entities hanging out in the world.\n\nAdditionally this fixes our Entity Add To World and Entity Remove From World events\n\nThose events have not been firing correctly since MC changed how chunks work here.\n\nNow the server will only consider a chunk \"loaded\" if it's got a ticket putting\nit at level 33 or lower, which matches the public Bukkit API."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1839208ccf809cf0ff1c878826c9af227b89123", "author": {"user": {"login": "aikar", "name": "Daniel Ennis"}}, "url": "https://github.com/PaperMC/Paper/commit/a1839208ccf809cf0ff1c878826c9af227b89123", "committedDate": "2020-09-19T16:44:29Z", "message": "Optimize some methods for inlining\n\nAdds final to some methods to improve inlining ability"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a50fd75caaf393aaff6bb57b2773569529116ca3", "author": {"user": {"login": "aikar", "name": "Daniel Ennis"}}, "url": "https://github.com/PaperMC/Paper/commit/a50fd75caaf393aaff6bb57b2773569529116ca3", "committedDate": "2020-09-14T05:53:39Z", "message": "temp disable tick chunks loop change to prevent crash risk"}, "afterCommit": {"oid": "a1839208ccf809cf0ff1c878826c9af227b89123", "author": {"user": {"login": "aikar", "name": "Daniel Ennis"}}, "url": "https://github.com/PaperMC/Paper/commit/a1839208ccf809cf0ff1c878826c9af227b89123", "committedDate": "2020-09-19T16:44:29Z", "message": "Optimize some methods for inlining\n\nAdds final to some methods to improve inlining ability"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1583, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}