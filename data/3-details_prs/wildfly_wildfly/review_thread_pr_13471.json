{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0ODU2Mzc3", "number": 13471, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwNDowMjo1MVrOFVff9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwNDowMjo1MVrOFVff9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4MDgwNTAzOnYy", "diffSide": "RIGHT", "path": "weld/subsystem/src/main/java/org/jboss/as/weld/WeldBootstrapService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwNDowMjo1MVrOId-vNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQwNDoxNTozMFrOId-86Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODMwNzUwOQ==", "bodyText": "@stuartwdouglas Can this result in listenerDone not completing and fakeStabilityService leaking?", "url": "https://github.com/wildfly/wildfly/pull/13471#discussion_r568307509", "createdAt": "2021-02-02T04:02:51Z", "author": {"login": "bstansberry"}, "path": "weld/subsystem/src/main/java/org/jboss/as/weld/WeldBootstrapService.java", "diffHunk": "@@ -236,8 +305,91 @@ public boolean isStarted() {\n         return started;\n     }\n \n-    void setStarted(boolean started) {\n-        this.started = started;\n+    void startServiceShutdown() {\n+        //the start service has been shutdown, which means either we are being shutdown/undeployed\n+        //or we are going to need to bounce the whole deployment\n+        this.started = false;\n+        if (controller.getServiceContainer().isShutdown()) {\n+            //container is being shutdown, no action required\n+            return;\n+        }\n+        ServiceController<?> deploymentController = controller.getServiceContainer().getService(deploymentServiceName);\n+        if (deploymentController.getMode() != ServiceController.Mode.ACTIVE) {\n+            //deployment is not active, no action required\n+            return;\n+        }\n+        //add a listener to tentatively 'bounce' this service\n+        //if the service does actually restart then this will trigger a full deployment restart\n+        //we do it this way as we don't have visibility into MSC in the general sense\n+        //so we don't really know if this service is supposed to go away\n+        //this 'potential bounce' is hard to do in a non-racey manner\n+        //we need to add the listener first, but the listener may be invoked before the CAS to never\n+        CompletableFuture<Boolean> attemptingBounce = new CompletableFuture();\n+\n+        try {\n+            CompletableFuture<Boolean> listenerDone = new CompletableFuture<>();\n+            LifecycleListener listener = new LifecycleListener() {\n+                @Override\n+                public void handleEvent(final ServiceController<?> controller, final LifecycleEvent event) {\n+                    try {\n+                        try {\n+                            if (controller.getServiceContainer().isShutdown() || !attemptingBounce.get()) {\n+                                controller.removeListener(this);\n+                                return;\n+                            }\n+                        } catch (InterruptedException | ExecutionException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        if (deploymentController.getMode() != ServiceController.Mode.ACTIVE ||\n+                                controller.getMode() == ServiceController.Mode.REMOVE) {\n+                            return;\n+                        }\n+                        if (event == LifecycleEvent.DOWN) {\n+                            controller.removeListener(this);\n+                            do {\n+                                if (controller.getMode() != ServiceController.Mode.NEVER) {\n+                                    return;\n+                                }\n+                            } while (!controller.compareAndSetMode(ServiceController.Mode.NEVER, ServiceController.Mode.ACTIVE));\n+                        }\n+                    } finally {\n+                        listenerDone.complete(true);\n+                    }\n+                }\n+            };\n+            //\n+            controller.getServiceContainer().addService(controller.getName().append(\"fakeStabilityService\")).setInstance(new Service() {\n+                @Override\n+                public void start(StartContext context) throws StartException {\n+                    context.asynchronous();\n+                    listenerDone.handle(new BiFunction<Boolean, Throwable, Object>() {\n+                        @Override\n+                        public Object apply(Boolean aBoolean, Throwable throwable) {\n+                            context.getController().setMode(ServiceController.Mode.REMOVE);\n+                            context.complete();\n+                            return null;\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void stop(StopContext context) {\n+\n+                }\n+            }).install();\n+            controller.addListener(listener);\n+            if (!controller.compareAndSetMode(ServiceController.Mode.ACTIVE, ServiceController.Mode.NEVER)) {\n+                controller.removeListener(listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d5f0a390c23c1c9c330bc4ea4d2175ccd1527e4"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODMxMTAxNw==", "bodyText": "Yes, fixed.\nThis whole thing is a horrible hack.", "url": "https://github.com/wildfly/wildfly/pull/13471#discussion_r568311017", "createdAt": "2021-02-02T04:15:30Z", "author": {"login": "stuartwdouglas"}, "path": "weld/subsystem/src/main/java/org/jboss/as/weld/WeldBootstrapService.java", "diffHunk": "@@ -236,8 +305,91 @@ public boolean isStarted() {\n         return started;\n     }\n \n-    void setStarted(boolean started) {\n-        this.started = started;\n+    void startServiceShutdown() {\n+        //the start service has been shutdown, which means either we are being shutdown/undeployed\n+        //or we are going to need to bounce the whole deployment\n+        this.started = false;\n+        if (controller.getServiceContainer().isShutdown()) {\n+            //container is being shutdown, no action required\n+            return;\n+        }\n+        ServiceController<?> deploymentController = controller.getServiceContainer().getService(deploymentServiceName);\n+        if (deploymentController.getMode() != ServiceController.Mode.ACTIVE) {\n+            //deployment is not active, no action required\n+            return;\n+        }\n+        //add a listener to tentatively 'bounce' this service\n+        //if the service does actually restart then this will trigger a full deployment restart\n+        //we do it this way as we don't have visibility into MSC in the general sense\n+        //so we don't really know if this service is supposed to go away\n+        //this 'potential bounce' is hard to do in a non-racey manner\n+        //we need to add the listener first, but the listener may be invoked before the CAS to never\n+        CompletableFuture<Boolean> attemptingBounce = new CompletableFuture();\n+\n+        try {\n+            CompletableFuture<Boolean> listenerDone = new CompletableFuture<>();\n+            LifecycleListener listener = new LifecycleListener() {\n+                @Override\n+                public void handleEvent(final ServiceController<?> controller, final LifecycleEvent event) {\n+                    try {\n+                        try {\n+                            if (controller.getServiceContainer().isShutdown() || !attemptingBounce.get()) {\n+                                controller.removeListener(this);\n+                                return;\n+                            }\n+                        } catch (InterruptedException | ExecutionException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        if (deploymentController.getMode() != ServiceController.Mode.ACTIVE ||\n+                                controller.getMode() == ServiceController.Mode.REMOVE) {\n+                            return;\n+                        }\n+                        if (event == LifecycleEvent.DOWN) {\n+                            controller.removeListener(this);\n+                            do {\n+                                if (controller.getMode() != ServiceController.Mode.NEVER) {\n+                                    return;\n+                                }\n+                            } while (!controller.compareAndSetMode(ServiceController.Mode.NEVER, ServiceController.Mode.ACTIVE));\n+                        }\n+                    } finally {\n+                        listenerDone.complete(true);\n+                    }\n+                }\n+            };\n+            //\n+            controller.getServiceContainer().addService(controller.getName().append(\"fakeStabilityService\")).setInstance(new Service() {\n+                @Override\n+                public void start(StartContext context) throws StartException {\n+                    context.asynchronous();\n+                    listenerDone.handle(new BiFunction<Boolean, Throwable, Object>() {\n+                        @Override\n+                        public Object apply(Boolean aBoolean, Throwable throwable) {\n+                            context.getController().setMode(ServiceController.Mode.REMOVE);\n+                            context.complete();\n+                            return null;\n+                        }\n+                    });\n+                }\n+\n+                @Override\n+                public void stop(StopContext context) {\n+\n+                }\n+            }).install();\n+            controller.addListener(listener);\n+            if (!controller.compareAndSetMode(ServiceController.Mode.ACTIVE, ServiceController.Mode.NEVER)) {\n+                controller.removeListener(listener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODMwNzUwOQ=="}, "originalCommit": {"oid": "9d5f0a390c23c1c9c330bc4ea4d2175ccd1527e4"}, "originalPosition": 279}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4250, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}