{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NTAzMTky", "number": 4248, "title": "[GEOS-9625] Add filtering support in json-ld module", "bodyText": "Jira ticket https://osgeo-org.atlassian.net/browse/GEOS-9625\nThis pull request add filtering capabilities in the Json-ld  module to have control over the final output.\nSupported syntax is the following:\n\nArrays below the source attribute, \"$filter\":\"{some filter}\"\nObject below the source attribute, \"$filter\":\"{some filter}\"\nAttribute before the static or dynamic attribute: \"key\": \"$filter{some filter},\"static value or expression\"\n\nChecklist\n\nReviewing is a process done by project maintainers, mostly on a volunteer basis. We try to keep the overhead as small as possible and appreciate if you help us to do so by completing the following items. Feel free to ask in a comment if you have troubles with any of them.\n\nFor all pull requests:\n\n Confirm you have read the contribution guidelines\n You have sent a Contribution Licence Agreement (CLA) as necessary (not required for small changes, e.g., fixing typos in documentation)\n Make sure the first PR targets the master branch, eventual backports will be managed later. This can be ignored if the PR is fixing an issue that only happens in a specific branch, but not in newer ones.\n\nThe following are required only for core and extension modules (they are welcomed, but not required, for community modules):\n\n There is a ticket in Jira describing the issue/improvement/feature (a notable exemptions is, changes not visible to end users)\n PR for bug fixes and small new features are presented as a single commit\n Commit message must be in the form \"[GEOS-XYZW] Title of the Jira ticket\" (export to XML in Jira generates the message in this exact form)\n The pull request contains changes related to a single objective. If multiple focuses cannot be avoided, each one is in its own commit and has a separate ticket describing it.\n New unit tests have been added covering the changes\n This PR passes all existing unit tests (test results will be reported by travis-ci after opening this PR)\n This PR passes the QA checks (QA checks results will be reported by travis-ci after opening this PR)\n Commits changing the UI, existing user workflows, or adding new functionality, need to include documentation updates (screenshots, text)\n Commits changing the REST API, or any configuration object, should check if the REST API docs (Swagger YAML files and classic documentation) need to be updated.\n\nSubmitting the PR does not require you to check all items, but by the time it gets merged, they should be either satisfied or inapplicable.", "createdAt": "2020-05-18T13:30:11Z", "url": "https://github.com/geoserver/geoserver/pull/4248", "merged": true, "mergeCommit": {"oid": "e1f9275e5bf24d8ba63cc2e03f97320ab6328492"}, "closed": true, "closedAt": "2020-06-05T08:18:44Z", "author": {"login": "taba90"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABciiE00gH2gAyNDE5NTAzMTkyOjdhZjRiNmU0ODExMDgzMWI4MmQ5YzVlMzY3NGJjOWEzZjA0MjgwYTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoOPSGgFqTQyNTA5MTU5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7af4b6e48110831b82d9c5e3674bc9a3f04280a4", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/7af4b6e48110831b82d9c5e3674bc9a3f04280a4", "committedDate": "2020-05-18T16:01:33Z", "message": "[GEOS-9625] Add filtering support in json-ld module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5ba2d0bcf8e2ce3436b26c2076d082042fbad68", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/e5ba2d0bcf8e2ce3436b26c2076d082042fbad68", "committedDate": "2020-05-18T16:01:33Z", "message": "add validation for filter and changes for better class readability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/fa265e67c1d6f2e2fb1201370f613df483cafcfa", "committedDate": "2020-05-18T16:01:33Z", "message": "tests and documentation updates"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f187b306f4119daeb92538dca5a254e344313a0b", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/f187b306f4119daeb92538dca5a254e344313a0b", "committedDate": "2020-05-18T13:28:22Z", "message": "tests and documentation updates"}, "afterCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/fa265e67c1d6f2e2fb1201370f613df483cafcfa", "committedDate": "2020-05-18T16:01:33Z", "message": "tests and documentation updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MjM1MTQx", "url": "https://github.com/geoserver/geoserver/pull/4248#pullrequestreview-424235141", "createdAt": "2020-06-04T08:51:58Z", "commit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODo1MTo1OFrOGe8HlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOTowNDowOVrOGe8kuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTQ0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.\n          \n          \n            \n            In the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"`, followed by  the cql expression, or by the static content, with a comma separating the two.", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435095444", "createdAt": "2020-06-04T08:51:58Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/community/json-ld/configuration.rst", "diffHunk": "@@ -116,3 +116,104 @@ The content of the json-ld output depends on specified properties in json-ld tem\n * a :code:`\"$source\":\"xpath\"` attribute can be added as the first element of an array or of an object;\n * if a :code:`\"$source\": \"xpath\"` attribute is present, it will act as a context against which all xpath expression will be evaluated. In the case of an array it will be use to iterate over a collection of element; if source evaluates to null the entire object/array will be skipped;\n * a :code:`../` syntax in an xpath means that xpath evaluation will be relative to the previous :code:`$source`. Give the above template file, the xpath :code:`\"../gsml:shape\"` will be evaluate not against the corresponding :code:`\"$source\": \"gsml:specification/gsml:GeologicUnit\"`, but against the parent one :code:`\"$source\": \"gsml:MappedFeature\"`.\n+\n+\n+Filtering Support\n+------------------\n+\n+In order to have a more fined grained control over the output it is possible to specify a filter at the array, object and attribute level.\n+Assuming to have a template file like the above, valid filters could be the followings:\n+\n+array \n+\n+.. code-block:: json\n+\n+ {\n+   \"lithology\":[\n+      {\n+         \"$source\":\"gsml:lithology\",\n+         \"$filter\":\"xpath('gsml:ControlledConcept/gsml:name') = 'name_2'\"\n+      },\n+      {\n+         \"@id\":\"${gsml:ControlledConcept/@id}\",\n+         \"name\":{\n+            \"value\":\"${gsml:ControlledConcept/gsml:name}\",\n+            \"@lang\":\"en\"\n+         },\n+         \"vocabulary\":{\n+            \"@href\":\"urn:ogc:def:nil:OGC::missing\"\n+         }\n+      }\n+   ]\n+ }\n+\n+\n+object \n+\n+.. code-block:: json\n+\n+ {\n+   \"gsml:GeologicUnit\":{\n+      \"$source\":\"gsml:specification/gsml:GeologicUnit\",\n+      \"$filter\":\"xpath('gml:description') = 'Olivine basalt'\",\n+      \"@id\":\"${@id}\",\n+      \"description\":\"${gml:description}\",\n+      \"gsml:geologicUnitType\":\"urn:ogc:def:nil:OGC::unknown\",\n+      \"gsml:composition\":\"...\"\n+   }\n+ }\n+\n+\n+\n+attribute (dynamic) \n+\n+.. code-block:: json\n+\n+  {\n+  \"gsml:GeologicUnit\": {\n+        \"$source\": \"gsml:specification/gsml:GeologicUnit\",\n+        \"@id\": \"${@id}\",\n+        \"description\": \"$filter{xpath('gml:description')='Olivine basalt'},${gml:description}\",\n+        \"gsml:geologicUnitType\": \"urn:ogc:def:nil:OGC::unknown\",\n+        \"gsml:composition\": \"...\"\n+    }\n+  }\n+\n+\n+attribute (static) \n+\n+.. code-block:: json\n+\n+   {\n+   \"gsml:composition\":[\n+      {\n+         \"$source\":\"gsml:composition\"\n+      },\n+      {\n+         \"gsml:compositionPart\":[\n+            {\n+               \"$source\":\"gsml:CompositionPart\"\n+            },\n+            {\n+               \"gsml:role\":{\n+                  \"value\":\"${gsml:role}\",\n+                  \"@codeSpace\":\"$filter{xpath('../../gml:description')='Olivine basalt'},urn:cgi:classifierScheme:Example:CompositionPartRole\"\n+               }\n+            }\n+         ]\n+      }\n+   ]\n+ }\n+\n+\n+\n+As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTg3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              * in the array case, each of its element will be included in the output if the condition in the filter condition is true;\n          \n          \n            \n              * in the array case, elements will be included in the output only if the condition in the filter is matched;", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435095879", "createdAt": "2020-06-04T08:52:43Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/community/json-ld/configuration.rst", "diffHunk": "@@ -116,3 +116,104 @@ The content of the json-ld output depends on specified properties in json-ld tem\n * a :code:`\"$source\":\"xpath\"` attribute can be added as the first element of an array or of an object;\n * if a :code:`\"$source\": \"xpath\"` attribute is present, it will act as a context against which all xpath expression will be evaluated. In the case of an array it will be use to iterate over a collection of element; if source evaluates to null the entire object/array will be skipped;\n * a :code:`../` syntax in an xpath means that xpath evaluation will be relative to the previous :code:`$source`. Give the above template file, the xpath :code:`\"../gsml:shape\"` will be evaluate not against the corresponding :code:`\"$source\": \"gsml:specification/gsml:GeologicUnit\"`, but against the parent one :code:`\"$source\": \"gsml:MappedFeature\"`.\n+\n+\n+Filtering Support\n+------------------\n+\n+In order to have a more fined grained control over the output it is possible to specify a filter at the array, object and attribute level.\n+Assuming to have a template file like the above, valid filters could be the followings:\n+\n+array \n+\n+.. code-block:: json\n+\n+ {\n+   \"lithology\":[\n+      {\n+         \"$source\":\"gsml:lithology\",\n+         \"$filter\":\"xpath('gsml:ControlledConcept/gsml:name') = 'name_2'\"\n+      },\n+      {\n+         \"@id\":\"${gsml:ControlledConcept/@id}\",\n+         \"name\":{\n+            \"value\":\"${gsml:ControlledConcept/gsml:name}\",\n+            \"@lang\":\"en\"\n+         },\n+         \"vocabulary\":{\n+            \"@href\":\"urn:ogc:def:nil:OGC::missing\"\n+         }\n+      }\n+   ]\n+ }\n+\n+\n+object \n+\n+.. code-block:: json\n+\n+ {\n+   \"gsml:GeologicUnit\":{\n+      \"$source\":\"gsml:specification/gsml:GeologicUnit\",\n+      \"$filter\":\"xpath('gml:description') = 'Olivine basalt'\",\n+      \"@id\":\"${@id}\",\n+      \"description\":\"${gml:description}\",\n+      \"gsml:geologicUnitType\":\"urn:ogc:def:nil:OGC::unknown\",\n+      \"gsml:composition\":\"...\"\n+   }\n+ }\n+\n+\n+\n+attribute (dynamic) \n+\n+.. code-block:: json\n+\n+  {\n+  \"gsml:GeologicUnit\": {\n+        \"$source\": \"gsml:specification/gsml:GeologicUnit\",\n+        \"@id\": \"${@id}\",\n+        \"description\": \"$filter{xpath('gml:description')='Olivine basalt'},${gml:description}\",\n+        \"gsml:geologicUnitType\": \"urn:ogc:def:nil:OGC::unknown\",\n+        \"gsml:composition\": \"...\"\n+    }\n+  }\n+\n+\n+attribute (static) \n+\n+.. code-block:: json\n+\n+   {\n+   \"gsml:composition\":[\n+      {\n+         \"$source\":\"gsml:composition\"\n+      },\n+      {\n+         \"gsml:compositionPart\":[\n+            {\n+               \"$source\":\"gsml:CompositionPart\"\n+            },\n+            {\n+               \"gsml:role\":{\n+                  \"value\":\"${gsml:role}\",\n+                  \"@codeSpace\":\"$filter{xpath('../../gml:description')='Olivine basalt'},urn:cgi:classifierScheme:Example:CompositionPartRole\"\n+               }\n+            }\n+         ]\n+      }\n+   ]\n+ }\n+\n+\n+\n+As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.\n+The evaluation of a filter is handled by the module in the following way:\n+\n+* if a :code:`\"$filter\": \"cql\"` attribute is present after the :code:`\"$source\"` attribute in an array or an object:\n+  * in the array case, each of its element will be included in the output if the condition in the filter condition is true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjEzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              * in the object case, the entire object will be included in the output if the condition in the filter condition is true;\n          \n          \n            \n              * in the object case, the object will be included in the output if the condition in the filter condition is matched, otherwise the object will be skipped;", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435096131", "createdAt": "2020-06-04T08:53:09Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/community/json-ld/configuration.rst", "diffHunk": "@@ -116,3 +116,104 @@ The content of the json-ld output depends on specified properties in json-ld tem\n * a :code:`\"$source\":\"xpath\"` attribute can be added as the first element of an array or of an object;\n * if a :code:`\"$source\": \"xpath\"` attribute is present, it will act as a context against which all xpath expression will be evaluated. In the case of an array it will be use to iterate over a collection of element; if source evaluates to null the entire object/array will be skipped;\n * a :code:`../` syntax in an xpath means that xpath evaluation will be relative to the previous :code:`$source`. Give the above template file, the xpath :code:`\"../gsml:shape\"` will be evaluate not against the corresponding :code:`\"$source\": \"gsml:specification/gsml:GeologicUnit\"`, but against the parent one :code:`\"$source\": \"gsml:MappedFeature\"`.\n+\n+\n+Filtering Support\n+------------------\n+\n+In order to have a more fined grained control over the output it is possible to specify a filter at the array, object and attribute level.\n+Assuming to have a template file like the above, valid filters could be the followings:\n+\n+array \n+\n+.. code-block:: json\n+\n+ {\n+   \"lithology\":[\n+      {\n+         \"$source\":\"gsml:lithology\",\n+         \"$filter\":\"xpath('gsml:ControlledConcept/gsml:name') = 'name_2'\"\n+      },\n+      {\n+         \"@id\":\"${gsml:ControlledConcept/@id}\",\n+         \"name\":{\n+            \"value\":\"${gsml:ControlledConcept/gsml:name}\",\n+            \"@lang\":\"en\"\n+         },\n+         \"vocabulary\":{\n+            \"@href\":\"urn:ogc:def:nil:OGC::missing\"\n+         }\n+      }\n+   ]\n+ }\n+\n+\n+object \n+\n+.. code-block:: json\n+\n+ {\n+   \"gsml:GeologicUnit\":{\n+      \"$source\":\"gsml:specification/gsml:GeologicUnit\",\n+      \"$filter\":\"xpath('gml:description') = 'Olivine basalt'\",\n+      \"@id\":\"${@id}\",\n+      \"description\":\"${gml:description}\",\n+      \"gsml:geologicUnitType\":\"urn:ogc:def:nil:OGC::unknown\",\n+      \"gsml:composition\":\"...\"\n+   }\n+ }\n+\n+\n+\n+attribute (dynamic) \n+\n+.. code-block:: json\n+\n+  {\n+  \"gsml:GeologicUnit\": {\n+        \"$source\": \"gsml:specification/gsml:GeologicUnit\",\n+        \"@id\": \"${@id}\",\n+        \"description\": \"$filter{xpath('gml:description')='Olivine basalt'},${gml:description}\",\n+        \"gsml:geologicUnitType\": \"urn:ogc:def:nil:OGC::unknown\",\n+        \"gsml:composition\": \"...\"\n+    }\n+  }\n+\n+\n+attribute (static) \n+\n+.. code-block:: json\n+\n+   {\n+   \"gsml:composition\":[\n+      {\n+         \"$source\":\"gsml:composition\"\n+      },\n+      {\n+         \"gsml:compositionPart\":[\n+            {\n+               \"$source\":\"gsml:CompositionPart\"\n+            },\n+            {\n+               \"gsml:role\":{\n+                  \"value\":\"${gsml:role}\",\n+                  \"@codeSpace\":\"$filter{xpath('../../gml:description')='Olivine basalt'},urn:cgi:classifierScheme:Example:CompositionPartRole\"\n+               }\n+            }\n+         ]\n+      }\n+   ]\n+ }\n+\n+\n+\n+As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.\n+The evaluation of a filter is handled by the module in the following way:\n+\n+* if a :code:`\"$filter\": \"cql\"` attribute is present after the :code:`\"$source\"` attribute in an array or an object:\n+  * in the array case, each of its element will be included in the output if the condition in the filter condition is true;\n+  * in the object case, the entire object will be included in the output if the condition in the filter condition is true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjQ3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * if a :code:`$filter{cql}` is present inside an attribute value before the expression or the static content, separated by it from a :code:`,`:\n          \n          \n            \n            * if a :code:`$filter{cql}` is present inside an attribute value before the expression or static content:", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435096478", "createdAt": "2020-06-04T08:53:40Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/community/json-ld/configuration.rst", "diffHunk": "@@ -116,3 +116,104 @@ The content of the json-ld output depends on specified properties in json-ld tem\n * a :code:`\"$source\":\"xpath\"` attribute can be added as the first element of an array or of an object;\n * if a :code:`\"$source\": \"xpath\"` attribute is present, it will act as a context against which all xpath expression will be evaluated. In the case of an array it will be use to iterate over a collection of element; if source evaluates to null the entire object/array will be skipped;\n * a :code:`../` syntax in an xpath means that xpath evaluation will be relative to the previous :code:`$source`. Give the above template file, the xpath :code:`\"../gsml:shape\"` will be evaluate not against the corresponding :code:`\"$source\": \"gsml:specification/gsml:GeologicUnit\"`, but against the parent one :code:`\"$source\": \"gsml:MappedFeature\"`.\n+\n+\n+Filtering Support\n+------------------\n+\n+In order to have a more fined grained control over the output it is possible to specify a filter at the array, object and attribute level.\n+Assuming to have a template file like the above, valid filters could be the followings:\n+\n+array \n+\n+.. code-block:: json\n+\n+ {\n+   \"lithology\":[\n+      {\n+         \"$source\":\"gsml:lithology\",\n+         \"$filter\":\"xpath('gsml:ControlledConcept/gsml:name') = 'name_2'\"\n+      },\n+      {\n+         \"@id\":\"${gsml:ControlledConcept/@id}\",\n+         \"name\":{\n+            \"value\":\"${gsml:ControlledConcept/gsml:name}\",\n+            \"@lang\":\"en\"\n+         },\n+         \"vocabulary\":{\n+            \"@href\":\"urn:ogc:def:nil:OGC::missing\"\n+         }\n+      }\n+   ]\n+ }\n+\n+\n+object \n+\n+.. code-block:: json\n+\n+ {\n+   \"gsml:GeologicUnit\":{\n+      \"$source\":\"gsml:specification/gsml:GeologicUnit\",\n+      \"$filter\":\"xpath('gml:description') = 'Olivine basalt'\",\n+      \"@id\":\"${@id}\",\n+      \"description\":\"${gml:description}\",\n+      \"gsml:geologicUnitType\":\"urn:ogc:def:nil:OGC::unknown\",\n+      \"gsml:composition\":\"...\"\n+   }\n+ }\n+\n+\n+\n+attribute (dynamic) \n+\n+.. code-block:: json\n+\n+  {\n+  \"gsml:GeologicUnit\": {\n+        \"$source\": \"gsml:specification/gsml:GeologicUnit\",\n+        \"@id\": \"${@id}\",\n+        \"description\": \"$filter{xpath('gml:description')='Olivine basalt'},${gml:description}\",\n+        \"gsml:geologicUnitType\": \"urn:ogc:def:nil:OGC::unknown\",\n+        \"gsml:composition\": \"...\"\n+    }\n+  }\n+\n+\n+attribute (static) \n+\n+.. code-block:: json\n+\n+   {\n+   \"gsml:composition\":[\n+      {\n+         \"$source\":\"gsml:composition\"\n+      },\n+      {\n+         \"gsml:compositionPart\":[\n+            {\n+               \"$source\":\"gsml:CompositionPart\"\n+            },\n+            {\n+               \"gsml:role\":{\n+                  \"value\":\"${gsml:role}\",\n+                  \"@codeSpace\":\"$filter{xpath('../../gml:description')='Olivine basalt'},urn:cgi:classifierScheme:Example:CompositionPartRole\"\n+               }\n+            }\n+         ]\n+      }\n+   ]\n+ }\n+\n+\n+\n+As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.\n+The evaluation of a filter is handled by the module in the following way:\n+\n+* if a :code:`\"$filter\": \"cql\"` attribute is present after the :code:`\"$source\"` attribute in an array or an object:\n+  * in the array case, each of its element will be included in the output if the condition in the filter condition is true;\n+  * in the object case, the entire object will be included in the output if the condition in the filter condition is true;\n+\n+* if a :code:`$filter{cql}` is present inside an attribute value before the expression or the static content, separated by it from a :code:`,`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NzU1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              * in case of a static content attribute, the static content will be included in the output if the filter condition is true.\n          \n          \n            \n              * in case of a static content attribute, the static content will be included in the output if the filter condition is true.\n          \n          \n            \n              * in case the expression is not matched, the content, static or dynamic, will not be set, resulting in the attribute being skipped.\n          \n      \n    \n    \n  \n\nIs the attribute going to be skipped, like I wrote, or encoded with a null value?", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435097559", "createdAt": "2020-06-04T08:55:24Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/community/json-ld/configuration.rst", "diffHunk": "@@ -116,3 +116,104 @@ The content of the json-ld output depends on specified properties in json-ld tem\n * a :code:`\"$source\":\"xpath\"` attribute can be added as the first element of an array or of an object;\n * if a :code:`\"$source\": \"xpath\"` attribute is present, it will act as a context against which all xpath expression will be evaluated. In the case of an array it will be use to iterate over a collection of element; if source evaluates to null the entire object/array will be skipped;\n * a :code:`../` syntax in an xpath means that xpath evaluation will be relative to the previous :code:`$source`. Give the above template file, the xpath :code:`\"../gsml:shape\"` will be evaluate not against the corresponding :code:`\"$source\": \"gsml:specification/gsml:GeologicUnit\"`, but against the parent one :code:`\"$source\": \"gsml:MappedFeature\"`.\n+\n+\n+Filtering Support\n+------------------\n+\n+In order to have a more fined grained control over the output it is possible to specify a filter at the array, object and attribute level.\n+Assuming to have a template file like the above, valid filters could be the followings:\n+\n+array \n+\n+.. code-block:: json\n+\n+ {\n+   \"lithology\":[\n+      {\n+         \"$source\":\"gsml:lithology\",\n+         \"$filter\":\"xpath('gsml:ControlledConcept/gsml:name') = 'name_2'\"\n+      },\n+      {\n+         \"@id\":\"${gsml:ControlledConcept/@id}\",\n+         \"name\":{\n+            \"value\":\"${gsml:ControlledConcept/gsml:name}\",\n+            \"@lang\":\"en\"\n+         },\n+         \"vocabulary\":{\n+            \"@href\":\"urn:ogc:def:nil:OGC::missing\"\n+         }\n+      }\n+   ]\n+ }\n+\n+\n+object \n+\n+.. code-block:: json\n+\n+ {\n+   \"gsml:GeologicUnit\":{\n+      \"$source\":\"gsml:specification/gsml:GeologicUnit\",\n+      \"$filter\":\"xpath('gml:description') = 'Olivine basalt'\",\n+      \"@id\":\"${@id}\",\n+      \"description\":\"${gml:description}\",\n+      \"gsml:geologicUnitType\":\"urn:ogc:def:nil:OGC::unknown\",\n+      \"gsml:composition\":\"...\"\n+   }\n+ }\n+\n+\n+\n+attribute (dynamic) \n+\n+.. code-block:: json\n+\n+  {\n+  \"gsml:GeologicUnit\": {\n+        \"$source\": \"gsml:specification/gsml:GeologicUnit\",\n+        \"@id\": \"${@id}\",\n+        \"description\": \"$filter{xpath('gml:description')='Olivine basalt'},${gml:description}\",\n+        \"gsml:geologicUnitType\": \"urn:ogc:def:nil:OGC::unknown\",\n+        \"gsml:composition\": \"...\"\n+    }\n+  }\n+\n+\n+attribute (static) \n+\n+.. code-block:: json\n+\n+   {\n+   \"gsml:composition\":[\n+      {\n+         \"$source\":\"gsml:composition\"\n+      },\n+      {\n+         \"gsml:compositionPart\":[\n+            {\n+               \"$source\":\"gsml:CompositionPart\"\n+            },\n+            {\n+               \"gsml:role\":{\n+                  \"value\":\"${gsml:role}\",\n+                  \"@codeSpace\":\"$filter{xpath('../../gml:description')='Olivine basalt'},urn:cgi:classifierScheme:Example:CompositionPartRole\"\n+               }\n+            }\n+         ]\n+      }\n+   ]\n+ }\n+\n+\n+\n+As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.\n+The evaluation of a filter is handled by the module in the following way:\n+\n+* if a :code:`\"$filter\": \"cql\"` attribute is present after the :code:`\"$source\"` attribute in an array or an object:\n+  * in the array case, each of its element will be included in the output if the condition in the filter condition is true;\n+  * in the object case, the entire object will be included in the output if the condition in the filter condition is true;\n+\n+* if a :code:`$filter{cql}` is present inside an attribute value before the expression or the static content, separated by it from a :code:`,`:\n+  * in case of an expression attribute, the result of the expression will be included in the output if the filter condition is true;\n+  * in case of a static content attribute, the static content will be included in the output if the filter condition is true.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5ODYxOQ==", "bodyText": "Ouch this makes for very heavy tests. Does not matter now that the tests are not run, but won't be good if/when the module upgrades to extension. It can be kept here and addressed at graduation time, just noting it will be trouble.", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435098619", "createdAt": "2020-06-04T08:57:10Z", "author": {"login": "aaime"}, "path": "src/community/json-ld/pom.xml", "diffHunk": "@@ -155,6 +155,26 @@\n         </dependency>\n     </dependencies>\n \n+    <build>\n+    <plugins>\n+    <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>2.15</version>\n+        <configuration>\n+            <runOrder>alphabetical</runOrder>\n+            <includes>\n+                <include>**/*Test.java</include>\n+            </includes>\n+            <reuseForks>false</reuseForks>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5OTEzNw==", "bodyText": "Public method without javadoc... but it seems it's in good company, and the module is unsupported, so eventually javadocs can be improved at the eventual graduation time, no need to do it now.", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435099137", "createdAt": "2020-06-04T08:58:00Z", "author": {"login": "aaime"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/JsonLdGenerator.java", "diffHunk": "@@ -133,6 +133,11 @@ public void writeResult(Object result) throws IOException {\n         }\n     }\n \n+    public void writeString(String entryName, String value) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMDE4Ng==", "bodyText": "Why couldn't this be written using a simple for loop? I don't see odd exit conditions.", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435100186", "createdAt": "2020-06-04T08:59:40Z", "author": {"login": "aaime"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/AbstractJsonBuilder.java", "diffHunk": "@@ -6,26 +6,60 @@\n \n import java.io.IOException;\n import org.geoserver.jsonld.JsonLdGenerator;\n+import org.geoserver.jsonld.builders.impl.JsonBuilderContext;\n+import org.geoserver.jsonld.expressions.JsonLdCqlManager;\n+import org.geotools.filter.text.cql2.CQLException;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.expression.*;\n+import org.xml.sax.helpers.NamespaceSupport;\n \n /** Abstract implementation of {@link JsonBuilder} who groups some common attributes and methods. */\n public abstract class AbstractJsonBuilder implements JsonBuilder {\n \n     protected String key;\n \n-    public AbstractJsonBuilder(String key) {\n+    protected Filter filter;\n+\n+    protected int filterContextPos = 0;\n+\n+    protected NamespaceSupport namespaces;\n+\n+    public AbstractJsonBuilder(String key, NamespaceSupport namespaces) {\n         this.key = key;\n+        this.namespaces = namespaces;\n     }\n \n     protected void writeKey(JsonLdGenerator writer) throws IOException {\n         if (key != null && !key.equals(\"\")) writer.writeFieldName(key);\n         else throw new RuntimeException(\"Cannot write null key value\");\n     }\n \n+    protected boolean evaluateFilter(JsonBuilderContext context) {\n+        if (filter == null) return true;\n+        int i = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMDU3Mw==", "bodyText": "Commented out code, please remove.", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435100573", "createdAt": "2020-06-04T09:00:16Z", "author": {"login": "aaime"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -38,65 +33,42 @@\n     private static final Logger LOGGER = Logging.getLogger(DynamicValueBuilder.class);\n \n     public DynamicValueBuilder(String key, String expression, NamespaceSupport namespaces) {\n-        super(key);\n+        super(key, namespaces);\n         this.namespaces = namespaces;\n+        JsonLdCqlManager cqlManager = new JsonLdCqlManager(expression, namespaces);\n         if (expression.startsWith(\"$${\")) {\n-            strCqlToExpression(expression);\n+            this.cql = cqlManager.getExpressionFromString();\n+            // strCqlToExpression(expression);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMDYyNQ==", "bodyText": "Commented out code, please remove.", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435100625", "createdAt": "2020-06-04T09:00:22Z", "author": {"login": "aaime"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -38,65 +33,42 @@\n     private static final Logger LOGGER = Logging.getLogger(DynamicValueBuilder.class);\n \n     public DynamicValueBuilder(String key, String expression, NamespaceSupport namespaces) {\n-        super(key);\n+        super(key, namespaces);\n         this.namespaces = namespaces;\n+        JsonLdCqlManager cqlManager = new JsonLdCqlManager(expression, namespaces);\n         if (expression.startsWith(\"$${\")) {\n-            strCqlToExpression(expression);\n+            this.cql = cqlManager.getExpressionFromString();\n+            // strCqlToExpression(expression);\n         } else if (expression.startsWith(\"${\")) {\n-            strXpathToPropertyName(expression);\n+            this.xpath = cqlManager.getAttributeExpressionFromString();\n+            // strXpathToPropertyName(expression);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMjI2Mw==", "bodyText": "What if the filter itself contains a comma? (a CQL filter can contain a \"in\" operator that uses it, or might have a string literal containing it).", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435102263", "createdAt": "2020-06-04T09:03:04Z", "author": {"login": "aaime"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/configuration/JsonLdTemplateReader.java", "diffHunk": "@@ -121,13 +136,47 @@ private void getBuilderFromJsonArray(\n \n     private void getBuilderFromJsonAttribute(\n             String nodeName, JsonNode node, JsonBuilder currentBuilder) {\n+        String strNode = node.asText();\n+        String filter = null;\n+        if (strNode.contains(FILTERKEY)) {\n+            String[] arrNode = strNode.split(\",\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMjkwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class JsonLdCqlManager {\n          \n          \n            \n            public class JsonLdCQLManager {\n          \n      \n    \n    \n  \n\nDoes the class need to be public?", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435102905", "createdAt": "2020-06-04T09:04:09Z", "author": {"login": "aaime"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/expressions/JsonLdCqlManager.java", "diffHunk": "@@ -1,38 +1,125 @@\n-/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n  * This code is licensed under the GPL 2.0 license, available at the root\n  * application directory.\n  */\n package org.geoserver.jsonld.expressions;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import org.geoserver.jsonld.builders.impl.JsonBuilderContext;\n-import org.geotools.data.complex.feature.type.ComplexFeatureTypeImpl;\n import org.geotools.factory.CommonFactoryFinder;\n-import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n import org.geotools.filter.text.cql2.CQLException;\n import org.geotools.filter.text.ecql.ECQL;\n-import org.opengis.feature.type.FeatureType;\n+import org.geotools.filter.visitor.DuplicatingFilterVisitor;\n+import org.opengis.filter.Filter;\n import org.opengis.filter.FilterFactory;\n import org.opengis.filter.expression.Expression;\n+import org.opengis.filter.expression.Literal;\n import org.xml.sax.helpers.NamespaceSupport;\n \n /**\n  * Helper class that mainly allows the extraction of CQL and Xpath expressions out of a plain text\n- * string using special separators. It also provides some Utility methods to handle namespaces and\n- * xpath syntax\n+ * string using special separators. Moreover, since JsonLd templates can declare an xpath('some\n+ * xpath') function that has no real FunctionExpression implementation, this class provides methods\n+ * to extracts the xpath from the function as a literal, to substitute it after cql encoding\n+ * happened with an AttributeExpression.\n  */\n-public class ExpressionsUtils {\n+public class JsonLdCqlManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca1763b490e951afd15222c8a382180af65eb3c0", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/ca1763b490e951afd15222c8a382180af65eb3c0", "committedDate": "2020-06-04T09:52:55Z", "message": "reviewer's suggestion applied"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDkxNTk5", "url": "https://github.com/geoserver/geoserver/pull/4248#pullrequestreview-425091599", "createdAt": "2020-06-05T08:18:25Z", "commit": {"oid": "ca1763b490e951afd15222c8a382180af65eb3c0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1443, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}