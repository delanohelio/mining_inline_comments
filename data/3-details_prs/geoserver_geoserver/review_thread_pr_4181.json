{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxOTI5Mzc5", "number": 4181, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1MDowMlrOD3sLVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDozOTo1MVrOD6MPwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzIyMDY5OnYy", "diffSide": "RIGHT", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1MDowMlrOGOFbag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjowNzo0OFrOGRacBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMjE4Ng==", "bodyText": "This class won't work correctly with just any random format, it just supports html and json. Best to make the format variable an enumeration then.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417422186", "createdAt": "2020-04-29T15:50:02Z", "author": {"login": "aaime"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjEzMg==", "bodyText": "fixed", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912132", "createdAt": "2020-05-06T16:07:48Z", "author": {"login": "taba90"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMjE4Ng=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzIyNjgwOnYy", "diffSide": "RIGHT", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1MToyNVrOGOFfRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjowNzo1NlrOGRacYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMzE3Mg==", "bodyText": "Seems to heavily duplicate the code of the \"write\" method. Is there no way to share it? Seems like a flag to allow for empty templates is all that would be needed?", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417423172", "createdAt": "2020-04-29T15:51:25Z", "author": {"login": "aaime"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjIyNA==", "bodyText": "fixed", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912224", "createdAt": "2020-05-06T16:07:56Z", "author": {"login": "taba90"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMzE3Mg=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzIzNjU0OnYy", "diffSide": "RIGHT", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1Mzo0M1rOGOFlbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjowODowNFrOGRacsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNDc1MA==", "bodyText": "If you don't bother documenting the parameters, please don't add them in the javadoc, it's just noise.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417424750", "createdAt": "2020-04-29T15:53:43Z", "author": {"login": "aaime"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;\n+\n+                contentTemplates[i] = content;\n+            }\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, contentTemplates[i], osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Process a template with dynamic content\n+     *\n+     * @param typeName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjMwNA==", "bodyText": "fixed", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912304", "createdAt": "2020-05-06T16:08:04Z", "author": {"login": "taba90"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;\n+\n+                contentTemplates[i] = content;\n+            }\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, contentTemplates[i], osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Process a template with dynamic content\n+     *\n+     * @param typeName", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNDc1MA=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzI0MDg4OnYy", "diffSide": "RIGHT", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1NDozMlrOGOFoAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjowODoxMVrOGRadAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNTQwOQ==", "bodyText": "Seems like this two methods could be turned into one, the static template case could just use this method and receive a null for the feature collection.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417425409", "createdAt": "2020-04-29T15:54:32Z", "author": {"login": "aaime"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;\n+\n+                contentTemplates[i] = content;\n+            }\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, contentTemplates[i], osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Process a template with dynamic content\n+     *\n+     * @param typeName\n+     * @param fc\n+     * @param template\n+     * @param osw\n+     * @throws IOException\n+     */\n+    private void processDynamicTemplate(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjM4NA==", "bodyText": "fixed", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912384", "createdAt": "2020-05-06T16:08:11Z", "author": {"login": "taba90"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;\n+\n+                contentTemplates[i] = content;\n+            }\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, contentTemplates[i], osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Process a template with dynamic content\n+     *\n+     * @param typeName\n+     * @param fc\n+     * @param template\n+     * @param osw\n+     * @throws IOException\n+     */\n+    private void processDynamicTemplate(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNTQwOQ=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzI2MTk5OnYy", "diffSide": "RIGHT", "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1OToxM1rOGOF1dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjowODo0NFrOGRaetA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyODg1NA==", "bodyText": "Uh, this one is interesting... so if one has a mix of collections with custom templates and some without, the resulting output would be the normal geojson one? Mind the multi-collection case is not uncommon, happens every time one does a GetFeatureInfo against a layer group. Ideally the code should be able to mix the custom part with the normal one, maybe calling the geojson encoder just to generate the output for the collection that does not have its own template. This assumes each content template leaves a clean json output that one can attach stuff to... may be not easy, and should be documented.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417428854", "createdAt": "2020-04-29T15:59:13Z", "author": {"login": "aaime"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjgyMA==", "bodyText": "fixed", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912820", "createdAt": "2020-05-06T16:08:44Z", "author": {"login": "taba90"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyODg1NA=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzI3MjMzOnYy", "diffSide": "RIGHT", "path": "src/wms/src/test/java/org/geoserver/wms/featureinfo/GetFeatureInfoJSONTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjowMTozMVrOGOF8Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjowODo1MlrOGRafFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMDU1OQ==", "bodyText": "Good start for testing, but insufficient. Should check the multi-collection case (try with a layer group) and the mix of layers with and without templates.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417430559", "createdAt": "2020-04-29T16:01:31Z", "author": {"login": "aaime"}, "path": "src/wms/src/test/java/org/geoserver/wms/featureinfo/GetFeatureInfoJSONTest.java", "diffHunk": "@@ -361,4 +372,130 @@ public void testDateTimeFormattingDisabled() throws Exception {\n             TimeZone.setDefault(defaultTimeZone);\n         }\n     }\n+\n+    /** Tests json output mediated by a free marker template */\n+    @Test\n+    public void testJSONFreeMarkerTemplate() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMjkxOA==", "bodyText": "fixed", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420912918", "createdAt": "2020-05-06T16:08:52Z", "author": {"login": "taba90"}, "path": "src/wms/src/test/java/org/geoserver/wms/featureinfo/GetFeatureInfoJSONTest.java", "diffHunk": "@@ -361,4 +372,130 @@ public void testDateTimeFormattingDisabled() throws Exception {\n             TimeZone.setDefault(defaultTimeZone);\n         }\n     }\n+\n+    /** Tests json output mediated by a free marker template */\n+    @Test\n+    public void testJSONFreeMarkerTemplate() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMDU1OQ=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzI3NzA1OnYy", "diffSide": "RIGHT", "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjowMjozN1rOGOF_Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjowOTowMFrOGRafdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMTMzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The default GeoJSON output doesn't rely on free marker templates to be produced, nonetheless it is possible to customize the output using them.\n          \n          \n            \n            The default GeoJSON output uses the WFS GeoJSON  encoding mechanism, producing a fixed output, it is however possible to to customize the output using FreeMarker templates.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417431339", "createdAt": "2020-04-29T16:02:37Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,40 @@\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output doesn't rely on free marker templates to be produced, nonetheless it is possible to customize the output using them.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMzAxMg==", "bodyText": "fixed", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420913012", "createdAt": "2020-05-06T16:09:00Z", "author": {"login": "taba90"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,40 @@\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output doesn't rely on free marker templates to be produced, nonetheless it is possible to customize the output using them.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMTMzOQ=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzI3ODIyOnYy", "diffSide": "RIGHT", "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjowMjo1NVrOGOF_5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjowOTowOVrOGRaf2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMTUyNA==", "bodyText": "Not the only difference, you also needs to have all of them.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417431524", "createdAt": "2020-04-29T16:02:55Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,40 @@\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output doesn't rely on free marker templates to be produced, nonetheless it is possible to customize the output using them.\n+GeoServer will lookup for json templates following the same rules defined for the hmtl output. The only difference regards the file names of the templates which have to be named appending ``_json`` to the name, as below:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMjgzNw==", "bodyText": "Also something must be said about multi-layer GetFeatureInfo requests in combination with templated output.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417432837", "createdAt": "2020-04-29T16:04:59Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,40 @@\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output doesn't rely on free marker templates to be produced, nonetheless it is possible to customize the output using them.\n+GeoServer will lookup for json templates following the same rules defined for the hmtl output. The only difference regards the file names of the templates which have to be named appending ``_json`` to the name, as below:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMTUyNA=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMzExMw==", "bodyText": "fixed", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420913113", "createdAt": "2020-05-06T16:09:09Z", "author": {"login": "taba90"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,40 @@\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output doesn't rely on free marker templates to be produced, nonetheless it is possible to customize the output using them.\n+GeoServer will lookup for json templates following the same rules defined for the hmtl output. The only difference regards the file names of the templates which have to be named appending ``_json`` to the name, as below:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMTUyNA=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzI4Mzc4OnYy", "diffSide": "RIGHT", "path": "doc/en/user/source/tutorials/GetFeatureInfo/html.rst", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjowNDoyNFrOGOGDmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjoxMTo1NFrOGRanAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMjQ3Mg==", "bodyText": "Wondering how much of this new content overlaps with the existing feature info Freemarker tutorial?\nhttps://geoserver.geo-solutions.it/downloads/releases/2.8.x-ld/doc/tutorials/GetFeatureInfo/index.html", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417432472", "createdAt": "2020-04-29T16:04:24Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/html.rst", "diffHunk": "@@ -0,0 +1,161 @@\n+HTML output format\n+===================\n+\n+The default HTML output is a sequence of titled tables, each one for a different layer. The following example shows the default output for the tiger-ny basemap (included in the above cited releases, and onwards).\n+\n+.. figure:: default.png\n+   :align: center\n+\n+   *Default Output*\n+\n+Standard Templates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxNDk0NA==", "bodyText": "This is actually that one. About getfeatureinfo there is only a section in the WMS reference page https://docs.geoserver.org/latest/en/user/services/wms/reference.html, and the that tutorial.\nSo I added the geojson doc page along that one in the tutorials section. In the last commit I've added also two example request and two example response in the geojson page.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r420914944", "createdAt": "2020-05-06T16:11:54Z", "author": {"login": "taba90"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/html.rst", "diffHunk": "@@ -0,0 +1,161 @@\n+HTML output format\n+===================\n+\n+The default HTML output is a sequence of titled tables, each one for a different layer. The following example shows the default output for the tiger-ny basemap (included in the above cited releases, and onwards).\n+\n+.. figure:: default.png\n+   :align: center\n+\n+   *Default Output*\n+\n+Standard Templates", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMjQ3Mg=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzQyMjkyOnYy", "diffSide": "RIGHT", "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDozMjo0MlrOGR4ghA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMzoxNzoyNFrOGSlMPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwNDgwNA==", "bodyText": "Seems to suggest that in a mixed templated/templated case the templates would still be used for the collections having the template. However, looking at the code, it seems the templates are used only if all collections have them instead. Please clarify.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r421404804", "createdAt": "2020-05-07T10:32:42Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,206 @@\n+.. _tutorials_getfeatureinfo_geojson:\n+\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output uses the WFS GeoJSON  encoding mechanism, producing a fixed output, it is however possible to customize the output using FreeMarker templates.\n+GeoServer will lookup for json templates following the same rules defined for the hmtl output, but the template files have to be named appending ``_json`` to the usual name, as below:\n+\n+* ``header_json.ftl``\n+* ``content_json.ftl``\n+* ``footer_json.ftl``\n+\n+Moreover, unlike the html case, all three template files must be provided.\n+In case of a multi-layer request GeoServer will act in the following way:\n+\n+* content template will be searched up following the usual rules;\n+* since there are no default templates for GeoJSON, header and footer will be looked up in the ``templates`` directory;\n+* features with no content template will be encoded with the normal GeoJSON encoding, along with the customized ones.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEzNjg5NQ==", "bodyText": "The method to check the presence of needed templates return true if at least one content template is found 7b1450e#diff-23918ce152856383ab9ceb08815749fbR246. But probably I had a bad idea in keeping the logic for both format in the templateManager. I made it an abstract class, so that each format has its own custom implementation, now the functioning should be more visible 9826f9d#diff-91952e39c8f5fd482e5bdf5e637d9967R90", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r422136895", "createdAt": "2020-05-08T13:17:24Z", "author": {"login": "taba90"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,206 @@\n+.. _tutorials_getfeatureinfo_geojson:\n+\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output uses the WFS GeoJSON  encoding mechanism, producing a fixed output, it is however possible to customize the output using FreeMarker templates.\n+GeoServer will lookup for json templates following the same rules defined for the hmtl output, but the template files have to be named appending ``_json`` to the usual name, as below:\n+\n+* ``header_json.ftl``\n+* ``content_json.ftl``\n+* ``footer_json.ftl``\n+\n+Moreover, unlike the html case, all three template files must be provided.\n+In case of a multi-layer request GeoServer will act in the following way:\n+\n+* content template will be searched up following the usual rules;\n+* since there are no default templates for GeoJSON, header and footer will be looked up in the ``templates`` directory;\n+* features with no content template will be encoded with the normal GeoJSON encoding, along with the customized ones.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwNDgwNA=="}, "originalCommit": {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzQ0NjQyOnYy", "diffSide": "RIGHT", "path": "src/wms/src/test/resources/org/geoserver/wms/content_json.ftl", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDozOTo1MlrOGR4vZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMzoxNzozNVrOGSlMhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwODYxNQ==", "bodyText": "Is this going to encode a valid GeoJSON geometry? How does it work?", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r421408615", "createdAt": "2020-05-07T10:39:52Z", "author": {"login": "aaime"}, "path": "src/wms/src/test/resources/org/geoserver/wms/content_json.ftl", "diffHunk": "@@ -0,0 +1,26 @@\n+<#list features as feature>\n+{\n+\"content\" : \"this is the content\",\n+\"type\": \"Feature\",\n+\"id\" : \"${feature.fid}\",\n+\"geometry_name\":\"the_geom\",\n+<#list feature.attributes as attribute1>\n+<#if attribute1.isGeometry>\n+\"geometry\": \"${attribute1.value}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxMTY3NQ==", "bodyText": "Tried interactively, it does not seem to generate valid GeoJSON:\n{\nheader: \"this is the header\",\ntype: \"FeatureCollection\",\nfeatures: [\n{\ncontent: \"this is the content\",\ntype: \"Feature\",\nid: \"archsites.7\",\ngeometry_name: \"the_geom\",\ngeometry: \"POINT (606635 4920773)\",\nproperties: {\ncat: \"7\",\nstr1: \"Jensen Pass\"\n}\n}\n],\nfooter: \"this is the footer\"\n}\n\nMy guess is that a function to encode a geometry as a valid GeoJSON geometry is missing.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r421411675", "createdAt": "2020-05-07T10:46:08Z", "author": {"login": "aaime"}, "path": "src/wms/src/test/resources/org/geoserver/wms/content_json.ftl", "diffHunk": "@@ -0,0 +1,26 @@\n+<#list features as feature>\n+{\n+\"content\" : \"this is the content\",\n+\"type\": \"Feature\",\n+\"id\" : \"${feature.fid}\",\n+\"geometry_name\":\"the_geom\",\n+<#list feature.attributes as attribute1>\n+<#if attribute1.isGeometry>\n+\"geometry\": \"${attribute1.value}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwODYxNQ=="}, "originalCommit": {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEzNjk2NQ==", "bodyText": "fixed", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r422136965", "createdAt": "2020-05-08T13:17:35Z", "author": {"login": "taba90"}, "path": "src/wms/src/test/resources/org/geoserver/wms/content_json.ftl", "diffHunk": "@@ -0,0 +1,26 @@\n+<#list features as feature>\n+{\n+\"content\" : \"this is the content\",\n+\"type\": \"Feature\",\n+\"id\" : \"${feature.fid}\",\n+\"geometry_name\":\"the_geom\",\n+<#list feature.attributes as attribute1>\n+<#if attribute1.isGeometry>\n+\"geometry\": \"${attribute1.value}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwODYxNQ=="}, "originalCommit": {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4053, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}