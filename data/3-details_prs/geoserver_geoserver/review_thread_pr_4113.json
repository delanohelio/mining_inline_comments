{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0Mzc4NTYy", "number": 4113, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxODowNTowMlrODl4_6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxODoxNDowNVrODl5J8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDU3NzY4OnYy", "diffSide": "RIGHT", "path": "src/community/wps-download/src/main/java/org/geoserver/wps/gs/download/CRSRequestHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxODowNTowMlrOFzCPEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxODowNTowMlrOFzCPEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1ODMyMA==", "bodyText": "and.. and? the suspence is killing me :-D", "url": "https://github.com/geoserver/geoserver/pull/4113#discussion_r389058320", "createdAt": "2020-03-06T18:05:02Z", "author": {"login": "aaime"}, "path": "src/community/wps-download/src/main/java/org/geoserver/wps/gs/download/CRSRequestHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wps.gs.download;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import org.geoserver.catalog.Catalog;\n+import org.geoserver.catalog.Predicates;\n+import org.geotools.coverage.grid.io.DimensionDescriptor;\n+import org.geotools.coverage.grid.io.GranuleSource;\n+import org.geotools.coverage.grid.io.GridCoverage2DReader;\n+import org.geotools.coverage.grid.io.StructuredGridCoverage2DReader;\n+import org.geotools.coverage.util.FeatureUtilities;\n+import org.geotools.data.Query;\n+import org.geotools.data.simple.SimpleFeatureCollection;\n+import org.geotools.gce.imagemosaic.Utils;\n+import org.geotools.geometry.jts.ReferencedEnvelope;\n+import org.geotools.referencing.CRS;\n+import org.geotools.util.logging.Logging;\n+import org.locationtech.jts.geom.Geometry;\n+import org.opengis.feature.type.GeometryDescriptor;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.referencing.FactoryException;\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\n+import org.opengis.referencing.operation.MathTransform;\n+import org.opengis.referencing.operation.TransformException;\n+\n+/**\n+ * Class to handle requested CRSs and ROI in order to determine if the request is involving any\n+ * granule with nativeCRS matching the targetCRS. Once the required flags and properties have been\n+ * set, it need to be initialized through the init method before any of its methods get used.\n+ */\n+class CRSRequestHandler {\n+    private static final Logger LOGGER = Logging.getLogger(CRSRequestHandler.class);\n+\n+    private static final FilterFactory2 FF = FeatureUtilities.DEFAULT_FILTER_FACTORY;\n+\n+    // ----------------\n+    // Input Parameters\n+    // ----------------\n+    private final GridCoverage2DReader reader;\n+\n+    private StructuredGridCoverage2DReader structuredReader;\n+    private final Geometry roi;\n+    private Filter filter;\n+    private CoordinateReferenceSystem originalTargetCRS;\n+    private CoordinateReferenceSystem originalNativeCRS;\n+    private Catalog catalog;\n+\n+    /**\n+     * Requested flag to use the best available resolution of granules in ROI, having their CRS\n+     * matching the targetCRS\n+     */\n+    private boolean useBestResolutionOnMatchingCRS;\n+\n+    /** Requested flag to minimizeReprojections on granules having CRS matching the Target one */\n+    private boolean minimizeReprojections;\n+\n+    // ------------------------------------------------\n+    // Computed parameters once initialization occurred\n+    // ------------------------------------------------\n+    private boolean initialized = false;\n+\n+    private boolean needsReprojection = false;\n+\n+    /** reporting if the request can actually use targetCRS as native */\n+    private boolean canUseTargetCrsAsNative = false;\n+\n+    /** The targetCRS actually selected for the processing. */\n+    private CoordinateReferenceSystem selectedTargetCRS;\n+\n+    private Map<String, DimensionDescriptor> descriptors = null;\n+\n+    private ROIManager roiManager;\n+\n+    /** The computed targetEnvelope after initialization */\n+    private ReferencedEnvelope targetEnvelope;\n+\n+    public CRSRequestHandler(\n+            GridCoverage2DReader reader,\n+            Catalog catalog,\n+            CoordinateReferenceSystem originalTargetCRS,\n+            Geometry roi) {\n+        this.reader = reader;\n+        this.catalog = catalog;\n+        this.originalTargetCRS = originalTargetCRS;\n+        this.selectedTargetCRS = originalTargetCRS;\n+        this.roi = roi;\n+        if (StructuredGridCoverage2DReader.class.isAssignableFrom(reader.getClass())) {\n+            structuredReader = (StructuredGridCoverage2DReader) reader;\n+        }\n+        originalNativeCRS = reader.getCoordinateReferenceSystem();\n+    }\n+\n+    public void setFilter(Filter filter) {\n+        this.filter = filter;\n+    }\n+\n+    public CoordinateReferenceSystem getSelectedNativeCRS() {\n+        return canUseTargetCrsAsNative ? originalTargetCRS : originalNativeCRS;\n+    }\n+\n+    public void setMinimizeReprojections(boolean minimizeReprojections) {\n+        this.minimizeReprojections = minimizeReprojections;\n+    }\n+\n+    public boolean canUseBestResolutionOnMatchingCRS() {\n+        return useBestResolutionOnMatchingCRS && canUseTargetCrsAsNative;\n+    }\n+\n+    public void setUseBestResolutionOnMatchingCRS(boolean bestResolutionOnMatchingCrs) {\n+        this.useBestResolutionOnMatchingCRS = bestResolutionOnMatchingCrs;\n+    }\n+\n+    public Map<String, DimensionDescriptor> getDescriptors() {\n+        return descriptors;\n+    }\n+\n+    public boolean needsReprojection() {\n+        return needsReprojection;\n+    }\n+\n+    public boolean hasStructuredReader() {\n+        return (structuredReader != null);\n+    }\n+\n+    public GridCoverage2DReader getReader() {\n+        return reader;\n+    }\n+\n+    public ROIManager getRoiManager() {\n+        return roiManager;\n+    }\n+\n+    public boolean canUseTargetCrsAsNative() {\n+        return canUseTargetCrsAsNative;\n+    }\n+\n+    public Filter getFilter() {\n+        return filter;\n+    }\n+\n+    public CoordinateReferenceSystem getSelectedTargetCRS() {\n+        return selectedTargetCRS;\n+    }\n+\n+    public ReferencedEnvelope getTargetEnvelope() {\n+        return targetEnvelope;\n+    }\n+\n+    public StructuredGridCoverage2DReader getStructuredReader() {\n+        return structuredReader;\n+    }\n+\n+    public void init() throws IOException, FactoryException, TransformException {\n+        if (initialized) return;\n+\n+        // Initialize dimension descriptors\n+        if (structuredReader != null) {\n+            String coverageName = structuredReader.getGridCoverageNames()[0];\n+            descriptors =\n+                    structuredReader\n+                            .getDimensionDescriptors(coverageName)\n+                            .stream()\n+                            .collect(Collectors.toMap(dd -> dd.getName(), dd -> dd));\n+        } else {\n+            descriptors = Collections.emptyMap();\n+        }\n+\n+        // Check if the request can actually use the TargetCRS as if it would be the\n+        // native one of the reader (so no reprojection in the mix).\n+        canUseTargetCrsAsNative =\n+                minimizeReprojections\n+                        && roi != null\n+                        && originalTargetCRS != null\n+                        && !CRS.equalsIgnoreMetadata(originalNativeCRS, originalTargetCRS)\n+                        && Utils.isSupportedCRS(reader, originalTargetCRS)\n+                        && descriptors.containsKey(DimensionDescriptor.CRS)\n+                        && haveGranulesMatchingTargetCRS(reader, originalTargetCRS, roi, filter);\n+\n+        MathTransform reprojectionTransform = null;\n+        CoordinateReferenceSystem nativeCRS = getSelectedNativeCRS();\n+\n+        if (LOGGER.isLoggable(Level.FINE)) {\n+            LOGGER.fine(\"Native CRS is \" + nativeCRS.toWKT());\n+        }\n+\n+        // Initialize reprojection flag and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd793848af82b5606251bc43356f998ac9396081"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDYwMzM2OnYy", "diffSide": "RIGHT", "path": "src/community/wps-download/src/main/java/org/geoserver/wps/gs/download/CRSRequestHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxODoxNDowNVrOFzCfCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMDozNjozNlrOFziAyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2MjQxMA==", "bodyText": "One \"Crs\" escaped the cleanup.", "url": "https://github.com/geoserver/geoserver/pull/4113#discussion_r389062410", "createdAt": "2020-03-06T18:14:05Z", "author": {"login": "aaime"}, "path": "src/community/wps-download/src/main/java/org/geoserver/wps/gs/download/CRSRequestHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wps.gs.download;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import org.geoserver.catalog.Catalog;\n+import org.geoserver.catalog.Predicates;\n+import org.geotools.coverage.grid.io.DimensionDescriptor;\n+import org.geotools.coverage.grid.io.GranuleSource;\n+import org.geotools.coverage.grid.io.GridCoverage2DReader;\n+import org.geotools.coverage.grid.io.StructuredGridCoverage2DReader;\n+import org.geotools.coverage.util.FeatureUtilities;\n+import org.geotools.data.Query;\n+import org.geotools.data.simple.SimpleFeatureCollection;\n+import org.geotools.gce.imagemosaic.Utils;\n+import org.geotools.geometry.jts.ReferencedEnvelope;\n+import org.geotools.referencing.CRS;\n+import org.geotools.util.logging.Logging;\n+import org.locationtech.jts.geom.Geometry;\n+import org.opengis.feature.type.GeometryDescriptor;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.referencing.FactoryException;\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\n+import org.opengis.referencing.operation.MathTransform;\n+import org.opengis.referencing.operation.TransformException;\n+\n+/**\n+ * Class to handle requested CRSs and ROI in order to determine if the request is involving any\n+ * granule with nativeCRS matching the targetCRS. Once the required flags and properties have been\n+ * set, it need to be initialized through the init method before any of its methods get used.\n+ */\n+class CRSRequestHandler {\n+    private static final Logger LOGGER = Logging.getLogger(CRSRequestHandler.class);\n+\n+    private static final FilterFactory2 FF = FeatureUtilities.DEFAULT_FILTER_FACTORY;\n+\n+    // ----------------\n+    // Input Parameters\n+    // ----------------\n+    private final GridCoverage2DReader reader;\n+\n+    private StructuredGridCoverage2DReader structuredReader;\n+    private final Geometry roi;\n+    private Filter filter;\n+    private CoordinateReferenceSystem originalTargetCRS;\n+    private CoordinateReferenceSystem originalNativeCRS;\n+    private Catalog catalog;\n+\n+    /**\n+     * Requested flag to use the best available resolution of granules in ROI, having their CRS\n+     * matching the targetCRS\n+     */\n+    private boolean useBestResolutionOnMatchingCRS;\n+\n+    /** Requested flag to minimizeReprojections on granules having CRS matching the Target one */\n+    private boolean minimizeReprojections;\n+\n+    // ------------------------------------------------\n+    // Computed parameters once initialization occurred\n+    // ------------------------------------------------\n+    private boolean initialized = false;\n+\n+    private boolean needsReprojection = false;\n+\n+    /** reporting if the request can actually use targetCRS as native */\n+    private boolean canUseTargetCrsAsNative = false;\n+\n+    /** The targetCRS actually selected for the processing. */\n+    private CoordinateReferenceSystem selectedTargetCRS;\n+\n+    private Map<String, DimensionDescriptor> descriptors = null;\n+\n+    private ROIManager roiManager;\n+\n+    /** The computed targetEnvelope after initialization */\n+    private ReferencedEnvelope targetEnvelope;\n+\n+    public CRSRequestHandler(\n+            GridCoverage2DReader reader,\n+            Catalog catalog,\n+            CoordinateReferenceSystem originalTargetCRS,\n+            Geometry roi) {\n+        this.reader = reader;\n+        this.catalog = catalog;\n+        this.originalTargetCRS = originalTargetCRS;\n+        this.selectedTargetCRS = originalTargetCRS;\n+        this.roi = roi;\n+        if (StructuredGridCoverage2DReader.class.isAssignableFrom(reader.getClass())) {\n+            structuredReader = (StructuredGridCoverage2DReader) reader;\n+        }\n+        originalNativeCRS = reader.getCoordinateReferenceSystem();\n+    }\n+\n+    public void setFilter(Filter filter) {\n+        this.filter = filter;\n+    }\n+\n+    public CoordinateReferenceSystem getSelectedNativeCRS() {\n+        return canUseTargetCrsAsNative ? originalTargetCRS : originalNativeCRS;\n+    }\n+\n+    public void setMinimizeReprojections(boolean minimizeReprojections) {\n+        this.minimizeReprojections = minimizeReprojections;\n+    }\n+\n+    public boolean canUseBestResolutionOnMatchingCRS() {\n+        return useBestResolutionOnMatchingCRS && canUseTargetCrsAsNative;\n+    }\n+\n+    public void setUseBestResolutionOnMatchingCRS(boolean bestResolutionOnMatchingCrs) {\n+        this.useBestResolutionOnMatchingCRS = bestResolutionOnMatchingCrs;\n+    }\n+\n+    public Map<String, DimensionDescriptor> getDescriptors() {\n+        return descriptors;\n+    }\n+\n+    public boolean needsReprojection() {\n+        return needsReprojection;\n+    }\n+\n+    public boolean hasStructuredReader() {\n+        return (structuredReader != null);\n+    }\n+\n+    public GridCoverage2DReader getReader() {\n+        return reader;\n+    }\n+\n+    public ROIManager getRoiManager() {\n+        return roiManager;\n+    }\n+\n+    public boolean canUseTargetCrsAsNative() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd793848af82b5606251bc43356f998ac9396081"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU3ODk1NQ==", "bodyText": "fixed. thx", "url": "https://github.com/geoserver/geoserver/pull/4113#discussion_r389578955", "createdAt": "2020-03-09T10:36:36Z", "author": {"login": "dromagnoli"}, "path": "src/community/wps-download/src/main/java/org/geoserver/wps/gs/download/CRSRequestHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wps.gs.download;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import org.geoserver.catalog.Catalog;\n+import org.geoserver.catalog.Predicates;\n+import org.geotools.coverage.grid.io.DimensionDescriptor;\n+import org.geotools.coverage.grid.io.GranuleSource;\n+import org.geotools.coverage.grid.io.GridCoverage2DReader;\n+import org.geotools.coverage.grid.io.StructuredGridCoverage2DReader;\n+import org.geotools.coverage.util.FeatureUtilities;\n+import org.geotools.data.Query;\n+import org.geotools.data.simple.SimpleFeatureCollection;\n+import org.geotools.gce.imagemosaic.Utils;\n+import org.geotools.geometry.jts.ReferencedEnvelope;\n+import org.geotools.referencing.CRS;\n+import org.geotools.util.logging.Logging;\n+import org.locationtech.jts.geom.Geometry;\n+import org.opengis.feature.type.GeometryDescriptor;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.referencing.FactoryException;\n+import org.opengis.referencing.crs.CoordinateReferenceSystem;\n+import org.opengis.referencing.operation.MathTransform;\n+import org.opengis.referencing.operation.TransformException;\n+\n+/**\n+ * Class to handle requested CRSs and ROI in order to determine if the request is involving any\n+ * granule with nativeCRS matching the targetCRS. Once the required flags and properties have been\n+ * set, it need to be initialized through the init method before any of its methods get used.\n+ */\n+class CRSRequestHandler {\n+    private static final Logger LOGGER = Logging.getLogger(CRSRequestHandler.class);\n+\n+    private static final FilterFactory2 FF = FeatureUtilities.DEFAULT_FILTER_FACTORY;\n+\n+    // ----------------\n+    // Input Parameters\n+    // ----------------\n+    private final GridCoverage2DReader reader;\n+\n+    private StructuredGridCoverage2DReader structuredReader;\n+    private final Geometry roi;\n+    private Filter filter;\n+    private CoordinateReferenceSystem originalTargetCRS;\n+    private CoordinateReferenceSystem originalNativeCRS;\n+    private Catalog catalog;\n+\n+    /**\n+     * Requested flag to use the best available resolution of granules in ROI, having their CRS\n+     * matching the targetCRS\n+     */\n+    private boolean useBestResolutionOnMatchingCRS;\n+\n+    /** Requested flag to minimizeReprojections on granules having CRS matching the Target one */\n+    private boolean minimizeReprojections;\n+\n+    // ------------------------------------------------\n+    // Computed parameters once initialization occurred\n+    // ------------------------------------------------\n+    private boolean initialized = false;\n+\n+    private boolean needsReprojection = false;\n+\n+    /** reporting if the request can actually use targetCRS as native */\n+    private boolean canUseTargetCrsAsNative = false;\n+\n+    /** The targetCRS actually selected for the processing. */\n+    private CoordinateReferenceSystem selectedTargetCRS;\n+\n+    private Map<String, DimensionDescriptor> descriptors = null;\n+\n+    private ROIManager roiManager;\n+\n+    /** The computed targetEnvelope after initialization */\n+    private ReferencedEnvelope targetEnvelope;\n+\n+    public CRSRequestHandler(\n+            GridCoverage2DReader reader,\n+            Catalog catalog,\n+            CoordinateReferenceSystem originalTargetCRS,\n+            Geometry roi) {\n+        this.reader = reader;\n+        this.catalog = catalog;\n+        this.originalTargetCRS = originalTargetCRS;\n+        this.selectedTargetCRS = originalTargetCRS;\n+        this.roi = roi;\n+        if (StructuredGridCoverage2DReader.class.isAssignableFrom(reader.getClass())) {\n+            structuredReader = (StructuredGridCoverage2DReader) reader;\n+        }\n+        originalNativeCRS = reader.getCoordinateReferenceSystem();\n+    }\n+\n+    public void setFilter(Filter filter) {\n+        this.filter = filter;\n+    }\n+\n+    public CoordinateReferenceSystem getSelectedNativeCRS() {\n+        return canUseTargetCrsAsNative ? originalTargetCRS : originalNativeCRS;\n+    }\n+\n+    public void setMinimizeReprojections(boolean minimizeReprojections) {\n+        this.minimizeReprojections = minimizeReprojections;\n+    }\n+\n+    public boolean canUseBestResolutionOnMatchingCRS() {\n+        return useBestResolutionOnMatchingCRS && canUseTargetCrsAsNative;\n+    }\n+\n+    public void setUseBestResolutionOnMatchingCRS(boolean bestResolutionOnMatchingCrs) {\n+        this.useBestResolutionOnMatchingCRS = bestResolutionOnMatchingCrs;\n+    }\n+\n+    public Map<String, DimensionDescriptor> getDescriptors() {\n+        return descriptors;\n+    }\n+\n+    public boolean needsReprojection() {\n+        return needsReprojection;\n+    }\n+\n+    public boolean hasStructuredReader() {\n+        return (structuredReader != null);\n+    }\n+\n+    public GridCoverage2DReader getReader() {\n+        return reader;\n+    }\n+\n+    public ROIManager getRoiManager() {\n+        return roiManager;\n+    }\n+\n+    public boolean canUseTargetCrsAsNative() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2MjQxMA=="}, "originalCommit": {"oid": "cd793848af82b5606251bc43356f998ac9396081"}, "originalPosition": 145}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4017, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}