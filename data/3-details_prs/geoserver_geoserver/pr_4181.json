{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxOTI5Mzc5", "number": 4181, "title": "[GEOS-9570] Allow the possibility to customize the GeoJSON GetFeature\u2026", "bodyText": "\u2026Info output format using free marker templates\n\nChecklist\n\nReviewing is a process done by project maintainers, mostly on a volunteer basis. We try to keep the overhead as small as possible and appreciate if you help us to do so by completing the following items. Feel free to ask in a comment if you have troubles with any of them.\n\nFor all pull requests:\n\n Confirm you have read the contribution guidelines\n You have sent a Contribution Licence Agreement (CLA) as necessary (not required for small changes, e.g., fixing typos in documentation)\n Make sure the first PR targets the master branch, eventual backports will be managed later. This can be ignored if the PR is fixing an issue that only happens in a specific branch, but not in newer ones.\n\nThe following are required only for core and extension modules (they are welcomed, but not required, for community modules):\n\n There is a ticket in Jira describing the issue/improvement/feature (a notable exemptions is, changes not visible to end users)\n PR for bug fixes and small new features are presented as a single commit\n Commit message must be in the form \"[GEOS-XYZW] Title of the Jira ticket\" (export to XML in Jira generates the message in this exact form)\n The pull request contains changes related to a single objective. If multiple focuses cannot be avoided, each one is in its own commit and has a separate ticket describing it.\n New unit tests have been added covering the changes\n This PR passes all existing unit tests (test results will be reported by travis-ci after opening this PR)\n This PR passes the QA checks (QA checks results will be reported by travis-ci after opening this PR)\n Commits changing the UI, existing user workflows, or adding new functionality, need to include documentation updates (screenshots, text)\n Commits changing the REST API, or any configuration object, should check if the REST API docs (Swagger YAML files and classic documentation) need to be updated.\n\nSubmitting the PR does not require you to check all items, but by the time it gets merged, they should be either satisfied or inapplicable.", "createdAt": "2020-04-10T14:24:33Z", "url": "https://github.com/geoserver/geoserver/pull/4181", "merged": true, "mergeCommit": {"oid": "8e3bee147bdf34d9bc84e4c1f3e04ead67fc5a39"}, "closed": true, "closedAt": "2020-05-11T13:03:33Z", "author": {"login": "taba90"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWSImXABqjMyMjIwNTUyNDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgLmwmgBqjMzMjE5MDY3Mjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d77dc3d25c5d00b29ddcf9354b777d279963a4ca", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/d77dc3d25c5d00b29ddcf9354b777d279963a4ca", "committedDate": "2020-04-10T14:23:19Z", "message": "[GEOS-9570] Allow the possibility to customize the GeoJSON GetFeatureInfo output format using free marker templates"}, "afterCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "committedDate": "2020-04-10T14:39:47Z", "message": "[GEOS-9570] Allow the possibility to customize the GeoJSON GetFeatureInfo output format using free marker templates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODAzMjQy", "url": "https://github.com/geoserver/geoserver/pull/4181#pullrequestreview-402803242", "createdAt": "2020-04-29T15:50:01Z", "commit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1MDowMlrOGOFbag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNjowNDo1OVrOGOGFBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMjE4Ng==", "bodyText": "This class won't work correctly with just any random format, it just supports html and json. Best to make the format variable an enumeration then.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417422186", "createdAt": "2020-04-29T15:50:02Z", "author": {"login": "aaime"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMzE3Mg==", "bodyText": "Seems to heavily duplicate the code of the \"write\" method. Is there no way to share it? Seems like a flag to allow for empty templates is all that would be needed?", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417423172", "createdAt": "2020-04-29T15:51:25Z", "author": {"login": "aaime"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNDc1MA==", "bodyText": "If you don't bother documenting the parameters, please don't add them in the javadoc, it's just noise.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417424750", "createdAt": "2020-04-29T15:53:43Z", "author": {"login": "aaime"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;\n+\n+                contentTemplates[i] = content;\n+            }\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, contentTemplates[i], osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Process a template with dynamic content\n+     *\n+     * @param typeName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNTQwOQ==", "bodyText": "Seems like this two methods could be turned into one, the static template case could just use this method and receive a null for the feature collection.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417425409", "createdAt": "2020-04-29T15:54:32Z", "author": {"login": "aaime"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;\n+\n+                contentTemplates[i] = content;\n+            }\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, contentTemplates[i], osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Process a template with dynamic content\n+     *\n+     * @param typeName\n+     * @param fc\n+     * @param template\n+     * @param osw\n+     * @throws IOException\n+     */\n+    private void processDynamicTemplate(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyODg1NA==", "bodyText": "Uh, this one is interesting... so if one has a mix of collections with custom templates and some without, the resulting output would be the normal geojson one? Mind the multi-collection case is not uncommon, happens every time one does a GetFeatureInfo against a layer group. Ideally the code should be able to mix the custom part with the normal one, maybe calling the geojson encoder just to generate the output for the collection that does not have its own template. This assumes each content template leaves a clean json output that one can attach stuff to... may be not easy, and should be documented.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417428854", "createdAt": "2020-04-29T15:59:13Z", "author": {"login": "aaime"}, "path": "src/wms/src/main/java/org/geoserver/wms/featureinfo/FreeMarkerTemplateManager.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wms.featureinfo;\n+\n+import freemarker.template.*;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import net.opengis.wfs.FeatureCollectionType;\n+import org.geoserver.catalog.ResourceInfo;\n+import org.geoserver.ows.Dispatcher;\n+import org.geoserver.platform.GeoServerResourceLoader;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.template.DirectTemplateFeatureCollectionFactory;\n+import org.geoserver.template.FeatureWrapper;\n+import org.geoserver.template.GeoServerTemplateLoader;\n+import org.geoserver.template.TemplateUtils;\n+import org.geoserver.wfs.json.JSONType;\n+import org.geoserver.wms.GetFeatureInfoRequest;\n+import org.geoserver.wms.WMS;\n+import org.geotools.feature.FeatureCollection;\n+import org.opengis.feature.simple.SimpleFeatureType;\n+\n+/**\n+ * Class to manage free marker templates used to customize getFeatureInfo output format. It takes\n+ * care to load templates according to the output format and writing the result.\n+ */\n+public class FreeMarkerTemplateManager {\n+\n+    private static Configuration templateConfig;\n+\n+    private static DirectTemplateFeatureCollectionFactory tfcFactory =\n+            new DirectTemplateFeatureCollectionFactory();\n+\n+    static {\n+        // initialize the template engine, this is static to maintain a cache\n+        // over instantiations of kml writer\n+        templateConfig = TemplateUtils.getSafeConfiguration();\n+        templateConfig.setObjectWrapper(\n+                new FeatureWrapper(tfcFactory) {\n+\n+                    @Override\n+                    public TemplateModel wrap(Object object) throws TemplateModelException {\n+                        if (object instanceof FeatureCollection) {\n+                            SimpleHash map = (SimpleHash) super.wrap(object);\n+                            map.put(\"request\", Dispatcher.REQUEST.get().getKvp());\n+                            map.put(\"environment\", new EnvironmentVariablesTemplateModel());\n+                            map.put(\"Math\", getStaticModel(\"java.lang.Math\"));\n+                            return map;\n+                        }\n+                        return super.wrap(object);\n+                    }\n+\n+                    private TemplateHashModel getStaticModel(String path)\n+                            throws TemplateModelException {\n+                        return (TemplateHashModel) getStaticModels().get(path);\n+                    }\n+                });\n+    }\n+\n+    private String format;\n+\n+    private GeoServerResourceLoader resourceLoader;\n+\n+    private WMS wms;\n+\n+    private GeoServerTemplateLoader templateLoader;\n+\n+    public FreeMarkerTemplateManager(\n+            String format, final WMS wms, GeoServerResourceLoader resourceLoader) {\n+        this.resourceLoader = resourceLoader;\n+        this.wms = wms;\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Write FeatureCollectionType to the output\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public void write(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+            if (ri != null) {\n+                header = getTemplate(ri, charSet, \"header\");\n+                footer = getTemplate(ri, charSet, \"footer\");\n+            } else {\n+                header = getTemplate(null, charSet, \"header\");\n+                footer = getTemplate(null, charSet, \"footer\");\n+            }\n+\n+            processStaticTemplate(\"header\", header, osw);\n+\n+            // process content template for all feature collections found\n+            for (int i = 0; i < collections.size(); i++) {\n+                FeatureCollection fc = collections.get(i);\n+                Template content = getContentTemplate(fc, charSet);\n+                String typeName = request.getQueryLayers().get(i).getName();\n+                processDynamicTemplate(typeName, fc, content, osw);\n+            }\n+\n+            // if a template footer was loaded (ie, there were only one feature\n+            // collection), process it\n+            if (footer != null) processStaticTemplate(\"footer\", footer, osw);\n+            osw.flush();\n+\n+        } finally {\n+            // close any open iterators\n+            tfcFactory.purge();\n+        }\n+    }\n+\n+    /**\n+     * Write a FeatureCollectionType to the output, checking that header.ftl, content.ftl and\n+     * footer.ftl are all present\n+     *\n+     * @param results\n+     * @param request\n+     * @param out\n+     * @return false if the three templates are not all present true if they are and output got\n+     *     written.\n+     * @throws ServiceException\n+     * @throws IOException\n+     */\n+    public boolean writeWithNullCheck(\n+            FeatureCollectionType results, GetFeatureInfoRequest request, OutputStream out)\n+            throws ServiceException, IOException {\n+        // setup the writer\n+        final Charset charSet = wms.getCharSet();\n+        final OutputStreamWriter osw = new OutputStreamWriter(out, charSet);\n+\n+        try {\n+            // if there is only one feature type loaded, we allow for header/footer customization,\n+            // otherwise we stick with the generic ones\n+            List<FeatureCollection> collections = results.getFeature();\n+            ResourceInfo ri = null;\n+            if (collections.size() == 1) {\n+                ri = wms.getResourceInfo(FeatureCollectionDecorator.getName(collections.get(0)));\n+            }\n+            // ri can be null if the type is the result of a rendering transformation\n+            Template header;\n+            Template footer;\n+\n+            header = getTemplate(ri, charSet, \"header\");\n+            if (header == null) return false;\n+\n+            footer = getTemplate(ri, charSet, \"footer\");\n+            if (footer == null) return false;\n+\n+            int collSize = collections.size();\n+            Template[] contentTemplates = new Template[collSize];\n+            for (int i = 0; i < collSize; i++) {\n+                FeatureCollection fc = collections.get(i);\n+\n+                Template content = getContentTemplate(fc, charSet);\n+                if (content == null) return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMDU1OQ==", "bodyText": "Good start for testing, but insufficient. Should check the multi-collection case (try with a layer group) and the mix of layers with and without templates.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417430559", "createdAt": "2020-04-29T16:01:31Z", "author": {"login": "aaime"}, "path": "src/wms/src/test/java/org/geoserver/wms/featureinfo/GetFeatureInfoJSONTest.java", "diffHunk": "@@ -361,4 +372,130 @@ public void testDateTimeFormattingDisabled() throws Exception {\n             TimeZone.setDefault(defaultTimeZone);\n         }\n     }\n+\n+    /** Tests json output mediated by a free marker template */\n+    @Test\n+    public void testJSONFreeMarkerTemplate() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMTMzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The default GeoJSON output doesn't rely on free marker templates to be produced, nonetheless it is possible to customize the output using them.\n          \n          \n            \n            The default GeoJSON output uses the WFS GeoJSON  encoding mechanism, producing a fixed output, it is however possible to to customize the output using FreeMarker templates.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417431339", "createdAt": "2020-04-29T16:02:37Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,40 @@\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output doesn't rely on free marker templates to be produced, nonetheless it is possible to customize the output using them.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMTUyNA==", "bodyText": "Not the only difference, you also needs to have all of them.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417431524", "createdAt": "2020-04-29T16:02:55Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,40 @@\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output doesn't rely on free marker templates to be produced, nonetheless it is possible to customize the output using them.\n+GeoServer will lookup for json templates following the same rules defined for the hmtl output. The only difference regards the file names of the templates which have to be named appending ``_json`` to the name, as below:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMjQ3Mg==", "bodyText": "Wondering how much of this new content overlaps with the existing feature info Freemarker tutorial?\nhttps://geoserver.geo-solutions.it/downloads/releases/2.8.x-ld/doc/tutorials/GetFeatureInfo/index.html", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417432472", "createdAt": "2020-04-29T16:04:24Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/html.rst", "diffHunk": "@@ -0,0 +1,161 @@\n+HTML output format\n+===================\n+\n+The default HTML output is a sequence of titled tables, each one for a different layer. The following example shows the default output for the tiger-ny basemap (included in the above cited releases, and onwards).\n+\n+.. figure:: default.png\n+   :align: center\n+\n+   *Default Output*\n+\n+Standard Templates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMjgzNw==", "bodyText": "Also something must be said about multi-layer GetFeatureInfo requests in combination with templated output.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r417432837", "createdAt": "2020-04-29T16:04:59Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,40 @@\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output doesn't rely on free marker templates to be produced, nonetheless it is possible to customize the output using them.\n+GeoServer will lookup for json templates following the same rules defined for the hmtl output. The only difference regards the file names of the templates which have to be named appending ``_json`` to the name, as below:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQzMTUyNA=="}, "originalCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/e6048ff62cf0bfc15f1ee018bf42bd56bf8a794d", "committedDate": "2020-04-10T14:39:47Z", "message": "[GEOS-9570] Allow the possibility to customize the GeoJSON GetFeatureInfo output format using free marker templates"}, "afterCommit": {"oid": "ebcfa627c2db6d8a43f1785728d996894c9c9c0c", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/ebcfa627c2db6d8a43f1785728d996894c9c9c0c", "committedDate": "2020-05-06T16:04:57Z", "message": "reviewer's feedback applied"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ebcfa627c2db6d8a43f1785728d996894c9c9c0c", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/ebcfa627c2db6d8a43f1785728d996894c9c9c0c", "committedDate": "2020-05-06T16:04:57Z", "message": "reviewer's feedback applied"}, "afterCommit": {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/7b1450e0172c8604de5e09c33423a4e455d69aec", "committedDate": "2020-05-07T07:04:16Z", "message": "reviewer's suggestion applied"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MzQ3MTc4", "url": "https://github.com/geoserver/geoserver/pull/4181#pullrequestreview-407347178", "createdAt": "2020-05-07T10:32:42Z", "commit": {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDozMjo0MlrOGR4ghA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDo0NjowOFrOGR47Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwNDgwNA==", "bodyText": "Seems to suggest that in a mixed templated/templated case the templates would still be used for the collections having the template. However, looking at the code, it seems the templates are used only if all collections have them instead. Please clarify.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r421404804", "createdAt": "2020-05-07T10:32:42Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/tutorials/GetFeatureInfo/geojson.rst", "diffHunk": "@@ -0,0 +1,206 @@\n+.. _tutorials_getfeatureinfo_geojson:\n+\n+GeoJSON output format\n+======================\n+\n+The default GeoJSON output uses the WFS GeoJSON  encoding mechanism, producing a fixed output, it is however possible to customize the output using FreeMarker templates.\n+GeoServer will lookup for json templates following the same rules defined for the hmtl output, but the template files have to be named appending ``_json`` to the usual name, as below:\n+\n+* ``header_json.ftl``\n+* ``content_json.ftl``\n+* ``footer_json.ftl``\n+\n+Moreover, unlike the html case, all three template files must be provided.\n+In case of a multi-layer request GeoServer will act in the following way:\n+\n+* content template will be searched up following the usual rules;\n+* since there are no default templates for GeoJSON, header and footer will be looked up in the ``templates`` directory;\n+* features with no content template will be encoded with the normal GeoJSON encoding, along with the customized ones.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwODYxNQ==", "bodyText": "Is this going to encode a valid GeoJSON geometry? How does it work?", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r421408615", "createdAt": "2020-05-07T10:39:52Z", "author": {"login": "aaime"}, "path": "src/wms/src/test/resources/org/geoserver/wms/content_json.ftl", "diffHunk": "@@ -0,0 +1,26 @@\n+<#list features as feature>\n+{\n+\"content\" : \"this is the content\",\n+\"type\": \"Feature\",\n+\"id\" : \"${feature.fid}\",\n+\"geometry_name\":\"the_geom\",\n+<#list feature.attributes as attribute1>\n+<#if attribute1.isGeometry>\n+\"geometry\": \"${attribute1.value}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxMTY3NQ==", "bodyText": "Tried interactively, it does not seem to generate valid GeoJSON:\n{\nheader: \"this is the header\",\ntype: \"FeatureCollection\",\nfeatures: [\n{\ncontent: \"this is the content\",\ntype: \"Feature\",\nid: \"archsites.7\",\ngeometry_name: \"the_geom\",\ngeometry: \"POINT (606635 4920773)\",\nproperties: {\ncat: \"7\",\nstr1: \"Jensen Pass\"\n}\n}\n],\nfooter: \"this is the footer\"\n}\n\nMy guess is that a function to encode a geometry as a valid GeoJSON geometry is missing.", "url": "https://github.com/geoserver/geoserver/pull/4181#discussion_r421411675", "createdAt": "2020-05-07T10:46:08Z", "author": {"login": "aaime"}, "path": "src/wms/src/test/resources/org/geoserver/wms/content_json.ftl", "diffHunk": "@@ -0,0 +1,26 @@\n+<#list features as feature>\n+{\n+\"content\" : \"this is the content\",\n+\"type\": \"Feature\",\n+\"id\" : \"${feature.fid}\",\n+\"geometry_name\":\"the_geom\",\n+<#list feature.attributes as attribute1>\n+<#if attribute1.isGeometry>\n+\"geometry\": \"${attribute1.value}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwODYxNQ=="}, "originalCommit": {"oid": "7b1450e0172c8604de5e09c33423a4e455d69aec"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a08c4a8b467b0de493afdf43f82e4123c3a3ec2b", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/a08c4a8b467b0de493afdf43f82e4123c3a3ec2b", "committedDate": "2020-05-11T06:42:57Z", "message": "[GEOS-9570] Allow the possibility to customize the GeoJSON GetFeatureInfo output format using free marker templates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c45495e4936bf4343b5a8924b1979d0c11103153", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/c45495e4936bf4343b5a8924b1979d0c11103153", "committedDate": "2020-05-11T06:42:57Z", "message": "reviewer's suggestion applied"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9826f9d6477444add511c2f0e6e06685e23c9d12", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/9826f9d6477444add511c2f0e6e06685e23c9d12", "committedDate": "2020-05-08T12:56:44Z", "message": "added template for valid geoJSON and better visibility for template process"}, "afterCommit": {"oid": "f9a2206a66fd2188d80bb694f8a8090ac6cd097e", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/f9a2206a66fd2188d80bb694f8a8090ac6cd097e", "committedDate": "2020-05-11T06:42:57Z", "message": "added template for valid geoJSON and better visibility for template process"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "523c2e4910cf00c8bbec4636c08b9a3578474ec1", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/523c2e4910cf00c8bbec4636c08b9a3578474ec1", "committedDate": "2020-05-11T08:42:36Z", "message": "added template for valid geoJSON and better visibility for template process"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f9a2206a66fd2188d80bb694f8a8090ac6cd097e", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/f9a2206a66fd2188d80bb694f8a8090ac6cd097e", "committedDate": "2020-05-11T06:42:57Z", "message": "added template for valid geoJSON and better visibility for template process"}, "afterCommit": {"oid": "523c2e4910cf00c8bbec4636c08b9a3578474ec1", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/523c2e4910cf00c8bbec4636c08b9a3578474ec1", "committedDate": "2020-05-11T08:42:36Z", "message": "added template for valid geoJSON and better visibility for template process"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1473, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}