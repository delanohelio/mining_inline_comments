{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3MzcwMzI5", "number": 4010, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOToxOTowMVrODdnIUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOToyNzowMFrODdnSdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzc2NDAwOnYy", "diffSide": "RIGHT", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOToxOTowMVrOFmUBVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMToxOTo1MVrOFmXqgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxODIyOA==", "bodyText": "This function would deserve some comments explaining its behavior, and ideally should be break into small chunks. No need to change, just sharing my thoughts.", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375718228", "createdAt": "2020-02-06T09:19:01Z", "author": {"login": "nmco"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -96,57 +112,48 @@ private Object evaluateExpressions(JsonBuilderContext context) {\n                 context = context.getParent();\n                 i++;\n             }\n-            if (namespaces != null) prepareXpathFilter(cql);\n             result = cql.evaluate(context.getCurrentObj());\n         } catch (Exception e) {\n             LOGGER.log(Level.INFO, \"Unable to evaluate expression. Exception: {0}\", e.getMessage());\n         }\n         return result;\n     }\n \n-    private void prepareXpathFilter(Expression expr) {\n-        List<Expression> params = ((Function) expr).getParameters();\n-        if (params.size() > 0) {\n-            for (Expression e : params) {\n-                if (e instanceof XPathFunction) ((XPathFunction) e).setNamespaces(namespaces);\n-                else if (e instanceof Function) {\n-                    prepareXpathFilter(e);\n+    private void literalXpathToPropertyName(Expression expr, String literalXpath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc3NzkyMw==", "bodyText": "Thanks for the review @nmco this feedback has been applied", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375777923", "createdAt": "2020-02-06T11:19:51Z", "author": {"login": "taba90"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -96,57 +112,48 @@ private Object evaluateExpressions(JsonBuilderContext context) {\n                 context = context.getParent();\n                 i++;\n             }\n-            if (namespaces != null) prepareXpathFilter(cql);\n             result = cql.evaluate(context.getCurrentObj());\n         } catch (Exception e) {\n             LOGGER.log(Level.INFO, \"Unable to evaluate expression. Exception: {0}\", e.getMessage());\n         }\n         return result;\n     }\n \n-    private void prepareXpathFilter(Expression expr) {\n-        List<Expression> params = ((Function) expr).getParameters();\n-        if (params.size() > 0) {\n-            for (Expression e : params) {\n-                if (e instanceof XPathFunction) ((XPathFunction) e).setNamespaces(namespaces);\n-                else if (e instanceof Function) {\n-                    prepareXpathFilter(e);\n+    private void literalXpathToPropertyName(Expression expr, String literalXpath) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxODIyOA=="}, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzc2NzM4OnYy", "diffSide": "RIGHT", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOToyMDowOFrOFmUDbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNjoyMzo0M1rOFmhd5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxODc2Ng==", "bodyText": "Here you probably want to check if its a binary expression and setting it accordingly no?", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375718766", "createdAt": "2020-02-06T09:20:08Z", "author": {"login": "nmco"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -96,57 +112,48 @@ private Object evaluateExpressions(JsonBuilderContext context) {\n                 context = context.getParent();\n                 i++;\n             }\n-            if (namespaces != null) prepareXpathFilter(cql);\n             result = cql.evaluate(context.getCurrentObj());\n         } catch (Exception e) {\n             LOGGER.log(Level.INFO, \"Unable to evaluate expression. Exception: {0}\", e.getMessage());\n         }\n         return result;\n     }\n \n-    private void prepareXpathFilter(Expression expr) {\n-        List<Expression> params = ((Function) expr).getParameters();\n-        if (params.size() > 0) {\n-            for (Expression e : params) {\n-                if (e instanceof XPathFunction) ((XPathFunction) e).setNamespaces(namespaces);\n-                else if (e instanceof Function) {\n-                    prepareXpathFilter(e);\n+    private void literalXpathToPropertyName(Expression expr, String literalXpath) {\n+        List<Expression> params = null;\n+        if (expr instanceof Function) {\n+            params = ((Function) expr).getParameters();\n+        } else if (expr instanceof BinaryExpression) {\n+            params =\n+                    Arrays.asList(\n+                            ((BinaryExpression) expr).getExpression1(),\n+                            ((BinaryExpression) expr).getExpression2());\n+        }\n+        List<Expression> newParams = new ArrayList<>(params.size());\n+        if (params != null || params.size() > 0) {\n+            for (int i = 0; i < params.size(); i++) {\n+                Expression e = params.get(i);\n+                if (e instanceof Literal) {\n+                    Literal literal = (Literal) params.get(i);\n+                    String unquoted = literalXpath.replaceAll(\"'\", \"\");\n+                    if (String.valueOf(literal.getValue()).equals(unquoted)) {\n+                        PropertyName pn = new AttributeExpressionImpl(unquoted, namespaces);\n+                        newParams.add(i, pn);\n+                    } else {\n+                        newParams.add(i, e);\n+                    }\n+                } else if (e instanceof Function) {\n+                    newParams.add(e);\n+                    literalXpathToPropertyName(e, literalXpath);\n                 }\n             }\n         }\n-    }\n-\n-    /**\n-     * Determines how many times is needed to walk up {@link JsonBuilderContext} in order to execute\n-     * xpath, and cleans it from ../ notation.\n-     *\n-     * @param xpath\n-     * @return\n-     */\n-    private String determineContextPos(String xpath) {\n-        while (xpath.contains(\"../\")) {\n-            contextPos++;\n-            xpath = xpath.replaceFirst(\"\\\\.\\\\./\", \"\");\n-        }\n-        return xpath;\n-    }\n-\n-    /**\n-     * Extract xpath from a cql expression if present\n-     *\n-     * @param expression\n-     * @return\n-     */\n-    private String workXpathFunction(String expression) {\n-        // extract xpath from cql expression if present\n-        int xpathI = expression.indexOf(\"xpath(\");\n-        if (xpathI != -1) {\n-            int xpathI2 = expression.indexOf(\")\", xpathI);\n-            String xpath = expression.substring(xpathI, xpathI2 + 1);\n-            determineContextPos(xpath);\n-            expression = expression.replaceAll(\"\\\\.\\\\./\", \"\");\n+        if (expr instanceof FunctionExpression) {\n+            ((FunctionExpression) expr).setParameters(newParams);\n+        } else if (expr instanceof MathExpressionImpl) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc3OTAwOA==", "bodyText": "Checking for MathExpressionImpl cause setParameters is available only casting to it. Anyway right now MathExpressionImpl is extended by all the implementation of BinaryExpression", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375779008", "createdAt": "2020-02-06T11:22:24Z", "author": {"login": "taba90"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -96,57 +112,48 @@ private Object evaluateExpressions(JsonBuilderContext context) {\n                 context = context.getParent();\n                 i++;\n             }\n-            if (namespaces != null) prepareXpathFilter(cql);\n             result = cql.evaluate(context.getCurrentObj());\n         } catch (Exception e) {\n             LOGGER.log(Level.INFO, \"Unable to evaluate expression. Exception: {0}\", e.getMessage());\n         }\n         return result;\n     }\n \n-    private void prepareXpathFilter(Expression expr) {\n-        List<Expression> params = ((Function) expr).getParameters();\n-        if (params.size() > 0) {\n-            for (Expression e : params) {\n-                if (e instanceof XPathFunction) ((XPathFunction) e).setNamespaces(namespaces);\n-                else if (e instanceof Function) {\n-                    prepareXpathFilter(e);\n+    private void literalXpathToPropertyName(Expression expr, String literalXpath) {\n+        List<Expression> params = null;\n+        if (expr instanceof Function) {\n+            params = ((Function) expr).getParameters();\n+        } else if (expr instanceof BinaryExpression) {\n+            params =\n+                    Arrays.asList(\n+                            ((BinaryExpression) expr).getExpression1(),\n+                            ((BinaryExpression) expr).getExpression2());\n+        }\n+        List<Expression> newParams = new ArrayList<>(params.size());\n+        if (params != null || params.size() > 0) {\n+            for (int i = 0; i < params.size(); i++) {\n+                Expression e = params.get(i);\n+                if (e instanceof Literal) {\n+                    Literal literal = (Literal) params.get(i);\n+                    String unquoted = literalXpath.replaceAll(\"'\", \"\");\n+                    if (String.valueOf(literal.getValue()).equals(unquoted)) {\n+                        PropertyName pn = new AttributeExpressionImpl(unquoted, namespaces);\n+                        newParams.add(i, pn);\n+                    } else {\n+                        newParams.add(i, e);\n+                    }\n+                } else if (e instanceof Function) {\n+                    newParams.add(e);\n+                    literalXpathToPropertyName(e, literalXpath);\n                 }\n             }\n         }\n-    }\n-\n-    /**\n-     * Determines how many times is needed to walk up {@link JsonBuilderContext} in order to execute\n-     * xpath, and cleans it from ../ notation.\n-     *\n-     * @param xpath\n-     * @return\n-     */\n-    private String determineContextPos(String xpath) {\n-        while (xpath.contains(\"../\")) {\n-            contextPos++;\n-            xpath = xpath.replaceFirst(\"\\\\.\\\\./\", \"\");\n-        }\n-        return xpath;\n-    }\n-\n-    /**\n-     * Extract xpath from a cql expression if present\n-     *\n-     * @param expression\n-     * @return\n-     */\n-    private String workXpathFunction(String expression) {\n-        // extract xpath from cql expression if present\n-        int xpathI = expression.indexOf(\"xpath(\");\n-        if (xpathI != -1) {\n-            int xpathI2 = expression.indexOf(\")\", xpathI);\n-            String xpath = expression.substring(xpathI, xpathI2 + 1);\n-            determineContextPos(xpath);\n-            expression = expression.replaceAll(\"\\\\.\\\\./\", \"\");\n+        if (expr instanceof FunctionExpression) {\n+            ((FunctionExpression) expr).setParameters(newParams);\n+        } else if (expr instanceof MathExpressionImpl) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxODc2Ng=="}, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzODUzNQ==", "bodyText": "Interesting I didn't know that, thx @taba90!", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375938535", "createdAt": "2020-02-06T16:23:43Z", "author": {"login": "nmco"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -96,57 +112,48 @@ private Object evaluateExpressions(JsonBuilderContext context) {\n                 context = context.getParent();\n                 i++;\n             }\n-            if (namespaces != null) prepareXpathFilter(cql);\n             result = cql.evaluate(context.getCurrentObj());\n         } catch (Exception e) {\n             LOGGER.log(Level.INFO, \"Unable to evaluate expression. Exception: {0}\", e.getMessage());\n         }\n         return result;\n     }\n \n-    private void prepareXpathFilter(Expression expr) {\n-        List<Expression> params = ((Function) expr).getParameters();\n-        if (params.size() > 0) {\n-            for (Expression e : params) {\n-                if (e instanceof XPathFunction) ((XPathFunction) e).setNamespaces(namespaces);\n-                else if (e instanceof Function) {\n-                    prepareXpathFilter(e);\n+    private void literalXpathToPropertyName(Expression expr, String literalXpath) {\n+        List<Expression> params = null;\n+        if (expr instanceof Function) {\n+            params = ((Function) expr).getParameters();\n+        } else if (expr instanceof BinaryExpression) {\n+            params =\n+                    Arrays.asList(\n+                            ((BinaryExpression) expr).getExpression1(),\n+                            ((BinaryExpression) expr).getExpression2());\n+        }\n+        List<Expression> newParams = new ArrayList<>(params.size());\n+        if (params != null || params.size() > 0) {\n+            for (int i = 0; i < params.size(); i++) {\n+                Expression e = params.get(i);\n+                if (e instanceof Literal) {\n+                    Literal literal = (Literal) params.get(i);\n+                    String unquoted = literalXpath.replaceAll(\"'\", \"\");\n+                    if (String.valueOf(literal.getValue()).equals(unquoted)) {\n+                        PropertyName pn = new AttributeExpressionImpl(unquoted, namespaces);\n+                        newParams.add(i, pn);\n+                    } else {\n+                        newParams.add(i, e);\n+                    }\n+                } else if (e instanceof Function) {\n+                    newParams.add(e);\n+                    literalXpathToPropertyName(e, literalXpath);\n                 }\n             }\n         }\n-    }\n-\n-    /**\n-     * Determines how many times is needed to walk up {@link JsonBuilderContext} in order to execute\n-     * xpath, and cleans it from ../ notation.\n-     *\n-     * @param xpath\n-     * @return\n-     */\n-    private String determineContextPos(String xpath) {\n-        while (xpath.contains(\"../\")) {\n-            contextPos++;\n-            xpath = xpath.replaceFirst(\"\\\\.\\\\./\", \"\");\n-        }\n-        return xpath;\n-    }\n-\n-    /**\n-     * Extract xpath from a cql expression if present\n-     *\n-     * @param expression\n-     * @return\n-     */\n-    private String workXpathFunction(String expression) {\n-        // extract xpath from cql expression if present\n-        int xpathI = expression.indexOf(\"xpath(\");\n-        if (xpathI != -1) {\n-            int xpathI2 = expression.indexOf(\")\", xpathI);\n-            String xpath = expression.substring(xpathI, xpathI2 + 1);\n-            determineContextPos(xpath);\n-            expression = expression.replaceAll(\"\\\\.\\\\./\", \"\");\n+        if (expr instanceof FunctionExpression) {\n+            ((FunctionExpression) expr).setParameters(newParams);\n+        } else if (expr instanceof MathExpressionImpl) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxODc2Ng=="}, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzc3MTgxOnYy", "diffSide": "RIGHT", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOToyMTozM1rOFmUGJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMToyMDoxMFrOFmXq9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxOTQ2MQ==", "bodyText": "This should be isolated in a more meaningful private method and some comments explaining waht's going on added.", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375719461", "createdAt": "2020-02-06T09:21:33Z", "author": {"login": "nmco"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -38,10 +41,23 @@ public DynamicValueBuilder(String key, String expression, NamespaceSupport names\n         super(key);\n         this.namespaces = namespaces;\n         if (expression.startsWith(\"$${\")) {\n-            this.cql = ExpressionsUtils.extractCqlExpressions(workXpathFunction(expression));\n+            // takes xpath fun from cql", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc3ODAzNg==", "bodyText": "applied too", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375778036", "createdAt": "2020-02-06T11:20:10Z", "author": {"login": "taba90"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -38,10 +41,23 @@ public DynamicValueBuilder(String key, String expression, NamespaceSupport names\n         super(key);\n         this.namespaces = namespaces;\n         if (expression.startsWith(\"$${\")) {\n-            this.cql = ExpressionsUtils.extractCqlExpressions(workXpathFunction(expression));\n+            // takes xpath fun from cql", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxOTQ2MQ=="}, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzc3MjIyOnYy", "diffSide": "RIGHT", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOToyMTo0MlrOFmUGZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOToyMTo0MlrOFmUGZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxOTUyNQ==", "bodyText": "Same as above here.", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375719525", "createdAt": "2020-02-06T09:21:42Z", "author": {"login": "nmco"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -38,10 +41,23 @@ public DynamicValueBuilder(String key, String expression, NamespaceSupport names\n         super(key);\n         this.namespaces = namespaces;\n         if (expression.startsWith(\"$${\")) {\n-            this.cql = ExpressionsUtils.extractCqlExpressions(workXpathFunction(expression));\n+            // takes xpath fun from cql\n+            String strXpathFun = extractXpathFromCQL(expression);\n+            if (strXpathFun.indexOf(XPATH_FUN_START) != -1)\n+                this.contextPos = determineContextPos(strXpathFun);\n+            // takes the literal argument of xpathFun\n+            String literalXpath = getLiteralXpath(strXpathFun);\n+\n+            // clean the function to obtain a cql expression without xpath() syntax\n+            this.cql =\n+                    extractCqlExpressions(\n+                            cleanCQLExpression(expression, strXpathFun, literalXpath));\n+            // replace the xpath literal inside the expression with a PropertyName\n+            literalXpathToPropertyName(this.cql, removeBackDots(literalXpath));\n         } else if (expression.startsWith(\"${\")) {\n-            String strXpath = ExpressionsUtils.extractXpath(expression);\n-            strXpath = determineContextPos(strXpath);\n+            String strXpath = extractXpath(expression);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzc3NTg5OnYy", "diffSide": "RIGHT", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/expressions/ExpressionsUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOToyMjo1NVrOFmUIow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxMTo0OToxM1rOFmYaWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcyMDA5OQ==", "bodyText": "This java doc looks bad.", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375720099", "createdAt": "2020-02-06T09:22:55Z", "author": {"login": "nmco"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/expressions/ExpressionsUtils.java", "diffHunk": "@@ -220,6 +222,12 @@ public static String quoteXpathAttribute(String xpath) {\n         return xpath;\n     }\n \n+    /**\n+     * Extract Namespaces from given FeatureType\n+     *\n+     * @param type\n+     * @return\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5MDE3MA==", "bodyText": "fixed", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375790170", "createdAt": "2020-02-06T11:49:13Z", "author": {"login": "taba90"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/expressions/ExpressionsUtils.java", "diffHunk": "@@ -220,6 +222,12 @@ public static String quoteXpathAttribute(String xpath) {\n         return xpath;\n     }\n \n+    /**\n+     * Extract Namespaces from given FeatureType\n+     *\n+     * @param type\n+     * @return\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcyMDA5OQ=="}, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzc4OTk5OnYy", "diffSide": "RIGHT", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/expressions/ExpressionsUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwOToyNzowMFrOFmURMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNjoyNDozOFrOFmhgMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcyMjI4OQ==", "bodyText": "@taba90 I have a doubt here, if someone writes xpath  ( (notice the extra spaces) in a CQL expression will this be valid? If no then we are good, if yes then this matching needs to be improved.", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375722289", "createdAt": "2020-02-06T09:27:00Z", "author": {"login": "nmco"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/expressions/ExpressionsUtils.java", "diffHunk": "@@ -251,4 +259,70 @@ public static String removeQuotes(String cqlFilter) {\n         }\n         return strBuilder.toString();\n     }\n+\n+    /**\n+     * Clean a CQL expression from the xpath function syntax to make the xpath suitable to be\n+     * encoded as a PropertyName\n+     *\n+     * @param expression\n+     * @param toReplace\n+     * @param replacement\n+     * @return\n+     */\n+    public static String cleanCQLExpression(\n+            String expression, String toReplace, String replacement) {\n+        if (expression.indexOf(XPATH_FUN_START) != -1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5MDEwMw==", "bodyText": "checked: an \"xpath (\" won't be considered valid", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375790103", "createdAt": "2020-02-06T11:49:04Z", "author": {"login": "taba90"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/expressions/ExpressionsUtils.java", "diffHunk": "@@ -251,4 +259,70 @@ public static String removeQuotes(String cqlFilter) {\n         }\n         return strBuilder.toString();\n     }\n+\n+    /**\n+     * Clean a CQL expression from the xpath function syntax to make the xpath suitable to be\n+     * encoded as a PropertyName\n+     *\n+     * @param expression\n+     * @param toReplace\n+     * @param replacement\n+     * @return\n+     */\n+    public static String cleanCQLExpression(\n+            String expression, String toReplace, String replacement) {\n+        if (expression.indexOf(XPATH_FUN_START) != -1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcyMjI4OQ=="}, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzOTEyMQ==", "bodyText": "ok, thx", "url": "https://github.com/geoserver/geoserver/pull/4010#discussion_r375939121", "createdAt": "2020-02-06T16:24:38Z", "author": {"login": "nmco"}, "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/expressions/ExpressionsUtils.java", "diffHunk": "@@ -251,4 +259,70 @@ public static String removeQuotes(String cqlFilter) {\n         }\n         return strBuilder.toString();\n     }\n+\n+    /**\n+     * Clean a CQL expression from the xpath function syntax to make the xpath suitable to be\n+     * encoded as a PropertyName\n+     *\n+     * @param expression\n+     * @param toReplace\n+     * @param replacement\n+     * @return\n+     */\n+    public static String cleanCQLExpression(\n+            String expression, String toReplace, String replacement) {\n+        if (expression.indexOf(XPATH_FUN_START) != -1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcyMjI4OQ=="}, "originalCommit": {"oid": "f238987e99e68be789dc2455ec98fa7bdcb249c1"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4064, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}