{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5ODYwMzEw", "number": 4344, "title": "[GEOS-9663] Add support for GEOJSON output in the JSON-LD module and rename it", "bodyText": "Jira ticket: https://osgeo-org.atlassian.net/browse/GEOS-9663\nThis pull request:\n\nadd support for GeoJSON output (normal and INSPIRE alternative version);\nrename the module to wfs-templating in case of future module extension regarding output format different from json (eg. gml)\n\nChecklist\n\nReviewing is a process done by project maintainers, mostly on a volunteer basis. We try to keep the overhead as small as possible and appreciate if you help us to do so by completing the following items. Feel free to ask in a comment if you have troubles with any of them.\n\nSubmitting the PR does not require you to check all items, but by the time it gets merged, they should be either satisfied or inapplicable.\nFor all pull requests:\n\n Confirm you have read the contribution guidelines\n You have sent a Contribution Licence Agreement (CLA) as necessary (not required for small changes, e.g., fixing typos in documentation)\n Make sure the first PR targets the master branch, eventual backports will be managed later. This can be ignored if the PR is fixing an issue that only happens in a specific branch, but not in newer ones.\n\nThe following are required only for core and extension modules (they are welcomed, but not required, for community modules):\n\n There is a ticket in Jira describing the issue/improvement/feature (a notable exemptions is, changes not visible to end users)\n PR for bug fixes and small new features are presented as a single commit\n Commit message must be in the form \"[GEOS-XYZW] Title of the Jira ticket\" (export to XML in Jira generates the message in this exact form)\n The pull request contains changes related to a single objective. If multiple focuses cannot be avoided, each one is in its own commit and has a separate ticket describing it.\n New unit tests have been added covering the changes\n This PR passes all existing unit tests (test results will be reported by travis-ci after opening this PR)\n This PR passes the QA checks (QA checks results will be reported by travis-ci after opening this PR)\n Commits changing the UI, existing user workflows, or adding new functionality, need to include documentation updates (screenshots, text)\n Commits changing the REST API, or any configuration object, should check if the REST API docs (Swagger YAML files and classic documentation) need to be updated.", "createdAt": "2020-06-25T09:05:31Z", "url": "https://github.com/geoserver/geoserver/pull/4344", "merged": true, "mergeCommit": {"oid": "051b3df46091d2a086bed5c248aa96aaae0fff85"}, "closed": true, "closedAt": "2020-07-10T08:40:54Z", "author": {"login": "taba90"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcvEsPeABqjM0ODcwMDQ5MzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczK1uQgBqjM1Mjg1OTkyMjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8ccf85890e60d9943cf3f285f555d44884053f3", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/b8ccf85890e60d9943cf3f285f555d44884053f3", "committedDate": "2020-06-25T09:04:32Z", "message": "refactoring"}, "afterCommit": {"oid": "2fbc72eb264084e4f59609ec83bbd8c644b40c8d", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/2fbc72eb264084e4f59609ec83bbd8c644b40c8d", "committedDate": "2020-06-26T15:04:39Z", "message": "refactoring"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fbc72eb264084e4f59609ec83bbd8c644b40c8d", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/2fbc72eb264084e4f59609ec83bbd8c644b40c8d", "committedDate": "2020-06-26T15:04:39Z", "message": "refactoring"}, "afterCommit": {"oid": "980df02467b664426ea087930561f37e45f92664", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/980df02467b664426ea087930561f37e45f92664", "committedDate": "2020-06-29T07:02:40Z", "message": "refactoring"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjA0MjYy", "url": "https://github.com/geoserver/geoserver/pull/4344#pullrequestreview-439204262", "createdAt": "2020-06-29T14:31:36Z", "commit": {"oid": "980df02467b664426ea087930561f37e45f92664"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNDozMTozNlrOGqTvNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNTowNjowM1rOGqVTZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxNjc1Nw==", "bodyText": "Un-necessary override", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447016757", "createdAt": "2020-06-29T14:31:36Z", "author": {"login": "aaime"}, "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/writers/GeoJsonWriter.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+\n+package org.geoserver.wfstemplating.writers;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import org.geotools.geojson.geom.GeometryJSON;\n+import org.locationtech.jts.geom.Geometry;\n+\n+/** Implements its superclass methods to write a valid GeoJSON output */\n+public class GeoJsonWriter extends CommonJsonWriter {\n+\n+    public GeoJsonWriter(JsonGenerator generator, boolean flattenedList) {\n+        super(generator, flattenedList);\n+    }\n+\n+    @Override\n+    protected void writeValue(Object value) throws IOException {\n+        if (value instanceof String) {\n+            writeString((String) value);\n+        } else if (value instanceof Integer) {\n+            writeNumber((Integer) value);\n+        } else if (value instanceof Double) {\n+            writeNumber((Double) value);\n+        } else if (value instanceof Float) {\n+            writeNumber((Float) value);\n+        } else if (value instanceof Long) {\n+            writeNumber((Long) value);\n+        } else if (value instanceof BigInteger) {\n+            writeNumber((BigInteger) value);\n+        } else if (value instanceof BigDecimal) {\n+            writeNumber((BigDecimal) value);\n+        } else if (value instanceof Boolean) {\n+            writeBoolean((Boolean) value);\n+        }\n+    }\n+\n+    @Override\n+    protected void writeGeometry(Object value) throws IOException {\n+        GeometryJSON geomJson = new GeometryJSON();\n+        String strGeom = geomJson.toString((Geometry) value);\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode actualObj = mapper.readTree(strGeom);\n+        writeObjectNode(null, actualObj);\n+    }\n+\n+    @Override\n+    public void startJson() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980df02467b664426ea087930561f37e45f92664"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAxNzA0MA==", "bodyText": "Wondering why the GeoJson writer has a writeValue method that looks a lot smarter than the jsonld one?", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447017040", "createdAt": "2020-06-29T14:31:57Z", "author": {"login": "aaime"}, "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/writers/GeoJsonWriter.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+\n+package org.geoserver.wfstemplating.writers;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import org.geotools.geojson.geom.GeometryJSON;\n+import org.locationtech.jts.geom.Geometry;\n+\n+/** Implements its superclass methods to write a valid GeoJSON output */\n+public class GeoJsonWriter extends CommonJsonWriter {\n+\n+    public GeoJsonWriter(JsonGenerator generator, boolean flattenedList) {\n+        super(generator, flattenedList);\n+    }\n+\n+    @Override\n+    protected void writeValue(Object value) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980df02467b664426ea087930561f37e45f92664"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyMjYzOA==", "bodyText": "Looking at the code, it seems the flat output is managed also in JSON_LD mode. I would clarify that's the case, renaming this section \"Flat output mode\" and then making an example that cites the new  INSPIRE flat GeoJSON as an example.", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447022638", "createdAt": "2020-06-29T14:39:27Z", "author": {"login": "aaime"}, "path": "doc/en/user/source/community/wfs-templating/configuration.rst", "diffHunk": "@@ -222,4 +299,76 @@ The evaluation of a filter is handled by the module in the following way:\n   \n   * in case of a static content attribute, the static content will be included in the output if the filter condition is true.\n   \n-  * in case the expression is not matched, the content, static or dynamic, will not be set, resulting in the attribute being skipped.\n\\ No newline at end of file\n+  * in case the expression is not matched, the content, static or dynamic, will not be set, resulting in the attribute being skipped.\n+\n+\n+Inspire GeoJSON Output\n+----------------------\n+\n+In order to provide a GeoJSON output encoded following INSPIRE rule for `alternative feature GeoJSON encoding <https://github.com/INSPIRE-MIF/2017.2/blob/master/GeoJSON/ads/simple-addresses.md>`_, it is possible to provide a VendorOption in the template file by adding the following attribute :code:`\"$VendorOptions\": \"flat_output:true\"`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980df02467b664426ea087930561f37e45f92664"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzMjEzMg==", "bodyText": "Confused... here it checks only the first feature type, but then during the loop each feature type is checked for template presence too. So, isn't this check redundant? The same seems to be happening in the GEoJSONTemplateGetFeatureResponse", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447032132", "createdAt": "2020-06-29T14:52:07Z", "author": {"login": "aaime"}, "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/response/JSONLDGetFeatureResponse.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wfstemplating.response;\n+\n+import java.io.*;\n+import java.util.List;\n+import org.geoserver.catalog.FeatureTypeInfo;\n+import org.geoserver.config.GeoServer;\n+import org.geoserver.platform.Operation;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.wfs.WFSGetFeatureOutputFormat;\n+import org.geoserver.wfs.request.FeatureCollectionResponse;\n+import org.geoserver.wfs.request.GetFeatureRequest;\n+import org.geoserver.wfstemplating.builders.TemplateBuilder;\n+import org.geoserver.wfstemplating.builders.impl.RootBuilder;\n+import org.geoserver.wfstemplating.builders.impl.TemplateBuilderContext;\n+import org.geoserver.wfstemplating.builders.jsonld.JsonLdRootBuilder;\n+import org.geoserver.wfstemplating.configuration.TemplateConfiguration;\n+import org.geoserver.wfstemplating.configuration.TemplateIdentifier;\n+import org.geoserver.wfstemplating.writers.JsonLdWriter;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+\n+/**\n+ * Encodes features in json-ld output format by means of a ${@link TemplateBuilder} tree obtained by\n+ * a JSON-LD template\n+ */\n+public class JSONLDGetFeatureResponse extends WFSGetFeatureOutputFormat {\n+\n+    /** The MIME type for a JSON-LD response* */\n+    public static final String MIME = \"application/ld+json\";\n+\n+    private TemplateConfiguration configuration;\n+\n+    public JSONLDGetFeatureResponse(GeoServer gs, TemplateConfiguration configuration) {\n+        super(gs, MIME);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    protected void write(\n+            FeatureCollectionResponse featureCollection, OutputStream output, Operation getFeature)\n+            throws ServiceException {\n+\n+        TemplateGetFeatureResponseHelper helper =\n+                new TemplateGetFeatureResponseHelper(gs.getCatalog(), TemplateIdentifier.JSONLD);\n+        FeatureTypeInfo info =\n+                helper.getFeatureTypeInfo(GetFeatureRequest.adapt(getFeature.getParameters()[0]));\n+        JsonLdWriter writer = null;\n+        try {\n+            JsonLdRootBuilder rootBuilder =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980df02467b664426ea087930561f37e45f92664"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAzNjI5Mg==", "bodyText": "This class and GeoJsonTemplateGetFeatureResponse look very similar to me... comparing them with a diff tool, seem to suggest they might be actually the same class, with parameters to specify which type of builders to use,\nor a common base class with subclasses filling the parameters in the constructor.", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447036292", "createdAt": "2020-06-29T14:57:36Z", "author": {"login": "aaime"}, "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/response/JSONLDGetFeatureResponse.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wfstemplating.response;\n+\n+import java.io.*;\n+import java.util.List;\n+import org.geoserver.catalog.FeatureTypeInfo;\n+import org.geoserver.config.GeoServer;\n+import org.geoserver.platform.Operation;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.wfs.WFSGetFeatureOutputFormat;\n+import org.geoserver.wfs.request.FeatureCollectionResponse;\n+import org.geoserver.wfs.request.GetFeatureRequest;\n+import org.geoserver.wfstemplating.builders.TemplateBuilder;\n+import org.geoserver.wfstemplating.builders.impl.RootBuilder;\n+import org.geoserver.wfstemplating.builders.impl.TemplateBuilderContext;\n+import org.geoserver.wfstemplating.builders.jsonld.JsonLdRootBuilder;\n+import org.geoserver.wfstemplating.configuration.TemplateConfiguration;\n+import org.geoserver.wfstemplating.configuration.TemplateIdentifier;\n+import org.geoserver.wfstemplating.writers.JsonLdWriter;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+\n+/**\n+ * Encodes features in json-ld output format by means of a ${@link TemplateBuilder} tree obtained by\n+ * a JSON-LD template\n+ */\n+public class JSONLDGetFeatureResponse extends WFSGetFeatureOutputFormat {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980df02467b664426ea087930561f37e45f92664"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MDQ4Mg==", "bodyText": "Unsure what's happening here... seems like a workaround for an issue with response resolution? Ah, I'm guessing the dispatcher would not be happy to see two responses producing the same output for the same request and mime type, and it would conflict with the main GeoJSON response?", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447040482", "createdAt": "2020-06-29T15:03:27Z", "author": {"login": "aaime"}, "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/request/JsonTemplateCallBackOGC.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wfstemplating.request;\n+\n+import java.io.OutputStream;\n+import org.geoserver.api.features.FeaturesResponse;\n+import org.geoserver.catalog.Catalog;\n+import org.geoserver.catalog.FeatureTypeInfo;\n+import org.geoserver.config.GeoServer;\n+import org.geoserver.ows.AbstractDispatcherCallback;\n+import org.geoserver.ows.DispatcherCallback;\n+import org.geoserver.ows.Request;\n+import org.geoserver.ows.Response;\n+import org.geoserver.platform.GeoServerExtensions;\n+import org.geoserver.platform.Operation;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.util.XCQL;\n+import org.geoserver.wfs.json.GeoJSONGetFeatureResponse;\n+import org.geoserver.wfs.request.FeatureCollectionResponse;\n+import org.geoserver.wfstemplating.builders.TemplateBuilder;\n+import org.geoserver.wfstemplating.builders.impl.RootBuilder;\n+import org.geoserver.wfstemplating.configuration.TemplateConfiguration;\n+import org.geoserver.wfstemplating.configuration.TemplateIdentifier;\n+import org.geoserver.wfstemplating.expressions.JsonLdCQLManager;\n+import org.geoserver.wfstemplating.response.GeoJsonTemplateGetFeatureResponse;\n+import org.geotools.filter.text.ecql.ECQL;\n+import org.opengis.filter.Filter;\n+import org.springframework.http.HttpHeaders;\n+\n+/**\n+ * This {@link DispatcherCallback} implementation OGCAPI compliant that checks on operation\n+ * dispatched event if a json-ld path has been provided to cql_filter and evaluate it against the\n+ * {@link TemplateBuilder} tree to get the corresponding {@link Filter}\n+ */\n+public class JsonTemplateCallBackOGC extends AbstractDispatcherCallback {\n+\n+    private Catalog catalog;\n+\n+    private TemplateConfiguration configuration;\n+\n+    private GeoServer gs;\n+\n+    public JsonTemplateCallBackOGC(GeoServer gs, TemplateConfiguration configuration) {\n+        this.catalog = gs.getCatalog();\n+        this.configuration = configuration;\n+        this.gs = gs;\n+    }\n+\n+    @Override\n+    public Operation operationDispatched(Request request, Operation operation) {\n+        String outputFormat = getFormatSupportingTemplating(request);\n+        if (\"FEATURES\".equalsIgnoreCase(request.getService()) && outputFormat != null) {\n+            try {\n+                String filterLang = (String) request.getKvp().get(\"FILTER-LANG\");\n+                if (filterLang != null && filterLang.equalsIgnoreCase(\"CQL-TEXT\")) {\n+                    String filter = (String) request.getKvp().get(\"FILTER\");\n+                    replaceJsonLdPathWithFilter(filter, outputFormat, operation);\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return super.operationDispatched(request, operation);\n+    }\n+\n+    private FeatureTypeInfo getFeatureType(String collectionId) {\n+        FeatureTypeInfo featureType = catalog.getFeatureTypeByName(collectionId);\n+        if (featureType == null) {\n+            throw new ServiceException(\n+                    \"Unknown collection \" + collectionId,\n+                    ServiceException.INVALID_PARAMETER_VALUE,\n+                    \"collectionId\");\n+        }\n+        return featureType;\n+    }\n+\n+    private String getFormatSupportingTemplating(Request request) {\n+        String accept = request.getHttpRequest().getHeader(HttpHeaders.ACCEPT);\n+        String format = request.getKvp() != null ? (String) request.getKvp().get(\"f\") : null;\n+        if (format != null\n+                && (format.equals(TemplateIdentifier.JSONLD.getOutputFormat())\n+                        || format.equals(TemplateIdentifier.GEOJSON.getOutputFormat()))) {\n+            return format;\n+        } else if (accept != null) {\n+            if (accept.contains(TemplateIdentifier.GEOJSON.getOutputFormat()))\n+                return TemplateIdentifier.GEOJSON.getOutputFormat();\n+            else if (accept.contains(TemplateIdentifier.JSONLD.getOutputFormat()))\n+                return TemplateIdentifier.JSONLD.getOutputFormat();\n+        }\n+        return null;\n+    }\n+\n+    private void replaceJsonLdPathWithFilter(\n+            String strFilter, String outputFormat, Operation operation) throws Exception {\n+        if (strFilter != null && strFilter.indexOf(\".\") != -1) {\n+            FeatureTypeInfo typeInfo = getFeatureType((String) operation.getParameters()[0]);\n+            RootBuilder root = configuration.getTemplate(typeInfo, outputFormat);\n+            if (root != null) {\n+                JsonPathVisitor visitor = new JsonPathVisitor(typeInfo.getFeatureType());\n+                /* Todo find a better way to replace json-ld path with corresponding template attribute*/\n+                // Get filter from string in order to make it accept the visitor\n+                Filter f = (Filter) XCQL.toFilter(strFilter).accept(visitor, root);\n+                // Taking back a string from Function cause\n+                // OGC API get a string cql filter from query string\n+                String newFilter =\n+                        JsonLdCQLManager.removeQuotes(ECQL.toCQL(f)).replaceAll(\"/\", \".\");\n+                newFilter = JsonLdCQLManager.quoteXpathAttribute(newFilter);\n+                for (int i = 0; i < operation.getParameters().length; i++) {\n+                    Object p = operation.getParameters()[i];\n+                    if (p != null && ((String.valueOf(p)).trim().equals(strFilter.trim()))) {\n+                        operation.getParameters()[i] = newFilter;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Response responseDispatched(\n+            Request request, Operation operation, Object result, Response response) {\n+        String format = getFormatSupportingTemplating(request);\n+        if (format != null && format.equals(TemplateIdentifier.GEOJSON.getOutputFormat())) {\n+            FeatureTypeInfo typeInfo = null;\n+            typeInfo = getFeatureType((String) operation.getParameters()[0]);\n+            if (typeInfo != null) {\n+                try {\n+                    RootBuilder root = configuration.getTemplate(typeInfo, format);\n+                    if (root != null) {\n+                        GeoJSONGetFeatureResponse featureResponse =\n+                                (GeoJSONGetFeatureResponse)\n+                                        GeoServerExtensions.bean(\"geoJSONGetFeatureResponse\");\n+                        GeoJsonTemplateGetFeatureResponse templatingResp =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980df02467b664426ea087930561f37e45f92664"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MTIwNA==", "bodyText": "Could you please reduce a bit the nesting level? There is no requirement to put everything in the same method, once you determined you want to replace the response, you can call a different method that does exactly that, and give it a name that explains the purpose in the process too (e.g., \"replaceResponse(...)\").", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447041204", "createdAt": "2020-06-29T15:04:28Z", "author": {"login": "aaime"}, "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/request/JsonTemplateCallBackOGC.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wfstemplating.request;\n+\n+import java.io.OutputStream;\n+import org.geoserver.api.features.FeaturesResponse;\n+import org.geoserver.catalog.Catalog;\n+import org.geoserver.catalog.FeatureTypeInfo;\n+import org.geoserver.config.GeoServer;\n+import org.geoserver.ows.AbstractDispatcherCallback;\n+import org.geoserver.ows.DispatcherCallback;\n+import org.geoserver.ows.Request;\n+import org.geoserver.ows.Response;\n+import org.geoserver.platform.GeoServerExtensions;\n+import org.geoserver.platform.Operation;\n+import org.geoserver.platform.ServiceException;\n+import org.geoserver.util.XCQL;\n+import org.geoserver.wfs.json.GeoJSONGetFeatureResponse;\n+import org.geoserver.wfs.request.FeatureCollectionResponse;\n+import org.geoserver.wfstemplating.builders.TemplateBuilder;\n+import org.geoserver.wfstemplating.builders.impl.RootBuilder;\n+import org.geoserver.wfstemplating.configuration.TemplateConfiguration;\n+import org.geoserver.wfstemplating.configuration.TemplateIdentifier;\n+import org.geoserver.wfstemplating.expressions.JsonLdCQLManager;\n+import org.geoserver.wfstemplating.response.GeoJsonTemplateGetFeatureResponse;\n+import org.geotools.filter.text.ecql.ECQL;\n+import org.opengis.filter.Filter;\n+import org.springframework.http.HttpHeaders;\n+\n+/**\n+ * This {@link DispatcherCallback} implementation OGCAPI compliant that checks on operation\n+ * dispatched event if a json-ld path has been provided to cql_filter and evaluate it against the\n+ * {@link TemplateBuilder} tree to get the corresponding {@link Filter}\n+ */\n+public class JsonTemplateCallBackOGC extends AbstractDispatcherCallback {\n+\n+    private Catalog catalog;\n+\n+    private TemplateConfiguration configuration;\n+\n+    private GeoServer gs;\n+\n+    public JsonTemplateCallBackOGC(GeoServer gs, TemplateConfiguration configuration) {\n+        this.catalog = gs.getCatalog();\n+        this.configuration = configuration;\n+        this.gs = gs;\n+    }\n+\n+    @Override\n+    public Operation operationDispatched(Request request, Operation operation) {\n+        String outputFormat = getFormatSupportingTemplating(request);\n+        if (\"FEATURES\".equalsIgnoreCase(request.getService()) && outputFormat != null) {\n+            try {\n+                String filterLang = (String) request.getKvp().get(\"FILTER-LANG\");\n+                if (filterLang != null && filterLang.equalsIgnoreCase(\"CQL-TEXT\")) {\n+                    String filter = (String) request.getKvp().get(\"FILTER\");\n+                    replaceJsonLdPathWithFilter(filter, outputFormat, operation);\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return super.operationDispatched(request, operation);\n+    }\n+\n+    private FeatureTypeInfo getFeatureType(String collectionId) {\n+        FeatureTypeInfo featureType = catalog.getFeatureTypeByName(collectionId);\n+        if (featureType == null) {\n+            throw new ServiceException(\n+                    \"Unknown collection \" + collectionId,\n+                    ServiceException.INVALID_PARAMETER_VALUE,\n+                    \"collectionId\");\n+        }\n+        return featureType;\n+    }\n+\n+    private String getFormatSupportingTemplating(Request request) {\n+        String accept = request.getHttpRequest().getHeader(HttpHeaders.ACCEPT);\n+        String format = request.getKvp() != null ? (String) request.getKvp().get(\"f\") : null;\n+        if (format != null\n+                && (format.equals(TemplateIdentifier.JSONLD.getOutputFormat())\n+                        || format.equals(TemplateIdentifier.GEOJSON.getOutputFormat()))) {\n+            return format;\n+        } else if (accept != null) {\n+            if (accept.contains(TemplateIdentifier.GEOJSON.getOutputFormat()))\n+                return TemplateIdentifier.GEOJSON.getOutputFormat();\n+            else if (accept.contains(TemplateIdentifier.JSONLD.getOutputFormat()))\n+                return TemplateIdentifier.JSONLD.getOutputFormat();\n+        }\n+        return null;\n+    }\n+\n+    private void replaceJsonLdPathWithFilter(\n+            String strFilter, String outputFormat, Operation operation) throws Exception {\n+        if (strFilter != null && strFilter.indexOf(\".\") != -1) {\n+            FeatureTypeInfo typeInfo = getFeatureType((String) operation.getParameters()[0]);\n+            RootBuilder root = configuration.getTemplate(typeInfo, outputFormat);\n+            if (root != null) {\n+                JsonPathVisitor visitor = new JsonPathVisitor(typeInfo.getFeatureType());\n+                /* Todo find a better way to replace json-ld path with corresponding template attribute*/\n+                // Get filter from string in order to make it accept the visitor\n+                Filter f = (Filter) XCQL.toFilter(strFilter).accept(visitor, root);\n+                // Taking back a string from Function cause\n+                // OGC API get a string cql filter from query string\n+                String newFilter =\n+                        JsonLdCQLManager.removeQuotes(ECQL.toCQL(f)).replaceAll(\"/\", \".\");\n+                newFilter = JsonLdCQLManager.quoteXpathAttribute(newFilter);\n+                for (int i = 0; i < operation.getParameters().length; i++) {\n+                    Object p = operation.getParameters()[i];\n+                    if (p != null && ((String.valueOf(p)).trim().equals(strFilter.trim()))) {\n+                        operation.getParameters()[i] = newFilter;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Response responseDispatched(\n+            Request request, Operation operation, Object result, Response response) {\n+        String format = getFormatSupportingTemplating(request);\n+        if (format != null && format.equals(TemplateIdentifier.GEOJSON.getOutputFormat())) {\n+            FeatureTypeInfo typeInfo = null;\n+            typeInfo = getFeatureType((String) operation.getParameters()[0]);\n+            if (typeInfo != null) {\n+                try {\n+                    RootBuilder root = configuration.getTemplate(typeInfo, format);\n+                    if (root != null) {\n+                        GeoJSONGetFeatureResponse featureResponse =\n+                                (GeoJSONGetFeatureResponse)\n+                                        GeoServerExtensions.bean(\"geoJSONGetFeatureResponse\");\n+                        GeoJsonTemplateGetFeatureResponse templatingResp =\n+                                new GeoJsonTemplateGetFeatureResponse(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980df02467b664426ea087930561f37e45f92664"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MjQwNA==", "bodyText": "When the formatter starts wrapping variable declaration and simple assignments over two lines, it's a sign you're nesting too much, try to split the method in two or more, keep shorter (but significant, and well named) methods instead.", "url": "https://github.com/geoserver/geoserver/pull/4344#discussion_r447042404", "createdAt": "2020-06-29T15:06:03Z", "author": {"login": "aaime"}, "path": "src/community/wfs-templating/src/main/java/org/geoserver/wfstemplating/request/JsonTemplateCallback.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+ * This code is licensed under the GPL 2.0 license, available at the root\n+ * application directory.\n+ */\n+package org.geoserver.wfstemplating.request;\n+\n+import java.util.List;\n+import javax.xml.namespace.QName;\n+import org.geoserver.catalog.*;\n+import org.geoserver.config.GeoServer;\n+import org.geoserver.ows.AbstractDispatcherCallback;\n+import org.geoserver.ows.DispatcherCallback;\n+import org.geoserver.ows.Request;\n+import org.geoserver.ows.Response;\n+import org.geoserver.platform.Operation;\n+import org.geoserver.wfs.json.GeoJSONGetFeatureResponse;\n+import org.geoserver.wfs.request.GetFeatureRequest;\n+import org.geoserver.wfs.request.Query;\n+import org.geoserver.wfstemplating.builders.TemplateBuilder;\n+import org.geoserver.wfstemplating.builders.impl.RootBuilder;\n+import org.geoserver.wfstemplating.configuration.TemplateConfiguration;\n+import org.geoserver.wfstemplating.configuration.TemplateIdentifier;\n+import org.geoserver.wfstemplating.response.GeoJsonTemplateGetFeatureResponse;\n+import org.geotools.feature.NameImpl;\n+import org.opengis.filter.Filter;\n+\n+/**\n+ * This {@link DispatcherCallback} implementation checks on operation dispatched event if a json-ld\n+ * path has been provided to cql_filter and evaluate it against the {@link TemplateBuilder} tree to\n+ * get the corresponding {@link Filter}\n+ */\n+public class JsonTemplateCallback extends AbstractDispatcherCallback {\n+\n+    private Catalog catalog;\n+\n+    private GeoServer gs;\n+\n+    private TemplateConfiguration configuration;\n+\n+    public JsonTemplateCallback(GeoServer gs, TemplateConfiguration configuration) {\n+        this.gs = gs;\n+        this.catalog = gs.getCatalog();\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Operation operationDispatched(Request request, Operation operation) {\n+        if (\"WFS\".equalsIgnoreCase(request.getService())\n+                && request.getOutputFormat() != null\n+                && (request.getOutputFormat().equals(TemplateIdentifier.JSONLD.getOutputFormat())\n+                        || request.getOutputFormat()\n+                                .equals(TemplateIdentifier.GEOJSON.getOutputFormat()))) {\n+            FeatureTypeInfo typeInfo = null;\n+            GetFeatureRequest getFeature = null;\n+            getFeature = GetFeatureRequest.adapt(operation.getParameters()[0]);\n+            List<Query> queries = getFeature.getQueries();\n+            if (getFeature != null && queries != null && queries.size() > 0) {\n+                for (int i = 0; i < queries.size(); i++) {\n+                    Query q = queries.get(i);\n+                    QName type = q.getTypeNames().get(0);\n+                    typeInfo =\n+                            catalog.getFeatureTypeByName(\n+                                    new NameImpl(type.getPrefix(), type.getLocalPart()));\n+                    if (typeInfo != null) {\n+                        try {\n+                            RootBuilder root =\n+                                    configuration.getTemplate(typeInfo, request.getOutputFormat());\n+                            if (root != null) {\n+                                JsonPathVisitor visitor =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980df02467b664426ea087930561f37e45f92664"}, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "980df02467b664426ea087930561f37e45f92664", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/980df02467b664426ea087930561f37e45f92664", "committedDate": "2020-06-29T07:02:40Z", "message": "refactoring"}, "afterCommit": {"oid": "a74cd7ba7afcf490809673049cfc0d76f2b9b658", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/a74cd7ba7afcf490809673049cfc0d76f2b9b658", "committedDate": "2020-07-01T12:40:35Z", "message": "reviewer's suggestion"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a74cd7ba7afcf490809673049cfc0d76f2b9b658", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/a74cd7ba7afcf490809673049cfc0d76f2b9b658", "committedDate": "2020-07-01T12:40:35Z", "message": "reviewer's suggestion"}, "afterCommit": {"oid": "aa2241490d5eaead7127988ba8d2d055bee88cbb", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/aa2241490d5eaead7127988ba8d2d055bee88cbb", "committedDate": "2020-07-01T15:06:39Z", "message": "reviewer's suggestion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f120a93edb36a726221653844298bd7db26f5ae4", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/f120a93edb36a726221653844298bd7db26f5ae4", "committedDate": "2020-07-08T07:06:50Z", "message": "[GEOS-9663] Add support for GEOJSON output in the JSON-LD module and rename it"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a9494075cf7d64e5b0af5bb1afe7d9529690e32", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/8a9494075cf7d64e5b0af5bb1afe7d9529690e32", "committedDate": "2020-07-08T07:06:50Z", "message": "tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c3f5089e1e91dff307cc8739f5581d9a57ac9ed", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/2c3f5089e1e91dff307cc8739f5581d9a57ac9ed", "committedDate": "2020-07-08T07:06:50Z", "message": "documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0706ec2cd84b3db733d3e1ad7f83a10474660b31", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/0706ec2cd84b3db733d3e1ad7f83a10474660b31", "committedDate": "2020-07-08T07:06:50Z", "message": "refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "883898da58bf5b2a88d8fe3b524ae043688a3a3d", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/883898da58bf5b2a88d8fe3b524ae043688a3a3d", "committedDate": "2020-07-08T07:06:50Z", "message": "reviewer's suggestion"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa2241490d5eaead7127988ba8d2d055bee88cbb", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/aa2241490d5eaead7127988ba8d2d055bee88cbb", "committedDate": "2020-07-01T15:06:39Z", "message": "reviewer's suggestion"}, "afterCommit": {"oid": "d389f7cf06e5ad6ca6f5e14b55f74f5510a93363", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/d389f7cf06e5ad6ca6f5e14b55f74f5510a93363", "committedDate": "2020-07-07T08:30:02Z", "message": "last stuff"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d389f7cf06e5ad6ca6f5e14b55f74f5510a93363", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/d389f7cf06e5ad6ca6f5e14b55f74f5510a93363", "committedDate": "2020-07-07T08:30:02Z", "message": "last stuff"}, "afterCommit": {"oid": "b08d24c46f24cc18e4f795104932fa1b85cec2ad", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/b08d24c46f24cc18e4f795104932fa1b85cec2ad", "committedDate": "2020-07-08T07:06:51Z", "message": "fix context not included in the output if not an json object"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afd8b255ac87d89450255a92dece968c5704bdee", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/afd8b255ac87d89450255a92dece968c5704bdee", "committedDate": "2020-07-09T08:33:26Z", "message": "added support for geo+json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "807efa257d58752c9363348a783446ebf0736d8f", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/807efa257d58752c9363348a783446ebf0736d8f", "committedDate": "2020-07-09T08:33:34Z", "message": "fix context included in json-ld output only if is an object"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b08d24c46f24cc18e4f795104932fa1b85cec2ad", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/b08d24c46f24cc18e4f795104932fa1b85cec2ad", "committedDate": "2020-07-08T07:06:51Z", "message": "fix context not included in the output if not an json object"}, "afterCommit": {"oid": "807efa257d58752c9363348a783446ebf0736d8f", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geoserver/geoserver/commit/807efa257d58752c9363348a783446ebf0736d8f", "committedDate": "2020-07-09T08:33:34Z", "message": "fix context included in json-ld output only if is an object"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1427, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}