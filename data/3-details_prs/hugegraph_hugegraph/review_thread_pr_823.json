{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwOTE5NDU4", "number": 823, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoyODoyNlrODji49g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMTo1NzozM1rODnC6YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTk4MzkwOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/serializer/BinaryEntryIterator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoyODoyNlrOFvaY8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzoyODoyNlrOFvaY8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1OTc2Mg==", "bodyText": "same as cassandra and hbase", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r385259762", "createdAt": "2020-02-27T17:28:26Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/serializer/BinaryEntryIterator.java", "diffHunk": "@@ -76,6 +76,9 @@ protected final boolean fetch() {\n             } else if (merged == this.current) {\n                 // The next entry belongs to the current entry\n                 assert this.current != null;\n+                if (this.sizeOf(this.current) >= INLINE_BATCH_SIZE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8773ea00b8d1f2d54fd659affdfca77c90e284e9"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzU5NDk3OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/page/IdHolder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNToyMjo0NlrOFvp0LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwNToyMjo0NlrOFvp0LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUxMjQ5Mw==", "bodyText": "'original query' align", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r385512493", "createdAt": "2020-02-28T05:22:46Z", "author": {"login": "Linary"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/page/IdHolder.java", "diffHunk": "@@ -19,89 +19,220 @@\n \n package com.baidu.hugegraph.backend.page;\n \n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n import java.util.Set;\n import java.util.function.Function;\n \n+import org.apache.commons.lang.NotImplementedException;\n+import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n+\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.backend.query.ConditionQuery;\n+import com.baidu.hugegraph.backend.query.Query;\n+import com.baidu.hugegraph.backend.store.BackendEntry;\n+import com.baidu.hugegraph.iterator.CIter;\n+import com.baidu.hugegraph.iterator.Metadatable;\n import com.baidu.hugegraph.util.E;\n-import com.baidu.hugegraph.util.InsertionOrderUtil;\n-import com.google.common.collect.ImmutableSet;\n-\n-public class IdHolder {\n \n-    private final ConditionQuery query;\n-    private final Function<ConditionQuery, PageIds> idsFetcher;\n-    private boolean exhausted;\n+public abstract class IdHolder {\n \n-    private Set<Id> ids;\n+    protected final Query query;\n+    protected boolean exhausted;\n \n-    /**\n-     * For non-paging situation\n-     * @param ids   all ids\n-     */\n-    public IdHolder(Set<Id> ids) {\n-        this.query = null;\n-        this.idsFetcher = null;\n+    public IdHolder(Query query) {\n+        E.checkNotNull(query, \"query\");;\n+        this.query = query;\n         this.exhausted = false;\n-        if (ids instanceof ImmutableSet) {\n-            this.ids = InsertionOrderUtil.newSet(ids);\n-        } else {\n-            this.ids = ids;\n-        }\n     }\n \n-    /**\n-     * For paging situation\n-     * @param query         original query\n-     * @param idsFetcher    function to fetch one page ids\n-     */\n-    public IdHolder(ConditionQuery query,\n-                    Function<ConditionQuery, PageIds> idsFetcher) {\n-        E.checkArgument(query.paging(),\n-                        \"Query '%s' must include page info\", query);\n-        this.query = query.copy();\n-        this.idsFetcher = idsFetcher;\n-        this.exhausted = false;\n-        this.ids = null;\n+    public Query query() {\n+        return this.query;\n     }\n \n-    public void merge(Set<Id> ids) {\n-        E.checkNotNull(this.ids, \"ids\");\n-        this.ids.addAll(ids);\n+    @Override\n+    public String toString() {\n+        return String.format(\"%s{origin:%s,final:%s}\",\n+                             this.getClass().getSimpleName(),\n+                             this.query.originQuery(), this.query);\n     }\n \n-    public Set<Id> ids() {\n-        E.checkNotNull(this.ids, \"ids\");\n-        return this.ids;\n-    }\n+    public abstract boolean paging();\n+\n+    public abstract Set<Id> all();\n+\n+    public abstract PageIds fetchNext(String page, long pageSize);\n+\n+    public static class FixedIdHolder extends IdHolder {\n+\n+        private final Set<Id> ids;\n \n-    public int size() {\n-        if (this.ids == null) {\n-            return 0;\n+        public FixedIdHolder(Query query, Set<Id> ids) {\n+            super(query);\n+            this.ids = ids;\n+        }\n+\n+        @Override\n+        public boolean paging() {\n+            return false;\n+        }\n+\n+        @Override\n+        public Set<Id> all() {\n+            return this.ids;\n+        }\n+\n+        @Override\n+        public PageIds fetchNext(String page, long pageSize) {\n+            throw new NotImplementedException(\"FixedIdHolder.fetchNext\");\n         }\n-        return this.ids.size();\n     }\n \n-    public boolean paging() {\n-        return this.idsFetcher != null;\n+    public static class PagingIdHolder extends IdHolder {\n+\n+        private final Function<ConditionQuery, PageIds> fetcher;\n+\n+        /**\n+         * For paging situation\n+         * @param query         original query", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8773ea00b8d1f2d54fd659affdfca77c90e284e9"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTExNDA0OnYy", "diffSide": "RIGHT", "path": "hugegraph-test/src/main/java/com/baidu/hugegraph/unit/core/QueryTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDozNDoxNVrOFzrLjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDozNDoxNVrOFzrLjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcyOTE2Nw==", "bodyText": "align", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r389729167", "createdAt": "2020-03-09T14:34:15Z", "author": {"login": "Linary"}, "path": "hugegraph-test/src/main/java/com/baidu/hugegraph/unit/core/QueryTest.java", "diffHunk": "@@ -43,36 +49,105 @@ public void testOrderBy() {\n     @Test\n     public void testToString() {\n         Query query = new Query(HugeType.VERTEX);\n-        Assert.assertEquals(\"Query for VERTEX\", query.toString());\n+        Assert.assertEquals(\"`Query for VERTEX`\", query.toString());\n \n         query.page(\"p1\");\n-        Assert.assertEquals(\"Query for VERTEX page 'p1'\", query.toString());\n+        Assert.assertEquals(\"`Query for VERTEX page 'p1'`\", query.toString());\n \n         query = new Query(HugeType.VERTEX);\n         query.limit(10L);\n-        Assert.assertEquals(\"Query for VERTEX limit 10\", query.toString());\n+        Assert.assertEquals(\"`Query for VERTEX limit 10`\", query.toString());\n \n         query = new Query(HugeType.VERTEX);\n         query.page(\"p2\");\n         query.limit(10L);\n-        Assert.assertEquals(\"Query for VERTEX page 'p2', limit 10\",\n+        Assert.assertEquals(\"`Query for VERTEX page 'p2', limit 10`\",\n                             query.toString());\n \n         query = new Query(HugeType.VERTEX);\n         query.page(\"p3\");\n         query.offset(100L);\n         query.limit(10L);\n-        Assert.assertEquals(\"Query for VERTEX page 'p3', offset 100, limit 10\",\n-                            query.toString());\n+        Assert.assertEquals(\"`Query for VERTEX page 'p3', offset 100, \" +\n+                            \"limit 10`\", query.toString());\n \n         query = new Query(HugeType.VERTEX);\n         query.page(\"\");\n         query.offset(100L);\n         query.limit(10L);\n         query.order(HugeKeys.NAME, Order.ASC);\n         query.order(HugeKeys.FIELDS, Order.DESC);\n-        Assert.assertEquals(\"Query for VERTEX page '', offset 100, \" +\n-                            \"limit 10, order by {NAME=ASC, FIELDS=DESC}\",\n+        Assert.assertEquals(\"`Query for VERTEX page '', offset 100, \" +\n+                            \"limit 10, order by {NAME=ASC, FIELDS=DESC}`\",\n+                            query.toString());\n+\n+        IdQuery query2 = new IdQuery(HugeType.VERTEX, IdGenerator.of(1));\n+        query2.query(IdGenerator.of(3));\n+        query2.limit(10L);\n+        Assert.assertEquals(\"`Query for VERTEX limit 10 where id in [1, 3]`\",\n+                            query2.toString());\n+\n+        ConditionQuery query3 = new ConditionQuery(HugeType.EDGE);\n+        query3.eq(HugeKeys.LABEL, 3);\n+        query3.gt(HugeKeys.PROPERTIES, 10);\n+        query3.lt(HugeKeys.PROPERTIES, 18);\n+        query3.limit(10L);\n+        Assert.assertEquals(\"`Query for EDGE limit 10 where [LABEL == 3, \" +\n+                            \"PROPERTIES > 10, PROPERTIES < 18]`\",\n+                            query3.toString());\n+\n+        ConditionQuery query4 = new ConditionQuery(HugeType.EDGE);\n+        query4.query(ImmutableSet.of(IdGenerator.of(1), IdGenerator.of(3)));\n+        query4.eq(HugeKeys.LABEL, 3);\n+        query4.lt(HugeKeys.PROPERTIES, 18);\n+        query4.limit(10L);\n+        Assert.assertEquals(\"`Query for EDGE limit 10 where id in [1, 3] \" +\n+                            \"and [LABEL == 3, PROPERTIES < 18]`\",\n+                            query4.toString());\n+    }\n+\n+    @Test\n+    public void testToStringOfIdRangeQuery() {\n+        IdRangeQuery query = new IdRangeQuery(HugeType.EDGE,\n+                                               IdGenerator.of(1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05622ae975f4ba5fa87566482153b0666f14f5df"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTM3MDM4OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/tx/GraphIndexTransaction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTozMzowMVrOFztrqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTozMzowMVrOFztrqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc3MDE1NA==", "bodyText": "What's the basis?", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r389770154", "createdAt": "2020-03-09T15:33:01Z", "author": {"login": "Linary"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/tx/GraphIndexTransaction.java", "diffHunk": "@@ -1211,6 +1275,10 @@ private static boolean hasNullableProp(HugeElement element, Id key) {\n         return indexLabels;\n     }\n \n+    private static void increaseLimit(Query query) {\n+        query.limit(query.limit() * 2L + 8L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05622ae975f4ba5fa87566482153b0666f14f5df"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTM3ODAyOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/tx/GraphIndexTransaction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTozNDo1NlrOFztwnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTozNDo1NlrOFztwnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc3MTQyMA==", "bodyText": "asJointQuery maybe clearer", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r389771420", "createdAt": "2020-03-09T15:34:56Z", "author": {"login": "Linary"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/tx/GraphIndexTransaction.java", "diffHunk": "@@ -1285,11 +1353,57 @@ public static IndexQueries of(IndexLabel il, ConditionQuery query) {\n             return indexQueries;\n         }\n \n+        public boolean bigCapacity() {\n+            for (Query subQuery : this.values()) {\n+                if (subQuery.bigCapacity()) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n         public Map.Entry<IndexLabel, ConditionQuery> one() {\n             E.checkState(this.size() == 1,\n                          \"Please ensure index queries only contains one entry\");\n             return this.entrySet().iterator().next();\n         }\n+\n+        public Query rootQuery() {\n+            if (this.size() > 0) {\n+                return this.values().iterator().next().rootOriginQuery();\n+            }\n+            return null;\n+        }\n+\n+        public Query asQuery() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05622ae975f4ba5fa87566482153b0666f14f5df"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTcyOTcxOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/cache/CachedGraphTransaction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNjo0NDowOFrOF0qyyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNjo0NDowOFrOF0qyyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc3MTQwMA==", "bodyText": "add empty after \":\"", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r390771400", "createdAt": "2020-03-11T06:44:08Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/cache/CachedGraphTransaction.java", "diffHunk": "@@ -162,42 +165,59 @@ private void unlistenChanges() {\n                 newQuery.query(vertexId);\n             }\n         }\n-        if (vertices.isEmpty()) {\n+\n+        // Join results from cache and backend\n+        ExtendableIterator<HugeVertex> results = new ExtendableIterator<>();\n+        if (!vertices.isEmpty()) {\n+            results.extend(vertices.iterator());\n+        } else {\n             // Just use the origin query if find none from the cache\n             newQuery = query;\n         }\n+\n         if (!newQuery.empty()) {\n             Iterator<HugeVertex> rs = super.queryVerticesFromBackend(newQuery);\n-            while (rs.hasNext()) {\n-                HugeVertex vertex = rs.next();\n-                vertices.add(vertex);\n+            // Generally there are not too much data with id query\n+            ListIterator<HugeVertex> listIterator = QueryResults.toList(rs);\n+            for (HugeVertex vertex :listIterator.list()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05622ae975f4ba5fa87566482153b0666f14f5df"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjM5NTQ5OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/optimize/TraversalUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMDoyOToxM1rOF0xJZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMDoyOToxM1rOF0xJZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg3NTQ5Mg==", "bodyText": "delete empty", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r390875492", "createdAt": "2020-03-11T10:29:13Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/optimize/TraversalUtil.java", "diffHunk": "@@ -552,15 +552,13 @@ private static Object convSysValueIfNeeded(HugeGraph graph,HugeType type,\n     public static Iterator<Edge> filterResult(Vertex vertex,\n                                               Directions dir,\n                                               Iterator<Edge> edges) {\n-        final List<Edge> list = new ArrayList<>();\n-        while (edges.hasNext()) {\n-            Edge edge = edges.next();\n+        return new FilterIterator<>(edges, edge -> {\n             if (dir == Directions.OUT && vertex.equals(edge.outVertex()) ||\n-                dir == Directions.IN && vertex.equals(edge.inVertex())) {\n-                list.add(edge);\n+                dir == Directions.IN  && vertex.equals(edge.inVertex())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05622ae975f4ba5fa87566482153b0666f14f5df"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjU0OTk0OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/query/Query.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMToxNDoyNFrOF0ypHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMToxNDoyNFrOF0ypHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg5OTk5OQ==", "bodyText": "capacityContext", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r390899999", "createdAt": "2020-03-11T11:14:24Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/query/Query.java", "diffHunk": "@@ -48,6 +51,7 @@\n     private HugeType resultType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a82d5fbe1ce34b6c68842bd4f604add8d8a6dda"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjYwMzk3OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/page/IdHolder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMTozMTo1N1rOF0zKMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMTozMTo1N1rOF0zKMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkwODQ2NA==", "bodyText": "add empty", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r390908464", "createdAt": "2020-03-11T11:31:57Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/page/IdHolder.java", "diffHunk": "@@ -19,89 +19,218 @@\n \n package com.baidu.hugegraph.backend.page;\n \n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n import java.util.Set;\n import java.util.function.Function;\n \n+import org.apache.commons.lang.NotImplementedException;\n+import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n+\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.backend.query.ConditionQuery;\n+import com.baidu.hugegraph.backend.query.Query;\n+import com.baidu.hugegraph.backend.store.BackendEntry;\n+import com.baidu.hugegraph.iterator.CIter;\n+import com.baidu.hugegraph.iterator.Metadatable;\n import com.baidu.hugegraph.util.E;\n-import com.baidu.hugegraph.util.InsertionOrderUtil;\n-import com.google.common.collect.ImmutableSet;\n-\n-public class IdHolder {\n \n-    private final ConditionQuery query;\n-    private final Function<ConditionQuery, PageIds> idsFetcher;\n-    private boolean exhausted;\n+public abstract class IdHolder {\n \n-    private Set<Id> ids;\n+    protected final Query query;\n+    protected boolean exhausted;\n \n-    /**\n-     * For non-paging situation\n-     * @param ids   all ids\n-     */\n-    public IdHolder(Set<Id> ids) {\n-        this.query = null;\n-        this.idsFetcher = null;\n+    public IdHolder(Query query) {\n+        E.checkNotNull(query, \"query\");;\n+        this.query = query;\n         this.exhausted = false;\n-        if (ids instanceof ImmutableSet) {\n-            this.ids = InsertionOrderUtil.newSet(ids);\n-        } else {\n-            this.ids = ids;\n-        }\n     }\n \n-    /**\n-     * For paging situation\n-     * @param query         original query\n-     * @param idsFetcher    function to fetch one page ids\n-     */\n-    public IdHolder(ConditionQuery query,\n-                    Function<ConditionQuery, PageIds> idsFetcher) {\n-        E.checkArgument(query.paging(),\n-                        \"Query '%s' must include page info\", query);\n-        this.query = query.copy();\n-        this.idsFetcher = idsFetcher;\n-        this.exhausted = false;\n-        this.ids = null;\n+    public Query query() {\n+        return this.query;\n     }\n \n-    public void merge(Set<Id> ids) {\n-        E.checkNotNull(this.ids, \"ids\");\n-        this.ids.addAll(ids);\n+    @Override\n+    public String toString() {\n+        return String.format(\"%s{origin:%s,final:%s}\",\n+                             this.getClass().getSimpleName(),\n+                             this.query.originQuery(), this.query);\n     }\n \n-    public Set<Id> ids() {\n-        E.checkNotNull(this.ids, \"ids\");\n-        return this.ids;\n-    }\n+    public abstract boolean paging();\n \n-    public int size() {\n-        if (this.ids == null) {\n-            return 0;\n+    public abstract Set<Id> all();\n+\n+    public abstract PageIds fetchNext(String page, long pageSize);\n+\n+    public static class FixedIdHolder extends IdHolder {\n+\n+        // Used by Joint Index\n+        private final Set<Id> ids;\n+\n+        public FixedIdHolder(Query query, Set<Id> ids) {\n+            super(query);\n+            this.ids = ids;\n+        }\n+\n+        @Override\n+        public boolean paging() {\n+            return false;\n+        }\n+\n+        @Override\n+        public Set<Id> all() {\n+            return this.ids;\n+        }\n+\n+        @Override\n+        public PageIds fetchNext(String page, long pageSize) {\n+            throw new NotImplementedException(\"FixedIdHolder.fetchNext\");\n         }\n-        return this.ids.size();\n     }\n \n-    public boolean paging() {\n-        return this.idsFetcher != null;\n+    public static class PagingIdHolder extends IdHolder {\n+\n+        private final Function<ConditionQuery, PageIds> fetcher;\n+\n+        public PagingIdHolder(ConditionQuery query,\n+                              Function<ConditionQuery, PageIds> fetcher) {\n+            super(query.copy());\n+            E.checkArgument(query.paging(),\n+                            \"Query '%s' must include page info\", query);\n+            this.fetcher = fetcher;\n+        }\n+\n+        @Override\n+        public boolean paging() {\n+            return true;\n+        }\n+\n+        @Override\n+        public PageIds fetchNext(String page, long pageSize) {\n+            if (this.exhausted) {\n+                return PageIds.EMPTY;\n+            }\n+\n+            this.query.page(page);\n+            this.query.limit(pageSize);\n+\n+            PageIds result = this.fetcher.apply((ConditionQuery) this.query);\n+            assert result != null;\n+            if (result.ids().size() < pageSize || result.page() == null) {\n+                this.exhausted = true;\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Set<Id> all() {\n+            throw new NotImplementedException(\"PagingIdHolder.all\");\n+        }\n     }\n \n-    public PageIds fetchNext(String page, long pageSize) {\n-        if (this.exhausted) {\n-            return PageIds.EMPTY;\n+    public static class BatchIdHolder extends IdHolder\n+                                      implements CIter<IdHolder> {\n+\n+        private final Iterator<BackendEntry> entries;\n+        private final Function<Long, Set<Id>> fetcher;\n+        private long count;\n+\n+        public BatchIdHolder(ConditionQuery query,\n+                             Iterator<BackendEntry> entries,\n+                             Function<Long, Set<Id>> fetcher) {\n+            super(query);\n+            this.entries = entries;\n+            this.fetcher = fetcher;\n+            this.count = 0L;\n+        }\n+\n+        @Override\n+        public boolean paging() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (this.exhausted) {\n+                return false;\n+            }\n+            boolean hasNext= this.entries.hasNext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a82d5fbe1ce34b6c68842bd4f604add8d8a6dda"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjYwOTQxOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/page/IdHolder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMTozMzoyMlrOF0zNTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMjozMzowMVrOF1PaCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkwOTI2Mg==", "bodyText": "batchSize might be 0?", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r390909262", "createdAt": "2020-03-11T11:33:22Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/page/IdHolder.java", "diffHunk": "@@ -19,89 +19,218 @@\n \n package com.baidu.hugegraph.backend.page;\n \n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n import java.util.Set;\n import java.util.function.Function;\n \n+import org.apache.commons.lang.NotImplementedException;\n+import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n+\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.backend.query.ConditionQuery;\n+import com.baidu.hugegraph.backend.query.Query;\n+import com.baidu.hugegraph.backend.store.BackendEntry;\n+import com.baidu.hugegraph.iterator.CIter;\n+import com.baidu.hugegraph.iterator.Metadatable;\n import com.baidu.hugegraph.util.E;\n-import com.baidu.hugegraph.util.InsertionOrderUtil;\n-import com.google.common.collect.ImmutableSet;\n-\n-public class IdHolder {\n \n-    private final ConditionQuery query;\n-    private final Function<ConditionQuery, PageIds> idsFetcher;\n-    private boolean exhausted;\n+public abstract class IdHolder {\n \n-    private Set<Id> ids;\n+    protected final Query query;\n+    protected boolean exhausted;\n \n-    /**\n-     * For non-paging situation\n-     * @param ids   all ids\n-     */\n-    public IdHolder(Set<Id> ids) {\n-        this.query = null;\n-        this.idsFetcher = null;\n+    public IdHolder(Query query) {\n+        E.checkNotNull(query, \"query\");;\n+        this.query = query;\n         this.exhausted = false;\n-        if (ids instanceof ImmutableSet) {\n-            this.ids = InsertionOrderUtil.newSet(ids);\n-        } else {\n-            this.ids = ids;\n-        }\n     }\n \n-    /**\n-     * For paging situation\n-     * @param query         original query\n-     * @param idsFetcher    function to fetch one page ids\n-     */\n-    public IdHolder(ConditionQuery query,\n-                    Function<ConditionQuery, PageIds> idsFetcher) {\n-        E.checkArgument(query.paging(),\n-                        \"Query '%s' must include page info\", query);\n-        this.query = query.copy();\n-        this.idsFetcher = idsFetcher;\n-        this.exhausted = false;\n-        this.ids = null;\n+    public Query query() {\n+        return this.query;\n     }\n \n-    public void merge(Set<Id> ids) {\n-        E.checkNotNull(this.ids, \"ids\");\n-        this.ids.addAll(ids);\n+    @Override\n+    public String toString() {\n+        return String.format(\"%s{origin:%s,final:%s}\",\n+                             this.getClass().getSimpleName(),\n+                             this.query.originQuery(), this.query);\n     }\n \n-    public Set<Id> ids() {\n-        E.checkNotNull(this.ids, \"ids\");\n-        return this.ids;\n-    }\n+    public abstract boolean paging();\n \n-    public int size() {\n-        if (this.ids == null) {\n-            return 0;\n+    public abstract Set<Id> all();\n+\n+    public abstract PageIds fetchNext(String page, long pageSize);\n+\n+    public static class FixedIdHolder extends IdHolder {\n+\n+        // Used by Joint Index\n+        private final Set<Id> ids;\n+\n+        public FixedIdHolder(Query query, Set<Id> ids) {\n+            super(query);\n+            this.ids = ids;\n+        }\n+\n+        @Override\n+        public boolean paging() {\n+            return false;\n+        }\n+\n+        @Override\n+        public Set<Id> all() {\n+            return this.ids;\n+        }\n+\n+        @Override\n+        public PageIds fetchNext(String page, long pageSize) {\n+            throw new NotImplementedException(\"FixedIdHolder.fetchNext\");\n         }\n-        return this.ids.size();\n     }\n \n-    public boolean paging() {\n-        return this.idsFetcher != null;\n+    public static class PagingIdHolder extends IdHolder {\n+\n+        private final Function<ConditionQuery, PageIds> fetcher;\n+\n+        public PagingIdHolder(ConditionQuery query,\n+                              Function<ConditionQuery, PageIds> fetcher) {\n+            super(query.copy());\n+            E.checkArgument(query.paging(),\n+                            \"Query '%s' must include page info\", query);\n+            this.fetcher = fetcher;\n+        }\n+\n+        @Override\n+        public boolean paging() {\n+            return true;\n+        }\n+\n+        @Override\n+        public PageIds fetchNext(String page, long pageSize) {\n+            if (this.exhausted) {\n+                return PageIds.EMPTY;\n+            }\n+\n+            this.query.page(page);\n+            this.query.limit(pageSize);\n+\n+            PageIds result = this.fetcher.apply((ConditionQuery) this.query);\n+            assert result != null;\n+            if (result.ids().size() < pageSize || result.page() == null) {\n+                this.exhausted = true;\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Set<Id> all() {\n+            throw new NotImplementedException(\"PagingIdHolder.all\");\n+        }\n     }\n \n-    public PageIds fetchNext(String page, long pageSize) {\n-        if (this.exhausted) {\n-            return PageIds.EMPTY;\n+    public static class BatchIdHolder extends IdHolder\n+                                      implements CIter<IdHolder> {\n+\n+        private final Iterator<BackendEntry> entries;\n+        private final Function<Long, Set<Id>> fetcher;\n+        private long count;\n+\n+        public BatchIdHolder(ConditionQuery query,\n+                             Iterator<BackendEntry> entries,\n+                             Function<Long, Set<Id>> fetcher) {\n+            super(query);\n+            this.entries = entries;\n+            this.fetcher = fetcher;\n+            this.count = 0L;\n+        }\n+\n+        @Override\n+        public boolean paging() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (this.exhausted) {\n+                return false;\n+            }\n+            boolean hasNext= this.entries.hasNext();\n+            if (!hasNext) {\n+                this.close();\n+            }\n+            return hasNext;\n+        }\n+\n+        @Override\n+        public IdHolder next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            return this;\n+        }\n+\n+        @Override\n+        public PageIds fetchNext(String page, long batchSize) {\n+            E.checkArgument(page == null,\n+                            \"Not support page parameter by BatchIdHolder\");\n+            E.checkArgument(batchSize >= 0L,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a82d5fbe1ce34b6c68842bd4f604add8d8a6dda"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM3MTI3Mw==", "bodyText": "yes, it's 0 when hit the last page, and then set exhausted true", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r391371273", "createdAt": "2020-03-12T02:33:01Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/page/IdHolder.java", "diffHunk": "@@ -19,89 +19,218 @@\n \n package com.baidu.hugegraph.backend.page;\n \n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n import java.util.Set;\n import java.util.function.Function;\n \n+import org.apache.commons.lang.NotImplementedException;\n+import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n+\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.backend.query.ConditionQuery;\n+import com.baidu.hugegraph.backend.query.Query;\n+import com.baidu.hugegraph.backend.store.BackendEntry;\n+import com.baidu.hugegraph.iterator.CIter;\n+import com.baidu.hugegraph.iterator.Metadatable;\n import com.baidu.hugegraph.util.E;\n-import com.baidu.hugegraph.util.InsertionOrderUtil;\n-import com.google.common.collect.ImmutableSet;\n-\n-public class IdHolder {\n \n-    private final ConditionQuery query;\n-    private final Function<ConditionQuery, PageIds> idsFetcher;\n-    private boolean exhausted;\n+public abstract class IdHolder {\n \n-    private Set<Id> ids;\n+    protected final Query query;\n+    protected boolean exhausted;\n \n-    /**\n-     * For non-paging situation\n-     * @param ids   all ids\n-     */\n-    public IdHolder(Set<Id> ids) {\n-        this.query = null;\n-        this.idsFetcher = null;\n+    public IdHolder(Query query) {\n+        E.checkNotNull(query, \"query\");;\n+        this.query = query;\n         this.exhausted = false;\n-        if (ids instanceof ImmutableSet) {\n-            this.ids = InsertionOrderUtil.newSet(ids);\n-        } else {\n-            this.ids = ids;\n-        }\n     }\n \n-    /**\n-     * For paging situation\n-     * @param query         original query\n-     * @param idsFetcher    function to fetch one page ids\n-     */\n-    public IdHolder(ConditionQuery query,\n-                    Function<ConditionQuery, PageIds> idsFetcher) {\n-        E.checkArgument(query.paging(),\n-                        \"Query '%s' must include page info\", query);\n-        this.query = query.copy();\n-        this.idsFetcher = idsFetcher;\n-        this.exhausted = false;\n-        this.ids = null;\n+    public Query query() {\n+        return this.query;\n     }\n \n-    public void merge(Set<Id> ids) {\n-        E.checkNotNull(this.ids, \"ids\");\n-        this.ids.addAll(ids);\n+    @Override\n+    public String toString() {\n+        return String.format(\"%s{origin:%s,final:%s}\",\n+                             this.getClass().getSimpleName(),\n+                             this.query.originQuery(), this.query);\n     }\n \n-    public Set<Id> ids() {\n-        E.checkNotNull(this.ids, \"ids\");\n-        return this.ids;\n-    }\n+    public abstract boolean paging();\n \n-    public int size() {\n-        if (this.ids == null) {\n-            return 0;\n+    public abstract Set<Id> all();\n+\n+    public abstract PageIds fetchNext(String page, long pageSize);\n+\n+    public static class FixedIdHolder extends IdHolder {\n+\n+        // Used by Joint Index\n+        private final Set<Id> ids;\n+\n+        public FixedIdHolder(Query query, Set<Id> ids) {\n+            super(query);\n+            this.ids = ids;\n+        }\n+\n+        @Override\n+        public boolean paging() {\n+            return false;\n+        }\n+\n+        @Override\n+        public Set<Id> all() {\n+            return this.ids;\n+        }\n+\n+        @Override\n+        public PageIds fetchNext(String page, long pageSize) {\n+            throw new NotImplementedException(\"FixedIdHolder.fetchNext\");\n         }\n-        return this.ids.size();\n     }\n \n-    public boolean paging() {\n-        return this.idsFetcher != null;\n+    public static class PagingIdHolder extends IdHolder {\n+\n+        private final Function<ConditionQuery, PageIds> fetcher;\n+\n+        public PagingIdHolder(ConditionQuery query,\n+                              Function<ConditionQuery, PageIds> fetcher) {\n+            super(query.copy());\n+            E.checkArgument(query.paging(),\n+                            \"Query '%s' must include page info\", query);\n+            this.fetcher = fetcher;\n+        }\n+\n+        @Override\n+        public boolean paging() {\n+            return true;\n+        }\n+\n+        @Override\n+        public PageIds fetchNext(String page, long pageSize) {\n+            if (this.exhausted) {\n+                return PageIds.EMPTY;\n+            }\n+\n+            this.query.page(page);\n+            this.query.limit(pageSize);\n+\n+            PageIds result = this.fetcher.apply((ConditionQuery) this.query);\n+            assert result != null;\n+            if (result.ids().size() < pageSize || result.page() == null) {\n+                this.exhausted = true;\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Set<Id> all() {\n+            throw new NotImplementedException(\"PagingIdHolder.all\");\n+        }\n     }\n \n-    public PageIds fetchNext(String page, long pageSize) {\n-        if (this.exhausted) {\n-            return PageIds.EMPTY;\n+    public static class BatchIdHolder extends IdHolder\n+                                      implements CIter<IdHolder> {\n+\n+        private final Iterator<BackendEntry> entries;\n+        private final Function<Long, Set<Id>> fetcher;\n+        private long count;\n+\n+        public BatchIdHolder(ConditionQuery query,\n+                             Iterator<BackendEntry> entries,\n+                             Function<Long, Set<Id>> fetcher) {\n+            super(query);\n+            this.entries = entries;\n+            this.fetcher = fetcher;\n+            this.count = 0L;\n+        }\n+\n+        @Override\n+        public boolean paging() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (this.exhausted) {\n+                return false;\n+            }\n+            boolean hasNext= this.entries.hasNext();\n+            if (!hasNext) {\n+                this.close();\n+            }\n+            return hasNext;\n+        }\n+\n+        @Override\n+        public IdHolder next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            return this;\n+        }\n+\n+        @Override\n+        public PageIds fetchNext(String page, long batchSize) {\n+            E.checkArgument(page == null,\n+                            \"Not support page parameter by BatchIdHolder\");\n+            E.checkArgument(batchSize >= 0L,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkwOTI2Mg=="}, "originalCommit": {"oid": "4a82d5fbe1ce34b6c68842bd4f604add8d8a6dda"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMjY4NzY5OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/query/QueryResults.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMTo1NzozM1rOF0z71A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMTo1NzozM1rOF0z71A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkyMTE3Mg==", "bodyText": "Expect just one result but got at least two: [%s, %s, ...]", "url": "https://github.com/hugegraph/hugegraph/pull/823#discussion_r390921172", "createdAt": "2020-03-11T11:57:33Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/backend/query/QueryResults.java", "diffHunk": "@@ -169,6 +208,23 @@ private boolean paging() {\n         return qr[0];\n     }\n \n+    public static <T> T one(Iterator<T> iterator) {\n+        try {\n+            if (iterator.hasNext()) {\n+                T result = iterator.next();\n+                if (iterator.hasNext()) {\n+                    throw new HugeException(\n+                              \"Expect just one result but got two: [%s, %s]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a82d5fbe1ce34b6c68842bd4f604add8d8a6dda"}, "originalPosition": 124}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1566, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}