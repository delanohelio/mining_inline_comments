{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3MDA3MTEy", "number": 1174, "reviewThreads": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMjozMzoxMVrOEk81lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODoxNTozNlrOEwIJdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MTgwOTUxOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMjozMzoxMVrOHULMRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwOTozMjoyOVrOHVHi6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNjkzNA==", "bodyText": "move Consumers to com/baidu/hugegraph/util", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r490916934", "createdAt": "2020-09-18T12:33:11Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.job.algorithm;\n+\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.task.TaskManager.ContextCallable;\n+import com.baidu.hugegraph.util.ExecutorUtil;\n+import com.baidu.hugegraph.util.Log;\n+\n+public class Consumers<V> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fc98af7e395491d35a619a7e26268e0e614b730"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkwNTc3MQ==", "bodyText": "rebase #1183", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r491905771", "createdAt": "2020-09-21T09:32:29Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.job.algorithm;\n+\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.task.TaskManager.ContextCallable;\n+import com.baidu.hugegraph.util.ExecutorUtil;\n+import com.baidu.hugegraph.util.Log;\n+\n+public class Consumers<V> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNjkzNA=="}, "originalCommit": {"oid": "3fc98af7e395491d35a619a7e26268e0e614b730"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MzI2NTc0OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMToyOTowOFrOHXV7NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMToyOTowOFrOHXV7NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIzODUxNg==", "bodyText": "add common method", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r494238516", "createdAt": "2020-09-24T11:29:08Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -0,0 +1,636 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.structure.HugeVertex;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+import com.baidu.hugegraph.util.Log;\n+import com.google.common.collect.ImmutableList;\n+\n+public class TemplatePathsTraverser extends TpTraverser {\n+\n+    private static final Logger LOG = Log.logger(TemplatePathsTraverser.class);\n+\n+    public TemplatePathsTraverser(HugeGraph graph) {\n+        super(graph, \"template-paths\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<Path> templatePaths(Iterator<Vertex> sources,\n+                                   Iterator<Vertex> targets,\n+                                   List<RepeatEdgeStep> steps,\n+                                   boolean withRing,\n+                                   long capacity, long limit) {\n+        checkCapacity(capacity);\n+        checkLimit(limit);\n+\n+        List<Id> sourceList = new ArrayList<>();\n+        while (sources.hasNext()) {\n+            sourceList.add(((HugeVertex) sources.next()).id());\n+        }\n+        int sourceSize = sourceList.size();\n+        E.checkState(sourceSize >= 1 && sourceSize <= MAX_VERTICES,\n+                     \"The number of source vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+        List<Id> targetList = new ArrayList<>();\n+        while (targets.hasNext()) {\n+            targetList.add(((HugeVertex) targets.next()).id());\n+        }\n+        int targetSize = targetList.size();\n+        E.checkState(targetSize >= 1 && targetSize <= MAX_VERTICES,\n+                     \"The number of target vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+\n+        int totalSteps = 0;\n+        for (RepeatEdgeStep step : steps) {\n+            totalSteps += step.maxTimes;\n+        }\n+        Traverser traverser = totalSteps >= this.concurrentDepth() ?\n+                              new ConcurrentTraverser(sourceList, targetList,\n+                                                      steps, withRing,\n+                                                      capacity, limit) :\n+                              new SingleTraverser(sourceList, targetList,\n+                                                  steps, withRing,\n+                                                  capacity, limit);\n+\n+        do {\n+            // Forward\n+            traverser.forward();\n+            if (traverser.finish()) {\n+                return traverser.paths();\n+            }\n+\n+            // Backward\n+            traverser.backward();\n+            if (traverser.finish()) {\n+                return traverser.paths();\n+            }\n+        } while (true);\n+    }\n+\n+    private class Traverser {\n+\n+        protected final List<RepeatEdgeStep> steps;\n+        protected int stepCount;\n+        protected final long capacity;\n+        protected final long limit;\n+        protected int totalSteps;\n+        protected boolean withRing;\n+        protected int sourceIndex;\n+        protected int targetIndex;\n+\n+        protected boolean sourceFinishOneStep = false;\n+        protected boolean targetFinishOneStep = false;\n+\n+        public Traverser(List<RepeatEdgeStep> steps,\n+                         long capacity, long limit, boolean withRing) {\n+            this.steps = steps;\n+            this.capacity = capacity;\n+            this.limit = limit;\n+            this.withRing = withRing;\n+\n+            this.stepCount = 0;\n+            for (RepeatEdgeStep step : steps) {\n+                this.totalSteps += step.maxTimes;\n+            }\n+            this.sourceIndex = 0;\n+            this.targetIndex = this.steps.size() - 1;\n+        }\n+\n+        public void forward() {\n+        }\n+\n+        public void backward() {\n+        }\n+\n+        public Set<Path> paths() {\n+            return new PathSet();\n+        }\n+\n+        public int pathCount() {\n+            return 0;\n+        }\n+\n+        protected boolean finish() {\n+            return this.stepCount >= this.totalSteps || this.reachLimit();\n+        }\n+\n+        protected boolean lastStep() {\n+            return this.stepCount == this.totalSteps - 1;\n+        }\n+\n+        protected int accessedNodes() {\n+            return 0;\n+        }\n+\n+        protected boolean reachLimit() {\n+            checkCapacity(this.capacity, this.accessedNodes(),\n+                          \"template paths\");\n+            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        public boolean lastSuperStep() {\n+            return this.targetIndex == this.sourceIndex ||\n+                   this.targetIndex == this.sourceIndex + 1;\n+        }\n+    }\n+\n+    private class ConcurrentTraverser extends Traverser {\n+\n+        private ConcurrentMultiValuedMap<Id, Node> sources =\n+                new ConcurrentMultiValuedMap<>();\n+        private ConcurrentMultiValuedMap<Id, Node> targets =\n+                new ConcurrentMultiValuedMap<>();\n+        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n+                new ConcurrentMultiValuedMap<>();\n+        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n+                new ConcurrentMultiValuedMap<>();\n+\n+        private Set<Path> paths;\n+\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(steps, capacity, limit, withRing);\n+            for (Id id : sources) {\n+                this.sources.add(id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.targets.add(id, new Node(id));\n+            }\n+            this.paths = ConcurrentHashMap.newKeySet();\n+        }\n+\n+        /**\n+         * Search forward from sources\n+         */\n+        public void forward() {\n+            ConcurrentMultiValuedMap<Id, Node> newVertices =\n+                                               new ConcurrentMultiValuedMap<>();\n+            RepeatEdgeStep currentStep = null;\n+            // Find next step to forward\n+            for (int i = 0; i < this.steps.size(); i++) {\n+                RepeatEdgeStep step = this.steps.get(i);\n+                if (step.remainTimes() > 0) {\n+                    currentStep = step;\n+                    this.sourceIndex = i;\n+                    break;\n+                }\n+            }\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            // Re-init source all if last forward finished one super step and\n+            // not last super step\n+            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n+                this.sourceFinishOneStep = false;\n+            }\n+\n+            // Traversal vertices of previous level\n+            RepeatEdgeStep finalCurrentStep = currentStep;\n+            traverseIds(this.sources.keySet().iterator(), vid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bff5a6a67a3c1f0868bf2a23aefa3cecf13fb12e"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTM5MTk2OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjo1Mjo1M1rOHZrn0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjo1Mjo1M1rOHZrn0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5MTE1NA==", "bodyText": "rename pre to prev", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496691154", "createdAt": "2020-09-29T12:52:53Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -551,6 +551,26 @@ public static void checkSkipDegree(long skipDegree, long degree,\n         return new MultivaluedHashMap<>();\n     }\n \n+    protected static List<Id> joinPath(Node pre, Node back, boolean ring) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQxMDkwOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjo1NzowMlrOHZrzTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjo1NzowMlrOHZrzTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NDA5NQ==", "bodyText": "rename v to source", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496694095", "createdAt": "2020-09-29T12:57:02Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQyNDYyOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowMDoyMlrOHZr8Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowMDoyMlrOHZr8Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NjMyNw==", "bodyText": "reInitCurrentStepIfNeeded", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496696327", "createdAt": "2020-09-29T13:00:22Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(target)) {\n+                    for (Node node : this.sourcesAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(target, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n+            }\n+        }\n+\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                // Re-init source all if last forward finished one super step\n+                // and not last super step\n+                if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                    this.sourcesAll = this.newMultiValueMap();\n+                    this.sourceFinishOneStep = false;\n+                }\n+            } else {\n+                // Re-init target all if last forward finished one super step\n+                // and not last super step\n+                if (this.targetFinishOneStep && !this.lastSuperStep()) {\n+                    this.targetsAll = this.newMultiValueMap();\n+                    this.targetFinishOneStep = false;\n+                }\n             }\n+        }\n \n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n+        private void reInitCurrentIfNeeded(RepeatEdgeStep step,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 337}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQyNzc2OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowMTowOFrOHZr9_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowMTowOFrOHZr9_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NjgzMQ==", "bodyText": "not finished last super step? or current step is not the last super step?\nand use /*", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496696831", "createdAt": "2020-09-29T13:01:08Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(target)) {\n+                    for (Node node : this.sourcesAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(target, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n+            }\n+        }\n+\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                // Re-init source all if last forward finished one super step\n+                // and not last super step", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 318}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQyODQ2OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowMToxN1rOHZr-bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowMToxN1rOHZr-bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5Njk0Mg==", "bodyText": "ditto", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496696942", "createdAt": "2020-09-29T13:01:17Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(target)) {\n+                    for (Node node : this.sourcesAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(target, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n+            }\n+        }\n+\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                // Re-init source all if last forward finished one super step\n+                // and not last super step\n+                if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                    this.sourcesAll = this.newMultiValueMap();\n+                    this.sourceFinishOneStep = false;\n+                }\n+            } else {\n+                // Re-init target all if last forward finished one super step\n+                // and not last super step", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 325}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQzNDk0OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowMjo1MFrOHZsCXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwODo0NTo1NFrOHf08oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5Nzk0OA==", "bodyText": "move to previous line", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496697948", "createdAt": "2020-09-29T13:02:50Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 533}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzNTM5Mg==", "bodyText": "move to previous line will exceed 80 char", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503135392", "createdAt": "2020-10-12T08:45:54Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5Nzk0OA=="}, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 533}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQ0MTIyOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowNDoyM1rOHZsGYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowNDoyM1rOHZsGYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5ODk3Ng==", "bodyText": "use this \"this.traverseIds()\"\nand don't need \"()\" in \"(id)\"", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496698976", "createdAt": "2020-09-29T13:04:23Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = newMultivalueMap();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-\n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        @Override\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return new ConcurrentMultiValuedMap<>();\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-\n-            // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.targetIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init target all if last forward finished one super step and\n-            // not last super step\n-            if (this.targetFinishOneStep && !this.lastSuperStep()) {\n-                this.targetsAll = newMultivalueMap();\n-                this.targetFinishOneStep = false;\n-            }\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n+            traverseIds(this.sources.keySet().iterator(), (id) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 649}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQ0NDYyOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowNToxMlrOHZsIeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowNToxMlrOHZsIeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5OTUxMw==", "bodyText": "just named consumer", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496699513", "createdAt": "2020-09-29T13:05:12Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = newMultivalueMap();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-\n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        @Override\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return new ConcurrentMultiValuedMap<>();\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-\n-            // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.targetIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init target all if last forward finished one super step and\n-            // not last super step\n-            if (this.targetFinishOneStep && !this.lastSuperStep()) {\n-                this.targetsAll = newMultivalueMap();\n-                this.targetFinishOneStep = false;\n-            }\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 648}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQ1MDQ5OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowNjoyOVrOHZsL8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowNjoyOVrOHZsL8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwMDQwMQ==", "bodyText": "ditto", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496700401", "createdAt": "2020-09-29T13:06:29Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = newMultivalueMap();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-\n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        @Override\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return new ConcurrentMultiValuedMap<>();\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-\n-            // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.targetIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init target all if last forward finished one super step and\n-            // not last super step\n-            if (this.targetFinishOneStep && !this.lastSuperStep()) {\n-                this.targetsAll = newMultivalueMap();\n-                this.targetFinishOneStep = false;\n-            }\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n+            traverseIds(this.sources.keySet().iterator(), (id) -> {\n+                biConsumer.accept(id, step);\n+            });\n+        }\n \n-            currentStep.swithDirection();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.targets.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n+        @Override\n+        public Set<Path> newPathSet() {\n+            return ConcurrentHashMap.newKeySet();\n+        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.sourcesAll.containsKey(target)) {\n-                            for (Node node : this.sourcesAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    Path newPath = new Path(target, path);\n-                                    newPath.reverse();\n-                                    this.paths.add(newPath);\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n+        @Override\n+        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n+            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n+        }\n \n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n+        @Override\n+        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n+            ConcurrentMultiValuedMap<Id, Node> vertices =\n+                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n+            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n+                vertices.addAll(entry.getKey(), entry.getValue());\n             }\n+        }\n+    }\n \n-            currentStep.swithDirection();\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.targetsAll.addAll(entry.getKey(), entry.getValue());\n-            }\n+    private class SingleTraverser extends Traverser {\n \n-            currentStep.decreaseTimes();\n-            // Re-init targets\n-            if (currentStep.remainTimes() > 0) {\n-                this.targets = newVertices;\n-            } else {\n-                this.targets = this.targetsAll;\n-                this.targetFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n+                               List<RepeatEdgeStep> steps, boolean withRing,\n+                               long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n         @Override\n-        public Set<Path> paths() {\n-            return this.paths;\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return newMultivalueMap();\n         }\n \n         @Override\n-        public int pathCount() {\n-            return this.paths.size();\n+        public Set<Path> newPathSet() {\n+            return new PathSet();\n         }\n \n-        protected int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 755}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQ1ODEwOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowODoxNFrOHZsQnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzowODoxNFrOHZsQnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwMTU5OQ==", "bodyText": "prefer nextStep", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496701599", "createdAt": "2020-09-29T13:08:14Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQ3NjYwOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoxMjozOFrOHZscTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoxMjozOFrOHZscTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwNDU4OQ==", "bodyText": "rename source to sourceV, and rename n to source, same as target", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496704589", "createdAt": "2020-09-29T13:12:38Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTQ5ODEzOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoxNzoyNFrOHZsprA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoxNzoyNFrOHZsprA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwODAxMg==", "bodyText": "ditto", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496708012", "createdAt": "2020-09-29T13:17:24Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 261}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTUwMTg5OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoxODoxNVrOHZssFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoxODoxNVrOHZssFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwODYyOQ==", "bodyText": "can we merge the two methods with one, and pass sourcesAll or targetsAll to that method", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496708629", "createdAt": "2020-09-29T13:18:15Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTUzMDYxOnYy", "diffSide": "RIGHT", "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoyNDoyOVrOHZs9lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoyNDoyOVrOHZs9lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxMzExMQ==", "bodyText": "keep origin", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496713111", "createdAt": "2020-09-29T13:24:29Z", "author": {"login": "javeme"}, "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java", "diffHunk": "@@ -165,7 +165,7 @@ private HugeAuthenticator authenticator() {\n \n     @SuppressWarnings(\"unused\")\n     private void installLicense(HugeConfig config, String md5) {\n-        LicenseVerifier.instance().install(config, this, md5);\n+//        LicenseVerifier.instance().install(config, this, md5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTUzMjM5OnYy", "diffSide": "RIGHT", "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoyNDo1MVrOHZs-pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoyNDo1MVrOHZs-pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxMzM4Mw==", "bodyText": "keep in one line", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496713383", "createdAt": "2020-09-29T13:24:51Z", "author": {"login": "javeme"}, "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java", "diffHunk": "@@ -286,4 +288,23 @@ public String writeWeightedPaths(WeightedPaths paths,\n         return JsonUtil.toJson(ImmutableMap.of(\"paths\", paths.toMap(),\n                                                \"vertices\", vertices));\n     }\n+\n+    @Override\n+    public String writeNodesWithPath(String name, Set<Id> nodes,\n+                                     Collection<HugeTraverser.Path> paths,\n+                                     Iterator<Vertex> iterator,\n+                                     boolean countOnly) {\n+        List<Map<String, Object>> pathList;\n+        pathList = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTUzNDc2OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoyNToyMlrOHZtAIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoyNToyMlrOHZtAIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxMzc2MQ==", "bodyText": "remove empty line", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496713761", "createdAt": "2020-09-29T13:25:22Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java", "diffHunk": "@@ -503,4 +503,21 @@ public static synchronized CoreOptions instance() {\n                     disallowEmpty(),\n                     \"./conf/computer.yaml\"\n             );\n+\n+    public static final ConfigOption<Integer> OLTP_CONCURRENT_THREADS =\n+            new ConfigOption<>(\n+                    \"oltp.concurrent_threads\",\n+                    \"Thread number to concurrently execute oltp algorithm.\",\n+                    rangeInt(0, 65535),\n+                    10\n+            );\n+\n+    public static final ConfigOption<Integer> OLTP_CONCURRENT_DEPTH =\n+            new ConfigOption<>(\n+                    \"oltp.concurrent_depth\",\n+                    \"The min depth to enable concurrent oltp algorithm.\",\n+                    rangeInt(0, 65535),\n+                    10\n+            );\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTUzODU3OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoyNjowN1rOHZtCXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoyNjowN1rOHZtCXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxNDMzNQ==", "bodyText": "also refactor this class, and can we share code with templatepath?", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496714335", "createdAt": "2020-09-29T13:26:07Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.structure.HugeVertex;\n+import com.baidu.hugegraph.util.E;\n+import com.baidu.hugegraph.util.Log;\n+\n+public class CollectionPathsTraverser extends TpTraverser {\n+\n+    private static final Logger LOG = Log.logger(CollectionPathsTraverser.class);\n+\n+    public CollectionPathsTraverser(HugeGraph graph) {\n+        super(graph, \"collection-paths\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<Path> paths(Iterator<Vertex> sources,\n+                                  Iterator<Vertex> targets,\n+                                  EdgeStep step, int depth, boolean nearest,\n+                                  long capacity, long limit) {\n+        checkCapacity(capacity);\n+        checkLimit(limit);\n+\n+        List<Id> sourceList = new ArrayList<>();\n+        while (sources.hasNext()) {\n+            sourceList.add(((HugeVertex) sources.next()).id());\n+        }\n+        int sourceSize = sourceList.size();\n+        E.checkState(sourceSize >= 1 && sourceSize <= MAX_VERTICES,\n+                     \"The number of source vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+        List<Id> targetList = new ArrayList<>();\n+        while (targets.hasNext()) {\n+            targetList.add(((HugeVertex) targets.next()).id());\n+        }\n+        int targetSize = targetList.size();\n+        E.checkState(targetSize >= 1 && targetSize <= MAX_VERTICES,\n+                     \"The number of target vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+        checkPositive(depth, \"max depth\");\n+\n+        Traverser traverser = depth >= this.concurrentDepth() ?\n+                              this.concurrentTraverser(sourceList, targetList,\n+                                                       step, nearest,\n+                                                       capacity, limit) :\n+                              this.singleTraverser(sourceList, targetList, step,\n+                                                   nearest, capacity, limit);\n+\n+        while (true) {\n+            if (--depth < 0 || traverser.reachLimit()) {\n+                break;\n+            }\n+            traverser.forward();\n+\n+            if (--depth < 0 || traverser.reachLimit()) {\n+                break;\n+            }\n+            traverser.backward();\n+        }\n+        return traverser.paths();\n+    }\n+\n+    private Traverser singleTraverser(List<Id> sources, List<Id> targets,\n+                                      EdgeStep step, boolean nearest,\n+                                      long capacity, long limit) {\n+        return nearest ? new SingleNearestTraverser(sources, targets, step,\n+                                                    capacity, limit) :\n+                         new SingleAllTraverser(sources, targets, step,\n+                                                capacity, limit);\n+    }\n+\n+    private Traverser concurrentTraverser(List<Id> sources, List<Id> targets,\n+                                          EdgeStep step, boolean nearest,\n+                                          long capacity, long limit) {\n+        return new ConcurrentTraverser(sources, targets, step, capacity, limit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTU1NjMwOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoyOTo0MlrOHZtNQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzoyOTo0MlrOHZtNQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxNzEyMQ==", "bodyText": "refactor with one method and call newSet() of Single and Concurrent", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496717121", "createdAt": "2020-09-29T13:29:42Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+\n+public class CustomizedKneighborTraverser extends TpTraverser {\n+\n+    public CustomizedKneighborTraverser(HugeGraph graph) {\n+        super(graph, \"kneighbor\");\n+    }\n+\n+    public Set<Node> customizedKneighbor(Id source, EdgeStep step,\n+                                         int maxDepth, long limit) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkPositive(maxDepth, \"k-neighbor max_depth\");\n+        checkLimit(limit);\n+\n+        if (maxDepth >= this.concurrentDepth() &&\n+            step.direction == Directions.BOTH) {\n+            return this.customizedKneighborConcurrent(source, step,\n+                                                      maxDepth, limit);\n+        } else {\n+            return this.customizedKneighborSingle(source, step,\n+                                                  maxDepth, limit);\n+        }\n+    }\n+\n+    public Set<Node> customizedKneighborConcurrent(Id source, EdgeStep step,\n+                                                   int maxDepth, long limit) {\n+        Set<Node> latest = ConcurrentHashMap.newKeySet();\n+        Set<Node> all = ConcurrentHashMap.newKeySet();\n+\n+        Node sourceV = new KNode(source, null);\n+\n+        latest.add(sourceV);\n+        all.add(sourceV);\n+\n+        while (maxDepth-- > 0) {\n+            long remaining = limit == NO_LIMIT ? NO_LIMIT : limit - all.size();\n+            AtomicLong remain = new AtomicLong(remaining);\n+            latest = this.adjacentVertices(latest, step, all, remain);\n+            int size = all.size() + latest.size();\n+            if (limit != NO_LIMIT && size >= limit) {\n+                int subLength = (int) limit - all.size();\n+                Iterator<Node> iterator = latest.iterator();\n+                for (int i = 0; i < subLength && iterator.hasNext(); i++) {\n+                    all.add(iterator.next());\n+                }\n+                break;\n+            } else {\n+                all.addAll(latest);\n+            }\n+        }\n+\n+        return all;\n+    }\n+\n+    public Set<Node> customizedKneighborSingle(Id source, EdgeStep step,\n+                                               int maxDepth, long limit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTU1ODc4OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozMDowN1rOHZtOsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozMDowN1rOHZtOsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxNzQ5MA==", "bodyText": "ditto", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496717490", "createdAt": "2020-09-29T13:30:07Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.CollectionUtil;\n+import com.baidu.hugegraph.util.E;\n+\n+public class CustomizedKoutTraverser extends TpTraverser {\n+\n+    public CustomizedKoutTraverser(HugeGraph graph) {\n+        super(graph, \"kout\");\n+    }\n+\n+    public Set<Node> customizedKout(Id source, EdgeStep step, int maxDepth,\n+                                    boolean nearest, long capacity,\n+                                    long limit) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkPositive(maxDepth, \"k-out max_depth\");\n+        checkCapacity(capacity);\n+        checkLimit(limit);\n+\n+        Set<Node> results;\n+        if (maxDepth >= this.concurrentDepth() &&\n+            step.direction == Directions.BOTH) {\n+            results = this.customizedKoutConcurrent(source, step, maxDepth,\n+                                                    nearest, capacity);\n+        } else {\n+            results = this.customizedKoutSingle(source, step, maxDepth,\n+                                                nearest, capacity);\n+        }\n+\n+        if (limit != NO_LIMIT && results.size() > limit) {\n+            results = CollectionUtil.subSet(results, 0, (int) limit);\n+        }\n+\n+        return results;\n+    }\n+\n+    public Set<Node> customizedKoutConcurrent(Id source, EdgeStep step,\n+                                              int maxDepth, boolean nearest,\n+                                              long capacity) {\n+        Set<Node> latest = ConcurrentHashMap.newKeySet();\n+        Set<Node> all = ConcurrentHashMap.newKeySet();\n+\n+        Node sourceV = new KNode(source, null);\n+\n+        latest.add(sourceV);\n+        all.add(sourceV);\n+\n+        int depth = maxDepth;\n+        long remaining = capacity == NO_LIMIT ?\n+                         NO_LIMIT : capacity - latest.size();\n+        while (depth-- > 0) {\n+            AtomicLong remain = new AtomicLong(remaining);\n+            if (nearest) {\n+                latest = this.adjacentVertices(latest, step, all, remain);\n+                all.addAll(latest);\n+            } else {\n+                latest = this.adjacentVertices(latest, step, null, remain);\n+            }\n+            if (capacity != NO_LIMIT) {\n+                // Update 'remaining' value to record remaining capacity\n+                remaining -= latest.size();\n+                reachCapacity(remaining, capacity, depth);\n+            }\n+        }\n+\n+        return latest;\n+    }\n+\n+    public Set<Node> customizedKoutSingle(Id source, EdgeStep step,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTU2MjUyOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozMDo1M1rOHZtQ8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozMDo1M1rOHZtQ8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxODA2Ng==", "bodyText": "align", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496718066", "createdAt": "2020-09-29T13:30:53Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java", "diffHunk": "@@ -194,7 +194,13 @@ public SimilarsMap fusiformSimilarity(Iterator<Vertex> vertices,\n     }\n \n     private static void checkGroupArgs(String groupProperty, int minGroups) {\n-        if (groupProperty != null) {\n+        if (groupProperty == null) {\n+            E.checkArgument(minGroups == 0,\n+                            \"Can not set min group count when \" +\n+                                    \"group property not set\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTU2NjAyOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozMTo0MFrOHZtTNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozMTo0MFrOHZtTNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxODY0NA==", "bodyText": "Can't", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496718644", "createdAt": "2020-09-29T13:31:40Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java", "diffHunk": "@@ -194,7 +194,13 @@ public SimilarsMap fusiformSimilarity(Iterator<Vertex> vertices,\n     }\n \n     private static void checkGroupArgs(String groupProperty, int minGroups) {\n-        if (groupProperty != null) {\n+        if (groupProperty == null) {\n+            E.checkArgument(minGroups == 0,\n+                            \"Can not set min group count when \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTU4MjUxOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozNTowOVrOHZtdYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozNTowOVrOHZtdYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMTI0OQ==", "bodyText": "move  Iterator adjacentVertices() to line 293", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496721249", "createdAt": "2020-09-29T13:35:09Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -259,6 +262,35 @@ public double jaccardSimilarity(Id vertex, Id other, Directions dir,\n         });\n     }\n \n+    protected Set<Node> adjacentVertices(Set<Node> vertices, EdgeStep step,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTU5MDg1OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozNjo1MFrOHZtimg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozNjo1MFrOHZtimg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMjU4Ng==", "bodyText": "prefer move kout/jaccardSimilarity out of this class", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496722586", "createdAt": "2020-09-29T13:36:50Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -217,10 +218,12 @@ public double jaccardSimilarity(Id vertex, Id other, Directions dir,\n                                   vertex, dir, labelId, degree));\n         Set<Id> targetNeighbors = IteratorUtils.set(this.adjacentVertices(\n                                   other, dir, labelId, degree));\n-        int interNum = CollectionUtil.intersect(sourceNeighbors,\n-                                                targetNeighbors).size();\n-        int unionNum = CollectionUtil.union(sourceNeighbors,\n-                                            targetNeighbors).size();\n+        return jaccardSimilarity(sourceNeighbors, targetNeighbors);\n+    }\n+\n+    public double jaccardSimilarity(Set<Id> set1, Set<Id> set2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTU5MzkxOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/JaccardSimilarTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozNzozMVrOHZtklw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMzozNzozMVrOHZtklw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMzA5NQ==", "bodyText": "ditto", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496723095", "createdAt": "2020-09-29T13:37:31Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/JaccardSimilarTraverser.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class JaccardSimilarTraverser extends TpTraverser {\n+\n+    public JaccardSimilarTraverser(HugeGraph graph) {\n+        super(graph, \"jaccard-similar\");\n+    }\n+\n+    public Map<Id, Double> jaccardSimilars(Id source, EdgeStep step,\n+                                           int top, long capacity) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkCapacity(capacity);\n+\n+        Map<Id, Double> results;\n+        if (3 >= this.concurrentDepth() &&\n+            step.direction == Directions.BOTH) {\n+            results = this.jaccardSimilarsConcurrent(source, step, capacity);\n+        } else {\n+            results = this.jaccardSimilarsSingle(source, step, capacity);\n+        }\n+\n+        if (top > 0) {\n+            results = HugeTraverser.topN(results, true, top);\n+        }\n+\n+        return results;\n+    }\n+\n+    public Map<Id, Double> jaccardSimilarsConcurrent(Id source, EdgeStep step,\n+                                                     long capacity) {\n+        AtomicLong count = new AtomicLong(0L);\n+        Set<Id> accessed = ConcurrentHashMap.newKeySet();\n+        accessed.add(source);\n+        reachCapacity(count.incrementAndGet(), capacity);\n+\n+        // Query neighbors\n+        Set<Id> layer1s = this.adjacentVertices(source, step);\n+        reachCapacity(count.get() + layer1s.size(), capacity);\n+        count.addAndGet(layer1s.size());\n+        if (layer1s.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+\n+        Map<Id, Double> results = new ConcurrentHashMap<>();\n+        Set<Id> layer2All = ConcurrentHashMap.newKeySet();\n+\n+        this.traverseIds(layer1s.iterator(), id -> {\n+            // Skip if accessed already\n+            if (accessed.contains(id)) {\n+                return;\n+            }\n+            Set<Id> layer2s = this.adjacentVertices(id, step);\n+            if (layer2s.isEmpty()) {\n+                results.put(id, 0.0D);\n+            }\n+\n+            layer2All.addAll(layer2s);\n+            reachCapacity(count.get() + layer2All.size(), capacity);\n+            double jaccardSimilarity = this.jaccardSimilarity(layer1s, layer2s);\n+            results.put(id, jaccardSimilarity);\n+            accessed.add(id);\n+        });\n+\n+        count.addAndGet(layer2All.size());\n+\n+        this.traverseIds(layer2All.iterator(), id -> {\n+            // Skip if accessed already\n+            if (accessed.contains(id)) {\n+                return;\n+            }\n+            Set<Id> layer3s = this.adjacentVertices(id, step);\n+            reachCapacity(count.get() + layer3s.size(), capacity);\n+            if (layer3s.isEmpty()) {\n+                results.put(id, 0.0D);\n+            }\n+\n+            double jaccardSimilarity = this.jaccardSimilarity(layer1s, layer3s);\n+            results.put(id, jaccardSimilarity);\n+            accessed.add(id);\n+        });\n+\n+        return results;\n+    }\n+\n+    public Map<Id, Double> jaccardSimilarsSingle(Id source, EdgeStep step,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NjgwNjUzOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowNDowNVrOHgodmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowNDowNVrOHgodmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk3OTQxOQ==", "bodyText": "no nearest when Concurrent?", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503979419", "createdAt": "2020-10-13T14:04:05Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "diffHunk": "@@ -75,509 +73,215 @@ public CollectionPathsTraverser(HugeGraph graph) {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n-        Traverser traverser = depth >= this.concurrentDepth() ?\n-                              this.concurrentTraverser(sourceList, targetList,\n-                                                       step, nearest,\n-                                                       capacity, limit) :\n-                              this.singleTraverser(sourceList, targetList, step,\n-                                                   nearest, capacity, limit);\n-\n-        while (true) {\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n-            }\n-            traverser.forward();\n-\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n+        Traverser traverser;\n+\n+        TraverseStrategy strategy;\n+        if (depth >= this.concurrentDepth()) {\n+            strategy = new ConcurrentTraverseStrategy(this.graph());\n+            traverser = new Traverser(sourceList, targetList, step, depth,\n+                                      capacity, limit, strategy);\n+        } else {\n+            strategy = new SingleTraverseStrategy(this.graph());\n+            if (nearest) {\n+                traverser = new SingleNearestTraverser(sourceList, targetList,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NjgxMDk2OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowNTowMVrOHgogdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODoxNjoxNFrOHlft-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDE0OA==", "bodyText": "unused empty line", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503980148", "createdAt": "2020-10-13T14:05:01Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "diffHunk": "@@ -75,509 +73,215 @@ public CollectionPathsTraverser(HugeGraph graph) {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n-        Traverser traverser = depth >= this.concurrentDepth() ?\n-                              this.concurrentTraverser(sourceList, targetList,\n-                                                       step, nearest,\n-                                                       capacity, limit) :\n-                              this.singleTraverser(sourceList, targetList, step,\n-                                                   nearest, capacity, limit);\n-\n-        while (true) {\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n-            }\n-            traverser.forward();\n-\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n+        Traverser traverser;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3OTAzMw==", "bodyText": "unused empty line", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509079033", "createdAt": "2020-10-21T08:16:14Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "diffHunk": "@@ -75,509 +73,215 @@ public CollectionPathsTraverser(HugeGraph graph) {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n-        Traverser traverser = depth >= this.concurrentDepth() ?\n-                              this.concurrentTraverser(sourceList, targetList,\n-                                                       step, nearest,\n-                                                       capacity, limit) :\n-                              this.singleTraverser(sourceList, targetList, step,\n-                                                   nearest, capacity, limit);\n-\n-        while (true) {\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n-            }\n-            traverser.forward();\n-\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n+        Traverser traverser;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDE0OA=="}, "originalCommit": {"oid": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NjgyMTM1OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowNzoxNVrOHgonKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowNzoxNVrOHgonKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MTg2NQ==", "bodyText": "prefer rename to concurrent", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503981865", "createdAt": "2020-10-13T14:07:15Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -540,7 +403,15 @@ public static void checkSkipDegree(long skipDegree, long degree,\n     }\n \n     protected static <V> Set<V> newSet() {\n-        return new HashSet<>();\n+        return newSet(true);\n+    }\n+\n+    protected static <V> Set<V> newSet(boolean single) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NjgyNzg5OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowODozNVrOHgorNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowODozNVrOHgorNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MjkwMQ==", "bodyText": "add a new java file", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503982901", "createdAt": "2020-10-13T14:08:35Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "diffHunk": "@@ -160,6 +177,199 @@ protected boolean match(Element elem, String key, Object value) {\n         return p.isPresent() && Objects.equal(p.value(), value);\n     }\n \n+    protected TraverseStrategy traverseStrategy(boolean single) {\n+        return single ? new SingleTraverseStrategy(this.graph()) :\n+                        new ConcurrentTraverseStrategy(this.graph());\n+\n+    }\n+\n+    public abstract class PathTraverser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDkxODQ3OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1MjoyOVrOHk4gow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1MjoyOVrOHk4gow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjY0Mw==", "bodyText": "this.traverseOneLayer", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508436643", "createdAt": "2020-10-20T11:52:29Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e8372a3adb05d109ed1c640a0087016ab0ad571"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDkyMzk5OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1NDowOFrOHk4kBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1NDowOFrOHk4kBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNzUxMA==", "bodyText": "ditto", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508437510", "createdAt": "2020-10-20T11:54:08Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e8372a3adb05d109ed1c640a0087016ab0ad571"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDkyNTM3OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1NDozMFrOHk4k5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1NDozMFrOHk4k5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNzczNA==", "bodyText": "ditto", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508437734", "createdAt": "2020-10-20T11:54:30Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);\n+        currentStep.swithDirection();\n+\n+        this.afterTraverse(currentStep, false);\n+    }\n+\n+    public abstract EdgeStep nextStep(boolean forward);\n+\n+    public void beforeTraverse(boolean forward) {\n+        this.clearNewVertices();\n+    }\n+\n+    public void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                                 EdgeStep step,\n+                                 BiConsumer<Id, EdgeStep> consumer) {\n+        this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n+    }\n+\n+    public void afterTraverse(EdgeStep step, boolean forward) {\n+        this.reInitCurrentStepIfNeeded(step, forward);\n+        this.stepCount++;\n+    }\n+\n+    private void forward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, true);\n+    }\n+\n+    private void backward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, false);\n+    }\n+\n+    private void traverseOne(Id v, EdgeStep step, boolean forward) {\n+        if (this.reachLimit()) {\n+            return;\n+        }\n+\n+        Iterator<Edge> edges = this.edgesOfVertex(v, step);\n+        while (edges.hasNext()) {\n+            HugeEdge edge = (HugeEdge) edges.next();\n+            Id target = edge.id().otherVertexId();\n+\n+            this.processOne(v, target, forward);\n+        }\n+    }\n+\n+    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n+    }\n+\n+    private void processOne(Id source, Id target, boolean forward) {\n+        if (forward) {\n+            processOneForForward(source, target);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e8372a3adb05d109ed1c640a0087016ab0ad571"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDkyNTY5OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1NDozNVrOHk4lEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1NDozNVrOHk4lEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNzc3Ng==", "bodyText": "ditto", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508437776", "createdAt": "2020-10-20T11:54:35Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);\n+        currentStep.swithDirection();\n+\n+        this.afterTraverse(currentStep, false);\n+    }\n+\n+    public abstract EdgeStep nextStep(boolean forward);\n+\n+    public void beforeTraverse(boolean forward) {\n+        this.clearNewVertices();\n+    }\n+\n+    public void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                                 EdgeStep step,\n+                                 BiConsumer<Id, EdgeStep> consumer) {\n+        this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n+    }\n+\n+    public void afterTraverse(EdgeStep step, boolean forward) {\n+        this.reInitCurrentStepIfNeeded(step, forward);\n+        this.stepCount++;\n+    }\n+\n+    private void forward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, true);\n+    }\n+\n+    private void backward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, false);\n+    }\n+\n+    private void traverseOne(Id v, EdgeStep step, boolean forward) {\n+        if (this.reachLimit()) {\n+            return;\n+        }\n+\n+        Iterator<Edge> edges = this.edgesOfVertex(v, step);\n+        while (edges.hasNext()) {\n+            HugeEdge edge = (HugeEdge) edges.next();\n+            Id target = edge.id().otherVertexId();\n+\n+            this.processOne(v, target, forward);\n+        }\n+    }\n+\n+    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n+    }\n+\n+    private void processOne(Id source, Id target, boolean forward) {\n+        if (forward) {\n+            processOneForForward(source, target);\n+        } else {\n+            processOneForBackward(source, target);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e8372a3adb05d109ed1c640a0087016ab0ad571"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDkyODY2OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1NToyNVrOHk4m7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMTo1NToyNVrOHk4m7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODI1Mw==", "bodyText": "finished", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508438253", "createdAt": "2020-10-20T11:55:25Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);\n+        currentStep.swithDirection();\n+\n+        this.afterTraverse(currentStep, false);\n+    }\n+\n+    public abstract EdgeStep nextStep(boolean forward);\n+\n+    public void beforeTraverse(boolean forward) {\n+        this.clearNewVertices();\n+    }\n+\n+    public void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                                 EdgeStep step,\n+                                 BiConsumer<Id, EdgeStep> consumer) {\n+        this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n+    }\n+\n+    public void afterTraverse(EdgeStep step, boolean forward) {\n+        this.reInitCurrentStepIfNeeded(step, forward);\n+        this.stepCount++;\n+    }\n+\n+    private void forward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, true);\n+    }\n+\n+    private void backward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, false);\n+    }\n+\n+    private void traverseOne(Id v, EdgeStep step, boolean forward) {\n+        if (this.reachLimit()) {\n+            return;\n+        }\n+\n+        Iterator<Edge> edges = this.edgesOfVertex(v, step);\n+        while (edges.hasNext()) {\n+            HugeEdge edge = (HugeEdge) edges.next();\n+            Id target = edge.id().otherVertexId();\n+\n+            this.processOne(v, target, forward);\n+        }\n+    }\n+\n+    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n+    }\n+\n+    private void processOne(Id source, Id target, boolean forward) {\n+        if (forward) {\n+            processOneForForward(source, target);\n+        } else {\n+            processOneForBackward(source, target);\n+        }\n+    }\n+\n+    protected abstract void processOneForForward(Id source, Id target);\n+\n+    protected abstract void processOneForBackward(Id source, Id target);\n+\n+    protected abstract void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                      boolean forward);\n+\n+    public void clearNewVertices() {\n+        this.newVertices = this.newMultiValueMap();\n+    }\n+\n+    public void addNodeToNewVertices(Id id, HugeTraverser.Node node) {\n+        this.addNode(this.newVertices, id, node);\n+    }\n+\n+    public Map<Id, List<HugeTraverser.Node>> newMultiValueMap() {\n+        return this.traverseStrategy.newMultiValueMap();\n+    }\n+\n+    public Set<HugeTraverser.Path> newPathSet() {\n+        return this.traverseStrategy.newPathSet();\n+    }\n+\n+    public void addNode(Map<Id, List<HugeTraverser.Node>> vertices, Id id,\n+                        HugeTraverser.Node node) {\n+        this.traverseStrategy.addNode(vertices, id, node);\n+    }\n+\n+    public void addNewVerticesToAll(Map<Id, List<HugeTraverser.Node>> targets) {\n+        this.traverseStrategy.addNewVerticesToAll(this.newVertices, targets);\n+    }\n+\n+    public Set<HugeTraverser.Path> paths() {\n+        return this.paths;\n+    }\n+\n+    public int pathCount() {\n+        return this.paths.size();\n+    }\n+\n+    protected boolean finish() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e8372a3adb05d109ed1c640a0087016ab0ad571"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NTA0MjYyOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjoyNTowMlrOHk5rnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjoyNTowMlrOHk5rnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1NTgzNg==", "bodyText": "delete it", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508455836", "createdAt": "2020-10-20T12:25:02Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java", "diffHunk": "@@ -71,4 +74,9 @@ public void addNewVerticesToAll(Map<Id, List<Node>> newVertices,\n             vertices.addAll(entry.getKey(), entry.getValue());\n         }\n     }\n+\n+    @Override\n+    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return super.edgesOfVertex(source, edgeStep);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e8372a3adb05d109ed1c640a0087016ab0ad571"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NTA0MzU5OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjoyNToxNVrOHk5sLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjoyNToxNVrOHk5sLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1NTk4MA==", "bodyText": "delete it", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508455980", "createdAt": "2020-10-20T12:25:15Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java", "diffHunk": "@@ -44,4 +47,6 @@ public abstract void addNode(Map<Id, List<HugeTraverser.Node>> vertices,\n     public abstract void addNewVerticesToAll(\n                          Map<Id, List<HugeTraverser.Node>> newVertices,\n                          Map<Id, List<HugeTraverser.Node>> targets);\n+\n+    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e8372a3adb05d109ed1c640a0087016ab0ad571"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODk5MTI0OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODoxMjoxMlrOHlfjbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODoxMjoxMlrOHlfjbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3NjMzNA==", "bodyText": "also rename TpTraverser to OltpTraverser", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509076334", "createdAt": "2020-10-21T08:12:12Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "diffHunk": "@@ -41,48 +38,34 @@\n import com.baidu.hugegraph.HugeGraph;\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.config.CoreOptions;\n-import com.baidu.hugegraph.config.HugeConfig;\n import com.baidu.hugegraph.iterator.FilterIterator;\n import com.baidu.hugegraph.structure.HugeEdge;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.ConcurrentTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.SingleTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n import com.baidu.hugegraph.util.Consumers;\n \n import jersey.repackaged.com.google.common.base.Objects;\n \n public abstract class TpTraverser extends HugeTraverser\n                                   implements AutoCloseable {\n \n-    protected static ExecutorService executor;\n+    private static final String EXECUTOR_NAME = \"oltp\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fd93f95cdac548c3d56f431d753a03e5ec6da69"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODk5MzAyOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODoxMjo0MFrOHlfkhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODoxMjo0MFrOHlfkhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3NjYxMw==", "bodyText": "empty line", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509076613", "createdAt": "2020-10-21T08:12:40Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java", "diffHunk": "@@ -48,5 +46,9 @@ public abstract void addNewVerticesToAll(\n                          Map<Id, List<HugeTraverser.Node>> newVertices,\n                          Map<Id, List<HugeTraverser.Node>> targets);\n \n-    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep);\n+    public static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n+        return concurrent ? new ConcurrentTraverseStrategy(graph) :\n+                            new SingleTraverseStrategy(graph);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fd93f95cdac548c3d56f431d753a03e5ec6da69"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4OTAwNTk5OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODoxNTozNlrOHlfsVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODoxNTozNlrOHlfsVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3ODYxMw==", "bodyText": "lock for null judgment and assignment", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509078613", "createdAt": "2020-10-21T08:15:36Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "diffHunk": "@@ -41,48 +38,34 @@\n import com.baidu.hugegraph.HugeGraph;\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.config.CoreOptions;\n-import com.baidu.hugegraph.config.HugeConfig;\n import com.baidu.hugegraph.iterator.FilterIterator;\n import com.baidu.hugegraph.structure.HugeEdge;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.ConcurrentTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.SingleTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n import com.baidu.hugegraph.util.Consumers;\n \n import jersey.repackaged.com.google.common.base.Objects;\n \n public abstract class TpTraverser extends HugeTraverser\n                                   implements AutoCloseable {\n \n-    protected static ExecutorService executor;\n+    private static final String EXECUTOR_NAME = \"oltp\";\n+    private static ExecutorService executor;\n \n     protected TpTraverser(HugeGraph graph) {\n         super(graph);\n-    }\n-\n-    protected TpTraverser(HugeGraph graph, String name) {\n-        super(graph);\n         if (executor == null) {\n             int workers = this.config().get(CoreOptions.OLTP_CONCURRENT_THREADS);\n             if (workers > 0) {\n-                executor = Consumers.newThreadPool(name, workers);\n+                executor = Consumers.newThreadPool(EXECUTOR_NAME, workers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fd93f95cdac548c3d56f431d753a03e5ec6da69"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1488, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}