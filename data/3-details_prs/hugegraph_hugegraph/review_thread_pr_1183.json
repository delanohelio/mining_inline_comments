{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5NjgwMDQ3", "number": 1183, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMDo0MTozMVrOEleW3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMDo0ODowMFrOEleY8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NzMwMTQzOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/StandardHugeGraph.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMDo0MTozMVrOHU-XKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMDo0MTozMVrOHU-XKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc1NTMwNA==", "bodyText": "if(ramtable) is more understandable", "url": "https://github.com/hugegraph/hugegraph/pull/1183#discussion_r491755304", "createdAt": "2020-09-21T00:41:31Z", "author": {"login": "houzhizhen"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/StandardHugeGraph.java", "diffHunk": "@@ -126,26 +127,37 @@\n     private final BackendStoreProvider storeProvider;\n     private final TinkerpopTransaction tx;\n \n-    public StandardHugeGraph(HugeConfig configuration) {\n+    private final RamTable ramtable;\n+\n+    public StandardHugeGraph(HugeConfig config) {\n         this.params = new StandardHugeGraphParams();\n-        this.configuration = configuration;\n+        this.configuration = config;\n \n         this.schemaEventHub = new EventHub(\"schema\");\n         this.graphEventHub = new EventHub(\"graph\");\n         this.indexEventHub = new EventHub(\"index\");\n \n-        final int writeLimit = configuration.get(CoreOptions.RATE_LIMIT_WRITE);\n+        final int writeLimit = config.get(CoreOptions.RATE_LIMIT_WRITE);\n         this.writeRateLimiter = writeLimit > 0 ?\n                                 RateLimiter.create(writeLimit) : null;\n-        final int readLimit = configuration.get(CoreOptions.RATE_LIMIT_READ);\n+        final int readLimit = config.get(CoreOptions.RATE_LIMIT_READ);\n         this.readRateLimiter = readLimit > 0 ?\n                                RateLimiter.create(readLimit) : null;\n \n+        boolean ramtable = config.get(CoreOptions.QUERY_RAMTABLE_ENABLE);\n+        if (!ramtable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5f56bcb60860c9166d2e8cb7192379213201fa3"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NzMwNjczOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/util/Consumers.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMDo0ODowMFrOHU-Z8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQwMDo0ODowMFrOHU-Z8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc1NjAxNg==", "bodyText": "It is better to put this.done in finally clause.", "url": "https://github.com/hugegraph/hugegraph/pull/1183#discussion_r491756016", "createdAt": "2020-09-21T00:48:00Z", "author": {"login": "houzhizhen"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/util/Consumers.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.util;\n+\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.task.TaskManager.ContextCallable;\n+import com.baidu.hugegraph.util.ExecutorUtil;\n+import com.baidu.hugegraph.util.Log;\n+\n+public class Consumers<V> {\n+\n+    public static final int CPUS = Runtime.getRuntime().availableProcessors();\n+    public static final int THREADS = 4 + CPUS / 4;\n+    public static final int QUEUE_WORKER_SIZE = 1000;\n+\n+    private static final Logger LOG = Log.logger(Consumers.class);\n+\n+    private final ExecutorService executor;\n+    private final Consumer<V> consumer;\n+    private final Runnable done;\n+\n+    private final int workers;\n+    private final int queueSize;\n+    private final CountDownLatch latch;\n+    private final BlockingQueue<V> queue;\n+\n+    private volatile boolean ending = false;\n+    private volatile Throwable exception = null;\n+\n+    public Consumers(ExecutorService executor, Consumer<V> consumer) {\n+        this(executor, consumer, null);\n+    }\n+\n+    public Consumers(ExecutorService executor,\n+                     Consumer<V> consumer, Runnable done) {\n+        this.executor = executor;\n+        this.consumer = consumer;\n+        this.done = done;\n+\n+        int workers = THREADS;\n+        if (this.executor instanceof ThreadPoolExecutor) {\n+            workers = ((ThreadPoolExecutor) this.executor).getCorePoolSize();\n+        }\n+        this.workers = workers;\n+        this.queueSize = QUEUE_WORKER_SIZE * workers;\n+        this.latch = new CountDownLatch(workers);\n+        this.queue = new ArrayBlockingQueue<>(this.queueSize);\n+    }\n+\n+    public void start(String name) {\n+        this.ending = false;\n+        this.exception = null;\n+        if (this.executor == null) {\n+            return;\n+        }\n+        LOG.info(\"Starting {} workers[{}] with queue size {}...\",\n+                 this.workers, name, this.queueSize);\n+        for (int i = 0; i < this.workers; i++) {\n+            this.executor.submit(new ContextCallable<>(this::runAndDone));\n+        }\n+    }\n+\n+    private Void runAndDone() {\n+        try {\n+            this.run();\n+            this.done();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5f56bcb60860c9166d2e8cb7192379213201fa3"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1492, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}