{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MTAwNzIx", "number": 1079, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMDo0NjoyNVrOEMSl6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwODoxMjo1NlrOEMyhHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzIyOTg1OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/TaskManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMDo0NjoyNVrOGuUTcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjoyMzo0N1rOGuZvbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMDMzNg==", "bodyText": "Parameter task is not used.", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r451220336", "createdAt": "2020-07-08T00:46:25Z", "author": {"login": "houzhizhen"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/TaskManager.java", "diffHunk": "@@ -242,17 +237,19 @@ public int pendingTasks() {\n     }\n \n     protected void notifyNewTask(HugeTask<?> task) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795ef8923415fe938de02fc5d3cb5c5f4f7e7a3d"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMwOTQyMw==", "bodyText": "does not matter, just preserved", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r451309423", "createdAt": "2020-07-08T06:23:47Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/TaskManager.java", "diffHunk": "@@ -242,17 +237,19 @@ public int pendingTasks() {\n     }\n \n     protected void notifyNewTask(HugeTask<?> task) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMDMzNg=="}, "originalCommit": {"oid": "795ef8923415fe938de02fc5d3cb5c5f4f7e7a3d"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzI2Nzg0OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/TaskManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMTowODo0MlrOGuUprw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNjoyODowNFrOGuZ14A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNjAzMQ==", "bodyText": "It may schedule more tasks at the same time, and these tasks will not be processed.", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r451226031", "createdAt": "2020-07-08T01:08:42Z", "author": {"login": "houzhizhen"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/TaskManager.java", "diffHunk": "@@ -242,17 +237,19 @@ public int pendingTasks() {\n     }\n \n     protected void notifyNewTask(HugeTask<?> task) {\n-        // Notify to schedule tasks initiatively when have new task\n-        this.schedulerExecutor.submit(this::scheduleOrExecuteJob);\n+        Queue<Runnable> queue = ((ThreadPoolExecutor) this.schedulerExecutor)\n+                                                          .getQueue();\n+        if (queue.size() <= 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795ef8923415fe938de02fc5d3cb5c5f4f7e7a3d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTMxMTA3Mg==", "bodyText": "it's ok to not notify again if there are more than 1 task in queue(like two, one is timer task, one is immediate task), we don't want too many  immediate tasks to be inserted into queue, one notify will cause all the tasks processed.", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r451311072", "createdAt": "2020-07-08T06:28:04Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/TaskManager.java", "diffHunk": "@@ -242,17 +237,19 @@ public int pendingTasks() {\n     }\n \n     protected void notifyNewTask(HugeTask<?> task) {\n-        // Notify to schedule tasks initiatively when have new task\n-        this.schedulerExecutor.submit(this::scheduleOrExecuteJob);\n+        Queue<Runnable> queue = ((ThreadPoolExecutor) this.schedulerExecutor)\n+                                                          .getQueue();\n+        if (queue.size() <= 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNjAzMQ=="}, "originalCommit": {"oid": "795ef8923415fe938de02fc5d3cb5c5f4f7e7a3d"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzQ1MzUwOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMzowMDoyM1rOGuWYZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMzowMDoyM1rOGuWYZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI1NDM3Mw==", "bodyText": "queued => scheduling", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r451254373", "createdAt": "2020-07-08T03:00:23Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "diffHunk": "@@ -248,127 +272,128 @@ private void unlistenChanges() {\n     @Override\n     public synchronized <V> void cancel(HugeTask<V> task) {\n         E.checkArgumentNotNull(task, \"Task can't be null\");\n-        if (!this.serverManager().master()) {\n+        this.checkOnMasterNode(\"cancel\");\n+\n+        if (task.completed() || task.cancelling()) {\n             return;\n         }\n-        if (!task.completed()) {\n-            // The task scheduled to workers, waiting for worker cancel\n-            task.status(TaskStatus.CANCELLING);\n+\n+        LOG.info(\"Cancel task '{}' in status {}\", task.id(), task.status());\n+\n+        if (task.server() == null) {\n+            // The task not scheduled to workers, set canceled immediately\n+            assert task.status().code() < TaskStatus.QUEUED.code();\n+            if (task.status(TaskStatus.CANCELLED)) {\n+                this.save(task);\n+                return;\n+            }\n+        } else if (task.status(TaskStatus.CANCELLING)) {\n+            // The task scheduled to workers, let the worker node to cancel\n             this.save(task);\n-            this.remove(task.id());\n+            assert task.server() != null : task;\n+            assert this.serverManager().master();\n+            if (!task.server().equals(this.serverManager().selfServerId())) {\n+                /*\n+                 * Remove task from memory if it's running on worker node,\n+                 * but keep task in memory if it's running on master node.\n+                 * cancel-scheduling will read task from backend store, if\n+                 * removed this instance from memory, there will be two task\n+                 * instances with same id, and can't cancel the real task that\n+                 * is running but removed from memory.\n+                 */\n+                this.remove(task);\n+            }\n             // Notify master server to schedule and execute immediately\n             TaskManager.instance().notifyNewTask(task);\n+            return;\n         }\n+\n+        throw new HugeException(\"Can't cancel task '%s' in status %s\",\n+                                task.id(), task.status());\n+    }\n+\n+    protected ServerInfoManager serverManager() {\n+        return this.serverManager;\n     }\n \n-    protected synchronized <V> void scheduleTasks() {\n-        // Master schedule all queued tasks to suitable servers\n+    protected synchronized void scheduleTasks() {\n+        // Master server schedule all queued tasks to suitable worker servers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795ef8923415fe938de02fc5d3cb5c5f4f7e7a3d"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzQ2OTgzOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMzoxMDozMFrOGuWh5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo0MDowNlrOGueBLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI1NjgwNA==", "bodyText": "must save server info here. Otherwise all tasks will be scheduled to same worker\nImplement increaseLoad(int load) in class HugeServerInfo", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r451256804", "createdAt": "2020-07-08T03:10:30Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "diffHunk": "@@ -248,127 +272,128 @@ private void unlistenChanges() {\n     @Override\n     public synchronized <V> void cancel(HugeTask<V> task) {\n         E.checkArgumentNotNull(task, \"Task can't be null\");\n-        if (!this.serverManager().master()) {\n+        this.checkOnMasterNode(\"cancel\");\n+\n+        if (task.completed() || task.cancelling()) {\n             return;\n         }\n-        if (!task.completed()) {\n-            // The task scheduled to workers, waiting for worker cancel\n-            task.status(TaskStatus.CANCELLING);\n+\n+        LOG.info(\"Cancel task '{}' in status {}\", task.id(), task.status());\n+\n+        if (task.server() == null) {\n+            // The task not scheduled to workers, set canceled immediately\n+            assert task.status().code() < TaskStatus.QUEUED.code();\n+            if (task.status(TaskStatus.CANCELLED)) {\n+                this.save(task);\n+                return;\n+            }\n+        } else if (task.status(TaskStatus.CANCELLING)) {\n+            // The task scheduled to workers, let the worker node to cancel\n             this.save(task);\n-            this.remove(task.id());\n+            assert task.server() != null : task;\n+            assert this.serverManager().master();\n+            if (!task.server().equals(this.serverManager().selfServerId())) {\n+                /*\n+                 * Remove task from memory if it's running on worker node,\n+                 * but keep task in memory if it's running on master node.\n+                 * cancel-scheduling will read task from backend store, if\n+                 * removed this instance from memory, there will be two task\n+                 * instances with same id, and can't cancel the real task that\n+                 * is running but removed from memory.\n+                 */\n+                this.remove(task);\n+            }\n             // Notify master server to schedule and execute immediately\n             TaskManager.instance().notifyNewTask(task);\n+            return;\n         }\n+\n+        throw new HugeException(\"Can't cancel task '%s' in status %s\",\n+                                task.id(), task.status());\n+    }\n+\n+    protected ServerInfoManager serverManager() {\n+        return this.serverManager;\n     }\n \n-    protected synchronized <V> void scheduleTasks() {\n-        // Master schedule all queued tasks to suitable servers\n+    protected synchronized void scheduleTasks() {\n+        // Master server schedule all queued tasks to suitable worker servers\n+        Map<HugeServerInfo, MutableInt> scheduleInfos = new HashMap<>();\n+        ServerInfoManager serverManager = this.serverManager();\n         String page = this.supportsPaging() ? PageInfo.PAGE_NONE : null;\n         do {\n-            Iterator<HugeTask<V>> tasks = this.tasks(TaskStatus.QUEUED,\n-                                                     PAGE_SIZE, page);\n-            HugeTask<V> task;\n+            Iterator<HugeTask<Object>> tasks = this.tasks(TaskStatus.SCHEDULING,\n+                                                          PAGE_SIZE, page);\n             while (tasks.hasNext()) {\n-                task = tasks.next();\n+                HugeTask<?> task = tasks.next();\n                 if (task.server() != null) {\n                     // Skip if already scheduled\n                     continue;\n                 }\n-                HugeServerInfo server = this.pickWorker(task);\n+\n+                HugeServerInfo server = serverManager.pickWorker(task);\n                 if (server == null) {\n                     LOG.debug(\"The master can't find suitable servers to \" +\n-                              \"execute task: {}, wait for next schedule\",\n+                              \"execute task '{}', wait for next schedule\",\n                               task.id());\n-                    return;\n+                    continue;\n                 }\n \n                 // Found suitable server, update task server and server load\n                 assert server.id() != null;\n                 task.server(server.id());\n+                task.status(TaskStatus.SCHEDULED);\n                 this.save(task);\n+\n                 server.load(server.load() + task.load());\n-                this.serverManager().save(server);\n-                LOG.info(\"Schedule task {} to server {}\",\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795ef8923415fe938de02fc5d3cb5c5f4f7e7a3d"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3OTUwMA==", "bodyText": "use batch read write", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r451379500", "createdAt": "2020-07-08T08:40:06Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "diffHunk": "@@ -248,127 +272,128 @@ private void unlistenChanges() {\n     @Override\n     public synchronized <V> void cancel(HugeTask<V> task) {\n         E.checkArgumentNotNull(task, \"Task can't be null\");\n-        if (!this.serverManager().master()) {\n+        this.checkOnMasterNode(\"cancel\");\n+\n+        if (task.completed() || task.cancelling()) {\n             return;\n         }\n-        if (!task.completed()) {\n-            // The task scheduled to workers, waiting for worker cancel\n-            task.status(TaskStatus.CANCELLING);\n+\n+        LOG.info(\"Cancel task '{}' in status {}\", task.id(), task.status());\n+\n+        if (task.server() == null) {\n+            // The task not scheduled to workers, set canceled immediately\n+            assert task.status().code() < TaskStatus.QUEUED.code();\n+            if (task.status(TaskStatus.CANCELLED)) {\n+                this.save(task);\n+                return;\n+            }\n+        } else if (task.status(TaskStatus.CANCELLING)) {\n+            // The task scheduled to workers, let the worker node to cancel\n             this.save(task);\n-            this.remove(task.id());\n+            assert task.server() != null : task;\n+            assert this.serverManager().master();\n+            if (!task.server().equals(this.serverManager().selfServerId())) {\n+                /*\n+                 * Remove task from memory if it's running on worker node,\n+                 * but keep task in memory if it's running on master node.\n+                 * cancel-scheduling will read task from backend store, if\n+                 * removed this instance from memory, there will be two task\n+                 * instances with same id, and can't cancel the real task that\n+                 * is running but removed from memory.\n+                 */\n+                this.remove(task);\n+            }\n             // Notify master server to schedule and execute immediately\n             TaskManager.instance().notifyNewTask(task);\n+            return;\n         }\n+\n+        throw new HugeException(\"Can't cancel task '%s' in status %s\",\n+                                task.id(), task.status());\n+    }\n+\n+    protected ServerInfoManager serverManager() {\n+        return this.serverManager;\n     }\n \n-    protected synchronized <V> void scheduleTasks() {\n-        // Master schedule all queued tasks to suitable servers\n+    protected synchronized void scheduleTasks() {\n+        // Master server schedule all queued tasks to suitable worker servers\n+        Map<HugeServerInfo, MutableInt> scheduleInfos = new HashMap<>();\n+        ServerInfoManager serverManager = this.serverManager();\n         String page = this.supportsPaging() ? PageInfo.PAGE_NONE : null;\n         do {\n-            Iterator<HugeTask<V>> tasks = this.tasks(TaskStatus.QUEUED,\n-                                                     PAGE_SIZE, page);\n-            HugeTask<V> task;\n+            Iterator<HugeTask<Object>> tasks = this.tasks(TaskStatus.SCHEDULING,\n+                                                          PAGE_SIZE, page);\n             while (tasks.hasNext()) {\n-                task = tasks.next();\n+                HugeTask<?> task = tasks.next();\n                 if (task.server() != null) {\n                     // Skip if already scheduled\n                     continue;\n                 }\n-                HugeServerInfo server = this.pickWorker(task);\n+\n+                HugeServerInfo server = serverManager.pickWorker(task);\n                 if (server == null) {\n                     LOG.debug(\"The master can't find suitable servers to \" +\n-                              \"execute task: {}, wait for next schedule\",\n+                              \"execute task '{}', wait for next schedule\",\n                               task.id());\n-                    return;\n+                    continue;\n                 }\n \n                 // Found suitable server, update task server and server load\n                 assert server.id() != null;\n                 task.server(server.id());\n+                task.status(TaskStatus.SCHEDULED);\n                 this.save(task);\n+\n                 server.load(server.load() + task.load());\n-                this.serverManager().save(server);\n-                LOG.info(\"Schedule task {} to server {}\",\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI1NjgwNA=="}, "originalCommit": {"oid": "795ef8923415fe938de02fc5d3cb5c5f4f7e7a3d"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzUwMjM1OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMzozMDozNlrOGuW02g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMzozMDozNlrOGuW02g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI2MTY1OA==", "bodyText": "move to line 397 and change to:\nId taskServer = task.server();\nassert taskServer != null;\nif (!taskServer.equals(server)) {\n    continue;\n}", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r451261658", "createdAt": "2020-07-08T03:30:36Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "diffHunk": "@@ -377,15 +402,14 @@ private void unlistenChanges() {\n                  * initialized when canceled.\n                  */\n                 this.initTaskCallable(task);\n-                @SuppressWarnings(\"unchecked\")\n-                HugeTask<V> memTask = (HugeTask<V>) this.tasks.get(task.id());\n+                HugeTask<?> memTask = this.tasks.get(task.id());\n                 if (memTask != null) {\n                     task = memTask;\n                 }\n                 Id taskServer = task.server();\n                 if (taskServer != null && taskServer.equals(server)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795ef8923415fe938de02fc5d3cb5c5f4f7e7a3d"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzUyNjc5OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/ServerInfoManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMzo0MzozMVrOGuXCWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMzo0MzozMVrOGuXCWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI2NTExMw==", "bodyText": "remove line 218 due to system tx is auto commit", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r451265113", "createdAt": "2020-07-08T03:43:31Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/ServerInfoManager.java", "diffHunk": "@@ -212,8 +273,8 @@ protected Id save(HugeServerInfo server) {\n         });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795ef8923415fe938de02fc5d3cb5c5f4f7e7a3d"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMzYzMjM4OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNDo0ODoxNFrOGuX_Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNDo0ODoxNFrOGuX_Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI4MDcwNg==", "bodyText": "as a monitor", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r451280706", "createdAt": "2020-07-08T04:48:14Z", "author": {"login": "Linary"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "diffHunk": "@@ -132,7 +137,14 @@ public int taskResultSizeLimit() {\n     private TaskTransaction tx() {\n         // NOTE: only the owner thread can access task tx\n         if (this.taskTx == null) {\n-            synchronized (this) {\n+            /*\n+             * NOTE: don't synchronized(this) due to scheduler thread hold\n+             * this lock through scheduleTasks(), then query tasks and wait\n+             * for db-worker thread after call(), the tx may not be initialized\n+             * but can't catch this lock, then cause dead lock.\n+             * We just use this.eventListener ad a monitor here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795ef8923415fe938de02fc5d3cb5c5f4f7e7a3d"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxODM0MDUzOnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzozODoxMFrOGvFTPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwNzozODoxMFrOGvFTPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAyMzEwMQ==", "bodyText": "move to line 234", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r452023101", "createdAt": "2020-07-09T07:38:10Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "diffHunk": "@@ -200,27 +211,38 @@ private void unlistenChanges() {\n \n     @Override\n     public <V> Future<?> schedule(HugeTask<V> task) {\n-        if (!this.serverManager().master()) {\n-            throw new HugeException(\"The worker can't schedule task\");\n-        }\n         E.checkArgumentNotNull(task, \"Task can't be null\");\n+        this.checkOnMasterNode(\"schedule\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "176c98863adf4918592e1e7d3f0a66c8814ef3cd"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxODQ2MDQ0OnYy", "diffSide": "RIGHT", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwODoxMjo1NlrOGvGd0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxMjowODozOVrOGvOOrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA0MjE5NA==", "bodyText": "else means task is on master, cancel it directly seems more efficient", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r452042194", "createdAt": "2020-07-09T08:12:56Z", "author": {"login": "zhoney"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "diffHunk": "@@ -248,65 +271,109 @@ private void unlistenChanges() {\n     @Override\n     public synchronized <V> void cancel(HugeTask<V> task) {\n         E.checkArgumentNotNull(task, \"Task can't be null\");\n-        if (!this.serverManager().master()) {\n+        this.checkOnMasterNode(\"cancel\");\n+\n+        if (task.completed() || task.cancelling()) {\n             return;\n         }\n-        if (!task.completed()) {\n-            // The task scheduled to workers, waiting for worker cancel\n-            task.status(TaskStatus.CANCELLING);\n+\n+        LOG.info(\"Cancel task '{}' in status {}\", task.id(), task.status());\n+\n+        if (task.server() == null) {\n+            // The task not scheduled to workers, set canceled immediately\n+            assert task.status().code() < TaskStatus.QUEUED.code();\n+            if (task.status(TaskStatus.CANCELLED)) {\n+                this.save(task);\n+                return;\n+            }\n+        } else if (task.status(TaskStatus.CANCELLING)) {\n+            // The task scheduled to workers, let the worker node to cancel\n             this.save(task);\n-            this.remove(task.id());\n+            assert task.server() != null : task;\n+            assert this.serverManager().master();\n+            if (!task.server().equals(this.serverManager().selfServerId())) {\n+                /*\n+                 * Remove task from memory if it's running on worker node,\n+                 * but keep task in memory if it's running on master node.\n+                 * cancel-scheduling will read task from backend store, if\n+                 * removed this instance from memory, there will be two task\n+                 * instances with same id, and can't cancel the real task that\n+                 * is running but removed from memory.\n+                 */\n+                this.remove(task);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "176c98863adf4918592e1e7d3f0a66c8814ef3cd"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE2OTM5MA==", "bodyText": "We assume cancel is not a frequent operation, so it is not optimized", "url": "https://github.com/hugegraph/hugegraph/pull/1079#discussion_r452169390", "createdAt": "2020-07-09T12:08:39Z", "author": {"login": "javeme"}, "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/task/StandardTaskScheduler.java", "diffHunk": "@@ -248,65 +271,109 @@ private void unlistenChanges() {\n     @Override\n     public synchronized <V> void cancel(HugeTask<V> task) {\n         E.checkArgumentNotNull(task, \"Task can't be null\");\n-        if (!this.serverManager().master()) {\n+        this.checkOnMasterNode(\"cancel\");\n+\n+        if (task.completed() || task.cancelling()) {\n             return;\n         }\n-        if (!task.completed()) {\n-            // The task scheduled to workers, waiting for worker cancel\n-            task.status(TaskStatus.CANCELLING);\n+\n+        LOG.info(\"Cancel task '{}' in status {}\", task.id(), task.status());\n+\n+        if (task.server() == null) {\n+            // The task not scheduled to workers, set canceled immediately\n+            assert task.status().code() < TaskStatus.QUEUED.code();\n+            if (task.status(TaskStatus.CANCELLED)) {\n+                this.save(task);\n+                return;\n+            }\n+        } else if (task.status(TaskStatus.CANCELLING)) {\n+            // The task scheduled to workers, let the worker node to cancel\n             this.save(task);\n-            this.remove(task.id());\n+            assert task.server() != null : task;\n+            assert this.serverManager().master();\n+            if (!task.server().equals(this.serverManager().selfServerId())) {\n+                /*\n+                 * Remove task from memory if it's running on worker node,\n+                 * but keep task in memory if it's running on master node.\n+                 * cancel-scheduling will read task from backend store, if\n+                 * removed this instance from memory, there will be two task\n+                 * instances with same id, and can't cancel the real task that\n+                 * is running but removed from memory.\n+                 */\n+                this.remove(task);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA0MjE5NA=="}, "originalCommit": {"oid": "176c98863adf4918592e1e7d3f0a66c8814ef3cd"}, "originalPosition": 184}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1653, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}