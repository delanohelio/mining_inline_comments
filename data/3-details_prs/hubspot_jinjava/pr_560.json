{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzODU2NDQ3", "number": 560, "title": "Implement EagerFromTag and EagerImportTag", "bodyText": "Part of #532\nThis PR finishes the logic for importing with either a from tag or an import tag. Over half the additions here are tests, but the logic is somewhat complex/lengthy so I'll do my best to explain it well.\nEagerImportTag\nThe import tag is mainly used to import macros from another file, but it also supports importing values set from another file. The deferred importing of both macros and values need to be handled. The goal is to make the output from eager execution not depend on any other files. So the data from the imported file needs to be serialised in some way to the output from eager execution if those values are dependent on deferred values.\nImport tags can either use an alias or not. A tag that imports with an alias, like {% import x as y %} stores all the macros and values from x like y.z. Without an alias like {% import x %} would store a macro declared in x, foo(), as simply foo() (as opposed to y.foo()). This is how imports work normally so the output when an import gets deferred needs to be able to populate these alias maps that can be multi-leveled (as there can be multiple levels of importing). This is done by tracking the full import resource alias name so that given 3 files \"file1.jinja\", \"file2.jinja\", \"file3.jinja\" as:\n{% set bar = 1234 %}\n\n{% import 'file1.jinja' as y %}\n\n{% import 'file2.jinja' as x %}\n\nWould result in a context map that looks like: {'x': {'y': {'bar': 1234}}} with the value of bar accessable with: {{ x.y.bar }}\nIf instead, bar depended on a deferred value, the simplified output from executing \"file3.jinja\" would look something like:\n{% set y = {} %}\n{% set bar = deferred %}\n{% do y.update({'bar': bar})\n{% set x = {} %}\n{% do x.update({'y': y}) %}\n\nThis is achieved with a process that I'll briefly describe. When an import tag is executed, I now add an additional meta value on the context: Context.IMPORT_RESOURCE_ALIAS_KEY is the key for the value which marks the full import alias. In the above example, while executing 'file1.jinja', this would be x.y. When executing a set tag, in addition to executing/reconstructing the set tag, a do-update tag is constructed if something depends on a deferred value. When executed during a second pass, this will update the alias map to hold the desired value, while allowing any other tokens that may be deferred in the imported file to be able to execute properly the second time.\nAfter the import file is interpreted, that child context gets integrated with the (parent) context in which the file was imported. If the import was done using an alias, the alias map is copied to the parent context. If it's not done using an alias, then the child bindings are simply copied over. If anything was deferred during the import, then a do-update tag is created that defines the alias map (which is essentially a copy of the child context's bindings) that can be loaded during a second pass.\nAlso, there are macros that get imported. Without an alias, they will get put as global macros, but with an alias, they will get loaded onto the alias map as what I refer to as \"localMacros\". They're called with alias.macro(), like in the normal import tag functionality. See #547 for the deferred macro logic when a macro function also needs to be deferred.\nThe caveat with this approach is that name clashes from deferred values don't get handled properly in one case:\n\nA variable is set on the context before an import.\nA file is imported using an alias.\nWithin that imported file, a variable is declared using the same name, but it depends on a deferred value so it's setting has to be deferred.\nOutside of the imported file, the variable set in step 1 is used, but it is now deferred and will have the value of the variable set in step 3 when run through a second pass.\n\nThis is an extremely niche case and I couldn't think of a way to solve it. I highly doubt there are any real-world usages that this would impact.\nEagerFromTag\nFrom tags are much easier because you explicitly specify which variables or macros to import from the file. The file which is being imported gets executed without anything really special. From tags also allow aliases for individual variables or macros, but these are different as they are simply renaming the variable or macro. In the case where a value needs to be deferred, then a set tag is created that just sets a variable with \"new_name\" to the value of \"old_name\" like: {% set new_name = old_name %}.\nThere is a similar niche case that exists for this logic as well:\n\nA variable (say x) is set on the context before a from tag\nA from tag imports a variable with that same name and calls it something else ({% from file import x as y %})\nWithin the file, the value of x can not be resolved, and it must be a deferred value\nOutside of the imported file, x, but it is now deferred and will have the same value as y when run through a second pass.\n\n\ncc @jboulter @Joeoh this should be the remaining logic that's needed for eager execution to be usable", "createdAt": "2020-12-07T18:14:56Z", "url": "https://github.com/HubSpot/jinjava/pull/560", "merged": true, "mergeCommit": {"oid": "93257ff07b768ebaa5c6adeee06e96d2f45b118d"}, "closed": true, "closedAt": "2020-12-18T16:50:03Z", "author": {"login": "jasmith-hs"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiqYg9gH2gAyNTMzODU2NDQ3OmU2ZjhhMzg0MDBiOGExYWJlYmNkODE4ZmRjMmM5YWRhNmE4YTU3YTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdnaydsAFqTU1NTYzODEyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e6f8a38400b8a1abebcd818fdc2c9ada6a8a57a5", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/e6f8a38400b8a1abebcd818fdc2c9ada6a8a57a5", "committedDate": "2020-12-03T21:53:27Z", "message": "Checkout EagerFromTag and EagerImportTag logic and enable more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f0fe2fd8d58fd928d7ebc5004f97b10be1b1f61", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/1f0fe2fd8d58fd928d7ebc5004f97b10be1b1f61", "committedDate": "2020-12-03T21:53:27Z", "message": "Fix deferred and non-deferred import var logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfbf1e00c15acc1aa6c55ac5109dde63870ddec2", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/bfbf1e00c15acc1aa6c55ac5109dde63870ddec2", "committedDate": "2020-12-03T21:53:27Z", "message": "Fix import logic for multi-layer imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5f3961431bf30eaf9f52e4e5d1489d16bef5fcc", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/f5f3961431bf30eaf9f52e4e5d1489d16bef5fcc", "committedDate": "2020-12-04T20:24:31Z", "message": "Fixing multi layer imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbc39765088351fafc6b028b80b29446ba8ccada", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/dbc39765088351fafc6b028b80b29446ba8ccada", "committedDate": "2020-12-04T20:52:40Z", "message": "Get all tests passing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "181387573ea6d997728dabcc833fec0252fd10c0", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/181387573ea6d997728dabcc833fec0252fd10c0", "committedDate": "2020-12-04T21:26:37Z", "message": "Cleanup import changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c405b785ac0a1b54c64c12da80f68b8920f1edf9", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/c405b785ac0a1b54c64c12da80f68b8920f1edf9", "committedDate": "2020-12-04T23:39:18Z", "message": "Handle imports, but naming collisions aren't perfect"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d54d2dc7a639830a839c6f68072581bb35af12f5", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/d54d2dc7a639830a839c6f68072581bb35af12f5", "committedDate": "2020-12-04T23:46:26Z", "message": "Fix build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b669175117707e1d2a6ee16d1b590a1462faaf1", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/5b669175117707e1d2a6ee16d1b590a1462faaf1", "committedDate": "2020-12-04T23:47:20Z", "message": "Remove unused method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94c7dc53faca8597b52f8dd3d2c884eb2f3a4d03", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/94c7dc53faca8597b52f8dd3d2c884eb2f3a4d03", "committedDate": "2020-12-07T15:15:18Z", "message": "Clean up some methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e05d2385b384f1a909988ebd6b588a37bc8b477", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/6e05d2385b384f1a909988ebd6b588a37bc8b477", "committedDate": "2020-12-07T17:34:00Z", "message": "Simplify set tag logic in import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92f7f742e6d1170a3c8135acae8f15f698d9b96e", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/92f7f742e6d1170a3c8135acae8f15f698d9b96e", "committedDate": "2020-12-10T17:32:30Z", "message": "Merge branch 'master' of github.com:HubSpot/jinjava into eager-from-import-a"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8ab1fbf000b9264019eccf7ce4093ea6ccf246e", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/a8ab1fbf000b9264019eccf7ce4093ea6ccf246e", "committedDate": "2020-12-10T17:34:19Z", "message": "Fix after merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0ODQ1MTI4", "url": "https://github.com/HubSpot/jinjava/pull/560#pullrequestreview-554845128", "createdAt": "2020-12-17T17:50:09Z", "commit": {"oid": "a8ab1fbf000b9264019eccf7ce4093ea6ccf246e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNzo1MDoxMFrOIIBfeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNzo1MDoxMFrOIIBfeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4Mzk2MQ==", "bodyText": "Maybe this should be in the Util?", "url": "https://github.com/HubSpot/jinjava/pull/560#discussion_r545283961", "createdAt": "2020-12-17T17:50:10Z", "author": {"login": "Joeoh"}, "path": "src/main/java/com/hubspot/jinjava/lib/tag/SetTag.java", "diffHunk": "@@ -108,32 +108,37 @@ public String interpret(TagNode tagNode, JinjavaInterpreter interpreter) {\n     String[] varTokens = var.split(\",\");\n \n     try {\n-      executeSet((TagToken) tagNode.getMaster(), interpreter, varTokens, expr);\n+      executeSet((TagToken) tagNode.getMaster(), interpreter, varTokens, expr, false);\n     } catch (DeferredValueException e) {\n-      for (String varToken : varTokens) {\n-        String key = varToken.trim();\n-        Object originalValue = interpreter.getContext().get(key);\n-        if (originalValue != null) {\n-          if (originalValue instanceof DeferredValue) {\n-            interpreter.getContext().put(key, originalValue);\n-          } else {\n-            interpreter.getContext().put(key, DeferredValue.instance(originalValue));\n-          }\n-        } else {\n-          interpreter.getContext().put(key, DeferredValue.instance());\n-        }\n-      }\n+      deferVariables(varTokens, interpreter);\n       throw e;\n     }\n \n     return \"\";\n   }\n \n+  public static void deferVariables(String[] varTokens, JinjavaInterpreter interpreter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8ab1fbf000b9264019eccf7ce4093ea6ccf246e"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e81a41a1057e4a100ac018f5986cf313042e4544", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/e81a41a1057e4a100ac018f5986cf313042e4544", "committedDate": "2020-12-17T18:40:36Z", "message": "Move deferVariables method to DeferredValueUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0aa12d2660a42eb63172eb68a156fc54e3bfecb", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/e0aa12d2660a42eb63172eb68a156fc54e3bfecb", "committedDate": "2020-12-17T18:40:49Z", "message": "Merge branch 'master' of github.com:HubSpot/jinjava into eager-from-import-a"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTAwOTE3", "url": "https://github.com/HubSpot/jinjava/pull/560#pullrequestreview-554900917", "createdAt": "2020-12-17T19:01:18Z", "commit": {"oid": "e0aa12d2660a42eb63172eb68a156fc54e3bfecb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjM4MTIw", "url": "https://github.com/HubSpot/jinjava/pull/560#pullrequestreview-555638120", "createdAt": "2020-12-18T16:32:56Z", "commit": {"oid": "e0aa12d2660a42eb63172eb68a156fc54e3bfecb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2499, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}