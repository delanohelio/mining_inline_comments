{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzMDI3MjIw", "number": 523, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNDoxNFrOEz6KjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo1MDoyNVrOE1uGjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODY1ODA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNDoxNFrOHra_GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNDoxNFrOHra_GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5Mjk1Mw==", "bodyText": "style nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n          \n          \n            \n                for (JinjavaParam jinjavaParam : getNamedArguments().values()) {", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515292953", "createdAt": "2020-10-30T18:14:14Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODY1ODg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNDoyNlrOHra_lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNDoyNlrOHra_lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5MzA3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n          \n          \n            \n                  if (jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515293077", "createdAt": "2020-10-30T18:14:26Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODY1OTcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNDo0MlrOHrbAFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNDo0MlrOHrbAFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5MzIwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {\n          \n          \n            \n                  for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515293204", "createdAt": "2020-10-30T18:14:42Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"MISSING_REQUIRED_ARG\",\n+                String.format(\"Argument named '%s' is required but missing for filter %s\", jinjavaParam.value(), getName())\n+        );\n+      }\n+    }\n+  }\n+\n+  public Map<String, JinjavaParam> getNamedArguments() {\n+    if (isNamedArgumentCheckDone) {\n+      return namedArguments;\n+    }\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      namedArguments = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODY2NTY2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNjoyM1rOHrbDsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNjoyM1rOHrbDsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NDEzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int width = ((Number)parsedArgs.get(\"width\")).intValue();\n          \n          \n            \n                int width = ((Number) parsedArgs.get(\"width\")).intValue();", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515294131", "createdAt": "2020-10-30T18:16:23Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "diffHunk": "@@ -40,24 +41,20 @@\n     )\n   }\n )\n-public class IndentFilter implements Filter {\n+public class IndentFilter extends AbstractFilter {\n \n   @Override\n   public String getName() {\n     return \"indent\";\n   }\n \n   @Override\n-  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n-    int width = 4;\n-    if (args.length > 0) {\n-      width = NumberUtils.toInt(args[0], 4);\n-    }\n+  public Object filter(Object var,\n+                       JinjavaInterpreter interpreter,\n+                       Map<String, Object> parsedArgs) {\n+    int width = ((Number)parsedArgs.get(\"width\")).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODY2NjAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNjozMVrOHrbD6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNjozMVrOHrbD6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NDE4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                boolean indentFirst = (boolean)parsedArgs.get(\"indentfirst\");\n          \n          \n            \n                boolean indentFirst = (boolean) parsedArgs.get(\"indentfirst\");", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515294186", "createdAt": "2020-10-30T18:16:31Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "diffHunk": "@@ -40,24 +41,20 @@\n     )\n   }\n )\n-public class IndentFilter implements Filter {\n+public class IndentFilter extends AbstractFilter {\n \n   @Override\n   public String getName() {\n     return \"indent\";\n   }\n \n   @Override\n-  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n-    int width = 4;\n-    if (args.length > 0) {\n-      width = NumberUtils.toInt(args[0], 4);\n-    }\n+  public Object filter(Object var,\n+                       JinjavaInterpreter interpreter,\n+                       Map<String, Object> parsedArgs) {\n+    int width = ((Number)parsedArgs.get(\"width\")).intValue();\n \n-    boolean indentFirst = false;\n-    if (args.length > 1) {\n-      indentFirst = BooleanUtils.toBoolean(args[1]);\n-    }\n+    boolean indentFirst = (boolean)parsedArgs.get(\"indentfirst\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODY4MzcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoyMjowMVrOHrbOpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoyMjowMVrOHrbOpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NjkzMw==", "bodyText": "You could rewrite this in funcional style with something like\nreturn Optional.ofNullable(getNamedArguments()).map(a -> a.keySet()).filter(argNames -> a.contains(argName)).map(a -> a.indexOf(argName)).orElse(-1);", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515296933", "createdAt": "2020-10-30T18:22:01Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"MISSING_REQUIRED_ARG\",\n+                String.format(\"Argument named '%s' is required but missing for filter %s\", jinjavaParam.value(), getName())\n+        );\n+      }\n+    }\n+  }\n+\n+  public Map<String, JinjavaParam> getNamedArguments() {\n+    if (isNamedArgumentCheckDone) {\n+      return namedArguments;\n+    }\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      namedArguments = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {\n+        namedArguments.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      namedArguments = Collections.unmodifiableMap(namedArguments);\n+    }\n+    isNamedArgumentCheckDone = true;\n+    return namedArguments;\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    getNamedArguments();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODY4NTg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoyMjo0M1rOHrbP9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoyMjo0M1rOHrbP9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NzI3MA==", "bodyText": "same comment as above.", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515297270", "createdAt": "2020-10-30T18:22:43Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"MISSING_REQUIRED_ARG\",\n+                String.format(\"Argument named '%s' is required but missing for filter %s\", jinjavaParam.value(), getName())\n+        );\n+      }\n+    }\n+  }\n+\n+  public Map<String, JinjavaParam> getNamedArguments() {\n+    if (isNamedArgumentCheckDone) {\n+      return namedArguments;\n+    }\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      namedArguments = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {\n+        namedArguments.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      namedArguments = Collections.unmodifiableMap(namedArguments);\n+    }\n+    isNamedArgumentCheckDone = true;\n+    return namedArguments;\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    getNamedArguments();\n+    if (namedArguments != null) {\n+      List<String> argNames = new ArrayList<>(namedArguments.keySet());\n+      return argNames.contains(argName) ? argNames.indexOf(argName) : -1;\n+    }\n+    return -1;\n+  }\n+\n+  public String getIndexedArgumentName(int position) {\n+    getNamedArguments();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODY4ODEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoyMzoyOVrOHrbRew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoyMzoyOVrOHrbRew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NzY1OQ==", "bodyText": "Can you add some more test coverage for this class?", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515297659", "createdAt": "2020-10-30T18:23:29Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzkwMDMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDo0ODowN1rOHsHerw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMjo0NToxNlrOHstKXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyMTkzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n          \n          \n            \n              private final Map<String, JinjavaParam> namedArguments;\n          \n      \n    \n    \n  \n\nbecause it's not static", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516021935", "createdAt": "2020-11-02T14:48:07Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTMyNA==", "bodyText": "Done", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516639324", "createdAt": "2020-11-03T12:45:16Z", "author": {"login": "michaelpro1"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyMTkzNQ=="}, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzkwODYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDo0OTo1NVrOHsHjrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMjo0NToyMlrOHstKlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyMzIxMw==", "bodyText": "Might as well do this in the initializer with a stream() and collect().", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516023213", "createdAt": "2020-11-02T14:49:55Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n+\n+  public AbstractFilter() {\n+    NAMED_ARGUMENTS = initNamedArguments();\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    NAMED_ARGUMENTS.forEach(\n+      (k, v) -> {\n+        if (StringUtils.isNotEmpty(v.defaultValue())) {\n+          namedArgs.put(k, v.defaultValue());\n+        }\n+      }\n+    );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTM4Mg==", "bodyText": "Done", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516639382", "createdAt": "2020-11-03T12:45:22Z", "author": {"login": "michaelpro1"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n+\n+  public AbstractFilter() {\n+    NAMED_ARGUMENTS = initNamedArguments();\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    NAMED_ARGUMENTS.forEach(\n+      (k, v) -> {\n+        if (StringUtils.isNotEmpty(v.defaultValue())) {\n+          namedArgs.put(k, v.defaultValue());\n+        }\n+      }\n+    );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyMzIxMw=="}, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzkxNDk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDo1MToyMVrOHsHntA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMjo0NTo1N1rOHstL2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyNDI0NA==", "bodyText": "Similar comment as above.", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516024244", "createdAt": "2020-11-02T14:51:21Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n+\n+  public AbstractFilter() {\n+    NAMED_ARGUMENTS = initNamedArguments();\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    NAMED_ARGUMENTS.forEach(\n+      (k, v) -> {\n+        if (StringUtils.isNotEmpty(v.defaultValue())) {\n+          namedArgs.put(k, v.defaultValue());\n+        }\n+      }\n+    );\n+    //Process named params\n+    for (Map.Entry<String, Object> passedNamedArgEntry : kwargs.entrySet()) {\n+      String argName = passedNamedArgEntry.getKey();\n+      Object argValue = passedNamedArgEntry.getValue();\n+      int argPosition = getNamedArgumentPosition(argName);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' is invalid for filter %s\",\n+            argName,\n+            getName()\n+          )\n+        );\n+      }\n+      namedArgs.put(argName, argValue);\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach(\n+      (k, v) -> parsedArgs.put(k, parseArg(interpreter, NAMED_ARGUMENTS.get(k), v))\n+    );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTcwNQ==", "bodyText": "These are runtime arguments so can't be initialized at init", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516639705", "createdAt": "2020-11-03T12:45:57Z", "author": {"login": "michaelpro1"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n+\n+  public AbstractFilter() {\n+    NAMED_ARGUMENTS = initNamedArguments();\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    NAMED_ARGUMENTS.forEach(\n+      (k, v) -> {\n+        if (StringUtils.isNotEmpty(v.defaultValue())) {\n+          namedArgs.put(k, v.defaultValue());\n+        }\n+      }\n+    );\n+    //Process named params\n+    for (Map.Entry<String, Object> passedNamedArgEntry : kwargs.entrySet()) {\n+      String argName = passedNamedArgEntry.getKey();\n+      Object argValue = passedNamedArgEntry.getValue();\n+      int argPosition = getNamedArgumentPosition(argName);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' is invalid for filter %s\",\n+            argName,\n+            getName()\n+          )\n+        );\n+      }\n+      namedArgs.put(argName, argValue);\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach(\n+      (k, v) -> parsedArgs.put(k, parseArg(interpreter, NAMED_ARGUMENTS.get(k), v))\n+    );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyNDI0NA=="}, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzkzODA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDo1NjoxMVrOHsH2EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxMjo0NjoyNFrOHstMyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyNzkyMA==", "bodyText": "could you create a static constant for \"indentfirst\" and \"width\"?", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516027920", "createdAt": "2020-11-02T14:56:11Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "diffHunk": "@@ -40,24 +39,22 @@\n     )\n   }\n )\n-public class IndentFilter implements Filter {\n+public class IndentFilter extends AbstractFilter {\n \n   @Override\n   public String getName() {\n     return \"indent\";\n   }\n \n   @Override\n-  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n-    int width = 4;\n-    if (args.length > 0) {\n-      width = NumberUtils.toInt(args[0], 4);\n-    }\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  ) {\n+    int width = ((Number) parsedArgs.get(\"width\")).intValue();\n \n-    boolean indentFirst = false;\n-    if (args.length > 1) {\n-      indentFirst = BooleanUtils.toBoolean(args[1]);\n-    }\n+    boolean indentFirst = (boolean) parsedArgs.get(\"indentfirst\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTk0Nw==", "bodyText": "Done", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516639947", "createdAt": "2020-11-03T12:46:24Z", "author": {"login": "michaelpro1"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "diffHunk": "@@ -40,24 +39,22 @@\n     )\n   }\n )\n-public class IndentFilter implements Filter {\n+public class IndentFilter extends AbstractFilter {\n \n   @Override\n   public String getName() {\n     return \"indent\";\n   }\n \n   @Override\n-  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n-    int width = 4;\n-    if (args.length > 0) {\n-      width = NumberUtils.toInt(args[0], 4);\n-    }\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  ) {\n+    int width = ((Number) parsedArgs.get(\"width\")).intValue();\n \n-    boolean indentFirst = false;\n-    if (args.length > 1) {\n-      indentFirst = BooleanUtils.toBoolean(args[1]);\n-    }\n+    boolean indentFirst = (boolean) parsedArgs.get(\"indentfirst\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyNzkyMA=="}, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzk0MTIyOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDo1Njo1M1rOHsH4DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDo1Njo1M1rOHsH4DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyODQyOQ==", "bodyText": "nice tests, thank you.", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516028429", "createdAt": "2020-11-02T14:56:53Z", "author": {"login": "boulter"}, "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.hubspot.jinjava.lib.filter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hubspot.jinjava.BaseInterpretingTest;\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+public class AbstractFilterTest extends BaseInterpretingTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzk0NDc1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDo1Nzo0OFrOHsH6cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzo1ODoxNFrOHujipQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyOTA0Mw==", "bodyText": "You could use ImmutableMap here for a more fluent interface and less repetition.", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516029043", "createdAt": "2020-11-02T14:57:48Z", "author": {"login": "boulter"}, "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.hubspot.jinjava.lib.filter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hubspot.jinjava.BaseInterpretingTest;\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+public class AbstractFilterTest extends BaseInterpretingTest {\n+  private ArgCapturingFilter filter;\n+\n+  public static class NoJinjavaDocFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itErrorsWhenNoJinjavaDoc() {\n+    assertThatThrownBy(() -> new NoJinjavaDocFilter())\n+      .hasMessageContaining(\"@JinjavaDoc must be configured\");\n+  }\n+\n+  @JinjavaDoc\n+  public static class NoJinjavaParamsFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itDoesNotRequireParams() {\n+    filter = new NoJinjavaParamsFilter();\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(value = \"1st\", desc = \"1st\"),\n+      @JinjavaParam(value = \"2nd\", desc = \"2nd\"),\n+      @JinjavaParam(value = \"3rd\", desc = \"3rd\")\n+    }\n+  )\n+  public static class TwoParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itSupportsMixingOfPositionalAndNamedArgs() {\n+    filter = new TwoParamTypesFilter();\n+\n+    filter.filter(null, interpreter, new Object[] { \"1\" }, ImmutableMap.of(\"3rd\", \"3\"));\n+\n+    assertThat(filter.parsedArgs).isEqualTo(ImmutableMap.of(\"1st\", \"1\", \"3rd\", \"3\"));\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(\n+        value = \"boolean\",\n+        type = \"boolean\",\n+        desc = \"boolean\",\n+        required = true\n+      ),\n+      @JinjavaParam(value = \"int\", type = \"int\", desc = \"int\"),\n+      @JinjavaParam(value = \"long\", type = \"long\", desc = \"long\"),\n+      @JinjavaParam(value = \"float\", type = \"float\", desc = \"float\"),\n+      @JinjavaParam(value = \"double\", type = \"double\", desc = \"double\"),\n+      @JinjavaParam(value = \"number\", type = \"number\", desc = \"number\"),\n+      @JinjavaParam(value = \"object\", type = \"object\", desc = \"object\"),\n+      @JinjavaParam(value = \"dict\", type = \"dict\", desc = \"dict\")\n+    }\n+  )\n+  public static class AllParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itParsesNumericAndBooleanInput() {\n+    filter = new AllParamTypesFilter();\n+\n+    Map<String, Object> kwArgs = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY0MDMzMw==", "bodyText": "Unfortunately ImmutableMap.of has a limit of 5 keys so forced to use this", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516640333", "createdAt": "2020-11-03T12:47:05Z", "author": {"login": "michaelpro1"}, "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.hubspot.jinjava.lib.filter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hubspot.jinjava.BaseInterpretingTest;\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+public class AbstractFilterTest extends BaseInterpretingTest {\n+  private ArgCapturingFilter filter;\n+\n+  public static class NoJinjavaDocFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itErrorsWhenNoJinjavaDoc() {\n+    assertThatThrownBy(() -> new NoJinjavaDocFilter())\n+      .hasMessageContaining(\"@JinjavaDoc must be configured\");\n+  }\n+\n+  @JinjavaDoc\n+  public static class NoJinjavaParamsFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itDoesNotRequireParams() {\n+    filter = new NoJinjavaParamsFilter();\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(value = \"1st\", desc = \"1st\"),\n+      @JinjavaParam(value = \"2nd\", desc = \"2nd\"),\n+      @JinjavaParam(value = \"3rd\", desc = \"3rd\")\n+    }\n+  )\n+  public static class TwoParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itSupportsMixingOfPositionalAndNamedArgs() {\n+    filter = new TwoParamTypesFilter();\n+\n+    filter.filter(null, interpreter, new Object[] { \"1\" }, ImmutableMap.of(\"3rd\", \"3\"));\n+\n+    assertThat(filter.parsedArgs).isEqualTo(ImmutableMap.of(\"1st\", \"1\", \"3rd\", \"3\"));\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(\n+        value = \"boolean\",\n+        type = \"boolean\",\n+        desc = \"boolean\",\n+        required = true\n+      ),\n+      @JinjavaParam(value = \"int\", type = \"int\", desc = \"int\"),\n+      @JinjavaParam(value = \"long\", type = \"long\", desc = \"long\"),\n+      @JinjavaParam(value = \"float\", type = \"float\", desc = \"float\"),\n+      @JinjavaParam(value = \"double\", type = \"double\", desc = \"double\"),\n+      @JinjavaParam(value = \"number\", type = \"number\", desc = \"number\"),\n+      @JinjavaParam(value = \"object\", type = \"object\", desc = \"object\"),\n+      @JinjavaParam(value = \"dict\", type = \"dict\", desc = \"dict\")\n+    }\n+  )\n+  public static class AllParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itParsesNumericAndBooleanInput() {\n+    filter = new AllParamTypesFilter();\n+\n+    Map<String, Object> kwArgs = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyOTA0Mw=="}, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE0Njc2NQ==", "bodyText": "You could use ImmutableMap.builder().", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518146765", "createdAt": "2020-11-05T15:37:45Z", "author": {"login": "boulter"}, "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.hubspot.jinjava.lib.filter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hubspot.jinjava.BaseInterpretingTest;\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+public class AbstractFilterTest extends BaseInterpretingTest {\n+  private ArgCapturingFilter filter;\n+\n+  public static class NoJinjavaDocFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itErrorsWhenNoJinjavaDoc() {\n+    assertThatThrownBy(() -> new NoJinjavaDocFilter())\n+      .hasMessageContaining(\"@JinjavaDoc must be configured\");\n+  }\n+\n+  @JinjavaDoc\n+  public static class NoJinjavaParamsFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itDoesNotRequireParams() {\n+    filter = new NoJinjavaParamsFilter();\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(value = \"1st\", desc = \"1st\"),\n+      @JinjavaParam(value = \"2nd\", desc = \"2nd\"),\n+      @JinjavaParam(value = \"3rd\", desc = \"3rd\")\n+    }\n+  )\n+  public static class TwoParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itSupportsMixingOfPositionalAndNamedArgs() {\n+    filter = new TwoParamTypesFilter();\n+\n+    filter.filter(null, interpreter, new Object[] { \"1\" }, ImmutableMap.of(\"3rd\", \"3\"));\n+\n+    assertThat(filter.parsedArgs).isEqualTo(ImmutableMap.of(\"1st\", \"1\", \"3rd\", \"3\"));\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(\n+        value = \"boolean\",\n+        type = \"boolean\",\n+        desc = \"boolean\",\n+        required = true\n+      ),\n+      @JinjavaParam(value = \"int\", type = \"int\", desc = \"int\"),\n+      @JinjavaParam(value = \"long\", type = \"long\", desc = \"long\"),\n+      @JinjavaParam(value = \"float\", type = \"float\", desc = \"float\"),\n+      @JinjavaParam(value = \"double\", type = \"double\", desc = \"double\"),\n+      @JinjavaParam(value = \"number\", type = \"number\", desc = \"number\"),\n+      @JinjavaParam(value = \"object\", type = \"object\", desc = \"object\"),\n+      @JinjavaParam(value = \"dict\", type = \"dict\", desc = \"dict\")\n+    }\n+  )\n+  public static class AllParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itParsesNumericAndBooleanInput() {\n+    filter = new AllParamTypesFilter();\n+\n+    Map<String, Object> kwArgs = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyOTA0Mw=="}, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3ODg1Mw==", "bodyText": "Done", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518578853", "createdAt": "2020-11-06T07:58:14Z", "author": {"login": "michaelpro1"}, "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.hubspot.jinjava.lib.filter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hubspot.jinjava.BaseInterpretingTest;\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+public class AbstractFilterTest extends BaseInterpretingTest {\n+  private ArgCapturingFilter filter;\n+\n+  public static class NoJinjavaDocFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itErrorsWhenNoJinjavaDoc() {\n+    assertThatThrownBy(() -> new NoJinjavaDocFilter())\n+      .hasMessageContaining(\"@JinjavaDoc must be configured\");\n+  }\n+\n+  @JinjavaDoc\n+  public static class NoJinjavaParamsFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itDoesNotRequireParams() {\n+    filter = new NoJinjavaParamsFilter();\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(value = \"1st\", desc = \"1st\"),\n+      @JinjavaParam(value = \"2nd\", desc = \"2nd\"),\n+      @JinjavaParam(value = \"3rd\", desc = \"3rd\")\n+    }\n+  )\n+  public static class TwoParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itSupportsMixingOfPositionalAndNamedArgs() {\n+    filter = new TwoParamTypesFilter();\n+\n+    filter.filter(null, interpreter, new Object[] { \"1\" }, ImmutableMap.of(\"3rd\", \"3\"));\n+\n+    assertThat(filter.parsedArgs).isEqualTo(ImmutableMap.of(\"1st\", \"1\", \"3rd\", \"3\"));\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(\n+        value = \"boolean\",\n+        type = \"boolean\",\n+        desc = \"boolean\",\n+        required = true\n+      ),\n+      @JinjavaParam(value = \"int\", type = \"int\", desc = \"int\"),\n+      @JinjavaParam(value = \"long\", type = \"long\", desc = \"long\"),\n+      @JinjavaParam(value = \"float\", type = \"float\", desc = \"float\"),\n+      @JinjavaParam(value = \"double\", type = \"double\", desc = \"double\"),\n+      @JinjavaParam(value = \"number\", type = \"number\", desc = \"number\"),\n+      @JinjavaParam(value = \"object\", type = \"object\", desc = \"object\"),\n+      @JinjavaParam(value = \"dict\", type = \"dict\", desc = \"dict\")\n+    }\n+  )\n+  public static class AllParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itParsesNumericAndBooleanInput() {\n+    filter = new AllParamTypesFilter();\n+\n+    Map<String, Object> kwArgs = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyOTA0Mw=="}, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NzYyMzA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo0NDoyMFrOHuJgHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo0NDoyMFrOHuJgHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1MjIyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             Copyright (c) 2014 HubSpot Inc.\n          \n          \n            \n             Copyright (c) 2020 HubSpot Inc.", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518152221", "createdAt": "2020-11-05T15:44:20Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "615e3b1b480e6badb98346cfa6337bab4a0f40a1"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NzY1MzI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo1MDoyNVrOHuJyyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwODowNToyOFrOHujv5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NzAwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, JinjavaParam> namedArgs = new LinkedHashMap<>();\n          \n          \n            \n                  for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {\n          \n          \n            \n                    namedArgs.put(jinjavaParam.value(), jinjavaParam);\n          \n          \n            \n                  }\n          \n          \n            \n                  return Collections.unmodifiableMap(namedArgs);\n          \n          \n            \n            return jinjavaDoc.params().stream().collect(ImmutableMap.toImmutableMap(p -> p.value(), p -> p));", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518157001", "createdAt": "2020-11-05T15:50:25Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private static final Map<Class, Map<String, JinjavaParam>> NAMED_ARGUMENTS_CACHE = new ConcurrentHashMap<>();\n+  private static final Map<Class, Map<String, Object>> DEFAULT_VALUES_CACHE = new ConcurrentHashMap<>();\n+\n+  private final Map<String, JinjavaParam> namedArguments;\n+  private final Map<String, Object> defaultValues;\n+\n+  public AbstractFilter() {\n+    namedArguments =\n+      NAMED_ARGUMENTS_CACHE.computeIfAbsent(getClass(), cls -> initNamedArguments());\n+    defaultValues =\n+      DEFAULT_VALUES_CACHE.computeIfAbsent(getClass(), cls -> initDefaultValues());\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    namedArgs.putAll(defaultValues);\n+\n+    //Process named params\n+    for (Map.Entry<String, Object> passedNamedArgEntry : kwargs.entrySet()) {\n+      String argName = passedNamedArgEntry.getKey();\n+      Object argValue = passedNamedArgEntry.getValue();\n+      int argPosition = getNamedArgumentPosition(argName);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' is invalid for filter %s\",\n+            argName,\n+            getName()\n+          )\n+        );\n+      }\n+      namedArgs.put(argName, argValue);\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach(\n+      (k, v) -> parsedArgs.put(k, parseArg(interpreter, namedArguments.get(k), v))\n+    );\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  protected Object parseArg(\n+    JinjavaInterpreter interpreter,\n+    JinjavaParam jinjavaParamMetadata,\n+    Object value\n+  ) {\n+    if (\n+      jinjavaParamMetadata.type() == null ||\n+      value == null ||\n+      Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())\n+    ) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\":\n+        return value instanceof Boolean\n+          ? (Boolean) value\n+          : BooleanUtils.toBooleanObject(valueString);\n+      case \"int\":\n+        return value instanceof Integer\n+          ? (Integer) value\n+          : NumberUtils.toInt(valueString);\n+      case \"long\":\n+        return value instanceof Long ? (Long) value : NumberUtils.toLong(valueString);\n+      case \"float\":\n+        return value instanceof Float ? (Float) value : NumberUtils.toFloat(valueString);\n+      case \"double\":\n+        return value instanceof Double\n+          ? (Double) value\n+          : NumberUtils.toDouble(valueString);\n+      case \"number\":\n+        return value instanceof Number ? (Number) value : new BigDecimal(valueString);\n+      case \"string\":\n+        return valueString;\n+      default:\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' with value '%s' cannot be parsed for filter %s\",\n+            jinjavaParamMetadata.value(),\n+            value,\n+            getName()\n+          )\n+        );\n+    }\n+  }\n+\n+  public void validateArgs(\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  ) {\n+    for (JinjavaParam jinjavaParam : namedArguments.values()) {\n+      if (jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"MISSING_REQUIRED_ARG\",\n+          String.format(\n+            \"Argument named '%s' is required but missing for filter %s\",\n+            jinjavaParam.value(),\n+            getName()\n+          )\n+        );\n+      }\n+    }\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(argNames -> Optional.of(argNames.indexOf(argName)))\n+      .orElse(-1);\n+  }\n+\n+  public String getIndexedArgumentName(int position) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(\n+        argNames ->\n+          Optional.ofNullable(argNames.size() > position ? argNames.get(position) : null)\n+      )\n+      .orElse(null);\n+  }\n+\n+  public Map<String, JinjavaParam> initNamedArguments() {\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      Map<String, JinjavaParam> namedArgs = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {\n+        namedArgs.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      return Collections.unmodifiableMap(namedArgs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "615e3b1b480e6badb98346cfa6337bab4a0f40a1"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1OTEzOA==", "bodyText": "Note that this won't preserve the order though. If you do need that, you could collect to a LinkedHashMap and then wrap the whole thing in Collections.unmodifiableMap", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518159138", "createdAt": "2020-11-05T15:53:17Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private static final Map<Class, Map<String, JinjavaParam>> NAMED_ARGUMENTS_CACHE = new ConcurrentHashMap<>();\n+  private static final Map<Class, Map<String, Object>> DEFAULT_VALUES_CACHE = new ConcurrentHashMap<>();\n+\n+  private final Map<String, JinjavaParam> namedArguments;\n+  private final Map<String, Object> defaultValues;\n+\n+  public AbstractFilter() {\n+    namedArguments =\n+      NAMED_ARGUMENTS_CACHE.computeIfAbsent(getClass(), cls -> initNamedArguments());\n+    defaultValues =\n+      DEFAULT_VALUES_CACHE.computeIfAbsent(getClass(), cls -> initDefaultValues());\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    namedArgs.putAll(defaultValues);\n+\n+    //Process named params\n+    for (Map.Entry<String, Object> passedNamedArgEntry : kwargs.entrySet()) {\n+      String argName = passedNamedArgEntry.getKey();\n+      Object argValue = passedNamedArgEntry.getValue();\n+      int argPosition = getNamedArgumentPosition(argName);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' is invalid for filter %s\",\n+            argName,\n+            getName()\n+          )\n+        );\n+      }\n+      namedArgs.put(argName, argValue);\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach(\n+      (k, v) -> parsedArgs.put(k, parseArg(interpreter, namedArguments.get(k), v))\n+    );\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  protected Object parseArg(\n+    JinjavaInterpreter interpreter,\n+    JinjavaParam jinjavaParamMetadata,\n+    Object value\n+  ) {\n+    if (\n+      jinjavaParamMetadata.type() == null ||\n+      value == null ||\n+      Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())\n+    ) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\":\n+        return value instanceof Boolean\n+          ? (Boolean) value\n+          : BooleanUtils.toBooleanObject(valueString);\n+      case \"int\":\n+        return value instanceof Integer\n+          ? (Integer) value\n+          : NumberUtils.toInt(valueString);\n+      case \"long\":\n+        return value instanceof Long ? (Long) value : NumberUtils.toLong(valueString);\n+      case \"float\":\n+        return value instanceof Float ? (Float) value : NumberUtils.toFloat(valueString);\n+      case \"double\":\n+        return value instanceof Double\n+          ? (Double) value\n+          : NumberUtils.toDouble(valueString);\n+      case \"number\":\n+        return value instanceof Number ? (Number) value : new BigDecimal(valueString);\n+      case \"string\":\n+        return valueString;\n+      default:\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' with value '%s' cannot be parsed for filter %s\",\n+            jinjavaParamMetadata.value(),\n+            value,\n+            getName()\n+          )\n+        );\n+    }\n+  }\n+\n+  public void validateArgs(\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  ) {\n+    for (JinjavaParam jinjavaParam : namedArguments.values()) {\n+      if (jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"MISSING_REQUIRED_ARG\",\n+          String.format(\n+            \"Argument named '%s' is required but missing for filter %s\",\n+            jinjavaParam.value(),\n+            getName()\n+          )\n+        );\n+      }\n+    }\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(argNames -> Optional.of(argNames.indexOf(argName)))\n+      .orElse(-1);\n+  }\n+\n+  public String getIndexedArgumentName(int position) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(\n+        argNames ->\n+          Optional.ofNullable(argNames.size() > position ? argNames.get(position) : null)\n+      )\n+      .orElse(null);\n+  }\n+\n+  public Map<String, JinjavaParam> initNamedArguments() {\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      Map<String, JinjavaParam> namedArgs = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {\n+        namedArgs.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      return Collections.unmodifiableMap(namedArgs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NzAwMQ=="}, "originalCommit": {"oid": "615e3b1b480e6badb98346cfa6337bab4a0f40a1"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4MjI0NA==", "bodyText": "The order is important, just to be sure I used forEachOrdered with Builder. Default behaviour of ImmutableMap appears to be order of insertion\nBy default, a Builder will generate maps that iterate over entries in the order they were inserted into the builder, equivalently to LinkedHashMap.\n[https://guava.dev/releases/23.0/api/docs/com/google/common/collect/ImmutableMap.Builder.html]", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518582244", "createdAt": "2020-11-06T08:05:28Z", "author": {"login": "michaelpro1"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private static final Map<Class, Map<String, JinjavaParam>> NAMED_ARGUMENTS_CACHE = new ConcurrentHashMap<>();\n+  private static final Map<Class, Map<String, Object>> DEFAULT_VALUES_CACHE = new ConcurrentHashMap<>();\n+\n+  private final Map<String, JinjavaParam> namedArguments;\n+  private final Map<String, Object> defaultValues;\n+\n+  public AbstractFilter() {\n+    namedArguments =\n+      NAMED_ARGUMENTS_CACHE.computeIfAbsent(getClass(), cls -> initNamedArguments());\n+    defaultValues =\n+      DEFAULT_VALUES_CACHE.computeIfAbsent(getClass(), cls -> initDefaultValues());\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    namedArgs.putAll(defaultValues);\n+\n+    //Process named params\n+    for (Map.Entry<String, Object> passedNamedArgEntry : kwargs.entrySet()) {\n+      String argName = passedNamedArgEntry.getKey();\n+      Object argValue = passedNamedArgEntry.getValue();\n+      int argPosition = getNamedArgumentPosition(argName);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' is invalid for filter %s\",\n+            argName,\n+            getName()\n+          )\n+        );\n+      }\n+      namedArgs.put(argName, argValue);\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach(\n+      (k, v) -> parsedArgs.put(k, parseArg(interpreter, namedArguments.get(k), v))\n+    );\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  protected Object parseArg(\n+    JinjavaInterpreter interpreter,\n+    JinjavaParam jinjavaParamMetadata,\n+    Object value\n+  ) {\n+    if (\n+      jinjavaParamMetadata.type() == null ||\n+      value == null ||\n+      Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())\n+    ) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\":\n+        return value instanceof Boolean\n+          ? (Boolean) value\n+          : BooleanUtils.toBooleanObject(valueString);\n+      case \"int\":\n+        return value instanceof Integer\n+          ? (Integer) value\n+          : NumberUtils.toInt(valueString);\n+      case \"long\":\n+        return value instanceof Long ? (Long) value : NumberUtils.toLong(valueString);\n+      case \"float\":\n+        return value instanceof Float ? (Float) value : NumberUtils.toFloat(valueString);\n+      case \"double\":\n+        return value instanceof Double\n+          ? (Double) value\n+          : NumberUtils.toDouble(valueString);\n+      case \"number\":\n+        return value instanceof Number ? (Number) value : new BigDecimal(valueString);\n+      case \"string\":\n+        return valueString;\n+      default:\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' with value '%s' cannot be parsed for filter %s\",\n+            jinjavaParamMetadata.value(),\n+            value,\n+            getName()\n+          )\n+        );\n+    }\n+  }\n+\n+  public void validateArgs(\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  ) {\n+    for (JinjavaParam jinjavaParam : namedArguments.values()) {\n+      if (jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"MISSING_REQUIRED_ARG\",\n+          String.format(\n+            \"Argument named '%s' is required but missing for filter %s\",\n+            jinjavaParam.value(),\n+            getName()\n+          )\n+        );\n+      }\n+    }\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(argNames -> Optional.of(argNames.indexOf(argName)))\n+      .orElse(-1);\n+  }\n+\n+  public String getIndexedArgumentName(int position) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(\n+        argNames ->\n+          Optional.ofNullable(argNames.size() > position ? argNames.get(position) : null)\n+      )\n+      .orElse(null);\n+  }\n+\n+  public Map<String, JinjavaParam> initNamedArguments() {\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      Map<String, JinjavaParam> namedArgs = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {\n+        namedArgs.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      return Collections.unmodifiableMap(namedArgs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NzAwMQ=="}, "originalCommit": {"oid": "615e3b1b480e6badb98346cfa6337bab4a0f40a1"}, "originalPosition": 218}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1731, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}