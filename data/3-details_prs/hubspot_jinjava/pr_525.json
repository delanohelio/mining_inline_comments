{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2MjU4MTM2", "number": 525, "title": "Add ChunkResolver to partially resolve expressions", "bodyText": "Part of #532\nThis PR introduces what I have called the ChunkResolver as a part of my Eager Execution project (draft PR for context).\nPurpose\nThe purpose of the ChunkResolver is to evaluate as much of an expression as possible, generally when there is something deferred within that expression. This is to minimize the number of values, macros, etc. that actually need to be deferred for a second rendering pass. The ChunkResolver will only be used when pre-rendering and will not be enabled by default. It will only be used when a future eagerExecutionEnabled flag is set to true.\nWhen a value is deferred, or something cannot be resolved because it directly depends on a deferred value (e.g. as range(0, deferred)), all the non-reserved words get added to the ChunkResolver's deferredWords. In that former example, getDeferredWords() would then return a list: [\"range\", \"deferred\"]. Clearly, for a second pass this expression would be resolvable once the deferred value gets resolved because the range function would likely exist in the second-pass-jinjava instance, but if it were a function such as hubdb_table_rows, that may prevent running a second pass if the second jinjava instance can't evaluate that function.\nSay, however, we're resolving an expression like:\n{% if hubdb_table_row(table_id, row_id).company == contact.company %}\n\nand contact is deferred (table_id, row_id are known).\nWithout the ChunkResolver, the expression within the if tag would be simply reconstructed in the output, and a dependency on hubdb_table_row would remain (but also there wouldn't be any indication that it does remain). Output:\n{% if hubdb_table_row(table_id, row_id).company == contact.company %}\n\nUsing the ChunkResolver, the expression could be resolved in chunks. The table_id and row_id get resolved to their values and then hubdb_table_row(1234, 56789).company can get resolved to 'HubSpot', for example. contact.company is then deferred, and the output is:\n{% if 'HubSpot' == contact.company %}\n\nAnd chunkResolver.getDeferredWords() is: [\"contact.company\"].\n\nIn the case that a value gets resolved as something like a Map, then it gets output in JSON, which can be read in by a Jinjava interpreter on the second pass. (Dates need their own serialization override so that they are formatted correctly and also don't use the thread-unsafe SimpleDateFormat that's built into Jackson.)\nFor example, if foobar is a map where foobar.foo='FooSpot', foobar.bar='HubBar' then the ChunkResolver would resolve deferred == foobar as deferred == {'foo':'FooSpot','bar':'HubBar'}\nLogic\nThe ChunkResolver gets its name by evaluating expressions in \"chunks\". It also uses \"mini-chunks\" and \"tokens\".\nTokens are words that are continuous strings made of letters, digits, underscores, and periods. (foo, foo_bar, baz99.zap, etc).\nMini-chunks are multiple tokens concatenated by their splitters ( , |, :, etc.). Mini-chunks are broken up by commas. Some examples of mini-chunks are (0, 19 || deferred, 1 + 2 + 3, 'foo' + 'bar')\nChunks are grouped by (), [], or {} so in range(0, deferred + 1), 0, deferred + 1 is a chunk.\nChunks are resolved recursively because there can be nested chunks with many layers of brackets/parentheses. Tokens are either retraced to variables or resolved as expressions, and chunks/mini-chunks are resolved as expressions. If they cannot be resolved, then they get deferred.\n\nNote that because the ChunkResolver resolves expressions in small pieces, interpreter errors are often encountered as, for example = by itself is not a valid expression. A flag is added to the context when the chunk resolver is resolving the expression to prevent errors from being unnecessarily added to the interpreter.\nFeel free to make any suggestions for this class or new test cases to add.", "createdAt": "2020-11-05T18:30:09Z", "url": "https://github.com/HubSpot/jinjava/pull/525", "merged": true, "mergeCommit": {"oid": "98085156a875f2a91b22936d7a8a959f0522f9dd"}, "closed": true, "closedAt": "2020-11-17T17:10:34Z", "author": {"login": "jasmith-hs"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZjjqFAH2gAyNTE2MjU4MTM2OmQwYjEzNjA2OWE3NmM3ZTExZjkyZDVjMmZjYTUwYTk4MTBkNWI2YmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABddct7mgH2gAyNTE2MjU4MTM2OmFkNGI5MjJhNjA4N2ZiMjdiZjFlMGE1MjYwOTA2Mjk2ZDFmNGE1Mjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d0b136069a76c7e11f92d5c2fca50a9810d5b6bb", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/d0b136069a76c7e11f92d5c2fca50a9810d5b6bb", "committedDate": "2020-11-05T14:50:58Z", "message": "Checkout ChunkResolver from eager-execution-a branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09803ac538070002e4ab656c6b6095871cd6b47c", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/09803ac538070002e4ab656c6b6095871cd6b47c", "committedDate": "2020-11-05T15:40:55Z", "message": "Add pyish date serializer to json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac5a8a1b54d08e49cfc6e507f4b4d4325481311b", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/ac5a8a1b54d08e49cfc6e507f4b4d4325481311b", "committedDate": "2020-11-05T15:44:09Z", "message": "Add hideInterpreterErrors flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccd1501a7791fd0d841594f8b9cedf5a94aa2f48", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/ccd1501a7791fd0d841594f8b9cedf5a94aa2f48", "committedDate": "2020-11-05T15:44:19Z", "message": "Add dict resolve test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c309fdb51e441575e910c47d9c03e2ac12f6a68f", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/c309fdb51e441575e910c47d9c03e2ac12f6a68f", "committedDate": "2020-11-05T18:10:27Z", "message": "Remove unnecessary useMiniChunks flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "560961dfada0a6c5cabf82506c2e9236cb93faa0", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/560961dfada0a6c5cabf82506c2e9236cb93faa0", "committedDate": "2020-11-05T18:20:49Z", "message": "Add date serialization test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50063a2af4499e41e92567427baac84cdaec8185", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/50063a2af4499e41e92567427baac84cdaec8185", "committedDate": "2020-11-05T18:23:02Z", "message": "Remove incorrectly dated license"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d50717be34f8879ad0ad78c7fbc65d015d6855f", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/3d50717be34f8879ad0ad78c7fbc65d015d6855f", "committedDate": "2020-11-05T18:27:41Z", "message": "Update comment for splitChunks()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NjMzNzc0", "url": "https://github.com/HubSpot/jinjava/pull/525#pullrequestreview-524633774", "createdAt": "2020-11-05T20:17:57Z", "commit": {"oid": "3d50717be34f8879ad0ad78c7fbc65d015d6855f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDoxNzo1N1rOHuU6Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDoyMDozMlrOHuU_eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzOTEyMg==", "bodyText": "can you reference constants from the tags themselves here?", "url": "https://github.com/HubSpot/jinjava/pull/525#discussion_r518339122", "createdAt": "2020-11-05T20:17:57Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/util/ChunkResolver.java", "diffHunk": "@@ -0,0 +1,355 @@\n+package com.hubspot.jinjava.util;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.hubspot.jinjava.interpret.DeferredValueException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import com.hubspot.jinjava.interpret.UnknownTokenException;\n+import com.hubspot.jinjava.objects.date.JsonPyishDateSerializer;\n+import com.hubspot.jinjava.objects.date.PyishDate;\n+import com.hubspot.jinjava.tree.parse.Token;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.StringUtils;\n+\n+/**\n+ * This class takes a string and resolves it in chunks. This allows for\n+ * strings with deferred values within them to be partially resolved, as much\n+ * as they can be with a deferred value.\n+ * E.g with foo=3, bar=2:\n+ *   \"range(0,foo)[-1] + deferred/bar\" -> \"2 + deferred/2\"\n+ * This class is not thread-safe. Do not reuse between threads.\n+ */\n+public class ChunkResolver {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\n+  .registerModule(\n+      new SimpleModule().addSerializer(PyishDate.class, new JsonPyishDateSerializer())\n+    );\n+\n+  private static final Set<String> RESERVED_KEYWORDS = ImmutableSet.of(\n+    \"and\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d50717be34f8879ad0ad78c7fbc65d015d6855f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM0MDQ3Mw==", "bodyText": "what do these do?", "url": "https://github.com/HubSpot/jinjava/pull/525#discussion_r518340473", "createdAt": "2020-11-05T20:20:32Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/util/ChunkResolver.java", "diffHunk": "@@ -0,0 +1,355 @@\n+package com.hubspot.jinjava.util;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.hubspot.jinjava.interpret.DeferredValueException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import com.hubspot.jinjava.interpret.UnknownTokenException;\n+import com.hubspot.jinjava.objects.date.JsonPyishDateSerializer;\n+import com.hubspot.jinjava.objects.date.PyishDate;\n+import com.hubspot.jinjava.tree.parse.Token;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.StringUtils;\n+\n+/**\n+ * This class takes a string and resolves it in chunks. This allows for\n+ * strings with deferred values within them to be partially resolved, as much\n+ * as they can be with a deferred value.\n+ * E.g with foo=3, bar=2:\n+ *   \"range(0,foo)[-1] + deferred/bar\" -> \"2 + deferred/2\"\n+ * This class is not thread-safe. Do not reuse between threads.\n+ */\n+public class ChunkResolver {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\n+  .registerModule(\n+      new SimpleModule().addSerializer(PyishDate.class, new JsonPyishDateSerializer())\n+    );\n+\n+  private static final Set<String> RESERVED_KEYWORDS = ImmutableSet.of(\n+    \"and\",\n+    \"block\",\n+    \"cycle\",\n+    \"elif\",\n+    \"else\",\n+    \"endblock\",\n+    \"endfilter\",\n+    \"endfor\",\n+    \"endif\",\n+    \"endmacro\",\n+    \"endraw\",\n+    \"endtrans\",\n+    \"extends\",\n+    \"filter\",\n+    \"for\",\n+    \"if\",\n+    \"in\",\n+    \"include\",\n+    \"is\",\n+    \"macro\",\n+    \"not\",\n+    \"or\",\n+    \"pluralize\",\n+    \"print\",\n+    \"raw\",\n+    \"recursive\",\n+    \"set\",\n+    \"trans\",\n+    \"call\",\n+    \"endcall\",\n+    \"__macros__\"\n+  );\n+\n+  // ( -> )\n+  // { -> }\n+  // [ -> ]\n+  private static final Map<Character, Character> CHUNK_LEVEL_MARKER_MAP = ImmutableMap.of(\n+    '(',\n+    ')',\n+    '{',\n+    '}',\n+    '[',\n+    ']'\n+  );\n+\n+  private final char[] value;\n+  private final int length;\n+  private final Token token;\n+  private final JinjavaInterpreter interpreter;\n+  private final Set<String> deferredWords;\n+\n+  private int nextPos = 0;\n+  private char prevChar = 0;\n+  private boolean inQuote = false;\n+  private char quoteChar = 0;\n+\n+  public ChunkResolver(String s, Token token, JinjavaInterpreter interpreter) {\n+    value = s.toCharArray();\n+    length = value.length;\n+    this.token = token;\n+    this.interpreter = interpreter;\n+    deferredWords = new HashSet<>();\n+  }\n+\n+  /**\n+   * @return Any deferred words that were encountered.\n+   */\n+  public Set<String> getDeferredWords() {\n+    return deferredWords;\n+  }\n+\n+  /**\n+   * Chunkify and resolve variables and expressions within the string.\n+   * Tokens are resolved within \"chunks\" where a chunk is surrounded by a markers\n+   * of {}, [], (). The contents inside of a chunk are split by whitespace\n+   * and/or comma, and these \"tokens\" resolved individually.\n+   *\n+   * The main chunk itself does not get resolved.\n+   * e.g.\n+   *  `false || (foo), 'bar'` -> `true, 'bar'`\n+   *  `[(foo == bar), deferred, bar]` -> `[true,deferred,'hello']`\n+   * @return String with chunk layers within it being partially or fully resolved.\n+   */\n+  public String resolveChunks() {\n+    nextPos = 0;\n+    boolean isHideInterpreterErrorsStart = interpreter\n+      .getContext()\n+      .isHideInterpreterErrors();\n+    try {\n+      interpreter.getContext().setHideInterpreterErrors(true);\n+      return String.join(\"\", getChunk(null));\n+    } finally {\n+      interpreter.getContext().setHideInterpreterErrors(isHideInterpreterErrorsStart);\n+    }\n+  }\n+\n+  /**\n+   * Chunkify and resolve variables and expressions within the string.\n+   * Rather than concatenating the chunks, they are split by mini-chunks,\n+   * with the comma splitter ommitted from the list of results.\n+   * Therefore an expression of \"1, 1 + 1, 1 + range(deferred)\" becomes a List of [\"1\", \"2\", \"1 + range(deferred)\"].\n+   *\n+   * @return List of the expression chunk which is split into mini-chunks.\n+   */\n+  public List<String> splitChunks() {\n+    nextPos = 0;\n+    boolean isHideInterpreterErrorsStart = interpreter\n+      .getContext()\n+      .isHideInterpreterErrors();\n+    try {\n+      interpreter.getContext().setHideInterpreterErrors(true);\n+      List<String> miniChunks = getChunk(null);\n+      return miniChunks\n+        .stream()\n+        .filter(s -> s.length() > 1 || !isMiniChunkSplitter(s.charAt(0)))\n+        .collect(Collectors.toList());\n+    } finally {\n+      interpreter.getContext().setHideInterpreterErrors(isHideInterpreterErrorsStart);\n+    }\n+  }\n+\n+  /**\n+   *  e.g. `[0, foo + bar]`:\n+   *     `0, foo + bar` is a chunk\n+   *     `0` and `foo + bar` are mini chunks\n+   *     `0`, `,`, ` `, `foo`, ` `, `+`, ` `, and `bar` are the tokens\n+   * @param chunkLevelMarker the marker `(`, `[`, `{` that started this chunk\n+   * @return the resolved chunk\n+   */\n+  private List<String> getChunk(Character chunkLevelMarker) {\n+    List<String> chunks = new ArrayList<>();\n+    // Mini chunks are split by commas.\n+    StringBuilder miniChunkBuilder = new StringBuilder();\n+    StringBuilder tokenBuilder = new StringBuilder();\n+    while (nextPos < length) {\n+      char c = value[nextPos++];\n+      if (inQuote) {\n+        if (c == quoteChar && prevChar != '\\\\') {\n+          inQuote = false;\n+        }\n+      } else if ((c == '\\'' || c == '\"') && prevChar != '\\\\') {\n+        inQuote = true;\n+        quoteChar = c;\n+      } else if (\n+        chunkLevelMarker != null && CHUNK_LEVEL_MARKER_MAP.get(chunkLevelMarker) == c\n+      ) {\n+        prevChar = c;\n+        break;\n+      } else if (CHUNK_LEVEL_MARKER_MAP.containsKey(c)) {\n+        prevChar = c;\n+        tokenBuilder.append(c);\n+        tokenBuilder.append(resolveChunk(String.join(\"\", getChunk(c))));\n+        tokenBuilder.append(prevChar);\n+        continue;\n+      } else if (isTokenSplitter(c)) {\n+        prevChar = c;\n+\n+        miniChunkBuilder.append(resolveToken(tokenBuilder.toString()));\n+        tokenBuilder = new StringBuilder();\n+        if (isMiniChunkSplitter(c)) {\n+          chunks.add(resolveChunk(miniChunkBuilder.toString()));\n+          chunks.add(String.valueOf(c));\n+          miniChunkBuilder = new StringBuilder();\n+        } else {\n+          miniChunkBuilder.append(c);\n+        }\n+        continue;\n+      }\n+      prevChar = c;\n+      tokenBuilder.append(c);\n+    }\n+    miniChunkBuilder.append(resolveToken(tokenBuilder.toString()));\n+    chunks.add(resolveChunk(miniChunkBuilder.toString()));\n+    return chunks;\n+  }\n+\n+  private boolean isTokenSplitter(char c) {\n+    return (!Character.isLetterOrDigit(c) && c != '_' && c != '.');\n+  }\n+\n+  private boolean isMiniChunkSplitter(char c) {\n+    return c == ',';\n+  }\n+\n+  private String resolveToken(String token) {\n+    if (StringUtils.isBlank(token)) {\n+      return \"\";\n+    }\n+    try {\n+      String resolvedToken;\n+      if (WhitespaceUtils.isQuoted(token) || RESERVED_KEYWORDS.contains(token)) {\n+        resolvedToken = token;\n+      } else {\n+        Object val = interpreter.retraceVariable(\n+          token,\n+          this.token.getLineNumber(),\n+          this.token.getStartPosition()\n+        );\n+        if (val == null) {\n+          try {\n+            val = interpreter.resolveELExpression(token, this.token.getLineNumber());\n+          } catch (UnknownTokenException e) {\n+            // val is still null\n+          }\n+        }\n+        if (val == null) {\n+          resolvedToken = token;\n+        } else {\n+          resolvedToken = getValueAsJinjavaString(val);\n+        }\n+      }\n+      return resolvedToken.trim();\n+    } catch (DeferredValueException | JsonProcessingException e) {\n+      deferredWords.addAll(findDeferredWords(token));\n+      return token.trim();\n+    }\n+  }\n+\n+  // Try resolving the chunk/mini chunk as an ELExpression\n+  private String resolveChunk(String chunk) {\n+    if (StringUtils.isBlank(chunk)) {\n+      return \"\";\n+    } else if (RESERVED_KEYWORDS.contains(chunk)) {\n+      return chunk;\n+    }\n+    try {\n+      String resolvedChunk;\n+      Object val = interpreter.resolveELExpression(chunk, token.getLineNumber());\n+      if (val == null) {\n+        resolvedChunk = chunk;\n+      } else {\n+        resolvedChunk = getValueAsJinjavaString(val);\n+      }\n+      return resolvedChunk.trim();\n+    } catch (Exception e) {\n+      deferredWords.addAll(findDeferredWords(chunk));\n+      return chunk.trim();\n+    }\n+  }\n+\n+  public static String getValueAsJinjavaString(Object val)\n+    throws JsonProcessingException {\n+    return OBJECT_MAPPER\n+      .writeValueAsString(val)\n+      .replaceAll(\"(?<!\\\\\\\\)(?:\\\\\\\\\\\\\\\\)*(\\\\\\\\n)\", \"\\n\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d50717be34f8879ad0ad78c7fbc65d015d6855f"}, "originalPosition": 282}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83a4ab649314e1000bc85560f61449c47ee4a2c3", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/83a4ab649314e1000bc85560f61449c47ee4a2c3", "committedDate": "2020-11-06T18:37:53Z", "message": "Comment regex replaceAll"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7b256e381972bc10338ecb741d6f97168098e4e", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/a7b256e381972bc10338ecb741d6f97168098e4e", "committedDate": "2020-11-13T21:20:14Z", "message": "Remove unnecessary reserved words"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTU0MTUw", "url": "https://github.com/HubSpot/jinjava/pull/525#pullrequestreview-532554150", "createdAt": "2020-11-17T16:29:16Z", "commit": {"oid": "a7b256e381972bc10338ecb741d6f97168098e4e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNjoyOToxNlrOH091Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNjoyOToxNlrOH091Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMwMTA1OA==", "bodyText": "even though this is a boolean, it would probably be more readable with a get instead of is", "url": "https://github.com/HubSpot/jinjava/pull/525#discussion_r525301058", "createdAt": "2020-11-17T16:29:16Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/interpret/Context.java", "diffHunk": "@@ -526,4 +527,12 @@ public void addDependencies(SetMultimap<String, String> dependencies) {\n   public SetMultimap<String, String> getDependencies() {\n     return this.dependencies;\n   }\n+\n+  public boolean isHideInterpreterErrors() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7b256e381972bc10338ecb741d6f97168098e4e"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad4b922a6087fb27bf1e0a5260906296d1f4a528", "author": {"user": {"login": "jasmith-hs", "name": "Jack Smith"}}, "url": "https://github.com/HubSpot/jinjava/commit/ad4b922a6087fb27bf1e0a5260906296d1f4a528", "committedDate": "2020-11-17T17:08:33Z", "message": "Change isHide to getHide"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1551, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}