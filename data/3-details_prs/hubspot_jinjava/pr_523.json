{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzMDI3MjIw", "number": 523, "title": "Python Booleans and Filter base with parsing", "bodyText": "This change includes the following\n\nSupport of python style booleans for portability of templates - True and False are added into ExtendedParser\nAbstractFilter that can be used for simpler filters which works by introspecting Jinjavadoc.params section with some automatic conversions", "createdAt": "2020-10-30T14:01:10Z", "url": "https://github.com/HubSpot/jinjava/pull/523", "merged": true, "mergeCommit": {"oid": "8de83d1a0e5e767f7a8d35d7773dac231135b058"}, "closed": true, "closedAt": "2020-11-09T16:07:44Z", "author": {"login": "michaelpro1"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXlGTeAH2gAyNTEzMDI3MjIwOjczYzhkNzhiODk3NmNjMTI5NWVjMGQ1NGQ0Yzg1NTYzMWI3ZTVjNzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABda2_twAFqTUyNjQwNjc0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "73c8d78b8976cc1295ec0d54d4c855631b7e5c76", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/73c8d78b8976cc1295ec0d54d4c855631b7e5c76", "committedDate": "2020-10-30T11:30:52Z", "message": "toyaml/fromyaml filters, almost the same as tojson/fromjson using jackson"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faf57d9b1575e08a0ca54c9a2ff0f419c6646ff8", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/faf57d9b1575e08a0ca54c9a2ff0f419c6646ff8", "committedDate": "2020-10-30T11:31:50Z", "message": "Py-style booleans support True|False"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/859f87d28f95d66c55c7bf146336cda61e9c2cbe", "committedDate": "2020-10-30T13:51:46Z", "message": "AbstractFilter implementation that uses Jinjavadoc to create parameters with name and automatic parsing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwOTIzNzM1", "url": "https://github.com/HubSpot/jinjava/pull/523#pullrequestreview-520923735", "createdAt": "2020-10-30T18:14:14Z", "commit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoxNDoxNFrOHra_GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoyMzoyOVrOHrbRew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5Mjk1Mw==", "bodyText": "style nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n          \n          \n            \n                for (JinjavaParam jinjavaParam : getNamedArguments().values()) {", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515292953", "createdAt": "2020-10-30T18:14:14Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5MzA3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n          \n          \n            \n                  if (jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515293077", "createdAt": "2020-10-30T18:14:26Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5MzIwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {\n          \n          \n            \n                  for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515293204", "createdAt": "2020-10-30T18:14:42Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"MISSING_REQUIRED_ARG\",\n+                String.format(\"Argument named '%s' is required but missing for filter %s\", jinjavaParam.value(), getName())\n+        );\n+      }\n+    }\n+  }\n+\n+  public Map<String, JinjavaParam> getNamedArguments() {\n+    if (isNamedArgumentCheckDone) {\n+      return namedArguments;\n+    }\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      namedArguments = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NDEzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int width = ((Number)parsedArgs.get(\"width\")).intValue();\n          \n          \n            \n                int width = ((Number) parsedArgs.get(\"width\")).intValue();", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515294131", "createdAt": "2020-10-30T18:16:23Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "diffHunk": "@@ -40,24 +41,20 @@\n     )\n   }\n )\n-public class IndentFilter implements Filter {\n+public class IndentFilter extends AbstractFilter {\n \n   @Override\n   public String getName() {\n     return \"indent\";\n   }\n \n   @Override\n-  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n-    int width = 4;\n-    if (args.length > 0) {\n-      width = NumberUtils.toInt(args[0], 4);\n-    }\n+  public Object filter(Object var,\n+                       JinjavaInterpreter interpreter,\n+                       Map<String, Object> parsedArgs) {\n+    int width = ((Number)parsedArgs.get(\"width\")).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NDE4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                boolean indentFirst = (boolean)parsedArgs.get(\"indentfirst\");\n          \n          \n            \n                boolean indentFirst = (boolean) parsedArgs.get(\"indentfirst\");", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515294186", "createdAt": "2020-10-30T18:16:31Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "diffHunk": "@@ -40,24 +41,20 @@\n     )\n   }\n )\n-public class IndentFilter implements Filter {\n+public class IndentFilter extends AbstractFilter {\n \n   @Override\n   public String getName() {\n     return \"indent\";\n   }\n \n   @Override\n-  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n-    int width = 4;\n-    if (args.length > 0) {\n-      width = NumberUtils.toInt(args[0], 4);\n-    }\n+  public Object filter(Object var,\n+                       JinjavaInterpreter interpreter,\n+                       Map<String, Object> parsedArgs) {\n+    int width = ((Number)parsedArgs.get(\"width\")).intValue();\n \n-    boolean indentFirst = false;\n-    if (args.length > 1) {\n-      indentFirst = BooleanUtils.toBoolean(args[1]);\n-    }\n+    boolean indentFirst = (boolean)parsedArgs.get(\"indentfirst\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NjkzMw==", "bodyText": "You could rewrite this in funcional style with something like\nreturn Optional.ofNullable(getNamedArguments()).map(a -> a.keySet()).filter(argNames -> a.contains(argName)).map(a -> a.indexOf(argName)).orElse(-1);", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515296933", "createdAt": "2020-10-30T18:22:01Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"MISSING_REQUIRED_ARG\",\n+                String.format(\"Argument named '%s' is required but missing for filter %s\", jinjavaParam.value(), getName())\n+        );\n+      }\n+    }\n+  }\n+\n+  public Map<String, JinjavaParam> getNamedArguments() {\n+    if (isNamedArgumentCheckDone) {\n+      return namedArguments;\n+    }\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      namedArguments = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {\n+        namedArguments.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      namedArguments = Collections.unmodifiableMap(namedArguments);\n+    }\n+    isNamedArgumentCheckDone = true;\n+    return namedArguments;\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    getNamedArguments();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NzI3MA==", "bodyText": "same comment as above.", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515297270", "createdAt": "2020-10-30T18:22:43Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"MISSING_REQUIRED_ARG\",\n+                String.format(\"Argument named '%s' is required but missing for filter %s\", jinjavaParam.value(), getName())\n+        );\n+      }\n+    }\n+  }\n+\n+  public Map<String, JinjavaParam> getNamedArguments() {\n+    if (isNamedArgumentCheckDone) {\n+      return namedArguments;\n+    }\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      namedArguments = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {\n+        namedArguments.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      namedArguments = Collections.unmodifiableMap(namedArguments);\n+    }\n+    isNamedArgumentCheckDone = true;\n+    return namedArguments;\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    getNamedArguments();\n+    if (namedArguments != null) {\n+      List<String> argNames = new ArrayList<>(namedArguments.keySet());\n+      return argNames.contains(argName) ? argNames.indexOf(argName) : -1;\n+    }\n+    return -1;\n+  }\n+\n+  public String getIndexedArgumentName(int position) {\n+    getNamedArguments();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NzY1OQ==", "bodyText": "Can you add some more test coverage for this class?", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515297659", "createdAt": "2020-10-30T18:23:29Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a375e70c387dfbcc24ae1720da6c3e5275f17fdc", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/a375e70c387dfbcc24ae1720da6c3e5275f17fdc", "committedDate": "2020-10-31T07:54:00Z", "message": "style, checkstyle, findbugs fixes per comments. coverage tests for AbstractFilter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cf9f579bffe782c2366d18dc9a5b446b47b4b66", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/3cf9f579bffe782c2366d18dc9a5b446b47b4b66", "committedDate": "2020-10-31T07:59:12Z", "message": "removed yaml filters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/653a0eb3796781854acea4ebab2cf5e2b5b9370d", "committedDate": "2020-10-31T12:51:03Z", "message": "automatic java prettifier"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNjk0OTg4", "url": "https://github.com/HubSpot/jinjava/pull/523#pullrequestreview-521694988", "createdAt": "2020-11-02T14:48:07Z", "commit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDo0ODowN1rOHsHerw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDo1Nzo0OFrOHsH6cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyMTkzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n          \n          \n            \n              private final Map<String, JinjavaParam> namedArguments;\n          \n      \n    \n    \n  \n\nbecause it's not static", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516021935", "createdAt": "2020-11-02T14:48:07Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyMzIxMw==", "bodyText": "Might as well do this in the initializer with a stream() and collect().", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516023213", "createdAt": "2020-11-02T14:49:55Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n+\n+  public AbstractFilter() {\n+    NAMED_ARGUMENTS = initNamedArguments();\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    NAMED_ARGUMENTS.forEach(\n+      (k, v) -> {\n+        if (StringUtils.isNotEmpty(v.defaultValue())) {\n+          namedArgs.put(k, v.defaultValue());\n+        }\n+      }\n+    );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyNDI0NA==", "bodyText": "Similar comment as above.", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516024244", "createdAt": "2020-11-02T14:51:21Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n+\n+  public AbstractFilter() {\n+    NAMED_ARGUMENTS = initNamedArguments();\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    NAMED_ARGUMENTS.forEach(\n+      (k, v) -> {\n+        if (StringUtils.isNotEmpty(v.defaultValue())) {\n+          namedArgs.put(k, v.defaultValue());\n+        }\n+      }\n+    );\n+    //Process named params\n+    for (Map.Entry<String, Object> passedNamedArgEntry : kwargs.entrySet()) {\n+      String argName = passedNamedArgEntry.getKey();\n+      Object argValue = passedNamedArgEntry.getValue();\n+      int argPosition = getNamedArgumentPosition(argName);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' is invalid for filter %s\",\n+            argName,\n+            getName()\n+          )\n+        );\n+      }\n+      namedArgs.put(argName, argValue);\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach(\n+      (k, v) -> parsedArgs.put(k, parseArg(interpreter, NAMED_ARGUMENTS.get(k), v))\n+    );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyNzkyMA==", "bodyText": "could you create a static constant for \"indentfirst\" and \"width\"?", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516027920", "createdAt": "2020-11-02T14:56:11Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "diffHunk": "@@ -40,24 +39,22 @@\n     )\n   }\n )\n-public class IndentFilter implements Filter {\n+public class IndentFilter extends AbstractFilter {\n \n   @Override\n   public String getName() {\n     return \"indent\";\n   }\n \n   @Override\n-  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n-    int width = 4;\n-    if (args.length > 0) {\n-      width = NumberUtils.toInt(args[0], 4);\n-    }\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  ) {\n+    int width = ((Number) parsedArgs.get(\"width\")).intValue();\n \n-    boolean indentFirst = false;\n-    if (args.length > 1) {\n-      indentFirst = BooleanUtils.toBoolean(args[1]);\n-    }\n+    boolean indentFirst = (boolean) parsedArgs.get(\"indentfirst\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyODQyOQ==", "bodyText": "nice tests, thank you.", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516028429", "createdAt": "2020-11-02T14:56:53Z", "author": {"login": "boulter"}, "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.hubspot.jinjava.lib.filter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hubspot.jinjava.BaseInterpretingTest;\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+public class AbstractFilterTest extends BaseInterpretingTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyOTA0Mw==", "bodyText": "You could use ImmutableMap here for a more fluent interface and less repetition.", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516029043", "createdAt": "2020-11-02T14:57:48Z", "author": {"login": "boulter"}, "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.hubspot.jinjava.lib.filter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hubspot.jinjava.BaseInterpretingTest;\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+public class AbstractFilterTest extends BaseInterpretingTest {\n+  private ArgCapturingFilter filter;\n+\n+  public static class NoJinjavaDocFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itErrorsWhenNoJinjavaDoc() {\n+    assertThatThrownBy(() -> new NoJinjavaDocFilter())\n+      .hasMessageContaining(\"@JinjavaDoc must be configured\");\n+  }\n+\n+  @JinjavaDoc\n+  public static class NoJinjavaParamsFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itDoesNotRequireParams() {\n+    filter = new NoJinjavaParamsFilter();\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(value = \"1st\", desc = \"1st\"),\n+      @JinjavaParam(value = \"2nd\", desc = \"2nd\"),\n+      @JinjavaParam(value = \"3rd\", desc = \"3rd\")\n+    }\n+  )\n+  public static class TwoParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itSupportsMixingOfPositionalAndNamedArgs() {\n+    filter = new TwoParamTypesFilter();\n+\n+    filter.filter(null, interpreter, new Object[] { \"1\" }, ImmutableMap.of(\"3rd\", \"3\"));\n+\n+    assertThat(filter.parsedArgs).isEqualTo(ImmutableMap.of(\"1st\", \"1\", \"3rd\", \"3\"));\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(\n+        value = \"boolean\",\n+        type = \"boolean\",\n+        desc = \"boolean\",\n+        required = true\n+      ),\n+      @JinjavaParam(value = \"int\", type = \"int\", desc = \"int\"),\n+      @JinjavaParam(value = \"long\", type = \"long\", desc = \"long\"),\n+      @JinjavaParam(value = \"float\", type = \"float\", desc = \"float\"),\n+      @JinjavaParam(value = \"double\", type = \"double\", desc = \"double\"),\n+      @JinjavaParam(value = \"number\", type = \"number\", desc = \"number\"),\n+      @JinjavaParam(value = \"object\", type = \"object\", desc = \"object\"),\n+      @JinjavaParam(value = \"dict\", type = \"dict\", desc = \"dict\")\n+    }\n+  )\n+  public static class AllParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itParsesNumericAndBooleanInput() {\n+    filter = new AllParamTypesFilter();\n+\n+    Map<String, Object> kwArgs = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bfd056c84fcb7499e73bf8fad12fb674b73e887", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/9bfd056c84fcb7499e73bf8fad12fb674b73e887", "committedDate": "2020-11-03T12:39:13Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaca4d49973d300baf593819ab4dc32b3fab80de", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/aaca4d49973d300baf593819ab4dc32b3fab80de", "committedDate": "2020-11-03T12:44:04Z", "message": "cache for namedArguments and defaultValues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "615e3b1b480e6badb98346cfa6337bab4a0f40a1", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/615e3b1b480e6badb98346cfa6337bab4a0f40a1", "committedDate": "2020-11-03T13:02:18Z", "message": "forgot the static classifier for cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0Mzk2MDU0", "url": "https://github.com/HubSpot/jinjava/pull/523#pullrequestreview-524396054", "createdAt": "2020-11-05T15:44:20Z", "commit": {"oid": "615e3b1b480e6badb98346cfa6337bab4a0f40a1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo0NDoyMFrOHuJgHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNTo1MzoxN1rOHuJ7Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1MjIyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             Copyright (c) 2014 HubSpot Inc.\n          \n          \n            \n             Copyright (c) 2020 HubSpot Inc.", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518152221", "createdAt": "2020-11-05T15:44:20Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "615e3b1b480e6badb98346cfa6337bab4a0f40a1"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NzAwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, JinjavaParam> namedArgs = new LinkedHashMap<>();\n          \n          \n            \n                  for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {\n          \n          \n            \n                    namedArgs.put(jinjavaParam.value(), jinjavaParam);\n          \n          \n            \n                  }\n          \n          \n            \n                  return Collections.unmodifiableMap(namedArgs);\n          \n          \n            \n            return jinjavaDoc.params().stream().collect(ImmutableMap.toImmutableMap(p -> p.value(), p -> p));", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518157001", "createdAt": "2020-11-05T15:50:25Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private static final Map<Class, Map<String, JinjavaParam>> NAMED_ARGUMENTS_CACHE = new ConcurrentHashMap<>();\n+  private static final Map<Class, Map<String, Object>> DEFAULT_VALUES_CACHE = new ConcurrentHashMap<>();\n+\n+  private final Map<String, JinjavaParam> namedArguments;\n+  private final Map<String, Object> defaultValues;\n+\n+  public AbstractFilter() {\n+    namedArguments =\n+      NAMED_ARGUMENTS_CACHE.computeIfAbsent(getClass(), cls -> initNamedArguments());\n+    defaultValues =\n+      DEFAULT_VALUES_CACHE.computeIfAbsent(getClass(), cls -> initDefaultValues());\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    namedArgs.putAll(defaultValues);\n+\n+    //Process named params\n+    for (Map.Entry<String, Object> passedNamedArgEntry : kwargs.entrySet()) {\n+      String argName = passedNamedArgEntry.getKey();\n+      Object argValue = passedNamedArgEntry.getValue();\n+      int argPosition = getNamedArgumentPosition(argName);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' is invalid for filter %s\",\n+            argName,\n+            getName()\n+          )\n+        );\n+      }\n+      namedArgs.put(argName, argValue);\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach(\n+      (k, v) -> parsedArgs.put(k, parseArg(interpreter, namedArguments.get(k), v))\n+    );\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  protected Object parseArg(\n+    JinjavaInterpreter interpreter,\n+    JinjavaParam jinjavaParamMetadata,\n+    Object value\n+  ) {\n+    if (\n+      jinjavaParamMetadata.type() == null ||\n+      value == null ||\n+      Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())\n+    ) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\":\n+        return value instanceof Boolean\n+          ? (Boolean) value\n+          : BooleanUtils.toBooleanObject(valueString);\n+      case \"int\":\n+        return value instanceof Integer\n+          ? (Integer) value\n+          : NumberUtils.toInt(valueString);\n+      case \"long\":\n+        return value instanceof Long ? (Long) value : NumberUtils.toLong(valueString);\n+      case \"float\":\n+        return value instanceof Float ? (Float) value : NumberUtils.toFloat(valueString);\n+      case \"double\":\n+        return value instanceof Double\n+          ? (Double) value\n+          : NumberUtils.toDouble(valueString);\n+      case \"number\":\n+        return value instanceof Number ? (Number) value : new BigDecimal(valueString);\n+      case \"string\":\n+        return valueString;\n+      default:\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' with value '%s' cannot be parsed for filter %s\",\n+            jinjavaParamMetadata.value(),\n+            value,\n+            getName()\n+          )\n+        );\n+    }\n+  }\n+\n+  public void validateArgs(\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  ) {\n+    for (JinjavaParam jinjavaParam : namedArguments.values()) {\n+      if (jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"MISSING_REQUIRED_ARG\",\n+          String.format(\n+            \"Argument named '%s' is required but missing for filter %s\",\n+            jinjavaParam.value(),\n+            getName()\n+          )\n+        );\n+      }\n+    }\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(argNames -> Optional.of(argNames.indexOf(argName)))\n+      .orElse(-1);\n+  }\n+\n+  public String getIndexedArgumentName(int position) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(\n+        argNames ->\n+          Optional.ofNullable(argNames.size() > position ? argNames.get(position) : null)\n+      )\n+      .orElse(null);\n+  }\n+\n+  public Map<String, JinjavaParam> initNamedArguments() {\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      Map<String, JinjavaParam> namedArgs = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {\n+        namedArgs.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      return Collections.unmodifiableMap(namedArgs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "615e3b1b480e6badb98346cfa6337bab4a0f40a1"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1OTEzOA==", "bodyText": "Note that this won't preserve the order though. If you do need that, you could collect to a LinkedHashMap and then wrap the whole thing in Collections.unmodifiableMap", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518159138", "createdAt": "2020-11-05T15:53:17Z", "author": {"login": "boulter"}, "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private static final Map<Class, Map<String, JinjavaParam>> NAMED_ARGUMENTS_CACHE = new ConcurrentHashMap<>();\n+  private static final Map<Class, Map<String, Object>> DEFAULT_VALUES_CACHE = new ConcurrentHashMap<>();\n+\n+  private final Map<String, JinjavaParam> namedArguments;\n+  private final Map<String, Object> defaultValues;\n+\n+  public AbstractFilter() {\n+    namedArguments =\n+      NAMED_ARGUMENTS_CACHE.computeIfAbsent(getClass(), cls -> initNamedArguments());\n+    defaultValues =\n+      DEFAULT_VALUES_CACHE.computeIfAbsent(getClass(), cls -> initDefaultValues());\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    namedArgs.putAll(defaultValues);\n+\n+    //Process named params\n+    for (Map.Entry<String, Object> passedNamedArgEntry : kwargs.entrySet()) {\n+      String argName = passedNamedArgEntry.getKey();\n+      Object argValue = passedNamedArgEntry.getValue();\n+      int argPosition = getNamedArgumentPosition(argName);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' is invalid for filter %s\",\n+            argName,\n+            getName()\n+          )\n+        );\n+      }\n+      namedArgs.put(argName, argValue);\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach(\n+      (k, v) -> parsedArgs.put(k, parseArg(interpreter, namedArguments.get(k), v))\n+    );\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  protected Object parseArg(\n+    JinjavaInterpreter interpreter,\n+    JinjavaParam jinjavaParamMetadata,\n+    Object value\n+  ) {\n+    if (\n+      jinjavaParamMetadata.type() == null ||\n+      value == null ||\n+      Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())\n+    ) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\":\n+        return value instanceof Boolean\n+          ? (Boolean) value\n+          : BooleanUtils.toBooleanObject(valueString);\n+      case \"int\":\n+        return value instanceof Integer\n+          ? (Integer) value\n+          : NumberUtils.toInt(valueString);\n+      case \"long\":\n+        return value instanceof Long ? (Long) value : NumberUtils.toLong(valueString);\n+      case \"float\":\n+        return value instanceof Float ? (Float) value : NumberUtils.toFloat(valueString);\n+      case \"double\":\n+        return value instanceof Double\n+          ? (Double) value\n+          : NumberUtils.toDouble(valueString);\n+      case \"number\":\n+        return value instanceof Number ? (Number) value : new BigDecimal(valueString);\n+      case \"string\":\n+        return valueString;\n+      default:\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' with value '%s' cannot be parsed for filter %s\",\n+            jinjavaParamMetadata.value(),\n+            value,\n+            getName()\n+          )\n+        );\n+    }\n+  }\n+\n+  public void validateArgs(\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  ) {\n+    for (JinjavaParam jinjavaParam : namedArguments.values()) {\n+      if (jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"MISSING_REQUIRED_ARG\",\n+          String.format(\n+            \"Argument named '%s' is required but missing for filter %s\",\n+            jinjavaParam.value(),\n+            getName()\n+          )\n+        );\n+      }\n+    }\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(argNames -> Optional.of(argNames.indexOf(argName)))\n+      .orElse(-1);\n+  }\n+\n+  public String getIndexedArgumentName(int position) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(\n+        argNames ->\n+          Optional.ofNullable(argNames.size() > position ? argNames.get(position) : null)\n+      )\n+      .orElse(null);\n+  }\n+\n+  public Map<String, JinjavaParam> initNamedArguments() {\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      Map<String, JinjavaParam> namedArgs = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {\n+        namedArgs.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      return Collections.unmodifiableMap(namedArgs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NzAwMQ=="}, "originalCommit": {"oid": "615e3b1b480e6badb98346cfa6337bab4a0f40a1"}, "originalPosition": 218}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "469907f7a9a1bee72849fb370beb63148b2dee7d", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/469907f7a9a1bee72849fb370beb63148b2dee7d", "committedDate": "2020-11-06T07:57:54Z", "message": "further review comments re: immutablemap. implement the AbstractFilter.filter(varargs) for backward compatibility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad437f9caaface26f214dfd708ccfe6c3144a3a5", "author": {"user": {"login": "michaelpro1", "name": null}}, "url": "https://github.com/HubSpot/jinjava/commit/ad437f9caaface26f214dfd708ccfe6c3144a3a5", "committedDate": "2020-11-06T08:04:39Z", "message": "missed the toImmutableMap comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2MzY2MDQz", "url": "https://github.com/HubSpot/jinjava/pull/523#pullrequestreview-526366043", "createdAt": "2020-11-09T15:24:34Z", "commit": {"oid": "ad437f9caaface26f214dfd708ccfe6c3144a3a5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab42f2263e1070ac7847ae9970f5685b3136ec28", "author": {"user": {"login": "boulter", "name": "Jeff Boulter"}}, "url": "https://github.com/HubSpot/jinjava/commit/ab42f2263e1070ac7847ae9970f5685b3136ec28", "committedDate": "2020-11-09T15:25:23Z", "message": "remove newline"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NDA2NzQz", "url": "https://github.com/HubSpot/jinjava/pull/523#pullrequestreview-526406743", "createdAt": "2020-11-09T16:03:44Z", "commit": {"oid": "ab42f2263e1070ac7847ae9970f5685b3136ec28"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1547, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}