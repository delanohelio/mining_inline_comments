{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2NzQ3NjM3", "number": 291, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNDoyNzozMlrOFJ7RqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQwMDoxOToyOVrOFKMoUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTUyNjgwOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityCompletionClientImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNDoyNzozMlrOIMdJzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNDoyNzozMlrOIMdJzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTQ2OQ==", "bodyText": "I don't think you want to complete on a heartbeat.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r549931469", "createdAt": "2020-12-30T04:27:32Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityCompletionClientImpl.java", "diffHunk": "@@ -23,58 +23,98 @@\n import io.temporal.client.ActivityCompletionClient;\n import io.temporal.client.ActivityCompletionException;\n import io.temporal.internal.external.ManualActivityCompletionClientFactory;\n+import io.temporal.workflow.Functions;\n import java.util.Optional;\n \n class ActivityCompletionClientImpl implements ActivityCompletionClient {\n \n   private final ManualActivityCompletionClientFactory factory;\n+  private final Functions.Proc completionHandle;\n \n   public ActivityCompletionClientImpl(\n-      ManualActivityCompletionClientFactory manualActivityCompletionClientFactory) {\n+      ManualActivityCompletionClientFactory manualActivityCompletionClientFactory,\n+      Functions.Proc completionHandle) {\n     this.factory = manualActivityCompletionClientFactory;\n+    this.completionHandle = completionHandle;\n   }\n \n   @Override\n   public <R> void complete(byte[] taskToken, R result) {\n-    factory.getClient(taskToken).complete(result);\n+    try {\n+      factory.getClient(taskToken).complete(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <R> void complete(String workflowId, Optional<String> runId, String activityId, R result) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).complete(result);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).complete(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public void completeExceptionally(byte[] taskToken, Exception result) {\n-    factory.getClient(taskToken).fail(result);\n+    try {\n+      factory.getClient(taskToken).fail(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public void completeExceptionally(\n       String workflowId, Optional<String> runId, String activityId, Exception result) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).fail(result);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).fail(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void reportCancellation(byte[] taskToken, V details) {\n-    factory.getClient(taskToken).reportCancellation(details);\n+    try {\n+      factory.getClient(taskToken).reportCancellation(details);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void reportCancellation(\n       String workflowId, Optional<String> runId, String activityId, V details) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).reportCancellation(details);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).reportCancellation(details);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void heartbeat(byte[] taskToken, V details) throws ActivityCompletionException {\n-    factory.getClient(taskToken).recordHeartbeat(details);\n+    try {\n+      factory.getClient(taskToken).recordHeartbeat(details);\n+    } finally {\n+      completionHandle.apply();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTUyNjg2OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityCompletionClientImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNDoyNzo0MVrOIMdJ2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNDoyNzo0MVrOIMdJ2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTQ4MA==", "bodyText": "ditto", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r549931480", "createdAt": "2020-12-30T04:27:41Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityCompletionClientImpl.java", "diffHunk": "@@ -23,58 +23,98 @@\n import io.temporal.client.ActivityCompletionClient;\n import io.temporal.client.ActivityCompletionException;\n import io.temporal.internal.external.ManualActivityCompletionClientFactory;\n+import io.temporal.workflow.Functions;\n import java.util.Optional;\n \n class ActivityCompletionClientImpl implements ActivityCompletionClient {\n \n   private final ManualActivityCompletionClientFactory factory;\n+  private final Functions.Proc completionHandle;\n \n   public ActivityCompletionClientImpl(\n-      ManualActivityCompletionClientFactory manualActivityCompletionClientFactory) {\n+      ManualActivityCompletionClientFactory manualActivityCompletionClientFactory,\n+      Functions.Proc completionHandle) {\n     this.factory = manualActivityCompletionClientFactory;\n+    this.completionHandle = completionHandle;\n   }\n \n   @Override\n   public <R> void complete(byte[] taskToken, R result) {\n-    factory.getClient(taskToken).complete(result);\n+    try {\n+      factory.getClient(taskToken).complete(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <R> void complete(String workflowId, Optional<String> runId, String activityId, R result) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).complete(result);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).complete(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public void completeExceptionally(byte[] taskToken, Exception result) {\n-    factory.getClient(taskToken).fail(result);\n+    try {\n+      factory.getClient(taskToken).fail(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public void completeExceptionally(\n       String workflowId, Optional<String> runId, String activityId, Exception result) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).fail(result);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).fail(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void reportCancellation(byte[] taskToken, V details) {\n-    factory.getClient(taskToken).reportCancellation(details);\n+    try {\n+      factory.getClient(taskToken).reportCancellation(details);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void reportCancellation(\n       String workflowId, Optional<String> runId, String activityId, V details) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).reportCancellation(details);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).reportCancellation(details);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void heartbeat(byte[] taskToken, V details) throws ActivityCompletionException {\n-    factory.getClient(taskToken).recordHeartbeat(details);\n+    try {\n+      factory.getClient(taskToken).recordHeartbeat(details);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void heartbeat(String workflowId, Optional<String> runId, String activityId, V details)\n       throws ActivityCompletionException {\n-    factory.getClient(toExecution(workflowId, runId), activityId).recordHeartbeat(details);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).recordHeartbeat(details);\n+    } finally {\n+      completionHandle.apply();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTUyOTI1OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNDoyOTo0MFrOIMdK-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODozNDoxM1rOIMjb1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTc2OA==", "bodyText": "Make this method and other methods thread safe. It looks like doNotComplete on return should be also made thread safe.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r549931768", "createdAt": "2020-12-30T04:29:40Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -228,6 +239,17 @@ public boolean isDoNotCompleteOnReturn() {\n     return doNotCompleteOnReturn;\n   }\n \n+  public boolean isUseLocalManualCompletion() {\n+    return useLocalManualCompletion;\n+  }\n+\n+  @Override\n+  public ActivityCompletionClient useLocalManualCompletion() {\n+    doNotCompleteOnReturn();\n+    useLocalManualCompletion = true;\n+    return new ActivityCompletionClientImpl(manualCompletionClientFactory, completionHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDAzNDM4OQ==", "bodyText": "Done", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550034389", "createdAt": "2020-12-30T08:34:13Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -228,6 +239,17 @@ public boolean isDoNotCompleteOnReturn() {\n     return doNotCompleteOnReturn;\n   }\n \n+  public boolean isUseLocalManualCompletion() {\n+    return useLocalManualCompletion;\n+  }\n+\n+  @Override\n+  public ActivityCompletionClient useLocalManualCompletion() {\n+    doNotCompleteOnReturn();\n+    useLocalManualCompletion = true;\n+    return new ActivityCompletionClientImpl(manualCompletionClientFactory, completionHandle);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTc2OA=="}, "originalCommit": {"oid": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTUzMDIxOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/LocalActivityExecutionContextImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNDozMDozMlrOIMdLdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMToxNjoxMVrOIM1cLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTg5Mg==", "bodyText": "Why? it makes perfect sense for local activities implemented asynchronously.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r549931892", "createdAt": "2020-12-30T04:30:32Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/LocalActivityExecutionContextImpl.java", "diffHunk": "@@ -72,6 +73,18 @@ public boolean isDoNotCompleteOnReturn() {\n         \"isDoNotCompleteOnReturn is not supported for local activities\");\n   }\n \n+  @Override\n+  public boolean isUseLocalManualCompletion() {\n+    throw new UnsupportedOperationException(\n+        \"isUseLocalManualCompletion is not supported for local activities\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDAzMDE3OQ==", "bodyText": "We need to rethink our behavior for limiting local activity throughput as currently semaphore and setMaxConcurrentActivityExecutionSize is only applied to normal activities. Also I don't think we support async local activities in principle. This would be a bigger change, and I suggest keep it out of scope for this PR.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550030179", "createdAt": "2020-12-30T08:28:34Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/LocalActivityExecutionContextImpl.java", "diffHunk": "@@ -72,6 +73,18 @@ public boolean isDoNotCompleteOnReturn() {\n         \"isDoNotCompleteOnReturn is not supported for local activities\");\n   }\n \n+  @Override\n+  public boolean isUseLocalManualCompletion() {\n+    throw new UnsupportedOperationException(\n+        \"isUseLocalManualCompletion is not supported for local activities\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTg5Mg=="}, "originalCommit": {"oid": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTM4OA==", "bodyText": "Let's keep it out of the scope of this PR.\nI believe that async local activities can be an important performance optimization in some cases.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550329388", "createdAt": "2020-12-30T21:16:11Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/LocalActivityExecutionContextImpl.java", "diffHunk": "@@ -72,6 +73,18 @@ public boolean isDoNotCompleteOnReturn() {\n         \"isDoNotCompleteOnReturn is not supported for local activities\");\n   }\n \n+  @Override\n+  public boolean isUseLocalManualCompletion() {\n+    throw new UnsupportedOperationException(\n+        \"isUseLocalManualCompletion is not supported for local activities\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTg5Mg=="}, "originalCommit": {"oid": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MjExOTUwOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMToxNDowOFrOIM1aNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMzoyMTo1MVrOIM29eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyODg4NQ==", "bodyText": "Does it need to be the Impl or the ManualActivityCompletionClientFactory interface would be enough?", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550328885", "createdAt": "2020-12-30T21:14:08Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -72,6 +75,9 @@\n   private final Lock lock = new ReentrantLock();\n   private ScheduledFuture future;\n   private ActivityCompletionException lastException;\n+  private final ManualActivityCompletionClientFactoryImpl manualCompletionClientFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NDI5Nw==", "bodyText": "Interface is enough.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550354297", "createdAt": "2020-12-30T23:21:51Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -72,6 +75,9 @@\n   private final Lock lock = new ReentrantLock();\n   private ScheduledFuture future;\n   private ActivityCompletionException lastException;\n+  private final ManualActivityCompletionClientFactoryImpl manualCompletionClientFactory;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyODg4NQ=="}, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MjEyMDM3OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMToxNDo0NlrOIM1arg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMzoyMzoxM1rOIM2-JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTAwNg==", "bodyText": "Needs locking as well", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550329006", "createdAt": "2020-12-30T21:14:46Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -220,14 +231,35 @@ private void sendHeartbeatRequest(Object details) {\n \n   @Override\n   public void doNotCompleteOnReturn() {\n-    doNotCompleteOnReturn = true;\n+    lock.lock();\n+    try {\n+      doNotCompleteOnReturn = true;\n+    } finally {\n+      lock.unlock();\n+    }\n   }\n \n   @Override\n   public boolean isDoNotCompleteOnReturn() {\n     return doNotCompleteOnReturn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NDQ2OQ==", "bodyText": "Added.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550354469", "createdAt": "2020-12-30T23:23:13Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -220,14 +231,35 @@ private void sendHeartbeatRequest(Object details) {\n \n   @Override\n   public void doNotCompleteOnReturn() {\n-    doNotCompleteOnReturn = true;\n+    lock.lock();\n+    try {\n+      doNotCompleteOnReturn = true;\n+    } finally {\n+      lock.unlock();\n+    }\n   }\n \n   @Override\n   public boolean isDoNotCompleteOnReturn() {\n     return doNotCompleteOnReturn;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTAwNg=="}, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MjEyMDYyOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMToxNDo1OFrOIM1a2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMzoyMzowOVrOIM2-Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTA1MA==", "bodyText": "Needs locking as well", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550329050", "createdAt": "2020-12-30T21:14:58Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -220,14 +231,35 @@ private void sendHeartbeatRequest(Object details) {\n \n   @Override\n   public void doNotCompleteOnReturn() {\n-    doNotCompleteOnReturn = true;\n+    lock.lock();\n+    try {\n+      doNotCompleteOnReturn = true;\n+    } finally {\n+      lock.unlock();\n+    }\n   }\n \n   @Override\n   public boolean isDoNotCompleteOnReturn() {\n     return doNotCompleteOnReturn;\n   }\n \n+  public boolean isUseLocalManualCompletion() {\n+    return useLocalManualCompletion;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NDQ2Mw==", "bodyText": "Added.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550354463", "createdAt": "2020-12-30T23:23:09Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -220,14 +231,35 @@ private void sendHeartbeatRequest(Object details) {\n \n   @Override\n   public void doNotCompleteOnReturn() {\n-    doNotCompleteOnReturn = true;\n+    lock.lock();\n+    try {\n+      doNotCompleteOnReturn = true;\n+    } finally {\n+      lock.unlock();\n+    }\n   }\n \n   @Override\n   public boolean isDoNotCompleteOnReturn() {\n     return doNotCompleteOnReturn;\n   }\n \n+  public boolean isUseLocalManualCompletion() {\n+    return useLocalManualCompletion;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTA1MA=="}, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MjEyNjM3OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/worker/ActivityWorker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMToxODowNVrOIM1eCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQwMjoxNjo1MlrOIM4ZuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTg2Ng==", "bodyText": "Does response != null check mean that if activity throws an exception the counter is not decremented?", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550329866", "createdAt": "2020-12-30T21:18:05Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/worker/ActivityWorker.java", "diffHunk": "@@ -210,17 +210,20 @@ public void handle(ActivityTask task) throws Exception {\n           if (info.hasDetails()) {\n             canceledRequest.setDetails(info.getDetails());\n           }\n-          sendReply(\n-              r,\n-              new Result(r.getActivityId(), null, null, canceledRequest.build(), null),\n-              metricsScope);\n+          response =\n+              new Result(r.getActivityId(), null, null, canceledRequest.build(), null, false);\n+          sendReply(r, response, metricsScope);\n         }\n       } finally {\n         MDC.remove(LoggerTag.ACTIVITY_ID);\n         MDC.remove(LoggerTag.ACTIVITY_TYPE);\n         MDC.remove(LoggerTag.WORKFLOW_ID);\n         MDC.remove(LoggerTag.RUN_ID);\n-        task.getCompletionHandle().apply();\n+        // Apply completion handle if task has been completed synchronously or is async and manual\n+        // completion hasn't been requested.\n+        if (response != null && !response.isManualCompletion()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3NzkxMw==", "bodyText": "No, it should be null only if activity is async.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550377913", "createdAt": "2020-12-31T02:16:52Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/worker/ActivityWorker.java", "diffHunk": "@@ -210,17 +210,20 @@ public void handle(ActivityTask task) throws Exception {\n           if (info.hasDetails()) {\n             canceledRequest.setDetails(info.getDetails());\n           }\n-          sendReply(\n-              r,\n-              new Result(r.getActivityId(), null, null, canceledRequest.build(), null),\n-              metricsScope);\n+          response =\n+              new Result(r.getActivityId(), null, null, canceledRequest.build(), null, false);\n+          sendReply(r, response, metricsScope);\n         }\n       } finally {\n         MDC.remove(LoggerTag.ACTIVITY_ID);\n         MDC.remove(LoggerTag.ACTIVITY_TYPE);\n         MDC.remove(LoggerTag.WORKFLOW_ID);\n         MDC.remove(LoggerTag.RUN_ID);\n-        task.getCompletionHandle().apply();\n+        // Apply completion handle if task has been completed synchronously or is async and manual\n+        // completion hasn't been requested.\n+        if (response != null && !response.isManualCompletion()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTg2Ng=="}, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MjEzMDM3OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/test/java/io/temporal/workflow/LocalAsyncCompletionWorkflowTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMToyMDozMFrOIM1gLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMzozMDowOVrOIM3CuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMzMDQxMg==", "bodyText": "This doesn't need to be static. Move to the AsyncActivityWithManualCompletion field.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550330412", "createdAt": "2020-12-30T21:20:30Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/test/java/io/temporal/workflow/LocalAsyncCompletionWorkflowTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.activity.Activity;\n+import io.temporal.activity.ActivityExecutionContext;\n+import io.temporal.activity.ActivityInterface;\n+import io.temporal.activity.ActivityMethod;\n+import io.temporal.activity.ActivityOptions;\n+import io.temporal.client.ActivityCompletionClient;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.common.RetryOptions;\n+import io.temporal.worker.WorkerOptions;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalAsyncCompletionWorkflowTest {\n+\n+  public static final int MAX_CONCURRENT_ACTIVITIES = 1;\n+\n+  @Rule\n+  public TestWorkflowRule testWorkflowRule =\n+      TestWorkflowRule.newBuilder()\n+          .setWorkerOptions(\n+              WorkerOptions.newBuilder()\n+                  .setMaxConcurrentActivityExecutionSize(MAX_CONCURRENT_ACTIVITIES)\n+                  .setActivityPollThreadCount(5)\n+                  .build())\n+          .setWorkflowTypes(TestWorkflowImpl.class)\n+          .setActivityImplementations(new AsyncActivityWithManualCompletion())\n+          .setUseExternalService(Boolean.parseBoolean(System.getenv(\"USE_DOCKER_SERVICE\")))\n+          .setTarget(System.getenv(\"TEMPORAL_SERVICE_ADDRESS\"))\n+          .build();\n+\n+  private static final AtomicInteger concurrentActivitiesCount = new AtomicInteger(0);\n+\n+  @WorkflowInterface\n+  public interface TestWorkflow {\n+\n+    @WorkflowMethod\n+    String execute(String taskQueue);\n+  }\n+\n+  public static class TestWorkflowImpl implements TestWorkflow {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivity activity =\n+          Workflow.newActivityStub(\n+              TestActivity.class,\n+              ActivityOptions.newBuilder()\n+                  .setScheduleToStartTimeout(Duration.ofSeconds(10))\n+                  .setScheduleToCloseTimeout(Duration.ofSeconds(10))\n+                  .setHeartbeatTimeout(Duration.ofSeconds(1))\n+                  .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\n+                  .build());\n+      List<Promise<Integer>> promises = new ArrayList<>();\n+      for (int i = 0; i < 10; i++) {\n+        promises.add(Async.function(() -> activity.execute(2)));\n+      }\n+      Promise.allOf(promises).get();\n+      for (Promise<Integer> promise : promises) {\n+        if (promise.getFailure() != null) {\n+          return \"exception\";\n+        }\n+        if (promise.get() != 4) { // All activities compute 2 * 2\n+          return \"wrong result\";\n+        }\n+      }\n+      return \"success\";\n+    }\n+  }\n+\n+  @ActivityInterface\n+  public interface TestActivity {\n+\n+    @ActivityMethod\n+    int execute(int value);\n+  }\n+\n+  public static class AsyncActivityWithManualCompletion implements TestActivity {\n+\n+    @Override\n+    public int execute(int value) {\n+      int concurrentActivities = concurrentActivitiesCount.incrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NTY0MA==", "bodyText": "Done", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550355640", "createdAt": "2020-12-30T23:30:09Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/test/java/io/temporal/workflow/LocalAsyncCompletionWorkflowTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.activity.Activity;\n+import io.temporal.activity.ActivityExecutionContext;\n+import io.temporal.activity.ActivityInterface;\n+import io.temporal.activity.ActivityMethod;\n+import io.temporal.activity.ActivityOptions;\n+import io.temporal.client.ActivityCompletionClient;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.common.RetryOptions;\n+import io.temporal.worker.WorkerOptions;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalAsyncCompletionWorkflowTest {\n+\n+  public static final int MAX_CONCURRENT_ACTIVITIES = 1;\n+\n+  @Rule\n+  public TestWorkflowRule testWorkflowRule =\n+      TestWorkflowRule.newBuilder()\n+          .setWorkerOptions(\n+              WorkerOptions.newBuilder()\n+                  .setMaxConcurrentActivityExecutionSize(MAX_CONCURRENT_ACTIVITIES)\n+                  .setActivityPollThreadCount(5)\n+                  .build())\n+          .setWorkflowTypes(TestWorkflowImpl.class)\n+          .setActivityImplementations(new AsyncActivityWithManualCompletion())\n+          .setUseExternalService(Boolean.parseBoolean(System.getenv(\"USE_DOCKER_SERVICE\")))\n+          .setTarget(System.getenv(\"TEMPORAL_SERVICE_ADDRESS\"))\n+          .build();\n+\n+  private static final AtomicInteger concurrentActivitiesCount = new AtomicInteger(0);\n+\n+  @WorkflowInterface\n+  public interface TestWorkflow {\n+\n+    @WorkflowMethod\n+    String execute(String taskQueue);\n+  }\n+\n+  public static class TestWorkflowImpl implements TestWorkflow {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivity activity =\n+          Workflow.newActivityStub(\n+              TestActivity.class,\n+              ActivityOptions.newBuilder()\n+                  .setScheduleToStartTimeout(Duration.ofSeconds(10))\n+                  .setScheduleToCloseTimeout(Duration.ofSeconds(10))\n+                  .setHeartbeatTimeout(Duration.ofSeconds(1))\n+                  .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\n+                  .build());\n+      List<Promise<Integer>> promises = new ArrayList<>();\n+      for (int i = 0; i < 10; i++) {\n+        promises.add(Async.function(() -> activity.execute(2)));\n+      }\n+      Promise.allOf(promises).get();\n+      for (Promise<Integer> promise : promises) {\n+        if (promise.getFailure() != null) {\n+          return \"exception\";\n+        }\n+        if (promise.get() != 4) { // All activities compute 2 * 2\n+          return \"wrong result\";\n+        }\n+      }\n+      return \"success\";\n+    }\n+  }\n+\n+  @ActivityInterface\n+  public interface TestActivity {\n+\n+    @ActivityMethod\n+    int execute(int value);\n+  }\n+\n+  public static class AsyncActivityWithManualCompletion implements TestActivity {\n+\n+    @Override\n+    public int execute(int value) {\n+      int concurrentActivities = concurrentActivitiesCount.incrementAndGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMzMDQxMg=="}, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MjEzMzAyOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/test/java/io/temporal/workflow/LocalAsyncCompletionWorkflowTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMToyMjoyOFrOIM1hqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMzozMDoxNFrOIM3Cwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMzMDc5NA==", "bodyText": "I would move completion to a separate thread just to increase code coverage. See HelloAsyncActivityCompletion.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550330794", "createdAt": "2020-12-30T21:22:28Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/test/java/io/temporal/workflow/LocalAsyncCompletionWorkflowTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.activity.Activity;\n+import io.temporal.activity.ActivityExecutionContext;\n+import io.temporal.activity.ActivityInterface;\n+import io.temporal.activity.ActivityMethod;\n+import io.temporal.activity.ActivityOptions;\n+import io.temporal.client.ActivityCompletionClient;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.common.RetryOptions;\n+import io.temporal.worker.WorkerOptions;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalAsyncCompletionWorkflowTest {\n+\n+  public static final int MAX_CONCURRENT_ACTIVITIES = 1;\n+\n+  @Rule\n+  public TestWorkflowRule testWorkflowRule =\n+      TestWorkflowRule.newBuilder()\n+          .setWorkerOptions(\n+              WorkerOptions.newBuilder()\n+                  .setMaxConcurrentActivityExecutionSize(MAX_CONCURRENT_ACTIVITIES)\n+                  .setActivityPollThreadCount(5)\n+                  .build())\n+          .setWorkflowTypes(TestWorkflowImpl.class)\n+          .setActivityImplementations(new AsyncActivityWithManualCompletion())\n+          .setUseExternalService(Boolean.parseBoolean(System.getenv(\"USE_DOCKER_SERVICE\")))\n+          .setTarget(System.getenv(\"TEMPORAL_SERVICE_ADDRESS\"))\n+          .build();\n+\n+  private static final AtomicInteger concurrentActivitiesCount = new AtomicInteger(0);\n+\n+  @WorkflowInterface\n+  public interface TestWorkflow {\n+\n+    @WorkflowMethod\n+    String execute(String taskQueue);\n+  }\n+\n+  public static class TestWorkflowImpl implements TestWorkflow {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivity activity =\n+          Workflow.newActivityStub(\n+              TestActivity.class,\n+              ActivityOptions.newBuilder()\n+                  .setScheduleToStartTimeout(Duration.ofSeconds(10))\n+                  .setScheduleToCloseTimeout(Duration.ofSeconds(10))\n+                  .setHeartbeatTimeout(Duration.ofSeconds(1))\n+                  .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\n+                  .build());\n+      List<Promise<Integer>> promises = new ArrayList<>();\n+      for (int i = 0; i < 10; i++) {\n+        promises.add(Async.function(() -> activity.execute(2)));\n+      }\n+      Promise.allOf(promises).get();\n+      for (Promise<Integer> promise : promises) {\n+        if (promise.getFailure() != null) {\n+          return \"exception\";\n+        }\n+        if (promise.get() != 4) { // All activities compute 2 * 2\n+          return \"wrong result\";\n+        }\n+      }\n+      return \"success\";\n+    }\n+  }\n+\n+  @ActivityInterface\n+  public interface TestActivity {\n+\n+    @ActivityMethod\n+    int execute(int value);\n+  }\n+\n+  public static class AsyncActivityWithManualCompletion implements TestActivity {\n+\n+    @Override\n+    public int execute(int value) {\n+      int concurrentActivities = concurrentActivitiesCount.incrementAndGet();\n+      if (concurrentActivities > MAX_CONCURRENT_ACTIVITIES) {\n+        throw new RuntimeException(\n+            String.format(\n+                \"More than %d activities was running concurrently!\", MAX_CONCURRENT_ACTIVITIES));\n+      }\n+      ActivityExecutionContext context = Activity.getExecutionContext();\n+      context.heartbeat(value);\n+      ActivityCompletionClient completionClient = context.useLocalManualCompletion();\n+      try {\n+        Thread.sleep(500);\n+        completionClient.complete(context.getTaskToken(), value * 2);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        e.printStackTrace();\n+        completionClient.completeExceptionally(context.getTaskToken(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NTY1MA==", "bodyText": "Done", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550355650", "createdAt": "2020-12-30T23:30:14Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/test/java/io/temporal/workflow/LocalAsyncCompletionWorkflowTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.activity.Activity;\n+import io.temporal.activity.ActivityExecutionContext;\n+import io.temporal.activity.ActivityInterface;\n+import io.temporal.activity.ActivityMethod;\n+import io.temporal.activity.ActivityOptions;\n+import io.temporal.client.ActivityCompletionClient;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.common.RetryOptions;\n+import io.temporal.worker.WorkerOptions;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalAsyncCompletionWorkflowTest {\n+\n+  public static final int MAX_CONCURRENT_ACTIVITIES = 1;\n+\n+  @Rule\n+  public TestWorkflowRule testWorkflowRule =\n+      TestWorkflowRule.newBuilder()\n+          .setWorkerOptions(\n+              WorkerOptions.newBuilder()\n+                  .setMaxConcurrentActivityExecutionSize(MAX_CONCURRENT_ACTIVITIES)\n+                  .setActivityPollThreadCount(5)\n+                  .build())\n+          .setWorkflowTypes(TestWorkflowImpl.class)\n+          .setActivityImplementations(new AsyncActivityWithManualCompletion())\n+          .setUseExternalService(Boolean.parseBoolean(System.getenv(\"USE_DOCKER_SERVICE\")))\n+          .setTarget(System.getenv(\"TEMPORAL_SERVICE_ADDRESS\"))\n+          .build();\n+\n+  private static final AtomicInteger concurrentActivitiesCount = new AtomicInteger(0);\n+\n+  @WorkflowInterface\n+  public interface TestWorkflow {\n+\n+    @WorkflowMethod\n+    String execute(String taskQueue);\n+  }\n+\n+  public static class TestWorkflowImpl implements TestWorkflow {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivity activity =\n+          Workflow.newActivityStub(\n+              TestActivity.class,\n+              ActivityOptions.newBuilder()\n+                  .setScheduleToStartTimeout(Duration.ofSeconds(10))\n+                  .setScheduleToCloseTimeout(Duration.ofSeconds(10))\n+                  .setHeartbeatTimeout(Duration.ofSeconds(1))\n+                  .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\n+                  .build());\n+      List<Promise<Integer>> promises = new ArrayList<>();\n+      for (int i = 0; i < 10; i++) {\n+        promises.add(Async.function(() -> activity.execute(2)));\n+      }\n+      Promise.allOf(promises).get();\n+      for (Promise<Integer> promise : promises) {\n+        if (promise.getFailure() != null) {\n+          return \"exception\";\n+        }\n+        if (promise.get() != 4) { // All activities compute 2 * 2\n+          return \"wrong result\";\n+        }\n+      }\n+      return \"success\";\n+    }\n+  }\n+\n+  @ActivityInterface\n+  public interface TestActivity {\n+\n+    @ActivityMethod\n+    int execute(int value);\n+  }\n+\n+  public static class AsyncActivityWithManualCompletion implements TestActivity {\n+\n+    @Override\n+    public int execute(int value) {\n+      int concurrentActivities = concurrentActivitiesCount.incrementAndGet();\n+      if (concurrentActivities > MAX_CONCURRENT_ACTIVITIES) {\n+        throw new RuntimeException(\n+            String.format(\n+                \"More than %d activities was running concurrently!\", MAX_CONCURRENT_ACTIVITIES));\n+      }\n+      ActivityExecutionContext context = Activity.getExecutionContext();\n+      context.heartbeat(value);\n+      ActivityCompletionClient completionClient = context.useLocalManualCompletion();\n+      try {\n+        Thread.sleep(500);\n+        completionClient.complete(context.getTaskToken(), value * 2);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        e.printStackTrace();\n+        completionClient.completeExceptionally(context.getTaskToken(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMzMDc5NA=="}, "originalCommit": {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MjM2ODA4OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivityWorker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQwMDoxNzozMVrOIM3duQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQwMjoxNzo0NVrOIM4aCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2MjU1Mw==", "bodyText": "nit: Might be worth having a constructor overload for empty completion handles", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550362553", "createdAt": "2020-12-31T00:17:31Z", "author": {"login": "Sushisource"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivityWorker.java", "diffHunk": "@@ -220,7 +220,8 @@ public Throwable wrapFailure(Task task, Throwable failure) {\n       metricsScope.counter(MetricsType.LOCAL_ACTIVITY_TOTAL_COUNTER).inc(1);\n \n       Stopwatch sw = metricsScope.timer(MetricsType.LOCAL_ACTIVITY_EXECUTION_LATENCY).start();\n-      ActivityTaskHandler.Result result = handler.handle(activityTask.build(), metricsScope, true);\n+      ActivityTaskHandler.Result result =\n+          handler.handle(new ActivityTask(activityTask.build(), () -> {}), metricsScope, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a77f55d6b47b97b2ac6807068b1357421d26110"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3Nzk5Mw==", "bodyText": "I don't think this warrants a separate constructor. Would prefer to keep as is.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550377993", "createdAt": "2020-12-31T02:17:45Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivityWorker.java", "diffHunk": "@@ -220,7 +220,8 @@ public Throwable wrapFailure(Task task, Throwable failure) {\n       metricsScope.counter(MetricsType.LOCAL_ACTIVITY_TOTAL_COUNTER).inc(1);\n \n       Stopwatch sw = metricsScope.timer(MetricsType.LOCAL_ACTIVITY_EXECUTION_LATENCY).start();\n-      ActivityTaskHandler.Result result = handler.handle(activityTask.build(), metricsScope, true);\n+      ActivityTaskHandler.Result result =\n+          handler.handle(new ActivityTask(activityTask.build(), () -> {}), metricsScope, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2MjU1Mw=="}, "originalCommit": {"oid": "7a77f55d6b47b97b2ac6807068b1357421d26110"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MjM3MDEwOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/test/java/io/temporal/internal/statemachines/LocalActivityStateMachineTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQwMDoxOToyOVrOIM3e1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQwMDoxOToyOVrOIM3e1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2MjgzOA==", "bodyText": "nit: Constructor overload might be nice for these Result types as well, looks like they're frequently constructed w/ a bunch of empty params.", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550362838", "createdAt": "2020-12-31T00:19:29Z", "author": {"login": "Sushisource"}, "path": "temporal-sdk/src/test/java/io/temporal/internal/statemachines/LocalActivityStateMachineTest.java", "diffHunk": "@@ -172,7 +172,8 @@ protected void buildWorkflow(AsyncWorkflowBuilder<Void> builder) {\n               RespondActivityTaskCompletedRequest.newBuilder().setResult(result2).build(),\n               null,\n               null,\n-              null);\n+              null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a77f55d6b47b97b2ac6807068b1357421d26110"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1693, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}