{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4ODA3NDY4", "number": 58, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNDoxNToyN1rODvY8FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNDoxNToyN1rODvY8FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDE4MjYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/io/temporal/internal/sync/POJOWorkflowInterfaceMetadata.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNDoxNToyN1rOGByPPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNDoyNToyOFrOGByYWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyNDg2Mw==", "bodyText": "nit: init and constructor have some similar code that might be able to be turned into util", "url": "https://github.com/temporalio/sdk-java/pull/58#discussion_r404524863", "createdAt": "2020-04-07T04:15:27Z", "author": {"login": "shawnhathaway"}, "path": "src/main/java/io/temporal/internal/sync/POJOWorkflowInterfaceMetadata.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.sync;\n+\n+import io.temporal.workflow.WorkflowInterface;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Rules:\n+ *\n+ * <ul>\n+ *   <li>A workflow implementation must implement at least one non empty interface annotated with\n+ *       WorkflowInterface\n+ *   <li>An interface annotated with WorkflowInterface can extend zero or more interfaces.\n+ *   <li>An interface annotated with WorkflowInterface defines workflow methods for all methods it\n+ *       inherited from interfaces which are not annotated with WorkflowInterface.\n+ *   <li>Each method name can be defined only once across all interfaces annotated with\n+ *       WorkflowInterface. So if annotated interface A has method foo() and an annotated interface\n+ *       B extends A it cannot also declare foo() even with a different signature.\n+ * </ul>\n+ */\n+class POJOWorkflowInterfaceMetadata {\n+\n+  /** Used to override equals and hashCode of Method to ensure deduping by method name in a set. */\n+  static class EqualsByMethodName {\n+    private final Method method;\n+\n+    EqualsByMethodName(Method method) {\n+      this.method = method;\n+    }\n+\n+    public Method getMethod() {\n+      return method;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) return true;\n+      if (o == null || getClass() != o.getClass()) return false;\n+      EqualsByMethodName that = (EqualsByMethodName) o;\n+      return com.google.common.base.Objects.equal(method.getName(), that.method.getName());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return com.google.common.base.Objects.hashCode(method.getName());\n+    }\n+  }\n+\n+  static class EqualsByNameType {\n+    private final String name;\n+    private final WorkflowMethodType type;\n+\n+    EqualsByNameType(String name, WorkflowMethodType type) {\n+      this.name = name;\n+      this.type = type;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) return true;\n+      if (o == null || getClass() != o.getClass()) return false;\n+      EqualsByNameType that = (EqualsByNameType) o;\n+      return com.google.common.base.Objects.equal(name, that.name) && type == that.type;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return com.google.common.base.Objects.hashCode(name, type);\n+    }\n+  }\n+\n+  private POJOWorkflowMethodMetadata workflowMethod;\n+  private final Map<Method, POJOWorkflowMethodMetadata> methods = new HashMap<>();\n+\n+  public static POJOWorkflowInterfaceMetadata newInstance(Class<?> anInterface) {\n+    if (!anInterface.isInterface()) {\n+      throw new IllegalArgumentException(\"Not an interface: \" + anInterface);\n+    }\n+    WorkflowInterface annotation = anInterface.getAnnotation(WorkflowInterface.class);\n+    if (annotation == null) {\n+      throw new IllegalArgumentException(\n+          \"Missing requied @WorkflowInterface annotation: \" + anInterface);\n+    }\n+    POJOWorkflowInterfaceMetadata result = new POJOWorkflowInterfaceMetadata(anInterface);\n+    if (result.methods.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Interface doesn't contain any methods: \" + anInterface.getName());\n+    }\n+    return result;\n+  }\n+\n+  static POJOWorkflowInterfaceMetadata newImplementationInterface(Class<?> anInterface) {\n+    return new POJOWorkflowInterfaceMetadata(anInterface);\n+  }\n+\n+  private POJOWorkflowInterfaceMetadata(Class<?> anInterface) {\n+    Map<EqualsByMethodName, Method> dedupeMap = new HashMap<>();\n+    getWorkflowInterfaceMethods(anInterface, dedupeMap);\n+  }\n+\n+  public Optional<POJOWorkflowMethodMetadata> getWorkflowMethod() {\n+    return Optional.ofNullable(workflowMethod);\n+  }\n+\n+  public Optional<String> getWorkflowType() {\n+    if (workflowMethod == null) {\n+      return Optional.empty();\n+    }\n+    return Optional.of(workflowMethod.getName());\n+  }\n+\n+  public POJOWorkflowMethodMetadata getMethodMetadata(Method method) {\n+    POJOWorkflowMethodMetadata result = methods.get(method);\n+    if (result == null) {\n+      throw new IllegalArgumentException(\"Unknown method: \" + method);\n+    }\n+    return result;\n+  }\n+\n+  public List<POJOWorkflowMethodMetadata> getMethodsMetadata(WorkflowMethodType type) {\n+    List<POJOWorkflowMethodMetadata> result = new ArrayList<>();\n+    for (POJOWorkflowMethodMetadata methodMetadata : this.methods.values()) {\n+      if (methodMetadata.getType() == type) {\n+        result.add(methodMetadata);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  public List<POJOWorkflowMethodMetadata> getMethodsMetadata() {\n+    return new ArrayList<>(this.methods.values());\n+  }\n+\n+  private void initWorkflowInterface(Class<?> anInterface) {\n+    if (!anInterface.isInterface()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "006d3d243d86ae0efd9885dededb3e386b23e216"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyNzE5NQ==", "bodyText": "Good catch. It is actually leftover of me moving this code to constructor :). Removing this method completely.", "url": "https://github.com/temporalio/sdk-java/pull/58#discussion_r404527195", "createdAt": "2020-04-07T04:25:28Z", "author": {"login": "mfateev"}, "path": "src/main/java/io/temporal/internal/sync/POJOWorkflowInterfaceMetadata.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.sync;\n+\n+import io.temporal.workflow.WorkflowInterface;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Rules:\n+ *\n+ * <ul>\n+ *   <li>A workflow implementation must implement at least one non empty interface annotated with\n+ *       WorkflowInterface\n+ *   <li>An interface annotated with WorkflowInterface can extend zero or more interfaces.\n+ *   <li>An interface annotated with WorkflowInterface defines workflow methods for all methods it\n+ *       inherited from interfaces which are not annotated with WorkflowInterface.\n+ *   <li>Each method name can be defined only once across all interfaces annotated with\n+ *       WorkflowInterface. So if annotated interface A has method foo() and an annotated interface\n+ *       B extends A it cannot also declare foo() even with a different signature.\n+ * </ul>\n+ */\n+class POJOWorkflowInterfaceMetadata {\n+\n+  /** Used to override equals and hashCode of Method to ensure deduping by method name in a set. */\n+  static class EqualsByMethodName {\n+    private final Method method;\n+\n+    EqualsByMethodName(Method method) {\n+      this.method = method;\n+    }\n+\n+    public Method getMethod() {\n+      return method;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) return true;\n+      if (o == null || getClass() != o.getClass()) return false;\n+      EqualsByMethodName that = (EqualsByMethodName) o;\n+      return com.google.common.base.Objects.equal(method.getName(), that.method.getName());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return com.google.common.base.Objects.hashCode(method.getName());\n+    }\n+  }\n+\n+  static class EqualsByNameType {\n+    private final String name;\n+    private final WorkflowMethodType type;\n+\n+    EqualsByNameType(String name, WorkflowMethodType type) {\n+      this.name = name;\n+      this.type = type;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) return true;\n+      if (o == null || getClass() != o.getClass()) return false;\n+      EqualsByNameType that = (EqualsByNameType) o;\n+      return com.google.common.base.Objects.equal(name, that.name) && type == that.type;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return com.google.common.base.Objects.hashCode(name, type);\n+    }\n+  }\n+\n+  private POJOWorkflowMethodMetadata workflowMethod;\n+  private final Map<Method, POJOWorkflowMethodMetadata> methods = new HashMap<>();\n+\n+  public static POJOWorkflowInterfaceMetadata newInstance(Class<?> anInterface) {\n+    if (!anInterface.isInterface()) {\n+      throw new IllegalArgumentException(\"Not an interface: \" + anInterface);\n+    }\n+    WorkflowInterface annotation = anInterface.getAnnotation(WorkflowInterface.class);\n+    if (annotation == null) {\n+      throw new IllegalArgumentException(\n+          \"Missing requied @WorkflowInterface annotation: \" + anInterface);\n+    }\n+    POJOWorkflowInterfaceMetadata result = new POJOWorkflowInterfaceMetadata(anInterface);\n+    if (result.methods.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"Interface doesn't contain any methods: \" + anInterface.getName());\n+    }\n+    return result;\n+  }\n+\n+  static POJOWorkflowInterfaceMetadata newImplementationInterface(Class<?> anInterface) {\n+    return new POJOWorkflowInterfaceMetadata(anInterface);\n+  }\n+\n+  private POJOWorkflowInterfaceMetadata(Class<?> anInterface) {\n+    Map<EqualsByMethodName, Method> dedupeMap = new HashMap<>();\n+    getWorkflowInterfaceMethods(anInterface, dedupeMap);\n+  }\n+\n+  public Optional<POJOWorkflowMethodMetadata> getWorkflowMethod() {\n+    return Optional.ofNullable(workflowMethod);\n+  }\n+\n+  public Optional<String> getWorkflowType() {\n+    if (workflowMethod == null) {\n+      return Optional.empty();\n+    }\n+    return Optional.of(workflowMethod.getName());\n+  }\n+\n+  public POJOWorkflowMethodMetadata getMethodMetadata(Method method) {\n+    POJOWorkflowMethodMetadata result = methods.get(method);\n+    if (result == null) {\n+      throw new IllegalArgumentException(\"Unknown method: \" + method);\n+    }\n+    return result;\n+  }\n+\n+  public List<POJOWorkflowMethodMetadata> getMethodsMetadata(WorkflowMethodType type) {\n+    List<POJOWorkflowMethodMetadata> result = new ArrayList<>();\n+    for (POJOWorkflowMethodMetadata methodMetadata : this.methods.values()) {\n+      if (methodMetadata.getType() == type) {\n+        result.add(methodMetadata);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  public List<POJOWorkflowMethodMetadata> getMethodsMetadata() {\n+    return new ArrayList<>(this.methods.values());\n+  }\n+\n+  private void initWorkflowInterface(Class<?> anInterface) {\n+    if (!anInterface.isInterface()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyNDg2Mw=="}, "originalCommit": {"oid": "006d3d243d86ae0efd9885dededb3e386b23e216"}, "originalPosition": 161}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1753, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}