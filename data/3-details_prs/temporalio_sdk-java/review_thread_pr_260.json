{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzNTExMTY3", "number": 260, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjowODoyNlrOE6yY1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzowOToxMVrOFAqFgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDc4NDIyOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/test/java/io/temporal/workflow/WorkflowTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjowODoyNlrOH2ESeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQyMDoxMjozN1rOH3xEiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ1NTQxNw==", "bodyText": "Would love it if someone could fill me in here. While playing around with samples, I was able to use a @every 2s cron designation, but not here. I assume because the in-memory server mock is using a library that doesn't support that.\nAlso there appears to be some time-travel stuff going on to speed this up, but I couldn't find exactly where that is. Would appreciate a pointer for learning purposes.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r526455417", "createdAt": "2020-11-18T22:08:26Z", "author": {"login": "Sushisource"}, "path": "temporal-sdk/src/test/java/io/temporal/workflow/WorkflowTest.java", "diffHunk": "@@ -4264,6 +4267,10 @@ public String execute(String testName) {\n \n   @Test\n   public void testWorkflowWithCronSchedule() {\n+    // REVIEW: Min interval can be less than 1min when running against a real server - what explains\n+    // that discrepancy?\n+    //   Why doesn't \"@every 1s\" work here? Different cron parsing libs?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4839308a6faf241d4705c135f749d5dc64316d40"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NzQxMQ==", "bodyText": "We need to update the documentation. The discrepancy is because the service uses https://github.com/robfig/cron and the java unit test service uses https://github.com/jmrozanec/cron-utils.\nThe time skipping is the major feature of the unit testing framework that supports unit testing long running workflows.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528047411", "createdAt": "2020-11-21T01:21:32Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/test/java/io/temporal/workflow/WorkflowTest.java", "diffHunk": "@@ -4264,6 +4267,10 @@ public String execute(String testName) {\n \n   @Test\n   public void testWorkflowWithCronSchedule() {\n+    // REVIEW: Min interval can be less than 1min when running against a real server - what explains\n+    // that discrepancy?\n+    //   Why doesn't \"@every 1s\" work here? Different cron parsing libs?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ1NTQxNw=="}, "originalCommit": {"oid": "4839308a6faf241d4705c135f749d5dc64316d40"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNzcwNw==", "bodyText": "Thanks for the answer! Can you point me at info/code on the time skipping stuff?", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528237707", "createdAt": "2020-11-21T20:12:37Z", "author": {"login": "Sushisource"}, "path": "temporal-sdk/src/test/java/io/temporal/workflow/WorkflowTest.java", "diffHunk": "@@ -4264,6 +4267,10 @@ public String execute(String testName) {\n \n   @Test\n   public void testWorkflowWithCronSchedule() {\n+    // REVIEW: Min interval can be less than 1min when running against a real server - what explains\n+    // that discrepancy?\n+    //   Why doesn't \"@every 1s\" work here? Different cron parsing libs?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ1NTQxNw=="}, "originalCommit": {"oid": "4839308a6faf241d4705c135f749d5dc64316d40"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk1NzQ3OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/StateMachines.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1MTozNVrOH3lHrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1MTozNVrOH3lHrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MTkwMQ==", "bodyText": "I believe both setLastCompletionResult and setFailure should b called only if d has the corresponding value.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528041901", "createdAt": "2020-11-21T00:51:35Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/StateMachines.java", "diffHunk": "@@ -914,6 +920,7 @@ private static void continueAsNewWorkflow(\n     a.setWorkflowTaskCompletedEventId(workflowTaskCompletedEventId);\n     a.setBackoffStartInterval(d.getBackoffStartInterval());\n     a.setLastCompletionResult(d.getLastCompletionResult());\n+    a.setFailure(d.getFailure());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e525ef605cc9e7c00ec919e1b58f0b92f6e16b6f"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk2MjMwOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDo1NDoyMFrOH3lKGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMTowODoyMVrOH3lUfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjUyMA==", "bodyText": "I would put it after the lastCompletionResult here and down in the WorkflowData constructor.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528042520", "createdAt": "2020-11-21T00:54:20Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "diffHunk": "@@ -183,7 +171,8 @@\n       OptionalLong parentChildInitiatedEventId,\n       Optional<String> continuedExecutionRunId,\n       TestWorkflowService service,\n-      TestWorkflowStore store) {\n+      TestWorkflowStore store,\n+      Failure lastFailure) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e525ef605cc9e7c00ec919e1b58f0b92f6e16b6f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NTE4Mw==", "bodyText": "And make it Optional", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528045183", "createdAt": "2020-11-21T01:08:21Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "diffHunk": "@@ -183,7 +171,8 @@\n       OptionalLong parentChildInitiatedEventId,\n       Optional<String> continuedExecutionRunId,\n       TestWorkflowService service,\n-      TestWorkflowStore store) {\n+      TestWorkflowStore store,\n+      Failure lastFailure) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjUyMA=="}, "originalCommit": {"oid": "e525ef605cc9e7c00ec919e1b58f0b92f6e16b6f"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk3Mzc1OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMTowMjoyNlrOH3lQHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMTowMjoyNlrOH3lQHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NDA2MA==", "bodyText": "I think a simple if condition at line 267 would be much more readable.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528044060", "createdAt": "2020-11-21T01:02:26Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowService.java", "diffHunk": "@@ -276,7 +277,8 @@ StartWorkflowExecutionResponse startWorkflowExecutionImpl(\n           parent,\n           parentChildInitiatedEventId,\n           signalWithStartSignal,\n-          workflowId);\n+          workflowId,\n+          retryState.flatMap(TestServiceRetryState::getLastFailure).orElse(null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e525ef605cc9e7c00ec919e1b58f0b92f6e16b6f"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk4MDYwOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/StateMachines.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMTowNzoyN1rOH3lT3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMTozNjo1MFrOH3lmUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NTAyMg==", "bodyText": "Shouldn't this be Optional?", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528045022", "createdAt": "2020-11-21T01:07:27Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/StateMachines.java", "diffHunk": "@@ -199,20 +199,23 @@\n     String originalExecutionRunId;\n     Optional<String> continuedExecutionRunId;\n     Functions.Proc runTimerCancellationHandle;\n+    Failure lastFailure;\n \n     WorkflowData(\n         Optional<TestServiceRetryState> retryState,\n         Duration backoffStartInterval,\n         String cronSchedule,\n         Payloads lastCompletionResult,\n         String originalExecutionRunId,\n-        Optional<String> continuedExecutionRunId) {\n+        Optional<String> continuedExecutionRunId,\n+        Failure lastFailure) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e525ef605cc9e7c00ec919e1b58f0b92f6e16b6f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0OTc0Nw==", "bodyText": "Could be, for sure. Java is killing me a bit with the whole Optional<T> actually has three states problem, where it can still be null. IntelliJ has a lint that whines at you when you use it as a parameter, which I've always found a bit odd, but there are reasons: https://stackoverflow.com/questions/31922866/why-should-java-8s-optional-not-be-used-in-arguments\nI don't really have much of a preference. Since we're already using them as arguments here though, I should probably stay consistent. Curious to hear your thoughts though @mfateev", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528049747", "createdAt": "2020-11-21T01:36:50Z", "author": {"login": "Sushisource"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/StateMachines.java", "diffHunk": "@@ -199,20 +199,23 @@\n     String originalExecutionRunId;\n     Optional<String> continuedExecutionRunId;\n     Functions.Proc runTimerCancellationHandle;\n+    Failure lastFailure;\n \n     WorkflowData(\n         Optional<TestServiceRetryState> retryState,\n         Duration backoffStartInterval,\n         String cronSchedule,\n         Payloads lastCompletionResult,\n         String originalExecutionRunId,\n-        Optional<String> continuedExecutionRunId) {\n+        Optional<String> continuedExecutionRunId,\n+        Failure lastFailure) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NTAyMg=="}, "originalCommit": {"oid": "e525ef605cc9e7c00ec919e1b58f0b92f6e16b6f"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk4MzA0OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMTowOTozMVrOH3lVNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMTowOTozMVrOH3lVNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NTM2Ng==", "bodyText": "gRPC doesn't support nulls.\nSo d.getFailure never returns null and Optional.of of \"d\" that has d.hasFailure==false will be an optional of an empty Failure structure.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528045366", "createdAt": "2020-11-21T01:09:31Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "diffHunk": "@@ -1191,7 +1181,13 @@ private void processFailWorkflowExecution(\n     }\n \n     if (!Strings.isNullOrEmpty(data.cronSchedule)) {\n-      startNewCronRun(ctx, workflowTaskCompletedId, identity, data, data.lastCompletionResult);\n+      startNewCronRun(\n+          ctx,\n+          workflowTaskCompletedId,\n+          identity,\n+          data,\n+          data.lastCompletionResult,\n+          Optional.of(d.getFailure()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e525ef605cc9e7c00ec919e1b58f0b92f6e16b6f"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDk4ODQ3OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMToxMzo0N1rOH3lYDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMzozNjo1MFrOH3-gHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NjA5NQ==", "bodyText": "Change the result type to Optional as neither Failure nor Payload are exposed to the workflow code. Use failureToException method to convert.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528046095", "createdAt": "2020-11-21T01:13:47Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java", "diffHunk": "@@ -1181,6 +1182,18 @@ public static Logger getLogger(String name) {\n     return WorkflowInternal.getLastCompletionResult(resultClass, resultClass);\n   }\n \n+  /**\n+   * Extract the latest failure from some previous run for this cron workflow. This is used in\n+   * combination with cron schedule. A workflow can be started with an optional cron schedule. If\n+   * any previous workflow has failed, this function returns that failure. If no previous workflows\n+   * have failed, an empty optional is returned.\n+   *\n+   * @return The last {@link Failure} that occurred in this workflow, if there has been one.\n+   */\n+  public static Optional<Failure> getLastFailure() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e525ef605cc9e7c00ec919e1b58f0b92f6e16b6f"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ1Nzc1OA==", "bodyText": "Changed. Should we change the method name as well? Pertains to my question here:temporalio/sdk-go#293 (comment)", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r528457758", "createdAt": "2020-11-23T03:36:50Z", "author": {"login": "Sushisource"}, "path": "temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java", "diffHunk": "@@ -1181,6 +1182,18 @@ public static Logger getLogger(String name) {\n     return WorkflowInternal.getLastCompletionResult(resultClass, resultClass);\n   }\n \n+  /**\n+   * Extract the latest failure from some previous run for this cron workflow. This is used in\n+   * combination with cron schedule. A workflow can be started with an optional cron schedule. If\n+   * any previous workflow has failed, this function returns that failure. If no previous workflows\n+   * have failed, an empty optional is returned.\n+   *\n+   * @return The last {@link Failure} that occurred in this workflow, if there has been one.\n+   */\n+  public static Optional<Failure> getLastFailure() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0NjA5NQ=="}, "originalCommit": {"oid": "e525ef605cc9e7c00ec919e1b58f0b92f6e16b6f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzc3ODQ3OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/StateMachines.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToxNjoyMFrOH6A3PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDozNDoxNlrOH6DEJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5MzU5Nw==", "bodyText": "We shouldn't allow null values for Optional fields. They should be either Optiona.empty or populated.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530593597", "createdAt": "2020-11-25T19:16:20Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/StateMachines.java", "diffHunk": "@@ -830,6 +833,9 @@ private static void startWorkflow(\n     if (data.lastCompletionResult != null) {\n       a.setLastCompletionResult(data.lastCompletionResult);\n     }\n+    if (data.lastFailure != null && data.lastFailure.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMDgwNg==", "bodyText": "Maybe I'm still stuck in Rust land but, I worry about the idea that we can only rely on our own consistency to ensure Optionals are non-null. The null check is cheap and not too noisy, and allows us to consider the method by itself without ensuring data is always well constructed.\nSo, I agree with the theory, but in practice I like to check because it decreases mental load. Thoughts?", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530600806", "createdAt": "2020-11-25T19:31:41Z", "author": {"login": "Sushisource"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/StateMachines.java", "diffHunk": "@@ -830,6 +833,9 @@ private static void startWorkflow(\n     if (data.lastCompletionResult != null) {\n       a.setLastCompletionResult(data.lastCompletionResult);\n     }\n+    if (data.lastFailure != null && data.lastFailure.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5MzU5Nw=="}, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMzM0Nw==", "bodyText": "Java has nice mechanism called NullPointerException to report such bugs. So adding repetitive checks all other the code for null is not serving any purpose besides adding clutter. In this particular case if  you want to add the check do in the constructor of Data.\nthis.lastFailure = Objects.requireNotNull(lastFailure);\nI would also change all Data fields that are not expected to be changed to final.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530603347", "createdAt": "2020-11-25T19:37:04Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/StateMachines.java", "diffHunk": "@@ -830,6 +833,9 @@ private static void startWorkflow(\n     if (data.lastCompletionResult != null) {\n       a.setLastCompletionResult(data.lastCompletionResult);\n     }\n+    if (data.lastFailure != null && data.lastFailure.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5MzU5Nw=="}, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYyOTY2OA==", "bodyText": "Ah, that's a nice way to handle it. Thanks.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530629668", "createdAt": "2020-11-25T20:34:16Z", "author": {"login": "Sushisource"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/StateMachines.java", "diffHunk": "@@ -830,6 +833,9 @@ private static void startWorkflow(\n     if (data.lastCompletionResult != null) {\n       a.setLastCompletionResult(data.lastCompletionResult);\n     }\n+    if (data.lastFailure != null && data.lastFailure.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5MzU5Nw=="}, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzc4MTUzOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToxNzoxNVrOH6A47g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToxNzoxNVrOH6A47g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NDAzMA==", "bodyText": "Revert. Change your IDE settings to not use *.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530594030", "createdAt": "2020-11-25T19:17:15Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "diffHunk": "@@ -37,20 +37,7 @@\n import com.google.protobuf.util.Timestamps;\n import io.grpc.Status;\n import io.grpc.StatusRuntimeException;\n-import io.temporal.api.command.v1.CancelTimerCommandAttributes;\n-import io.temporal.api.command.v1.CancelWorkflowExecutionCommandAttributes;\n-import io.temporal.api.command.v1.Command;\n-import io.temporal.api.command.v1.CompleteWorkflowExecutionCommandAttributes;\n-import io.temporal.api.command.v1.ContinueAsNewWorkflowExecutionCommandAttributes;\n-import io.temporal.api.command.v1.FailWorkflowExecutionCommandAttributes;\n-import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n-import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n-import io.temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes;\n-import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n-import io.temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes;\n-import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;\n-import io.temporal.api.command.v1.StartTimerCommandAttributes;\n-import io.temporal.api.command.v1.UpsertWorkflowSearchAttributesCommandAttributes;\n+import io.temporal.api.command.v1.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzc4OTc1OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToyMDowNFrOH6A-FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDo1MzozMVrOH6DiRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NTM0OQ==", "bodyText": "I would move empty() initialization to else block:\nOptional<Failure> lastFailure;\nif (...) {\n   lastFailure = ...\n} else {\n   lastFailure = Optional.empty();\n}", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530595349", "createdAt": "2020-11-25T19:20:04Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowService.java", "diffHunk": "@@ -259,10 +260,14 @@ StartWorkflowExecutionResponse startWorkflowExecutionImpl(\n         }\n       }\n       Optional<TestServiceRetryState> retryState;\n+      Optional<Failure> lastFailure = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzNzM4Mw==", "bodyText": "This would require us to set it to empty in two branching paths to ensure it's non-null, thus more verbose. Any particular reason not to leave it this way?", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530637383", "createdAt": "2020-11-25T20:53:31Z", "author": {"login": "Sushisource"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowService.java", "diffHunk": "@@ -259,10 +260,14 @@ StartWorkflowExecutionResponse startWorkflowExecutionImpl(\n         }\n       }\n       Optional<TestServiceRetryState> retryState;\n+      Optional<Failure> lastFailure = Optional.empty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NTM0OQ=="}, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzc5Mjc2OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToyMTowNVrOH6A_4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToyMTowNVrOH6A_4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NTgxMA==", "bodyText": "It looks like we use both Optional and null for lastFailure inside the testservice. Let's make this consistent.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530595810", "createdAt": "2020-11-25T19:21:05Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "diffHunk": "@@ -1307,8 +1299,11 @@ private void startNewCronRun(\n             .setTaskQueue(startRequest.getTaskQueue())\n             .setBackoffStartInterval(ProtobufTimeUtils.toProtoDuration(backoffInterval))\n             .setRetryPolicy(startRequest.getRetryPolicy())\n-            .setLastCompletionResult(lastCompletionResult)\n-            .build();\n+            .setLastCompletionResult(lastCompletionResult);\n+    if (lastFailure != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzgwMDY0OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToyNDowMlrOH6BFAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToyNDowMlrOH6BFAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5NzEyMw==", "bodyText": "I would move this logic into WorkflowInternal. The idea is that Workflow is just a public layer over internal stuff without any business logic.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530597123", "createdAt": "2020-11-25T19:24:02Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java", "diffHunk": "@@ -1181,6 +1183,19 @@ public static Logger getLogger(String name) {\n     return WorkflowInternal.getLastCompletionResult(resultClass, resultClass);\n   }\n \n+  /**\n+   * Extract the latest failure from some previous run for this cron workflow. This is used in\n+   * combination with cron schedule. A workflow can be started with an optional cron schedule. If\n+   * any previous workflow has failed, this function returns that failure. If no previous workflows\n+   * have failed, an empty optional is returned.\n+   *\n+   * @return The last {@link Exception} that occurred in this workflow, if there has been one.\n+   */\n+  public static Optional<Exception> getLastFailure() {\n+    return WorkflowInternal.getLastFailure()\n+        .map(f -> FailureConverter.failureToException(f, DataConverter.getDefaultInstance()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzg1NDg1OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo0MjowMFrOH6BmFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo0MjowMFrOH6BmFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNTU4OQ==", "bodyText": "Let's rename to the getPreviousRunFailure. It is not really clear what this failure is about just by the name.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530605589", "createdAt": "2020-11-25T19:42:00Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java", "diffHunk": "@@ -1181,6 +1183,19 @@ public static Logger getLogger(String name) {\n     return WorkflowInternal.getLastCompletionResult(resultClass, resultClass);\n   }\n \n+  /**\n+   * Extract the latest failure from some previous run for this cron workflow. This is used in\n+   * combination with cron schedule. A workflow can be started with an optional cron schedule. If\n+   * any previous workflow has failed, this function returns that failure. If no previous workflows\n+   * have failed, an empty optional is returned.\n+   *\n+   * @return The last {@link Exception} that occurred in this workflow, if there has been one.\n+   */\n+  public static Optional<Exception> getLastFailure() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzg2NTI2OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo0NToyM1rOH6BsRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo0NToyM1rOH6BsRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNzE3Mg==", "bodyText": "This doesn't apply to cron workflows only. It applies to any workflow retries (at least this is my understanding that is worth testing). So I would say something like:\nExtract the latest failure from some previous run for this workflow. This run can be created as a retry of the previous failed run or as a next cron invocation for cron workflows.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r530607172", "createdAt": "2020-11-25T19:45:23Z", "author": {"login": "mfateev"}, "path": "temporal-sdk/src/main/java/io/temporal/workflow/Workflow.java", "diffHunk": "@@ -1181,6 +1183,19 @@ public static Logger getLogger(String name) {\n     return WorkflowInternal.getLastCompletionResult(resultClass, resultClass);\n   }\n \n+  /**\n+   * Extract the latest failure from some previous run for this cron workflow. This is used in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cedec75e13ed7d6a5fa7eb1600221a0c0ead9ab9"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MjMzMDkxOnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/SyncWorkflow.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzowNjo0MFrOH_DkGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzowNjo0MFrOH_DkGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MDczMA==", "bodyText": "nit. s/Fail/Failure", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r535880730", "createdAt": "2020-12-04T07:06:40Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/SyncWorkflow.java", "diffHunk": "@@ -101,8 +102,12 @@ public void start(HistoryEvent event, ReplayWorkflowContext context) {\n         startEvent.hasLastCompletionResult()\n             ? Optional.of(startEvent.getLastCompletionResult())\n             : Optional.empty();\n+    Optional<Failure> lastFail =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae496df3547af5923a905cbd4a926c4a86d45a8a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MjMzODU2OnYy", "diffSide": "RIGHT", "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzowOToxMVrOH_DoIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjo1NTo1MVrOH_ZhRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MTc2MA==", "bodyText": "nit. I know you haven't changed this, but do we really need to pass both data and data.lastCompletionResult separately?", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r535881760", "createdAt": "2020-12-04T07:09:11Z", "author": {"login": "vitarb"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "diffHunk": "@@ -1193,7 +1197,13 @@ private void processFailWorkflowExecution(\n     }\n \n     if (!Strings.isNullOrEmpty(data.cronSchedule)) {\n-      startNewCronRun(ctx, workflowTaskCompletedId, identity, data, data.lastCompletionResult);\n+      startNewCronRun(\n+          ctx,\n+          workflowTaskCompletedId,\n+          identity,\n+          data,\n+          data.lastCompletionResult,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae496df3547af5923a905cbd4a926c4a86d45a8a"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI0MDQ1NA==", "bodyText": "We do - at a different call site the last completion result comes from another source.", "url": "https://github.com/temporalio/sdk-java/pull/260#discussion_r536240454", "createdAt": "2020-12-04T16:55:51Z", "author": {"login": "Sushisource"}, "path": "temporal-sdk/src/main/java/io/temporal/internal/testservice/TestWorkflowMutableStateImpl.java", "diffHunk": "@@ -1193,7 +1197,13 @@ private void processFailWorkflowExecution(\n     }\n \n     if (!Strings.isNullOrEmpty(data.cronSchedule)) {\n-      startNewCronRun(ctx, workflowTaskCompletedId, identity, data, data.lastCompletionResult);\n+      startNewCronRun(\n+          ctx,\n+          workflowTaskCompletedId,\n+          identity,\n+          data,\n+          data.lastCompletionResult,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4MTc2MA=="}, "originalCommit": {"oid": "ae496df3547af5923a905cbd4a926c4a86d45a8a"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1679, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}