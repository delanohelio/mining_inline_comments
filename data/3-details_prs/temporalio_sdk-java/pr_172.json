{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0NjM5MTg4", "number": 172, "title": "StateMachine rewrite", "bodyText": "Complete rewrite of the workflow task handling state machine. It was caused by the need to fix immediate cancellation issues that weren't possible to solve using previous design.", "createdAt": "2020-08-07T14:33:19Z", "url": "https://github.com/temporalio/sdk-java/pull/172", "merged": true, "mergeCommit": {"oid": "d357d79603c172142d4f34ca9c182b82fc110358"}, "closed": true, "closedAt": "2020-08-14T17:28:39Z", "author": {"login": "mfateev"}, "timelineItems": {"totalCount": 91, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8lUHkAH2gAyNDY0NjM5MTg4OjEzYzJiMGY0Zjk1ODBiZGVkZjAxZGM1YzU1OTU1ZmY4OTM2ZTQ2MzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-1lEvgFqTQ2NzYyMTk4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/13c2b0f4f9580bdedf01dc5c55955ff8936e4631", "committedDate": "2020-08-07T14:30:00Z", "message": "StateMachine refactoring"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDMwMzM2", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463430336", "createdAt": "2020-08-07T16:05:08Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjowNTowOFrOG9fedg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjowNTowOFrOG9fedg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzMjAyMg==", "bodyText": "[Question] - Should this type of \"default\" be set on the Server side instead?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467132022", "createdAt": "2020-08-07T16:05:08Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/activity/ActivityOptions.java", "diffHunk": "@@ -185,7 +185,7 @@ public ActivityOptions validateAndBuildWithDefaults() {\n           taskQueue,\n           retryOptions,\n           contextPropagators,\n-          cancellationType);\n+          cancellationType == null ? ActivityCancellationType.TRY_CANCEL : cancellationType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDM3NTcy", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463437572", "createdAt": "2020-08-07T16:15:57Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjoxNTo1OFrOG9f1Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjoxNTo1OFrOG9f1Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNzc5NA==", "bodyText": "[Nit] dumb question (based on similar change above), when do we use single quote (') vs double quote (\") for these types of messages?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467137794", "createdAt": "2020-08-07T16:15:58Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/grpc/GrpcTracingInterceptor.java", "diffHunk": "@@ -49,7 +49,7 @@\n         next.newCall(method, callOptions)) {\n       @Override\n       public void sendMessage(ReqT message) {\n-        log.trace(\"Invoking \" + method.getFullMethodName() + \"with input: \" + message);\n+        log.trace(\"Invoking \\\"\" + method.getFullMethodName() + \"\\\" with input: \" + message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDM4NjE3", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463438617", "createdAt": "2020-08-07T16:17:34Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjoxNzozNFrOG9f4Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjoxNzozNFrOG9f4Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzODY0Mw==", "bodyText": "even with the comment, it is still not obvious to me what the difference is between execution latency and execution total latency?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467138643", "createdAt": "2020-08-07T16:17:34Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/metrics/MetricsType.java", "diffHunk": "@@ -42,13 +42,19 @@\n       TEMPORAL_METRICS_PREFIX + \"workflow_task_schedule_to_start_latency\";\n   public static final String WORKFLOW_TASK_EXECUTION_LATENCY =\n       TEMPORAL_METRICS_PREFIX + \"workflow_task_execution_latency\";\n+  // Total latency of a workflow task which can include multiple synchronous decision tasks", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDQ0NDMy", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463444432", "createdAt": "2020-08-07T16:26:23Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjoyNjoyM1rOG9gKlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjoyNjoyM1rOG9gKlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0MzMxNg==", "bodyText": "[Nit] no single or double quote delimiters around activityTask here?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467143316", "createdAt": "2020-08-07T16:26:23Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ExecuteLocalActivityParameters.java", "diffHunk": "@@ -24,19 +24,17 @@\n public class ExecuteLocalActivityParameters {\n \n   private final PollActivityTaskQueueResponse.Builder activityTask;\n-  private final long elapsedTime;\n \n-  public ExecuteLocalActivityParameters(\n-      PollActivityTaskQueueResponse.Builder activityTask, long elapsedTime) {\n+  public ExecuteLocalActivityParameters(PollActivityTaskQueueResponse.Builder activityTask) {\n     this.activityTask = activityTask;\n-    this.elapsedTime = elapsedTime;\n   }\n \n   public PollActivityTaskQueueResponse.Builder getActivityTask() {\n     return activityTask;\n   }\n \n-  public long getElapsedTime() {\n-    return elapsedTime;\n+  @Override\n+  public String toString() {\n+    return \"ExecuteLocalActivityParameters{\" + \"activityTask=\" + activityTask + '}';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDQ5NzU1", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463449755", "createdAt": "2020-08-07T16:35:01Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjozNTowMVrOG9gbVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjozNTowMVrOG9gbVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NzYwNw==", "bodyText": "Curious why some of these methods have full comments (such as startChildWorkflow), but then some like this one (signalExternalWorkflowExecution) don't", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467147607", "createdAt": "2020-08-07T16:35:01Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowContext.java", "diffHunk": "@@ -104,39 +104,39 @@\n    * @param parameters An object which encapsulates all the information required to schedule an\n    *     activity for execution\n    * @param callback Callback that is called upon activity completion or failure.\n-   * @return cancellation handle. Invoke {@link Consumer#accept(Object)} to cancel activity task.\n+   * @return cancellation handle. Invoke {@link Functions.Proc1#apply(Object)} to cancel activity\n+   *     task.\n    */\n-  Consumer<Exception> scheduleActivityTask(\n-      ExecuteActivityParameters parameters, BiConsumer<Optional<Payloads>, Exception> callback);\n+  Functions.Proc1<Exception> scheduleActivityTask(\n+      ExecuteActivityParameters parameters, Functions.Proc2<Optional<Payloads>, Failure> callback);\n \n-  Consumer<Exception> scheduleLocalActivityTask(\n+  Functions.Proc scheduleLocalActivityTask(\n       ExecuteLocalActivityParameters parameters,\n-      BiConsumer<Optional<Payloads>, Exception> callback);\n+      Functions.Proc2<Optional<Payloads>, Failure> callback);\n \n   /**\n    * Start child workflow.\n    *\n    * @param parameters An object which encapsulates all the information required to schedule a child\n    *     workflow for execution\n    * @param callback Callback that is called upon child workflow completion or failure.\n-   * @return cancellation handle. Invoke {@link Consumer#accept(Object)} to cancel activity task.\n+   * @return cancellation handle. Invoke {@link Functions.Proc1#apply(Object)} to cancel activity\n+   *     task.\n    */\n-  Consumer<Exception> startChildWorkflow(\n+  Functions.Proc1<Exception> startChildWorkflow(\n       StartChildWorkflowExecutionParameters parameters,\n-      Consumer<WorkflowExecution> executionCallback,\n-      BiConsumer<Optional<Payloads>, Exception> callback);\n+      Functions.Proc1<WorkflowExecution> executionCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> callback);\n \n-  Consumer<Exception> signalWorkflowExecution(\n+  Functions.Proc1<Exception> signalExternalWorkflowExecution(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDU4Mjg3", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463458287", "createdAt": "2020-08-07T16:48:43Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo0ODo0M1rOG9g1sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo0ODo0M1rOG9g1sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1NDM1NQ==", "bodyText": "hopefully we added a unit test to cover this as this should have been caught when I was syncing to Alex's latest proto changes", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467154355", "createdAt": "2020-08-07T16:48:43Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowTaskHandler.java", "diffHunk": "@@ -104,10 +108,27 @@ public ReplayWorkflowTaskHandler(\n       return handleWorkflowTaskImpl(workflowTask.toBuilder(), metricsScope);\n     } catch (Throwable e) {\n       metricsScope.counter(MetricsType.WORKFLOW_TASK_EXECUTION_FAILURE_COUNTER).inc(1);\n+      // Fail workflow and not a task as WorkflowExecutionException is thrown only if FailWorkflow\n+      // policy was set.\n+      if (e instanceof WorkflowExecutionException) {\n+        RespondWorkflowTaskCompletedRequest response =\n+            RespondWorkflowTaskCompletedRequest.newBuilder()\n+                .setTaskToken(workflowTask.getTaskToken())\n+                .setIdentity(options.getIdentity())\n+                .addCommands(\n+                    Command.newBuilder()\n+                        .setCommandType(CommandType.COMMAND_TYPE_FAIL_WORKFLOW_EXECUTION)\n+                        .setFailWorkflowExecutionCommandAttributes(\n+                            FailWorkflowExecutionCommandAttributes.newBuilder()\n+                                .setFailure(((WorkflowExecutionException) e).getFailure()))\n+                        .build())\n+                .build();\n+        return new WorkflowTaskHandler.Result(workflowType, response, null, null, null, false);\n+      }\n       // Only fail workflow task on the first attempt, subsequent failures of the same workflow task\n       // should timeout. This is to avoid spin on the failed workflow task as the service doesn't\n       // yet increase the retry interval.\n-      if (workflowTask.getAttempt() > 0) {\n+      if (workflowTask.getAttempt() > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDYwMzU1", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463460355", "createdAt": "2020-08-07T16:52:08Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo1MjowOFrOG9g8IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo1MjowOFrOG9g8IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1NjAwMQ==", "bodyText": "[Nit] what does it mean by return \"true if new task should be created synchronously\"? Does this mean not null?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467156001", "createdAt": "2020-08-07T16:52:08Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/WorkflowExecutor.java", "diffHunk": "@@ -24,45 +24,53 @@\n import io.temporal.api.query.v1.WorkflowQuery;\n import io.temporal.api.query.v1.WorkflowQueryResult;\n import io.temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponseOrBuilder;\n+import java.time.Duration;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n \n public interface WorkflowExecutor {\n \n-  WorkflowTaskResult handleWorkflowTask(PollWorkflowTaskQueueResponseOrBuilder workflowTask)\n-      throws Throwable;\n+  /**\n+   * Handles a single workflow task.\n+   *\n+   * @param workflowTask task to handle\n+   * @return true if new task should be created synchronously as local activities are still running.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDYwOTI2", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463460926", "createdAt": "2020-08-07T16:53:03Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo1MzowM1rOG9g93g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo1MzowM1rOG9g93g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1NjQ0Ng==", "bodyText": "we swapped the order to two arguments with the same type...hopefully all the callers have been updated", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467156446", "createdAt": "2020-08-07T16:53:03Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/WorkflowExecutor.java", "diffHunk": "@@ -24,45 +24,53 @@\n import io.temporal.api.query.v1.WorkflowQuery;\n import io.temporal.api.query.v1.WorkflowQueryResult;\n import io.temporal.api.workflowservice.v1.PollWorkflowTaskQueueResponseOrBuilder;\n+import java.time.Duration;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n \n public interface WorkflowExecutor {\n \n-  WorkflowTaskResult handleWorkflowTask(PollWorkflowTaskQueueResponseOrBuilder workflowTask)\n-      throws Throwable;\n+  /**\n+   * Handles a single workflow task.\n+   *\n+   * @param workflowTask task to handle\n+   * @return true if new task should be created synchronously as local activities are still running.\n+   */\n+  WorkflowTaskResult handleWorkflowTask(PollWorkflowTaskQueueResponseOrBuilder workflowTask);\n \n   Optional<Payloads> handleQueryWorkflowTask(\n-      PollWorkflowTaskQueueResponseOrBuilder workflowTask, WorkflowQuery query) throws Throwable;\n+      PollWorkflowTaskQueueResponseOrBuilder workflowTask, WorkflowQuery query);\n \n   void close();\n \n+  Duration getWorkflowTaskTimeout();\n+\n   class WorkflowTaskResult {\n+\n     private final List<Command> commands;\n-    private final boolean forceCreateNewWorkflowTask;\n     private final boolean finalCommand;\n     private final Map<String, WorkflowQueryResult> queryResults;\n+    private final boolean forceWorkflowTask;\n \n     public WorkflowTaskResult(\n         List<Command> commands,\n         Map<String, WorkflowQueryResult> queryResults,\n-        boolean forceCreateNewWorkflowTask,\n-        boolean finalCommand) {\n+        boolean finalCommand,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDYyNzU1", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463462755", "createdAt": "2020-08-07T16:56:01Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo1NjowMVrOG9hDiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo1NjowMVrOG9hDiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1Nzg5OQ==", "bodyText": "Name of class implies two possible configurations, but it looks like its ActionOrEventTypeOrCommandType (three)", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467157899", "createdAt": "2020-08-07T16:56:01Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActionOrEventType.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import com.google.common.base.Objects;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+\n+class ActionOrEventType<Action> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDY4MjA0", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463468204", "createdAt": "2020-08-07T17:04:33Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzowNDozM1rOG9hUwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzowNDozM1rOG9hUwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MjMwNQ==", "bodyText": "is this a typo / copy paste error (SCHEDULE_COMMAND_CREATED twice)? Maybe I'm interpreting this incorrectly? I assumed first line is current state, subsequent line is potential transition, second line is final state and last line is an additional callback to run. Or should we add another state between \"CREATED\" and \"SCHEDULE_COMMAND_CREATED\"?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467162305", "createdAt": "2020-08-07T17:04:33Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.Action, ActivityStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, Action, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDczOTcx", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463473971", "createdAt": "2020-08-07T17:14:14Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzoxNDoxNVrOG9hngA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzoxNDoxNVrOG9hngA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NzEwNA==", "bodyText": "for this state and the cancel_command_Created state, we don't have transitions for a timed out event?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467167104", "createdAt": "2020-08-07T17:14:15Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.Action, ActivityStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, Action, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            Action.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelScheduleCommand)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            Action.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED,\n+            Action.CANCEL,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 157}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDc1MTk0", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463475194", "createdAt": "2020-08-07T17:16:04Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzoxNjowNFrOG9hq7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzoxNjowNFrOG9hq7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2Nzk4MQ==", "bodyText": "where are these 3 *_CANCEL_REQUESTED states used?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467167981", "createdAt": "2020-08-07T17:16:04Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.Action, ActivityStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDgyNTc0", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463482574", "createdAt": "2020-08-07T17:28:05Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzoyODowNVrOG9iCCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzoyODowNVrOG9iCCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3Mzg5OA==", "bodyText": "should we have string constants file for these error messages so that its easy for a technical writer to review or so we can do translations (in the future)", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467173898", "createdAt": "2020-08-07T17:28:05Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.Action, ActivityStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, Action, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            Action.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelScheduleCommand)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            Action.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED,\n+            Action.CANCEL,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::cancelScheduleCommandNotifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::cancelScheduleCommandNotifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCancellationFromEvent);\n+  }\n+\n+  private final ExecuteActivityParameters parameters;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Failure> completionCallback;\n+\n+  /**\n+   * @param parameters attributes used to schedule an activity\n+   * @param completionCallback one of ActivityTaskCompletedEvent, ActivityTaskFailedEvent,\n+   *     ActivityTaskTimedOutEvent, ActivityTaskCanceledEvents\n+   * @param commandSink sink to send commands\n+   * @return an instance of ActivityCommands\n+   */\n+  public static ActivityStateMachine newInstance(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    return new ActivityStateMachine(parameters, completionCallback, commandSink);\n+  }\n+\n+  private ActivityStateMachine(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.parameters = parameters;\n+    this.completionCallback = completionCallback;\n+    action(Action.SCHEDULE);\n+  }\n+\n+  public void createScheduleActivityTaskCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK)\n+            .setScheduleActivityTaskCommandAttributes(parameters.getAttributes())\n+            .build());\n+  }\n+\n+  public void cancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    } else {\n+      action(Action.CANCEL);\n+    }\n+  }\n+\n+  private void cancelScheduleCommand() {\n+    cancelInitialCommand();\n+    if (parameters.getCancellationType() != ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceledIfTryCancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.TRY_CANCEL) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceled() {\n+    Failure canceledFailure =\n+        Failure.newBuilder()\n+            .setSource(JAVA_SDK)\n+            .setCanceledFailureInfo(CanceledFailureInfo.getDefaultInstance())\n+            .build();\n+    completionCallback.apply(Optional.empty(), canceledFailure);\n+  }\n+\n+  private void notifyCompleted() {\n+    ActivityTaskCompletedEventAttributes completedAttr =\n+        currentEvent.getActivityTaskCompletedEventAttributes();\n+    Optional<Payloads> result =\n+        completedAttr.hasResult() ? Optional.of(completedAttr.getResult()) : Optional.empty();\n+    completionCallback.apply(result, null);\n+  }\n+\n+  private void notifyFailed() {\n+    ActivityTaskFailedEventAttributes failed = currentEvent.getActivityTaskFailedEventAttributes();\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+    ActivityFailureInfo failureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())\n+            .setActivityType(scheduleAttr.getActivityType())\n+            .setIdentity(failed.getIdentity())\n+            .setRetryState(failed.getRetryState())\n+            .setScheduledEventId(failed.getScheduledEventId())\n+            .setStartedEventId(failed.getStartedEventId())\n+            .build();\n+    Failure failure =\n+        Failure.newBuilder()\n+            .setActivityFailureInfo(failureInfo)\n+            .setCause(failed.getFailure())\n+            .setMessage(\"Activity task failed\")\n+            .build();\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyTimedOut() {\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+\n+    ActivityTaskTimedOutEventAttributes timedOut =\n+        currentEvent.getActivityTaskTimedOutEventAttributes();\n+\n+    ActivityFailureInfo failureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())\n+            .setActivityType(scheduleAttr.getActivityType())\n+            .setRetryState(timedOut.getRetryState())\n+            .setScheduledEventId(timedOut.getScheduledEventId())\n+            .setStartedEventId(timedOut.getStartedEventId())\n+            .build();\n+    Failure failure =\n+        Failure.newBuilder()\n+            .setActivityFailureInfo(failureInfo)\n+            .setCause(timedOut.getFailure())\n+            .setMessage(\"Activity task timedOut\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 296}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDg2NjU1", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463486655", "createdAt": "2020-08-07T17:34:41Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzozNDo0MVrOG9iONA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzozNDo0MVrOG9iONA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NzAxMg==", "bodyText": "we don't have any information as to why cancellation failed?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467177012", "createdAt": "2020-08-07T17:34:41Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/CancelExternalStateMachine.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.workflow.CancelExternalWorkflowException;\n+import io.temporal.workflow.Functions;\n+\n+final class CancelExternalStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        CancelExternalStateMachine.State,\n+        CancelExternalStateMachine.Action,\n+        CancelExternalStateMachine> {\n+\n+  private final RequestCancelExternalWorkflowExecutionCommandAttributes requestCancelAttributes;\n+\n+  private final Functions.Proc2<Void, RuntimeException> completionCallback;\n+\n+  /**\n+   * @param attributes attributes to use to cancel external worklfow\n+   * @param completionCallback one of ExternalWorkflowExecutionCancelRequestedEvent,\n+   *     RequestCancelExternalWorkflowExecutionFailedEvent\n+   * @param commandSink sink to send commands\n+   */\n+  public static void newInstance(\n+      RequestCancelExternalWorkflowExecutionCommandAttributes attributes,\n+      Functions.Proc2<Void, RuntimeException> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    new CancelExternalStateMachine(attributes, completionCallback, commandSink);\n+  }\n+\n+  private CancelExternalStateMachine(\n+      RequestCancelExternalWorkflowExecutionCommandAttributes requestCancelAttributes,\n+      Functions.Proc2<Void, RuntimeException> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.requestCancelAttributes = requestCancelAttributes;\n+    this.completionCallback = completionCallback;\n+    action(Action.SCHEDULE);\n+  }\n+\n+  enum Action {\n+    SCHEDULE\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REQUEST_CANCEL_EXTERNAL_COMMAND_CREATED,\n+    REQUEST_CANCEL_EXTERNAL_COMMAND_RECORDED,\n+    CANCEL_REQUESTED,\n+    REQUEST_CANCEL_FAILED,\n+  }\n+\n+  private static StateMachine<State, Action, CancelExternalStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, CancelExternalStateMachine>newInstance(\n+            \"CancelExternal\", State.CREATED, State.CANCEL_REQUESTED, State.REQUEST_CANCEL_FAILED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_CREATED,\n+            CancelExternalStateMachine::createCancelExternalCommand)\n+        .add(\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION,\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_CREATED)\n+        .add(\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED,\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_RECORDED)\n+        .add(\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_RECORDED,\n+            EventType.EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED,\n+            State.CANCEL_REQUESTED,\n+            CancelExternalStateMachine::notifyCompleted)\n+        .add(\n+            State.REQUEST_CANCEL_EXTERNAL_COMMAND_RECORDED,\n+            EventType.EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED,\n+            State.REQUEST_CANCEL_FAILED,\n+            CancelExternalStateMachine::notifyFailed);\n+  }\n+\n+  private void createCancelExternalCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION)\n+            .setRequestCancelExternalWorkflowExecutionCommandAttributes(requestCancelAttributes)\n+            .build());\n+  }\n+\n+  private void notifyCompleted() {\n+    completionCallback.apply(null, null);\n+  }\n+\n+  private void notifyFailed() {\n+    WorkflowExecution execution =\n+        WorkflowExecution.newBuilder()\n+            .setWorkflowId(requestCancelAttributes.getWorkflowId())\n+            .setRunId(requestCancelAttributes.getRunId())\n+            .build();\n+    completionCallback.apply(null, new CancelExternalWorkflowException(execution, \"\", null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDkwODMx", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463490831", "createdAt": "2020-08-07T17:41:23Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo0MToyM1rOG9ia2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo0MToyM1rOG9ia2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MDI1MQ==", "bodyText": "can't get a cancel event type here?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467180251", "createdAt": "2020-08-07T17:41:23Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ChildWorkflowStateMachine.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.enums.v1.TimeoutType;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes;\n+import io.temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.client.WorkflowExecutionAlreadyStarted;\n+import io.temporal.common.converter.EncodedValues;\n+import io.temporal.failure.CanceledFailure;\n+import io.temporal.failure.ChildWorkflowFailure;\n+import io.temporal.failure.TerminatedFailure;\n+import io.temporal.failure.TimeoutFailure;\n+import io.temporal.internal.replay.ChildWorkflowTaskFailedException;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ChildWorkflowStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ChildWorkflowStateMachine.State,\n+        ChildWorkflowStateMachine.Action,\n+        ChildWorkflowStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_EVENT_RECORDED,\n+    STARTED,\n+    START_FAILED,\n+    COMPLETED,\n+    FAILED,\n+    CANCELED,\n+    TIMED_OUT,\n+    TERMINATED,\n+  }\n+\n+  private static StateMachine<State, Action, ChildWorkflowStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, ChildWorkflowStateMachine>newInstance(\n+            \"ChildWorkflow\",\n+            State.CREATED,\n+            State.START_FAILED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.CANCELED,\n+            State.TIMED_OUT,\n+            State.TERMINATED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.START_COMMAND_CREATED,\n+            ChildWorkflowStateMachine::createStartChildCommand)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION,\n+            State.START_COMMAND_CREATED)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED,\n+            State.START_EVENT_RECORDED)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            Action.CANCEL,\n+            State.CANCELED,\n+            ChildWorkflowStateMachine::cancelStartChildCommand)\n+        .add(\n+            State.START_EVENT_RECORDED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNTIzNTEy", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463523512", "createdAt": "2020-08-07T18:36:11Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODozNjoxMlrOG9kAXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODozNjoxMlrOG9kAXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwNjIzNg==", "bodyText": "is it guaranteed that this is the only reason why we could not start a workflow?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467206236", "createdAt": "2020-08-07T18:36:12Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ChildWorkflowStateMachine.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.enums.v1.TimeoutType;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes;\n+import io.temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.client.WorkflowExecutionAlreadyStarted;\n+import io.temporal.common.converter.EncodedValues;\n+import io.temporal.failure.CanceledFailure;\n+import io.temporal.failure.ChildWorkflowFailure;\n+import io.temporal.failure.TerminatedFailure;\n+import io.temporal.failure.TimeoutFailure;\n+import io.temporal.internal.replay.ChildWorkflowTaskFailedException;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ChildWorkflowStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ChildWorkflowStateMachine.State,\n+        ChildWorkflowStateMachine.Action,\n+        ChildWorkflowStateMachine> {\n+\n+  enum Action {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_EVENT_RECORDED,\n+    STARTED,\n+    START_FAILED,\n+    COMPLETED,\n+    FAILED,\n+    CANCELED,\n+    TIMED_OUT,\n+    TERMINATED,\n+  }\n+\n+  private static StateMachine<State, Action, ChildWorkflowStateMachine> newStateMachine() {\n+    return StateMachine.<State, Action, ChildWorkflowStateMachine>newInstance(\n+            \"ChildWorkflow\",\n+            State.CREATED,\n+            State.START_FAILED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.CANCELED,\n+            State.TIMED_OUT,\n+            State.TERMINATED)\n+        .add(\n+            State.CREATED,\n+            Action.SCHEDULE,\n+            State.START_COMMAND_CREATED,\n+            ChildWorkflowStateMachine::createStartChildCommand)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION,\n+            State.START_COMMAND_CREATED)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED,\n+            State.START_EVENT_RECORDED)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            Action.CANCEL,\n+            State.CANCELED,\n+            ChildWorkflowStateMachine::cancelStartChildCommand)\n+        .add(\n+            State.START_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED,\n+            State.STARTED,\n+            ChildWorkflowStateMachine::notifyStarted)\n+        .add(\n+            State.START_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED,\n+            State.START_FAILED,\n+            ChildWorkflowStateMachine::notifyStartFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED,\n+            State.COMPLETED,\n+            ChildWorkflowStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED,\n+            State.FAILED,\n+            ChildWorkflowStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ChildWorkflowStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED,\n+            State.CANCELED,\n+            ChildWorkflowStateMachine::notifyCanceled)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED,\n+            State.TERMINATED,\n+            ChildWorkflowStateMachine::notifyTerminated);\n+  }\n+\n+  private final StartChildWorkflowExecutionCommandAttributes startAttributes;\n+\n+  private final Functions.Proc1<WorkflowExecution> startedCallback;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Exception> completionCallback;\n+\n+  /**\n+   * Creates a new child workflow state machine\n+   *\n+   * @param attributes child workflow start command attributes\n+   * @param startedCallback\n+   * @param completionCallback invoked when child reports completion or failure. The following types\n+   *     of events can be passed to the callback: StartChildWorkflowExecutionFailedEvent,\n+   *     ChildWorkflowExecutionCompletedEvent, ChildWorkflowExecutionFailedEvent,\n+   *     ChildWorkflowExecutionTimedOutEvent, ChildWorkflowExecutionCanceledEvent,\n+   *     ChildWorkflowExecutionTerminatedEvent.\n+   * @return cancellation callback that should be invoked to cancel the child\n+   */\n+  public static ChildWorkflowStateMachine newInstance(\n+      StartChildWorkflowExecutionCommandAttributes attributes,\n+      Functions.Proc1<WorkflowExecution> startedCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    return new ChildWorkflowStateMachine(\n+        attributes, startedCallback, completionCallback, commandSink);\n+  }\n+\n+  private ChildWorkflowStateMachine(\n+      StartChildWorkflowExecutionCommandAttributes startAttributes,\n+      Functions.Proc1<WorkflowExecution> startedCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> completionCallback,\n+      Functions.Proc1<NewCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.startAttributes = startAttributes;\n+    this.startedCallback = startedCallback;\n+    this.completionCallback = completionCallback;\n+    action(Action.SCHEDULE);\n+  }\n+\n+  public void createStartChildCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION)\n+            .setStartChildWorkflowExecutionCommandAttributes(startAttributes)\n+            .build());\n+  }\n+\n+  public boolean isCancellable() {\n+    return State.START_COMMAND_CREATED == getState();\n+  }\n+\n+  /**\n+   * Cancellation through this class is valid only when start child workflow command is not sent\n+   * yet. Cancellation of an initiated child workflow is done through CancelExternalCommands. So all\n+   * of the types besides ABANDON are treated differently.\n+   */\n+  public void cancel() {\n+    action(Action.CANCEL);\n+  }\n+\n+  private void cancelStartChildCommand() {\n+    cancelInitialCommand();\n+    CanceledFailure failure = new CanceledFailure(\"Child canceled\", null, null);\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyCompleted() {\n+    ChildWorkflowExecutionCompletedEventAttributes attributes =\n+        currentEvent.getChildWorkflowExecutionCompletedEventAttributes();\n+    Optional<Payloads> result =\n+        attributes.hasResult() ? Optional.of(attributes.getResult()) : Optional.empty();\n+    completionCallback.apply(result, null);\n+  }\n+\n+  private void notifyStartFailed() {\n+    StartChildWorkflowExecutionFailedEventAttributes attributes =\n+        currentEvent.getStartChildWorkflowExecutionFailedEventAttributes();\n+    Exception failure =\n+        new ChildWorkflowTaskFailedException(\n+            currentEvent.getEventId(),\n+            WorkflowExecution.newBuilder().setWorkflowId(attributes.getWorkflowId()).build(),\n+            attributes.getWorkflowType(),\n+            RetryState.RETRY_STATE_NON_RETRYABLE_FAILURE,\n+            null);\n+    failure.initCause(\n+        new WorkflowExecutionAlreadyStarted(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 220}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNTI2NTA5", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463526509", "createdAt": "2020-08-07T18:41:20Z", "commit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo0MToyMVrOG9kJXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo0MToyMVrOG9kJXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwODU0Mg==", "bodyText": "shouldn't we do this check before applying the callback?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467208542", "createdAt": "2020-08-07T18:41:21Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/DynamicTransitionTarget.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+class DynamicTransitionTarget<State, Data> implements TransitionTarget<State, Data> {\n+\n+  final DynamicCallback<State, Data> callback;\n+  State[] expectedStates;\n+  State state;\n+\n+  DynamicTransitionTarget(State[] expectedStates, DynamicCallback<State, Data> callback) {\n+    this.expectedStates = expectedStates;\n+    this.callback = callback;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"DynamicTransitionDestination{\" + \"state=\" + state + \", callback=\" + callback + '}';\n+  }\n+\n+  @Override\n+  public State apply(Data data) {\n+    state = callback.apply(data);\n+    for (State s : expectedStates) {\n+      if (s.equals(state)) {\n+        return state;\n+      }\n+    }\n+    throw new IllegalStateException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c2b0f4f9580bdedf01dc5c55955ff8936e4631"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c08449829228c32f344cdf21fb6c0dc0c60a7f9", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/0c08449829228c32f344cdf21fb6c0dc0c60a7f9", "committedDate": "2020-08-08T16:45:18Z", "message": "PR feedback and broken unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "250f70dc022bffc0c2ea350a082fb8b46e6067ec", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/250f70dc022bffc0c2ea350a082fb8b46e6067ec", "committedDate": "2020-08-08T17:17:49Z", "message": "Fixed workflow task failure reporting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68db6c6c2da1c4fce870ff2c41cbfdade02928cd", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/68db6c6c2da1c4fce870ff2c41cbfdade02928cd", "committedDate": "2020-08-08T17:41:51Z", "message": "WorkflowTaskResult now is created through a Builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b1254b636ad9dd6895e8dc2179bede07b2153ae", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/1b1254b636ad9dd6895e8dc2179bede07b2153ae", "committedDate": "2020-08-08T19:55:54Z", "message": "StateMachine nomenclature cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8243071768b41f6b6582987ccc86d93871443752", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/8243071768b41f6b6582987ccc86d93871443752", "committedDate": "2020-08-09T00:29:05Z", "message": "Merge branch 'master' of github.com:temporalio/temporal-java-sdk into state-machine-review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4df71d6cae7d14e25ebeadb368b9f0342653e85c", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/4df71d6cae7d14e25ebeadb368b9f0342653e85c", "committedDate": "2020-08-09T05:38:02Z", "message": "initial command refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/e1e3fa6db2903db82312a1b256c2a8046f098737", "committedDate": "2020-08-09T20:43:42Z", "message": "Added ActivityStateMachineTest and fixed cancellation failure"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTA4MDY5", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463908069", "createdAt": "2020-08-09T22:25:55Z", "commit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjoyNTo1NVrOG9-Ovw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjoyNTo1NVrOG9-Ovw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNTkwMw==", "bodyText": "[Nit] swap the order of these two state transitions just for consistency (have the self-transition appear first)", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467635903", "createdAt": "2020-08-09T22:25:55Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTA4MTY3", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463908167", "createdAt": "2020-08-09T22:27:25Z", "commit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjoyNzoyNVrOG9-PVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjoyNzoyNVrOG9-PVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNjA1NQ==", "bodyText": "can we group the transitions by state? You have a bunch of transitions from state.STARTED above...feels like you should move this cancel up there as well. there are a few other transitions that can be sorted as well just for better readability", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467636055", "createdAt": "2020-08-09T22:27:25Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        /*\n+        This state transition is not possible.\n+        It looks like it is valid when an event, handling of which requests activity\n+        cancellation, precedes EVENT_TYPE_ACTIVITY_TASK_STARTED event.\n+        But as all code execution happens in the event loop the STARTED event is\n+        applied to the sate machine (as it is done for all command events before\n+        the event loop invocation) before the cancellation request.\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+             */\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTA4MzA1", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463908305", "createdAt": "2020-08-09T22:29:43Z", "commit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjoyOTo0NFrOG9-QEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjoyOTo0NFrOG9-QEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNjI0Mg==", "bodyText": "[Nit] typo = 'sate machine'", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467636242", "createdAt": "2020-08-09T22:29:44Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        /*\n+        This state transition is not possible.\n+        It looks like it is valid when an event, handling of which requests activity\n+        cancellation, precedes EVENT_TYPE_ACTIVITY_TASK_STARTED event.\n+        But as all code execution happens in the event loop the STARTED event is\n+        applied to the sate machine (as it is done for all command events before", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTA5MjAy", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463909202", "createdAt": "2020-08-09T22:44:08Z", "commit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjo0NDowOFrOG9-VQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjo0NDowOFrOG9-VQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzNzU3MQ==", "bodyText": "(more for my own knowledge than an actual comment), what does \"Abandon\" mean vs some of the other semantics and why would a developer choose one over the other? Does it mean the server will just perceive an activity timeout vs an explicit cancellation? Or does it mean we will wait for the server to acknowledge the cancel before actually cancelling? Or I guess it means the caller doesn't care to wait for the cancellation to actually be ACK'd, (s)he just wants it scheduled?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467637571", "createdAt": "2020-08-09T22:44:08Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        /*\n+        This state transition is not possible.\n+        It looks like it is valid when an event, handling of which requests activity\n+        cancellation, precedes EVENT_TYPE_ACTIVITY_TASK_STARTED event.\n+        But as all code execution happens in the event loop the STARTED event is\n+        applied to the sate machine (as it is done for all command events before\n+        the event loop invocation) before the cancellation request.\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+             */\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.STARTED,\n+            ExplicitEvent.CANCEL,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::cancelCommandNotifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::cancelCommandNotifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCancellationFromEvent);\n+  }\n+\n+  private final ExecuteActivityParameters parameters;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Failure> completionCallback;\n+\n+  private long startedCommandEventId;\n+\n+  /**\n+   * @param parameters attributes used to schedule an activity\n+   * @param completionCallback one of ActivityTaskCompletedEvent, ActivityTaskFailedEvent,\n+   *     ActivityTaskTimedOutEvent, ActivityTaskCanceledEvents\n+   * @param commandSink sink to send commands\n+   * @return an instance of ActivityCommands\n+   */\n+  public static ActivityStateMachine newInstance(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    return new ActivityStateMachine(parameters, completionCallback, commandSink);\n+  }\n+\n+  private ActivityStateMachine(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.parameters = parameters;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  public void createScheduleActivityTaskCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK)\n+            .setScheduleActivityTaskCommandAttributes(parameters.getAttributes())\n+            .build());\n+  }\n+\n+  public void cancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.ABANDON) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "originalPosition": 246}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTA5NDk5", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463909499", "createdAt": "2020-08-09T22:48:58Z", "commit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjo0ODo1OFrOG9-XCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjo0ODo1OFrOG9-XCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzODAyNA==", "bodyText": "[Nit] these fields seem more specific to ActivityInfo vs. ActivityFailureInfo", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467638024", "createdAt": "2020-08-09T22:48:58Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        /*\n+        This state transition is not possible.\n+        It looks like it is valid when an event, handling of which requests activity\n+        cancellation, precedes EVENT_TYPE_ACTIVITY_TASK_STARTED event.\n+        But as all code execution happens in the event loop the STARTED event is\n+        applied to the sate machine (as it is done for all command events before\n+        the event loop invocation) before the cancellation request.\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+             */\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.STARTED,\n+            ExplicitEvent.CANCEL,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::cancelCommandNotifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::cancelCommandNotifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCancellationFromEvent);\n+  }\n+\n+  private final ExecuteActivityParameters parameters;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Failure> completionCallback;\n+\n+  private long startedCommandEventId;\n+\n+  /**\n+   * @param parameters attributes used to schedule an activity\n+   * @param completionCallback one of ActivityTaskCompletedEvent, ActivityTaskFailedEvent,\n+   *     ActivityTaskTimedOutEvent, ActivityTaskCanceledEvents\n+   * @param commandSink sink to send commands\n+   * @return an instance of ActivityCommands\n+   */\n+  public static ActivityStateMachine newInstance(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    return new ActivityStateMachine(parameters, completionCallback, commandSink);\n+  }\n+\n+  private ActivityStateMachine(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.parameters = parameters;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  public void createScheduleActivityTaskCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK)\n+            .setScheduleActivityTaskCommandAttributes(parameters.getAttributes())\n+            .build());\n+  }\n+\n+  public void cancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    } else {\n+      explicitEvent(ExplicitEvent.CANCEL);\n+    }\n+  }\n+\n+  private void setStartedCommandEventId() {\n+    startedCommandEventId = currentEvent.getEventId();\n+  }\n+\n+  private void cancelCommandNotifyCancelled() {\n+    cancelCommand();\n+    if (parameters.getCancellationType() != ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceledIfTryCancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.TRY_CANCEL) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceled() {\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+    Failure canceledFailure =\n+        Failure.newBuilder()\n+            .setSource(JAVA_SDK)\n+            .setCanceledFailureInfo(CanceledFailureInfo.getDefaultInstance())\n+            .build();\n+    ActivityFailureInfo activityFailureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "originalPosition": 279}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTA5ODg0", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463909884", "createdAt": "2020-08-09T22:54:27Z", "commit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjo1NDoyN1rOG9-ZEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjo1NDoyN1rOG9-ZEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzODU0NA==", "bodyText": "should this error message indicate the activity was canceled rather than timed out?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467638544", "createdAt": "2020-08-09T22:54:27Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import static io.temporal.failure.FailureConverter.JAVA_SDK;\n+\n+import io.temporal.activity.ActivityCancellationType;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RequestCancelActivityTaskCommandAttributes;\n+import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.ActivityTaskCanceledEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskCompletedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskFailedEventAttributes;\n+import io.temporal.api.history.v1.ActivityTaskTimedOutEventAttributes;\n+import io.temporal.internal.replay.ExecuteActivityParameters;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ActivityStateMachine.State, ActivityStateMachine.ExplicitEvent, ActivityStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SCHEDULE_COMMAND_CREATED,\n+    SCHEDULED_EVENT_RECORDED,\n+    STARTED,\n+    COMPLETED,\n+    FAILED,\n+    TIMED_OUT,\n+    CANCELED,\n+    SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+    STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+    COMPLETED_CANCEL_REQUESTED,\n+    FAILED_CANCEL_REQUESTED,\n+    CANCELED_CANCEL_REQUESTED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ActivityStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ActivityStateMachine>newInstance(\n+            \"Activity\",\n+            State.CREATED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.TIMED_OUT,\n+            State.CANCELED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ActivityStateMachine::createScheduleActivityTaskCommand)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK,\n+            State.SCHEDULE_COMMAND_CREATED)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED,\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ActivityStateMachine::setInitialCommandEventId)\n+        .add(\n+            State.SCHEDULE_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ActivityStateMachine::cancelCommandNotifyCancelled)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED,\n+            ActivityStateMachine::setStartedCommandEventId)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::notifyTimedOut)\n+        .add(\n+            State.SCHEDULED_EVENT_RECORDED,\n+            ExplicitEvent.CANCEL,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        /*\n+        This state transition is not possible.\n+        It looks like it is valid when an event, handling of which requests activity\n+        cancellation, precedes EVENT_TYPE_ACTIVITY_TASK_STARTED event.\n+        But as all code execution happens in the event loop the STARTED event is\n+        applied to the sate machine (as it is done for all command events before\n+        the event loop invocation) before the cancellation request.\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+             */\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCanceled)\n+        .add(\n+            State.SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED,\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            ActivityStateMachine::notifyCanceledIfTryCancel)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED)\n+        .add(\n+            State.STARTED,\n+            ExplicitEvent.CANCEL,\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            ActivityStateMachine::createRequestCancelActivityTaskCommand)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::cancelCommandNotifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::cancelCommandNotifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ActivityStateMachine::cancelCommandNotifyTimedOut)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED,\n+            State.FAILED,\n+            ActivityStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED,\n+            State.COMPLETED,\n+            ActivityStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED_ACTIVITY_CANCEL_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED,\n+            State.CANCELED,\n+            ActivityStateMachine::notifyCancellationFromEvent);\n+  }\n+\n+  private final ExecuteActivityParameters parameters;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Failure> completionCallback;\n+\n+  private long startedCommandEventId;\n+\n+  /**\n+   * @param parameters attributes used to schedule an activity\n+   * @param completionCallback one of ActivityTaskCompletedEvent, ActivityTaskFailedEvent,\n+   *     ActivityTaskTimedOutEvent, ActivityTaskCanceledEvents\n+   * @param commandSink sink to send commands\n+   * @return an instance of ActivityCommands\n+   */\n+  public static ActivityStateMachine newInstance(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    return new ActivityStateMachine(parameters, completionCallback, commandSink);\n+  }\n+\n+  private ActivityStateMachine(\n+      ExecuteActivityParameters parameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.parameters = parameters;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  public void createScheduleActivityTaskCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK)\n+            .setScheduleActivityTaskCommandAttributes(parameters.getAttributes())\n+            .build());\n+  }\n+\n+  public void cancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    } else {\n+      explicitEvent(ExplicitEvent.CANCEL);\n+    }\n+  }\n+\n+  private void setStartedCommandEventId() {\n+    startedCommandEventId = currentEvent.getEventId();\n+  }\n+\n+  private void cancelCommandNotifyCancelled() {\n+    cancelCommand();\n+    if (parameters.getCancellationType() != ActivityCancellationType.ABANDON) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceledIfTryCancel() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.TRY_CANCEL) {\n+      notifyCanceled();\n+    }\n+  }\n+\n+  private void notifyCanceled() {\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+    Failure canceledFailure =\n+        Failure.newBuilder()\n+            .setSource(JAVA_SDK)\n+            .setCanceledFailureInfo(CanceledFailureInfo.getDefaultInstance())\n+            .build();\n+    ActivityFailureInfo activityFailureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())\n+            .setActivityType(scheduleAttr.getActivityType())\n+            .setIdentity(\"workflow\")\n+            .setScheduledEventId(getInitialCommandEventId())\n+            .setStartedEventId(startedCommandEventId)\n+            .build();\n+    Failure failure =\n+        Failure.newBuilder()\n+            .setActivityFailureInfo(activityFailureInfo)\n+            .setCause(canceledFailure)\n+            .setMessage(\"Activity canceled\")\n+            .build();\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyCompleted() {\n+    ActivityTaskCompletedEventAttributes completedAttr =\n+        currentEvent.getActivityTaskCompletedEventAttributes();\n+    Optional<Payloads> result =\n+        completedAttr.hasResult() ? Optional.of(completedAttr.getResult()) : Optional.empty();\n+    completionCallback.apply(result, null);\n+  }\n+\n+  private void notifyFailed() {\n+    ActivityTaskFailedEventAttributes failed = currentEvent.getActivityTaskFailedEventAttributes();\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+    ActivityFailureInfo failureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())\n+            .setActivityType(scheduleAttr.getActivityType())\n+            .setIdentity(failed.getIdentity())\n+            .setRetryState(failed.getRetryState())\n+            .setScheduledEventId(failed.getScheduledEventId())\n+            .setStartedEventId(failed.getStartedEventId())\n+            .build();\n+    Failure failure =\n+        Failure.newBuilder()\n+            .setActivityFailureInfo(failureInfo)\n+            .setCause(failed.getFailure())\n+            .setMessage(\"Activity task failed\")\n+            .build();\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyTimedOut() {\n+    ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+\n+    ActivityTaskTimedOutEventAttributes timedOut =\n+        currentEvent.getActivityTaskTimedOutEventAttributes();\n+\n+    ActivityFailureInfo failureInfo =\n+        ActivityFailureInfo.newBuilder()\n+            .setActivityId(scheduleAttr.getActivityId())\n+            .setActivityType(scheduleAttr.getActivityType())\n+            .setRetryState(timedOut.getRetryState())\n+            .setScheduledEventId(timedOut.getScheduledEventId())\n+            .setStartedEventId(timedOut.getStartedEventId())\n+            .build();\n+    Failure failure =\n+        Failure.newBuilder()\n+            .setActivityFailureInfo(failureInfo)\n+            .setCause(timedOut.getFailure())\n+            .setMessage(\"Activity task timedOut\")\n+            .build();\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyCancellationFromEvent() {\n+    if (parameters.getCancellationType() == ActivityCancellationType.WAIT_CANCELLATION_COMPLETED) {\n+      ActivityTaskCanceledEventAttributes canceledAttr =\n+          currentEvent.getActivityTaskCanceledEventAttributes();\n+      Failure canceledFailure =\n+          Failure.newBuilder()\n+              .setSource(JAVA_SDK)\n+              .setCanceledFailureInfo(\n+                  CanceledFailureInfo.newBuilder().setDetails(canceledAttr.getDetails()))\n+              .build();\n+\n+      ScheduleActivityTaskCommandAttributes.Builder scheduleAttr = parameters.getAttributes();\n+      ActivityFailureInfo failureInfo =\n+          ActivityFailureInfo.newBuilder()\n+              .setActivityId(scheduleAttr.getActivityId())\n+              .setActivityType(scheduleAttr.getActivityType())\n+              .setScheduledEventId(canceledAttr.getScheduledEventId())\n+              .setStartedEventId(canceledAttr.getStartedEventId())\n+              .build();\n+      Failure failure =\n+          Failure.newBuilder()\n+              .setActivityFailureInfo(failureInfo)\n+              .setCause(canceledFailure)\n+              .setMessage(\"Activity task timedOut\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "originalPosition": 369}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTEwMDI1", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463910025", "createdAt": "2020-08-09T22:56:25Z", "commit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjo1NjoyNlrOG9-Z5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMjo1NjoyNlrOG9-Z5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzODc1Ng==", "bodyText": "Same comment as above file. Can we sort by source state?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467638756", "createdAt": "2020-08-09T22:56:26Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.puml", "diffHunk": "@@ -0,0 +1,54 @@\n+` Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+`\n+` Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+`\n+` Modifications copyright (C) 2017 Uber Technologies, Inc.\n+`\n+` Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+` use this file except in compliance with the License. A copy of the License is\n+` located at\n+`\n+` http://aws.amazon.com/apache2.0\n+`\n+` or in the \"license\" file accompanying this file. This file is distributed on\n+` an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+` express or implied. See the License for the specific language governing\n+` permissions and limitations under the License.\n+\n+` PlantUML <plantuml.com> State Diagram.\n+` Generated from src/main/java/io/temporal/internal/statemachines/ActivityStateMachine.java\n+` by io.temporal.internal.statemachines.CommandsGeneratePlantUMLStateDiagrams.\n+\n+\n+@startuml\n+scale 350 width\n+[*] --> CREATED\n+CREATED --> SCHEDULE_COMMAND_CREATED: SCHEDULE\n+SCHEDULE_COMMAND_CREATED --> SCHEDULE_COMMAND_CREATED: SCHEDULE_ACTIVITY_TASK\n+SCHEDULE_COMMAND_CREATED --> SCHEDULED_EVENT_RECORDED: ACTIVITY_TASK_SCHEDULED\n+SCHEDULE_COMMAND_CREATED --> CANCELED: CANCEL\n+SCHEDULED_EVENT_RECORDED --> STARTED: ACTIVITY_TASK_STARTED\n+SCHEDULED_EVENT_RECORDED --> TIMED_OUT: ACTIVITY_TASK_TIMED_OUT\n+STARTED --> COMPLETED: ACTIVITY_TASK_COMPLETED\n+STARTED --> FAILED: ACTIVITY_TASK_FAILED\n+STARTED --> TIMED_OUT: ACTIVITY_TASK_TIMED_OUT\n+SCHEDULED_EVENT_RECORDED --> SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED: CANCEL\n+SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED --> SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED: ACTIVITY_TASK_CANCEL_REQUESTED\n+SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED --> SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED: REQUEST_CANCEL_ACTIVITY_TASK\n+SCHEDULED_ACTIVITY_CANCEL_COMMAND_CREATED --> TIMED_OUT: ACTIVITY_TASK_TIMED_OUT\n+SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED --> CANCELED: ACTIVITY_TASK_CANCELED\n+SCHEDULED_ACTIVITY_CANCEL_EVENT_RECORDED --> STARTED_ACTIVITY_CANCEL_EVENT_RECORDED: ACTIVITY_TASK_STARTED\n+STARTED_ACTIVITY_CANCEL_COMMAND_CREATED --> STARTED_ACTIVITY_CANCEL_EVENT_RECORDED: ACTIVITY_TASK_CANCEL_REQUESTED\n+STARTED_ACTIVITY_CANCEL_COMMAND_CREATED --> STARTED_ACTIVITY_CANCEL_COMMAND_CREATED: REQUEST_CANCEL_ACTIVITY_TASK\n+STARTED --> STARTED_ACTIVITY_CANCEL_COMMAND_CREATED: CANCEL", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/190f3f1645864fc9bc1ec0e22f6b5f994656b7d4", "committedDate": "2020-08-09T23:11:31Z", "message": "Added more activity state machine tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTExMTY0", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463911164", "createdAt": "2020-08-09T23:12:19Z", "commit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzoxMjoxOVrOG9-f6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzoxMjoxOVrOG9-f6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MDI5OQ==", "bodyText": "[Nit] this variable name (commands) seems off?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467640299", "createdAt": "2020-08-09T23:12:19Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/CancellableCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import java.util.Objects;\n+\n+class CancellableCommand {\n+\n+  private final Command command;\n+  private final EntityStateMachine commands;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTExMjYy", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463911262", "createdAt": "2020-08-09T23:13:46Z", "commit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzoxMzo0NlrOG9-gdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzoxMzo0NlrOG9-gdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MDQzOA==", "bodyText": "\"NewCommand\" --> \"CancellableCommand\"", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467640438", "createdAt": "2020-08-09T23:13:46Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/CancellableCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import java.util.Objects;\n+\n+class CancellableCommand {\n+\n+  private final Command command;\n+  private final EntityStateMachine commands;\n+  private boolean canceled;\n+\n+  public CancellableCommand(Command command, EntityStateMachine commands) {\n+    this.command = Objects.requireNonNull(command);\n+    this.commands = Objects.requireNonNull(commands);\n+  }\n+\n+  public Command getCommand() {\n+    if (canceled) {\n+      throw new IllegalStateException(\"canceled\");\n+    }\n+    return command;\n+  }\n+\n+  public boolean isCanceled() {\n+    return canceled;\n+  }\n+\n+  public void cancel() {\n+    canceled = true;\n+  }\n+\n+  public EntityStateMachine getStateMachine() {\n+    return commands;\n+  }\n+\n+  public CommandType getCommandType() {\n+    return command.getCommandType();\n+  }\n+\n+  public void handleCommand(CommandType commandType) {\n+    if (!canceled) {\n+      commands.handleCommand(commandType);\n+    }\n+  }\n+\n+  public WorkflowStateMachines.HandleEventStatus handleEvent(\n+      HistoryEvent event, boolean hasNextEvent) {\n+    if (canceled) {\n+      return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;\n+    }\n+    return commands.handleEvent(event, hasNextEvent);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"NewCommand{\" + \"command=\" + command + \", canceled=\" + canceled + '}';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1e3fa6db2903db82312a1b256c2a8046f098737"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTExODA4", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463911808", "createdAt": "2020-08-09T23:21:13Z", "commit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzoyMToxM1rOG9-jlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzoyMToxM1rOG9-jlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MTIzNw==", "bodyText": "why do we need to set the stack trace here, but not for terminated?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467641237", "createdAt": "2020-08-09T23:21:13Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/ChildWorkflowStateMachine.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.enums.v1.TimeoutType;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes;\n+import io.temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.client.WorkflowExecutionAlreadyStarted;\n+import io.temporal.common.converter.EncodedValues;\n+import io.temporal.failure.CanceledFailure;\n+import io.temporal.failure.ChildWorkflowFailure;\n+import io.temporal.failure.TerminatedFailure;\n+import io.temporal.failure.TimeoutFailure;\n+import io.temporal.internal.replay.ChildWorkflowTaskFailedException;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ChildWorkflowStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ChildWorkflowStateMachine.State,\n+        ChildWorkflowStateMachine.ExplicitEvent,\n+        ChildWorkflowStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_EVENT_RECORDED,\n+    STARTED,\n+    START_FAILED,\n+    COMPLETED,\n+    FAILED,\n+    CANCELED,\n+    TIMED_OUT,\n+    TERMINATED,\n+  }\n+\n+  private static StateMachine<State, ExplicitEvent, ChildWorkflowStateMachine> newStateMachine() {\n+    return StateMachine.<State, ExplicitEvent, ChildWorkflowStateMachine>newInstance(\n+            \"ChildWorkflow\",\n+            State.CREATED,\n+            State.START_FAILED,\n+            State.COMPLETED,\n+            State.FAILED,\n+            State.CANCELED,\n+            State.TIMED_OUT,\n+            State.TERMINATED)\n+        .add(\n+            State.CREATED,\n+            ExplicitEvent.SCHEDULE,\n+            State.START_COMMAND_CREATED,\n+            ChildWorkflowStateMachine::createStartChildCommand)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION,\n+            State.START_COMMAND_CREATED)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED,\n+            State.START_EVENT_RECORDED,\n+            EntityStateMachineInitialCommand::setInitialCommandEventId)\n+        .add(\n+            State.START_COMMAND_CREATED,\n+            ExplicitEvent.CANCEL,\n+            State.CANCELED,\n+            ChildWorkflowStateMachine::cancelStartChildCommand)\n+        .add(\n+            State.START_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED,\n+            State.STARTED,\n+            ChildWorkflowStateMachine::notifyStarted)\n+        .add(\n+            State.START_EVENT_RECORDED,\n+            EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED,\n+            State.START_FAILED,\n+            ChildWorkflowStateMachine::notifyStartFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED,\n+            State.COMPLETED,\n+            ChildWorkflowStateMachine::notifyCompleted)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED,\n+            State.FAILED,\n+            ChildWorkflowStateMachine::notifyFailed)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT,\n+            State.TIMED_OUT,\n+            ChildWorkflowStateMachine::notifyTimedOut)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED,\n+            State.CANCELED,\n+            ChildWorkflowStateMachine::notifyCanceled)\n+        .add(\n+            State.STARTED,\n+            EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED,\n+            State.TERMINATED,\n+            ChildWorkflowStateMachine::notifyTerminated);\n+  }\n+\n+  private final StartChildWorkflowExecutionCommandAttributes startAttributes;\n+\n+  private final Functions.Proc1<WorkflowExecution> startedCallback;\n+\n+  private final Functions.Proc2<Optional<Payloads>, Exception> completionCallback;\n+\n+  /**\n+   * Creates a new child workflow state machine\n+   *\n+   * @param attributes child workflow start command attributes\n+   * @param startedCallback\n+   * @param completionCallback invoked when child reports completion or failure. The following types\n+   *     of events can be passed to the callback: StartChildWorkflowExecutionFailedEvent,\n+   *     ChildWorkflowExecutionCompletedEvent, ChildWorkflowExecutionFailedEvent,\n+   *     ChildWorkflowExecutionTimedOutEvent, ChildWorkflowExecutionCanceledEvent,\n+   *     ChildWorkflowExecutionTerminatedEvent.\n+   * @return cancellation callback that should be invoked to cancel the child\n+   */\n+  public static ChildWorkflowStateMachine newInstance(\n+      StartChildWorkflowExecutionCommandAttributes attributes,\n+      Functions.Proc1<WorkflowExecution> startedCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    return new ChildWorkflowStateMachine(\n+        attributes, startedCallback, completionCallback, commandSink);\n+  }\n+\n+  private ChildWorkflowStateMachine(\n+      StartChildWorkflowExecutionCommandAttributes startAttributes,\n+      Functions.Proc1<WorkflowExecution> startedCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    super(newStateMachine(), commandSink);\n+    this.startAttributes = startAttributes;\n+    this.startedCallback = startedCallback;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  public void createStartChildCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION)\n+            .setStartChildWorkflowExecutionCommandAttributes(startAttributes)\n+            .build());\n+  }\n+\n+  public boolean isCancellable() {\n+    return State.START_COMMAND_CREATED == getState();\n+  }\n+\n+  /**\n+   * Cancellation through this class is valid only when start child workflow command is not sent\n+   * yet. Cancellation of an initiated child workflow is done through CancelExternalCommands. So all\n+   * of the types besides ABANDON are treated differently.\n+   */\n+  public void cancel() {\n+    if (!isFinalState()) {\n+      explicitEvent(ExplicitEvent.CANCEL);\n+    }\n+  }\n+\n+  private void cancelStartChildCommand() {\n+    cancelCommand();\n+    RuntimeException failure =\n+        new ChildWorkflowFailure(\n+            0,\n+            0,\n+            startAttributes.getWorkflowType().getName(),\n+            WorkflowExecution.newBuilder().setWorkflowId(startAttributes.getWorkflowId()).build(),\n+            startAttributes.getNamespace(),\n+            RetryState.RETRY_STATE_NON_RETRYABLE_FAILURE,\n+            new CanceledFailure(\"Child immediately canceled\", null, null));\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyCompleted() {\n+    ChildWorkflowExecutionCompletedEventAttributes attributes =\n+        currentEvent.getChildWorkflowExecutionCompletedEventAttributes();\n+    Optional<Payloads> result =\n+        attributes.hasResult() ? Optional.of(attributes.getResult()) : Optional.empty();\n+    completionCallback.apply(result, null);\n+  }\n+\n+  private void notifyStartFailed() {\n+    StartChildWorkflowExecutionFailedEventAttributes attributes =\n+        currentEvent.getStartChildWorkflowExecutionFailedEventAttributes();\n+    Exception failure =\n+        new ChildWorkflowTaskFailedException(\n+            currentEvent.getEventId(),\n+            WorkflowExecution.newBuilder().setWorkflowId(attributes.getWorkflowId()).build(),\n+            attributes.getWorkflowType(),\n+            RetryState.RETRY_STATE_NON_RETRYABLE_FAILURE,\n+            null);\n+    failure.initCause(\n+        new WorkflowExecutionAlreadyStarted(\n+            WorkflowExecution.newBuilder().setWorkflowId(attributes.getWorkflowId()).build(),\n+            attributes.getWorkflowType().getName(),\n+            null));\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyFailed() {\n+    ChildWorkflowExecutionFailedEventAttributes attributes =\n+        currentEvent.getChildWorkflowExecutionFailedEventAttributes();\n+    RuntimeException failure =\n+        new ChildWorkflowTaskFailedException(\n+            currentEvent.getEventId(),\n+            attributes.getWorkflowExecution(),\n+            attributes.getWorkflowType(),\n+            attributes.getRetryState(),\n+            attributes.getFailure());\n+    completionCallback.apply(Optional.empty(), failure);\n+  }\n+\n+  private void notifyTimedOut() {\n+    ChildWorkflowExecutionTimedOutEventAttributes attributes =\n+        currentEvent.getChildWorkflowExecutionTimedOutEventAttributes();\n+    TimeoutFailure timeoutFailure =\n+        new TimeoutFailure(null, null, TimeoutType.TIMEOUT_TYPE_START_TO_CLOSE);\n+    timeoutFailure.setStackTrace(new StackTraceElement[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "originalPosition": 256}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTEzODU5", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463913859", "createdAt": "2020-08-09T23:36:21Z", "commit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzozNjoyMVrOG9-p5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzozNjoyMVrOG9-p5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0Mjg1Mg==", "bodyText": "[Nit] toString value does not match class name", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467642852", "createdAt": "2020-08-09T23:36:21Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/DynamicTransitionAction.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/** Action that can dynamically decide to which state to transition. */\n+class DynamicTransitionAction<State, Data> implements TransitionAction<State, Data> {\n+\n+  final DynamicCallback<State, Data> callback;\n+  State[] expectedStates;\n+  State state;\n+\n+  DynamicTransitionAction(State[] expectedStates, DynamicCallback<State, Data> callback) {\n+    this.expectedStates = expectedStates;\n+    this.callback = callback;\n+  }\n+\n+  @Override\n+  public String toString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTE0MDQ3", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463914047", "createdAt": "2020-08-09T23:38:32Z", "commit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzozODozMlrOG9-qvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzozODozMlrOG9-qvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MzA2OA==", "bodyText": "[Nit] typo in comment", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467643068", "createdAt": "2020-08-09T23:38:32Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/EntityStateMachineBase.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.workflow.Functions;\n+\n+class EntityStateMachineBase<State, ExplicitEvent, Data> implements EntityStateMachine {\n+\n+  private final StateMachine<State, ExplicitEvent, Data> stateMachine;\n+\n+  protected final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  protected HistoryEvent currentEvent;\n+  protected boolean hasNextEvent;\n+\n+  public EntityStateMachineBase(\n+      StateMachine<State, ExplicitEvent, Data> stateMachine,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    this.stateMachine = stateMachine;\n+    this.commandSink = commandSink;\n+  }\n+\n+  /**\n+   * Notifies that command is included into zthe workflow task completion result.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTE0MzQ4", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463914348", "createdAt": "2020-08-09T23:41:51Z", "commit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzo0MTo1MVrOG9-sKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzo0MTo1MVrOG9-sKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MzQzMw==", "bodyText": "worth printing out some of the other class members here?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467643433", "createdAt": "2020-08-09T23:41:51Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/EntityStateMachineBase.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.workflow.Functions;\n+\n+class EntityStateMachineBase<State, ExplicitEvent, Data> implements EntityStateMachine {\n+\n+  private final StateMachine<State, ExplicitEvent, Data> stateMachine;\n+\n+  protected final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  protected HistoryEvent currentEvent;\n+  protected boolean hasNextEvent;\n+\n+  public EntityStateMachineBase(\n+      StateMachine<State, ExplicitEvent, Data> stateMachine,\n+      Functions.Proc1<CancellableCommand> commandSink) {\n+    this.stateMachine = stateMachine;\n+    this.commandSink = commandSink;\n+  }\n+\n+  /**\n+   * Notifies that command is included into zthe workflow task completion result.\n+   *\n+   * <p>Is not called for commands generated during replay.\n+   */\n+  @Override\n+  public void handleCommand(CommandType commandType) {\n+    stateMachine.handleCommand(commandType, (Data) this);\n+  }\n+\n+  @Override\n+  public WorkflowStateMachines.HandleEventStatus handleEvent(\n+      HistoryEvent event, boolean hasNextEvent) {\n+    if (!stateMachine.getValidEventTypes().contains(event.getEventType())) {\n+      return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;\n+    }\n+    this.currentEvent = event;\n+    this.hasNextEvent = hasNextEvent;\n+    try {\n+      stateMachine.handleHistoryEvent(event.getEventType(), (Data) this);\n+    } finally {\n+      this.currentEvent = null;\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public void handleWorkflowTaskStarted() {}\n+\n+  protected final void explicitEvent(ExplicitEvent explicitEvent) {\n+    stateMachine.handleExplicitEvent(explicitEvent, (Data) this);\n+  }\n+\n+  @Override\n+  public boolean isFinalState() {\n+    return stateMachine.isFinalState();\n+  }\n+\n+  protected State getState() {\n+    return stateMachine.getState();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return this.getClass().getSimpleName() + \"{\" + \"state=\" + stateMachine + '}';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTE0NDkw", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463914490", "createdAt": "2020-08-09T23:43:33Z", "commit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzo0MzozM1rOG9-svw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMzo0MzozM1rOG9-svw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0MzU4Mw==", "bodyText": "[Nit] class doesn't match string value here as well. Also action= vs callback=", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467643583", "createdAt": "2020-08-09T23:43:33Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/FixedTransitionAction.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.workflow.Functions;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/** Action that can transition to exactly one state. */\n+class FixedTransitionAction<State, Data> implements TransitionAction<State, Data> {\n+\n+  final State state;\n+\n+  final Functions.Proc1<Data> action;\n+\n+  FixedTransitionAction(State state, Functions.Proc1<Data> action) {\n+    this.state = state;\n+    this.action = action;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"TransitionDestination{\" + \"state=\" + state + \", callback=\" + action + '}';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTE2NTkz", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463916593", "createdAt": "2020-08-10T00:07:26Z", "commit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMDowNzoyNlrOG9-2pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMDowNzoyNlrOG9-2pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0NjExOA==", "bodyText": "what is this timeout? is it in ms? should we have a constant/take a duration here?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467646118", "createdAt": "2020-08-10T00:07:26Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/sync/TestActivityEnvironmentInternal.java", "diffHunk": "@@ -115,6 +114,7 @@ public TestActivityEnvironmentInternal(TestEnvironmentOptions options) {\n             WorkflowServiceStubsOptions.newBuilder()\n                 .setChannel(channel)\n                 .setMetricsScope(options.getMetricsScope())\n+                .setQueryRpcTimeout(600000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTE2ODYz", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-463916863", "createdAt": "2020-08-10T00:10:48Z", "commit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMDoxMDo0OFrOG9-4AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwMDoxMDo0OFrOG9-4AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0NjQ2NQ==", "bodyText": "[Nit] let's update the strings for these two variables as well", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r467646465", "createdAt": "2020-08-10T00:10:48Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/worker/WorkerOptions.java", "diffHunk": "@@ -301,15 +304,15 @@ public int hashCode() {\n   public String toString() {\n     return \"WorkerOptions{\"\n         + \"maxActivitiesPerSecond=\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "190f3f1645864fc9bc1ec0e22f6b5f994656b7d4"}, "originalPosition": 191}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6ed96a2af365097f5a72b39719e9171a58c5982", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/f6ed96a2af365097f5a72b39719e9171a58c5982", "committedDate": "2020-08-10T00:32:05Z", "message": "Created StateMachineDefinition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f94e9ec0929fe844dbfc56cde820525b51af751e", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/f94e9ec0929fe844dbfc56cde820525b51af751e", "committedDate": "2020-08-10T00:33:06Z", "message": "missing final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef3e87049571406b9fd67df2de6bb434c57ebf69", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/ef3e87049571406b9fd67df2de6bb434c57ebf69", "committedDate": "2020-08-10T01:34:19Z", "message": "Added state diagram coverage diagram"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb1dfd93f2ed4ca0a9ee1e85786af0d623a5ddc3", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/eb1dfd93f2ed4ca0a9ee1e85786af0d623a5ddc3", "committedDate": "2020-08-10T18:00:19Z", "message": "100% coverage of ActivityStateMachine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24e6d7fcc92f27792e3ce5cf686354d1e4331dbc", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/24e6d7fcc92f27792e3ce5cf686354d1e4331dbc", "committedDate": "2020-08-10T19:16:29Z", "message": "PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49713bd7f6295302a4de1f6464a27f527c9d4c0e", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/49713bd7f6295302a4de1f6464a27f527c9d4c0e", "committedDate": "2020-08-10T23:57:03Z", "message": "UnsupportedVersion exception. Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a22826a95e370fd13a7411aa5aa79a7644155f8", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/8a22826a95e370fd13a7411aa5aa79a7644155f8", "committedDate": "2020-08-11T00:07:11Z", "message": "Updated order of state transition in activity state machine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8ba786486a338f55a38b0c08f419610105ca5c3", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/a8ba786486a338f55a38b0c08f419610105ca5c3", "committedDate": "2020-08-11T00:51:40Z", "message": "Sort of the PlantUML diagrams"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5397c1734caed50fea7a179c362243eda2db0e74", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/5397c1734caed50fea7a179c362243eda2db0e74", "committedDate": "2020-08-11T01:13:46Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/731f9022dc2ad7f599084a66bdeb82658cb1456a", "committedDate": "2020-08-11T03:35:50Z", "message": "Added coverage to LocalActivityStateMachineTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzI1OTg4", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464725988", "createdAt": "2020-08-11T03:36:10Z", "commit": {"oid": "5397c1734caed50fea7a179c362243eda2db0e74"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzozNjoxMFrOG-nMYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzozNjoxMFrOG-nMYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzA0MA==", "bodyText": "Interesting that signalExternalWorkflowExecution is cancelable. What is the scenario for that?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468307040", "createdAt": "2020-08-11T03:36:10Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowContextImpl.java", "diffHunk": "@@ -214,183 +207,127 @@ public SearchAttributes getSearchAttributes() {\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleActivityTask(\n-      ExecuteActivityParameters parameters, BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return activityClient.scheduleActivityTask(parameters, callback);\n+  public Functions.Proc1<Exception> scheduleActivityTask(\n+      ExecuteActivityParameters parameters, Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    ScheduleActivityTaskCommandAttributes.Builder attributes = parameters.getAttributes();\n+    if (attributes.getActivityId().isEmpty()) {\n+      attributes.setActivityId(workflowStateMachines.randomUUID().toString());\n+    }\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.scheduleActivityTask(parameters, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleLocalActivityTask(\n+  public Functions.Proc scheduleLocalActivityTask(\n       ExecuteLocalActivityParameters parameters,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClock.scheduleLocalActivityTask(parameters, callback);\n+      Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    return workflowStateMachines.scheduleLocalActivityTask(parameters, callback);\n   }\n \n   @Override\n-  public Consumer<Exception> startChildWorkflow(\n+  public Functions.Proc1<Exception> startChildWorkflow(\n       StartChildWorkflowExecutionParameters parameters,\n-      Consumer<WorkflowExecution> executionCallback,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClient.startChildWorkflow(parameters, executionCallback, callback);\n+      Functions.Proc1<WorkflowExecution> executionCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> callback) {\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.startChildWorkflow(parameters, executionCallback, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> signalWorkflowExecution(\n+  public Functions.Proc1<Exception> signalExternalWorkflowExecution(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5397c1734caed50fea7a179c362243eda2db0e74"}, "originalPosition": 153}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzI2MzA2", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464726306", "createdAt": "2020-08-11T03:37:28Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzozNzoyOFrOG-nNhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzozNzoyOFrOG-nNhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzMzMg==", "bodyText": "Can we do <= here?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468307332", "createdAt": "2020-08-11T03:37:28Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowContextImpl.java", "diffHunk": "@@ -214,183 +207,127 @@ public SearchAttributes getSearchAttributes() {\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleActivityTask(\n-      ExecuteActivityParameters parameters, BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return activityClient.scheduleActivityTask(parameters, callback);\n+  public Functions.Proc1<Exception> scheduleActivityTask(\n+      ExecuteActivityParameters parameters, Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    ScheduleActivityTaskCommandAttributes.Builder attributes = parameters.getAttributes();\n+    if (attributes.getActivityId().isEmpty()) {\n+      attributes.setActivityId(workflowStateMachines.randomUUID().toString());\n+    }\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.scheduleActivityTask(parameters, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleLocalActivityTask(\n+  public Functions.Proc scheduleLocalActivityTask(\n       ExecuteLocalActivityParameters parameters,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClock.scheduleLocalActivityTask(parameters, callback);\n+      Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    return workflowStateMachines.scheduleLocalActivityTask(parameters, callback);\n   }\n \n   @Override\n-  public Consumer<Exception> startChildWorkflow(\n+  public Functions.Proc1<Exception> startChildWorkflow(\n       StartChildWorkflowExecutionParameters parameters,\n-      Consumer<WorkflowExecution> executionCallback,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClient.startChildWorkflow(parameters, executionCallback, callback);\n+      Functions.Proc1<WorkflowExecution> executionCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> callback) {\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.startChildWorkflow(parameters, executionCallback, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> signalWorkflowExecution(\n+  public Functions.Proc1<Exception> signalExternalWorkflowExecution(\n       SignalExternalWorkflowExecutionCommandAttributes.Builder attributes,\n-      BiConsumer<Void, Exception> callback) {\n-    return workflowClient.signalWorkflowExecution(attributes, callback);\n+      Functions.Proc2<Void, Failure> callback) {\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.signalExternalWorkflowExecution(attributes.build(), callback);\n+    return (e) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Promise<Void> requestCancelWorkflowExecution(WorkflowExecution execution) {\n-    workflowClient.requestCancelWorkflowExecution(execution);\n-    // TODO: Make promise return success or failure of the cancellation request.\n-    return Workflow.newPromise(null);\n+  public void requestCancelExternalWorkflowExecution(\n+      WorkflowExecution execution, Functions.Proc2<Void, RuntimeException> callback) {\n+    RequestCancelExternalWorkflowExecutionCommandAttributes attributes =\n+        RequestCancelExternalWorkflowExecutionCommandAttributes.newBuilder()\n+            .setWorkflowId(execution.getWorkflowId())\n+            .setRunId(execution.getRunId())\n+            .build();\n+    workflowStateMachines.requestCancelExternalWorkflowExecution(attributes, callback);\n   }\n \n   @Override\n   public void continueAsNewOnCompletion(\n       ContinueAsNewWorkflowExecutionCommandAttributes attributes) {\n-    workflowClient.continueAsNewOnCompletion(attributes);\n-  }\n-\n-  void setReplayCurrentTimeMilliseconds(long replayCurrentTimeMilliseconds) {\n-    if (replayCurrentTimeMilliseconds < workflowClock.currentTimeMillis()) {\n-      if (log.isWarnEnabled()) {\n-        log.warn(\n-            \"Trying to set workflow clock back from \"\n-                + workflowClock.currentTimeMillis()\n-                + \" to \"\n-                + replayCurrentTimeMilliseconds\n-                + \". This will be a no-op.\");\n-      }\n-      return;\n-    }\n-    workflowClock.setReplayCurrentTimeMilliseconds(replayCurrentTimeMilliseconds);\n+    workflowContext.setContinueAsNewOnCompletion(attributes);\n   }\n \n   long getReplayCurrentTimeMilliseconds() {\n-    return workflowClock.currentTimeMillis();\n+    return workflowStateMachines.currentTimeMillis();\n   }\n \n   @Override\n   public boolean isReplaying() {\n-    return workflowClock.isReplaying();\n+    return workflowStateMachines.isReplaying();\n   }\n \n   @Override\n-  public Consumer<Exception> createTimer(Duration delay, Consumer<Exception> callback) {\n-    return workflowClock.createTimer(delay, callback);\n+  public Functions.Proc1<RuntimeException> newTimer(\n+      Duration delay, Functions.Proc1<RuntimeException> callback) {\n+    if (delay == Duration.ZERO) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzI2NzY4", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464726768", "createdAt": "2020-08-11T03:39:11Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzozOToxMlrOG-nPBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzozOToxMlrOG-nPBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwNzcxOQ==", "bodyText": "[Super-Nit] Canceled vs Cancelled", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468307719", "createdAt": "2020-08-11T03:39:12Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowContextImpl.java", "diffHunk": "@@ -214,183 +207,127 @@ public SearchAttributes getSearchAttributes() {\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleActivityTask(\n-      ExecuteActivityParameters parameters, BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return activityClient.scheduleActivityTask(parameters, callback);\n+  public Functions.Proc1<Exception> scheduleActivityTask(\n+      ExecuteActivityParameters parameters, Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    ScheduleActivityTaskCommandAttributes.Builder attributes = parameters.getAttributes();\n+    if (attributes.getActivityId().isEmpty()) {\n+      attributes.setActivityId(workflowStateMachines.randomUUID().toString());\n+    }\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.scheduleActivityTask(parameters, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> scheduleLocalActivityTask(\n+  public Functions.Proc scheduleLocalActivityTask(\n       ExecuteLocalActivityParameters parameters,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClock.scheduleLocalActivityTask(parameters, callback);\n+      Functions.Proc2<Optional<Payloads>, Failure> callback) {\n+    return workflowStateMachines.scheduleLocalActivityTask(parameters, callback);\n   }\n \n   @Override\n-  public Consumer<Exception> startChildWorkflow(\n+  public Functions.Proc1<Exception> startChildWorkflow(\n       StartChildWorkflowExecutionParameters parameters,\n-      Consumer<WorkflowExecution> executionCallback,\n-      BiConsumer<Optional<Payloads>, Exception> callback) {\n-    return workflowClient.startChildWorkflow(parameters, executionCallback, callback);\n+      Functions.Proc1<WorkflowExecution> executionCallback,\n+      Functions.Proc2<Optional<Payloads>, Exception> callback) {\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.startChildWorkflow(parameters, executionCallback, callback);\n+    return (exception) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Consumer<Exception> signalWorkflowExecution(\n+  public Functions.Proc1<Exception> signalExternalWorkflowExecution(\n       SignalExternalWorkflowExecutionCommandAttributes.Builder attributes,\n-      BiConsumer<Void, Exception> callback) {\n-    return workflowClient.signalWorkflowExecution(attributes, callback);\n+      Functions.Proc2<Void, Failure> callback) {\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.signalExternalWorkflowExecution(attributes.build(), callback);\n+    return (e) -> cancellationHandler.apply();\n   }\n \n   @Override\n-  public Promise<Void> requestCancelWorkflowExecution(WorkflowExecution execution) {\n-    workflowClient.requestCancelWorkflowExecution(execution);\n-    // TODO: Make promise return success or failure of the cancellation request.\n-    return Workflow.newPromise(null);\n+  public void requestCancelExternalWorkflowExecution(\n+      WorkflowExecution execution, Functions.Proc2<Void, RuntimeException> callback) {\n+    RequestCancelExternalWorkflowExecutionCommandAttributes attributes =\n+        RequestCancelExternalWorkflowExecutionCommandAttributes.newBuilder()\n+            .setWorkflowId(execution.getWorkflowId())\n+            .setRunId(execution.getRunId())\n+            .build();\n+    workflowStateMachines.requestCancelExternalWorkflowExecution(attributes, callback);\n   }\n \n   @Override\n   public void continueAsNewOnCompletion(\n       ContinueAsNewWorkflowExecutionCommandAttributes attributes) {\n-    workflowClient.continueAsNewOnCompletion(attributes);\n-  }\n-\n-  void setReplayCurrentTimeMilliseconds(long replayCurrentTimeMilliseconds) {\n-    if (replayCurrentTimeMilliseconds < workflowClock.currentTimeMillis()) {\n-      if (log.isWarnEnabled()) {\n-        log.warn(\n-            \"Trying to set workflow clock back from \"\n-                + workflowClock.currentTimeMillis()\n-                + \" to \"\n-                + replayCurrentTimeMilliseconds\n-                + \". This will be a no-op.\");\n-      }\n-      return;\n-    }\n-    workflowClock.setReplayCurrentTimeMilliseconds(replayCurrentTimeMilliseconds);\n+    workflowContext.setContinueAsNewOnCompletion(attributes);\n   }\n \n   long getReplayCurrentTimeMilliseconds() {\n-    return workflowClock.currentTimeMillis();\n+    return workflowStateMachines.currentTimeMillis();\n   }\n \n   @Override\n   public boolean isReplaying() {\n-    return workflowClock.isReplaying();\n+    return workflowStateMachines.isReplaying();\n   }\n \n   @Override\n-  public Consumer<Exception> createTimer(Duration delay, Consumer<Exception> callback) {\n-    return workflowClock.createTimer(delay, callback);\n+  public Functions.Proc1<RuntimeException> newTimer(\n+      Duration delay, Functions.Proc1<RuntimeException> callback) {\n+    if (delay == Duration.ZERO) {\n+      callback.apply(null);\n+      return (e) -> {};\n+    }\n+    StartTimerCommandAttributes attributes =\n+        StartTimerCommandAttributes.newBuilder()\n+            .setStartToFireTimeout(ProtobufTimeUtils.ToProtoDuration(delay))\n+            .setTimerId(workflowStateMachines.randomUUID().toString())\n+            .build();\n+    Functions.Proc cancellationHandler =\n+        workflowStateMachines.newTimer(attributes, (event) -> handleTimerCallback(callback, event));\n+    return (e) -> cancellationHandler.apply();\n+  }\n+\n+  private void handleTimerCallback(Functions.Proc1<RuntimeException> callback, HistoryEvent event) {\n+    switch (event.getEventType()) {\n+      case EVENT_TYPE_TIMER_FIRED:\n+        {\n+          callback.apply(null);\n+          return;\n+        }\n+      case EVENT_TYPE_TIMER_CANCELED:\n+        {\n+          CanceledFailure exception = new CanceledFailure(\"Cancelled by request\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 239}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzI3Mzky", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464727392", "createdAt": "2020-08-11T03:41:23Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo0MToyM1rOG-nRKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo0MToyM1rOG-nRKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwODI2NA==", "bodyText": "Canceled vs Cancelled", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468308264", "createdAt": "2020-08-11T03:41:23Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java", "diffHunk": "@@ -295,32 +190,27 @@ private void eventLoop() {\n       failure = workflow.mapUnexpectedException(e);\n       completed = true;\n     }\n-  }\n-\n-  private void mayBeCompleteWorkflow() {\n     if (completed) {\n       completeWorkflow();\n-    } else {\n-      updateTimers();\n     }\n   }\n \n   private void completeWorkflow() {\n     if (failure != null) {\n-      commandHelper.failWorkflowExecution(failure);\n+      workflowStateMachines.newFailWorkflow(failure.getFailure());\n       metricsScope.counter(MetricsType.WORKFLOW_FAILED_COUNTER).inc(1);\n     } else if (cancelRequested) {\n-      commandHelper.cancelWorkflowExecution();\n+      workflowStateMachines.newCancelWorkflow();\n       metricsScope.counter(MetricsType.WORKFLOW_CANCELLED_COUNTER).inc(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 327}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzI3OTIy", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464727922", "createdAt": "2020-08-11T03:43:18Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo0MzoxOFrOG-nS6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo0MzoxOFrOG-nS6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwODcxMw==", "bodyText": "[Nit] kinda strange that some of these methods communicate their results via return values while others communicate using instance members of the class.", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468308713", "createdAt": "2020-08-11T03:43:18Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java", "diffHunk": "@@ -395,96 +242,48 @@ private void handleWorkflowExecutionSignaled(HistoryEvent event) {\n   }\n \n   @Override\n-  public WorkflowTaskResult handleWorkflowTask(PollWorkflowTaskQueueResponseOrBuilder workflowTask)\n-      throws Throwable {\n+  public WorkflowTaskResult handleWorkflowTask(\n+      PollWorkflowTaskQueueResponseOrBuilder workflowTask) {\n     lock.lock();\n     try {\n+      long startTime = System.currentTimeMillis();\n       queryResults.clear();\n-      boolean forceCreateNewWorkflowTask = handleWorkflowTaskImpl(workflowTask, null);\n-      return new WorkflowTaskResult(\n-          commandHelper.getCommands(), queryResults, forceCreateNewWorkflowTask, completed);\n+      handleWorkflowTaskImpl(workflowTask);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 422}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzI5Mzg5", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464729389", "createdAt": "2020-08-11T03:48:39Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo0ODozOVrOG-nYEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo0ODozOVrOG-nYEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMDAzNA==", "bodyText": "this is a strange name for a variable (timeoutInterval) especially as it just seems to represent the elapsed amount of time / 2? This interval will simply get bigger as the while loop continues to run right?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468310034", "createdAt": "2020-08-11T03:48:39Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java", "diffHunk": "@@ -622,27 +341,76 @@ public void close() {\n \n   @Override\n   public Optional<Payloads> handleQueryWorkflowTask(\n-      PollWorkflowTaskQueueResponseOrBuilder response, WorkflowQuery query) throws Throwable {\n+      PollWorkflowTaskQueueResponseOrBuilder workflowTask, WorkflowQuery query) {\n     lock.lock();\n     try {\n       AtomicReference<Optional<Payloads>> result = new AtomicReference<>();\n-      handleWorkflowTaskImpl(response, () -> result.set(workflow.query(query)));\n+      handleWorkflowTaskImpl(workflowTask);\n+      result.set(workflow.query(query));\n       return result.get();\n     } finally {\n       lock.unlock();\n     }\n   }\n \n-  public Consumer<HistoryEvent> getLocalActivityCompletionSink() {\n-    return localActivityCompletionSink;\n+  private void processLocalActivityRequests(long startTime) {\n+    Duration maxProcessingTime = getWorkflowTaskTimeout().multipliedBy(4).dividedBy(5);\n+    while (true) {\n+      List<ExecuteLocalActivityParameters> laRequests =\n+          workflowStateMachines.takeLocalActivityRequests();\n+      long timeoutInterval = (long) ((System.currentTimeMillis() - startTime) * 0.5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 697}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzMwNDU3", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464730457", "createdAt": "2020-08-11T03:52:50Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo1Mjo1MVrOG-nb9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo1Mjo1MVrOG-nb9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMTAyOQ==", "bodyText": "this represents the amount of time the local activity has to execute?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468311029", "createdAt": "2020-08-11T03:52:51Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java", "diffHunk": "@@ -622,27 +341,76 @@ public void close() {\n \n   @Override\n   public Optional<Payloads> handleQueryWorkflowTask(\n-      PollWorkflowTaskQueueResponseOrBuilder response, WorkflowQuery query) throws Throwable {\n+      PollWorkflowTaskQueueResponseOrBuilder workflowTask, WorkflowQuery query) {\n     lock.lock();\n     try {\n       AtomicReference<Optional<Payloads>> result = new AtomicReference<>();\n-      handleWorkflowTaskImpl(response, () -> result.set(workflow.query(query)));\n+      handleWorkflowTaskImpl(workflowTask);\n+      result.set(workflow.query(query));\n       return result.get();\n     } finally {\n       lock.unlock();\n     }\n   }\n \n-  public Consumer<HistoryEvent> getLocalActivityCompletionSink() {\n-    return localActivityCompletionSink;\n+  private void processLocalActivityRequests(long startTime) {\n+    Duration maxProcessingTime = getWorkflowTaskTimeout().multipliedBy(4).dividedBy(5);\n+    while (true) {\n+      List<ExecuteLocalActivityParameters> laRequests =\n+          workflowStateMachines.takeLocalActivityRequests();\n+      long timeoutInterval = (long) ((System.currentTimeMillis() - startTime) * 0.5);\n+      for (ExecuteLocalActivityParameters laRequest : laRequests) {\n+        // TODO(maxim): In the presence of workflow task heartbeat this timeout doesn't make\n+        // much sense. I believe we should add ScheduleToStart timeout for the local activities\n+        // as well.\n+        long processingTime = Math.min(System.currentTimeMillis() - startTime, timeoutInterval);\n+        boolean accepted =\n+            localActivityTaskPoller.apply(\n+                new LocalActivityWorker.Task(\n+                    laRequest, localActivityCompletionSink, 10000 /* TODO: Configurable */),\n+                Duration.ofMillis(processingTime));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 707}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzMxMDg0", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464731084", "createdAt": "2020-08-11T03:55:02Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo1NTowM1rOG-neHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo1NTowM1rOG-neHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMTU4Mg==", "bodyText": "[Nit] double nested while(true) loops with breaks and returns might make this code hard to read", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468311582", "createdAt": "2020-08-11T03:55:03Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/replay/ReplayWorkflowExecutor.java", "diffHunk": "@@ -622,27 +341,76 @@ public void close() {\n \n   @Override\n   public Optional<Payloads> handleQueryWorkflowTask(\n-      PollWorkflowTaskQueueResponseOrBuilder response, WorkflowQuery query) throws Throwable {\n+      PollWorkflowTaskQueueResponseOrBuilder workflowTask, WorkflowQuery query) {\n     lock.lock();\n     try {\n       AtomicReference<Optional<Payloads>> result = new AtomicReference<>();\n-      handleWorkflowTaskImpl(response, () -> result.set(workflow.query(query)));\n+      handleWorkflowTaskImpl(workflowTask);\n+      result.set(workflow.query(query));\n       return result.get();\n     } finally {\n       lock.unlock();\n     }\n   }\n \n-  public Consumer<HistoryEvent> getLocalActivityCompletionSink() {\n-    return localActivityCompletionSink;\n+  private void processLocalActivityRequests(long startTime) {\n+    Duration maxProcessingTime = getWorkflowTaskTimeout().multipliedBy(4).dividedBy(5);\n+    while (true) {\n+      List<ExecuteLocalActivityParameters> laRequests =\n+          workflowStateMachines.takeLocalActivityRequests();\n+      long timeoutInterval = (long) ((System.currentTimeMillis() - startTime) * 0.5);\n+      for (ExecuteLocalActivityParameters laRequest : laRequests) {\n+        // TODO(maxim): In the presence of workflow task heartbeat this timeout doesn't make\n+        // much sense. I believe we should add ScheduleToStart timeout for the local activities\n+        // as well.\n+        long processingTime = Math.min(System.currentTimeMillis() - startTime, timeoutInterval);\n+        boolean accepted =\n+            localActivityTaskPoller.apply(\n+                new LocalActivityWorker.Task(\n+                    laRequest, localActivityCompletionSink, 10000 /* TODO: Configurable */),\n+                Duration.ofMillis(processingTime));\n+        laTaskCount++;\n+        if (!accepted) {\n+          throw new Error(\"Unable to schedule local activity for execution\");\n+        }\n+      }\n+      if (laTaskCount == 0) {\n+        break;\n+      }\n+      while (true) {\n+        Duration processingTime = Duration.ofMillis(System.currentTimeMillis() - startTime);\n+        Duration maxWaitAllowed = maxProcessingTime.minus(processingTime);\n+        if (maxWaitAllowed.isZero() || maxWaitAllowed.isNegative()) {\n+          return;\n+        }\n+        ActivityTaskHandler.Result laCompletion;\n+        // Do not wait under lock.\n+        try {\n+          laCompletion =\n+              localActivityCompletionQueue.poll(maxWaitAllowed.toMillis(), TimeUnit.MILLISECONDS);\n+          if (laCompletion == null) {\n+            // Need to force a new task\n+            break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 729}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzMxODYx", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464731861", "createdAt": "2020-08-11T03:58:01Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo1ODowMVrOG-ngww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzo1ODowMVrOG-ngww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMxMjI1OQ==", "bodyText": "typo in comment", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468312259", "createdAt": "2020-08-11T03:58:01Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/EntityStateMachineInitialCommand.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.workflow.Functions;\n+\n+class EntityStateMachineInitialCommand<State, ExplicitEvent, Data>\n+    extends EntityStateMachineBase<State, ExplicitEvent, Data> {\n+\n+  private CancellableCommand command;\n+\n+  private long initialCommandEventId;\n+\n+  public EntityStateMachineInitialCommand(\n+      StateMachineDefinition<State, ExplicitEvent, Data> stateMachineDefinition,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(stateMachineDefinition, commandSink, stateMachineSink);\n+  }\n+\n+  protected final void addCommand(Command command) {\n+    if (command.getCommandType() == CommandType.COMMAND_TYPE_UNSPECIFIED) {\n+      throw new IllegalArgumentException(\"unspecified command type\");\n+    }\n+    this.command = new CancellableCommand(command, this);\n+    commandSink.apply(this.command);\n+  }\n+\n+  protected final void cancelCommand() {\n+    command.cancel();\n+  }\n+\n+  protected long getInitialCommandEventId() {\n+    return initialCommandEventId;\n+  }\n+\n+  /** Sets initialCommandEventId ot the currentEvent eventId. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzQwODg2", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464740886", "createdAt": "2020-08-11T04:31:58Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDozMTo1OFrOG-n_1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDozMTo1OFrOG-n_1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMDIxNA==", "bodyText": "so we have NOT_MATCHING_EVENT and NON_MATCHING_EVENT. Can we align these?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468320214", "createdAt": "2020-08-11T04:31:58Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/MutableSideEffectStateMachine.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import com.google.common.base.Strings;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+final class MutableSideEffectStateMachine {\n+\n+  private static final String MARKER_HEADER_KEY = \"header\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+  static final String MARKER_SKIP_COUNT_KEY = \"skipCount\";\n+  static final String MARKER_ID_KEY = \"id\";\n+  static final String MUTABLE_SIDE_EFFECT_MARKER_NAME = \"MutableSideEffect\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+  private final String id;\n+  private final Functions.Func<Boolean> replaying;\n+  private final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  private Optional<Payloads> result = Optional.empty();\n+\n+  private int currentSkipCount;\n+\n+  private int skipCountFromMarker = Integer.MAX_VALUE;\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    NON_MATCHING_EVENT\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    MARKER_COMMAND_CREATED,\n+    SKIPPED,\n+    CACHED_RESULT_NOTIFIED,\n+    RESULT_NOTIFIED,\n+    SKIPPED_NOTIFIED,\n+    RESULT_NOTIFIED_REPLAYING,\n+    MARKER_COMMAND_CREATED_REPLAYING,\n+    MARKER_COMMAND_RECORDED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, InvocationStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, InvocationStateMachine>newInstance(\n+                  \"MutableSideEffect\",\n+                  State.CREATED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  State.SKIPPED_NOTIFIED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  InvocationStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  new State[] {State.MARKER_COMMAND_CREATED, State.SKIPPED},\n+                  InvocationStateMachine::createMarker)\n+              .add(\n+                  State.REPLAYING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  InvocationStateMachine::createFakeCommand)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  InvocationStateMachine::notifyCachedResult)\n+              .add(\n+                  State.SKIPPED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED_REPLAYING)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  ExplicitEvent.NON_MATCHING_EVENT,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  new State[] {State.MARKER_COMMAND_RECORDED, State.SKIPPED_NOTIFIED},\n+                  InvocationStateMachine::notifyFromEvent);\n+\n+  /** Represents a single invocation of mutableSideEffect. */\n+  private class InvocationStateMachine\n+      extends EntityStateMachineInitialCommand<State, ExplicitEvent, InvocationStateMachine> {\n+\n+    private final Functions.Proc1<Optional<Payloads>> resultCallback;\n+    private final Functions.Func1<Optional<Payloads>, Optional<Payloads>> func;\n+\n+    InvocationStateMachine(\n+        Functions.Func1<Optional<Payloads>, Optional<Payloads>> func,\n+        Functions.Proc1<Optional<Payloads>> callback,\n+        Functions.Proc1<StateMachine> stateMachineSink) {\n+      super(\n+          STATE_MACHINE_DEFINITION,\n+          MutableSideEffectStateMachine.this.commandSink,\n+          stateMachineSink);\n+      this.func = Objects.requireNonNull(func);\n+      this.resultCallback = Objects.requireNonNull(callback);\n+    }\n+\n+    State getExecutionState() {\n+      return replaying.apply() ? State.REPLAYING : State.EXECUTING;\n+    }\n+\n+    @Override\n+    public WorkflowStateMachines.HandleEventStatus handleEvent(\n+        HistoryEvent event, boolean hasNextEvent) {\n+      if (event.getEventType() != EventType.EVENT_TYPE_MARKER_RECORDED\n+          || !event\n+              .getMarkerRecordedEventAttributes()\n+              .getMarkerName()\n+              .equals(MUTABLE_SIDE_EFFECT_MARKER_NAME)) {\n+        explicitEvent(ExplicitEvent.NON_MATCHING_EVENT);\n+        return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzQxMjA3", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464741207", "createdAt": "2020-08-11T04:33:12Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDozMzoxMlrOG-oA2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDozMzoxMlrOG-oA2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMDQ3Mw==", "bodyText": "any reason this is commented out?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468320473", "createdAt": "2020-08-11T04:33:12Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/MutableSideEffectStateMachine.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import com.google.common.base.Strings;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+final class MutableSideEffectStateMachine {\n+\n+  private static final String MARKER_HEADER_KEY = \"header\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+  static final String MARKER_SKIP_COUNT_KEY = \"skipCount\";\n+  static final String MARKER_ID_KEY = \"id\";\n+  static final String MUTABLE_SIDE_EFFECT_MARKER_NAME = \"MutableSideEffect\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+  private final String id;\n+  private final Functions.Func<Boolean> replaying;\n+  private final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  private Optional<Payloads> result = Optional.empty();\n+\n+  private int currentSkipCount;\n+\n+  private int skipCountFromMarker = Integer.MAX_VALUE;\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    NON_MATCHING_EVENT\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    MARKER_COMMAND_CREATED,\n+    SKIPPED,\n+    CACHED_RESULT_NOTIFIED,\n+    RESULT_NOTIFIED,\n+    SKIPPED_NOTIFIED,\n+    RESULT_NOTIFIED_REPLAYING,\n+    MARKER_COMMAND_CREATED_REPLAYING,\n+    MARKER_COMMAND_RECORDED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, InvocationStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, InvocationStateMachine>newInstance(\n+                  \"MutableSideEffect\",\n+                  State.CREATED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  State.SKIPPED_NOTIFIED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  InvocationStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  new State[] {State.MARKER_COMMAND_CREATED, State.SKIPPED},\n+                  InvocationStateMachine::createMarker)\n+              .add(\n+                  State.REPLAYING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  InvocationStateMachine::createFakeCommand)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  InvocationStateMachine::notifyCachedResult)\n+              .add(\n+                  State.SKIPPED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED_REPLAYING)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  ExplicitEvent.NON_MATCHING_EVENT,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  new State[] {State.MARKER_COMMAND_RECORDED, State.SKIPPED_NOTIFIED},\n+                  InvocationStateMachine::notifyFromEvent);\n+\n+  /** Represents a single invocation of mutableSideEffect. */\n+  private class InvocationStateMachine\n+      extends EntityStateMachineInitialCommand<State, ExplicitEvent, InvocationStateMachine> {\n+\n+    private final Functions.Proc1<Optional<Payloads>> resultCallback;\n+    private final Functions.Func1<Optional<Payloads>, Optional<Payloads>> func;\n+\n+    InvocationStateMachine(\n+        Functions.Func1<Optional<Payloads>, Optional<Payloads>> func,\n+        Functions.Proc1<Optional<Payloads>> callback,\n+        Functions.Proc1<StateMachine> stateMachineSink) {\n+      super(\n+          STATE_MACHINE_DEFINITION,\n+          MutableSideEffectStateMachine.this.commandSink,\n+          stateMachineSink);\n+      this.func = Objects.requireNonNull(func);\n+      this.resultCallback = Objects.requireNonNull(callback);\n+    }\n+\n+    State getExecutionState() {\n+      return replaying.apply() ? State.REPLAYING : State.EXECUTING;\n+    }\n+\n+    @Override\n+    public WorkflowStateMachines.HandleEventStatus handleEvent(\n+        HistoryEvent event, boolean hasNextEvent) {\n+      if (event.getEventType() != EventType.EVENT_TYPE_MARKER_RECORDED\n+          || !event\n+              .getMarkerRecordedEventAttributes()\n+              .getMarkerName()\n+              .equals(MUTABLE_SIDE_EFFECT_MARKER_NAME)) {\n+        explicitEvent(ExplicitEvent.NON_MATCHING_EVENT);\n+        return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;\n+      }\n+      Map<String, Payloads> detailsMap = event.getMarkerRecordedEventAttributes().getDetailsMap();\n+      Optional<Payloads> idPayloads = Optional.ofNullable(detailsMap.get(MARKER_ID_KEY));\n+      String expectedId = dataConverter.fromPayloads(0, idPayloads, String.class, String.class);\n+      if (Strings.isNullOrEmpty(expectedId)) {\n+        throw new IllegalStateException(\n+            \"Marker details map missing required key: \" + MARKER_ID_KEY);\n+      }\n+      if (!id.equals(expectedId)) {\n+        //        explicitEvent(ExplicitEvent.NON_MATCHING_EVENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 169}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzQxMzQ0", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464741344", "createdAt": "2020-08-11T04:33:41Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDozMzo0MVrOG-oBSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDozMzo0MVrOG-oBSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMDU4Nw==", "bodyText": "my own learning: i assume that isPresent returns false if the value is identical to the previously stored version, right?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468320587", "createdAt": "2020-08-11T04:33:41Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/MutableSideEffectStateMachine.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import com.google.common.base.Strings;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+final class MutableSideEffectStateMachine {\n+\n+  private static final String MARKER_HEADER_KEY = \"header\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+  static final String MARKER_SKIP_COUNT_KEY = \"skipCount\";\n+  static final String MARKER_ID_KEY = \"id\";\n+  static final String MUTABLE_SIDE_EFFECT_MARKER_NAME = \"MutableSideEffect\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+  private final String id;\n+  private final Functions.Func<Boolean> replaying;\n+  private final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  private Optional<Payloads> result = Optional.empty();\n+\n+  private int currentSkipCount;\n+\n+  private int skipCountFromMarker = Integer.MAX_VALUE;\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    NON_MATCHING_EVENT\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    MARKER_COMMAND_CREATED,\n+    SKIPPED,\n+    CACHED_RESULT_NOTIFIED,\n+    RESULT_NOTIFIED,\n+    SKIPPED_NOTIFIED,\n+    RESULT_NOTIFIED_REPLAYING,\n+    MARKER_COMMAND_CREATED_REPLAYING,\n+    MARKER_COMMAND_RECORDED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, InvocationStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, InvocationStateMachine>newInstance(\n+                  \"MutableSideEffect\",\n+                  State.CREATED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  State.SKIPPED_NOTIFIED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  InvocationStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  new State[] {State.MARKER_COMMAND_CREATED, State.SKIPPED},\n+                  InvocationStateMachine::createMarker)\n+              .add(\n+                  State.REPLAYING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  InvocationStateMachine::createFakeCommand)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  InvocationStateMachine::notifyCachedResult)\n+              .add(\n+                  State.SKIPPED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED_REPLAYING)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  ExplicitEvent.NON_MATCHING_EVENT,\n+                  State.SKIPPED_NOTIFIED,\n+                  InvocationStateMachine::cancelCommandNotifyCachedResult)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  new State[] {State.MARKER_COMMAND_RECORDED, State.SKIPPED_NOTIFIED},\n+                  InvocationStateMachine::notifyFromEvent);\n+\n+  /** Represents a single invocation of mutableSideEffect. */\n+  private class InvocationStateMachine\n+      extends EntityStateMachineInitialCommand<State, ExplicitEvent, InvocationStateMachine> {\n+\n+    private final Functions.Proc1<Optional<Payloads>> resultCallback;\n+    private final Functions.Func1<Optional<Payloads>, Optional<Payloads>> func;\n+\n+    InvocationStateMachine(\n+        Functions.Func1<Optional<Payloads>, Optional<Payloads>> func,\n+        Functions.Proc1<Optional<Payloads>> callback,\n+        Functions.Proc1<StateMachine> stateMachineSink) {\n+      super(\n+          STATE_MACHINE_DEFINITION,\n+          MutableSideEffectStateMachine.this.commandSink,\n+          stateMachineSink);\n+      this.func = Objects.requireNonNull(func);\n+      this.resultCallback = Objects.requireNonNull(callback);\n+    }\n+\n+    State getExecutionState() {\n+      return replaying.apply() ? State.REPLAYING : State.EXECUTING;\n+    }\n+\n+    @Override\n+    public WorkflowStateMachines.HandleEventStatus handleEvent(\n+        HistoryEvent event, boolean hasNextEvent) {\n+      if (event.getEventType() != EventType.EVENT_TYPE_MARKER_RECORDED\n+          || !event\n+              .getMarkerRecordedEventAttributes()\n+              .getMarkerName()\n+              .equals(MUTABLE_SIDE_EFFECT_MARKER_NAME)) {\n+        explicitEvent(ExplicitEvent.NON_MATCHING_EVENT);\n+        return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;\n+      }\n+      Map<String, Payloads> detailsMap = event.getMarkerRecordedEventAttributes().getDetailsMap();\n+      Optional<Payloads> idPayloads = Optional.ofNullable(detailsMap.get(MARKER_ID_KEY));\n+      String expectedId = dataConverter.fromPayloads(0, idPayloads, String.class, String.class);\n+      if (Strings.isNullOrEmpty(expectedId)) {\n+        throw new IllegalStateException(\n+            \"Marker details map missing required key: \" + MARKER_ID_KEY);\n+      }\n+      if (!id.equals(expectedId)) {\n+        //        explicitEvent(ExplicitEvent.NON_MATCHING_EVENT);\n+        return WorkflowStateMachines.HandleEventStatus.NOT_MATCHING_EVENT;\n+      }\n+      super.handleEvent(event, hasNextEvent);\n+      return WorkflowStateMachines.HandleEventStatus.OK;\n+    }\n+\n+    State createMarker() {\n+      State toState;\n+      RecordMarkerCommandAttributes markerAttributes;\n+      Optional<Payloads> updated;\n+      updated = func.apply(result);\n+      if (!updated.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 181}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzQyNDgz", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464742483", "createdAt": "2020-08-11T04:37:44Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDozNzo0NFrOG-oFFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDozNzo0NFrOG-oFFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMTU1Nw==", "bodyText": "does this mean a side effect cannot return a null value?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468321557", "createdAt": "2020-08-11T04:37:44Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/SideEffectStateMachine.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class SideEffectStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        SideEffectStateMachine.State,\n+        SideEffectStateMachine.ExplicitEvent,\n+        SideEffectStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE\n+  }\n+\n+  enum State {\n+    CREATED,\n+    MARKER_COMMAND_CREATED,\n+    RESULT_NOTIFIED,\n+    RESULT_NOTIFIED_REPLAYING,\n+    MARKER_COMMAND_CREATED_REPLAYING,\n+    MARKER_COMMAND_RECORDED,\n+  }\n+\n+  private static final String MARKER_HEADER_KEY = \"header\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+  static final String SIDE_EFFECT_MARKER_NAME = \"SideEffect\";\n+\n+  private final Functions.Proc1<Optional<Payloads>> callback;\n+  private final Functions.Func<Optional<Payloads>> func;\n+  private final Functions.Func<Boolean> replaying;\n+\n+  private Optional<Payloads> result;\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, SideEffectStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, SideEffectStateMachine>newInstance(\n+                  \"SideEffect\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  new State[] {\n+                    State.MARKER_COMMAND_CREATED, State.MARKER_COMMAND_CREATED_REPLAYING\n+                  },\n+                  SideEffectStateMachine::createMarkerCommand)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED_REPLAYING)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  SideEffectStateMachine::markerResultFromFunc)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  SideEffectStateMachine::markerResultFromEvent);\n+\n+  /**\n+   * Creates new SideEffect Marker\n+   *\n+   * @param func used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static void newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func<Optional<Payloads>> func,\n+      Functions.Proc1<Optional<Payloads>> callback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    new SideEffectStateMachine(replaying, func, callback, commandSink, stateMachineSink);\n+  }\n+\n+  private SideEffectStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func<Optional<Payloads>> func,\n+      Functions.Proc1<Optional<Payloads>> callback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.func = func;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  private State createMarkerCommand() {\n+    RecordMarkerCommandAttributes markerAttributes;\n+    if (replaying.apply()) {\n+      markerAttributes = RecordMarkerCommandAttributes.getDefaultInstance();\n+      return State.MARKER_COMMAND_CREATED_REPLAYING;\n+    } else {\n+      // executing first time\n+      result = func.apply();\n+      if (result == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzQyNjU4", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464742658", "createdAt": "2020-08-11T04:38:19Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDozODoxOVrOG-oFmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDozODoxOVrOG-oFmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMTY5MQ==", "bodyText": "[Nit] fromMarker", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468321691", "createdAt": "2020-08-11T04:38:19Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/SideEffectStateMachine.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class SideEffectStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        SideEffectStateMachine.State,\n+        SideEffectStateMachine.ExplicitEvent,\n+        SideEffectStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE\n+  }\n+\n+  enum State {\n+    CREATED,\n+    MARKER_COMMAND_CREATED,\n+    RESULT_NOTIFIED,\n+    RESULT_NOTIFIED_REPLAYING,\n+    MARKER_COMMAND_CREATED_REPLAYING,\n+    MARKER_COMMAND_RECORDED,\n+  }\n+\n+  private static final String MARKER_HEADER_KEY = \"header\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+  static final String SIDE_EFFECT_MARKER_NAME = \"SideEffect\";\n+\n+  private final Functions.Proc1<Optional<Payloads>> callback;\n+  private final Functions.Func<Optional<Payloads>> func;\n+  private final Functions.Func<Boolean> replaying;\n+\n+  private Optional<Payloads> result;\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, SideEffectStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, SideEffectStateMachine>newInstance(\n+                  \"SideEffect\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  new State[] {\n+                    State.MARKER_COMMAND_CREATED, State.MARKER_COMMAND_CREATED_REPLAYING\n+                  },\n+                  SideEffectStateMachine::createMarkerCommand)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED_REPLAYING,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED_REPLAYING)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  SideEffectStateMachine::markerResultFromFunc)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.RESULT_NOTIFIED_REPLAYING,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  SideEffectStateMachine::markerResultFromEvent);\n+\n+  /**\n+   * Creates new SideEffect Marker\n+   *\n+   * @param func used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static void newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func<Optional<Payloads>> func,\n+      Functions.Proc1<Optional<Payloads>> callback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    new SideEffectStateMachine(replaying, func, callback, commandSink, stateMachineSink);\n+  }\n+\n+  private SideEffectStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func<Optional<Payloads>> func,\n+      Functions.Proc1<Optional<Payloads>> callback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.func = func;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  private State createMarkerCommand() {\n+    RecordMarkerCommandAttributes markerAttributes;\n+    if (replaying.apply()) {\n+      markerAttributes = RecordMarkerCommandAttributes.getDefaultInstance();\n+      return State.MARKER_COMMAND_CREATED_REPLAYING;\n+    } else {\n+      // executing first time\n+      result = func.apply();\n+      if (result == null) {\n+        throw new IllegalStateException(\"marker function returned null\");\n+      }\n+      Map<String, Payloads> details = new HashMap<>();\n+      if (result.isPresent()) {\n+        details.put(MARKER_DATA_KEY, result.get());\n+      }\n+      markerAttributes =\n+          RecordMarkerCommandAttributes.newBuilder()\n+              .setMarkerName(SIDE_EFFECT_MARKER_NAME)\n+              .putAllDetails(details)\n+              .build();\n+    }\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_RECORD_MARKER)\n+            .setRecordMarkerCommandAttributes(markerAttributes)\n+            .build());\n+    return State.MARKER_COMMAND_CREATED;\n+  }\n+\n+  private void markerResultFromEvent() {\n+    MarkerRecordedEventAttributes attributes = currentEvent.getMarkerRecordedEventAttributes();\n+    if (!attributes.getMarkerName().equals(SIDE_EFFECT_MARKER_NAME)) {\n+      throw new IllegalStateException(\n+          \"Expected \" + SIDE_EFFECT_MARKER_NAME + \", received: \" + attributes);\n+    }\n+    Map<String, Payloads> map = attributes.getDetailsMap();\n+    Optional<Payloads> fromMaker = Optional.ofNullable(map.get(MARKER_DATA_KEY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 157}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzQzOTk4", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-464743998", "createdAt": "2020-08-11T04:43:19Z", "commit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDo0MzoxOVrOG-oKXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwNDo0MzoxOVrOG-oKXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMyMjkwOQ==", "bodyText": "basically, once we have a notification from the server that the external workflow was signaled, then a cancel is basically a no-op, hence this transition back to its own state?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468322909", "createdAt": "2020-08-11T04:43:19Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/SignalExternalStateMachine.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.failure.v1.ApplicationFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.SignalExternalWorkflowExecutionFailedEventAttributes;\n+import io.temporal.workflow.Functions;\n+\n+final class SignalExternalStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        SignalExternalStateMachine.State,\n+        SignalExternalStateMachine.ExplicitEvent,\n+        SignalExternalStateMachine> {\n+\n+  private final SignalExternalWorkflowExecutionCommandAttributes signalAttributes;\n+\n+  private final Functions.Proc2<Void, Failure> completionCallback;\n+\n+  /**\n+   * Register new instance of the signal commands\n+   *\n+   * @param signalAttributes attributes used to signal an external workflow\n+   * @param completionCallback either SignalExternalWorkflowExecutionFailed,\n+   *     ExternalWorkflowExecutionSignaled or true value of the second parameter to indicate\n+   *     immediate cancellation.\n+   * @param commandSink sink to send commands\n+   * @return cancellation handler\n+   */\n+  public static Functions.Proc newInstance(\n+      SignalExternalWorkflowExecutionCommandAttributes signalAttributes,\n+      Functions.Proc2<Void, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    SignalExternalStateMachine commands =\n+        new SignalExternalStateMachine(\n+            signalAttributes, completionCallback, commandSink, stateMachineSink);\n+    return commands::cancel;\n+  }\n+\n+  private SignalExternalStateMachine(\n+      SignalExternalWorkflowExecutionCommandAttributes signalAttributes,\n+      Functions.Proc2<Void, Failure> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.signalAttributes = signalAttributes;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    SIGNAL_EXTERNAL_COMMAND_CREATED,\n+    SIGNAL_EXTERNAL_COMMAND_RECORDED,\n+    SIGNALED,\n+    FAILED,\n+    CANCELED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, SignalExternalStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, SignalExternalStateMachine>newInstance(\n+                  \"SignalExternal\", State.CREATED, State.SIGNALED, State.FAILED, State.CANCELED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.SIGNAL_EXTERNAL_COMMAND_CREATED,\n+                  SignalExternalStateMachine::createSignalExternalCommand)\n+              .add(\n+                  State.SIGNAL_EXTERNAL_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION,\n+                  State.SIGNAL_EXTERNAL_COMMAND_CREATED)\n+              .add(\n+                  State.SIGNAL_EXTERNAL_COMMAND_CREATED,\n+                  ExplicitEvent.CANCEL,\n+                  State.CANCELED,\n+                  SignalExternalStateMachine::cancelSignalExternalCommand)\n+              .add(\n+                  State.SIGNAL_EXTERNAL_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED,\n+                  State.SIGNAL_EXTERNAL_COMMAND_RECORDED,\n+                  EntityStateMachineInitialCommand::setInitialCommandEventId)\n+              .add(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "731f9022dc2ad7f599084a66bdeb82658cb1456a"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "088cbcfcdf31acfe7fcc37f60b4491b08324f04d", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/088cbcfcdf31acfe7fcc37f60b4491b08324f04d", "committedDate": "2020-08-11T16:42:07Z", "message": "Added coverage to versionStateMachineTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/0b7bc472a702cfd414300d910dc9d26623233eb1", "committedDate": "2020-08-11T16:56:15Z", "message": "Cancelled->canceled"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1Mjc0NDUz", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-465274453", "createdAt": "2020-08-11T17:21:43Z", "commit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzoyMTo0M1rOG_Bv7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzoyMTo0M1rOG_Bv7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MjEyNw==", "bodyText": "there is zero chance we somehow get a timer fired event before the timer started event? This should be properly serialized on the server, right?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468742127", "createdAt": "2020-08-11T17:21:43Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/TimerStateMachine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.CancelTimerCommandAttributes;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartTimerCommandAttributes;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.TimerCanceledEventAttributes;\n+import io.temporal.workflow.Functions;\n+\n+final class TimerStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        TimerStateMachine.State, TimerStateMachine.ExplicitEvent, TimerStateMachine> {\n+\n+  private final StartTimerCommandAttributes startAttributes;\n+\n+  private final Functions.Proc1<HistoryEvent> completionCallback;\n+\n+  /**\n+   * Creates a new timer state machine\n+   *\n+   * @param attributes timer command attributes\n+   * @param completionCallback invoked when timer fires or reports cancellation. One of\n+   *     TimerFiredEvent, TimerCanceledEvent.\n+   * @return cancellation callback that should be invoked to initiate timer cancellation\n+   */\n+  public static TimerStateMachine newInstance(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new TimerStateMachine(attributes, completionCallback, commandSink, stateMachineSink);\n+  }\n+\n+  private TimerStateMachine(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.startAttributes = attributes;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_COMMAND_RECORDED,\n+    CANCEL_TIMER_COMMAND_CREATED,\n+    FIRED,\n+    CANCELED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, TimerStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, TimerStateMachine>newInstance(\n+                  \"Timer\", State.CREATED, State.FIRED, State.CANCELED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.START_COMMAND_CREATED,\n+                  TimerStateMachine::createStartTimerCommand)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_START_TIMER,\n+                  State.START_COMMAND_CREATED)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_TIMER_STARTED,\n+                  State.START_COMMAND_RECORDED,\n+                  EntityStateMachineInitialCommand::setInitialCommandEventId)\n+              .add(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1Mjc5Mzk3", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-465279397", "createdAt": "2020-08-11T17:28:27Z", "commit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzoyODoyN1rOG_B_JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzoyODoyN1rOG_B_JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NjAyMQ==", "bodyText": "similarly, is there a chance the timer fired event arrives even after the explicit cancel, but before we get the event_type_timer started/fired events? In this case, we'd be in the Canceled state when we receive those events. I assume that is a no-op then?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468746021", "createdAt": "2020-08-11T17:28:27Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/TimerStateMachine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.CancelTimerCommandAttributes;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartTimerCommandAttributes;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.TimerCanceledEventAttributes;\n+import io.temporal.workflow.Functions;\n+\n+final class TimerStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        TimerStateMachine.State, TimerStateMachine.ExplicitEvent, TimerStateMachine> {\n+\n+  private final StartTimerCommandAttributes startAttributes;\n+\n+  private final Functions.Proc1<HistoryEvent> completionCallback;\n+\n+  /**\n+   * Creates a new timer state machine\n+   *\n+   * @param attributes timer command attributes\n+   * @param completionCallback invoked when timer fires or reports cancellation. One of\n+   *     TimerFiredEvent, TimerCanceledEvent.\n+   * @return cancellation callback that should be invoked to initiate timer cancellation\n+   */\n+  public static TimerStateMachine newInstance(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new TimerStateMachine(attributes, completionCallback, commandSink, stateMachineSink);\n+  }\n+\n+  private TimerStateMachine(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.startAttributes = attributes;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_COMMAND_RECORDED,\n+    CANCEL_TIMER_COMMAND_CREATED,\n+    FIRED,\n+    CANCELED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, TimerStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, TimerStateMachine>newInstance(\n+                  \"Timer\", State.CREATED, State.FIRED, State.CANCELED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.START_COMMAND_CREATED,\n+                  TimerStateMachine::createStartTimerCommand)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_START_TIMER,\n+                  State.START_COMMAND_CREATED)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_TIMER_STARTED,\n+                  State.START_COMMAND_RECORDED,\n+                  EntityStateMachineInitialCommand::setInitialCommandEventId)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  ExplicitEvent.CANCEL,\n+                  State.CANCELED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1Mjk5Mzkz", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-465299393", "createdAt": "2020-08-11T17:55:54Z", "commit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzo1NTo1NFrOG_C9rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzo1NTo1NFrOG_C9rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MjAzMA==", "bodyText": "just curious: what would happen if we did not call cancelCommand() here? We would not filter it out when returning the commands, right?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468762030", "createdAt": "2020-08-11T17:55:54Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/TimerStateMachine.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.CancelTimerCommandAttributes;\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartTimerCommandAttributes;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.api.history.v1.TimerCanceledEventAttributes;\n+import io.temporal.workflow.Functions;\n+\n+final class TimerStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        TimerStateMachine.State, TimerStateMachine.ExplicitEvent, TimerStateMachine> {\n+\n+  private final StartTimerCommandAttributes startAttributes;\n+\n+  private final Functions.Proc1<HistoryEvent> completionCallback;\n+\n+  /**\n+   * Creates a new timer state machine\n+   *\n+   * @param attributes timer command attributes\n+   * @param completionCallback invoked when timer fires or reports cancellation. One of\n+   *     TimerFiredEvent, TimerCanceledEvent.\n+   * @return cancellation callback that should be invoked to initiate timer cancellation\n+   */\n+  public static TimerStateMachine newInstance(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new TimerStateMachine(attributes, completionCallback, commandSink, stateMachineSink);\n+  }\n+\n+  private TimerStateMachine(\n+      StartTimerCommandAttributes attributes,\n+      Functions.Proc1<HistoryEvent> completionCallback,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.startAttributes = attributes;\n+    this.completionCallback = completionCallback;\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_COMMAND_RECORDED,\n+    CANCEL_TIMER_COMMAND_CREATED,\n+    FIRED,\n+    CANCELED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, TimerStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, TimerStateMachine>newInstance(\n+                  \"Timer\", State.CREATED, State.FIRED, State.CANCELED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.START_COMMAND_CREATED,\n+                  TimerStateMachine::createStartTimerCommand)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_START_TIMER,\n+                  State.START_COMMAND_CREATED)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_TIMER_STARTED,\n+                  State.START_COMMAND_RECORDED,\n+                  EntityStateMachineInitialCommand::setInitialCommandEventId)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  ExplicitEvent.CANCEL,\n+                  State.CANCELED,\n+                  TimerStateMachine::cancelStartTimerCommand)\n+              .add(\n+                  State.START_COMMAND_RECORDED,\n+                  EventType.EVENT_TYPE_TIMER_FIRED,\n+                  State.FIRED,\n+                  TimerStateMachine::notifyCompletion)\n+              .add(\n+                  State.START_COMMAND_RECORDED,\n+                  ExplicitEvent.CANCEL,\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  TimerStateMachine::createCancelTimerCommand)\n+              .add(\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  ExplicitEvent.CANCEL,\n+                  State.CANCEL_TIMER_COMMAND_CREATED)\n+              .add(\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_TIMER_CANCELED,\n+                  State.CANCELED)\n+              .add(\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_CANCEL_TIMER,\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  TimerStateMachine::notifyCancellation)\n+              .add(\n+                  State.CANCEL_TIMER_COMMAND_CREATED,\n+                  EventType.EVENT_TYPE_TIMER_FIRED,\n+                  State.FIRED,\n+                  TimerStateMachine::cancelTimerCommandFireTimer);\n+\n+  private void createStartTimerCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_START_TIMER)\n+            .setStartTimerCommandAttributes(startAttributes)\n+            .build());\n+  }\n+\n+  public void cancel() {\n+    if (!isFinalState()) {\n+      explicitEvent(ExplicitEvent.CANCEL);\n+    }\n+  }\n+\n+  private void cancelStartTimerCommand() {\n+    cancelCommand();\n+    notifyCancellation();\n+  }\n+\n+  private void notifyCancellation() {\n+    completionCallback.apply(\n+        HistoryEvent.newBuilder()\n+            .setEventType(EventType.EVENT_TYPE_TIMER_CANCELED)\n+            .setTimerCanceledEventAttributes(\n+                TimerCanceledEventAttributes.newBuilder()\n+                    .setIdentity(\"workflow\")\n+                    .setTimerId(startAttributes.getTimerId()))\n+            .build());\n+  }\n+\n+  private void notifyCompletion() {\n+    completionCallback.apply(currentEvent);\n+  }\n+\n+  private void createCancelTimerCommand() {\n+    addCommand(\n+        Command.newBuilder()\n+            .setCommandType(CommandType.COMMAND_TYPE_CANCEL_TIMER)\n+            .setCancelTimerCommandAttributes(\n+                CancelTimerCommandAttributes.newBuilder().setTimerId(startAttributes.getTimerId()))\n+            .build());\n+  }\n+\n+  private void cancelTimerCommandFireTimer() {\n+    cancelCommand();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1"}, "originalPosition": 176}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDY5Mjky", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-465469292", "createdAt": "2020-08-11T22:23:13Z", "commit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjoyMzoxM1rOG_LQmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozMzozMlrOG_Lf7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5Nzk0NA==", "bodyText": "We have the same mess on GoSDK and server side.", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468897944", "createdAt": "2020-08-11T22:23:13Z", "author": {"login": "alexshtin"}, "path": "src/main/java/io/temporal/activity/ActivityCancellationType.java", "diffHunk": "@@ -24,7 +24,7 @@\n \n /**\n  * Defines behaviour of the parent workflow when {@link CancellationScope} that wraps child workflow\n- * execution request is cancelled. The result of the cancellation independently of the type is a\n+ * execution request is canceled. The result of the cancellation independently of the type is a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTg2OA==", "bodyText": "temporalio/sdk-go#227", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r468901868", "createdAt": "2020-08-11T22:33:32Z", "author": {"login": "alexshtin"}, "path": "src/main/java/io/temporal/activity/ActivityCancellationType.java", "diffHunk": "@@ -24,7 +24,7 @@\n \n /**\n  * Defines behaviour of the parent workflow when {@link CancellationScope} that wraps child workflow\n- * execution request is cancelled. The result of the cancellation independently of the type is a\n+ * execution request is canceled. The result of the cancellation independently of the type is a", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5Nzk0NA=="}, "originalCommit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NTA2MDM2", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-465506036", "createdAt": "2020-08-12T00:01:54Z", "commit": {"oid": "0b7bc472a702cfd414300d910dc9d26623233eb1"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd642f04b93e7304b2fc768802317bfdd9ec3bc2", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/dd642f04b93e7304b2fc768802317bfdd9ec3bc2", "committedDate": "2020-08-12T00:47:37Z", "message": "Simplified local activity handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cc7b0c1e729d543ca4eec4bc405d375c5f51533", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/1cc7b0c1e729d543ca4eec4bc405d375c5f51533", "committedDate": "2020-08-12T03:00:51Z", "message": "allOf, anyOf and iterator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abf241cf397678698be6add3bcb457101f7b2cd0", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/abf241cf397678698be6add3bcb457101f7b2cd0", "committedDate": "2020-08-12T03:06:10Z", "message": "event loop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MjY0ODYx", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-466264861", "createdAt": "2020-08-12T20:46:54Z", "commit": {"oid": "abf241cf397678698be6add3bcb457101f7b2cd0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo0Njo1NFrOG_yQnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo0Njo1NFrOG_yQnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzNjkyNA==", "bodyText": "is there a better name we can come up with than \"GET_REQUEST?\" maybe \"CREATE_REQUEST\" or CREATEORGET_REQUEST or something like that? And how do I interpret what REQUEST_SENT means? To me that sounds like something was sent to the server, but this is a local activity, so not sure if there is a more appropriate name", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469536924", "createdAt": "2020-08-12T20:46:54Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/LocalActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.api.workflowservice.v1.PollActivityTaskQueueResponse;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.failure.FailureConverter;\n+import io.temporal.internal.replay.ExecuteLocalActivityParameters;\n+import io.temporal.internal.worker.ActivityTaskHandler;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class LocalActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        LocalActivityStateMachine.State,\n+        LocalActivityStateMachine.ExplicitEvent,\n+        LocalActivityStateMachine> {\n+\n+  static final String LOCAL_ACTIVITY_MARKER_NAME = \"LocalActivity\";\n+  static final String MARKER_ACTIVITY_ID_KEY = \"activityId\";\n+  static final String MARKER_TIME_KEY = \"time\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+\n+  private final Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink;\n+  private final Functions.Proc2<Optional<Payloads>, Failure> callback;\n+\n+  private final ExecuteLocalActivityParameters localActivityParameters;\n+  private final Functions.Func<Boolean> replaying;\n+  /** Accepts proposed current time. Returns accepted current time. */\n+  private final Functions.Func1<Long, Long> setCurrentTimeCallback;\n+\n+  private Failure failure;\n+  private ActivityTaskHandler.Result result;\n+  private Optional<Payloads> laResult;\n+\n+  /**\n+   * Creates new local activity marker\n+   *\n+   * @param localActivityParameters used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static LocalActivityStateMachine newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new LocalActivityStateMachine(\n+        replaying,\n+        setCurrentTimeCallback,\n+        localActivityParameters,\n+        callback,\n+        localActivityRequestSink,\n+        commandSink,\n+        stateMachineSink);\n+  }\n+\n+  private LocalActivityStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.setCurrentTimeCallback = setCurrentTimeCallback;\n+    this.localActivityParameters = localActivityParameters;\n+    this.localActivityRequestSink = localActivityRequestSink;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.CHECK_EXECUTION_STATE);\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    GET_REQUEST,\n+    HANDLE_RESPONSE,\n+    NON_REPLAY_WORKFLOW_TASK_STARTED\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    REQUEST_PREPARED,\n+    REQUEST_SENT,\n+    RESULT_NOTIFIED,\n+    MARKER_COMMAND_CREATED,\n+    MARKER_COMMAND_RECORDED,\n+    WAITING_MARKER_EVENT,\n+    RESULT_NOTIFIED_REPLAYING\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, LocalActivityStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, LocalActivityStateMachine>newInstance(\n+                  \"LocalActivity\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  LocalActivityStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.REQUEST_PREPARED,\n+                  LocalActivityStateMachine::sendRequest)\n+              .add(State.REQUEST_PREPARED, ExplicitEvent.GET_REQUEST, State.REQUEST_SENT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf241cf397678698be6add3bcb457101f7b2cd0"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MjY3NTQ0", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-466267544", "createdAt": "2020-08-12T20:51:09Z", "commit": {"oid": "abf241cf397678698be6add3bcb457101f7b2cd0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo1MTowOVrOG_yY_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo1MTowOVrOG_yY_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTA2OA==", "bodyText": "this basically means local activity execution started? or that we've started executing the workflow? is there a scenario where this same event gets invoked twice? can we come up with a more friendly name?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469539068", "createdAt": "2020-08-12T20:51:09Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/LocalActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.api.workflowservice.v1.PollActivityTaskQueueResponse;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.failure.FailureConverter;\n+import io.temporal.internal.replay.ExecuteLocalActivityParameters;\n+import io.temporal.internal.worker.ActivityTaskHandler;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class LocalActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        LocalActivityStateMachine.State,\n+        LocalActivityStateMachine.ExplicitEvent,\n+        LocalActivityStateMachine> {\n+\n+  static final String LOCAL_ACTIVITY_MARKER_NAME = \"LocalActivity\";\n+  static final String MARKER_ACTIVITY_ID_KEY = \"activityId\";\n+  static final String MARKER_TIME_KEY = \"time\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+\n+  private final Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink;\n+  private final Functions.Proc2<Optional<Payloads>, Failure> callback;\n+\n+  private final ExecuteLocalActivityParameters localActivityParameters;\n+  private final Functions.Func<Boolean> replaying;\n+  /** Accepts proposed current time. Returns accepted current time. */\n+  private final Functions.Func1<Long, Long> setCurrentTimeCallback;\n+\n+  private Failure failure;\n+  private ActivityTaskHandler.Result result;\n+  private Optional<Payloads> laResult;\n+\n+  /**\n+   * Creates new local activity marker\n+   *\n+   * @param localActivityParameters used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static LocalActivityStateMachine newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new LocalActivityStateMachine(\n+        replaying,\n+        setCurrentTimeCallback,\n+        localActivityParameters,\n+        callback,\n+        localActivityRequestSink,\n+        commandSink,\n+        stateMachineSink);\n+  }\n+\n+  private LocalActivityStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.setCurrentTimeCallback = setCurrentTimeCallback;\n+    this.localActivityParameters = localActivityParameters;\n+    this.localActivityRequestSink = localActivityRequestSink;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.CHECK_EXECUTION_STATE);\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    GET_REQUEST,\n+    HANDLE_RESPONSE,\n+    NON_REPLAY_WORKFLOW_TASK_STARTED\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    REQUEST_PREPARED,\n+    REQUEST_SENT,\n+    RESULT_NOTIFIED,\n+    MARKER_COMMAND_CREATED,\n+    MARKER_COMMAND_RECORDED,\n+    WAITING_MARKER_EVENT,\n+    RESULT_NOTIFIED_REPLAYING\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, LocalActivityStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, LocalActivityStateMachine>newInstance(\n+                  \"LocalActivity\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  LocalActivityStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.REQUEST_PREPARED,\n+                  LocalActivityStateMachine::sendRequest)\n+              .add(State.REQUEST_PREPARED, ExplicitEvent.GET_REQUEST, State.REQUEST_SENT)\n+              .add(\n+                  State.REQUEST_SENT,\n+                  ExplicitEvent.NON_REPLAY_WORKFLOW_TASK_STARTED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf241cf397678698be6add3bcb457101f7b2cd0"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MjcwMjY3", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-466270267", "createdAt": "2020-08-12T20:55:17Z", "commit": {"oid": "abf241cf397678698be6add3bcb457101f7b2cd0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo1NToxN1rOG_yhXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo1NToxN1rOG_yhXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU0MTIxMw==", "bodyText": "and is this for explicitly reporting the local activity result? if so, can we have better naming for explicit event here?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469541213", "createdAt": "2020-08-12T20:55:17Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/LocalActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.api.workflowservice.v1.PollActivityTaskQueueResponse;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.failure.FailureConverter;\n+import io.temporal.internal.replay.ExecuteLocalActivityParameters;\n+import io.temporal.internal.worker.ActivityTaskHandler;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class LocalActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        LocalActivityStateMachine.State,\n+        LocalActivityStateMachine.ExplicitEvent,\n+        LocalActivityStateMachine> {\n+\n+  static final String LOCAL_ACTIVITY_MARKER_NAME = \"LocalActivity\";\n+  static final String MARKER_ACTIVITY_ID_KEY = \"activityId\";\n+  static final String MARKER_TIME_KEY = \"time\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+\n+  private final Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink;\n+  private final Functions.Proc2<Optional<Payloads>, Failure> callback;\n+\n+  private final ExecuteLocalActivityParameters localActivityParameters;\n+  private final Functions.Func<Boolean> replaying;\n+  /** Accepts proposed current time. Returns accepted current time. */\n+  private final Functions.Func1<Long, Long> setCurrentTimeCallback;\n+\n+  private Failure failure;\n+  private ActivityTaskHandler.Result result;\n+  private Optional<Payloads> laResult;\n+\n+  /**\n+   * Creates new local activity marker\n+   *\n+   * @param localActivityParameters used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static LocalActivityStateMachine newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new LocalActivityStateMachine(\n+        replaying,\n+        setCurrentTimeCallback,\n+        localActivityParameters,\n+        callback,\n+        localActivityRequestSink,\n+        commandSink,\n+        stateMachineSink);\n+  }\n+\n+  private LocalActivityStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.setCurrentTimeCallback = setCurrentTimeCallback;\n+    this.localActivityParameters = localActivityParameters;\n+    this.localActivityRequestSink = localActivityRequestSink;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.CHECK_EXECUTION_STATE);\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    GET_REQUEST,\n+    HANDLE_RESPONSE,\n+    NON_REPLAY_WORKFLOW_TASK_STARTED\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    REQUEST_PREPARED,\n+    REQUEST_SENT,\n+    RESULT_NOTIFIED,\n+    MARKER_COMMAND_CREATED,\n+    MARKER_COMMAND_RECORDED,\n+    WAITING_MARKER_EVENT,\n+    RESULT_NOTIFIED_REPLAYING\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, LocalActivityStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, LocalActivityStateMachine>newInstance(\n+                  \"LocalActivity\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  LocalActivityStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.REQUEST_PREPARED,\n+                  LocalActivityStateMachine::sendRequest)\n+              .add(State.REQUEST_PREPARED, ExplicitEvent.GET_REQUEST, State.REQUEST_SENT)\n+              .add(\n+                  State.REQUEST_SENT,\n+                  ExplicitEvent.NON_REPLAY_WORKFLOW_TASK_STARTED,\n+                  State.REQUEST_SENT)\n+              .add(\n+                  State.REQUEST_SENT,\n+                  ExplicitEvent.HANDLE_RESPONSE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf241cf397678698be6add3bcb457101f7b2cd0"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2Mjc1MTEw", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-466275110", "createdAt": "2020-08-12T21:02:30Z", "commit": {"oid": "abf241cf397678698be6add3bcb457101f7b2cd0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTowMjozMFrOG_ywJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTowMjozMFrOG_ywJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU0NDk5OA==", "bodyText": "had a hard time following this. when calling getExecutionState wouldn't it still be as if the \"first time\" it ran? OR does the force workflowtask is started create a persistent checkpoint", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469544998", "createdAt": "2020-08-12T21:02:30Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/internal/statemachines/LocalActivityStateMachine.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.RecordMarkerCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.failure.v1.ActivityFailureInfo;\n+import io.temporal.api.failure.v1.CanceledFailureInfo;\n+import io.temporal.api.failure.v1.Failure;\n+import io.temporal.api.history.v1.MarkerRecordedEventAttributes;\n+import io.temporal.api.workflowservice.v1.PollActivityTaskQueueResponse;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCanceledRequest;\n+import io.temporal.api.workflowservice.v1.RespondActivityTaskCompletedRequest;\n+import io.temporal.common.converter.DataConverter;\n+import io.temporal.failure.FailureConverter;\n+import io.temporal.internal.replay.ExecuteLocalActivityParameters;\n+import io.temporal.internal.worker.ActivityTaskHandler;\n+import io.temporal.workflow.Functions;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+final class LocalActivityStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        LocalActivityStateMachine.State,\n+        LocalActivityStateMachine.ExplicitEvent,\n+        LocalActivityStateMachine> {\n+\n+  static final String LOCAL_ACTIVITY_MARKER_NAME = \"LocalActivity\";\n+  static final String MARKER_ACTIVITY_ID_KEY = \"activityId\";\n+  static final String MARKER_TIME_KEY = \"time\";\n+  static final String MARKER_DATA_KEY = \"data\";\n+\n+  private final DataConverter dataConverter = DataConverter.getDefaultInstance();\n+\n+  private final Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink;\n+  private final Functions.Proc2<Optional<Payloads>, Failure> callback;\n+\n+  private final ExecuteLocalActivityParameters localActivityParameters;\n+  private final Functions.Func<Boolean> replaying;\n+  /** Accepts proposed current time. Returns accepted current time. */\n+  private final Functions.Func1<Long, Long> setCurrentTimeCallback;\n+\n+  private Failure failure;\n+  private ActivityTaskHandler.Result result;\n+  private Optional<Payloads> laResult;\n+\n+  /**\n+   * Creates new local activity marker\n+   *\n+   * @param localActivityParameters used to produce side effect value. null if replaying.\n+   * @param callback returns side effect value or failure\n+   * @param commandSink callback to send commands to\n+   */\n+  public static LocalActivityStateMachine newInstance(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    return new LocalActivityStateMachine(\n+        replaying,\n+        setCurrentTimeCallback,\n+        localActivityParameters,\n+        callback,\n+        localActivityRequestSink,\n+        commandSink,\n+        stateMachineSink);\n+  }\n+\n+  private LocalActivityStateMachine(\n+      Functions.Func<Boolean> replaying,\n+      Functions.Func1<Long, Long> setCurrentTimeCallback,\n+      ExecuteLocalActivityParameters localActivityParameters,\n+      Functions.Proc2<Optional<Payloads>, Failure> callback,\n+      Functions.Proc1<ExecuteLocalActivityParameters> localActivityRequestSink,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    super(STATE_MACHINE_DEFINITION, commandSink, stateMachineSink);\n+    this.replaying = replaying;\n+    this.setCurrentTimeCallback = setCurrentTimeCallback;\n+    this.localActivityParameters = localActivityParameters;\n+    this.localActivityRequestSink = localActivityRequestSink;\n+    this.callback = callback;\n+    explicitEvent(ExplicitEvent.CHECK_EXECUTION_STATE);\n+    explicitEvent(ExplicitEvent.SCHEDULE);\n+  }\n+\n+  enum ExplicitEvent {\n+    CHECK_EXECUTION_STATE,\n+    SCHEDULE,\n+    GET_REQUEST,\n+    HANDLE_RESPONSE,\n+    NON_REPLAY_WORKFLOW_TASK_STARTED\n+  }\n+\n+  enum State {\n+    CREATED,\n+    REPLAYING,\n+    EXECUTING,\n+    REQUEST_PREPARED,\n+    REQUEST_SENT,\n+    RESULT_NOTIFIED,\n+    MARKER_COMMAND_CREATED,\n+    MARKER_COMMAND_RECORDED,\n+    WAITING_MARKER_EVENT,\n+    RESULT_NOTIFIED_REPLAYING\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, LocalActivityStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, LocalActivityStateMachine>newInstance(\n+                  \"LocalActivity\", State.CREATED, State.MARKER_COMMAND_RECORDED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.CHECK_EXECUTION_STATE,\n+                  new State[] {State.REPLAYING, State.EXECUTING},\n+                  LocalActivityStateMachine::getExecutionState)\n+              .add(\n+                  State.EXECUTING,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.REQUEST_PREPARED,\n+                  LocalActivityStateMachine::sendRequest)\n+              .add(State.REQUEST_PREPARED, ExplicitEvent.GET_REQUEST, State.REQUEST_SENT)\n+              .add(\n+                  State.REQUEST_SENT,\n+                  ExplicitEvent.NON_REPLAY_WORKFLOW_TASK_STARTED,\n+                  State.REQUEST_SENT)\n+              .add(\n+                  State.REQUEST_SENT,\n+                  ExplicitEvent.HANDLE_RESPONSE,\n+                  State.MARKER_COMMAND_CREATED,\n+                  LocalActivityStateMachine::createMarker)\n+              .add(\n+                  State.MARKER_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_RECORD_MARKER,\n+                  State.RESULT_NOTIFIED,\n+                  LocalActivityStateMachine::notifyResultFromResponse)\n+              .add(\n+                  State.RESULT_NOTIFIED,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED)\n+              .add(State.REPLAYING, ExplicitEvent.SCHEDULE, State.WAITING_MARKER_EVENT)\n+              .add(\n+                  State.WAITING_MARKER_EVENT,\n+                  EventType.EVENT_TYPE_MARKER_RECORDED,\n+                  State.MARKER_COMMAND_RECORDED,\n+                  LocalActivityStateMachine::notifyResultFromEvent)\n+              .add(\n+                  // This is to cover the following edge case:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf241cf397678698be6add3bcb457101f7b2cd0"}, "originalPosition": 173}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65ffd00a39575c4d3f242c398262b445c517ebb8", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/65ffd00a39575c4d3f242c398262b445c517ebb8", "committedDate": "2020-08-13T03:07:33Z", "message": "Refactored ReplayWorkflowExecutor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "919cad6eba2a314a9b8309fba84caa5d01cdfe1c", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/919cad6eba2a314a9b8309fba84caa5d01cdfe1c", "committedDate": "2020-08-13T03:09:35Z", "message": "Renamed StatefulTaskHandler to WorkflowRunTaskHandler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NDI1NjU3", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-466425657", "createdAt": "2020-08-13T03:50:15Z", "commit": {"oid": "919cad6eba2a314a9b8309fba84caa5d01cdfe1c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMzo1MDoxNVrOG_7AIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMzo1MDoxNVrOG_7AIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTY4MDE2Mw==", "bodyText": "why not have negative check here? Or do we treat that as 0? Interesting that we have different behavior than above (although I guess w/different defaults that makes sense)", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r469680163", "createdAt": "2020-08-13T03:50:15Z", "author": {"login": "mastermanu"}, "path": "src/main/java/io/temporal/worker/WorkerOptions.java", "diffHunk": "@@ -143,8 +144,8 @@ public Builder setMaxConcurrentLocalActivityExecutionSize(\n      * every 10 seconds. This can be used to protect down stream services from flooding. The zero\n      * value of this uses the default value. Default is unlimited.\n      */\n-    public Builder setTaskQueueActivitiesPerSecond(double taskQueueActivitiesPerSecond) {\n-      this.taskQueueActivitiesPerSecond = taskQueueActivitiesPerSecond;\n+    public Builder setMaxTaskQueueActivitiesPerSecond(double maxTaskQueueActivitiesPerSecond) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "919cad6eba2a314a9b8309fba84caa5d01cdfe1c"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6918a064fb75ac465cda8ab7078d7438e862c9a", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/d6918a064fb75ac465cda8ab7078d7438e862c9a", "committedDate": "2020-08-13T04:25:27Z", "message": "Fixed local activity retries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92a3e36f6a15c46099d6fadd7a49074a64c6ec28", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/92a3e36f6a15c46099d6fadd7a49074a64c6ec28", "committedDate": "2020-08-13T04:37:47Z", "message": "PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a4dc3876eea110fc74d03840ea3601db10a83af", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/0a4dc3876eea110fc74d03840ea3601db10a83af", "committedDate": "2020-08-13T05:39:19Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81a5fb3787d0549c786dbbe2c09f31daa96196f3", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/81a5fb3787d0549c786dbbe2c09f31daa96196f3", "committedDate": "2020-08-13T21:11:16Z", "message": "Fixed Saga defaults"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MjcyNzIz", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-467272723", "createdAt": "2020-08-14T02:42:20Z", "commit": {"oid": "81a5fb3787d0549c786dbbe2c09f31daa96196f3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ddab733749843b1db745cf45e3f8b1849be89f0", "author": {"user": {"login": "mfateev", "name": "Maxim Fateev"}}, "url": "https://github.com/temporalio/sdk-java/commit/4ddab733749843b1db745cf45e3f8b1849be89f0", "committedDate": "2020-08-14T04:54:06Z", "message": "Fixed sticky task and cache invalidation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NjIxOTg3", "url": "https://github.com/temporalio/sdk-java/pull/172#pullrequestreview-467621987", "createdAt": "2020-08-14T14:30:45Z", "commit": {"oid": "4ddab733749843b1db745cf45e3f8b1849be89f0"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNDozMDo0NVrOHA2xAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNDozMjoyMVrOHA20ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY1OTMyOQ==", "bodyText": "What are the side effects of not defining the no-op transitions that are command based?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r470659329", "createdAt": "2020-08-14T14:30:45Z", "author": {"login": "shawnhathaway"}, "path": "src/main/java/io/temporal/internal/statemachines/ChildWorkflowStateMachine.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.command.v1.Command;\n+import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;\n+import io.temporal.api.common.v1.Payloads;\n+import io.temporal.api.common.v1.WorkflowExecution;\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.enums.v1.EventType;\n+import io.temporal.api.enums.v1.RetryState;\n+import io.temporal.api.enums.v1.TimeoutType;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionCompletedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTerminatedEventAttributes;\n+import io.temporal.api.history.v1.ChildWorkflowExecutionTimedOutEventAttributes;\n+import io.temporal.api.history.v1.StartChildWorkflowExecutionFailedEventAttributes;\n+import io.temporal.client.WorkflowExecutionAlreadyStarted;\n+import io.temporal.common.converter.EncodedValues;\n+import io.temporal.failure.CanceledFailure;\n+import io.temporal.failure.ChildWorkflowFailure;\n+import io.temporal.failure.TerminatedFailure;\n+import io.temporal.failure.TimeoutFailure;\n+import io.temporal.internal.replay.ChildWorkflowTaskFailedException;\n+import io.temporal.workflow.Functions;\n+import java.util.Optional;\n+\n+final class ChildWorkflowStateMachine\n+    extends EntityStateMachineInitialCommand<\n+        ChildWorkflowStateMachine.State,\n+        ChildWorkflowStateMachine.ExplicitEvent,\n+        ChildWorkflowStateMachine> {\n+\n+  enum ExplicitEvent {\n+    SCHEDULE,\n+    CANCEL\n+  }\n+\n+  enum State {\n+    CREATED,\n+    START_COMMAND_CREATED,\n+    START_EVENT_RECORDED,\n+    STARTED,\n+    START_FAILED,\n+    COMPLETED,\n+    FAILED,\n+    CANCELED,\n+    TIMED_OUT,\n+    TERMINATED,\n+  }\n+\n+  public static final StateMachineDefinition<State, ExplicitEvent, ChildWorkflowStateMachine>\n+      STATE_MACHINE_DEFINITION =\n+          StateMachineDefinition.<State, ExplicitEvent, ChildWorkflowStateMachine>newInstance(\n+                  \"ChildWorkflow\",\n+                  State.CREATED,\n+                  State.START_FAILED,\n+                  State.COMPLETED,\n+                  State.FAILED,\n+                  State.CANCELED,\n+                  State.TIMED_OUT,\n+                  State.TERMINATED)\n+              .add(\n+                  State.CREATED,\n+                  ExplicitEvent.SCHEDULE,\n+                  State.START_COMMAND_CREATED,\n+                  ChildWorkflowStateMachine::createStartChildCommand)\n+              .add(\n+                  State.START_COMMAND_CREATED,\n+                  CommandType.COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ddab733749843b1db745cf45e3f8b1849be89f0"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MDIxOQ==", "bodyText": "Why are events registered/validated, but commands are not?", "url": "https://github.com/temporalio/sdk-java/pull/172#discussion_r470660219", "createdAt": "2020-08-14T14:32:21Z", "author": {"login": "shawnhathaway"}, "path": "src/main/java/io/temporal/internal/statemachines/EntityStateMachineBase.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.internal.statemachines;\n+\n+import io.temporal.api.enums.v1.CommandType;\n+import io.temporal.api.history.v1.HistoryEvent;\n+import io.temporal.workflow.Functions;\n+\n+class EntityStateMachineBase<State, ExplicitEvent, Data> implements EntityStateMachine {\n+\n+  private final StateMachine<State, ExplicitEvent, Data> stateMachine;\n+\n+  protected final Functions.Proc1<CancellableCommand> commandSink;\n+\n+  protected HistoryEvent currentEvent;\n+  protected boolean hasNextEvent;\n+\n+  public EntityStateMachineBase(\n+      StateMachineDefinition<State, ExplicitEvent, Data> stateMachineDefinition,\n+      Functions.Proc1<CancellableCommand> commandSink,\n+      Functions.Proc1<StateMachine> stateMachineSink) {\n+    this.stateMachine = StateMachine.newInstance(stateMachineDefinition);\n+    this.commandSink = commandSink;\n+    stateMachineSink.apply(this.stateMachine);\n+  }\n+\n+  /**\n+   * Notifies that command is included into the workflow task completion result.\n+   *\n+   * <p>Is not called for commands generated during replay.\n+   */\n+  @Override\n+  public void handleCommand(CommandType commandType) {\n+    stateMachine.handleCommand(commandType, (Data) this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ddab733749843b1db745cf45e3f8b1849be89f0"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3504, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}