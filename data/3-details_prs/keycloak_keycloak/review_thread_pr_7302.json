{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NDI5MDA4", "number": 7302, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMDoxMVrOEZpFFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMToyNzoyMVrOEfaSLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzIyOTAzOnYy", "diffSide": "RIGHT", "path": "server-spi-private/src/main/java/org/keycloak/migration/migrators/MigrateTo4_0_0.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMDoxMVrOHCk3Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMDoxMVrOHCk3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2MzE1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .peek(c -> {\n          \n          \n            \n                                    .forEach(c -> {", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r472463154", "createdAt": "2020-08-18T20:20:11Z", "author": {"login": "hmlnarik"}, "path": "server-spi-private/src/main/java/org/keycloak/migration/migrators/MigrateTo4_0_0.java", "diffHunk": "@@ -94,40 +94,40 @@ protected void migrateRealm(KeycloakSession session, RealmModel realm, boolean j\n         // If client has scope for offline_access role (either directly or through fullScopeAllowed), then add offline_access client\n         // scope as optional scope to the client. If it's indirectly (no fullScopeAllowed), then remove role from the scoped roles\n         RoleModel offlineAccessRole = realm.getRole(OAuth2Constants.OFFLINE_ACCESS);\n-        ClientScopeModel offlineAccessScope = null;\n+        ClientScopeModel offlineAccessScope;\n         if (offlineAccessRole == null) {\n             LOG.infof(\"Role 'offline_access' not available in realm '%s'. Skip migration of offline_access client scope.\", realm.getName());\n         } else {\n             offlineAccessScope = KeycloakModelUtils.getClientScopeByName(realm, OAuth2Constants.OFFLINE_ACCESS);\n             if (offlineAccessScope == null) {\n                 LOG.infof(\"Client scope 'offline_access' not available in realm '%s'. Skip migration of offline_access client scope.\", realm.getName());\n             } else {\n-                for (ClientModel client : realm.getClients()) {\n-                    if (\"openid-connect\".equals(client.getProtocol())\n-                            && !client.isBearerOnly()\n-                            && client.hasScope(offlineAccessRole)\n-                            && !client.getClientScopes(false, true).containsKey(OAuth2Constants.OFFLINE_ACCESS)) {\n-                        LOG.debugf(\"Adding client scope 'offline_access' as optional scope to client '%s' in realm '%s'.\", client.getClientId(), realm.getName());\n-                        client.addClientScope(offlineAccessScope, false);\n-\n-                        if (!client.isFullScopeAllowed()) {\n-                            LOG.debugf(\"Removing role scope mapping for role 'offline_access' from client '%s' in realm '%s'.\", client.getClientId(), realm.getName());\n-                            client.deleteScopeMapping(offlineAccessRole);\n-                        }\n-                    }\n-                }\n+                session.clients().getClientsStream(realm)\n+                        .filter(MigrationUtils::isOIDCNonBearerOnlyClient)\n+                        .filter(c -> c.hasScope(offlineAccessRole))\n+                        .filter(c -> !c.getClientScopes(false, true).containsKey(OAuth2Constants.OFFLINE_ACCESS))\n+                        .peek(c -> {\n+                            LOG.debugf(\"Adding client scope 'offline_access' as optional scope to client '%s' in realm '%s'.\", c.getClientId(), realm.getName());\n+                            c.addClientScope(offlineAccessScope, false);\n+                        })\n+                        .filter(c -> !c.isFullScopeAllowed())\n+                        .peek(c -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20d0ef10d44f94262abb9d4c613902d84cdec80"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI3Mzc0OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/partialimport/RealmRolesPartialImport.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyODowMFrOHClUPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyODowMFrOHClUPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MDU5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (role.isPresent()) {\n          \n          \n            \n                        return role.get().getId();\n          \n          \n            \n                    }\n          \n          \n            \n                    return null;\n          \n          \n            \n                    return role.map(RoleModel::getId).orElse(null);", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r472470591", "createdAt": "2020-08-18T20:28:00Z", "author": {"login": "hmlnarik"}, "path": "services/src/main/java/org/keycloak/partialimport/RealmRolesPartialImport.java", "diffHunk": "@@ -56,20 +58,17 @@ public String getName(RoleRepresentation roleRep) {\n \n     @Override\n     public String getModelId(RealmModel realm, KeycloakSession session, RoleRepresentation roleRep) {\n-        for (RoleModel role : realm.getRoles()) {\n-            if (getName(roleRep).equals(role.getName())) return role.getId();\n-        }\n+        Optional<RoleModel> role = realm.getRolesStream().filter(r -> Objects.equals(getName(roleRep), r.getName())).findFirst();\n \n+        if (role.isPresent()) {\n+            return role.get().getId();\n+        }\n         return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20d0ef10d44f94262abb9d4c613902d84cdec80"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1Njg0NzAxOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzo0OToxNlrOHDITWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzo0OToxNlrOHDITWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA0MzgwMQ==", "bodyText": "Can this be broken down to remove dependency on offlineClients and extracted to a named method rather than anonymous method?", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r473043801", "createdAt": "2020-08-19T13:49:16Z", "author": {"login": "hmlnarik"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "diffHunk": "@@ -465,40 +465,39 @@ public void removeFederatedIdentity(final @PathParam(\"provider\") String provider\n     @Produces(MediaType.APPLICATION_JSON)\n     public List<Map<String, Object>> getConsents() {\n         auth.users().requireView(user);\n-        List<Map<String, Object>> result = new LinkedList<>();\n \n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        for (ClientModel client : realm.getClients()) {\n-            UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n-            boolean hasOfflineToken = offlineClients.contains(client);\n-\n-            if (consent == null && !hasOfflineToken) {\n-                continue;\n-            }\n-\n-            UserConsentRepresentation rep = (consent == null) ? null : ModelToRepresentation.toRepresentation(consent);\n-\n-            Map<String, Object> currentRep = new HashMap<>();\n-            currentRep.put(\"clientId\", client.getClientId());\n-            currentRep.put(\"grantedClientScopes\", (rep==null ? Collections.emptyList() : rep.getGrantedClientScopes()));\n-            currentRep.put(\"createdDate\", (rep==null ? null : rep.getCreatedDate()));\n-            currentRep.put(\"lastUpdatedDate\", (rep==null ? null : rep.getLastUpdatedDate()));\n-\n-            List<Map<String, String>> additionalGrants = new LinkedList<>();\n-            if (hasOfflineToken) {\n-                Map<String, String> offlineTokens = new HashMap<>();\n-                offlineTokens.put(\"client\", client.getId());\n-                // TODO: translate\n-                offlineTokens.put(\"key\", \"Offline Token\");\n-                additionalGrants.add(offlineTokens);\n-            }\n-            currentRep.put(\"additionalGrants\", additionalGrants);\n-\n-            result.add(currentRep);\n-        }\n-\n-        return result;\n+        return session.clients().getClientsStream(realm)\n+                .map(client -> {\n+                    UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n+                    boolean hasOfflineToken = offlineClients.contains(client);\n+\n+                    if (consent == null && !hasOfflineToken) {\n+                        return null;\n+                    }\n+\n+                    UserConsentRepresentation rep = (consent == null) ? null : ModelToRepresentation.toRepresentation(consent);\n+\n+                    Map<String, Object> currentRep = new HashMap<>();\n+                    currentRep.put(\"clientId\", client.getClientId());\n+                    currentRep.put(\"grantedClientScopes\", (rep == null ? Collections.emptyList() : rep.getGrantedClientScopes()));\n+                    currentRep.put(\"createdDate\", (rep == null ? null : rep.getCreatedDate()));\n+                    currentRep.put(\"lastUpdatedDate\", (rep == null ? null : rep.getLastUpdatedDate()));\n+\n+                    List<Map<String, String>> additionalGrants = new LinkedList<>();\n+                    if (hasOfflineToken) {\n+                        Map<String, String> offlineTokens = new HashMap<>();\n+                        offlineTokens.put(\"client\", client.getId());\n+                        // TODO: translate\n+                        offlineTokens.put(\"key\", \"Offline Token\");\n+                        additionalGrants.add(offlineTokens);\n+                    }\n+                    currentRep.put(\"additionalGrants\", additionalGrants);\n+                    return currentRep;\n+                })\n+                .filter(Objects::nonNull)\n+                .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20d0ef10d44f94262abb9d4c613902d84cdec80"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1Njg3OTMzOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/util/ScopeMappedUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzo1NjoxN1rOHDInYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzo1NjoxN1rOHDInYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA0ODkyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<RoleRepresentation> roles = new ArrayList<>();\n          \n          \n            \n                        List<RoleRepresentation> roles = new LinkedList<>();", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r473048929", "createdAt": "2020-08-19T13:56:17Z", "author": {"login": "hmlnarik"}, "path": "services/src/main/java/org/keycloak/services/util/ScopeMappedUtil.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.util;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.ScopeContainerModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.models.utils.ModelToRepresentation;\n+import org.keycloak.representations.idm.ClientMappingsRepresentation;\n+import org.keycloak.representations.idm.RoleRepresentation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class ScopeMappedUtil {\n+    public static ClientMappingsRepresentation toClientMappingsRepresentation(ClientModel client, ScopeContainerModel scopeContainer) {\n+        Set<RoleModel> roleMappings = KeycloakModelUtils.getClientScopeMappings(client, scopeContainer);\n+\n+        if (roleMappings.size() > 0) {\n+\n+            ClientMappingsRepresentation mappings = new ClientMappingsRepresentation();\n+            mappings.setId(client.getId());\n+            mappings.setClient(client.getClientId());\n+            List<RoleRepresentation> roles = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20d0ef10d44f94262abb9d4c613902d84cdec80"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1Njg4MjAwOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/util/ScopeMappedUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzo1Njo1MFrOHDIpEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzo1Njo1MFrOHDIpEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA0OTM2Mg==", "bodyText": "For performance, prefer:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (roleMappings.size() > 0) {\n          \n          \n            \n                    if (! roleMappings.isEmpty()) {", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r473049362", "createdAt": "2020-08-19T13:56:50Z", "author": {"login": "hmlnarik"}, "path": "services/src/main/java/org/keycloak/services/util/ScopeMappedUtil.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.util;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.ScopeContainerModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.models.utils.ModelToRepresentation;\n+import org.keycloak.representations.idm.ClientMappingsRepresentation;\n+import org.keycloak.representations.idm.RoleRepresentation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class ScopeMappedUtil {\n+    public static ClientMappingsRepresentation toClientMappingsRepresentation(ClientModel client, ScopeContainerModel scopeContainer) {\n+        Set<RoleModel> roleMappings = KeycloakModelUtils.getClientScopeMappings(client, scopeContainer);\n+\n+        if (roleMappings.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20d0ef10d44f94262abb9d4c613902d84cdec80"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1ODExMTQwOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODo1MDowOVrOHDU0RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODo1MDowOVrOHDU0RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI0ODgzNw==", "bodyText": "Can this code be simplified?", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r473248837", "createdAt": "2020-08-19T18:50:09Z", "author": {"login": "hmlnarik"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "diffHunk": "@@ -465,40 +465,39 @@ public void removeFederatedIdentity(final @PathParam(\"provider\") String provider\n     @Produces(MediaType.APPLICATION_JSON)\n     public List<Map<String, Object>> getConsents() {\n         auth.users().requireView(user);\n-        List<Map<String, Object>> result = new LinkedList<>();\n \n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        for (ClientModel client : realm.getClients()) {\n-            UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n-            boolean hasOfflineToken = offlineClients.contains(client);\n-\n-            if (consent == null && !hasOfflineToken) {\n-                continue;\n-            }\n-\n-            UserConsentRepresentation rep = (consent == null) ? null : ModelToRepresentation.toRepresentation(consent);\n-\n-            Map<String, Object> currentRep = new HashMap<>();\n-            currentRep.put(\"clientId\", client.getClientId());\n-            currentRep.put(\"grantedClientScopes\", (rep==null ? Collections.emptyList() : rep.getGrantedClientScopes()));\n-            currentRep.put(\"createdDate\", (rep==null ? null : rep.getCreatedDate()));\n-            currentRep.put(\"lastUpdatedDate\", (rep==null ? null : rep.getLastUpdatedDate()));\n-\n-            List<Map<String, String>> additionalGrants = new LinkedList<>();\n-            if (hasOfflineToken) {\n-                Map<String, String> offlineTokens = new HashMap<>();\n-                offlineTokens.put(\"client\", client.getId());\n-                // TODO: translate\n-                offlineTokens.put(\"key\", \"Offline Token\");\n-                additionalGrants.add(offlineTokens);\n-            }\n-            currentRep.put(\"additionalGrants\", additionalGrants);\n-\n-            result.add(currentRep);\n-        }\n-\n-        return result;\n+        return session.clients().getClientsStream(realm)\n+                .map(client -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20d0ef10d44f94262abb9d4c613902d84cdec80"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1ODExNjY2OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/resources/admin/ScopeMappedResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODo1MTo0OFrOHDU3aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODo1MTo0OFrOHDU3aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI0OTY0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<RoleRepresentation> realmRep = new ArrayList<>();\n          \n          \n            \n                        List<RoleRepresentation> realmRep = new LinkedList<>();", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r473249640", "createdAt": "2020-08-19T18:51:48Z", "author": {"login": "hmlnarik"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/ScopeMappedResource.java", "diffHunk": "@@ -98,31 +102,21 @@ public MappingsRepresentation getScopeMappings() {\n         MappingsRepresentation all = new MappingsRepresentation();\n         Set<RoleModel> realmMappings = scopeContainer.getRealmScopeMappings();\n         if (realmMappings.size() > 0) {\n-            List<RoleRepresentation> realmRep = new ArrayList<RoleRepresentation>();\n+            List<RoleRepresentation> realmRep = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20d0ef10d44f94262abb9d4c613902d84cdec80"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1ODExOTY1OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/resources/admin/ScopeMappedResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODo1Mjo1NFrOHDU5Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODo1Mjo1NFrOHDU5Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI1MDEzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Stream<ClientModel> clients = session.clients().getClientsStream(realm);\n          \n          \n            \n                    Map<String, ClientMappingsRepresentation> clientMappings = clients\n          \n          \n            \n                            .map(c -> ScopeMappedUtil.toClientMappingsRepresentation(c, scopeContainer))\n          \n          \n            \n                            .filter(Objects::nonNull)\n          \n          \n            \n                            .collect(Collectors.toMap(ClientMappingsRepresentation::getClient, Function.identity()));\n          \n          \n            \n            \n          \n          \n            \n                    if (clientMappings.size() > 0) {\n          \n          \n            \n                        all.setClientMappings(clientMappings);\n          \n          \n            \n                    }\n          \n          \n            \n                    try (Stream<ClientModel> clients = session.clients().getClientsStream(realm)) {\n          \n          \n            \n                        Map<String, ClientMappingsRepresentation> clientMappings = clients\n          \n          \n            \n                                .map(c -> ScopeMappedUtil.toClientMappingsRepresentation(c, scopeContainer))\n          \n          \n            \n                                .filter(Objects::nonNull)\n          \n          \n            \n                                .collect(Collectors.toMap(ClientMappingsRepresentation::getClient, Function.identity()));\n          \n          \n            \n            \n          \n          \n            \n                        if (clientMappings.size() > 0) {\n          \n          \n            \n                            all.setClientMappings(clientMappings);\n          \n          \n            \n                        }\n          \n          \n            \n                    }", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r473250138", "createdAt": "2020-08-19T18:52:54Z", "author": {"login": "hmlnarik"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/ScopeMappedResource.java", "diffHunk": "@@ -98,31 +102,21 @@ public MappingsRepresentation getScopeMappings() {\n         MappingsRepresentation all = new MappingsRepresentation();\n         Set<RoleModel> realmMappings = scopeContainer.getRealmScopeMappings();\n         if (realmMappings.size() > 0) {\n-            List<RoleRepresentation> realmRep = new ArrayList<RoleRepresentation>();\n+            List<RoleRepresentation> realmRep = new ArrayList<>();\n             for (RoleModel roleModel : realmMappings) {\n                 realmRep.add(ModelToRepresentation.toBriefRepresentation(roleModel));\n             }\n             all.setRealmMappings(realmRep);\n         }\n \n-        List<ClientModel> clients = realm.getClients();\n-        if (clients.size() > 0) {\n-            Map<String, ClientMappingsRepresentation> clientMappings = new HashMap<String, ClientMappingsRepresentation>();\n-            for (ClientModel client : clients) {\n-                Set<RoleModel> roleMappings = KeycloakModelUtils.getClientScopeMappings(client, this.scopeContainer); //client.getClientScopeMappings(this.client);\n-                if (roleMappings.size() > 0) {\n-                    ClientMappingsRepresentation mappings = new ClientMappingsRepresentation();\n-                    mappings.setId(client.getId());\n-                    mappings.setClient(client.getClientId());\n-                    List<RoleRepresentation> roles = new ArrayList<RoleRepresentation>();\n-                    mappings.setMappings(roles);\n-                    for (RoleModel role : roleMappings) {\n-                        roles.add(ModelToRepresentation.toBriefRepresentation(role));\n-                    }\n-                    clientMappings.put(client.getClientId(), mappings);\n-                    all.setClientMappings(clientMappings);\n-                }\n-            }\n+        Stream<ClientModel> clients = session.clients().getClientsStream(realm);\n+        Map<String, ClientMappingsRepresentation> clientMappings = clients\n+                .map(c -> ScopeMappedUtil.toClientMappingsRepresentation(c, scopeContainer))\n+                .filter(Objects::nonNull)\n+                .collect(Collectors.toMap(ClientMappingsRepresentation::getClient, Function.identity()));\n+\n+        if (clientMappings.size() > 0) {\n+            all.setClientMappings(clientMappings);\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a20d0ef10d44f94262abb9d4c613902d84cdec80"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzcxOTUxOnYy", "diffSide": "RIGHT", "path": "authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/role/RolePolicyProviderFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMToyNzoyMVrOHLqv7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowMDo1OFrOHMoCxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Njc4MA==", "bodyText": "Are we going to replace any other occurrence of RealmModel.getClientByClientId(String) with session.clients().getClientByClientId(RealmModel, String)? It's not clear to me why we update it here but not on all other places. Are all other occurrences used becouse we don't have access to keycloak session there?\nThe same question applies to RealmModel.getClientById(String).", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r481996780", "createdAt": "2020-09-02T11:27:21Z", "author": {"login": "vramik"}, "path": "authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/role/RolePolicyProviderFactory.java", "diffHunk": "@@ -163,7 +164,7 @@ private void updateRoles(Policy policy, AuthorizationProvider authorization, Set\n                         role = realm.getRoleById(roleName);\n                     }\n                 } else {\n-                    ClientModel client = realm.getClientByClientId(clientId);\n+                    ClientModel client = session.clients().getClientByClientId(realm, clientId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64746b742f24cc02899d91d8fcba20c7520b0899"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc5MDA3OQ==", "bodyText": "@vramik Good question. I guess I somehow assumed that I'll only change those occurrences which are relevant to this PR and the rest is/will be changed in a different PR. I'll revert these changes and it can be done in a separate task. WDYT?", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r482790079", "createdAt": "2020-09-03T08:10:10Z", "author": {"login": "martin-kanis"}, "path": "authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/role/RolePolicyProviderFactory.java", "diffHunk": "@@ -163,7 +164,7 @@ private void updateRoles(Policy policy, AuthorizationProvider authorization, Set\n                         role = realm.getRoleById(roleName);\n                     }\n                 } else {\n-                    ClientModel client = realm.getClientByClientId(clientId);\n+                    ClientModel client = session.clients().getClientByClientId(realm, clientId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Njc4MA=="}, "originalCommit": {"oid": "64746b742f24cc02899d91d8fcba20c7520b0899"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMTAyOA==", "bodyText": "The original version (via realm) should serve as a shortcut to the new version (via session), so they are effectively equivalent. There is no strong rule which drives which use when though.\nFrom readability perspective, the physical storage layer, it may be preferrable to use the latter approach with session, but in the logical layer (e.g. from services), the former would likely prevail.\nWe could perhaps add a comment in the javadoc to these shortcuts similar to This call is effectively the same as {@code session.clients().getClientByClientId(this, clientId);}..", "url": "https://github.com/keycloak/keycloak/pull/7302#discussion_r483001028", "createdAt": "2020-09-03T14:00:58Z", "author": {"login": "hmlnarik"}, "path": "authz/policy/common/src/main/java/org/keycloak/authorization/policy/provider/role/RolePolicyProviderFactory.java", "diffHunk": "@@ -163,7 +164,7 @@ private void updateRoles(Policy policy, AuthorizationProvider authorization, Set\n                         role = realm.getRoleById(roleName);\n                     }\n                 } else {\n-                    ClientModel client = realm.getClientByClientId(clientId);\n+                    ClientModel client = session.clients().getClientByClientId(realm, clientId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Njc4MA=="}, "originalCommit": {"oid": "64746b742f24cc02899d91d8fcba20c7520b0899"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3498, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}