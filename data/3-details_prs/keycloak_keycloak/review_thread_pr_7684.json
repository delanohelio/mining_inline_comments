{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxODMxNTE0", "number": 7684, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMDo1MDo0M1rOFOFzrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTo1NTo1OVrOFQUaiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwMzE5NTMyOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/ModelCriteriaBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMDo1MDo0M1rOISpyrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxMDowNDoyOFrOIUUajg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQyOTk5OA==", "bodyText": "Will there remain both KEYCLOAK-16584 and KEYCLOAK-16118 commits?\nIt seems to me (and I might be wrong :) ) ModelCriteriaBuilder should rather belong to KEYCLOAK-16118 commit than to this one. But it'd mean to move all related code there so I'm not sure if it's worth it, wdyt?", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r556429998", "createdAt": "2021-01-13T10:50:43Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/ModelCriteriaBuilder.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.storage.SearchableModelField;\n+\n+/**\n+ * Builder for criteria that can be used to limit results obtained from the store.\n+ * This class is used for similar purpose as e.g. JPA's {@code CriteriaBuilder},\n+ * however it is much simpler version as it is tailored to very specific needs\n+ * of future Keycloak store.\n+ * <p>\n+ * Implementations are expected to be immutable. The expected use is like this:\n+ * <pre>\n+ * cb = storage.getCriteriaBuilder();\n+ * storage.read(\n+ *   cb.or(\n+ *     cb.compare(FIELD1, EQ, 1).compare(FIELD2, EQ, 2),\n+ *     cb.compare(FIELD1, EQ, 3).compare(FIELD2, EQ, 4)\n+ *   )\n+ * );\n+ * </pre>\n+ * The above code should read items where\n+ * {@code (FIELD1 == 1 && FIELD2 == 2) || (FIELD1 == 3 && FIELD2 == 4)}.\n+ *\n+ * <p>\n+ * It is equivalent to this:\n+ * <pre>\n+ * cb = storage.getCriteriaBuilder();\n+ * storage.read(\n+ *   cb.or(\n+ *     cb.and(cb.compare(FIELD1, EQ, 1), cb.compare(FIELD2, EQ, 2)),\n+ *     cb.and(cb.compare(FIELD1, EQ, 3), cb.compare(FIELD2, EQ, 4))\n+ *   )\n+ * );\n+ * </pre>\n+ *\n+ * @author hmlnarik\n+ */\n+public interface ModelCriteriaBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9764901d76cc2688c1372453ba0f9928da04d9b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODE3NjkxMA==", "bodyText": "This is exactly the concern, the boundary is blurred here. I'd prefer to keep it as is right now.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r558176910", "createdAt": "2021-01-15T10:04:28Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/ModelCriteriaBuilder.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.storage.SearchableModelField;\n+\n+/**\n+ * Builder for criteria that can be used to limit results obtained from the store.\n+ * This class is used for similar purpose as e.g. JPA's {@code CriteriaBuilder},\n+ * however it is much simpler version as it is tailored to very specific needs\n+ * of future Keycloak store.\n+ * <p>\n+ * Implementations are expected to be immutable. The expected use is like this:\n+ * <pre>\n+ * cb = storage.getCriteriaBuilder();\n+ * storage.read(\n+ *   cb.or(\n+ *     cb.compare(FIELD1, EQ, 1).compare(FIELD2, EQ, 2),\n+ *     cb.compare(FIELD1, EQ, 3).compare(FIELD2, EQ, 4)\n+ *   )\n+ * );\n+ * </pre>\n+ * The above code should read items where\n+ * {@code (FIELD1 == 1 && FIELD2 == 2) || (FIELD1 == 3 && FIELD2 == 4)}.\n+ *\n+ * <p>\n+ * It is equivalent to this:\n+ * <pre>\n+ * cb = storage.getCriteriaBuilder();\n+ * storage.read(\n+ *   cb.or(\n+ *     cb.and(cb.compare(FIELD1, EQ, 1), cb.compare(FIELD2, EQ, 2)),\n+ *     cb.and(cb.compare(FIELD1, EQ, 3), cb.compare(FIELD2, EQ, 4))\n+ *   )\n+ * );\n+ * </pre>\n+ *\n+ * @author hmlnarik\n+ */\n+public interface ModelCriteriaBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQyOTk5OA=="}, "originalCommit": {"oid": "d9764901d76cc2688c1372453ba0f9928da04d9b"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwMzE5NzYzOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/ModelCriteriaBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMDo1MToyNlrOISp0Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMDo1MToyNlrOISp0Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQzMDM3OQ==", "bodyText": "Do we need to update the year to 2021?\nIf so, there are other newly created classes or interfaces.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r556430379", "createdAt": "2021-01-13T10:51:26Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/ModelCriteriaBuilder.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9764901d76cc2688c1372453ba0f9928da04d9b"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwMzIxMjY1OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapStorage.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMDo1NDo1NVrOISp9LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxOTozNjoxNVrOIV1UKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQzMjY4NA==", "bodyText": "Really minor question. Do we need to add also @throws NullPointerException clause in case key is null? I've just noticed the clause is there for create, but not here, so I was wondering if it should't be \"unified\".", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r556432684", "createdAt": "2021-01-13T10:54:55Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapStorage.java", "diffHunk": "@@ -18,21 +18,68 @@\n \n import java.util.Map;\n import java.util.Set;\n+import java.util.stream.Stream;\n \n /**\n  *\n  * @author hmlnarik\n  */\n public interface MapStorage<K, V> {\n \n-    V get(K key);\n+    /**\n+     * Creates an object in the store identified by given {@code key}.\n+     * @param key Key of the object as seen in the logical level\n+     * @param value Entity\n+     * @return Reference to the entity created in the store\n+     * @throws NullPointerException if object or its {@code id} is {@code null}\n+     */\n+    V create(K key, V value);\n \n-    V put(K key, V value);\n+    /**\n+     * Returns object with the given {@code key} from the storage or {@code null} if object does not exist.\n+     * @param key Must not be {@code null}.\n+     * @return See description\n+     */\n+    V read(K key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9764901d76cc2688c1372453ba0f9928da04d9b"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTQ5NjI3NQ==", "bodyText": "Yes. Since it this note is there though, I believe there was a race condition between some of my commits and the review", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r559496275", "createdAt": "2021-01-18T11:22:14Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapStorage.java", "diffHunk": "@@ -18,21 +18,68 @@\n \n import java.util.Map;\n import java.util.Set;\n+import java.util.stream.Stream;\n \n /**\n  *\n  * @author hmlnarik\n  */\n public interface MapStorage<K, V> {\n \n-    V get(K key);\n+    /**\n+     * Creates an object in the store identified by given {@code key}.\n+     * @param key Key of the object as seen in the logical level\n+     * @param value Entity\n+     * @return Reference to the entity created in the store\n+     * @throws NullPointerException if object or its {@code id} is {@code null}\n+     */\n+    V create(K key, V value);\n \n-    V put(K key, V value);\n+    /**\n+     * Returns object with the given {@code key} from the storage or {@code null} if object does not exist.\n+     * @param key Must not be {@code null}.\n+     * @return See description\n+     */\n+    V read(K key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQzMjY4NA=="}, "originalCommit": {"oid": "d9764901d76cc2688c1372453ba0f9928da04d9b"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc2NDUyMg==", "bodyText": "yup, it seems so, thank you", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r559764522", "createdAt": "2021-01-18T19:36:15Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapStorage.java", "diffHunk": "@@ -18,21 +18,68 @@\n \n import java.util.Map;\n import java.util.Set;\n+import java.util.stream.Stream;\n \n /**\n  *\n  * @author hmlnarik\n  */\n public interface MapStorage<K, V> {\n \n-    V get(K key);\n+    /**\n+     * Creates an object in the store identified by given {@code key}.\n+     * @param key Key of the object as seen in the logical level\n+     * @param value Entity\n+     * @return Reference to the entity created in the store\n+     * @throws NullPointerException if object or its {@code id} is {@code null}\n+     */\n+    V create(K key, V value);\n \n-    V put(K key, V value);\n+    /**\n+     * Returns object with the given {@code key} from the storage or {@code null} if object does not exist.\n+     * @param key Must not be {@code null}.\n+     * @return See description\n+     */\n+    V read(K key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQzMjY4NA=="}, "originalCommit": {"oid": "d9764901d76cc2688c1372453ba0f9928da04d9b"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwODk4OTA2OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorage.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxMjowNzo1NFrOITh3iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMToyOToxOFrOIVlLfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0ODc0Nw==", "bodyText": "It might be beneficial to add a javadoc for this method here as it's not overridden from MapStorage so when using it in the code there is no java-doc info what the method actually does, so it has to be seen from the code itself, while other methods has their description from MapStorage interface, wdyt?\nTo be honest I'm not sure why this particular method is not included in the interface. Maybe we could add it there?", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r557348747", "createdAt": "2021-01-14T12:07:54Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorage.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage.chm;\n+\n+import org.keycloak.models.map.storage.MapModelCriteriaBuilder;\n+import org.keycloak.models.map.common.AbstractEntity;\n+import org.keycloak.models.map.storage.MapFieldPredicates;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder;\n+import org.keycloak.storage.SearchableModelField;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapModelCriteriaBuilder.UpdatePredicatesFunc;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class ConcurrentHashMapStorage<K, V extends AbstractEntity<K>, M> implements MapStorage<K, V, M> {\n+\n+    private final ConcurrentMap<K, V> store = new ConcurrentHashMap<>();\n+\n+    private final Map<SearchableModelField<M>, UpdatePredicatesFunc<K, V, M>> fieldPredicates;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public ConcurrentHashMapStorage(Class<M> modelClass) {\n+        this.fieldPredicates = MapFieldPredicates.getPredicates(modelClass);\n+    }\n+\n+    @Override\n+    public V create(K key, V value) {\n+        return store.putIfAbsent(key, value);\n+    }\n+\n+    @Override\n+    public V read(K key) {\n+        Objects.requireNonNull(key, \"Key must be non-null\");\n+        return store.get(key);\n+    }\n+\n+    @Override\n+    public V update(K key, V value) {\n+        return store.replace(key, value);\n+    }\n+\n+    @Override\n+    public boolean delete(K key) {\n+        return store.remove(key) != null;\n+    }\n+\n+    @Override\n+    public long delete(ModelCriteriaBuilder<M> criteria) {\n+        long res;\n+        if (criteria == null) {\n+            res = store.size();\n+            store.clear();\n+            return res;\n+        }\n+\n+        MapModelCriteriaBuilder<K, V, M> b = criteria.unwrap(MapModelCriteriaBuilder.class);\n+        if (b == null) {\n+            throw new IllegalStateException(\"Incompatible class: \" + criteria.getClass());\n+        }\n+        Predicate<? super K> keyFilter = b.getKeyFilter();\n+        Predicate<? super V> entityFilter = b.getEntityFilter();\n+        res = 0;\n+        for (Iterator<Entry<K, V>> iterator = store.entrySet().iterator(); iterator.hasNext();) {\n+            Entry<K, V> next = iterator.next();\n+            if (keyFilter.test(next.getKey()) && entityFilter.test(next.getValue())) {\n+                res++;\n+                iterator.remove();\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Override\n+    public ModelCriteriaBuilder<M> createCriteriaBuilder() {\n+        return new MapModelCriteriaBuilder<>(fieldPredicates);\n+    }\n+\n+    @Override\n+    public MapKeycloakTransaction<K, V, M> createTransaction() {\n+        return new MapKeycloakTransaction<>(this);\n+    }\n+\n+\n+    @Override\n+    public Stream<V> read(ModelCriteriaBuilder<M> criteria) {\n+        if (criteria == null) {\n+            return Stream.empty();\n+        }\n+        Stream<Entry<K, V>> stream = store.entrySet().stream();\n+\n+        MapModelCriteriaBuilder<K, V, M> b = criteria.unwrap(MapModelCriteriaBuilder.class);\n+        if (b == null) {\n+            throw new IllegalStateException(\"Incompatible class: \" + criteria.getClass());\n+        }\n+        Predicate<? super K> keyFilter = b.getKeyFilter();\n+        Predicate<? super V> entityFilter = b.getEntityFilter();\n+        stream = stream.filter(me -> keyFilter.test(me.getKey()) && entityFilter.test(me.getValue()));\n+\n+        return stream.map(Map.Entry::getValue);\n+    }\n+\n+    public Stream<V> read() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ef0fa4cd5fdb267ee23cc6c8cd06df8f2fa6325"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwMDE1Nw==", "bodyText": "Good catch. This method should have been removed.\nReason for not including it in the interface is to remove easy way to read full database which is not desirable anywhere apart from test and development where it can be achieved via the existing read(ModelCriteriaBuilder) method.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r559500157", "createdAt": "2021-01-18T11:29:18Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/chm/ConcurrentHashMapStorage.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage.chm;\n+\n+import org.keycloak.models.map.storage.MapModelCriteriaBuilder;\n+import org.keycloak.models.map.common.AbstractEntity;\n+import org.keycloak.models.map.storage.MapFieldPredicates;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder;\n+import org.keycloak.storage.SearchableModelField;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapModelCriteriaBuilder.UpdatePredicatesFunc;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class ConcurrentHashMapStorage<K, V extends AbstractEntity<K>, M> implements MapStorage<K, V, M> {\n+\n+    private final ConcurrentMap<K, V> store = new ConcurrentHashMap<>();\n+\n+    private final Map<SearchableModelField<M>, UpdatePredicatesFunc<K, V, M>> fieldPredicates;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public ConcurrentHashMapStorage(Class<M> modelClass) {\n+        this.fieldPredicates = MapFieldPredicates.getPredicates(modelClass);\n+    }\n+\n+    @Override\n+    public V create(K key, V value) {\n+        return store.putIfAbsent(key, value);\n+    }\n+\n+    @Override\n+    public V read(K key) {\n+        Objects.requireNonNull(key, \"Key must be non-null\");\n+        return store.get(key);\n+    }\n+\n+    @Override\n+    public V update(K key, V value) {\n+        return store.replace(key, value);\n+    }\n+\n+    @Override\n+    public boolean delete(K key) {\n+        return store.remove(key) != null;\n+    }\n+\n+    @Override\n+    public long delete(ModelCriteriaBuilder<M> criteria) {\n+        long res;\n+        if (criteria == null) {\n+            res = store.size();\n+            store.clear();\n+            return res;\n+        }\n+\n+        MapModelCriteriaBuilder<K, V, M> b = criteria.unwrap(MapModelCriteriaBuilder.class);\n+        if (b == null) {\n+            throw new IllegalStateException(\"Incompatible class: \" + criteria.getClass());\n+        }\n+        Predicate<? super K> keyFilter = b.getKeyFilter();\n+        Predicate<? super V> entityFilter = b.getEntityFilter();\n+        res = 0;\n+        for (Iterator<Entry<K, V>> iterator = store.entrySet().iterator(); iterator.hasNext();) {\n+            Entry<K, V> next = iterator.next();\n+            if (keyFilter.test(next.getKey()) && entityFilter.test(next.getValue())) {\n+                res++;\n+                iterator.remove();\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Override\n+    public ModelCriteriaBuilder<M> createCriteriaBuilder() {\n+        return new MapModelCriteriaBuilder<>(fieldPredicates);\n+    }\n+\n+    @Override\n+    public MapKeycloakTransaction<K, V, M> createTransaction() {\n+        return new MapKeycloakTransaction<>(this);\n+    }\n+\n+\n+    @Override\n+    public Stream<V> read(ModelCriteriaBuilder<M> criteria) {\n+        if (criteria == null) {\n+            return Stream.empty();\n+        }\n+        Stream<Entry<K, V>> stream = store.entrySet().stream();\n+\n+        MapModelCriteriaBuilder<K, V, M> b = criteria.unwrap(MapModelCriteriaBuilder.class);\n+        if (b == null) {\n+            throw new IllegalStateException(\"Incompatible class: \" + criteria.getClass());\n+        }\n+        Predicate<? super K> keyFilter = b.getKeyFilter();\n+        Predicate<? super V> entityFilter = b.getEntityFilter();\n+        stream = stream.filter(me -> keyFilter.test(me.getKey()) && entityFilter.test(me.getValue()));\n+\n+        return stream.map(Map.Entry::getValue);\n+    }\n+\n+    public Stream<V> read() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0ODc0Nw=="}, "originalCommit": {"oid": "7ef0fa4cd5fdb267ee23cc6c8cd06df8f2fa6325"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwOTAzNTIyOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupported.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxMjoyMToxNFrOITiTXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMToyOTo0OVrOIVlMlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NTg2OA==", "bodyText": "I miss the reason to have this parameters here as it seems to me those are not accessible via any methods. But maybe I'm overlooking something.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r557355868", "createdAt": "2021-01-14T12:21:14Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupported.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;\n+import org.keycloak.storage.SearchableModelField;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class CriterionNotSupported extends RuntimeException {\n+    private final SearchableModelField field;\n+    private final Operator op;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ef0fa4cd5fdb267ee23cc6c8cd06df8f2fa6325"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwMDQzOQ==", "bodyText": ":) Me as well.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r559500439", "createdAt": "2021-01-18T11:29:49Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupported.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;\n+import org.keycloak.storage.SearchableModelField;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class CriterionNotSupported extends RuntimeException {\n+    private final SearchableModelField field;\n+    private final Operator op;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NTg2OA=="}, "originalCommit": {"oid": "7ef0fa4cd5fdb267ee23cc6c8cd06df8f2fa6325"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwOTU2MjczOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupported.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNDozNDo0M1rOITnWeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTozMDowMlrOIVlNBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzQzODU4Ng==", "bodyText": "Just a question, I've always seen classes which extends Exception or a subclass named with suffix \"Exception\". I'm not sure if it's a convention or a habit. Anyway I wanted to hear your opinion.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r557438586", "createdAt": "2021-01-14T14:34:43Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupported.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;\n+import org.keycloak.storage.SearchableModelField;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class CriterionNotSupported extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ef0fa4cd5fdb267ee23cc6c8cd06df8f2fa6325"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwMDU0OA==", "bodyText": "Good catch!", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r559500548", "createdAt": "2021-01-18T11:30:02Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupported.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;\n+import org.keycloak.storage.SearchableModelField;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class CriterionNotSupported extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzQzODU4Ng=="}, "originalCommit": {"oid": "7ef0fa4cd5fdb267ee23cc6c8cd06df8f2fa6325"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwOTY3Mjg4OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriteriaOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNDo1Nzo0M1rOIToadw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTo0MjowOFrOIVlm3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzQ1NTk5MQ==", "bodyText": "Can you please explain the benefit using anonymous inner class here for me?", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r557455991", "createdAt": "2021-01-14T14:57:43Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriteriaOperator.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+class CriteriaOperator {\n+\n+    private static final EnumMap<Operator, Function<Object[], Predicate<Object>>> OPERATORS = new EnumMap<>(Operator.class);\n+\n+    private static final Logger LOG = Logger.getLogger(CriteriaOperator.class.getSimpleName());\n+\n+    private static final Predicate<Object> ALWAYS_FALSE = o -> false;\n+\n+    static {\n+        OPERATORS.put(Operator.EQ, CriteriaOperator::eq);\n+        OPERATORS.put(Operator.NE, CriteriaOperator::ne);\n+        OPERATORS.put(Operator.EXISTS, CriteriaOperator::exists);\n+        OPERATORS.put(Operator.NOT_EXISTS, CriteriaOperator::notExists);\n+        OPERATORS.put(Operator.LT, CriteriaOperator::lt);\n+        OPERATORS.put(Operator.LE, CriteriaOperator::le);\n+        OPERATORS.put(Operator.GT, CriteriaOperator::gt);\n+        OPERATORS.put(Operator.GE, CriteriaOperator::ge);\n+        OPERATORS.put(Operator.IN, CriteriaOperator::in);\n+        OPERATORS.put(Operator.LIKE, CriteriaOperator::like);\n+        OPERATORS.put(Operator.ILIKE, CriteriaOperator::ilike);\n+\n+        // Check that all operators are covered\n+        EnumSet<Operator> s = EnumSet.allOf(Operator.class);\n+        s.removeAll(OPERATORS.keySet());\n+        if (! s.isEmpty()) {\n+            throw new IllegalStateException(\"Some operators are not implemented: \" + s);\n+        }\n+    }\n+\n+    /**\n+     * Returns a predicate {@code P(x)} for comparing {@code value} and {@code x} as {@code x OP value}.\n+     * <b>Implementation note:</b> Note that this may mean reverse logic to e.g. {@link Comparable#compareTo}.\n+     * @param operator\n+     * @param value\n+     * @return\n+     */\n+    public static Predicate<Object> predicateFor(Operator op, Object[] value) {\n+        final Function<Object[], Predicate<Object>> funcToGetPredicate = OPERATORS.get(op);\n+        if (funcToGetPredicate == null) {\n+            throw new IllegalArgumentException(\"Unknown operator: \" + op);\n+        }\n+        return funcToGetPredicate.apply(value);\n+    }\n+\n+    public static Predicate<Object> eq(Object[] value) {\n+        if (value == null || value.length != 1) {\n+            throw new IllegalStateException(\"Invalid argument: \" + Arrays.toString(value));\n+        }\n+        final Object value0 = value[0];\n+        return new Predicate<Object>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ef0fa4cd5fdb267ee23cc6c8cd06df8f2fa6325"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwNzE2NQ==", "bodyText": "None in particular, could be lambda as well.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r559507165", "createdAt": "2021-01-18T11:42:08Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriteriaOperator.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+class CriteriaOperator {\n+\n+    private static final EnumMap<Operator, Function<Object[], Predicate<Object>>> OPERATORS = new EnumMap<>(Operator.class);\n+\n+    private static final Logger LOG = Logger.getLogger(CriteriaOperator.class.getSimpleName());\n+\n+    private static final Predicate<Object> ALWAYS_FALSE = o -> false;\n+\n+    static {\n+        OPERATORS.put(Operator.EQ, CriteriaOperator::eq);\n+        OPERATORS.put(Operator.NE, CriteriaOperator::ne);\n+        OPERATORS.put(Operator.EXISTS, CriteriaOperator::exists);\n+        OPERATORS.put(Operator.NOT_EXISTS, CriteriaOperator::notExists);\n+        OPERATORS.put(Operator.LT, CriteriaOperator::lt);\n+        OPERATORS.put(Operator.LE, CriteriaOperator::le);\n+        OPERATORS.put(Operator.GT, CriteriaOperator::gt);\n+        OPERATORS.put(Operator.GE, CriteriaOperator::ge);\n+        OPERATORS.put(Operator.IN, CriteriaOperator::in);\n+        OPERATORS.put(Operator.LIKE, CriteriaOperator::like);\n+        OPERATORS.put(Operator.ILIKE, CriteriaOperator::ilike);\n+\n+        // Check that all operators are covered\n+        EnumSet<Operator> s = EnumSet.allOf(Operator.class);\n+        s.removeAll(OPERATORS.keySet());\n+        if (! s.isEmpty()) {\n+            throw new IllegalStateException(\"Some operators are not implemented: \" + s);\n+        }\n+    }\n+\n+    /**\n+     * Returns a predicate {@code P(x)} for comparing {@code value} and {@code x} as {@code x OP value}.\n+     * <b>Implementation note:</b> Note that this may mean reverse logic to e.g. {@link Comparable#compareTo}.\n+     * @param operator\n+     * @param value\n+     * @return\n+     */\n+    public static Predicate<Object> predicateFor(Operator op, Object[] value) {\n+        final Function<Object[], Predicate<Object>> funcToGetPredicate = OPERATORS.get(op);\n+        if (funcToGetPredicate == null) {\n+            throw new IllegalArgumentException(\"Unknown operator: \" + op);\n+        }\n+        return funcToGetPredicate.apply(value);\n+    }\n+\n+    public static Predicate<Object> eq(Object[] value) {\n+        if (value == null || value.length != 1) {\n+            throw new IllegalStateException(\"Invalid argument: \" + Arrays.toString(value));\n+        }\n+        final Object value0 = value[0];\n+        return new Predicate<Object>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzQ1NTk5MQ=="}, "originalCommit": {"oid": "7ef0fa4cd5fdb267ee23cc6c8cd06df8f2fa6325"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwOTcxNTM5OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriteriaOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNTowNjoxNlrOITo1MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTo0ODo1MFrOIVl13Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzQ2MjgzMg==", "bodyText": "nit: this check could be potentially moved to private method as it's used multiple times within this class, but I'm really ok with the way how it's now.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r557462832", "createdAt": "2021-01-14T15:06:16Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriteriaOperator.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+class CriteriaOperator {\n+\n+    private static final EnumMap<Operator, Function<Object[], Predicate<Object>>> OPERATORS = new EnumMap<>(Operator.class);\n+\n+    private static final Logger LOG = Logger.getLogger(CriteriaOperator.class.getSimpleName());\n+\n+    private static final Predicate<Object> ALWAYS_FALSE = o -> false;\n+\n+    static {\n+        OPERATORS.put(Operator.EQ, CriteriaOperator::eq);\n+        OPERATORS.put(Operator.NE, CriteriaOperator::ne);\n+        OPERATORS.put(Operator.EXISTS, CriteriaOperator::exists);\n+        OPERATORS.put(Operator.NOT_EXISTS, CriteriaOperator::notExists);\n+        OPERATORS.put(Operator.LT, CriteriaOperator::lt);\n+        OPERATORS.put(Operator.LE, CriteriaOperator::le);\n+        OPERATORS.put(Operator.GT, CriteriaOperator::gt);\n+        OPERATORS.put(Operator.GE, CriteriaOperator::ge);\n+        OPERATORS.put(Operator.IN, CriteriaOperator::in);\n+        OPERATORS.put(Operator.LIKE, CriteriaOperator::like);\n+        OPERATORS.put(Operator.ILIKE, CriteriaOperator::ilike);\n+\n+        // Check that all operators are covered\n+        EnumSet<Operator> s = EnumSet.allOf(Operator.class);\n+        s.removeAll(OPERATORS.keySet());\n+        if (! s.isEmpty()) {\n+            throw new IllegalStateException(\"Some operators are not implemented: \" + s);\n+        }\n+    }\n+\n+    /**\n+     * Returns a predicate {@code P(x)} for comparing {@code value} and {@code x} as {@code x OP value}.\n+     * <b>Implementation note:</b> Note that this may mean reverse logic to e.g. {@link Comparable#compareTo}.\n+     * @param operator\n+     * @param value\n+     * @return\n+     */\n+    public static Predicate<Object> predicateFor(Operator op, Object[] value) {\n+        final Function<Object[], Predicate<Object>> funcToGetPredicate = OPERATORS.get(op);\n+        if (funcToGetPredicate == null) {\n+            throw new IllegalArgumentException(\"Unknown operator: \" + op);\n+        }\n+        return funcToGetPredicate.apply(value);\n+    }\n+\n+    public static Predicate<Object> eq(Object[] value) {\n+        if (value == null || value.length != 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ef0fa4cd5fdb267ee23cc6c8cd06df8f2fa6325"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUxMTAwNQ==", "bodyText": "You're right, fixed", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r559511005", "createdAt": "2021-01-18T11:48:50Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriteriaOperator.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+class CriteriaOperator {\n+\n+    private static final EnumMap<Operator, Function<Object[], Predicate<Object>>> OPERATORS = new EnumMap<>(Operator.class);\n+\n+    private static final Logger LOG = Logger.getLogger(CriteriaOperator.class.getSimpleName());\n+\n+    private static final Predicate<Object> ALWAYS_FALSE = o -> false;\n+\n+    static {\n+        OPERATORS.put(Operator.EQ, CriteriaOperator::eq);\n+        OPERATORS.put(Operator.NE, CriteriaOperator::ne);\n+        OPERATORS.put(Operator.EXISTS, CriteriaOperator::exists);\n+        OPERATORS.put(Operator.NOT_EXISTS, CriteriaOperator::notExists);\n+        OPERATORS.put(Operator.LT, CriteriaOperator::lt);\n+        OPERATORS.put(Operator.LE, CriteriaOperator::le);\n+        OPERATORS.put(Operator.GT, CriteriaOperator::gt);\n+        OPERATORS.put(Operator.GE, CriteriaOperator::ge);\n+        OPERATORS.put(Operator.IN, CriteriaOperator::in);\n+        OPERATORS.put(Operator.LIKE, CriteriaOperator::like);\n+        OPERATORS.put(Operator.ILIKE, CriteriaOperator::ilike);\n+\n+        // Check that all operators are covered\n+        EnumSet<Operator> s = EnumSet.allOf(Operator.class);\n+        s.removeAll(OPERATORS.keySet());\n+        if (! s.isEmpty()) {\n+            throw new IllegalStateException(\"Some operators are not implemented: \" + s);\n+        }\n+    }\n+\n+    /**\n+     * Returns a predicate {@code P(x)} for comparing {@code value} and {@code x} as {@code x OP value}.\n+     * <b>Implementation note:</b> Note that this may mean reverse logic to e.g. {@link Comparable#compareTo}.\n+     * @param operator\n+     * @param value\n+     * @return\n+     */\n+    public static Predicate<Object> predicateFor(Operator op, Object[] value) {\n+        final Function<Object[], Predicate<Object>> funcToGetPredicate = OPERATORS.get(op);\n+        if (funcToGetPredicate == null) {\n+            throw new IllegalArgumentException(\"Unknown operator: \" + op);\n+        }\n+        return funcToGetPredicate.apply(value);\n+    }\n+\n+    public static Predicate<Object> eq(Object[] value) {\n+        if (value == null || value.length != 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzQ2MjgzMg=="}, "originalCommit": {"oid": "7ef0fa4cd5fdb267ee23cc6c8cd06df8f2fa6325"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNDU5OTY4OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupportedException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxOTozMzoxM1rOIV1P_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxMjozOToyNFrOIWMs8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc2MzQ1Mw==", "bodyText": "Now the parameters are accessible, but the methods are not used anywhere. Do you plan to have a use for them?", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r559763453", "createdAt": "2021-01-18T19:33:13Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupportedException.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;\n+import org.keycloak.storage.SearchableModelField;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class CriterionNotSupportedException extends RuntimeException {\n+    private final SearchableModelField field;\n+    private final Operator op;\n+\n+    public CriterionNotSupportedException(SearchableModelField field, Operator op) {\n+        super(\"Criterion not supported: operator: \" + op + \", field: \" + field);\n+        this.field = field;\n+        this.op = op;\n+    }\n+\n+    public CriterionNotSupportedException(SearchableModelField field, Operator op, String message) {\n+        super(message);\n+        this.field = field;\n+        this.op = op;\n+    }\n+\n+    public CriterionNotSupportedException(SearchableModelField field, Operator op, String message, Throwable cause) {\n+        super(message, cause);\n+        this.field = field;\n+        this.op = op;\n+    }\n+\n+    public SearchableModelField getField() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDE0NzY5Nw==", "bodyText": "They will likely be used in an exception converter", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560147697", "createdAt": "2021-01-19T12:39:24Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/CriterionNotSupportedException.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.map.storage.ModelCriteriaBuilder.Operator;\n+import org.keycloak.storage.SearchableModelField;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class CriterionNotSupportedException extends RuntimeException {\n+    private final SearchableModelField field;\n+    private final Operator op;\n+\n+    public CriterionNotSupportedException(SearchableModelField field, Operator op) {\n+        super(\"Criterion not supported: operator: \" + op + \", field: \" + field);\n+        this.field = field;\n+        this.op = op;\n+    }\n+\n+    public CriterionNotSupportedException(SearchableModelField field, Operator op, String message) {\n+        super(message);\n+        this.field = field;\n+        this.op = op;\n+    }\n+\n+    public CriterionNotSupportedException(SearchableModelField field, Operator op, String message, Throwable cause) {\n+        super(message, cause);\n+        this.field = field;\n+        this.op = op;\n+    }\n+\n+    public SearchableModelField getField() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc2MzQ1Mw=="}, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjQ0ODYxOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTozMDo1OVrOIWFumw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNTowNjo0M1rOIXC5wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAzMzQzNQ==", "bodyText": "Previously, realm was checked for null value, should we check it here as well?", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560033435", "createdAt": "2021-01-19T09:30:59Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -87,43 +81,47 @@ public GroupModel getGroupById(RealmModel realm, String id) {\n             return null;\n         }\n         \n-        MapGroupEntity entity = tx.get(uid, groupStore::get);\n-        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+        MapGroupEntity entity = tx.read(uid);\n+        String realmId = realm.getId();\n+        return (entity == null || ! Objects.equals(realmId, entity.getRealmId()))\n                 ? null\n                 : entityToAdapterFunc(realm).apply(entity);\n     }\n \n-    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n-        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n-                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n-                .filter(Objects::nonNull);\n-        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedGroupsStream);\n-    }\n-\n-    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {\n-        return getNotRemovedUpdatedGroupsStream()\n-                .filter(entityRealmFilter(realm));\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n+        return getGroupsStreamInternal(realm, null);\n+    }\n+\n+    private Stream<GroupModel> getGroupsStreamInternal(RealmModel realm, UnaryOperator<ModelCriteriaBuilder<GroupModel>> modifier) {\n         LOG.tracef(\"getGroupsStream(%s)%s\", realm, getShortStackTrace());\n-        return getUnsortedGroupEntitiesStream(realm)\n+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()\n+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDIxNDg3NA==", "bodyText": "This check is now performed in tx.getUpdatedNotRemoved() which is the only place where null may appear. The set of returned values that were not touched in this transaction should never be null (since it would not satisfy the mcb filter in the first place).", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560214874", "createdAt": "2021-01-19T14:28:07Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -87,43 +81,47 @@ public GroupModel getGroupById(RealmModel realm, String id) {\n             return null;\n         }\n         \n-        MapGroupEntity entity = tx.get(uid, groupStore::get);\n-        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+        MapGroupEntity entity = tx.read(uid);\n+        String realmId = realm.getId();\n+        return (entity == null || ! Objects.equals(realmId, entity.getRealmId()))\n                 ? null\n                 : entityToAdapterFunc(realm).apply(entity);\n     }\n \n-    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n-        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n-                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n-                .filter(Objects::nonNull);\n-        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedGroupsStream);\n-    }\n-\n-    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {\n-        return getNotRemovedUpdatedGroupsStream()\n-                .filter(entityRealmFilter(realm));\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n+        return getGroupsStreamInternal(realm, null);\n+    }\n+\n+    private Stream<GroupModel> getGroupsStreamInternal(RealmModel realm, UnaryOperator<ModelCriteriaBuilder<GroupModel>> modifier) {\n         LOG.tracef(\"getGroupsStream(%s)%s\", realm, getShortStackTrace());\n-        return getUnsortedGroupEntitiesStream(realm)\n+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()\n+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAzMzQzNQ=="}, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDI4MzI5MA==", "bodyText": "I mean realm.getId() will throw NPE when realm is null. However, I am not sure this makes sense to add now. We are not checking many other parameters. Maybe we should add it to cleanup task to either document that NPE may be thrown when null parameter is passed or do some checking everywhere.\nI just wanted to point it out as this is change of behaviour in this PR. Before there was no user/group/role returned as ALWAYS_FALSE filter was used when realm was null.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560283290", "createdAt": "2021-01-19T15:54:39Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -87,43 +81,47 @@ public GroupModel getGroupById(RealmModel realm, String id) {\n             return null;\n         }\n         \n-        MapGroupEntity entity = tx.get(uid, groupStore::get);\n-        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+        MapGroupEntity entity = tx.read(uid);\n+        String realmId = realm.getId();\n+        return (entity == null || ! Objects.equals(realmId, entity.getRealmId()))\n                 ? null\n                 : entityToAdapterFunc(realm).apply(entity);\n     }\n \n-    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n-        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n-                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n-                .filter(Objects::nonNull);\n-        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedGroupsStream);\n-    }\n-\n-    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {\n-        return getNotRemovedUpdatedGroupsStream()\n-                .filter(entityRealmFilter(realm));\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n+        return getGroupsStreamInternal(realm, null);\n+    }\n+\n+    private Stream<GroupModel> getGroupsStreamInternal(RealmModel realm, UnaryOperator<ModelCriteriaBuilder<GroupModel>> modifier) {\n         LOG.tracef(\"getGroupsStream(%s)%s\", realm, getShortStackTrace());\n-        return getUnsortedGroupEntitiesStream(realm)\n+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()\n+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAzMzQzNQ=="}, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTAzNTcxNA==", "bodyText": "I agree, this should have been there. Added https://issues.redhat.com/browse/KEYCLOAK-16872", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r561035714", "createdAt": "2021-01-20T15:06:43Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -87,43 +81,47 @@ public GroupModel getGroupById(RealmModel realm, String id) {\n             return null;\n         }\n         \n-        MapGroupEntity entity = tx.get(uid, groupStore::get);\n-        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+        MapGroupEntity entity = tx.read(uid);\n+        String realmId = realm.getId();\n+        return (entity == null || ! Objects.equals(realmId, entity.getRealmId()))\n                 ? null\n                 : entityToAdapterFunc(realm).apply(entity);\n     }\n \n-    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n-        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n-                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n-                .filter(Objects::nonNull);\n-        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedGroupsStream);\n-    }\n-\n-    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {\n-        return getNotRemovedUpdatedGroupsStream()\n-                .filter(entityRealmFilter(realm));\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n+        return getGroupsStreamInternal(realm, null);\n+    }\n+\n+    private Stream<GroupModel> getGroupsStreamInternal(RealmModel realm, UnaryOperator<ModelCriteriaBuilder<GroupModel>> modifier) {\n         LOG.tracef(\"getGroupsStream(%s)%s\", realm, getShortStackTrace());\n-        return getUnsortedGroupEntitiesStream(realm)\n+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()\n+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAzMzQzNQ=="}, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjUwNTMzOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTo0MzoyNVrOIWGQnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxNDozNDoxM1rOIWRF6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MjE0Mw==", "bodyText": "Should this be done using tx.getCount() instead getUpdatedNotRemoved()? Currently it is the same, however for JPA it could be faster using count query.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560042143", "createdAt": "2021-01-19T09:43:25Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -214,20 +221,25 @@ public GroupModel createGroup(RealmModel realm, String id, String name, GroupMod\n         final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n \n         // Check Db constraint: uniqueConstraints = { @UniqueConstraint(columnNames = {\"REALM_ID\", \"PARENT_GROUP\", \"NAME\"})}\n-        if (getUnsortedGroupEntitiesStream(realm)\n-                .anyMatch(groupEntity -> \n-                        Objects.equals(groupEntity.getParentId(), toParent == null ? null : toParent.getId()) &&\n-                        Objects.equals(groupEntity.getName(), name))) {\n-            throw new ModelDuplicateException(\"Group with name '\" + name + \"' in realm \" + realm.getName() + \" already exists for requested parent\" );\n+        String parentId = toParent == null ? null : toParent.getId();\n+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()\n+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId())\n+          .compare(SearchableFields.PARENT_ID, Operator.EQ, parentId)\n+          .compare(SearchableFields.NAME, Operator.EQ, name);\n+\n+        try (Stream<MapGroupEntity> possibleSiblings = tx.getUpdatedNotRemoved(mcb)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDIxOTYyNA==", "bodyText": "good catch!", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560219624", "createdAt": "2021-01-19T14:34:13Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -214,20 +221,25 @@ public GroupModel createGroup(RealmModel realm, String id, String name, GroupMod\n         final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n \n         // Check Db constraint: uniqueConstraints = { @UniqueConstraint(columnNames = {\"REALM_ID\", \"PARENT_GROUP\", \"NAME\"})}\n-        if (getUnsortedGroupEntitiesStream(realm)\n-                .anyMatch(groupEntity -> \n-                        Objects.equals(groupEntity.getParentId(), toParent == null ? null : toParent.getId()) &&\n-                        Objects.equals(groupEntity.getName(), name))) {\n-            throw new ModelDuplicateException(\"Group with name '\" + name + \"' in realm \" + realm.getName() + \" already exists for requested parent\" );\n+        String parentId = toParent == null ? null : toParent.getId();\n+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()\n+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId())\n+          .compare(SearchableFields.PARENT_ID, Operator.EQ, parentId)\n+          .compare(SearchableFields.NAME, Operator.EQ, name);\n+\n+        try (Stream<MapGroupEntity> possibleSiblings = tx.getUpdatedNotRemoved(mcb)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MjE0Mw=="}, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjUyOTk2OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTo0ODo1NVrOIWGf2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxNDoyMjo0MVrOIWQiuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0NjA0MQ==", "bodyText": "Should we add limit and start support to mcb? Or some other way into transaction/storage? Because if I recall correctly, the stream's skip/max is not ideal for JPA.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560046041", "createdAt": "2021-01-19T09:48:55Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -194,8 +200,9 @@ public Long getGroupsCountByNameContaining(RealmModel realm, String search) {\n     @Override\n     public Stream<GroupModel> searchForGroupByNameStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {\n         LOG.tracef(\"searchForGroupByNameStream(%s, %s, %d, %d)%s\", realm, search, firstResult, maxResults, getShortStackTrace());\n-        Stream<GroupModel> groupModelStream = getGroupsStream(realm)\n-                .filter(groupModel -> groupModel.getName().contains(search));\n+        Stream<GroupModel> groupModelStream = getGroupsStreamInternal(realm,\n+          (ModelCriteriaBuilder<GroupModel> mcb) -> mcb.compare(SearchableFields.NAME, Operator.ILIKE, \"%\" + search + \"%\")\n+        );\n \n         if (firstResult != null && firstResult > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDIxMDYxNg==", "bodyText": "I believe this is a good idea, thought I'm not convinced that ModelCriteriaBuilder should be the place to put it, as ModelCriteriaBuilder can be nested to a Boolean expressions via and, or and not operations that don't play well. Looks like the MapStorage.read variant would be a better fit? I've introduced https://issues.redhat.com/browse/KEYCLOAK-16855 to have a discussion there", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560210616", "createdAt": "2021-01-19T14:22:41Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -194,8 +200,9 @@ public Long getGroupsCountByNameContaining(RealmModel realm, String search) {\n     @Override\n     public Stream<GroupModel> searchForGroupByNameStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {\n         LOG.tracef(\"searchForGroupByNameStream(%s, %s, %d, %d)%s\", realm, search, firstResult, maxResults, getShortStackTrace());\n-        Stream<GroupModel> groupModelStream = getGroupsStream(realm)\n-                .filter(groupModel -> groupModel.getName().contains(search));\n+        Stream<GroupModel> groupModelStream = getGroupsStreamInternal(realm,\n+          (ModelCriteriaBuilder<GroupModel> mcb) -> mcb.compare(SearchableFields.NAME, Operator.ILIKE, \"%\" + search + \"%\")\n+        );\n \n         if (firstResult != null && firstResult > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0NjA0MQ=="}, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjU2MDA4OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTo1NTo1OVrOIWGyvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxNjowMjo0NVrOIWVXwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA1MDg3OA==", "bodyText": "This construct is quite often repeating in each provider. Should we create some auxiliary function for it? Or maybe even create a function like createCriteriaBuilder(RealmModel)? The corresponding SearchableFields field could be hardcoded withing storage since it is always the same for each storage.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560050878", "createdAt": "2021-01-19T09:55:59Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -87,43 +81,47 @@ public GroupModel getGroupById(RealmModel realm, String id) {\n             return null;\n         }\n         \n-        MapGroupEntity entity = tx.get(uid, groupStore::get);\n-        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+        MapGroupEntity entity = tx.read(uid);\n+        String realmId = realm.getId();\n+        return (entity == null || ! Objects.equals(realmId, entity.getRealmId()))\n                 ? null\n                 : entityToAdapterFunc(realm).apply(entity);\n     }\n \n-    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n-        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n-                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n-                .filter(Objects::nonNull);\n-        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedGroupsStream);\n-    }\n-\n-    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {\n-        return getNotRemovedUpdatedGroupsStream()\n-                .filter(entityRealmFilter(realm));\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n+        return getGroupsStreamInternal(realm, null);\n+    }\n+\n+    private Stream<GroupModel> getGroupsStreamInternal(RealmModel realm, UnaryOperator<ModelCriteriaBuilder<GroupModel>> modifier) {\n         LOG.tracef(\"getGroupsStream(%s)%s\", realm, getShortStackTrace());\n-        return getUnsortedGroupEntitiesStream(realm)\n+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()\n+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDIxODIyNQ==", "bodyText": "I was thinking about it, I decided for a more explicit \"WHERE clause\" as it then shows exact condition in full and is still short enough. I'm open to change it if there is a convincing argument though", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560218225", "createdAt": "2021-01-19T14:32:22Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -87,43 +81,47 @@ public GroupModel getGroupById(RealmModel realm, String id) {\n             return null;\n         }\n         \n-        MapGroupEntity entity = tx.get(uid, groupStore::get);\n-        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+        MapGroupEntity entity = tx.read(uid);\n+        String realmId = realm.getId();\n+        return (entity == null || ! Objects.equals(realmId, entity.getRealmId()))\n                 ? null\n                 : entityToAdapterFunc(realm).apply(entity);\n     }\n \n-    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n-        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n-                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n-                .filter(Objects::nonNull);\n-        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedGroupsStream);\n-    }\n-\n-    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {\n-        return getNotRemovedUpdatedGroupsStream()\n-                .filter(entityRealmFilter(realm));\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n+        return getGroupsStreamInternal(realm, null);\n+    }\n+\n+    private Stream<GroupModel> getGroupsStreamInternal(RealmModel realm, UnaryOperator<ModelCriteriaBuilder<GroupModel>> modifier) {\n         LOG.tracef(\"getGroupsStream(%s)%s\", realm, getShortStackTrace());\n-        return getUnsortedGroupEntitiesStream(realm)\n+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()\n+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA1MDg3OA=="}, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDI4OTcyOQ==", "bodyText": "I see. Well I don't have any strong argument there, I just think that it would be worth adding as almost each entity we have is related to exactly one realm. But I agree with you, the code is more comprehensible this way, so we can leave it as is.", "url": "https://github.com/keycloak/keycloak/pull/7684#discussion_r560289729", "createdAt": "2021-01-19T16:02:45Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -87,43 +81,47 @@ public GroupModel getGroupById(RealmModel realm, String id) {\n             return null;\n         }\n         \n-        MapGroupEntity entity = tx.get(uid, groupStore::get);\n-        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+        MapGroupEntity entity = tx.read(uid);\n+        String realmId = realm.getId();\n+        return (entity == null || ! Objects.equals(realmId, entity.getRealmId()))\n                 ? null\n                 : entityToAdapterFunc(realm).apply(entity);\n     }\n \n-    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n-        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n-                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n-                .filter(Objects::nonNull);\n-        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedGroupsStream);\n-    }\n-\n-    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {\n-        return getNotRemovedUpdatedGroupsStream()\n-                .filter(entityRealmFilter(realm));\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n+        return getGroupsStreamInternal(realm, null);\n+    }\n+\n+    private Stream<GroupModel> getGroupsStreamInternal(RealmModel realm, UnaryOperator<ModelCriteriaBuilder<GroupModel>> modifier) {\n         LOG.tracef(\"getGroupsStream(%s)%s\", realm, getShortStackTrace());\n-        return getUnsortedGroupEntitiesStream(realm)\n+        ModelCriteriaBuilder<GroupModel> mcb = groupStore.createCriteriaBuilder()\n+          .compare(SearchableFields.REALM_ID, Operator.EQ, realm.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA1MDg3OA=="}, "originalCommit": {"oid": "6ac090e1714263c809aac673b4efca49678ac6c5"}, "originalPosition": 99}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3279, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}