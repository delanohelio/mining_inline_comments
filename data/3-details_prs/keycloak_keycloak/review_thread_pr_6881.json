{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NjAzMTI3", "number": 6881, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzo1Mjo1MVrODuP0kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzo1Mjo1MVrODuP0kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODIwMzA3OnYy", "diffSide": "RIGHT", "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/RefreshableKeycloakSecurityContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzo1Mjo1MVrOGAI8Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjowMTo1NFrOGAScRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc5OTY0Mw==", "bodyText": "The refresh should only be done if the token is not active. Suppose two threads entering this method up until this line (both already checked the token not being active), then they sequentially enter this section and refresh the token immediately (i.e. update this.token) one after another.\nHence the check\n        if (checkActive) {\n            log.trace(\"Checking whether token has been refreshed in another thread already.\");\n            if (isActive() && isTokenTimeToLiveSufficient(this.token)) return true;\n        }\nwould help to only refresh the token once if placed right as the first thing inside the synchronized block.", "url": "https://github.com/keycloak/keycloak/pull/6881#discussion_r402799643", "createdAt": "2020-04-03T07:52:51Z", "author": {"login": "hmlnarik"}, "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/RefreshableKeycloakSecurityContext.java", "diffHunk": "@@ -114,51 +114,59 @@ public boolean refreshExpiredToken(boolean checkActive) {\n         if (log.isTraceEnabled()) {\n             log.trace(\"Doing refresh\");\n         }\n-        AccessTokenResponse response = null;\n-        try {\n-            response = ServerRequest.invokeRefresh(deployment, refreshToken);\n-        } catch (IOException e) {\n-            log.error(\"Refresh token failure\", e);\n-            return false;\n-        } catch (ServerRequest.HttpFailure httpFailure) {\n-            log.error(\"Refresh token failure status: \" + httpFailure.getStatus() + \" \" + httpFailure.getError());\n-            return false;\n-        }\n-        if (log.isTraceEnabled()) {\n-            log.trace(\"received refresh response\");\n-        }\n-        String tokenString = response.getToken();\n-        AccessToken token = null;\n-        try {\n-            AdapterTokenVerifier.VerifiedTokens tokens = AdapterTokenVerifier.verifyTokens(tokenString, response.getIdToken(), deployment);\n-            token = tokens.getAccessToken();\n-            log.debug(\"Token Verification succeeded!\");\n-        } catch (VerificationException e) {\n-            log.error(\"failed verification of token\");\n-            return false;\n-        }\n+        \n+        // block requests if the refresh token herein stored is already being used to refresh the token so that subsequent requests\n+        // can use the last refresh token issued by the server. Note that this will only work for deployments using the session store\n+        // and, when running in a cluster, sticky sessions must be used.\n+        // \n+        synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e5e67b51b935399bca7a49176595de14b5b89d6"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk1NTMzMg==", "bodyText": "You are right. That should avoid unnecessary refreshes if it happened before.", "url": "https://github.com/keycloak/keycloak/pull/6881#discussion_r402955332", "createdAt": "2020-04-03T12:01:54Z", "author": {"login": "pedroigor"}, "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/RefreshableKeycloakSecurityContext.java", "diffHunk": "@@ -114,51 +114,59 @@ public boolean refreshExpiredToken(boolean checkActive) {\n         if (log.isTraceEnabled()) {\n             log.trace(\"Doing refresh\");\n         }\n-        AccessTokenResponse response = null;\n-        try {\n-            response = ServerRequest.invokeRefresh(deployment, refreshToken);\n-        } catch (IOException e) {\n-            log.error(\"Refresh token failure\", e);\n-            return false;\n-        } catch (ServerRequest.HttpFailure httpFailure) {\n-            log.error(\"Refresh token failure status: \" + httpFailure.getStatus() + \" \" + httpFailure.getError());\n-            return false;\n-        }\n-        if (log.isTraceEnabled()) {\n-            log.trace(\"received refresh response\");\n-        }\n-        String tokenString = response.getToken();\n-        AccessToken token = null;\n-        try {\n-            AdapterTokenVerifier.VerifiedTokens tokens = AdapterTokenVerifier.verifyTokens(tokenString, response.getIdToken(), deployment);\n-            token = tokens.getAccessToken();\n-            log.debug(\"Token Verification succeeded!\");\n-        } catch (VerificationException e) {\n-            log.error(\"failed verification of token\");\n-            return false;\n-        }\n+        \n+        // block requests if the refresh token herein stored is already being used to refresh the token so that subsequent requests\n+        // can use the last refresh token issued by the server. Note that this will only work for deployments using the session store\n+        // and, when running in a cluster, sticky sessions must be used.\n+        // \n+        synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc5OTY0Mw=="}, "originalCommit": {"oid": "9e5e67b51b935399bca7a49176595de14b5b89d6"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3822, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}