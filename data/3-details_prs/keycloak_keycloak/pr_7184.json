{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2NjQxNzc0", "number": 7184, "title": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated", "bodyText": "", "createdAt": "2020-06-18T17:09:17Z", "url": "https://github.com/keycloak/keycloak/pull/7184", "merged": true, "mergeCommit": {"oid": "40efbb0f9c4bb5cc756f9dfc67a81b5536291d2a"}, "closed": true, "closedAt": "2021-03-02T14:01:43Z", "author": {"login": "pedroigor"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcxUfeTgFqTQ0MjQ1NDI2OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABd_M-cmAFqTYwMTg0NTU0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNDU0MjY5", "url": "https://github.com/keycloak/keycloak/pull/7184#pullrequestreview-442454269", "createdAt": "2020-07-03T14:39:05Z", "commit": {"oid": "2b04595f1467ce1a24fe1e2ba098ea20d8d41dea"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNDozOTowNlrOGsyUug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNDozOTowNlrOGsyUug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNTAzNA==", "bodyText": "Hello @pedroigor, is it correct, that this way all paths defined only in enforcerConfig are removed after cache expiration? I tried to play with ServletPolicyEnforcerTest and changed cache lifespan to 5ms.\nNow I tried to run ServletPolicyEnforcerTest#testPattern1 and it fails during the first login. I described behavior in comments here.", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r449615034", "createdAt": "2020-07-03T14:39:06Z", "author": {"login": "mhajas"}, "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PathCache.java", "diffHunk": "@@ -115,12 +123,19 @@ private PathConfig removeIfExpired(CacheEntry cached) {\n             return null;\n         }\n \n+        PathConfig config = cached.value();\n+\n         if (cached.isExpired()) {\n             remove(cached.key());\n+            \n+            if (config != null && config.getPath() != null) {\n+                // also remove from pre-defined paths map so that changes on the server are properly reflected\n+                paths.remove(config.getPath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b04595f1467ce1a24fe1e2ba098ea20d8d41dea"}, "originalPosition": 55}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2b04595f1467ce1a24fe1e2ba098ea20d8d41dea", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/2b04595f1467ce1a24fe1e2ba098ea20d8d41dea", "committedDate": "2020-06-18T17:07:31Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}, "afterCommit": {"oid": "f9b172921e381dd710eaf60b80850d0093f5db07", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/f9b172921e381dd710eaf60b80850d0093f5db07", "committedDate": "2020-07-06T20:45:35Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f9b172921e381dd710eaf60b80850d0093f5db07", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/f9b172921e381dd710eaf60b80850d0093f5db07", "committedDate": "2020-07-06T20:45:35Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}, "afterCommit": {"oid": "51b3467752a18015fe411b5d4f2d89fad425a600", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/51b3467752a18015fe411b5d4f2d89fad425a600", "committedDate": "2020-07-06T21:46:07Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDM1MTAw", "url": "https://github.com/keycloak/keycloak/pull/7184#pullrequestreview-444035100", "createdAt": "2020-07-07T16:01:25Z", "commit": {"oid": "51b3467752a18015fe411b5d4f2d89fad425a600"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjowMToyNVrOGuFWTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjowODozMVrOGuFoBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NTMwOQ==", "bodyText": "This is unused", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r450975309", "createdAt": "2020-07-07T16:01:25Z", "author": {"login": "mhajas"}, "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PathCache.java", "diffHunk": "@@ -42,14 +43,17 @@\n \n     private final long maxAge;\n     private final boolean enabled;\n+    private final Map<String, PathConfig> paths;\n+    private final PolicyEnforcerConfig config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51b3467752a18015fe411b5d4f2d89fad425a600"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NzMxNg==", "bodyText": "Why are we doing lazy loading even if lazy loading is disabled and cache is enabled?: || enforcerConfig.getPathCacheConfig() != null?", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r450977316", "createdAt": "2020-07-07T16:04:37Z", "author": {"login": "mhajas"}, "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PolicyEnforcer.java", "diffHunk": "@@ -263,20 +267,35 @@ public PathConfig matches(String targetUri) {\n             pathConfig = super.matches(targetUri);\n \n             if (enforcerConfig.getLazyLoadPaths() || enforcerConfig.getPathCacheConfig() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51b3467752a18015fe411b5d4f2d89fad425a600"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3OTg0NQ==", "bodyText": "Could you please elaborate a little bit more on why is this condition necessary? I would understand it without the exclamation mark in the last condition, but not with it. Maybe in some example situation when this happens.", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r450979845", "createdAt": "2020-07-07T16:08:31Z", "author": {"login": "mhajas"}, "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PolicyEnforcer.java", "diffHunk": "@@ -263,20 +267,35 @@ public PathConfig matches(String targetUri) {\n             pathConfig = super.matches(targetUri);\n \n             if (enforcerConfig.getLazyLoadPaths() || enforcerConfig.getPathCacheConfig() != null) {\n-                if ((pathConfig == null || (pathConfig.getPath().contains(\"*\")))) {\n+                if ((pathConfig == null || pathConfig.isInvalidated() || pathConfig.getPath().contains(\"*\"))) {\n                     try {\n                         List<ResourceRepresentation> matchingResources = authzClient.protection().resource().findByMatchingUri(targetUri);\n \n-                        if (!matchingResources.isEmpty()) {\n+                        if (matchingResources.isEmpty()) {\n+                            // if this config is invalidated (e.g.: due to cache expiration) we remove and return null\n+                            if (pathConfig != null && pathConfig.isInvalidated()) {\n+                                paths.remove(targetUri);\n+                                return null;\n+                            }\n+                        } else {\n                             Map<String, Map<String, Object>> cipConfig = null;\n                             PolicyEnforcerConfig.EnforcementMode enforcementMode = PolicyEnforcerConfig.EnforcementMode.ENFORCING;\n+                            ResourceRepresentation targetResource = matchingResources.get(0);\n \n                             if (pathConfig != null) {\n                                 cipConfig = pathConfig.getClaimInformationPointConfig();\n                                 enforcementMode = pathConfig.getEnforcementMode();\n+                            } else {\n+                                for (PathConfig existingPath : paths.values()) {\n+                                    if (existingPath.getId().equals(targetResource.getId()) \n+                                            && existingPath.isStatic()\n+                                            && !PolicyEnforcerConfig.EnforcementMode.DISABLED.equals(existingPath.getEnforcementMode())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51b3467752a18015fe411b5d4f2d89fad425a600"}, "originalPosition": 51}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51b3467752a18015fe411b5d4f2d89fad425a600", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/51b3467752a18015fe411b5d4f2d89fad425a600", "committedDate": "2020-07-06T21:46:07Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}, "afterCommit": {"oid": "d095372c56a9f5f57b27ebb23ceb2dd81a938dd4", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/d095372c56a9f5f57b27ebb23ceb2dd81a938dd4", "committedDate": "2020-07-08T20:19:02Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMzk3MTcx", "url": "https://github.com/keycloak/keycloak/pull/7184#pullrequestreview-451397171", "createdAt": "2020-07-20T08:26:48Z", "commit": {"oid": "d095372c56a9f5f57b27ebb23ceb2dd81a938dd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODoyNjo0OFrOGz_ftw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODoyNjo0OFrOGz_ftw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE3MDg3MQ==", "bodyText": "Hey @pedroigor, this test is failing on this line.", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r457170871", "createdAt": "2020-07-20T08:26:48Z", "author": {"login": "mhajas"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/example/authorization/LifespanAdapterTest.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2018 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.testsuite.adapter.example.authorization;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import javax.ws.rs.core.Response;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.hamcrest.Matchers;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.Test;\n+import org.keycloak.admin.client.resource.AuthorizationResource;\n+import org.keycloak.admin.client.resource.RealmResource;\n+import org.keycloak.admin.client.resource.UserResource;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.representations.idm.authorization.PolicyRepresentation;\n+import org.keycloak.representations.idm.authorization.ResourceRepresentation;\n+import org.keycloak.testsuite.adapter.page.PhotozClientAuthzTestApp;\n+import org.keycloak.testsuite.arquillian.annotation.AppServerContainer;\n+import org.keycloak.testsuite.util.javascript.ResponseValidator;\n+import org.keycloak.testsuite.utils.arquillian.ContainerConstants;\n+import org.keycloak.util.JsonSerialization;\n+\n+/**\n+ * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n+ */\n+@AppServerContainer(ContainerConstants.APP_SERVER_WILDFLY)\n+@AppServerContainer(ContainerConstants.APP_SERVER_WILDFLY_DEPRECATED)\n+@AppServerContainer(ContainerConstants.APP_SERVER_EAP)\n+@AppServerContainer(ContainerConstants.APP_SERVER_EAP6)\n+@AppServerContainer(ContainerConstants.APP_SERVER_EAP71)\n+@AppServerContainer(ContainerConstants.APP_SERVER_UNDERTOW)\n+public class LifespanAdapterTest extends AbstractPhotozExampleAdapterTest {\n+\n+    @Deployment(name = PhotozClientAuthzTestApp.DEPLOYMENT_NAME)\n+    public static WebArchive deploymentClient() throws IOException {\n+        return exampleDeployment(PhotozClientAuthzTestApp.DEPLOYMENT_NAME);\n+    }\n+\n+    @Deployment(name = RESOURCE_SERVER_ID, managed = false, testable = false)\n+    public static WebArchive deploymentResourceServer() throws IOException {\n+        return exampleDeployment(RESOURCE_SERVER_ID,\n+              webArchive -> webArchive.addAsWebInfResource(new File(TEST_APPS_HOME_DIR + \"/photoz/keycloak-cache-lifespan-authz-service.json\"), \"keycloak.json\"));\n+    }\n+\n+    @Test\n+    public void testPathConfigInvalidation() throws Exception {\n+        loginToClientPage(aliceUser);\n+        assertSuccess();\n+\n+        ResourceRepresentation resource = getAuthorizationResource().resources().findByName(\"Profile Resource\").get(0);\n+        AuthorizationResource authorizationResource = getAuthorizationResource();\n+\n+        authorizationResource.resources().resource(resource.getId()).remove();\n+\n+        loginToClientPage(aliceUser);\n+\n+        // should throw an error because the resource was removed and cache entry did not expire yet\n+        clientPage.viewProfile(new ResponseValidator() {\n+            @Override\n+            public void validate(Map<String, Object> response) {\n+                Object res = response.get(\"res\");\n+                assertThat(res, Matchers.notNullValue());\n+                assertThat(res.toString(), Matchers.not(Matchers.containsString(\"userName\")));\n+            }\n+        });\n+\n+        setTimeOffsetOfAdapter(20);\n+\n+        loginToClientPage(aliceUser);\n+        assertSuccess();\n+        setTimeOffsetOfAdapter(0);\n+\n+        try (Response response = authorizationResource.resources().create(resource)) {\n+            resource = response.readEntity(ResourceRepresentation.class);\n+        }\n+\n+        loginToClientPage(aliceUser);\n+        assertSuccess();\n+\n+        RealmResource realm = this.realmsResouce().realm(REALM_NAME);\n+        UserRepresentation userRepresentation = realm.users().search(aliceUser.getUsername()).get(0);\n+        UserResource userResource = realm.users().get(userRepresentation.getId());\n+        \n+        userRepresentation.setEmail(\"alice@anotherdomain.org\");\n+        \n+        userResource.update(userRepresentation);\n+        loginToClientPage(aliceUser);\n+        assertTicket();\n+\n+        try {\n+            PolicyRepresentation resourceInstancePermission = new PolicyRepresentation();\n+\n+            resourceInstancePermission.setName(\"View User Permission\");\n+            resourceInstancePermission.setType(\"resource\");\n+\n+            Map<String, String> config = new HashMap<>();\n+\n+            config.put(\"resources\", JsonSerialization.writeValueAsString(Arrays.asList(resource.getId())));\n+            config.put(\"applyPolicies\", JsonSerialization.writeValueAsString(Arrays.asList(\"Only From @keycloak.org or Admin\")));\n+\n+            resourceInstancePermission.setConfig(config);\n+            authorizationResource.policies().create(resourceInstancePermission);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Error creating policy.\", e);\n+        }\n+\n+        loginToClientPage(aliceUser);\n+        // should throw an error because the resource was removed and cache entry did not expire yet\n+        clientPage.viewProfile(new ResponseValidator() {\n+            @Override\n+            public void validate(Map<String, Object> response) {\n+                Object res = response.get(\"res\");\n+                assertThat(res, Matchers.notNullValue());\n+                assertThat(res.toString(), Matchers.not(Matchers.containsString(\"userName\")));\n+            }\n+        });\n+\n+        userRepresentation.setEmail(\"alice@keycloak.org\");\n+\n+        userResource.update(userRepresentation);\n+        loginToClientPage(aliceUser);\n+        assertSuccess();\n+    }\n+\n+    private void assertSuccess() {\n+        clientPage.viewProfile((ResponseValidator) response -> {\n+            Object res = response.get(\"res\");\n+            assertThat(res, Matchers.notNullValue());\n+            assertThat(res.toString(), Matchers.containsString(\"userName\"));\n+        });\n+    }\n+\n+    private void assertTicket() {\n+        clientPage.viewProfile((ResponseValidator) response -> {\n+            Object headers = response.get(\"responseHeaders\");\n+            assertThat(headers, Matchers.notNullValue());\n+            assertThat(headers.toString(), Matchers.containsString(\"WWW-Authenticate: UMA\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d095372c56a9f5f57b27ebb23ceb2dd81a938dd4"}, "originalPosition": 158}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d095372c56a9f5f57b27ebb23ceb2dd81a938dd4", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/d095372c56a9f5f57b27ebb23ceb2dd81a938dd4", "committedDate": "2020-07-08T20:19:02Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}, "afterCommit": {"oid": "9a961b50b37d007b634ae633077c7c7a0f8e9364", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/9a961b50b37d007b634ae633077c7c7a0f8e9364", "committedDate": "2020-10-28T20:42:30Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a961b50b37d007b634ae633077c7c7a0f8e9364", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/9a961b50b37d007b634ae633077c7c7a0f8e9364", "committedDate": "2020-10-28T20:42:30Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}, "afterCommit": {"oid": "9efb2facc6780d0d6ff6524433e240697efdc412", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/9efb2facc6780d0d6ff6524433e240697efdc412", "committedDate": "2021-02-11T12:21:40Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be23f13bd0d14f22afd0ca1f18459d2eae3e163b", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/be23f13bd0d14f22afd0ca1f18459d2eae3e163b", "committedDate": "2021-02-17T16:30:36Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9efb2facc6780d0d6ff6524433e240697efdc412", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/9efb2facc6780d0d6ff6524433e240697efdc412", "committedDate": "2021-02-11T12:21:40Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}, "afterCommit": {"oid": "be23f13bd0d14f22afd0ca1f18459d2eae3e163b", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/be23f13bd0d14f22afd0ca1f18459d2eae3e163b", "committedDate": "2021-02-17T16:30:36Z", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAxNzY3MDQw", "url": "https://github.com/keycloak/keycloak/pull/7184#pullrequestreview-601767040", "createdAt": "2021-03-02T12:36:41Z", "commit": {"oid": "be23f13bd0d14f22afd0ca1f18459d2eae3e163b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAxODQ1NTQx", "url": "https://github.com/keycloak/keycloak/pull/7184#pullrequestreview-601845541", "createdAt": "2021-03-02T14:01:32Z", "commit": {"oid": "be23f13bd0d14f22afd0ca1f18459d2eae3e163b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2988, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}