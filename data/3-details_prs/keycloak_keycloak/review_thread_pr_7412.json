{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg0Njc0MTEy", "number": 7412, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNDo1ODowOVrOEls7aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNDo1ODowOVrOEls7aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTY4ODc1OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNDo1ODowOVrOHVUc2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNjoyNzoyMFrOHVrtLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjExNzIwOA==", "bodyText": "You don't need to fake-verify the token just to parse it. You can do something like:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                TokenVerifier<AccessToken> verifier = TokenVerifier.create(accessTokenString, AccessToken.class)\n          \n          \n            \n                                        .withDefaultChecks()\n          \n          \n            \n                                        .realmUrl(Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()))\n          \n          \n            \n                                        .checkActive(false);\n          \n          \n            \n                                String kid = verifier.getHeader().getKeyId();\n          \n          \n            \n                                String algorithm = verifier.getHeader().getAlgorithm().name();\n          \n          \n            \n                                SignatureVerifierContext signatureVerifier = session.getProvider(SignatureProvider.class, algorithm).verifier(kid);\n          \n          \n            \n                                verifier.verifierContext(signatureVerifier);\n          \n          \n            \n                                AccessToken invalidToken = verifier.verify().getToken();\n          \n          \n            \n                                AccessToken invalidToken = new JWSInput(accessTokenString).readJsonContent(AccessToken.class);\n          \n      \n    \n    \n  \n\nMaybe there's even more efficient solution, I'm not sure.", "url": "https://github.com/keycloak/keycloak/pull/7412#discussion_r492117208", "createdAt": "2020-09-21T14:58:09Z", "author": {"login": "vmuzikar"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java", "diffHunk": "@@ -1210,6 +1214,22 @@ public Response permissionGrant() {\n             AccessToken accessToken = Tokens.getAccessToken(session);\n \n             if (accessToken == null) {\n+                try {\n+                    // In case the access token is invalid because it's expired or the user is disabled, identify the client\n+                    // from the access token anyway in order to set correct CORS headers.\n+                    TokenVerifier<AccessToken> verifier = TokenVerifier.create(accessTokenString, AccessToken.class)\n+                            .withDefaultChecks()\n+                            .realmUrl(Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()))\n+                            .checkActive(false);\n+                    String kid = verifier.getHeader().getKeyId();\n+                    String algorithm = verifier.getHeader().getAlgorithm().name();\n+                    SignatureVerifierContext signatureVerifier = session.getProvider(SignatureProvider.class, algorithm).verifier(kid);\n+                    verifier.verifierContext(signatureVerifier);\n+                    AccessToken invalidToken = verifier.verify().getToken();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09ad2b240e3e79a389f3c8663307f8130d23692e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NjgzOQ==", "bodyText": "Is it just as correct then to allow any origin for the error response, and ignore the client setting completely? I see that has been done for some of the other checks in TokenEndpoint: (checkSsl, checkRealm)\n                    cors.allowAllOrigins();", "url": "https://github.com/keycloak/keycloak/pull/7412#discussion_r492486839", "createdAt": "2020-09-22T05:49:30Z", "author": {"login": "FrodeI"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java", "diffHunk": "@@ -1210,6 +1214,22 @@ public Response permissionGrant() {\n             AccessToken accessToken = Tokens.getAccessToken(session);\n \n             if (accessToken == null) {\n+                try {\n+                    // In case the access token is invalid because it's expired or the user is disabled, identify the client\n+                    // from the access token anyway in order to set correct CORS headers.\n+                    TokenVerifier<AccessToken> verifier = TokenVerifier.create(accessTokenString, AccessToken.class)\n+                            .withDefaultChecks()\n+                            .realmUrl(Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()))\n+                            .checkActive(false);\n+                    String kid = verifier.getHeader().getKeyId();\n+                    String algorithm = verifier.getHeader().getAlgorithm().name();\n+                    SignatureVerifierContext signatureVerifier = session.getProvider(SignatureProvider.class, algorithm).verifier(kid);\n+                    verifier.verifierContext(signatureVerifier);\n+                    AccessToken invalidToken = verifier.verify().getToken();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjExNzIwOA=="}, "originalCommit": {"oid": "09ad2b240e3e79a389f3c8663307f8130d23692e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ5ODIyMg==", "bodyText": "I haven't checked what other verifications do, but I see no real reason why we should allow all origins here. Just parse the token, get the client and you're good to go. :)", "url": "https://github.com/keycloak/keycloak/pull/7412#discussion_r492498222", "createdAt": "2020-09-22T06:27:20Z", "author": {"login": "vmuzikar"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java", "diffHunk": "@@ -1210,6 +1214,22 @@ public Response permissionGrant() {\n             AccessToken accessToken = Tokens.getAccessToken(session);\n \n             if (accessToken == null) {\n+                try {\n+                    // In case the access token is invalid because it's expired or the user is disabled, identify the client\n+                    // from the access token anyway in order to set correct CORS headers.\n+                    TokenVerifier<AccessToken> verifier = TokenVerifier.create(accessTokenString, AccessToken.class)\n+                            .withDefaultChecks()\n+                            .realmUrl(Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()))\n+                            .checkActive(false);\n+                    String kid = verifier.getHeader().getKeyId();\n+                    String algorithm = verifier.getHeader().getAlgorithm().name();\n+                    SignatureVerifierContext signatureVerifier = session.getProvider(SignatureProvider.class, algorithm).verifier(kid);\n+                    verifier.verifierContext(signatureVerifier);\n+                    AccessToken invalidToken = verifier.verify().getToken();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjExNzIwOA=="}, "originalCommit": {"oid": "09ad2b240e3e79a389f3c8663307f8130d23692e"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3440, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}