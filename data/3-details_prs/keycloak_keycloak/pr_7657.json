{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxNDQwMzIx", "number": 7657, "title": "KEYCLOAK-11908 Support for conditional creating indices based on number", "bodyText": "JIRA ticket: https://issues.redhat.com/browse/KEYCLOAK-11908\nHow to use\n\n\nChange indexCreationThreshold property of connectionsLiquibase spi in the configuration file (like standalone.xml).\n            <spi name=\"connectionsLiquibase\">\n                <provider name=\"default\" enabled=\"true\">\n                    <properties>\n                        <property name=\"indexCreationThreshold\" value=\"10000\"/>\n                    </properties>\n                </provider>\n            </spi>\n\n\nDefine createIndex change to the change log file (jpa-changelog-x.x.x.xml).\n    <changeSet author=\"keycloak\" id=\"add-index\">\n        <createIndex indexName=\"xxx\" tableName=\"yyy\">\n            <column name=\"zzz\" type=\"VARCHAR(255)\"/>\n        </createIndex>\n    </changeSet>\n\n\nWhen migration, if the number of records of the specified table is larger than indexCreationThreshold, createIndex change does not run, otherwise createIndex change run.\n\n\nSpec\n\nThe indexCreationThreshold value is common in all tables.\nThe default indexCreationThreshold value is 10000.\nIf the indexCreationThreshold value is -1, all createIndex change run.\n\nCode\n\nDefaultLiquibaseConnectionProvider\n\nnew field indexCreationThreshold\n\nIn init method, set this value from the indexCreationThreshold property's value in the configuration file.\nIn getLiquibase method, pass indexCreationThreshold to LiquibaseJpaUpdaterProvider and QuarkusJpaUpdaterProvider via Liquibase's changeLogParameter.\n\n\n\n\nLiquibaseJpaUpdaterProvider and QuarkusJpaUpdaterProvider\n\nnew validateIndexThreshold method\n\nIf indexCreationThreshold  is not defined, or indexCreationThreshold equals -1, skip verification.\nIf there is a change instance of CreateIndexChange in the changeSet of unrunChangeSets,\n\nif the target table exists and the number of records of the target table is larger than indexCreationThreshold, mark the changeSet as validationFailed.\n\n\n\n\nIn updateChangeSet method, call validateIndexThreshold method when there are unrunChangeSets.", "createdAt": "2020-12-03T04:06:45Z", "url": "https://github.com/keycloak/keycloak/pull/7657", "merged": true, "mergeCommit": {"oid": "ab1dba5fa6d98146e63556581ccd74077af1c998"}, "closed": true, "closedAt": "2021-01-12T08:06:28Z", "author": {"login": "y-tabata"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdjsbMxgBqjQwNzc0NDEwODQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdm_1AAAFqTU1NDQwMzU4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c57bcec5fe8a57978fb9c545544654af2a9a4116", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/c57bcec5fe8a57978fb9c545544654af2a9a4116", "committedDate": "2020-12-03T04:00:22Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}, "afterCommit": {"oid": "74c53324d60b8edaf4a73d8ac2223f786aa8fe53", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/74c53324d60b8edaf4a73d8ac2223f786aa8fe53", "committedDate": "2020-12-07T02:49:29Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTU0Njgy", "url": "https://github.com/keycloak/keycloak/pull/7657#pullrequestreview-549554682", "createdAt": "2020-12-10T19:59:16Z", "commit": {"oid": "74c53324d60b8edaf4a73d8ac2223f786aa8fe53"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "74c53324d60b8edaf4a73d8ac2223f786aa8fe53", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/74c53324d60b8edaf4a73d8ac2223f786aa8fe53", "committedDate": "2020-12-07T02:49:29Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}, "afterCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/f997c299d53b316f4c1a45c05549f2b96a4117ce", "committedDate": "2020-12-11T04:12:45Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTY0NTAy", "url": "https://github.com/keycloak/keycloak/pull/7657#pullrequestreview-549964502", "createdAt": "2020-12-11T10:11:22Z", "commit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDoxMToyMlrOIDx_Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMToyNzo1MlrOID0v1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNTY3MA==", "bodyText": "nit: missing copyright comment", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540835670", "createdAt": "2020-12-11T10:11:22Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNjkyNA==", "bodyText": "If I understand it correctly this check is here to test if the table actually exist, am I right? If so I wonder if the check is necessary.", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540836924", "createdAt": "2020-12-11T10:13:19Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n+            return super.generateStatements(database);\n+\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MzUyNA==", "bodyText": "Have you chance to test this sql in various databases like MySQL, Oracle, Portgres and MSSQL? It seems there is missing whitespace character after from keyword.\nIf I remember correctly there is also a need to properly escape schema for select statements when the table name is retrieved. Please see CustomKeycloakTask.getTableName(String) for more details.", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540843524", "createdAt": "2020-12-11T10:24:14Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n+            return super.generateStatements(database);\n+\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n+                return super.generateStatements(database);\n+\n+            int result = ExecutorService.getInstance().getExecutor(database)\n+                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDYyNw==", "bodyText": "Could @DatabaseChange annotation be used directly instead of overriding this method?", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540844627", "createdAt": "2020-12-11T10:25:57Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n+            return super.generateStatements(database);\n+\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n+                return super.generateStatements(database);\n+\n+            int result = ExecutorService.getInstance().getExecutor(database)\n+                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));\n+\n+            if (result > (Integer) indexCreationThreshold) {\n+                logger.warnv(\"Following index should be created: CREATE INDEX {0};\",\n+                    new Index(getIndexName(), getCatalogName(), getSchemaName(), getTableName()));\n+                return new SqlStatement[] {};\n+            }\n+        } catch (DatabaseException | InvalidExampleException e) {\n+            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n+        }\n+\n+        return super.generateStatements(database);\n+    }\n+\n+    @Override\n+    public ChangeMetaData createChangeMetaData() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NjE0MQ==", "bodyText": "I'd suggest to add a // comment with a note the CustomCreateIndexChange is registered for handle conditional indices creation", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540846141", "createdAt": "2020-12-11T10:28:17Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java", "diffHunk": "@@ -109,12 +116,14 @@ protected void baseLiquibaseInitialization() {\n \n         // Use \"SELECT FOR UPDATE\" for locking database\n         SqlGeneratorFactory.getInstance().register(new CustomLockDatabaseChangeLogGenerator());\n-    }\n \n+        ChangeFactory.getInstance().register(CustomCreateIndexChange.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0ODQwNQ==", "bodyText": "I'd suggest to add // comment where could be specified that this check is here for manual migration. It should be easily overlooked and the comment should help.", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540848405", "createdAt": "2020-12-11T10:32:00Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NDEwNQ==", "bodyText": "The intention is to avoid tens of seconds spent on index creation upon upgrade, so I think 100000 would be still perfectly acceptable.", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540864105", "createdAt": "2020-12-11T10:58:05Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java", "diffHunk": "@@ -109,12 +116,14 @@ protected void baseLiquibaseInitialization() {\n \n         // Use \"SELECT FOR UPDATE\" for locking database\n         SqlGeneratorFactory.getInstance().register(new CustomLockDatabaseChangeLogGenerator());\n-    }\n \n+        ChangeFactory.getInstance().register(CustomCreateIndexChange.class);\n+    }\n \n     @Override\n     public void init(Config.Scope config) {\n-\n+        indexCreationThreshold = config.getInt(\"indexCreationThreshold\", 10000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4MDg1NQ==", "bodyText": "I'd suggest to introduce private int indexCreationThreshold; in this class and I'd also suggest following\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n          \n          \n            \n                    if (indexCreationThreshold instanceof Integer) {\n          \n          \n            \n                        this.indexCreationThreshold = (Integer) indexCreationThreshold;\n          \n          \n            \n                        if (this.indexCreationThreshold <= 0) return super.generateStatements(database);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return super.generateStatements(database);\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\ninstanceof  should take care of null and we can avoid type casting on line 50. wdyt?", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540880855", "createdAt": "2020-12-11T11:27:52Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 39}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/f997c299d53b316f4c1a45c05549f2b96a4117ce", "committedDate": "2020-12-11T04:12:45Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}, "afterCommit": {"oid": "bce93fb0c80e637282040e762ca880e1e5542ce0", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/bce93fb0c80e637282040e762ca880e1e5542ce0", "committedDate": "2020-12-14T07:49:22Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bce93fb0c80e637282040e762ca880e1e5542ce0", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/bce93fb0c80e637282040e762ca880e1e5542ce0", "committedDate": "2020-12-14T07:49:22Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}, "afterCommit": {"oid": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "committedDate": "2020-12-15T05:49:31Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTU1NDk5", "url": "https://github.com/keycloak/keycloak/pull/7657#pullrequestreview-553555499", "createdAt": "2020-12-16T10:35:33Z", "commit": {"oid": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDozNTozM1rOIG-qMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNDozNzoyN1rOIHIZlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE4ODk3OQ==", "bodyText": "You're right. The reason why it fails is the fact that generateStatements(Database) is called during validation and other stuff multiple times when the table doesn't have to be there yet. Maybe it'd be worth to add a // comment with the info to this check as well, wdyt?", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544188979", "createdAt": "2020-12-16T10:35:33Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n+            return super.generateStatements(database);\n+\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNjkyNA=="}, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNTkxNA==", "bodyText": "thank you", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544235914", "createdAt": "2020-12-16T11:50:28Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java", "diffHunk": "@@ -109,12 +116,14 @@ protected void baseLiquibaseInitialization() {\n \n         // Use \"SELECT FOR UPDATE\" for locking database\n         SqlGeneratorFactory.getInstance().register(new CustomLockDatabaseChangeLogGenerator());\n-    }\n \n+        ChangeFactory.getInstance().register(CustomCreateIndexChange.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NjE0MQ=="}, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNjAwNQ==", "bodyText": "thank you", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544236005", "createdAt": "2020-12-16T11:50:37Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNTY3MA=="}, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNjA4Ng==", "bodyText": "thank you", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544236086", "createdAt": "2020-12-16T11:50:46Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0ODQwNQ=="}, "originalCommit": {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0Mzg4MQ==", "bodyText": "What'd you say about idea to create make DefaultLiquibaseConnectionProvider.indexCreationThreshold static and to introduce\n    public static int getIndexCreationThreshold() {\n        return indexCreationThreshold;\n    }\n\nthere? We'd then be able to use\nif (DefaultLiquibaseConnectionProvider.getIndexCreationThreshold() <= 0)\n                return super.generateStatements(database);\n\nhere instead of parsing Integer from attributes.", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544343881", "createdAt": "2020-12-16T14:31:20Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.io.StringWriter;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.LiquibaseJpaUpdaterProvider;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.AddColumnConfig;\n+import liquibase.change.ChangeFactory;\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.ChangeParameterMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.exception.ValidationErrors;\n+import liquibase.exception.Warnings;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.sqlgenerator.SqlGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.CreateIndexStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+@DatabaseChange(name = \"createIndex\", description = \"Creates an index on an existing column or set of columns conditionally based on the number of records.\", priority = ChangeMetaData.PRIORITY_DEFAULT\n+    + 1, appliesTo = \"index\")\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+    private int indexCreationThreshold;\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        // This check is for manual migration\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0ODU2NQ==", "bodyText": "Can we avoid overriding this and following two methods?", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544348565", "createdAt": "2020-12-16T14:37:27Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.io.StringWriter;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.LiquibaseJpaUpdaterProvider;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.AddColumnConfig;\n+import liquibase.change.ChangeFactory;\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.ChangeParameterMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.exception.ValidationErrors;\n+import liquibase.exception.Warnings;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.sqlgenerator.SqlGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.CreateIndexStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+@DatabaseChange(name = \"createIndex\", description = \"Creates an index on an existing column or set of columns conditionally based on the number of records.\", priority = ChangeMetaData.PRIORITY_DEFAULT\n+    + 1, appliesTo = \"index\")\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+    private int indexCreationThreshold;\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        // This check is for manual migration\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold instanceof Integer) {\n+            this.indexCreationThreshold = (Integer) indexCreationThreshold;\n+            if (this.indexCreationThreshold <= 0)\n+                return super.generateStatements(database);\n+        } else {\n+            return super.generateStatements(database);\n+        }\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n+                return super.generateStatements(database);\n+\n+            int result = ExecutorService.getInstance().getExecutor(database).queryForInt(\n+                new RawSqlStatement(\"SELECT COUNT(*) FROM \" + getTableNameForSqlSelects(database, getTableName())));\n+\n+            if (result > this.indexCreationThreshold) {\n+                String loggingString = createLoggingString(database);\n+                logger.warnv(\"Following index should be created: {0}\", loggingString);\n+                getChangeSet().setComments(loggingString);\n+                return new SqlStatement[] {};\n+            }\n+\n+        } catch (DatabaseException | InvalidExampleException e) {\n+            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n+        }\n+\n+        return super.generateStatements(database);\n+    }\n+\n+    private String getTableNameForSqlSelects(Database database, String tableName) {\n+        String correctedSchemaName = database.escapeObjectName(database.getDefaultSchemaName(), Schema.class);\n+        return LiquibaseJpaUpdaterProvider.getTable(tableName, correctedSchemaName);\n+    }\n+\n+    private String createLoggingString(Database database) throws DatabaseException {\n+        StringWriter writer = new StringWriter();\n+        LoggingExecutor loggingExecutor = new LoggingExecutor(ExecutorService.getInstance().getExecutor(database), writer,\n+            database);\n+        SqlStatement sqlStatement = new CreateIndexStatement(getIndexName(), getCatalogName(), getSchemaName(), getTableName(),\n+            this.isUnique(), getAssociatedWith(), getColumns().toArray(new AddColumnConfig[getColumns().size()]))\n+                .setTablespace(getTablespace()).setClustered(getClustered());\n+\n+        loggingExecutor.execute(sqlStatement);\n+\n+        return writer.toString();\n+    }\n+\n+    @Override\n+    public boolean generateStatementsVolatile(Database database) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzODkyMDIz", "url": "https://github.com/keycloak/keycloak/pull/7657#pullrequestreview-553892023", "createdAt": "2020-12-16T16:57:16Z", "commit": {"oid": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "486733f8f8fc557a94ee93072eba08eed8daea74", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/486733f8f8fc557a94ee93072eba08eed8daea74", "committedDate": "2020-12-16T21:46:29Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "committedDate": "2020-12-15T05:49:31Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}, "afterCommit": {"oid": "486733f8f8fc557a94ee93072eba08eed8daea74", "author": {"user": {"login": "y-tabata", "name": "Yoshiyuki Tabata"}}, "url": "https://github.com/keycloak/keycloak/commit/486733f8f8fc557a94ee93072eba08eed8daea74", "committedDate": "2020-12-16T21:46:29Z", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTYxMjQ0", "url": "https://github.com/keycloak/keycloak/pull/7657#pullrequestreview-554161244", "createdAt": "2020-12-16T23:13:54Z", "commit": {"oid": "486733f8f8fc557a94ee93072eba08eed8daea74"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NDAzNTg4", "url": "https://github.com/keycloak/keycloak/pull/7657#pullrequestreview-554403588", "createdAt": "2020-12-17T09:08:16Z", "commit": {"oid": "486733f8f8fc557a94ee93072eba08eed8daea74"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3298, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}