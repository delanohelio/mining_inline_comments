{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4ODY4MTE1", "number": 6704, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMTowNDozOFrODcNAgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDoyNjoyMFrOD2tlxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwODk5ODQzOnYy", "diffSide": "RIGHT", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/TokenRevocationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxMTowNDozOFrOFkIJNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNjozODo1MVrOFlJbDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQyNjQ4NA==", "bodyText": "I could not find so maybe I'm missing it. But is there a test that asserts:\n\nUser session is still valid when client sessions are invalidated after revocation\nAdapter is actually receiving the backchannel request and invalidating the local session accordingly", "url": "https://github.com/keycloak/keycloak/pull/6704#discussion_r373426484", "createdAt": "2020-01-31T11:04:38Z", "author": {"login": "pedroigor"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/TokenRevocationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.testsuite.oauth;\n+\n+import static org.junit.Assert.*;\n+import static org.keycloak.testsuite.admin.AbstractAdminTest.*;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.admin.client.resource.RealmResource;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.testsuite.AbstractKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.util.ClientManager;\n+import org.keycloak.testsuite.util.Matchers;\n+import org.keycloak.testsuite.util.OAuthClient;\n+import org.keycloak.testsuite.util.OAuthClient.AccessTokenResponse;\n+import org.keycloak.testsuite.util.RealmBuilder;\n+import org.keycloak.util.JsonSerialization;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+public class TokenRevocationTest extends AbstractKeycloakTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17542d5359d5938c54465a65573c501ffcb2aa60"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NjAxNQ==", "bodyText": "@pedroigor Thanks! I fixed the test and included these tests.", "url": "https://github.com/keycloak/keycloak/pull/6704#discussion_r374496015", "createdAt": "2020-02-04T06:38:51Z", "author": {"login": "y-tabata"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/TokenRevocationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.testsuite.oauth;\n+\n+import static org.junit.Assert.*;\n+import static org.keycloak.testsuite.admin.AbstractAdminTest.*;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.admin.client.resource.RealmResource;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.testsuite.AbstractKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.util.ClientManager;\n+import org.keycloak.testsuite.util.Matchers;\n+import org.keycloak.testsuite.util.OAuthClient;\n+import org.keycloak.testsuite.util.OAuthClient.AccessTokenResponse;\n+import org.keycloak.testsuite.util.RealmBuilder;\n+import org.keycloak.util.JsonSerialization;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+public class TokenRevocationTest extends AbstractKeycloakTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQyNjQ4NA=="}, "originalCommit": {"oid": "17542d5359d5938c54465a65573c501ffcb2aa60"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjkzMjk4OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDoyMDoxN1rOGMlspQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMTo1NjoyNFrOGNQZCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg1MzczMw==", "bodyText": "It looks like you are missing validations based on the token_type_hint. As well as what is the default value we expect if none was provided.\nI understand this parameter is OPTIONAL and we can infer the token type from the token itself (As we are using JWT as the format). But not validate this parameter can cause confusion given that we are supposed to accept only a specific set of values.", "url": "https://github.com/keycloak/keycloak/pull/6704#discussion_r415853733", "createdAt": "2020-04-27T14:20:17Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.protocol.oidc.endpoints;\n+\n+import java.util.List;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.managers.UserSessionCrossDCManager;\n+import org.keycloak.services.managers.UserSessionManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.util.TokenUtil;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+public class TokenRevocationEndpoint {\n+    private static final String PARAM_TOKEN = \"token\";\n+\n+    @Context\n+    private KeycloakSession session;\n+\n+    @Context\n+    private HttpRequest request;\n+\n+    @Context\n+    private HttpHeaders headers;\n+\n+    @Context\n+    private ClientConnection clientConnection;\n+\n+    private MultivaluedMap<String, String> formParams;\n+    private ClientModel client;\n+    private RealmModel realm;\n+    private EventBuilder event;\n+    private Cors cors;\n+    private RefreshToken token;\n+    private UserModel user;\n+\n+    public TokenRevocationEndpoint(RealmModel realm, EventBuilder event) {\n+        this.realm = realm;\n+        this.event = event;\n+    }\n+\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    public Response revoke() {\n+        event.event(EventType.REVOKE_GRANT);\n+\n+        cors = Cors.add(request).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+\n+        checkSsl();\n+        checkRealm();\n+        checkClient();\n+\n+        formParams = request.getDecodedFormParameters();\n+\n+        checkToken();\n+        checkIssuedFor();\n+\n+        checkUser();\n+        revokeClient();\n+\n+        event.detail(Details.REVOKED_CLIENT, client.getClientId()).success();\n+\n+        return cors.builder(Response.ok()).build();\n+    }\n+\n+    private void checkSsl() {\n+        if (!session.getContext().getUri().getBaseUri().getScheme().equals(\"https\")\n+            && realm.getSslRequired().isRequired(clientConnection)) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), OAuthErrorException.INVALID_REQUEST, \"HTTPS required\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkRealm() {\n+        if (!realm.isEnabled()) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), \"access_denied\", \"Realm not enabled\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkClient() {\n+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);\n+        client = clientAuth.getClient();\n+\n+        event.client(client);\n+\n+        cors.allowedOrigins(session, client);\n+\n+        if (client.isBearerOnly()) {\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, \"Bearer-only not allowed\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkToken() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e64e838b8692efc8e8334a18ace73a8b8b4d17f3"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzMTAwMg==", "bodyText": "@pedroigor\n\nBut not validate this parameter can cause confusion given that we are supposed to accept only a specific set of values.\n\nWe are not supposed to accept only a specific set of values. RFC7009 defined two values \"access_token\" and \"refresh_token\", and also says that other values for this parameter can be defined. And RFC 7009 also says like [1], so they can be summarized as follows.\n\n\ntoken_type_hint == \"refresh_token\":\nWe will support this and if \"token\" is the refresh token, the server can revoke it. But if \"token\" is not the refresh token, return an error.\n\n\ntoken_type_hint == \"access_token\":\nWe will not support this. But if \"token\" is the refresh token, the server can revoke it.\n\n\ntoken_type_hint == \"invalid_token_type\":\nThe same as \"access_token\", we will not support this, but if \"token\" is the refresh token, the server can revoke it.\n\n\ntoken_type_hint == null:\nThe same as \"access_token\", we will not support this, but if \"token\" is the refresh token, the server can revoke it.\n\n\nAccording to the above, there is no need to check \"token_type_hint\".\n[1] If the server is unable to locate the token using the given hint, it MUST extend its search across all of its supported token types. An authorization server MAY ignore this parameter, particularly if it is able to detect the token type automatically. An invalid token type hint value is ignored by the authorization server and does not influence the revocation response.", "url": "https://github.com/keycloak/keycloak/pull/6704#discussion_r416231002", "createdAt": "2020-04-28T00:02:44Z", "author": {"login": "y-tabata"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.protocol.oidc.endpoints;\n+\n+import java.util.List;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.managers.UserSessionCrossDCManager;\n+import org.keycloak.services.managers.UserSessionManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.util.TokenUtil;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+public class TokenRevocationEndpoint {\n+    private static final String PARAM_TOKEN = \"token\";\n+\n+    @Context\n+    private KeycloakSession session;\n+\n+    @Context\n+    private HttpRequest request;\n+\n+    @Context\n+    private HttpHeaders headers;\n+\n+    @Context\n+    private ClientConnection clientConnection;\n+\n+    private MultivaluedMap<String, String> formParams;\n+    private ClientModel client;\n+    private RealmModel realm;\n+    private EventBuilder event;\n+    private Cors cors;\n+    private RefreshToken token;\n+    private UserModel user;\n+\n+    public TokenRevocationEndpoint(RealmModel realm, EventBuilder event) {\n+        this.realm = realm;\n+        this.event = event;\n+    }\n+\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    public Response revoke() {\n+        event.event(EventType.REVOKE_GRANT);\n+\n+        cors = Cors.add(request).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+\n+        checkSsl();\n+        checkRealm();\n+        checkClient();\n+\n+        formParams = request.getDecodedFormParameters();\n+\n+        checkToken();\n+        checkIssuedFor();\n+\n+        checkUser();\n+        revokeClient();\n+\n+        event.detail(Details.REVOKED_CLIENT, client.getClientId()).success();\n+\n+        return cors.builder(Response.ok()).build();\n+    }\n+\n+    private void checkSsl() {\n+        if (!session.getContext().getUri().getBaseUri().getScheme().equals(\"https\")\n+            && realm.getSslRequired().isRequired(clientConnection)) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), OAuthErrorException.INVALID_REQUEST, \"HTTPS required\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkRealm() {\n+        if (!realm.isEnabled()) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), \"access_denied\", \"Realm not enabled\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkClient() {\n+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);\n+        client = clientAuth.getClient();\n+\n+        event.client(client);\n+\n+        cors.allowedOrigins(session, client);\n+\n+        if (client.isBearerOnly()) {\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, \"Bearer-only not allowed\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkToken() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg1MzczMw=="}, "originalCommit": {"oid": "e64e838b8692efc8e8334a18ace73a8b8b4d17f3"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzIyNA==", "bodyText": "@y-tabata I missed that part. But still confusing to me. IMO, the AS could just have a default hint (e.g.: refresh) if none was provided and discard right away any value not supported by the server.\nMy point here is that now we only support revocation using refresh tokens, so we could just fail fast when attempting to pass any other hint.", "url": "https://github.com/keycloak/keycloak/pull/6704#discussion_r416553224", "createdAt": "2020-04-28T11:56:24Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.protocol.oidc.endpoints;\n+\n+import java.util.List;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.managers.UserSessionCrossDCManager;\n+import org.keycloak.services.managers.UserSessionManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.util.TokenUtil;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+public class TokenRevocationEndpoint {\n+    private static final String PARAM_TOKEN = \"token\";\n+\n+    @Context\n+    private KeycloakSession session;\n+\n+    @Context\n+    private HttpRequest request;\n+\n+    @Context\n+    private HttpHeaders headers;\n+\n+    @Context\n+    private ClientConnection clientConnection;\n+\n+    private MultivaluedMap<String, String> formParams;\n+    private ClientModel client;\n+    private RealmModel realm;\n+    private EventBuilder event;\n+    private Cors cors;\n+    private RefreshToken token;\n+    private UserModel user;\n+\n+    public TokenRevocationEndpoint(RealmModel realm, EventBuilder event) {\n+        this.realm = realm;\n+        this.event = event;\n+    }\n+\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    public Response revoke() {\n+        event.event(EventType.REVOKE_GRANT);\n+\n+        cors = Cors.add(request).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+\n+        checkSsl();\n+        checkRealm();\n+        checkClient();\n+\n+        formParams = request.getDecodedFormParameters();\n+\n+        checkToken();\n+        checkIssuedFor();\n+\n+        checkUser();\n+        revokeClient();\n+\n+        event.detail(Details.REVOKED_CLIENT, client.getClientId()).success();\n+\n+        return cors.builder(Response.ok()).build();\n+    }\n+\n+    private void checkSsl() {\n+        if (!session.getContext().getUri().getBaseUri().getScheme().equals(\"https\")\n+            && realm.getSslRequired().isRequired(clientConnection)) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), OAuthErrorException.INVALID_REQUEST, \"HTTPS required\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkRealm() {\n+        if (!realm.isEnabled()) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), \"access_denied\", \"Realm not enabled\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkClient() {\n+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);\n+        client = clientAuth.getClient();\n+\n+        event.client(client);\n+\n+        cors.allowedOrigins(session, client);\n+\n+        if (client.isBearerOnly()) {\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, \"Bearer-only not allowed\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkToken() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg1MzczMw=="}, "originalCommit": {"oid": "e64e838b8692efc8e8334a18ace73a8b8b4d17f3"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Njk2NjQ2OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDoyNjoyMFrOGMmAYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMjowNjo1NlrOGNQvmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg1ODc4Nw==", "bodyText": "Currently, consents are persistent and we don't ask end-users for consent if they have previously granted it to a client.\nBy removing this you are forcing users to consent again. Is that on purpose?", "url": "https://github.com/keycloak/keycloak/pull/6704#discussion_r415858787", "createdAt": "2020-04-27T14:26:20Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.protocol.oidc.endpoints;\n+\n+import java.util.List;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.managers.UserSessionCrossDCManager;\n+import org.keycloak.services.managers.UserSessionManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.util.TokenUtil;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+public class TokenRevocationEndpoint {\n+    private static final String PARAM_TOKEN = \"token\";\n+\n+    @Context\n+    private KeycloakSession session;\n+\n+    @Context\n+    private HttpRequest request;\n+\n+    @Context\n+    private HttpHeaders headers;\n+\n+    @Context\n+    private ClientConnection clientConnection;\n+\n+    private MultivaluedMap<String, String> formParams;\n+    private ClientModel client;\n+    private RealmModel realm;\n+    private EventBuilder event;\n+    private Cors cors;\n+    private RefreshToken token;\n+    private UserModel user;\n+\n+    public TokenRevocationEndpoint(RealmModel realm, EventBuilder event) {\n+        this.realm = realm;\n+        this.event = event;\n+    }\n+\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    public Response revoke() {\n+        event.event(EventType.REVOKE_GRANT);\n+\n+        cors = Cors.add(request).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+\n+        checkSsl();\n+        checkRealm();\n+        checkClient();\n+\n+        formParams = request.getDecodedFormParameters();\n+\n+        checkToken();\n+        checkIssuedFor();\n+\n+        checkUser();\n+        revokeClient();\n+\n+        event.detail(Details.REVOKED_CLIENT, client.getClientId()).success();\n+\n+        return cors.builder(Response.ok()).build();\n+    }\n+\n+    private void checkSsl() {\n+        if (!session.getContext().getUri().getBaseUri().getScheme().equals(\"https\")\n+            && realm.getSslRequired().isRequired(clientConnection)) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), OAuthErrorException.INVALID_REQUEST, \"HTTPS required\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkRealm() {\n+        if (!realm.isEnabled()) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), \"access_denied\", \"Realm not enabled\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkClient() {\n+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);\n+        client = clientAuth.getClient();\n+\n+        event.client(client);\n+\n+        cors.allowedOrigins(session, client);\n+\n+        if (client.isBearerOnly()) {\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, \"Bearer-only not allowed\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkToken() {\n+        String encodedToken = formParams.getFirst(PARAM_TOKEN);\n+\n+        if (encodedToken == null) {\n+            event.error(Errors.INVALID_REQUEST);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST, \"Token not provided\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+\n+        token = session.tokens().decode(encodedToken, RefreshToken.class);\n+\n+        if (token == null) {\n+            event.error(Errors.INVALID_TOKEN);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\", Response.Status.OK);\n+        }\n+\n+        if (!(TokenUtil.TOKEN_TYPE_REFRESH.equals(token.getType()) || TokenUtil.TOKEN_TYPE_OFFLINE.equals(token.getType()))) {\n+            event.error(Errors.INVALID_TOKEN_TYPE);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.UNSUPPORTED_TOKEN_TYPE, \"Unsupported token type\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkIssuedFor() {\n+        String issuedFor = token.getIssuedFor();\n+        if (issuedFor == null) {\n+            event.error(Errors.INVALID_TOKEN);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\", Response.Status.OK);\n+        }\n+\n+        if (!client.getClientId().equals(issuedFor)) {\n+            event.error(Errors.INVALID_REQUEST);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST, \"Unmatching clients\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkUser() {\n+        UserSessionModel userSession = new UserSessionCrossDCManager(session).getUserSessionWithClient(realm,\n+            token.getSessionState(), false, client.getId());\n+\n+        if (userSession == null) {\n+            userSession = new UserSessionCrossDCManager(session).getUserSessionWithClient(realm, token.getSessionState(), true,\n+                client.getId());\n+\n+            if (userSession == null) {\n+                event.error(Errors.USER_SESSION_NOT_FOUND);\n+                throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\",\n+                    Response.Status.OK);\n+            }\n+        }\n+\n+        user = userSession.getUser();\n+\n+        if (user == null) {\n+            event.error(Errors.USER_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\", Response.Status.OK);\n+        }\n+\n+        event.user(user);\n+    }\n+\n+    private void revokeClient() {\n+        session.users().revokeConsentForClient(realm, user.getId(), client.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e64e838b8692efc8e8334a18ace73a8b8b4d17f3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI0MDEzNQ==", "bodyText": "@pedroigor\n\nBy removing this you are forcing users to consent again. Is that on purpose?\n\nYes. A user revokes a token because the user doesn't want the client to use it, so the relationship between the user and the client should be broken off and also the consent should be removed.", "url": "https://github.com/keycloak/keycloak/pull/6704#discussion_r416240135", "createdAt": "2020-04-28T00:27:49Z", "author": {"login": "y-tabata"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.protocol.oidc.endpoints;\n+\n+import java.util.List;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.managers.UserSessionCrossDCManager;\n+import org.keycloak.services.managers.UserSessionManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.util.TokenUtil;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+public class TokenRevocationEndpoint {\n+    private static final String PARAM_TOKEN = \"token\";\n+\n+    @Context\n+    private KeycloakSession session;\n+\n+    @Context\n+    private HttpRequest request;\n+\n+    @Context\n+    private HttpHeaders headers;\n+\n+    @Context\n+    private ClientConnection clientConnection;\n+\n+    private MultivaluedMap<String, String> formParams;\n+    private ClientModel client;\n+    private RealmModel realm;\n+    private EventBuilder event;\n+    private Cors cors;\n+    private RefreshToken token;\n+    private UserModel user;\n+\n+    public TokenRevocationEndpoint(RealmModel realm, EventBuilder event) {\n+        this.realm = realm;\n+        this.event = event;\n+    }\n+\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    public Response revoke() {\n+        event.event(EventType.REVOKE_GRANT);\n+\n+        cors = Cors.add(request).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+\n+        checkSsl();\n+        checkRealm();\n+        checkClient();\n+\n+        formParams = request.getDecodedFormParameters();\n+\n+        checkToken();\n+        checkIssuedFor();\n+\n+        checkUser();\n+        revokeClient();\n+\n+        event.detail(Details.REVOKED_CLIENT, client.getClientId()).success();\n+\n+        return cors.builder(Response.ok()).build();\n+    }\n+\n+    private void checkSsl() {\n+        if (!session.getContext().getUri().getBaseUri().getScheme().equals(\"https\")\n+            && realm.getSslRequired().isRequired(clientConnection)) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), OAuthErrorException.INVALID_REQUEST, \"HTTPS required\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkRealm() {\n+        if (!realm.isEnabled()) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), \"access_denied\", \"Realm not enabled\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkClient() {\n+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);\n+        client = clientAuth.getClient();\n+\n+        event.client(client);\n+\n+        cors.allowedOrigins(session, client);\n+\n+        if (client.isBearerOnly()) {\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, \"Bearer-only not allowed\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkToken() {\n+        String encodedToken = formParams.getFirst(PARAM_TOKEN);\n+\n+        if (encodedToken == null) {\n+            event.error(Errors.INVALID_REQUEST);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST, \"Token not provided\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+\n+        token = session.tokens().decode(encodedToken, RefreshToken.class);\n+\n+        if (token == null) {\n+            event.error(Errors.INVALID_TOKEN);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\", Response.Status.OK);\n+        }\n+\n+        if (!(TokenUtil.TOKEN_TYPE_REFRESH.equals(token.getType()) || TokenUtil.TOKEN_TYPE_OFFLINE.equals(token.getType()))) {\n+            event.error(Errors.INVALID_TOKEN_TYPE);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.UNSUPPORTED_TOKEN_TYPE, \"Unsupported token type\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkIssuedFor() {\n+        String issuedFor = token.getIssuedFor();\n+        if (issuedFor == null) {\n+            event.error(Errors.INVALID_TOKEN);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\", Response.Status.OK);\n+        }\n+\n+        if (!client.getClientId().equals(issuedFor)) {\n+            event.error(Errors.INVALID_REQUEST);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST, \"Unmatching clients\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkUser() {\n+        UserSessionModel userSession = new UserSessionCrossDCManager(session).getUserSessionWithClient(realm,\n+            token.getSessionState(), false, client.getId());\n+\n+        if (userSession == null) {\n+            userSession = new UserSessionCrossDCManager(session).getUserSessionWithClient(realm, token.getSessionState(), true,\n+                client.getId());\n+\n+            if (userSession == null) {\n+                event.error(Errors.USER_SESSION_NOT_FOUND);\n+                throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\",\n+                    Response.Status.OK);\n+            }\n+        }\n+\n+        user = userSession.getUser();\n+\n+        if (user == null) {\n+            event.error(Errors.USER_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\", Response.Status.OK);\n+        }\n+\n+        event.user(user);\n+    }\n+\n+    private void revokeClient() {\n+        session.users().revokeConsentForClient(realm, user.getId(), client.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg1ODc4Nw=="}, "originalCommit": {"oid": "e64e838b8692efc8e8334a18ace73a8b8b4d17f3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1OTAwMA==", "bodyText": "The user does not revoke tokens but clients. Another reason behind my question is that reading the specs it is not clear how consents should be handled when revoking tokens. It does talk about cleaning up data associated with the token (e.g.: session data).\nIMO, consents span multiple sessions and are not related to a single access token. Users have control over their consent so they can decide whether or not they want to revoke consent for a given client. By revoking consent when revoking tokens you are assuming the end-user also wants to revoke the consent but is that always true?\nI do see a lot of references where token revocation is more a \"logout\"  feature for clients than a revocation mechanism for consents.\nI know we are talking about OAuth2 and not OIDC. But the specs say:\n From an end-user's perspective, OAuth is often used to **log into** a\n   certain site or application.  This revocation mechanism allows a\n   client to invalidate its tokens if the end-user logs out, changes\n   identity, or uninstalls the respective application.  Notifying the\n   authorization server that the token is no longer needed allows the\n   authorization server to clean up data associated with that token\n   (e.g., **session data**) and the underlying authorization grant.\n\nThat is what I mentioned logout. Another reference is https://oauth.net/2/token-revocation/.", "url": "https://github.com/keycloak/keycloak/pull/6704#discussion_r416559000", "createdAt": "2020-04-28T12:06:56Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenRevocationEndpoint.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.protocol.oidc.endpoints;\n+\n+import java.util.List;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.managers.UserSessionCrossDCManager;\n+import org.keycloak.services.managers.UserSessionManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.util.TokenUtil;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+public class TokenRevocationEndpoint {\n+    private static final String PARAM_TOKEN = \"token\";\n+\n+    @Context\n+    private KeycloakSession session;\n+\n+    @Context\n+    private HttpRequest request;\n+\n+    @Context\n+    private HttpHeaders headers;\n+\n+    @Context\n+    private ClientConnection clientConnection;\n+\n+    private MultivaluedMap<String, String> formParams;\n+    private ClientModel client;\n+    private RealmModel realm;\n+    private EventBuilder event;\n+    private Cors cors;\n+    private RefreshToken token;\n+    private UserModel user;\n+\n+    public TokenRevocationEndpoint(RealmModel realm, EventBuilder event) {\n+        this.realm = realm;\n+        this.event = event;\n+    }\n+\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    public Response revoke() {\n+        event.event(EventType.REVOKE_GRANT);\n+\n+        cors = Cors.add(request).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+\n+        checkSsl();\n+        checkRealm();\n+        checkClient();\n+\n+        formParams = request.getDecodedFormParameters();\n+\n+        checkToken();\n+        checkIssuedFor();\n+\n+        checkUser();\n+        revokeClient();\n+\n+        event.detail(Details.REVOKED_CLIENT, client.getClientId()).success();\n+\n+        return cors.builder(Response.ok()).build();\n+    }\n+\n+    private void checkSsl() {\n+        if (!session.getContext().getUri().getBaseUri().getScheme().equals(\"https\")\n+            && realm.getSslRequired().isRequired(clientConnection)) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), OAuthErrorException.INVALID_REQUEST, \"HTTPS required\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkRealm() {\n+        if (!realm.isEnabled()) {\n+            throw new CorsErrorResponseException(cors.allowAllOrigins(), \"access_denied\", \"Realm not enabled\",\n+                Response.Status.FORBIDDEN);\n+        }\n+    }\n+\n+    private void checkClient() {\n+        AuthorizeClientUtil.ClientAuthResult clientAuth = AuthorizeClientUtil.authorizeClient(session, event);\n+        client = clientAuth.getClient();\n+\n+        event.client(client);\n+\n+        cors.allowedOrigins(session, client);\n+\n+        if (client.isBearerOnly()) {\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_CLIENT, \"Bearer-only not allowed\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkToken() {\n+        String encodedToken = formParams.getFirst(PARAM_TOKEN);\n+\n+        if (encodedToken == null) {\n+            event.error(Errors.INVALID_REQUEST);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST, \"Token not provided\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+\n+        token = session.tokens().decode(encodedToken, RefreshToken.class);\n+\n+        if (token == null) {\n+            event.error(Errors.INVALID_TOKEN);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\", Response.Status.OK);\n+        }\n+\n+        if (!(TokenUtil.TOKEN_TYPE_REFRESH.equals(token.getType()) || TokenUtil.TOKEN_TYPE_OFFLINE.equals(token.getType()))) {\n+            event.error(Errors.INVALID_TOKEN_TYPE);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.UNSUPPORTED_TOKEN_TYPE, \"Unsupported token type\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkIssuedFor() {\n+        String issuedFor = token.getIssuedFor();\n+        if (issuedFor == null) {\n+            event.error(Errors.INVALID_TOKEN);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\", Response.Status.OK);\n+        }\n+\n+        if (!client.getClientId().equals(issuedFor)) {\n+            event.error(Errors.INVALID_REQUEST);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_REQUEST, \"Unmatching clients\",\n+                Response.Status.BAD_REQUEST);\n+        }\n+    }\n+\n+    private void checkUser() {\n+        UserSessionModel userSession = new UserSessionCrossDCManager(session).getUserSessionWithClient(realm,\n+            token.getSessionState(), false, client.getId());\n+\n+        if (userSession == null) {\n+            userSession = new UserSessionCrossDCManager(session).getUserSessionWithClient(realm, token.getSessionState(), true,\n+                client.getId());\n+\n+            if (userSession == null) {\n+                event.error(Errors.USER_SESSION_NOT_FOUND);\n+                throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\",\n+                    Response.Status.OK);\n+            }\n+        }\n+\n+        user = userSession.getUser();\n+\n+        if (user == null) {\n+            event.error(Errors.USER_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_TOKEN, \"Invalid token\", Response.Status.OK);\n+        }\n+\n+        event.user(user);\n+    }\n+\n+    private void revokeClient() {\n+        session.users().revokeConsentForClient(realm, user.getId(), client.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg1ODc4Nw=="}, "originalCommit": {"oid": "e64e838b8692efc8e8334a18ace73a8b8b4d17f3"}, "originalPosition": 198}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3840, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}