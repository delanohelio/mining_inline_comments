{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5ODQwNjcw", "number": 7679, "title": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)", "bodyText": "This PR is for KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA), also is the part of the project FAPI-CIBA(poll mode) of FAPI-SIG activity.\nGenerally speaking, the aim of this PR is to support CIBA Flow defined in the design document.\nHowever, this PR does not support Financial-grade API: Client Initiated Backchannel Authentication Profile\n(FAPI-CIBA) feature. As mentioned in the 8th meeting of FAPI-SIG, I will send PRs for FAPI-CIBA features consecutively after this PR supporting pure CIBA being merged.\nThis PR is still huge so that I will add detailed comments on the commits to help the reviewer grasp them.\nThis PR has been written with the contribution by @andriimurashkin as FAPI-SIG activities..", "createdAt": "2020-12-14T22:27:55Z", "url": "https://github.com/keycloak/keycloak/pull/7679", "merged": true, "mergeCommit": {"oid": "65c48a4183505718c433b332517711396123e378"}, "closed": true, "closedAt": "2021-04-29T13:56:40Z", "author": {"login": "tnorimat"}, "timelineItems": {"totalCount": 59, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdn_4RhABqjQxMzMyMzk4Nzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeR3qOYAFqTY0ODIzODMzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0cb77af007981f965a12f4913f8e1489bb4b9f44", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/0cb77af007981f965a12f4913f8e1489bb4b9f44", "committedDate": "2020-12-14T22:09:55Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>"}, "afterCommit": {"oid": "84fe84e083f0e2e488d26a729401dc2175a9f73a", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/84fe84e083f0e2e488d26a729401dc2175a9f73a", "committedDate": "2020-12-20T11:44:37Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "84fe84e083f0e2e488d26a729401dc2175a9f73a", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/84fe84e083f0e2e488d26a729401dc2175a9f73a", "committedDate": "2020-12-20T11:44:37Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>"}, "afterCommit": {"oid": "47f206a06b177d0342baf15819e4c481b19c7ef3", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/47f206a06b177d0342baf15819e4c481b19c7ef3", "committedDate": "2020-12-23T10:08:44Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "47f206a06b177d0342baf15819e4c481b19c7ef3", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/47f206a06b177d0342baf15819e4c481b19c7ef3", "committedDate": "2020-12-23T10:08:44Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>"}, "afterCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/466333489cd8bd510d90b698b9ef7a332a666f03", "committedDate": "2020-12-27T12:24:35Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NDEwNTMz", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-577410533", "createdAt": "2021-01-27T14:45:35Z", "commit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxNDo0NTozNVrOIbLJOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxODoxNDoxNlrOIbVHog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2NTA0OA==", "bodyText": "Is migrate being used here?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565365048", "createdAt": "2021-01-27T14:45:35Z", "author": {"login": "pedroigor"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/DefaultAuthenticationFlows.java", "diffHunk": "@@ -378,6 +381,33 @@ public static void browserFlow(RealmModel realm, boolean migrate) {\n         realm.addAuthenticatorExecution(execution);\n     }\n \n+    public static void cibaFlow(RealmModel realm, boolean migrate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2ODEzOQ==", "bodyText": "I'm wondering if CIBAPolicy could also be used as a top-level field on the representation so that we don't need to set its properties back and forth from rep <-> model.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565368139", "createdAt": "2021-01-27T14:49:09Z", "author": {"login": "pedroigor"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java", "diffHunk": "@@ -394,12 +401,19 @@ public static RealmRepresentation toRepresentation(RealmModel realm, boolean int\n         rep.setWebAuthnPolicyPasswordlessAvoidSameAuthenticatorRegister(webAuthnPolicy.isAvoidSameAuthenticatorRegister());\n         rep.setWebAuthnPolicyPasswordlessAcceptableAaguids(webAuthnPolicy.getAcceptableAaguids());\n \n+        CIBAPolicy cibaPolicy = realm.getCIBAPolicy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2OTc2Nw==", "bodyText": "Maybe the flow could also be part of the CIBAPolicy (or maybe change its name to something more generic around CIBA settings).\nThe point here is to have better isolation and centralize changes in a single place as much as possible.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565369767", "createdAt": "2021-01-27T14:51:14Z", "author": {"login": "pedroigor"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java", "diffHunk": "@@ -394,12 +401,19 @@ public static RealmRepresentation toRepresentation(RealmModel realm, boolean int\n         rep.setWebAuthnPolicyPasswordlessAvoidSameAuthenticatorRegister(webAuthnPolicy.isAvoidSameAuthenticatorRegister());\n         rep.setWebAuthnPolicyPasswordlessAcceptableAaguids(webAuthnPolicy.getAcceptableAaguids());\n \n+        CIBAPolicy cibaPolicy = realm.getCIBAPolicy();\n+        rep.setCibaBackchannelTokenDeliveryMode(cibaPolicy.getBackchannelTokenDeliveryMode());\n+        rep.setCibaExpiresIn(cibaPolicy.getExpiresIn());\n+        rep.setCibaInterval(cibaPolicy.getInterval());\n+        rep.setCibaAuthRequestedUserHint(cibaPolicy.getAuthRequestedUserHint());\n+\n         if (realm.getBrowserFlow() != null) rep.setBrowserFlow(realm.getBrowserFlow().getAlias());\n         if (realm.getRegistrationFlow() != null) rep.setRegistrationFlow(realm.getRegistrationFlow().getAlias());\n         if (realm.getDirectGrantFlow() != null) rep.setDirectGrantFlow(realm.getDirectGrantFlow().getAlias());\n         if (realm.getResetCredentialsFlow() != null) rep.setResetCredentialsFlow(realm.getResetCredentialsFlow().getAlias());\n         if (realm.getClientAuthenticationFlow() != null) rep.setClientAuthenticationFlow(realm.getClientAuthenticationFlow().getAlias());\n         if (realm.getDockerAuthenticationFlow() != null) rep.setDockerAuthenticationFlow(realm.getDockerAuthenticationFlow().getAlias());\n+        if (realm.getCIBAFlow() != null) rep.setCibaFlow(realm.getCIBAFlow().getAlias());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUwMzc3Mg==", "bodyText": "Why do you need to validate/convert to UUID? Isn't expected that this string will always be a uuid?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565503772", "createdAt": "2021-01-27T17:38:27Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/utils/EarlyAccessBlockerParser.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.utils;\n+\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.ciba.EarlyAccessBlockerStore;\n+\n+public class EarlyAccessBlockerParser {\n+\n+    private static final Logger logger = Logger.getLogger(EarlyAccessBlockerParser.class);\n+\n+    public static void persistEarlyAccessBlocker(KeycloakSession session, String id, EarlyAccessBlocker earlyAccessBlockerData, int expires_in) {\n+        if (id == null) {\n+            throw new IllegalStateException(\"ID not present in the data\");\n+        }\n+        UUID key = UUID.fromString(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxMjI2MA==", "bodyText": "You probably want to validate if decoupledAuthnRequestUri was provided otherwise you will have errors when issuing the CIBAAuthReqId to do channel you choose to authenticate the user.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565512260", "createdAt": "2021-01-27T17:50:29Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProviderFactory.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+\n+public class DelegateDecoupledAuthenticationProviderFactory implements DecoupledAuthenticationProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"delegate-decoupled-authn\";\n+\n+    private String decoupledAuthenticationRequestUri;\n+\n+    @Override\n+    public DecoupledAuthenticationProvider create(KeycloakSession session) {\n+        return new DelegateDecoupledAuthenticationProvider(session, decoupledAuthenticationRequestUri);\n+    }\n+\n+    @Override\n+    public void init(Scope config) {\n+        decoupledAuthenticationRequestUri = config.get(\"decoupledAuthnRequestUri\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxMzkyNw==", "bodyText": "Maybe we can change this class to HTTPAuthenticationProvider?\nOr maybe, introduce the concept of an authentication channel and have HttpAuthenticationChannel.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565513927", "createdAt": "2021-01-27T17:52:55Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class DelegateDecoupledAuthenticationProvider extends DecoupledAuthenticationProviderBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxODU2Ng==", "bodyText": "I think it makes more sense to have the concept of authentication channel. Here we would rename the provider to AuthenticationChannelProvider, AuthenticationChannelProviderFactory, and AuthenticationChannelSPI.\nThe method could be just requestAuthentication. Or something more meaningful to indicate that we are actually requesting the choosed authentication channel to authenticate/authorize a user request.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565518566", "createdAt": "2021-01-27T17:59:14Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.provider.Provider;\n+\n+/**\n+ * Provides the interface for requesting the authentication(AuthN) and authorization(AuthZ) by an authentication device (AD) to the external entity called Decoupled Authentication Server.\n+ * This interface is for Client Initiated Backchannel Authentication(CIBA).\n+ *\n+ */\n+public interface DecoupledAuthenticationProvider extends Provider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUyNjU3Mg==", "bodyText": "In case you have a status other than 200, such as 404, 500, or any other that indicates that the chosen channel did not receive the authentication request, shouldn't we fail?\nAlso, the contract is not clear to me in regards to the expected response from the channel. Wouldn't be better to enforce a specific status code? Probably 201 (created) ?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565526572", "createdAt": "2021-01-27T18:11:17Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class DelegateDecoupledAuthenticationProvider extends DecoupledAuthenticationProviderBase {\n+\n+    private static final Logger logger = Logger.getLogger(DelegateDecoupledAuthenticationProvider.class);\n+\n+    private final String decoupledAuthenticationRequestUri;\n+\n+    public DelegateDecoupledAuthenticationProvider(KeycloakSession session, String decoupledAuthenticationRequestUri) {\n+        super(session);\n+        this.decoupledAuthenticationRequestUri = decoupledAuthenticationRequestUri;\n+    }\n+\n+    private String scope;\n+    private String userSessionIdWillBeCreated;\n+    private String userIdToBeAuthenticated;\n+    private String authResultId;\n+    private int expiration;\n+\n+    @Override\n+    protected String getScope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    protected String getUserSessionIdWillBeCreated() {\n+        return userSessionIdWillBeCreated;\n+    }\n+\n+    @Override\n+    protected String getUserIdToBeAuthenticated() {\n+        return userIdToBeAuthenticated;\n+    }\n+\n+    @Override\n+    protected String getAuthResultId() {\n+        return authResultId;\n+    }\n+\n+    @Override\n+    protected int getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    protected Response verifyDecoupledAuthnResult() {\n+        String decoupledAuthId = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_ID);\n+        ParseResult parseResult = parseDecoupledAuthId(session, decoupledAuthId, event);\n+\n+        if (parseResult.isIllegalDecoupledAuthId()) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            // decoupled auth id format is invalid or it has already been used\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"invalid decoupled authn id\", Response.Status.BAD_REQUEST);\n+        } else if (parseResult.isExpiredDecoupledAuthId()) {\n+            event.error(Errors.SESSION_EXPIRED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.EXPIRED);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = parseResult.decoupledAuthIdJwt();\n+        authResultId = decoupledAuthIdJwt.getAuthResultId();\n+        scope = decoupledAuthIdJwt.getScope();\n+        expiration = decoupledAuthIdJwt.getExp().intValue();\n+        userSessionIdWillBeCreated = decoupledAuthIdJwt.getSessionState();\n+        userIdToBeAuthenticated = decoupledAuthIdJwt.getSubject();\n+        // to bind Client Session of CD(Consumption Device) with User Session, set CD's Client Model to this class member \"client\".\n+        client = realm.getClientByClientId(decoupledAuthIdJwt.getIssuedFor());\n+\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String userIdAuthenticated = resolver.getUserFromInfoUsedByAuthentication(formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_USER_INFO)).getId();\n+        if (!userIdToBeAuthenticated.equals(userIdAuthenticated)) {\n+            event.error(Errors.DIFFERENT_USER_AUTHENTICATED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.DIFFERENT);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        String authResult = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_RESULT);\n+        if (authResult == null) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"authentication result not specified\", Response.Status.BAD_REQUEST);\n+        } else if (authResult.equals(DecoupledAuthStatus.FAILED)) {\n+            event.error(Errors.NOT_LOGGED_IN);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.FAILED);\n+        } else if (authResult.equals(DecoupledAuthStatus.CANCELLED)) {\n+            event.error(Errors.NOT_ALLOWED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.CANCELLED);\n+        } else if (authResult.equals(DecoupledAuthStatus.UNAUTHORIZED)) {\n+            event.error(Errors.CONSENT_DENIED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNAUTHORIZED);\n+        } else if (authResult.equals(DecoupledAuthStatus.SUCCEEDED)) {\n+            return null;\n+        } else {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+        }\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    @Override\n+    public void doBackchannelAuthentication(ClientModel client, BackchannelAuthenticationRequest request, int expiresIn, String authResultId, String userSessionIdWillBeCreated) {\n+        // create JWT formatted/JWS signed/JWE encrypted Decoupled Auth ID by the same manner in creating auth_req_id\n+        // Decoupled Auth ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).\n+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Decoupled Authentication Callback Endpoint,\n+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.\n+        // By including authResultId, keycloak can create Decoupled Authentication Result of Authentication by AD on Decoupled Authentication Callback Endpoint,\n+        // which can bind authResultId with Decoupled Authentication Result of Authentication by AD.\n+        // By including client_id, Decoupled Authentication Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.\n+\n+        // The following scopes should be displayed on AD(Authentication Device):\n+        // 1. scopes specified explicitly as query parameter in the authorization request\n+        // 2. scopes specified implicitly as default client scope in keycloak\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String authRequestedUserHint = realm.getCIBAPolicy().getAuthRequestedUserHint();\n+        UserModel user = null;\n+        if (authRequestedUserHint.equals(CIBAConstants.LOGIN_HINT)) {\n+            user = resolver.getUserFromLoginHint(request.getLoginHint());\n+        } else if (authRequestedUserHint.equals(CIBAConstants.ID_TOKEN_HINT)) {\n+            user = resolver.getUserFromLoginHint(request.getIdTokenHint());\n+        } else if (authRequestedUserHint.equals(CIBAConstants.LOGIN_HINT_TOKEN)) {\n+            user = resolver.getUserFromLoginHint(request.getLoginHintToken());\n+        } else {\n+            throw new RuntimeException(\"CIBA invalid Authentication Requested User Hint.\");\n+        }\n+        String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);\n+\n+        StringBuilder scopeBuilder = new StringBuilder();\n+        Map<String, ClientScopeModel> defaultScopesMap = client.getClientScopes(true, true);\n+        defaultScopesMap.forEach((key, value)->{if (value.isDisplayOnConsentScreen()) scopeBuilder.append(value.getName()).append(\" \");});\n+        String defaultClientScope = scopeBuilder.toString();\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = new CIBAAuthReqId();\n+        decoupledAuthIdJwt.id(KeycloakModelUtils.generateId());\n+        decoupledAuthIdJwt.setScope(request.getScope());\n+        decoupledAuthIdJwt.setSessionState(userSessionIdWillBeCreated);\n+        decoupledAuthIdJwt.setAuthResultId(authResultId);\n+        decoupledAuthIdJwt.issuedNow();\n+        decoupledAuthIdJwt.issuer(Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        decoupledAuthIdJwt.audience(decoupledAuthIdJwt.getIssuer());\n+        decoupledAuthIdJwt.subject(user.getId());\n+        decoupledAuthIdJwt.exp(Long.valueOf(Time.currentTime() + expiresIn));\n+        //decoupledAuthIdJwt.issuedFor(Decoupled Auth Server's client_id); TODO\n+        decoupledAuthIdJwt.issuedFor(client.getClientId()); // TODO : set CD's client_id intentionally, not Decoupled Auth Server. It is not good idea so that client_id field should be added.\n+        String decoupledAuthId = CIBAAuthReqIdParser.persistAuthReqId(session, decoupledAuthIdJwt);\n+\n+        logger.info(\"  decoupledAuthnRequestUri = \" + decoupledAuthenticationRequestUri);\n+        try {\n+            int status = SimpleHttp.doPost(decoupledAuthenticationRequestUri, session)\n+                .param(DECOUPLED_AUTHN_ID, decoupledAuthId)\n+                .param(DECOUPLED_AUTHN_USER_INFO, infoUsedByAuthentication)\n+                .param(DECOUPLED_AUTHN_IS_CONSENT_REQUIRED, Boolean.toString(client.isConsentRequired()))\n+                .param(CIBAConstants.SCOPE, request.getScope())\n+                .param(DECOUPLED_DEFAULT_CLIENT_SCOPE, defaultClientScope)\n+                .param(CIBAConstants.BINDING_MESSAGE, request.getBindingMessage())\n+                .asStatus();\n+            logger.info(\"  Decoupled Authn Request URI Access = \" + status);\n+            if (status != 200) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUyODQ4Mg==", "bodyText": "I agree it is not a good idea.\nIMO, having the authentication channel as a client in Keycloak is probably the best way to go. We could potentially use different authentication methods when sending requests to the service too.\nWe could even send signed/encrypted requests.\nThe way it is right now is not much secure, from the service perspective.\nOne more reason, I think, to make have a HttpAuthenticationChannel so that we can use different forms of HTTP Authentication/Authorization, even if only BASIC.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565528482", "createdAt": "2021-01-27T18:14:16Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class DelegateDecoupledAuthenticationProvider extends DecoupledAuthenticationProviderBase {\n+\n+    private static final Logger logger = Logger.getLogger(DelegateDecoupledAuthenticationProvider.class);\n+\n+    private final String decoupledAuthenticationRequestUri;\n+\n+    public DelegateDecoupledAuthenticationProvider(KeycloakSession session, String decoupledAuthenticationRequestUri) {\n+        super(session);\n+        this.decoupledAuthenticationRequestUri = decoupledAuthenticationRequestUri;\n+    }\n+\n+    private String scope;\n+    private String userSessionIdWillBeCreated;\n+    private String userIdToBeAuthenticated;\n+    private String authResultId;\n+    private int expiration;\n+\n+    @Override\n+    protected String getScope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    protected String getUserSessionIdWillBeCreated() {\n+        return userSessionIdWillBeCreated;\n+    }\n+\n+    @Override\n+    protected String getUserIdToBeAuthenticated() {\n+        return userIdToBeAuthenticated;\n+    }\n+\n+    @Override\n+    protected String getAuthResultId() {\n+        return authResultId;\n+    }\n+\n+    @Override\n+    protected int getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    protected Response verifyDecoupledAuthnResult() {\n+        String decoupledAuthId = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_ID);\n+        ParseResult parseResult = parseDecoupledAuthId(session, decoupledAuthId, event);\n+\n+        if (parseResult.isIllegalDecoupledAuthId()) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            // decoupled auth id format is invalid or it has already been used\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"invalid decoupled authn id\", Response.Status.BAD_REQUEST);\n+        } else if (parseResult.isExpiredDecoupledAuthId()) {\n+            event.error(Errors.SESSION_EXPIRED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.EXPIRED);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = parseResult.decoupledAuthIdJwt();\n+        authResultId = decoupledAuthIdJwt.getAuthResultId();\n+        scope = decoupledAuthIdJwt.getScope();\n+        expiration = decoupledAuthIdJwt.getExp().intValue();\n+        userSessionIdWillBeCreated = decoupledAuthIdJwt.getSessionState();\n+        userIdToBeAuthenticated = decoupledAuthIdJwt.getSubject();\n+        // to bind Client Session of CD(Consumption Device) with User Session, set CD's Client Model to this class member \"client\".\n+        client = realm.getClientByClientId(decoupledAuthIdJwt.getIssuedFor());\n+\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String userIdAuthenticated = resolver.getUserFromInfoUsedByAuthentication(formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_USER_INFO)).getId();\n+        if (!userIdToBeAuthenticated.equals(userIdAuthenticated)) {\n+            event.error(Errors.DIFFERENT_USER_AUTHENTICATED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.DIFFERENT);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        String authResult = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_RESULT);\n+        if (authResult == null) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"authentication result not specified\", Response.Status.BAD_REQUEST);\n+        } else if (authResult.equals(DecoupledAuthStatus.FAILED)) {\n+            event.error(Errors.NOT_LOGGED_IN);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.FAILED);\n+        } else if (authResult.equals(DecoupledAuthStatus.CANCELLED)) {\n+            event.error(Errors.NOT_ALLOWED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.CANCELLED);\n+        } else if (authResult.equals(DecoupledAuthStatus.UNAUTHORIZED)) {\n+            event.error(Errors.CONSENT_DENIED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNAUTHORIZED);\n+        } else if (authResult.equals(DecoupledAuthStatus.SUCCEEDED)) {\n+            return null;\n+        } else {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+        }\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    @Override\n+    public void doBackchannelAuthentication(ClientModel client, BackchannelAuthenticationRequest request, int expiresIn, String authResultId, String userSessionIdWillBeCreated) {\n+        // create JWT formatted/JWS signed/JWE encrypted Decoupled Auth ID by the same manner in creating auth_req_id\n+        // Decoupled Auth ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).\n+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Decoupled Authentication Callback Endpoint,\n+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.\n+        // By including authResultId, keycloak can create Decoupled Authentication Result of Authentication by AD on Decoupled Authentication Callback Endpoint,\n+        // which can bind authResultId with Decoupled Authentication Result of Authentication by AD.\n+        // By including client_id, Decoupled Authentication Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.\n+\n+        // The following scopes should be displayed on AD(Authentication Device):\n+        // 1. scopes specified explicitly as query parameter in the authorization request\n+        // 2. scopes specified implicitly as default client scope in keycloak\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String authRequestedUserHint = realm.getCIBAPolicy().getAuthRequestedUserHint();\n+        UserModel user = null;\n+        if (authRequestedUserHint.equals(CIBAConstants.LOGIN_HINT)) {\n+            user = resolver.getUserFromLoginHint(request.getLoginHint());\n+        } else if (authRequestedUserHint.equals(CIBAConstants.ID_TOKEN_HINT)) {\n+            user = resolver.getUserFromLoginHint(request.getIdTokenHint());\n+        } else if (authRequestedUserHint.equals(CIBAConstants.LOGIN_HINT_TOKEN)) {\n+            user = resolver.getUserFromLoginHint(request.getLoginHintToken());\n+        } else {\n+            throw new RuntimeException(\"CIBA invalid Authentication Requested User Hint.\");\n+        }\n+        String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);\n+\n+        StringBuilder scopeBuilder = new StringBuilder();\n+        Map<String, ClientScopeModel> defaultScopesMap = client.getClientScopes(true, true);\n+        defaultScopesMap.forEach((key, value)->{if (value.isDisplayOnConsentScreen()) scopeBuilder.append(value.getName()).append(\" \");});\n+        String defaultClientScope = scopeBuilder.toString();\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = new CIBAAuthReqId();\n+        decoupledAuthIdJwt.id(KeycloakModelUtils.generateId());\n+        decoupledAuthIdJwt.setScope(request.getScope());\n+        decoupledAuthIdJwt.setSessionState(userSessionIdWillBeCreated);\n+        decoupledAuthIdJwt.setAuthResultId(authResultId);\n+        decoupledAuthIdJwt.issuedNow();\n+        decoupledAuthIdJwt.issuer(Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        decoupledAuthIdJwt.audience(decoupledAuthIdJwt.getIssuer());\n+        decoupledAuthIdJwt.subject(user.getId());\n+        decoupledAuthIdJwt.exp(Long.valueOf(Time.currentTime() + expiresIn));\n+        //decoupledAuthIdJwt.issuedFor(Decoupled Auth Server's client_id); TODO\n+        decoupledAuthIdJwt.issuedFor(client.getClientId()); // TODO : set CD's client_id intentionally, not Decoupled Auth Server. It is not good idea so that client_id field should be added.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 195}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3Njg1Nzk0", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-577685794", "createdAt": "2021-01-27T19:28:25Z", "commit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxOToyODoyNVrOIbYCXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDoyMTozMFrOIbZ9AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU3NjI4Ng==", "bodyText": "Shall we validate the inputs and avoid unexpected errors ? What happens if the form parameter is null ? I guess we want to return 400 ?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565576286", "createdAt": "2021-01-27T19:28:25Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class DelegateDecoupledAuthenticationProvider extends DecoupledAuthenticationProviderBase {\n+\n+    private static final Logger logger = Logger.getLogger(DelegateDecoupledAuthenticationProvider.class);\n+\n+    private final String decoupledAuthenticationRequestUri;\n+\n+    public DelegateDecoupledAuthenticationProvider(KeycloakSession session, String decoupledAuthenticationRequestUri) {\n+        super(session);\n+        this.decoupledAuthenticationRequestUri = decoupledAuthenticationRequestUri;\n+    }\n+\n+    private String scope;\n+    private String userSessionIdWillBeCreated;\n+    private String userIdToBeAuthenticated;\n+    private String authResultId;\n+    private int expiration;\n+\n+    @Override\n+    protected String getScope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    protected String getUserSessionIdWillBeCreated() {\n+        return userSessionIdWillBeCreated;\n+    }\n+\n+    @Override\n+    protected String getUserIdToBeAuthenticated() {\n+        return userIdToBeAuthenticated;\n+    }\n+\n+    @Override\n+    protected String getAuthResultId() {\n+        return authResultId;\n+    }\n+\n+    @Override\n+    protected int getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    protected Response verifyDecoupledAuthnResult() {\n+        String decoupledAuthId = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_ID);\n+        ParseResult parseResult = parseDecoupledAuthId(session, decoupledAuthId, event);\n+\n+        if (parseResult.isIllegalDecoupledAuthId()) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            // decoupled auth id format is invalid or it has already been used\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"invalid decoupled authn id\", Response.Status.BAD_REQUEST);\n+        } else if (parseResult.isExpiredDecoupledAuthId()) {\n+            event.error(Errors.SESSION_EXPIRED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.EXPIRED);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = parseResult.decoupledAuthIdJwt();\n+        authResultId = decoupledAuthIdJwt.getAuthResultId();\n+        scope = decoupledAuthIdJwt.getScope();\n+        expiration = decoupledAuthIdJwt.getExp().intValue();\n+        userSessionIdWillBeCreated = decoupledAuthIdJwt.getSessionState();\n+        userIdToBeAuthenticated = decoupledAuthIdJwt.getSubject();\n+        // to bind Client Session of CD(Consumption Device) with User Session, set CD's Client Model to this class member \"client\".\n+        client = realm.getClientByClientId(decoupledAuthIdJwt.getIssuedFor());\n+\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String userIdAuthenticated = resolver.getUserFromInfoUsedByAuthentication(formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_USER_INFO)).getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU4ODcyNA==", "bodyText": "We should probably check whether username is null to avoid NPE.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565588724", "createdAt": "2021-01-27T19:48:37Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/authentication/authenticators/ciba/CIBADecoupledAuthenticator.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.authentication.authenticators.ciba;\n+\n+import org.jboss.logging.Logger;\n+\n+import org.keycloak.authentication.AuthenticationFlowContext;\n+import org.keycloak.authentication.AuthenticationFlowError;\n+import org.keycloak.authentication.Authenticator;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+\n+public class CIBADecoupledAuthenticator implements Authenticator {\n+\n+    private static final Logger logger = Logger.getLogger(CIBADecoupledAuthenticator.class);\n+\n+    @Override\n+    public void authenticate(AuthenticationFlowContext context) {\n+        String userIdField = context.getAuthenticatorConfig().getConfig().get(CIBADecoupledAuthenticatorFactory.DEFAULT_USERID_FIELD);\n+        if (userIdField == null) userIdField = CIBAConstants.LOGIN_HINT;\n+        String username = context.getHttpRequest().getDecodedFormParameters().getFirst(userIdField);\n+\n+        logger.info(\"username = \" + username);\n+        UserModel user = KeycloakModelUtils.findUserByNameOrEmail(context.getSession(), context.getRealm(), username);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU5MjM1OQ==", "bodyText": "Missing i18n for ciba-flow and tooltip.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565592359", "createdAt": "2021-01-27T19:54:55Z", "author": {"login": "pedroigor"}, "path": "themes/src/main/resources/theme/base/admin/resources/partials/authentication-flow-bindings.html", "diffHunk": "@@ -69,6 +69,17 @@ <h1>{{:: 'authentication' | translate}}</h1>\n             <kc-tooltip>{{:: 'docker-auth.tooltip' | translate}}</kc-tooltip>\n         </div>\n \n+        <div class=\"form-group\">\n+            <label for=\"ciba\" class=\"col-md-2 control-label\">{{:: 'ciba-flow' | translate}}</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwNzY4MA==", "bodyText": "I think expires_in is in milliseconds and the provider is going to set expiration based on seconds. That would cause entries to take a lot of time to expire, and not really what you are expected.\nSee \n  \n    \n      keycloak/model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanCodeToTokenStoreProvider.java\n    \n    \n         Line 54\n      in\n      80f4bd3\n    \n    \n    \n    \n\n        \n          \n           cache.put(codeId, tokenValue, lifespanSeconds, TimeUnit.SECONDS); \n        \n    \n  \n\n.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565607680", "createdAt": "2021-01-27T20:21:30Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/utils/DecoupledAuthnResultParser.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.utils;\n+\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.models.CodeToTokenStoreProvider;\n+import org.keycloak.models.KeycloakSession;\n+\n+public class DecoupledAuthnResultParser {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthnResultParser.class);\n+\n+    public static void persistDecoupledAuthnResult(KeycloakSession session, String id, DecoupledAuthnResult decoupledAuthnResultData, int expires_in) {\n+        CodeToTokenStoreProvider codeStore = session.getProvider(CodeToTokenStoreProvider.class);\n+\n+        if (id == null) {\n+            throw new IllegalStateException(\"ID not present in the data\");\n+        }\n+        UUID key = UUID.fromString(id);\n+\n+        Map<String, String> serialized = decoupledAuthnResultData.serializeCode();\n+        codeStore.put(key, expires_in, serialized);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NzMzMTY2", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-577733166", "createdAt": "2021-01-27T20:32:00Z", "commit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDozMjowMFrOIbaUpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QyMDozMjowMFrOIbaUpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYxMzczNQ==", "bodyText": "Maybe a LinkedHashMap makes sense here so we could bound the map to size and avoid memory leaks.\nIt should also be possible to remove the eldest entry more easily. Instead of iterating over entries (mainly if it is expected a potential growth in entries).", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565613735", "createdAt": "2021-01-27T20:32:00Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/EarlyAccessBlockerStore.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba;\n+\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.keycloak.common.util.Time;\n+import org.keycloak.protocol.ciba.utils.EarlyAccessBlocker;\n+\n+public class EarlyAccessBlockerStore {\n+\n+    private final static ConcurrentMap<UUID, EarlyAccessBlockerValueEntity> blockerCache = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg5OTc5NzYx", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-589979761", "createdAt": "2021-02-13T16:51:19Z", "commit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xM1QxNjo1MToxOVrOIlBK-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xM1QxODowMzoxOFrOIlBpuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzQxNg==", "bodyText": "Here, NumberFormatException will happen if expiresIn is empty string \"\". Suggest to create some utility method\nstatic bool isNotBlank(String str) {\n    return str != null && !str.isEmpty();\n}\n\nand use it instead expiresIn != null", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575687416", "createdAt": "2021-02-13T16:51:19Z", "author": {"login": "valb3r"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1061,6 +1061,46 @@ private void setWebAuthnPolicy(WebAuthnPolicy policy, String attributePrefix) {\n         }\n     }\n \n+    @Override\n+    public CIBAPolicy getCIBAPolicy() {\n+        CIBAPolicy policy = new CIBAPolicy();\n+\n+        String backchannelTokenDeliveryMode = getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE);\n+        if (backchannelTokenDeliveryMode == null || backchannelTokenDeliveryMode.isEmpty())\n+            backchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n+        policy.setBackchannelTokenDeliveryMode(backchannelTokenDeliveryMode);\n+\n+        String expiresIn = getAttribute(RealmAttributes.CIBA_EXPIRES_IN);\n+        if (expiresIn != null) policy.setExpiresIn(Integer.parseInt(expiresIn));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzQ1NQ==", "bodyText": "Here, NumberFormatException will happen if interval is empty string \"\". Suggest to create some utility method\nstatic bool isNotBlank(String str) {\n    return str != null && !str.isEmpty();\n}\n\nand use it instead interval != null", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575687455", "createdAt": "2021-02-13T16:51:41Z", "author": {"login": "valb3r"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1061,6 +1061,46 @@ private void setWebAuthnPolicy(WebAuthnPolicy policy, String attributePrefix) {\n         }\n     }\n \n+    @Override\n+    public CIBAPolicy getCIBAPolicy() {\n+        CIBAPolicy policy = new CIBAPolicy();\n+\n+        String backchannelTokenDeliveryMode = getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE);\n+        if (backchannelTokenDeliveryMode == null || backchannelTokenDeliveryMode.isEmpty())\n+            backchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n+        policy.setBackchannelTokenDeliveryMode(backchannelTokenDeliveryMode);\n+\n+        String expiresIn = getAttribute(RealmAttributes.CIBA_EXPIRES_IN);\n+        if (expiresIn != null) policy.setExpiresIn(Integer.parseInt(expiresIn));\n+        else policy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n+\n+        String interval = getAttribute(RealmAttributes.CIBA_INTERVAL);\n+        if (interval != null) policy.setInterval(Integer.parseInt(interval));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzU2NQ==", "bodyText": "Suggest to use create and use isBlank utility method instead of authRequestedUserHint == null || authRequestedUserHint.isEmpty() as the same check is done at\nhttps://github.com/keycloak/keycloak/pull/7679/files#diff-170c22cf3ea1d9f1e8150ebd8220d3dfdc27d411c26e005bd4b45d3e7e716e03R1069", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575687565", "createdAt": "2021-02-13T16:53:09Z", "author": {"login": "valb3r"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1061,6 +1061,46 @@ private void setWebAuthnPolicy(WebAuthnPolicy policy, String attributePrefix) {\n         }\n     }\n \n+    @Override\n+    public CIBAPolicy getCIBAPolicy() {\n+        CIBAPolicy policy = new CIBAPolicy();\n+\n+        String backchannelTokenDeliveryMode = getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE);\n+        if (backchannelTokenDeliveryMode == null || backchannelTokenDeliveryMode.isEmpty())\n+            backchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n+        policy.setBackchannelTokenDeliveryMode(backchannelTokenDeliveryMode);\n+\n+        String expiresIn = getAttribute(RealmAttributes.CIBA_EXPIRES_IN);\n+        if (expiresIn != null) policy.setExpiresIn(Integer.parseInt(expiresIn));\n+        else policy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n+\n+        String interval = getAttribute(RealmAttributes.CIBA_INTERVAL);\n+        if (interval != null) policy.setInterval(Integer.parseInt(interval));\n+        else policy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);\n+\n+        String authRequestedUserHint = getAttribute(RealmAttributes.CIBA_AUTH_REQUESTED_USER_HINT);\n+        if (authRequestedUserHint == null || authRequestedUserHint.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzY4NA==", "bodyText": "Suggest to create isBlank utility method for this check", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575687684", "createdAt": "2021-02-13T16:54:15Z", "author": {"login": "valb3r"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1061,6 +1061,46 @@ private void setWebAuthnPolicy(WebAuthnPolicy policy, String attributePrefix) {\n         }\n     }\n \n+    @Override\n+    public CIBAPolicy getCIBAPolicy() {\n+        CIBAPolicy policy = new CIBAPolicy();\n+\n+        String backchannelTokenDeliveryMode = getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE);\n+        if (backchannelTokenDeliveryMode == null || backchannelTokenDeliveryMode.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MDE0Mg==", "bodyText": "Suggest to create isBlank utility method and use it here to check if String is empty", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575690142", "createdAt": "2021-02-13T17:16:38Z", "author": {"login": "valb3r"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -285,6 +286,28 @@ public static void importRealm(KeycloakSession session, RealmRepresentation rep,\n         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);\n         newRealm.setWebAuthnPolicyPasswordless(webAuthnPolicy);\n \n+        CIBAPolicy cibaPolicy = new CIBAPolicy();\n+\n+        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n+        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MDE0Nw==", "bodyText": "Suggest to create isBlank utility method and use it here to check if String is empty", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575690147", "createdAt": "2021-02-13T17:16:48Z", "author": {"login": "valb3r"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -285,6 +286,28 @@ public static void importRealm(KeycloakSession session, RealmRepresentation rep,\n         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);\n         newRealm.setWebAuthnPolicyPasswordless(webAuthnPolicy);\n \n+        CIBAPolicy cibaPolicy = new CIBAPolicy();\n+\n+        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n+        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())\n+            cibaBackchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n+        cibaPolicy.setBackchannelTokenDeliveryMode(cibaBackchannelTokenDeliveryMode);\n+\n+        Integer cibaExpiresIn = rep.getCibaExpiresIn();\n+        if (cibaExpiresIn != null) cibaPolicy.setExpiresIn(cibaExpiresIn);\n+        else cibaPolicy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n+\n+        Integer cibaInterval = rep.getCibaInterval();\n+        if (cibaInterval != null) cibaPolicy.setInterval(cibaInterval);\n+        else cibaPolicy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);\n+\n+        String cibaAuthRequestedUserHint = rep.getCibaAuthRequestedUserHint();\n+        if (cibaAuthRequestedUserHint == null || cibaAuthRequestedUserHint.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTAwNg==", "bodyText": "The body of the current method is already huge. Can we simply create private static method\n    private static void handleCibaFlowIfApplicable(RealmModel newRealm, RealmRepresentation rep) {\n        if (rep.getCibaFlow() == null) {\n            AuthenticationFlowModel cibaFlowModel = newRealm.getFlowByAlias(DefaultAuthenticationFlows.CIBA_FLOW);\n            if (cibaFlowModel != null) {\n                newRealm.setCIBAFlow(cibaFlowModel);\n            } else {\n                DefaultAuthenticationFlows.cibaFlow(newRealm, true);\n            }\n        } else {\n            newRealm.setCIBAFlow(newRealm.getFlowByAlias(rep.getCibaFlow()));\n        }\n    }\n\nand do simply handleCibaFlowIfApplicable(newRealm, rep); instead of this  if", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575691006", "createdAt": "2021-02-13T17:24:24Z", "author": {"login": "valb3r"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -766,6 +789,16 @@ public static void importGroup(RealmModel realm, GroupModel parent, GroupReprese\n         } else {\n             newRealm.setDirectGrantFlow(newRealm.getFlowByAlias(rep.getDirectGrantFlow()));\n         }\n+        if (rep.getCibaFlow() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTA5MA==", "bodyText": "Suggest to create isBlank utility method and use it here to check if String is empty", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575691090", "createdAt": "2021-02-13T17:25:21Z", "author": {"login": "valb3r"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -1140,6 +1173,28 @@ public static void updateRealm(RealmRepresentation rep, RealmModel realm, Keyclo\n         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);\n         realm.setWebAuthnPolicyPasswordless(webAuthnPolicy);\n \n+        CIBAPolicy cibaPolicy = new CIBAPolicy();\n+\n+        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n+        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTExNg==", "bodyText": "Suggest to create isBlank utility method and use it here to check if String is empty", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575691116", "createdAt": "2021-02-13T17:25:36Z", "author": {"login": "valb3r"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -1140,6 +1173,28 @@ public static void updateRealm(RealmRepresentation rep, RealmModel realm, Keyclo\n         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);\n         realm.setWebAuthnPolicyPasswordless(webAuthnPolicy);\n \n+        CIBAPolicy cibaPolicy = new CIBAPolicy();\n+\n+        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n+        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())\n+            cibaBackchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n+        cibaPolicy.setBackchannelTokenDeliveryMode(cibaBackchannelTokenDeliveryMode);\n+\n+        Integer cibaExpiresIn = rep.getCibaExpiresIn();\n+        if (cibaExpiresIn != null) cibaPolicy.setExpiresIn(cibaExpiresIn);\n+        else cibaPolicy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n+\n+        Integer cibaInterval = rep.getCibaInterval();\n+        if (cibaInterval != null) cibaPolicy.setInterval(cibaInterval);\n+        else cibaPolicy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);\n+\n+        String cibaAuthRequestedUserHint = rep.getCibaAuthRequestedUserHint();\n+        if (cibaAuthRequestedUserHint == null || cibaAuthRequestedUserHint.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTgxMw==", "bodyText": "The lines\nCIBAPolicy cibaPolicy = new CIBAPolicy();\n\n        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())\n            cibaBackchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n        cibaPolicy.setBackchannelTokenDeliveryMode(cibaBackchannelTokenDeliveryMode);\n\n        Integer cibaExpiresIn = rep.getCibaExpiresIn();\n        if (cibaExpiresIn != null) cibaPolicy.setExpiresIn(cibaExpiresIn);\n        else cibaPolicy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n\n        Integer cibaInterval = rep.getCibaInterval();\n        if (cibaInterval != null) cibaPolicy.setInterval(cibaInterval);\n        else cibaPolicy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);\n\n        String cibaAuthRequestedUserHint = rep.getCibaAuthRequestedUserHint();\n        if (cibaAuthRequestedUserHint == null || cibaAuthRequestedUserHint.isEmpty())\n            cibaAuthRequestedUserHint = Constants.DEFAULT_CIBA_POLICY_AUTH_REQUESTED_USER_HINT;\n        cibaPolicy.setAuthRequestedUserHint(cibaAuthRequestedUserHint);\n\n        newRealm.setCIBAPolicy(cibaPolicy);\n\nseem to be duplicated at\nhttps://github.com/keycloak/keycloak/pull/7679/files#diff-bf084091e13d0b998262192910037c7cd2e5640fcd846da15299f1bdef7230c9R1176\nCan't we extract the following static private method:\n    private static void applyCibaPolicyToRealm(RealmRepresentation rep, RealmModel realm) {\n        CIBAPolicy cibaPolicy = new CIBAPolicy();\n\n        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())\n            cibaBackchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n        cibaPolicy.setBackchannelTokenDeliveryMode(cibaBackchannelTokenDeliveryMode);\n\n        Integer cibaExpiresIn = rep.getCibaExpiresIn();\n        if (cibaExpiresIn != null) cibaPolicy.setExpiresIn(cibaExpiresIn);\n        else cibaPolicy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n\n        Integer cibaInterval = rep.getCibaInterval();\n        if (cibaInterval != null) cibaPolicy.setInterval(cibaInterval);\n        else cibaPolicy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);\n\n        String cibaAuthRequestedUserHint = rep.getCibaAuthRequestedUserHint();\n        if (cibaAuthRequestedUserHint == null || cibaAuthRequestedUserHint.isEmpty())\n            cibaAuthRequestedUserHint = Constants.DEFAULT_CIBA_POLICY_AUTH_REQUESTED_USER_HINT;\n        cibaPolicy.setAuthRequestedUserHint(cibaAuthRequestedUserHint);\n\n        realm.setCIBAPolicy(cibaPolicy);\n    }\n\nand use it in both places?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575691813", "createdAt": "2021-02-13T17:31:17Z", "author": {"login": "valb3r"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -285,6 +286,28 @@ public static void importRealm(KeycloakSession session, RealmRepresentation rep,\n         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);\n         newRealm.setWebAuthnPolicyPasswordless(webAuthnPolicy);\n \n+        CIBAPolicy cibaPolicy = new CIBAPolicy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MjExNA==", "bodyText": "There is no need to define empty public contructor, java already provides the default one", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575692114", "createdAt": "2021-02-13T17:35:06Z", "author": {"login": "valb3r"}, "path": "server-spi/src/main/java/org/keycloak/models/CIBAPolicy.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models;\n+\n+import java.io.Serializable;\n+\n+import org.jboss.logging.Logger;\n+\n+public class CIBAPolicy implements Serializable {\n+\n+    protected static final Logger logger = Logger.getLogger(CIBAPolicy.class);\n+\n+    protected String backchannelTokenDeliveryMode = \"poll\";\n+    protected int expiresIn = 120;\n+    protected int interval = 0;\n+    protected String authRequestedUserHint = \"login_hint\";\n+\n+    public CIBAPolicy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NDYxNA==", "bodyText": "What is the purpose of this log statement? if userSession is null doesn't it makes sense to throw an exception immediately? as updateUserSessionFromClientAuthwill throw NPE ifuserSession` is null", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575694614", "createdAt": "2021-02-13T17:56:57Z", "author": {"login": "valb3r"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            logger.info(\" userSession is null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NDk0Ng==", "bodyText": "Instead of doing string-concatenation, it might be better to use logger.infof", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575694946", "createdAt": "2021-02-13T17:59:23Z", "author": {"login": "valb3r"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            logger.info(\" userSession is null.\");\n+        } else {\n+            logger.info(\" user session id = \" + userSession.getId() + \", username = \" + userSession.getUser().getUsername());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NTE5MA==", "bodyText": "can be simplified to grantedConsent.getGrantedClientScopes().forEach(i->logger.info(i.getName()));", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575695190", "createdAt": "2021-02-13T18:02:02Z", "author": {"login": "valb3r"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            logger.info(\" userSession is null.\");\n+        } else {\n+            logger.info(\" user session id = \" + userSession.getId() + \", username = \" + userSession.getUser().getUsername());\n+        }\n+        updateUserSessionFromClientAuth(userSession);\n+\n+        logger.info(\"  Created User Session's id                            = \" + userSession.getId());\n+        logger.info(\"  Submitted in advance User Session ID Will Be Created = \" + getUserSessionIdWillBeCreated());\n+\n+        // authorization (consent)\n+        UserConsentModel grantedConsent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n+        if (grantedConsent == null) {\n+            grantedConsent = new UserConsentModel(client);\n+            session.users().addConsent(realm, user.getId(), grantedConsent);\n+            logger.info(\"  Consent updated : \");\n+            grantedConsent.getGrantedClientScopes().stream().forEach(i->logger.info(i.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NTI5MQ==", "bodyText": "can be simplified to grantedConsent.getGrantedClientScopes().forEach(i->logger.info(i.getName()));", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575695291", "createdAt": "2021-02-13T18:03:18Z", "author": {"login": "valb3r"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            logger.info(\" userSession is null.\");\n+        } else {\n+            logger.info(\" user session id = \" + userSession.getId() + \", username = \" + userSession.getUser().getUsername());\n+        }\n+        updateUserSessionFromClientAuth(userSession);\n+\n+        logger.info(\"  Created User Session's id                            = \" + userSession.getId());\n+        logger.info(\"  Submitted in advance User Session ID Will Be Created = \" + getUserSessionIdWillBeCreated());\n+\n+        // authorization (consent)\n+        UserConsentModel grantedConsent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n+        if (grantedConsent == null) {\n+            grantedConsent = new UserConsentModel(client);\n+            session.users().addConsent(realm, user.getId(), grantedConsent);\n+            logger.info(\"  Consent updated : \");\n+            grantedConsent.getGrantedClientScopes().stream().forEach(i->logger.info(i.getName()));\n+        }\n+\n+        boolean updateConsentRequired = false;\n+\n+        for (String clientScopeId : authSession.getClientScopes()) {\n+            ClientScopeModel clientScope = KeycloakModelUtils.findClientScopeById(realm, client, clientScopeId);\n+            if (clientScope != null) {\n+                if (!grantedConsent.isClientScopeGranted(clientScope) && clientScope.isDisplayOnConsentScreen()) {\n+                    grantedConsent.addGrantedClientScope(clientScope);\n+                    updateConsentRequired = true;\n+                }\n+            } else {\n+                logger.warnf(\"Client scope or client with ID '%s' not found\", clientScopeId);\n+            }\n+        }\n+\n+        if (updateConsentRequired) {\n+            session.users().updateConsent(realm, user.getId(), grantedConsent);\n+            logger.info(\"  Consent granted : \");\n+            grantedConsent.getGrantedClientScopes().stream().forEach(i->logger.info(i.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03"}, "originalPosition": 211}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/466333489cd8bd510d90b698b9ef7a332a666f03", "committedDate": "2020-12-27T12:24:35Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>"}, "afterCommit": {"oid": "9fdf0bb45e53185115f1035c059be90569f31cea", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/9fdf0bb45e53185115f1035c059be90569f31cea", "committedDate": "2021-02-16T09:00:23Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMTExODEw", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-592111810", "createdAt": "2021-02-17T11:50:28Z", "commit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxMTo1MDoyOFrOImyvrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxMjoyNjowOVrOIm0Cqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU0ODIwNA==", "bodyText": "I would also move this to the CIBA representation. All CIBA related data from a single place. Same for the model.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577548204", "createdAt": "2021-02-17T11:50:28Z", "author": {"login": "pedroigor"}, "path": "core/src/main/java/org/keycloak/representations/idm/RealmRepresentation.java", "diffHunk": "@@ -180,6 +183,7 @@\n     protected String resetCredentialsFlow;\n     protected String clientAuthenticationFlow;\n     protected String dockerAuthenticationFlow;\n+    protected String cibaFlow;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU1MDE3NQ==", "bodyText": "To avoid boilerplate code we could probable add a public String getAttribute(String name, String defaultValue) as we have for other types like int, boolean, etc.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577550175", "createdAt": "2021-02-17T11:54:02Z", "author": {"login": "pedroigor"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1048,6 +1049,46 @@ private void setWebAuthnPolicy(WebAuthnPolicy policy, String attributePrefix) {\n         }\n     }\n \n+    @Override\n+    public CIBAPolicy getCIBAPolicy() {\n+        CIBAPolicy policy = new CIBAPolicy();\n+\n+        String backchannelTokenDeliveryMode = getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU1NjA1OA==", "bodyText": "As mentioned before. We can move the cibaFlow to CIBAPolicy. No need for this method.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577556058", "createdAt": "2021-02-17T12:04:01Z", "author": {"login": "pedroigor"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1554,6 +1595,18 @@ public void setDockerAuthenticationFlow(AuthenticationFlowModel flow) {\n         realm.setDockerAuthenticationFlow(flow.getId());\n     }\n \n+    @Override\n+    public AuthenticationFlowModel getCIBAFlow() {\n+        String flowId = getAttribute(RealmAttributes.CIBA_AUTHENTICATION_FLOW);\n+        if (flowId == null) return null;\n+        return getAuthenticationFlowById(flowId);\n+    }\n+\n+    @Override\n+    public void setCIBAFlow(AuthenticationFlowModel flow) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU1ODk5MA==", "bodyText": "This should remove some boilerplate code:\ncibaPolicy.setBackchannelTokenDeliveryMode(Optional.ofNullable(cibaRep.getCibaBackchannelTokenDeliveryMode())\n                    .filter(StringUtil::isNotBlank)\n                    .orElse(Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE));", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577558990", "createdAt": "2021-02-17T12:08:58Z", "author": {"login": "pedroigor"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -544,6 +550,35 @@ private static WebAuthnPolicy getWebAuthnPolicyPasswordless(RealmRepresentation\n         return webAuthnPolicy;\n     }\n \n+    private static CIBAPolicy convertCIBARepresentationToPolicy(CIBARepresentation cibaRep) {\n+        CIBAPolicy cibaPolicy = new CIBAPolicy();\n+        if (cibaRep != null) {\n+            String cibaBackchannelTokenDeliveryMode = cibaRep.getCibaBackchannelTokenDeliveryMode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MDE4Nw==", "bodyText": "What should happen if the flow from representation does not exist?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577560187", "createdAt": "2021-02-17T12:10:58Z", "author": {"login": "pedroigor"}, "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -808,6 +844,19 @@ public static void importGroup(RealmModel realm, GroupModel parent, GroupReprese\n         return mappedFlows;\n     }\n \n+    private static void handleCibaFlowIfApplicable(RealmModel newRealm, RealmRepresentation rep) {\n+        if (rep.getCibaFlow() == null) {\n+            AuthenticationFlowModel cibaFlowModel = newRealm.getFlowByAlias(DefaultAuthenticationFlows.CIBA_FLOW);\n+            if (cibaFlowModel != null) {\n+                newRealm.setCIBAFlow(cibaFlowModel);\n+            } else {\n+                DefaultAuthenticationFlows.cibaFlow(newRealm);\n+            }\n+        } else {\n+            newRealm.setCIBAFlow(newRealm.getFlowByAlias(rep.getCibaFlow()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MDU1MA==", "bodyText": "Using logger?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577560550", "createdAt": "2021-02-17T12:11:41Z", "author": {"login": "pedroigor"}, "path": "server-spi/src/main/java/org/keycloak/models/CIBAPolicy.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models;\n+\n+import java.io.Serializable;\n+\n+import org.jboss.logging.Logger;\n+\n+public class CIBAPolicy implements Serializable {\n+\n+    protected static final Logger logger = Logger.getLogger(CIBAPolicy.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MTE4OQ==", "bodyText": "Do you expect sub-types or types within the same package to extend this class? Could them be private instead?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577561189", "createdAt": "2021-02-17T12:12:47Z", "author": {"login": "pedroigor"}, "path": "server-spi/src/main/java/org/keycloak/models/CIBAPolicy.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models;\n+\n+import java.io.Serializable;\n+\n+import org.jboss.logging.Logger;\n+\n+public class CIBAPolicy implements Serializable {\n+\n+    protected static final Logger logger = Logger.getLogger(CIBAPolicy.class);\n+\n+    protected String backchannelTokenDeliveryMode = \"poll\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MjIwMA==", "bodyText": "Trim the string before checking if it is empty?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577562200", "createdAt": "2021-02-17T12:14:20Z", "author": {"login": "pedroigor"}, "path": "server-spi/src/main/java/org/keycloak/utils/StringUtil.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.utils;\n+\n+public class StringUtil {\n+\n+    public static boolean isBlank(String str) {\n+        return !(isNotBlank(str));\n+    }\n+\n+    public static boolean  isNotBlank(String str) {\n+        return str != null && !str.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2Mjg4NQ==", "bodyText": "Aren't those fields automatically injected as they are annotated with @Context ?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577562885", "createdAt": "2021-02-17T12:15:31Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2Mzg4NA==", "bodyText": "Prefer using constants from org.jboss.resteasy.util.HttpHeaderNames.\nAlso, the Response type from JAX-RS should give you methods to set the cache-control as well as any other header, without having to deal with the HttpResponse directly.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577563884", "createdAt": "2021-02-17T12:17:11Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2NjQwOA==", "bodyText": "Too verbose?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577566408", "createdAt": "2021-02-17T12:21:13Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2Njc0Ng==", "bodyText": "Too verbose?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577566746", "createdAt": "2021-02-17T12:21:46Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            event.error(Errors.USER_SESSION_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"User session is not found\", Response.Status.BAD_REQUEST);\n+        } else {\n+            logger.infof(\" user session id =  %s, username = %s\", userSession.getId(), userSession.getUser().getUsername());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2NzMyMg==", "bodyText": "Too verbose?\nCould you please check other logging messages in other places that fit into the same problem?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577567322", "createdAt": "2021-02-17T12:22:31Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            event.error(Errors.USER_SESSION_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"User session is not found\", Response.Status.BAD_REQUEST);\n+        } else {\n+            logger.infof(\" user session id =  %s, username = %s\", userSession.getId(), userSession.getUser().getUsername());\n+        }\n+        updateUserSessionFromClientAuth(userSession);\n+\n+        logger.infof(\"  Created User Session's id                            = %s\", userSession.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2OTQ1MQ==", "bodyText": "Woudn't be easier to just userSession.getNotes().putAll(clientAuthAttributes)? And probably remove this method.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577569451", "createdAt": "2021-02-17T12:26:09Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            event.error(Errors.USER_SESSION_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"User session is not found\", Response.Status.BAD_REQUEST);\n+        } else {\n+            logger.infof(\" user session id =  %s, username = %s\", userSession.getId(), userSession.getUser().getUsername());\n+        }\n+        updateUserSessionFromClientAuth(userSession);\n+\n+        logger.infof(\"  Created User Session's id                            = %s\", userSession.getId());\n+        logger.infof(\"  Submitted in advance User Session ID Will Be Created = %s\", getUserSessionIdWillBeCreated());\n+\n+        // authorization (consent)\n+        UserConsentModel grantedConsent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n+        if (grantedConsent == null) {\n+            grantedConsent = new UserConsentModel(client);\n+            session.users().addConsent(realm, user.getId(), grantedConsent);\n+            logger.info(\"  Consent updated : \");\n+            grantedConsent.getGrantedClientScopes().forEach(i->logger.info(i.getName()));\n+        }\n+\n+        boolean updateConsentRequired = false;\n+\n+        for (String clientScopeId : authSession.getClientScopes()) {\n+            ClientScopeModel clientScope = KeycloakModelUtils.findClientScopeById(realm, client, clientScopeId);\n+            if (clientScope != null) {\n+                if (!grantedConsent.isClientScopeGranted(clientScope) && clientScope.isDisplayOnConsentScreen()) {\n+                    grantedConsent.addGrantedClientScope(clientScope);\n+                    updateConsentRequired = true;\n+                }\n+            } else {\n+                logger.warnf(\"Client scope or client with ID '%s' not found\", clientScopeId);\n+            }\n+        }\n+\n+        if (updateConsentRequired) {\n+            session.users().updateConsent(realm, user.getId(), grantedConsent);\n+            logger.info(\"  Consent granted : \");\n+            grantedConsent.getGrantedClientScopes().forEach(i->logger.info(i.getName()));\n+        }\n+\n+        event.detail(Details.CONSENT, Details.CONSENT_VALUE_CONSENT_GRANTED);\n+\n+        event.success();\n+    }\n+\n+\n+    protected void persistDecoupledAuthenticationResult(String status) {\n+        DecoupledAuthnResult decoupledAuthnResult = new DecoupledAuthnResult(getExpiration(), status);\n+        DecoupledAuthnResultParser.persistDecoupledAuthnResult(session, getAuthResultId(), decoupledAuthnResult, getExpiration());\n+    }\n+\n+    abstract protected String getScope();\n+    abstract protected String getUserSessionIdWillBeCreated();\n+    abstract protected String getUserIdToBeAuthenticated();\n+    abstract protected String getAuthResultId();\n+    abstract protected int getExpiration();\n+\n+    abstract protected Response verifyDecoupledAuthnResult();\n+\n+    private void updateUserSessionFromClientAuth(UserSessionModel userSession) {\n+        for (Map.Entry<String, String> attr : clientAuthAttributes.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "098220ef66b8ff7bad8371639a102f03cf9e66d3"}, "originalPosition": 235}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "564b62a677d8cd11302094ec113bbc6c9cfb1476", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/564b62a677d8cd11302094ec113bbc6c9cfb1476", "committedDate": "2021-02-21T20:11:49Z", "message": "incorporating mainly 2nd review comments"}, "afterCommit": {"oid": "6f0c208a4affc51479ffeffa99a5c59c5e43c10d", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/6f0c208a4affc51479ffeffa99a5c59c5e43c10d", "committedDate": "2021-02-21T20:29:39Z", "message": "rebase master to resolve conflicts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NzQ1Njkw", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-595745690", "createdAt": "2021-02-22T20:18:05Z", "commit": {"oid": "6f0c208a4affc51479ffeffa99a5c59c5e43c10d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMlQyMDoxODowNVrOIpqp7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMlQyMDoxODowNVrOIpqp7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDU2MTM5MQ==", "bodyText": "I would add an if statement prior to running this line to check if trace level is enabled.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r580561391", "createdAt": "2021-02-22T20:18:05Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.util.HttpHeaderNames;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+\n+        HttpRequest httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        ClientConnection clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl(clientConnection);\n+        checkRealm();\n+        checkClient();\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions(httpRequest, clientConnection);\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)\n+                .header(HttpHeaderNames.CACHE_CONTROL, \"no-store\")\n+                .header(HttpHeaderNames.PRAGMA, \"no-cache\"))\n+                .build();\n+    }\n+\n+    private void setupSessions(HttpRequest httpRequest, ClientConnection clientConnection) {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            event.error(Errors.USER_SESSION_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"User session is not found\", Response.Status.BAD_REQUEST);\n+        }\n+        userSession.getNotes().putAll(clientAuthAttributes);\n+        logger.tracef(\"CIBA Grant :: specified scopes in backchannel authentication endpoint = %s, Created User Session's id = %s, Submitted in advance User Session ID Will Be Created = %s, username = %s\", getScope(), userSession.getId(), getUserSessionIdWillBeCreated(), userSession.getUser().getUsername());\n+\n+        // authorization (consent)\n+        UserConsentModel grantedConsent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n+        if (grantedConsent == null) {\n+            grantedConsent = new UserConsentModel(client);\n+            session.users().addConsent(realm, user.getId(), grantedConsent);\n+            grantedConsent.getGrantedClientScopes().forEach(i->logger.tracef(\"CIBA Grant :: Consent granted. %s\", i.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f0c208a4affc51479ffeffa99a5c59c5e43c10d"}, "originalPosition": 170}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0e7abcd4448fd7f2cdbff65d04009693553bbf26", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/0e7abcd4448fd7f2cdbff65d04009693553bbf26", "committedDate": "2021-02-23T04:28:43Z", "message": "remove CIBARepresentation add trace log facility check in advance"}, "afterCommit": {"oid": "132f6b350528cbf6f8a212bfac88b1badc3a378e", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/132f6b350528cbf6f8a212bfac88b1badc3a378e", "committedDate": "2021-02-23T07:38:43Z", "message": "remove CIBARepresentation add trace log facility check in advance"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwNzg3MjQ1", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-600787245", "createdAt": "2021-03-01T14:28:52Z", "commit": {"oid": "fcbea7a2f9ce743bd5503edc43464c8bb01c1721"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQxNDoyODo1MlrOItqkmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQxNDozMjoxNVrOItquyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1NDMyOA==", "bodyText": "This is going to cause an NPE if the param is not available from the request.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r584754328", "createdAt": "2021-03-01T14:28:52Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/HttpAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class HttpAuthenticationChannelProvider extends HttpAuthenticationChannelProviderBase {\n+\n+    private static final Logger logger = Logger.getLogger(HttpAuthenticationChannelProvider.class);\n+\n+    protected final String httpAuthenticationRequestUri;\n+\n+    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {\n+        super(session);\n+        this.httpAuthenticationRequestUri = httpAuthenticationRequestUri;\n+    }\n+\n+    protected String scope;\n+    protected String userSessionIdWillBeCreated;\n+    protected String userIdToBeAuthenticated;\n+    protected String authResultId;\n+    protected int expiration;\n+\n+    @Override\n+    protected String getScope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    protected String getUserSessionIdWillBeCreated() {\n+        return userSessionIdWillBeCreated;\n+    }\n+\n+    @Override\n+    protected String getUserIdToBeAuthenticated() {\n+        return userIdToBeAuthenticated;\n+    }\n+\n+    @Override\n+    protected String getAuthResultId() {\n+        return authResultId;\n+    }\n+\n+    @Override\n+    protected int getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    protected Response verifyDecoupledAuthnResult() {\n+        String decoupledAuthId = formParams.getFirst(HttpAuthenticationChannelProvider.DECOUPLED_AUTHN_ID);\n+        ParseResult parseResult = parseDecoupledAuthId(session, decoupledAuthId, event);\n+\n+        if (parseResult.isIllegalDecoupledAuthId()) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            // decoupled auth id format is invalid or it has already been used\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"invalid decoupled authn id\", Response.Status.BAD_REQUEST);\n+        } else if (parseResult.isExpiredDecoupledAuthId()) {\n+            event.error(Errors.SESSION_EXPIRED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.EXPIRED);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = parseResult.decoupledAuthIdJwt();\n+        authResultId = decoupledAuthIdJwt.getAuthResultId();\n+        scope = decoupledAuthIdJwt.getScope();\n+        expiration = decoupledAuthIdJwt.getExp().intValue();\n+        userSessionIdWillBeCreated = decoupledAuthIdJwt.getSessionState();\n+        userIdToBeAuthenticated = decoupledAuthIdJwt.getSubject();\n+        // to bind Client Session of CD(Consumption Device) with User Session, set CD's Client Model to this class member \"client\".\n+        client = realm.getClientByClientId(decoupledAuthIdJwt.getIssuedFor());\n+\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String userIdAuthenticated = resolver.getUserFromInfoUsedByAuthentication(formParams.getFirst(HttpAuthenticationChannelProvider.DECOUPLED_AUTHN_USER_INFO)).getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcbea7a2f9ce743bd5503edc43464c8bb01c1721"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1NTQ3MA==", "bodyText": "Does it make more sense to move all this method to the CIBADecoupledAuthenticator ?\nPlease, see my last comment about whether we need a CIBA flow.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r584755470", "createdAt": "2021-03-01T14:30:19Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/HttpAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class HttpAuthenticationChannelProvider extends HttpAuthenticationChannelProviderBase {\n+\n+    private static final Logger logger = Logger.getLogger(HttpAuthenticationChannelProvider.class);\n+\n+    protected final String httpAuthenticationRequestUri;\n+\n+    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {\n+        super(session);\n+        this.httpAuthenticationRequestUri = httpAuthenticationRequestUri;\n+    }\n+\n+    protected String scope;\n+    protected String userSessionIdWillBeCreated;\n+    protected String userIdToBeAuthenticated;\n+    protected String authResultId;\n+    protected int expiration;\n+\n+    @Override\n+    protected String getScope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    protected String getUserSessionIdWillBeCreated() {\n+        return userSessionIdWillBeCreated;\n+    }\n+\n+    @Override\n+    protected String getUserIdToBeAuthenticated() {\n+        return userIdToBeAuthenticated;\n+    }\n+\n+    @Override\n+    protected String getAuthResultId() {\n+        return authResultId;\n+    }\n+\n+    @Override\n+    protected int getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    protected Response verifyDecoupledAuthnResult() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcbea7a2f9ce743bd5503edc43464c8bb01c1721"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1NjkzOA==", "bodyText": "Like in other places, I think we should remove all references to \"decoupled\" to reference \"authentication channel\" instead?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r584756938", "createdAt": "2021-03-01T14:32:15Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/HttpAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcbea7a2f9ce743bd5503edc43464c8bb01c1721"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAwNzkzODE4", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-600793818", "createdAt": "2021-03-01T14:35:07Z", "commit": {"oid": "fcbea7a2f9ce743bd5503edc43464c8bb01c1721"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQxNDozNTowN1rOItq3OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQxNDozNTowN1rOItq3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1OTA5Ng==", "bodyText": "Wouldn't be easier to just have a single HttpAuthenticationChannepProvider for both http and https schemes?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r584759096", "createdAt": "2021-03-01T14:35:07Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/HttpsAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.KeycloakSession;\n+\n+public class HttpsAuthenticationChannelProvider extends HttpAuthenticationChannelProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcbea7a2f9ce743bd5503edc43464c8bb01c1721"}, "originalPosition": 22}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9bd4ecd7a6be92ec4c2edfdfd794faf90069d86f", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/9bd4ecd7a6be92ec4c2edfdfd794faf90069d86f", "committedDate": "2021-03-06T22:03:41Z", "message": "replace words : decoupled authentication with authentication channel"}, "afterCommit": {"oid": "557ec24025cc86e630da1ef29c13d5cc38435ad1", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/557ec24025cc86e630da1ef29c13d5cc38435ad1", "committedDate": "2021-03-07T23:20:38Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>\nCo-authored-by: Christophe Lannoy <c4r1570p4e@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "557ec24025cc86e630da1ef29c13d5cc38435ad1", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/557ec24025cc86e630da1ef29c13d5cc38435ad1", "committedDate": "2021-03-07T23:20:38Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>\nCo-authored-by: Christophe Lannoy <c4r1570p4e@gmail.com>"}, "afterCommit": {"oid": "b7187a29bf4b6a6c1b2119291b10aefa31b4d295", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/b7187a29bf4b6a6c1b2119291b10aefa31b4d295", "committedDate": "2021-03-08T07:23:23Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>\nCo-authored-by: Christophe Lannoy <c4r1570p4e@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "464d787ecbff534b3f0e567b0d5819c882971a68", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/464d787ecbff534b3f0e567b0d5819c882971a68", "committedDate": "2021-03-10T01:48:44Z", "message": "revert removed SAML SCP default auth flow setting"}, "afterCommit": {"oid": "4ba2e1eedcfd3fa6714789f0c99ecc0bb62b2d71", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/4ba2e1eedcfd3fa6714789f0c99ecc0bb62b2d71", "committedDate": "2021-03-22T01:30:26Z", "message": "fix CIBATest"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4ba2e1eedcfd3fa6714789f0c99ecc0bb62b2d71", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/4ba2e1eedcfd3fa6714789f0c99ecc0bb62b2d71", "committedDate": "2021-03-22T01:30:26Z", "message": "fix CIBATest"}, "afterCommit": {"oid": "a0c3846cf6d86e45f501a6de1e28f0efbaa25991", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/a0c3846cf6d86e45f501a6de1e28f0efbaa25991", "committedDate": "2021-03-22T04:04:17Z", "message": "fix CIBATest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4Mzc4Nzg2", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-618378786", "createdAt": "2021-03-23T09:38:13Z", "commit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QwOTozODoxM1rOI7pARg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMDowODowOVrOI7qW1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQwODcxMA==", "bodyText": "Shouldn't we throw an exception in case that unsupported token delivery mode is used? Accepting for example \"ping\" may indicate that Keycloak supports that, even if not.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599408710", "createdAt": "2021-03-23T09:38:13Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/services/clientregistration/oidc/DescriptionConverter.java", "diffHunk": "@@ -165,6 +165,10 @@ public static ClientRepresentation toInternal(KeycloakSession session, OIDCClien\n             configWrapper.setBackchannelLogoutRevokeOfflineTokens(clientOIDC.getBackchannelLogoutRevokeOfflineTokens());\n         }\n \n+        if (clientOIDC.getBackchannelTokenDeliveryMode() != null) {\n+            configWrapper.setBackchannelTokenDeliveryMode(clientOIDC.getBackchannelTokenDeliveryMode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxMjY1Ng==", "bodyText": "@tnorimat @pedroigor Comment to DescriptionConverter.getOIDCGrantTypes: According to the specification https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#registration, there is this: When using the ping or poll mode, the Client MUST include the CIBA grant type in the \"grant_types\" field. . However we don't include it here. For example for Device Grant, we correctly include the device grant type based on whether the device grant is enabled for client or not.\nRelated question: For CIBA, we don't have switch for the client to specify if CIBA grant type is enabled for the client or not. Shouldn't we have this switch similarly like we have it for the Device Grant? It seems to me that yes. For example see the example from the end of the section https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#registration . This registration request specifies that CIBA is required (and only supported) grant type for this client. IMO we should allow to convert such registration request to the Keycloak client, which will have only CIBA grant allowed and not any other grant types. Hence I suggest, we should also change the DescriptionConverter.toInternal to propagate the OIDC \"grant_types\" field to enable CIBA for the client in case that CIBA grant type is enabled.\nRelated note for device grant: I've just noticed that in DescriptionConverter.toInternal, for some reason we missed to convert OIDC device grant type to the switch for enabling device grant for the client. I suggest we fix this as well when we're at this (or maybe we can create separate JIRA for it?)", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599412656", "createdAt": "2021-03-23T09:43:47Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/services/clientregistration/oidc/DescriptionConverter.java", "diffHunk": "@@ -270,6 +274,10 @@ public static OIDCClientRepresentation toExternalResponse(KeycloakSession sessio\n         response.setBackchannelLogoutSessionRequired(config.isBackchannelLogoutSessionRequired());\n         response.setBackchannelLogoutSessionRequired(config.getBackchannelLogoutRevokeOfflineTokens());\n \n+        if (config.getBackchannelTokenDeliveryMode() != null) {\n+            response.setBackchannelTokenDeliveryMode(config.getBackchannelTokenDeliveryMode());\n+        }\n+\n         List<ProtocolMapperRepresentation> foundPairwiseMappers = PairwiseSubMapperUtils.getPairwiseSubMappers(client);\n         SubjectType subjectType = foundPairwiseMappers.isEmpty() ? SubjectType.PUBLIC : SubjectType.PAIRWISE;\n         response.setSubjectType(subjectType.toString().toLowerCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNDI5MA==", "bodyText": "@pedroigor Should this switch be moved to the CibaConfig? Not a big deal, but I've noticed that you added client-specific switches to the OAuth2DeviceConfig class. Hence I wonder if CIBA client-specific switches should be also moved there to align with device grant?\nSame might apply to the client switch for \"CIBA Enabled\" if we add it (See my comment in the DescriptionConverter class)", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599414290", "createdAt": "2021-03-23T09:45:58Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/OIDCAdvancedConfigWrapper.java", "diffHunk": "@@ -220,6 +220,14 @@ public void setBackchannelLogoutRevokeOfflineTokens(boolean backchannelLogoutRev\n         setAttribute(OIDCConfigAttributes.BACKCHANNEL_LOGOUT_REVOKE_OFFLINE_TOKENS, val);\n     }\n \n+    public String getBackchannelTokenDeliveryMode() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNDg1NA==", "bodyText": "My vote is to rename this class to something like \"CibaRootEndpoint\" or \"CibaExtEndpoint\" . CibaEndpoint implies to me that it inherits from \"AbstractCibaEndpoint\", which is not the case. But maybe it is just me.. I don't have strong opinion in regards to this one...:)", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599414854", "createdAt": "2021-03-23T09:46:47Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/CibaEndpoint.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ *\n+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates\n+ *  * and other contributors as indicated by the @author tags.\n+ *  *\n+ *  * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  * you may not use this file except in compliance with the License.\n+ *  * You may obtain a copy of the License at\n+ *  *\n+ *  * http://www.apache.org/licenses/LICENSE-2.0\n+ *  *\n+ *  * Unless required by applicable law or agreed to in writing, software\n+ *  * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  * See the License for the specific language governing permissions and\n+ *  * limitations under the License.\n+ *\n+ */\n+\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.spi.ResteasyProviderFactory;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProviderFactory;\n+\n+/**\n+ * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n+ */\n+public class CibaEndpoint implements OIDCExtProvider, OIDCExtProviderFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNTQzNQ==", "bodyText": "This comment is outdated. For example it mentions userSessionIdWillBeCreated, which doesn't exists anymore in this PR. I suggest to either remove this comment or make it up-to-date to avoid confusions and outdated info in the source code comments.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599415435", "createdAt": "2021-03-23T09:47:27Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.channel;\n+\n+import static org.keycloak.OAuth2Constants.SCOPE;\n+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.services.resources.Cors;\n+\n+public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{\n+\n+    public static final String AUTHENTICATION_CHANNEL_ID = \"authentication_channel_id\";\n+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = \"user_info\";\n+    public static final String AUTHENTICATION_STATUS = \"auth_result\";\n+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = \"is_consent_required\";\n+\n+    protected KeycloakSession session;\n+    protected MultivaluedMap<String, String> formParams;\n+    protected RealmModel realm;\n+    protected Map<String, String> clientAuthAttributes;\n+    protected Cors cors;\n+    protected final String httpAuthenticationChannelUri;\n+\n+    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {\n+        this.session = session;\n+        this.realm = session.getContext().getRealm();\n+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;\n+    }\n+\n+    @Override\n+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {\n+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNjY4MQ==", "bodyText": "@pedroigor I see that for CIBA, we don't use OAuth2DeviceUserCodeModel for anything. The callback and grant endpoints need just the deviceCode. Currently after finish the CIBA flow, the \"userCode\" entry still remains in the cache as a thombstone until it is expired (which is usually in a short period of time, but still). So should be better to just send \"null\" as a \"userCode\" argument to the OAuth2DeviceTokenStoreProvider?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599416681", "createdAt": "2021-03-23T09:49:05Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.jboss.resteasy.annotations.cache.NoCache;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.Profile;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.OAuth2DeviceCodeModel;\n+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;\n+import org.keycloak.models.OAuth2DeviceUserCodeModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;\n+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.services.ErrorResponseException;\n+import org.keycloak.util.JsonSerialization;\n+import org.keycloak.utils.ProfileHelper;\n+\n+public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {\n+\n+    private final RealmModel realm;\n+\n+    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {\n+        super(session, event);\n+        this.realm = session.getContext().getRealm();\n+        event.event(EventType.LOGIN);\n+    }\n+\n+    @POST\n+    @NoCache\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processGrantRequest(@Context HttpRequest httpRequest) {\n+        ProfileHelper.requireFeature(Profile.Feature.CIBA);\n+        AuthenticationRequest request = authorizeClient(httpRequest.getDecodedFormParameters());\n+\n+        try {\n+            String authReqId = request.serialize(session);\n+            AuthenticationChannelProvider provider = session.getProvider(AuthenticationChannelProvider.class);\n+\n+            if (provider == null) {\n+                throw new RuntimeException(\"Authentication Channel Provider not found.\");\n+            }\n+\n+            CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+\n+            if (resolver == null) {\n+                throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+            }\n+\n+            UserModel user = request.getUser();\n+\n+            String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);\n+\n+            if (provider.requestAuthentication(request, infoUsedByAuthentication)) {\n+                CibaConfig cibaPolicy = realm.getCibaPolicy();\n+                int poolingInterval = cibaPolicy.getPoolingInterval();\n+\n+                storeAuthenticationRequest(request, cibaPolicy);\n+\n+                ObjectNode response = JsonSerialization.createObjectNode();\n+\n+                response.put(CibaGrantType.AUTH_REQ_ID, authReqId)\n+                        .put(OAuth2Constants.EXPIRES_IN, cibaPolicy.getExpiresIn());\n+\n+                if (poolingInterval > 0) {\n+                    response.put(OAuth2Constants.INTERVAL, poolingInterval);\n+                }\n+\n+                return Response.ok(JsonSerialization.writeValueAsBytes(response))\n+                        .build();\n+            }\n+        } catch (Exception e) {\n+            throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, \"Failed to send authentication request\", Response.Status.SERVICE_UNAVAILABLE);\n+        }\n+\n+        throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, \"Unexpected response from authentication device\", Response.Status.SERVICE_UNAVAILABLE);\n+    }\n+\n+    /**\n+     * TODO: Leverage the device code storage for tracking authentication requests. Not sure if we need a specific storage,\n+     * but probably make the {@link OAuth2DeviceTokenStoreProvider} more generic for ciba, device, or any other use case\n+     * that relies on cross-references for unsolicited user authentication requests from devices.\n+     */\n+    private void storeAuthenticationRequest(AuthenticationRequest request, CibaConfig cibaConfig) {\n+        ClientModel client = request.getClient();\n+        int expiresIn = cibaConfig.getExpiresIn();\n+        int poolingInterval = cibaConfig.getPoolingInterval();\n+\n+        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,\n+                request.getId(), request.getScope(), null, expiresIn, poolingInterval,\n+                Collections.emptyMap());\n+        String authResultId = request.getAuthResultId();\n+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(),\n+                authResultId);\n+\n+        // To inform \"expired_token\" to the client, the lifespan of the cache provider is longer than device code\n+        int lifespanSeconds = expiresIn + poolingInterval + 10;\n+\n+        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);\n+\n+        store.put(deviceCode, userCode, lifespanSeconds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxOTAxNg==", "bodyText": "@tnorimat @pedroigor I have one minor concern regarding \"acr_values\" . Keycloak currently doesn't properly support this parameter inside Keycloak authentication flows. However in the case of CIBA, Keycloak delegates authentication to the authentication channel to happen outside of Keycloak. Hence I wonder if we should allow this \"acr_parameter\" and include it via the HttpAuthenticationChannelProvider.requestAuthentication for the case that authentication channel supports it?\nAlternatively to sending acr_values to the channel provider, I think we can also support to have more AuthenticationChannelProvider implementations and Keycloak can decide which AuthenticationChannelProvider to use based on the \"acr_values\" parameter. At least, that is my understanding how it could work based on the specification https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_server_obtains_consent . See especially this comment in the specs After the OP has validated the Authentication Request, the OP identifies the user and chooses a channel to best authenticate the user and authorize the request, in line with the Client's requests regarding acr_values. .\nThis support for acr_values is not a blocker for this PR IMO, just something to consider...", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599419016", "createdAt": "2021-03-23T09:52:13Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.jboss.resteasy.annotations.cache.NoCache;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.Profile;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.OAuth2DeviceCodeModel;\n+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;\n+import org.keycloak.models.OAuth2DeviceUserCodeModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;\n+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.services.ErrorResponseException;\n+import org.keycloak.util.JsonSerialization;\n+import org.keycloak.utils.ProfileHelper;\n+\n+public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {\n+\n+    private final RealmModel realm;\n+\n+    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {\n+        super(session, event);\n+        this.realm = session.getContext().getRealm();\n+        event.event(EventType.LOGIN);\n+    }\n+\n+    @POST\n+    @NoCache\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processGrantRequest(@Context HttpRequest httpRequest) {\n+        ProfileHelper.requireFeature(Profile.Feature.CIBA);\n+        AuthenticationRequest request = authorizeClient(httpRequest.getDecodedFormParameters());\n+\n+        try {\n+            String authReqId = request.serialize(session);\n+            AuthenticationChannelProvider provider = session.getProvider(AuthenticationChannelProvider.class);\n+\n+            if (provider == null) {\n+                throw new RuntimeException(\"Authentication Channel Provider not found.\");\n+            }\n+\n+            CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+\n+            if (resolver == null) {\n+                throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+            }\n+\n+            UserModel user = request.getUser();\n+\n+            String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);\n+\n+            if (provider.requestAuthentication(request, infoUsedByAuthentication)) {\n+                CibaConfig cibaPolicy = realm.getCibaPolicy();\n+                int poolingInterval = cibaPolicy.getPoolingInterval();\n+\n+                storeAuthenticationRequest(request, cibaPolicy);\n+\n+                ObjectNode response = JsonSerialization.createObjectNode();\n+\n+                response.put(CibaGrantType.AUTH_REQ_ID, authReqId)\n+                        .put(OAuth2Constants.EXPIRES_IN, cibaPolicy.getExpiresIn());\n+\n+                if (poolingInterval > 0) {\n+                    response.put(OAuth2Constants.INTERVAL, poolingInterval);\n+                }\n+\n+                return Response.ok(JsonSerialization.writeValueAsBytes(response))\n+                        .build();\n+            }\n+        } catch (Exception e) {\n+            throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, \"Failed to send authentication request\", Response.Status.SERVICE_UNAVAILABLE);\n+        }\n+\n+        throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, \"Unexpected response from authentication device\", Response.Status.SERVICE_UNAVAILABLE);\n+    }\n+\n+    /**\n+     * TODO: Leverage the device code storage for tracking authentication requests. Not sure if we need a specific storage,\n+     * but probably make the {@link OAuth2DeviceTokenStoreProvider} more generic for ciba, device, or any other use case\n+     * that relies on cross-references for unsolicited user authentication requests from devices.\n+     */\n+    private void storeAuthenticationRequest(AuthenticationRequest request, CibaConfig cibaConfig) {\n+        ClientModel client = request.getClient();\n+        int expiresIn = cibaConfig.getExpiresIn();\n+        int poolingInterval = cibaConfig.getPoolingInterval();\n+\n+        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,\n+                request.getId(), request.getScope(), null, expiresIn, poolingInterval,\n+                Collections.emptyMap());\n+        String authResultId = request.getAuthResultId();\n+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(),\n+                authResultId);\n+\n+        // To inform \"expired_token\" to the client, the lifespan of the cache provider is longer than device code\n+        int lifespanSeconds = expiresIn + poolingInterval + 10;\n+\n+        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);\n+\n+        store.put(deviceCode, userCode, lifespanSeconds);\n+    }\n+\n+    private AuthenticationRequest authorizeClient(MultivaluedMap<String, String> params) {\n+        ClientModel client = authenticateClient();\n+        UserModel user = resolveUser(params, realm.getCibaPolicy().getAuthRequestedUserHint());\n+\n+        AuthenticationRequest request = new AuthenticationRequest(session, user, client);\n+\n+        request.setClient(client);\n+\n+        String scope = params.getFirst(OAuth2Constants.SCOPE);\n+\n+        if (scope == null)\n+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, \"missing parameter : scope\",\n+                    Response.Status.BAD_REQUEST);\n+\n+        request.setScope(scope);\n+\n+        request.setBindingMessage(params.getFirst(CibaGrantType.BINDING_MESSAGE));\n+\n+        CibaConfig policy = realm.getCibaPolicy();\n+\n+        // create JWE encoded auth_req_id from Auth Req ID.\n+        Integer expiresIn = policy.getExpiresIn();\n+        String requestedExpiry = params.getFirst(CibaGrantType.REQUESTED_EXPIRY);\n+\n+        if (requestedExpiry != null) {\n+            expiresIn = Integer.valueOf(requestedExpiry);\n+        }\n+\n+        request.exp(Time.currentTime() + expiresIn.longValue());\n+\n+        StringBuilder scopes = new StringBuilder(Optional.ofNullable(request.getScope()).orElse(\"\"));\n+        client.getClientScopes(true, true)\n+                .forEach((key, value) -> {\n+                    if (value.isDisplayOnConsentScreen())\n+                        scopes.append(\" \").append(value.getName());\n+                });\n+        request.setScope(scopes.toString());\n+\n+        String clientNotificationToken = params.getFirst(CibaGrantType.CLIENT_NOTIFICATION_TOKEN);\n+\n+        if (clientNotificationToken != null) {\n+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST,\n+                    \"Ping and push modes not supported. Use poll mode instead.\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        String userCode = params.getFirst(OAuth2Constants.USER_CODE);\n+\n+        if (userCode != null) {\n+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, \"User code not supported\",\n+                    Response.Status.BAD_REQUEST);\n+        }\n+\n+        String acrValues = params.getFirst(OAuth2Constants.ACR_VALUES);\n+\n+        if (acrValues != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyMTAyNg==", "bodyText": "@tnorimat @pedroigor AFAIK this endpoint contains lots of proprietary non-standard CIBA parameters specific to the particular authentication channel. For example parameters like authentication_channel_id or auth_result . In this regards, I am not sure if it rather makes sense to move some parts regarding to parsing this request to the HttpAuthenticationChannelProvider?\nMy understanding is, that it might be ideal if implemetation of the AuthenticationChannelProvider contains all the stuff related to the \"proprietary\" part of the CIBA protocol for the communication between Keycloak server and Authentication Channel. In this regards, I vote for add the \"callback\" method to AuthenticationChannelProvider interface and implement the processing of the callback request inside AuthenticationChannelPRovider. So that if someone wants to introduce the custom protocol for the communication between Keycloak and Authentication Channel, he just needs to implement his own AuthenticationChannelProvider. Not also the callback endpoint, which is currently implemented in the BackchannelAuthenticationCallbackEndpoint. WDYT?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599421026", "createdAt": "2021-03-23T09:55:03Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import static org.keycloak.events.Errors.DIFFERENT_USER_AUTHENTICATED;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.util.HttpHeaderNames;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.services.ErrorResponseException;\n+\n+public class BackchannelAuthenticationCallbackEndpoint extends AbstractCibaEndpoint {\n+\n+    public static final String SUCCEEDED = \"succeeded\";\n+    public static final String UNAUTHORIZED = \"unauthorized\";\n+    public static final String CANCELLED = \"cancelled\";\n+\n+    @Context\n+    private HttpRequest httpRequest;\n+\n+    public BackchannelAuthenticationCallbackEndpoint(KeycloakSession session, EventBuilder event) {\n+        super(session, event);\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processAuthenticationChannelResult() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNDMyMw==", "bodyText": "@tnorimat @pedroigor Sorry for the dummy question (as maybe it is my lack of understanding protocol), but does BackchannelAuthenticationCallbackEndpoint really needs client authentication? My understanding is, that this endpoint is usually invoked by the \"Authentication Channel\" once it completes the authentication of the user with the authentication device. And the \"Authentication Channel\" won't have access to client credentials?\nIf it is the client, which is supposed to send the request to callback endpoint, then there won't be a need for the polling mechanism described in the CIBA specification. IMO the whole point of polling mechanism is, that client doesn't know when exactly is authentication between user and authentication channel finished.\nMy understanding is, that this Keycloak endpoint is able to parse the JWE sent in the authentication_channel_id parameter and IMO this is the verification that HTTP request to this endpoint was sent from the real authentication channel (the one implemented by the HttpAuthenticationChannelProvider). Hence no point for client authentication in this endpoint. WDYT?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599424323", "createdAt": "2021-03-23T09:59:26Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import static org.keycloak.events.Errors.DIFFERENT_USER_AUTHENTICATED;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.util.HttpHeaderNames;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.services.ErrorResponseException;\n+\n+public class BackchannelAuthenticationCallbackEndpoint extends AbstractCibaEndpoint {\n+\n+    public static final String SUCCEEDED = \"succeeded\";\n+    public static final String UNAUTHORIZED = \"unauthorized\";\n+    public static final String CANCELLED = \"cancelled\";\n+\n+    @Context\n+    private HttpRequest httpRequest;\n+\n+    public BackchannelAuthenticationCallbackEndpoint(KeycloakSession session, EventBuilder event) {\n+        super(session, event);\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processAuthenticationChannelResult() {\n+        event.event(EventType.LOGIN);\n+\n+        authenticateClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNjA4MQ==", "bodyText": "Minor: I vote to rename this class to CIBAAuthenticationRequest. We already have class \"AuthenticationRequest\" used by brokering, so it may help to avoid some confusions. In theory package name differentiation should be sufficient, but still sometimes the confusion can easily happen for the duplicated class names. But maybe it is just me... :-)", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599426081", "createdAt": "2021-03-23T10:01:55Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/AuthenticationRequest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ *\n+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates\n+ *  * and other contributors as indicated by the @author tags.\n+ *  *\n+ *  * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  * you may not use this file except in compliance with the License.\n+ *  * You may obtain a copy of the License at\n+ *  *\n+ *  * http://www.apache.org/licenses/LICENSE-2.0\n+ *  *\n+ *  * Unless required by applicable law or agreed to in writing, software\n+ *  * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  * See the License for the specific language governing permissions and\n+ *  * limitations under the License.\n+ *\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.channel;\n+\n+import javax.crypto.SecretKey;\n+import java.io.UnsupportedEncodingException;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.crypto.Algorithm;\n+import org.keycloak.crypto.KeyUse;\n+import org.keycloak.crypto.SignatureProvider;\n+import org.keycloak.crypto.SignatureSignerContext;\n+import org.keycloak.jose.jwe.JWEException;\n+import org.keycloak.jose.jws.JWSBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.representations.IDToken;\n+import org.keycloak.representations.JsonWebToken;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.keycloak.services.Urls;\n+import org.keycloak.util.TokenUtil;\n+\n+/**\n+ * <p>Represents an authentication request sent by a consumption device.\n+ *\n+ * <p>A authentication request can be serialized to a JWE so that they can be exchanged with authentication devices to communicate\n+ * and authorize the authentication request made by consumption devices.\n+ */\n+public class AuthenticationRequest extends JsonWebToken {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNjMxMg==", "bodyText": "The \"sessionState\" is not used at all in the AuthenticationRequest. It is always null. Should we remove this parameter?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599426312", "createdAt": "2021-03-23T10:02:12Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/AuthenticationRequest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ *\n+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates\n+ *  * and other contributors as indicated by the @author tags.\n+ *  *\n+ *  * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  * you may not use this file except in compliance with the License.\n+ *  * You may obtain a copy of the License at\n+ *  *\n+ *  * http://www.apache.org/licenses/LICENSE-2.0\n+ *  *\n+ *  * Unless required by applicable law or agreed to in writing, software\n+ *  * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  * See the License for the specific language governing permissions and\n+ *  * limitations under the License.\n+ *\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.channel;\n+\n+import javax.crypto.SecretKey;\n+import java.io.UnsupportedEncodingException;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.crypto.Algorithm;\n+import org.keycloak.crypto.KeyUse;\n+import org.keycloak.crypto.SignatureProvider;\n+import org.keycloak.crypto.SignatureSignerContext;\n+import org.keycloak.jose.jwe.JWEException;\n+import org.keycloak.jose.jws.JWSBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.representations.IDToken;\n+import org.keycloak.representations.JsonWebToken;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.keycloak.services.Urls;\n+import org.keycloak.util.TokenUtil;\n+\n+/**\n+ * <p>Represents an authentication request sent by a consumption device.\n+ *\n+ * <p>A authentication request can be serialized to a JWE so that they can be exchanged with authentication devices to communicate\n+ * and authorize the authentication request made by consumption devices.\n+ */\n+public class AuthenticationRequest extends JsonWebToken {\n+\n+    /**\n+     * Deserialize the given {@code jwe} to a {@link AuthenticationRequest} instance.\n+     *\n+     * @param session the session\n+     * @param jwe the authentication request in JWE format.\n+     * @return the authentication request instance\n+     * @throws Exception\n+     */\n+    public static AuthenticationRequest deserialize(KeycloakSession session, String jwe) {\n+        SecretKey aesKey = session.keys().getActiveKey(session.getContext().getRealm(), KeyUse.ENC, Algorithm.AES).getSecretKey();\n+        SecretKey hmacKey = session.keys().getActiveKey(session.getContext().getRealm(), KeyUse.SIG, Algorithm.HS256).getSecretKey();\n+\n+        try {\n+            byte[] contentBytes = TokenUtil.jweDirectVerifyAndDecode(aesKey, hmacKey, jwe);\n+            jwe = new String(contentBytes, \"UTF-8\");\n+        } catch (JWEException | UnsupportedEncodingException e) {\n+            throw new RuntimeException(\"Error decoding auth_req_id.\", e);\n+        }\n+\n+        return session.tokens().decode(jwe, AuthenticationRequest.class);\n+    }\n+\n+    public static final String SESSION_STATE = IDToken.SESSION_STATE;\n+    public static final String AUTH_RESULT_ID = \"auth_result_id\";\n+\n+    @JsonProperty(OAuth2Constants.SCOPE)\n+    protected String scope;\n+\n+    @JsonProperty(SESSION_STATE)\n+    protected String sessionState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNzU5Nw==", "bodyText": "It can be good to remove \"codeId\", \"sessionId\" and \"isOfflineAccess\" entirely from this method signature? It seems they are either always null or not used at all.\nSame for the other \"doBackchannelAuthenticationTokenRequest\" method below.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599427597", "createdAt": "2021-03-23T10:04:03Z", "author": {"login": "mposolda"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/CIBATest.java", "diffHunk": "@@ -0,0 +1,1196 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.testsuite.client;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.containsString;\n+\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+\n+import static org.junit.Assert.assertThat;\n+import static org.keycloak.OAuthErrorException.INVALID_REQUEST;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.CANCELLED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.SUCCEEDED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.UNAUTHORIZED;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.QUARKUS;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.REMOTE;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.admin.client.resource.ClientResource;\n+import org.keycloak.common.Profile;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProviderFactory;\n+import org.keycloak.representations.AccessToken;\n+import org.keycloak.representations.IDToken;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.EventRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.admin.ApiUtil;\n+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude;\n+import org.keycloak.testsuite.arquillian.annotation.EnableCiba;\n+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;\n+import org.keycloak.testsuite.ciba.AuthenticationChannelRequest;\n+import org.keycloak.testsuite.client.resources.TestApplicationResourceUrls;\n+import org.keycloak.testsuite.client.resources.TestOIDCEndpointsApplicationResource;\n+import org.keycloak.testsuite.util.KeycloakModelUtils;\n+import org.keycloak.testsuite.util.Matchers;\n+import org.keycloak.testsuite.util.OAuthClient;\n+import org.keycloak.testsuite.util.UserBuilder;\n+import org.keycloak.testsuite.util.OAuthClient.AuthenticationRequestAcknowledgement;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.keycloak.testsuite.util.WaitUtils;\n+\n+@EnableCiba\n+@EnableFeature(value = Profile.Feature.CIBA, skipRestart = true)\n+@AuthServerContainerExclude({REMOTE, QUARKUS})\n+public class CIBATest extends AbstractTestRealmKeycloakTest {\n+\n+    private final String AUTHENTICATION_CHANNEL_SERVER_NAME = \"authentication-channel-server\";\n+    private final String AUTHENTICATION_CHANNEL_SERVER_PASSWORD = \"passwort-authentication-channel-server\";\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    @Override\n+    public void configureTestRealm(RealmRepresentation testRealm) {\n+\n+        UserRepresentation user = UserBuilder.create()\n+                .username(\"nutzername-schwarz\")\n+                .email(\"schwarz@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-schwarz\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-rot\")\n+                .email(\"rot@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-rot\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-gelb\")\n+                .email(\"gelb@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-gelb\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-deaktiviert\")\n+                .email(\"deaktiviert@test.example.com\")\n+                .enabled(false)\n+                .password(\"passwort-deaktiviert\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        ClientRepresentation confApp = KeycloakModelUtils.createClient(testRealm, AUTHENTICATION_CHANNEL_SERVER_NAME);\n+        confApp.setSecret(AUTHENTICATION_CHANNEL_SERVER_PASSWORD);\n+        confApp.setServiceAccountsEnabled(Boolean.TRUE);\n+\n+    }\n+\n+    @BeforeClass\n+    public static void setAuthenticationChannelRequestUri() {\n+        System.setProperty(\"keycloak.ciba.auth.channel.provider\", HttpAuthenticationChannelProviderFactory.PROVIDER_ID);\n+        System.setProperty(\"keycloak.ciba.http.auth.channel.uri\", TestApplicationResourceUrls.clientAuthenticationChannelRequestUri());\n+    }\n+\n+    private String cibaBackchannelTokenDeliveryMode;\n+    private Integer cibaExpiresIn;\n+    private Integer cibaInterval;\n+    private String cibaAuthRequestedUserHint;\n+\n+    private final String TEST_REALM_NAME = \"test\";\n+    private final String TEST_CLIENT_NAME = \"test-app\";\n+    private final String TEST_CLIENT_PASSWORD = \"password\";\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String username) throws Exception {\n+        return doBackchannelAuthenticationRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, username, null);\n+    }\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String clientId, String clientSecret, String username, String bindingMessage) throws Exception {\n+        AuthenticationRequestAcknowledgement response = oauth.doBackchannelAuthenticationRequest(clientId, clientSecret, username, bindingMessage);\n+        Assert.assertThat(response.getStatusCode(), is(equalTo(200)));\n+        Assert.assertNotNull(response.getAuthReqId());\n+        return response;\n+    }\n+\n+    private AuthenticationChannelRequest doAuthenticationChannelRequest() {\n+        // get Authentication Channel Request keycloak has done on Backchannel Authentication Endpoint from the FIFO queue of testing Authentication Channel Request API\n+        TestOIDCEndpointsApplicationResource oidcClientEndpointsResource = testingClient.testApp().oidcClientEndpoints();\n+        AuthenticationChannelRequest authenticationChannelReq = oidcClientEndpointsResource.getAuthenticationChannel();\n+        return authenticationChannelReq;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        return doAuthenticationChannelCallback(TEST_CLIENT_NAME, authenticationChannelReq, authenticationChannelStatus, username);\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientIdAsConsumerDevice, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(200)));\n+        // check login event : ignore user id and other details except for username\n+        EventRepresentation representation = new EventRepresentation();\n+\n+        representation.setDetails(Collections.emptyMap());\n+\n+        return representation;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(200)));\n+        return events.expect(EventType.LOGIN_ERROR).clearDetails().client(clientId).error(error).user((String)null).session(CoreMatchers.nullValue(String.class)).assertEvent();\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallbackError(Status status, String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(status.getStatusCode())));\n+        return events.expect(EventType.LOGIN_ERROR).clearDetails().client(clientId).error(error).user((String)null).session(CoreMatchers.nullValue(String.class)).assertEvent();\n+    }\n+\n+    private OAuthClient.AccessTokenResponse doBackchannelAuthenticationTokenRequest(String codeId, String sessionId, String username, String authReqId, boolean isOfflineAccess) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyODYwNg==", "bodyText": "It seems this method is not used and can be removed", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599428606", "createdAt": "2021-03-23T10:05:22Z", "author": {"login": "mposolda"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/CIBATest.java", "diffHunk": "@@ -0,0 +1,1196 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.testsuite.client;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.containsString;\n+\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+\n+import static org.junit.Assert.assertThat;\n+import static org.keycloak.OAuthErrorException.INVALID_REQUEST;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.CANCELLED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.SUCCEEDED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.UNAUTHORIZED;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.QUARKUS;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.REMOTE;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.admin.client.resource.ClientResource;\n+import org.keycloak.common.Profile;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProviderFactory;\n+import org.keycloak.representations.AccessToken;\n+import org.keycloak.representations.IDToken;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.EventRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.admin.ApiUtil;\n+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude;\n+import org.keycloak.testsuite.arquillian.annotation.EnableCiba;\n+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;\n+import org.keycloak.testsuite.ciba.AuthenticationChannelRequest;\n+import org.keycloak.testsuite.client.resources.TestApplicationResourceUrls;\n+import org.keycloak.testsuite.client.resources.TestOIDCEndpointsApplicationResource;\n+import org.keycloak.testsuite.util.KeycloakModelUtils;\n+import org.keycloak.testsuite.util.Matchers;\n+import org.keycloak.testsuite.util.OAuthClient;\n+import org.keycloak.testsuite.util.UserBuilder;\n+import org.keycloak.testsuite.util.OAuthClient.AuthenticationRequestAcknowledgement;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.keycloak.testsuite.util.WaitUtils;\n+\n+@EnableCiba\n+@EnableFeature(value = Profile.Feature.CIBA, skipRestart = true)\n+@AuthServerContainerExclude({REMOTE, QUARKUS})\n+public class CIBATest extends AbstractTestRealmKeycloakTest {\n+\n+    private final String AUTHENTICATION_CHANNEL_SERVER_NAME = \"authentication-channel-server\";\n+    private final String AUTHENTICATION_CHANNEL_SERVER_PASSWORD = \"passwort-authentication-channel-server\";\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    @Override\n+    public void configureTestRealm(RealmRepresentation testRealm) {\n+\n+        UserRepresentation user = UserBuilder.create()\n+                .username(\"nutzername-schwarz\")\n+                .email(\"schwarz@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-schwarz\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-rot\")\n+                .email(\"rot@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-rot\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-gelb\")\n+                .email(\"gelb@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-gelb\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-deaktiviert\")\n+                .email(\"deaktiviert@test.example.com\")\n+                .enabled(false)\n+                .password(\"passwort-deaktiviert\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        ClientRepresentation confApp = KeycloakModelUtils.createClient(testRealm, AUTHENTICATION_CHANNEL_SERVER_NAME);\n+        confApp.setSecret(AUTHENTICATION_CHANNEL_SERVER_PASSWORD);\n+        confApp.setServiceAccountsEnabled(Boolean.TRUE);\n+\n+    }\n+\n+    @BeforeClass\n+    public static void setAuthenticationChannelRequestUri() {\n+        System.setProperty(\"keycloak.ciba.auth.channel.provider\", HttpAuthenticationChannelProviderFactory.PROVIDER_ID);\n+        System.setProperty(\"keycloak.ciba.http.auth.channel.uri\", TestApplicationResourceUrls.clientAuthenticationChannelRequestUri());\n+    }\n+\n+    private String cibaBackchannelTokenDeliveryMode;\n+    private Integer cibaExpiresIn;\n+    private Integer cibaInterval;\n+    private String cibaAuthRequestedUserHint;\n+\n+    private final String TEST_REALM_NAME = \"test\";\n+    private final String TEST_CLIENT_NAME = \"test-app\";\n+    private final String TEST_CLIENT_PASSWORD = \"password\";\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String username) throws Exception {\n+        return doBackchannelAuthenticationRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, username, null);\n+    }\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String clientId, String clientSecret, String username, String bindingMessage) throws Exception {\n+        AuthenticationRequestAcknowledgement response = oauth.doBackchannelAuthenticationRequest(clientId, clientSecret, username, bindingMessage);\n+        Assert.assertThat(response.getStatusCode(), is(equalTo(200)));\n+        Assert.assertNotNull(response.getAuthReqId());\n+        return response;\n+    }\n+\n+    private AuthenticationChannelRequest doAuthenticationChannelRequest() {\n+        // get Authentication Channel Request keycloak has done on Backchannel Authentication Endpoint from the FIFO queue of testing Authentication Channel Request API\n+        TestOIDCEndpointsApplicationResource oidcClientEndpointsResource = testingClient.testApp().oidcClientEndpoints();\n+        AuthenticationChannelRequest authenticationChannelReq = oidcClientEndpointsResource.getAuthenticationChannel();\n+        return authenticationChannelReq;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        return doAuthenticationChannelCallback(TEST_CLIENT_NAME, authenticationChannelReq, authenticationChannelStatus, username);\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientIdAsConsumerDevice, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(200)));\n+        // check login event : ignore user id and other details except for username\n+        EventRepresentation representation = new EventRepresentation();\n+\n+        representation.setDetails(Collections.emptyMap());\n+\n+        return representation;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQzMDg2OA==", "bodyText": "@tnorimat  @pedroigor This is only testsuite related concern, but my vote is that method \"doAuthenticationChannelRequest()\" accepts the bindingMessage as an argument and that the bindingMessage is sent to the testing endpoint. And also that the testing endpoint checks the \"bindingMessage\" equals to the previously saved request. This is minor testsuite related concern, but IMO it may help the \"newbie\" to understand CIBA protocols a bit better.\nIn general, the CIBA protocol is quite hard to understand for the newbies IMO as there is big amount of various HTTP requests sent among various parties. And hence it helps a bit if the testsuite related requests are also a bit \"logical\" and represents the reality, which will be used by the CIBA protocol in production. And IMO in reality, the request from the user to AuthenticationChannel will need to contain the \"bindingMessage\" as in reality AuthenticationChannel can contain many different requests from different users and bindingMessage would be used to bind the request with the actual user. For same reason, I vote to change the BlockingQueue in the TestingOIDCEndpointsApplicationResource to be the Map where the key is the \"bindingMessage\" and the value the actual request. WDYT?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599430868", "createdAt": "2021-03-23T10:08:09Z", "author": {"login": "mposolda"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/CIBATest.java", "diffHunk": "@@ -0,0 +1,1196 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.testsuite.client;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.containsString;\n+\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+\n+import static org.junit.Assert.assertThat;\n+import static org.keycloak.OAuthErrorException.INVALID_REQUEST;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.CANCELLED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.SUCCEEDED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.UNAUTHORIZED;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.QUARKUS;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.REMOTE;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.admin.client.resource.ClientResource;\n+import org.keycloak.common.Profile;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProviderFactory;\n+import org.keycloak.representations.AccessToken;\n+import org.keycloak.representations.IDToken;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.EventRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.admin.ApiUtil;\n+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude;\n+import org.keycloak.testsuite.arquillian.annotation.EnableCiba;\n+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;\n+import org.keycloak.testsuite.ciba.AuthenticationChannelRequest;\n+import org.keycloak.testsuite.client.resources.TestApplicationResourceUrls;\n+import org.keycloak.testsuite.client.resources.TestOIDCEndpointsApplicationResource;\n+import org.keycloak.testsuite.util.KeycloakModelUtils;\n+import org.keycloak.testsuite.util.Matchers;\n+import org.keycloak.testsuite.util.OAuthClient;\n+import org.keycloak.testsuite.util.UserBuilder;\n+import org.keycloak.testsuite.util.OAuthClient.AuthenticationRequestAcknowledgement;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.keycloak.testsuite.util.WaitUtils;\n+\n+@EnableCiba\n+@EnableFeature(value = Profile.Feature.CIBA, skipRestart = true)\n+@AuthServerContainerExclude({REMOTE, QUARKUS})\n+public class CIBATest extends AbstractTestRealmKeycloakTest {\n+\n+    private final String AUTHENTICATION_CHANNEL_SERVER_NAME = \"authentication-channel-server\";\n+    private final String AUTHENTICATION_CHANNEL_SERVER_PASSWORD = \"passwort-authentication-channel-server\";\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    @Override\n+    public void configureTestRealm(RealmRepresentation testRealm) {\n+\n+        UserRepresentation user = UserBuilder.create()\n+                .username(\"nutzername-schwarz\")\n+                .email(\"schwarz@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-schwarz\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-rot\")\n+                .email(\"rot@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-rot\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-gelb\")\n+                .email(\"gelb@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-gelb\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-deaktiviert\")\n+                .email(\"deaktiviert@test.example.com\")\n+                .enabled(false)\n+                .password(\"passwort-deaktiviert\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        ClientRepresentation confApp = KeycloakModelUtils.createClient(testRealm, AUTHENTICATION_CHANNEL_SERVER_NAME);\n+        confApp.setSecret(AUTHENTICATION_CHANNEL_SERVER_PASSWORD);\n+        confApp.setServiceAccountsEnabled(Boolean.TRUE);\n+\n+    }\n+\n+    @BeforeClass\n+    public static void setAuthenticationChannelRequestUri() {\n+        System.setProperty(\"keycloak.ciba.auth.channel.provider\", HttpAuthenticationChannelProviderFactory.PROVIDER_ID);\n+        System.setProperty(\"keycloak.ciba.http.auth.channel.uri\", TestApplicationResourceUrls.clientAuthenticationChannelRequestUri());\n+    }\n+\n+    private String cibaBackchannelTokenDeliveryMode;\n+    private Integer cibaExpiresIn;\n+    private Integer cibaInterval;\n+    private String cibaAuthRequestedUserHint;\n+\n+    private final String TEST_REALM_NAME = \"test\";\n+    private final String TEST_CLIENT_NAME = \"test-app\";\n+    private final String TEST_CLIENT_PASSWORD = \"password\";\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String username) throws Exception {\n+        return doBackchannelAuthenticationRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, username, null);\n+    }\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String clientId, String clientSecret, String username, String bindingMessage) throws Exception {\n+        AuthenticationRequestAcknowledgement response = oauth.doBackchannelAuthenticationRequest(clientId, clientSecret, username, bindingMessage);\n+        Assert.assertThat(response.getStatusCode(), is(equalTo(200)));\n+        Assert.assertNotNull(response.getAuthReqId());\n+        return response;\n+    }\n+\n+    private AuthenticationChannelRequest doAuthenticationChannelRequest() {\n+        // get Authentication Channel Request keycloak has done on Backchannel Authentication Endpoint from the FIFO queue of testing Authentication Channel Request API\n+        TestOIDCEndpointsApplicationResource oidcClientEndpointsResource = testingClient.testApp().oidcClientEndpoints();\n+        AuthenticationChannelRequest authenticationChannelReq = oidcClientEndpointsResource.getAuthenticationChannel();\n+        return authenticationChannelReq;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        return doAuthenticationChannelCallback(TEST_CLIENT_NAME, authenticationChannelReq, authenticationChannelStatus, username);\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientIdAsConsumerDevice, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(200)));\n+        // check login event : ignore user id and other details except for username\n+        EventRepresentation representation = new EventRepresentation();\n+\n+        representation.setDetails(Collections.emptyMap());\n+\n+        return representation;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(200)));\n+        return events.expect(EventType.LOGIN_ERROR).clearDetails().client(clientId).error(error).user((String)null).session(CoreMatchers.nullValue(String.class)).assertEvent();\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallbackError(Status status, String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(status.getStatusCode())));\n+        return events.expect(EventType.LOGIN_ERROR).clearDetails().client(clientId).error(error).user((String)null).session(CoreMatchers.nullValue(String.class)).assertEvent();\n+    }\n+\n+    private OAuthClient.AccessTokenResponse doBackchannelAuthenticationTokenRequest(String codeId, String sessionId, String username, String authReqId, boolean isOfflineAccess) throws Exception {\n+        return doBackchannelAuthenticationTokenRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, codeId, sessionId, username, authReqId, isOfflineAccess);\n+    }\n+\n+    private OAuthClient.AccessTokenResponse doBackchannelAuthenticationTokenRequest(String clientId, String clientSecret, String codeId, String sessionId, String username, String authReqId, boolean isOfflineAccess) throws Exception {\n+        OAuthClient.AccessTokenResponse tokenRes = oauth.doBackchannelAuthenticationTokenRequest(clientId, clientSecret, authReqId);\n+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(200)));\n+        EventRepresentation event = events.expectAuthReqIdToToken(codeId, sessionId).clearDetails().user(AssertEvents.isUUID()).client(clientId).assertEvent();\n+\n+        AccessToken accessToken = oauth.verifyToken(tokenRes.getAccessToken());\n+        Assert.assertThat(accessToken.getIssuedFor(), is(equalTo(clientId)));\n+\n+        RefreshToken refreshToken = oauth.parseRefreshToken(tokenRes.getRefreshToken());\n+        Assert.assertThat(refreshToken.getIssuedFor(), is(equalTo(clientId)));\n+        Assert.assertThat(refreshToken.getAudience()[0], is(equalTo(refreshToken.getIssuer())));\n+\n+        IDToken idToken = oauth.verifyIDToken(tokenRes.getIdToken());\n+        Assert.assertThat(idToken.getPreferredUsername(), is(equalTo(username)));\n+        Assert.assertThat(idToken.getIssuedFor(), is(equalTo(clientId)));\n+        Assert.assertThat(idToken.getAudience()[0], is(equalTo(idToken.getIssuedFor())));\n+\n+        return tokenRes;\n+    }\n+\n+    private String doIntrospectAccessTokenWithClientCredential(OAuthClient.AccessTokenResponse tokenRes, String username) throws IOException {\n+        String tokenResponse = oauth.introspectAccessTokenWithClientCredential(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, tokenRes.getAccessToken());\n+        ObjectMapper objectMapper = new ObjectMapper();\n+        JsonNode jsonNode = objectMapper.readTree(tokenResponse);\n+        Assert.assertThat(jsonNode.get(\"active\").asBoolean(), is(equalTo(true)));\n+        Assert.assertThat(jsonNode.get(\"username\").asText(), is(equalTo(username)));\n+        Assert.assertThat(jsonNode.get(\"client_id\").asText(), is(equalTo(TEST_CLIENT_NAME)));\n+        TokenMetadataRepresentation rep = objectMapper.readValue(tokenResponse, TokenMetadataRepresentation.class);\n+        Assert.assertThat(rep.isActive(), is(equalTo(true)));\n+        Assert.assertThat(rep.getClientId(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(rep.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        events.expect(EventType.INTROSPECT_TOKEN).user((String)null).clearDetails().assertEvent();\n+\n+        tokenResponse = oauth.introspectAccessTokenWithClientCredential(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, tokenRes.getRefreshToken());\n+        jsonNode = objectMapper.readTree(tokenResponse);\n+        Assert.assertThat(jsonNode.get(\"active\").asBoolean(), is(equalTo(true)));\n+        Assert.assertThat(jsonNode.get(\"client_id\").asText(), is(equalTo(TEST_CLIENT_NAME)));\n+        rep = objectMapper.readValue(tokenResponse, TokenMetadataRepresentation.class);\n+        Assert.assertThat(rep.isActive(), is(equalTo(true)));\n+        Assert.assertThat(rep.getClientId(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(rep.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(rep.getAudience()[0], is(equalTo(rep.getIssuer())));\n+        events.expect(EventType.INTROSPECT_TOKEN).user((String)null).clearDetails().assertEvent();\n+\n+        tokenResponse = oauth.introspectAccessTokenWithClientCredential(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, tokenRes.getIdToken());\n+        jsonNode = objectMapper.readTree(tokenResponse);\n+        Assert.assertThat(jsonNode.get(\"active\").asBoolean(), is(equalTo(true)));\n+        Assert.assertThat(jsonNode.get(\"client_id\").asText(), is(equalTo(TEST_CLIENT_NAME)));\n+        rep = objectMapper.readValue(tokenResponse, TokenMetadataRepresentation.class);\n+        Assert.assertThat(rep.isActive(), is(equalTo(true)));\n+        Assert.assertThat(rep.getUserName(), is(equalTo(username)));\n+        Assert.assertThat(rep.getClientId(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(rep.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(rep.getPreferredUsername(), is(equalTo(username)));\n+        Assert.assertThat(rep.getAudience()[0], is(equalTo(rep.getIssuedFor())));\n+        events.expect(EventType.INTROSPECT_TOKEN).user((String)null).clearDetails().assertEvent();\n+\n+        return tokenResponse;\n+    }\n+\n+    private OAuthClient.AccessTokenResponse doRefreshTokenRequest(String oldRefreshToken, String username, String sessionId, boolean isOfflineAccess) {\n+        OAuthClient.AccessTokenResponse tokenRes = oauth.doRefreshTokenRequest(oldRefreshToken, TEST_CLIENT_PASSWORD);\n+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(200)));\n+\n+        AccessToken accessToken = oauth.verifyToken(tokenRes.getAccessToken());\n+        Assert.assertThat(accessToken.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(accessToken.getExp().longValue(), is(equalTo(accessToken.getIat().longValue() + tokenRes.getExpiresIn())));\n+\n+        RefreshToken refreshToken = oauth.parseRefreshToken(tokenRes.getRefreshToken());\n+        Assert.assertThat(refreshToken.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(refreshToken.getAudience()[0], is(equalTo(refreshToken.getIssuer())));\n+        if(!isOfflineAccess) Assert.assertThat(refreshToken.getExp().longValue(), is(equalTo(refreshToken.getIat().longValue() + tokenRes.getRefreshExpiresIn())));\n+\n+        IDToken idToken = oauth.verifyIDToken(tokenRes.getIdToken());\n+        Assert.assertThat(idToken.getPreferredUsername(), is(equalTo(username)));\n+        Assert.assertThat(idToken.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(idToken.getAudience()[0], is(equalTo(idToken.getIssuedFor())));\n+        Assert.assertThat(idToken.getExp().longValue(), is(equalTo(idToken.getIat().longValue() + tokenRes.getExpiresIn())));\n+\n+        events.expectRefresh(tokenRes.getRefreshToken(), sessionId).session(CoreMatchers.notNullValue(String.class)).user(AssertEvents.isUUID()).clearDetails().assertEvent();\n+\n+        return tokenRes;\n+    }\n+\n+    private EventRepresentation doLogoutByRefreshToken(String refreshToken, String sessionId, String userId, boolean isOfflineAccess) throws IOException{\n+        try (CloseableHttpResponse res = oauth.doLogout(refreshToken, TEST_CLIENT_PASSWORD)) {\n+            assertThat(res, Matchers.statusCodeIsHC(Status.NO_CONTENT));\n+        }\n+\n+        // confirm logged out\n+        OAuthClient.AccessTokenResponse tokenRes = oauth.doRefreshTokenRequest(refreshToken, TEST_CLIENT_PASSWORD);\n+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(400)));\n+        Assert.assertThat(tokenRes.getError(), is(equalTo(OAuthErrorException.INVALID_GRANT)));\n+        if (isOfflineAccess) Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(\"Offline user session not found\")));\n+        else Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(\"Session not active\")));\n+\n+        return events.expectLogout(sessionId).client(TEST_CLIENT_NAME).user(AssertEvents.isUUID()).session(AssertEvents.isUUID()).clearDetails().assertEvent();\n+    }\n+\n+    private EventRepresentation doTokenRevokeByRefreshToken(String refreshToken, String sessionId, String userId, boolean isOfflineAccess) throws IOException{\n+        try (CloseableHttpResponse res = oauth.doTokenRevoke(refreshToken, \"refresh_token\", TEST_CLIENT_PASSWORD)) {\n+            assertThat(res, Matchers.statusCodeIsHC(Status.OK));\n+        }\n+\n+        // confirm revocation\n+        OAuthClient.AccessTokenResponse tokenRes = oauth.doRefreshTokenRequest(refreshToken, TEST_CLIENT_PASSWORD);\n+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(400)));\n+        Assert.assertThat(tokenRes.getError(), is(equalTo(OAuthErrorException.INVALID_GRANT)));\n+        if (isOfflineAccess) Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(\"Offline user session not found\")));\n+        else Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(\"Session not active\")));\n+\n+        return events.expect(EventType.REVOKE_GRANT).clearDetails().client(TEST_CLIENT_NAME).user(AssertEvents.isUUID()).assertEvent();\n+    }\n+\n+    private void testBackchannelAuthenticationFlow(boolean isOfflineAccess) throws Exception {\n+        ClientResource clientResource = null;\n+        ClientRepresentation clientRep = null;\n+        try {\n+            final String username = \"nutzername-rot\";\n+            final String bindingMessage = \"BASTION\";\n+\n+            // prepare CIBA settings\n+            clientResource = ApiUtil.findClientByClientId(adminClient.realm(TEST_REALM_NAME), TEST_CLIENT_NAME);\n+            clientRep = clientResource.toRepresentation();\n+            prepareCIBASettings(clientResource, clientRep);\n+            if(isOfflineAccess) oauth.scope(OAuth2Constants.OFFLINE_ACCESS);\n+\n+            // user Backchannel Authentication Request\n+            AuthenticationRequestAcknowledgement response = doBackchannelAuthenticationRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, username, bindingMessage);\n+\n+            // user Authentication Channel Request\n+            AuthenticationChannelRequest authenticationChannelReq = doAuthenticationChannelRequest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 336}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4NTAwMzgy", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-618500382", "createdAt": "2021-03-23T11:56:43Z", "commit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMTo1Njo0NFrOI7usWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMTo1Njo0NFrOI7usWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA==", "bodyText": "I've been thinking about this one.\nPerhaps, but I'm not pushing for it now, we could make the payload simpler by:\n\nUse a JWS holding all these parameters. Including the serialized auth_req_id. The JWS would be sent in the body where the AD should support application/json media type. By using a JWS, we would avoid the payload from being tampered and allow ADs to perform a more secure validation by checking signatures, consider expiration of the request, audience, etc.\n\nOne possible exploit I can think about here is in case an attacker intercepts the request and is able to change the scope parameter, potentially causing the device to ask users for scopes that are not really those originally asked by the CD.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599501914", "createdAt": "2021-03-23T11:56:44Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.channel;\n+\n+import static org.keycloak.OAuth2Constants.SCOPE;\n+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.services.resources.Cors;\n+\n+public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{\n+\n+    public static final String AUTHENTICATION_CHANNEL_ID = \"authentication_channel_id\";\n+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = \"user_info\";\n+    public static final String AUTHENTICATION_STATUS = \"auth_result\";\n+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = \"is_consent_required\";\n+\n+    protected KeycloakSession session;\n+    protected MultivaluedMap<String, String> formParams;\n+    protected RealmModel realm;\n+    protected Map<String, String> clientAuthAttributes;\n+    protected Cors cors;\n+    protected final String httpAuthenticationChannelUri;\n+\n+    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {\n+        this.session = session;\n+        this.realm = session.getContext().getRealm();\n+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;\n+    }\n+\n+    @Override\n+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {\n+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id\n+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).\n+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,\n+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.\n+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,\n+        // which can bind authId with Authentication Channel Result of Authentication by AD.\n+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.\n+\n+        // The following scopes should be displayed on AD(Authentication Device):\n+        // 1. scopes specified explicitly as query parameter in the authorization request\n+        // 2. scopes specified implicitly as default client scope in keycloak\n+\n+        checkAuthenticationChannel();\n+\n+        ClientModel client = request.getClient();\n+\n+        try {\n+            // TODO: we should probably just pass the serialized authentication request\n+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80"}, "originalPosition": 75}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "077f83af85195f4db9fffc0f1e245efc12d46f80", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/077f83af85195f4db9fffc0f1e245efc12d46f80", "committedDate": "2021-03-22T12:01:40Z", "message": "Revert \"revert use of RealmRepresentation.getAttributesOrEmpty()\"\n\nThis reverts commit 482d5c90"}, "afterCommit": {"oid": "ed778bbc0ae730a75eb17b8c06761180a8f370f7", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/ed778bbc0ae730a75eb17b8c06761180a8f370f7", "committedDate": "2021-03-24T05:05:56Z", "message": "ignore RealmRepresentation.getAttributesOrEmpty for PermissionsTest"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0adc2720f59778161cb76db5d4eb67bb8beb2390", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/0adc2720f59778161cb76db5d4eb67bb8beb2390", "committedDate": "2021-03-25T03:44:24Z", "message": "add author tag"}, "afterCommit": {"oid": "831c27e719868d70fade0dba77ae932d64a52c1a", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/831c27e719868d70fade0dba77ae932d64a52c1a", "committedDate": "2021-04-12T05:21:04Z", "message": "add c4r1570p4e's commit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0NDQwMDM4", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-634440038", "createdAt": "2021-04-13T10:44:08Z", "commit": {"oid": "da5a0fab4ef08d7088fd67c69d3604eea65f700e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xM1QxMDo0NDowOFrOJH96ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xM1QxMDo0NDowOFrOJH96ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjMzNDIwMw==", "bodyText": "Can you please revert this change?", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r612334203", "createdAt": "2021-04-13T10:44:08Z", "author": {"login": "pedroigor"}, "path": "model/map/src/main/java/org/keycloak/models/map/realm/AbstractRealmEntity.java", "diffHunk": "@@ -97,9 +97,10 @@\n     private String resetCredentialsFlow;\n     private String clientAuthenticationFlow;\n     private String dockerAuthenticationFlow;\n-    private MapOTPPolicyEntity otpPolicy = MapOTPPolicyEntity.fromModel(OTPPolicy.DEFAULT_POLICY);;\n-    private MapWebAuthnPolicyEntity webAuthnPolicy = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;\n-    private MapWebAuthnPolicyEntity webAuthnPolicyPasswordless = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;\n+    private MapOTPPolicyEntity otpPolicy = MapOTPPolicyEntity.fromModel(OTPPolicy.DEFAULT_POLICY);\n+    private MapWebAuthnPolicyEntity webAuthnPolicy = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();\n+    private MapWebAuthnPolicyEntity webAuthnPolicyPasswordless = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da5a0fab4ef08d7088fd67c69d3604eea65f700e"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0NDU5OTE5", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-634459919", "createdAt": "2021-04-13T11:08:52Z", "commit": {"oid": "da5a0fab4ef08d7088fd67c69d3604eea65f700e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xM1QxMTowODo1MlrOJH-0EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xM1QxMTowODo1MlrOJH-0EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjM0ODk0NQ==", "bodyText": "Please, look at my changes here pedroigor@36d4dad#diff-02e6e5ccb2fbf550ae191261cd4daa7e0618fc5e52f3810ea7e69550d0ac3d3fL72.\nWe should avoid using this kind of check and avoid loading any CIBA-related provider by pedroigor@36d4dad#diff-b3048d7253e9d6afa4a39616a9e090326ef3474fc31322f2a797991eeba73a5dR35.\nHere we are using EnvironmentDependentProviderFactory to decide whether or not CIBA providers should be loaded.", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r612348945", "createdAt": "2021-04-13T11:08:52Z", "author": {"login": "pedroigor"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.jboss.resteasy.annotations.cache.NoCache;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.Profile;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.OAuth2DeviceCodeModel;\n+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;\n+import org.keycloak.models.OAuth2DeviceUserCodeModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;\n+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.services.ErrorResponseException;\n+import org.keycloak.util.JsonSerialization;\n+import org.keycloak.utils.ProfileHelper;\n+\n+public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {\n+\n+    private final RealmModel realm;\n+\n+    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {\n+        super(session, event);\n+        this.realm = session.getContext().getRealm();\n+        event.event(EventType.LOGIN);\n+    }\n+\n+    @POST\n+    @NoCache\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processGrantRequest(@Context HttpRequest httpRequest) {\n+        ProfileHelper.requireFeature(Profile.Feature.CIBA);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da5a0fab4ef08d7088fd67c69d3604eea65f700e"}, "originalPosition": 72}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "89ddf701e09e54bdd2ae9300ff55a69352d9c90b", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/89ddf701e09e54bdd2ae9300ff55a69352d9c90b", "committedDate": "2021-04-21T11:45:47Z", "message": "remove not used arguments"}, "afterCommit": {"oid": "f60f13a7ee575ee00bc8324d5bb72d2f8f5ceec9", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/f60f13a7ee575ee00bc8324d5bb72d2f8f5ceec9", "committedDate": "2021-04-22T01:47:05Z", "message": "remove not used arguments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f648a35eaed5cf7df337ac14dd026ee73ef96837", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/f648a35eaed5cf7df337ac14dd026ee73ef96837", "committedDate": "2021-04-28T21:47:19Z", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>\nCo-authored-by: Christophe Lannoy <c4r1570p4e@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d0a282f1d5b3e3fab17e6e66693602cbd8ed9c2", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/2d0a282f1d5b3e3fab17e6e66693602cbd8ed9c2", "committedDate": "2021-04-28T21:47:19Z", "message": "removing ciba flow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebaadaf1d7f7d6af1a5d5d6f9b726ff34e60e4cc", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/ebaadaf1d7f7d6af1a5d5d6f9b726ff34e60e4cc", "committedDate": "2021-04-28T21:47:19Z", "message": "revert ciba flow related tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80f24bbd8731e8ef988485a09b7336e943047d6d", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/80f24bbd8731e8ef988485a09b7336e943047d6d", "committedDate": "2021-04-28T21:47:19Z", "message": "revert removed SAML SCP default auth flow setting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7915f9b49e3b8cea2466cebf7ca6a000219f8e1e", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/7915f9b49e3b8cea2466cebf7ca6a000219f8e1e", "committedDate": "2021-04-28T21:47:20Z", "message": "refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a63da421623a392e18b89160eb5b10900620eee", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/9a63da421623a392e18b89160eb5b10900620eee", "committedDate": "2021-04-28T21:47:20Z", "message": "fix CIBATest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3673a17873f26d225c3ec34d64905afc8af70ebf", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/3673a17873f26d225c3ec34d64905afc8af70ebf", "committedDate": "2021-04-28T21:47:20Z", "message": "fixing backchannel endpoint url"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d80f93a96fc2e56267cd76eeae0dc2df928394f", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/2d80f93a96fc2e56267cd76eeae0dc2df928394f", "committedDate": "2021-04-28T21:47:20Z", "message": "ignore RealmRepresentation.getAttributesOrEmpty for PermissionsTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acee96924e9385d0167ba7c08ef3b51a82e088ab", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/acee96924e9385d0167ba7c08ef3b51a82e088ab", "committedDate": "2021-04-28T21:47:20Z", "message": "add author tag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77419f98cdfc7eab29e37f7fa8e00c7e6b8af314", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/77419f98cdfc7eab29e37f7fa8e00c7e6b8af314", "committedDate": "2021-04-28T22:01:26Z", "message": "ad authentication"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b95bb6a5592b5db26165bc4268f657690ada06e", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/2b95bb6a5592b5db26165bc4268f657690ada06e", "committedDate": "2021-04-28T22:01:33Z", "message": "restore tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "824404af9c286924f0f8493498315ea938e74258", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/824404af9c286924f0f8493498315ea938e74258", "committedDate": "2021-04-28T22:01:33Z", "message": "remove unnecessary factory registration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15f2bc2398bdb7c4def12092e3967f9c685ad936", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/15f2bc2398bdb7c4def12092e3967f9c685ad936", "committedDate": "2021-04-28T22:01:33Z", "message": "partially support optional acr_values parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a7cb02f3a27ddeb24c6a750d484edb17868b5b6", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/9a7cb02f3a27ddeb24c6a750d484edb17868b5b6", "committedDate": "2021-04-28T22:01:33Z", "message": "add c4r1570p4e's commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "965f09c486d4de1b881587be26980914c8e417a2", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/965f09c486d4de1b881587be26980914c8e417a2", "committedDate": "2021-04-28T22:01:33Z", "message": "fix code comments and remove unused codes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70cc31ff06c667d962ede75ceebe7cc2a34f4c8a", "author": {"user": {"login": "mposolda", "name": "Marek Posolda"}}, "url": "https://github.com/keycloak/keycloak/commit/70cc31ff06c667d962ede75ceebe7cc2a34f4c8a", "committedDate": "2021-04-28T22:01:33Z", "message": "Added testAttackerClientUseAuthReqIdInCallbackEndpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4882555bd77f98297d9dbf8f2e2c3700332d8c6c", "author": {"user": {"login": "mposolda", "name": "Marek Posolda"}}, "url": "https://github.com/keycloak/keycloak/commit/4882555bd77f98297d9dbf8f2e2c3700332d8c6c", "committedDate": "2021-04-28T22:01:33Z", "message": "Use Infinispan time service and remove WaitUtils pauses"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5573890e4da627d72e8fa94d2a874a84aff0c3d", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/d5573890e4da627d72e8fa94d2a874a84aff0c3d", "committedDate": "2021-04-28T22:01:33Z", "message": "changes to callback endpoint and ciba feature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e87ebb8cab0258cf537f8eba45726b5128af280", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/1e87ebb8cab0258cf537f8eba45726b5128af280", "committedDate": "2021-04-28T22:01:34Z", "message": "only accept supported backchannel token delivery mode client metadata"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dd1d4b42aeb99ffb407b6df75de7da292146fc6", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/keycloak/keycloak/commit/6dd1d4b42aeb99ffb407b6df75de7da292146fc6", "committedDate": "2021-04-28T22:01:34Z", "message": "fixing auth-server-wildfly tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9879a644f7cf32a7d8d5feec8549b97fe3023ee2", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/9879a644f7cf32a7d8d5feec8549b97fe3023ee2", "committedDate": "2021-04-28T22:01:34Z", "message": "rename CIBAEndpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d1ff848e3b8e6bba980c4e7d9681fb5adcd2a77", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/2d1ff848e3b8e6bba980c4e7d9681fb5adcd2a77", "committedDate": "2021-04-28T22:01:34Z", "message": "rename AuthenticationRequest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28fc9341a362123737cc5f41800de3ad8e98f27d", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/28fc9341a362123737cc5f41800de3ad8e98f27d", "committedDate": "2021-04-28T22:01:34Z", "message": "remove not used arguments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f0b222eedb532c7aa137e4739f9ba1f5c76e982", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/2f0b222eedb532c7aa137e4739f9ba1f5c76e982", "committedDate": "2021-04-28T22:01:34Z", "message": "remove unnecessary server config in json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af4f8a181a92057aa7c6b201c2b1a9c6a5c4df4d", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/af4f8a181a92057aa7c6b201c2b1a9c6a5c4df4d", "committedDate": "2021-04-28T22:01:34Z", "message": "fix OIDCClientRegistrationTest.testCIBASettings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e6cdc682f44cc902cd879a404a3a32a5435e3d2", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/3e6cdc682f44cc902cd879a404a3a32a5435e3d2", "committedDate": "2021-04-28T22:01:34Z", "message": "add ciba grant enable switch per client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a449a9a8cad58fb9323796c7576e4f105006c0b", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/3a449a9a8cad58fb9323796c7576e4f105006c0b", "committedDate": "2021-04-28T22:01:34Z", "message": "convert internal and external rep for ciba grant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc0c8b6eb3fc17e419d80e8bf3c2a6590330b238", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/fc0c8b6eb3fc17e419d80e8bf3c2a6590330b238", "committedDate": "2021-04-28T22:01:35Z", "message": "fix messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42af20907a9fb1c63f670e3f8d1c36e40bd74516", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/42af20907a9fb1c63f670e3f8d1c36e40bd74516", "committedDate": "2021-04-28T22:01:35Z", "message": "move delivery mode setting to CibaConfig"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "722f1ff03a18def0931592afbec05e09474617a4", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/722f1ff03a18def0931592afbec05e09474617a4", "committedDate": "2021-04-28T22:01:35Z", "message": "typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8845be86d8baa428236df89eda4058589087ad46", "author": {"user": {"login": "mposolda", "name": "Marek Posolda"}}, "url": "https://github.com/keycloak/keycloak/commit/8845be86d8baa428236df89eda4058589087ad46", "committedDate": "2021-04-28T22:01:35Z", "message": "Avoid writing to DB during constructor of CibaConfig"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7cfa34662598c06fa19471cfb93a538949ff399", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/d7cfa34662598c06fa19471cfb93a538949ff399", "committedDate": "2021-04-28T04:56:36Z", "message": "typos"}, "afterCommit": {"oid": "8845be86d8baa428236df89eda4058589087ad46", "author": {"user": {"login": "mposolda", "name": "Marek Posolda"}}, "url": "https://github.com/keycloak/keycloak/commit/8845be86d8baa428236df89eda4058589087ad46", "committedDate": "2021-04-28T22:01:35Z", "message": "Avoid writing to DB during constructor of CibaConfig"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ3ODE5Mzcx", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-647819371", "createdAt": "2021-04-29T05:13:16Z", "commit": {"oid": "8845be86d8baa428236df89eda4058589087ad46"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQ4MjM4MzMy", "url": "https://github.com/keycloak/keycloak/pull/7679#pullrequestreview-648238332", "createdAt": "2021-04-29T13:56:00Z", "commit": {"oid": "8845be86d8baa428236df89eda4058589087ad46"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3341, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}