{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MTkyMzIx", "number": 7231, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOToyODowMlrOENBu5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNzo1OToyN1rOEQglNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDk1MzMzOnYy", "diffSide": "RIGHT", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOToyODowMlrOGve1_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNzozNzo0MVrOGxH68g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MTU5OQ==", "bodyText": "What about this method and the other client-specific methods? Should we introduce a ClientCacheSession class and move this functionality there or is this class meant to serve as CacheSession for both of them and then maybe we could rename it?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r452441599", "createdAt": "2020-07-09T19:28:02Z", "author": {"login": "vramik"}, "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java", "diffHunk": "@@ -495,13 +495,13 @@ public void evictRealmOnRemoval(RealmModel realm) {\n \n     @Override\n     public ClientModel addClient(RealmModel realm, String clientId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f87674e9029e9ec313a082d3206329377409544"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE2MzE4Ng==", "bodyText": "Yup, in the long term, this should be the way. This will be handled as part of the caching layer in store.x in some of the follow-up PR", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454163186", "createdAt": "2020-07-14T07:37:41Z", "author": {"login": "hmlnarik"}, "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java", "diffHunk": "@@ -495,13 +495,13 @@ public void evictRealmOnRemoval(RealmModel realm) {\n \n     @Override\n     public ClientModel addClient(RealmModel realm, String clientId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MTU5OQ=="}, "originalCommit": {"oid": "8f87674e9029e9ec313a082d3206329377409544"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDg2MDY2OnYy", "diffSide": "RIGHT", "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzoxNzoxM1rOGxdahg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNjo0NzoyMlrOGxwh4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUxNTMzNA==", "bodyText": "We should change the author as well.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454515334", "createdAt": "2020-07-14T17:17:13Z", "author": {"login": "vramik"}, "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "diffHunk": "@@ -20,30 +20,87 @@\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n-import java.util.Set;\n \n /**\n+ * Provider of the client records.\n+ *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgyODUxNA==", "bodyText": "I don't think we should in this case - Bill is the original author so I'd rather keep it.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454828514", "createdAt": "2020-07-15T06:47:22Z", "author": {"login": "hmlnarik"}, "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "diffHunk": "@@ -20,30 +20,87 @@\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n-import java.util.Set;\n \n /**\n+ * Provider of the client records.\n+ *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUxNTMzNA=="}, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDg3MTU2OnYy", "diffSide": "RIGHT", "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzoyMDowNlrOGxdhSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzoyMDowNlrOGxdhSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUxNzA2NQ==", "bodyText": "javadoc for this method is TODO or it is omitted on purpose?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454517065", "createdAt": "2020-07-14T17:20:06Z", "author": {"login": "vramik"}, "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "diffHunk": "@@ -20,30 +20,87 @@\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n-import java.util.Set;\n \n /**\n+ * Provider of the client records.\n+ *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ClientProvider extends ClientLookupProvider, Provider {\n+\n+    /**\n+     * Returns the clients of the given realm.\n+     * @param realm Realm.\n+     * @param firstResult First result to return. Ignored if negative or {@code null}.\n+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n     List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults);\n \n-    List<ClientModel> getClients(RealmModel realm);\n+    /**\n+     * Returns all the clients of the given realm.\n+     * Effectively the same as the call {@code getClients(realm, null, null)}.\n+     * @param realm Realm.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n+    default List<ClientModel> getClients(RealmModel realm) {\n+        return this.getClients(realm, null, null);\n+    };\n \n-    ClientModel addClient(RealmModel realm, String clientId);\n+    /**\n+     * Adds a client with given {@code clientId} to the given realm.\n+     * The internal ID of the client will be created automatically.\n+     * @param realm Realm owning this client.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     */\n+    default ClientModel addClient(RealmModel realm, String clientId) {\n+        return addClient(realm, null, clientId);\n+    }\n \n+    /**\n+     * Adds a client with given internal ID and {@code clientId} to the given realm.\n+     * @param realm Realm owning this client.\n+     * @param id Internal ID of the client or {@code null} if one is to be created by the underlying store\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     * @throws IllegalArgumentException If {@code id} does not conform\n+     *   the format understood by the underlying store.\n+     */\n     ClientModel addClient(RealmModel realm, String id, String clientId);\n \n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String name);\n-\n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String id, String name);\n+    /**\n+     * Returns number of clients in the given realm\n+     * @param realm Realm.\n+     * @return Number of the clients in the given realm.\n+     */\n+    long getClientsCount(RealmModel realm);\n \n-    RoleModel getClientRole(RealmModel realm, ClientModel client, String name);\n+    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDkwNTQzOnYy", "diffSide": "RIGHT", "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzoyODoyN1rOGxd2Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNzoxNToxNVrOGxxTBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyMjM4Ng==", "bodyText": "Do we really want to introduce default implementation of this method? I can imagine that someone who will implement this interface could potentially forgot to override one of removeClient methods and it would lead to infinite loop, wouldn't it? If I understand it correctly I'd suggest to leave default implementation for removeClient(String id, RealmModel realm) and remove default from this one. Correct me if I am wrong please.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454522386", "createdAt": "2020-07-14T17:28:27Z", "author": {"login": "vramik"}, "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "diffHunk": "@@ -20,30 +20,87 @@\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n-import java.util.Set;\n \n /**\n+ * Provider of the client records.\n+ *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ClientProvider extends ClientLookupProvider, Provider {\n+\n+    /**\n+     * Returns the clients of the given realm.\n+     * @param realm Realm.\n+     * @param firstResult First result to return. Ignored if negative or {@code null}.\n+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n     List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults);\n \n-    List<ClientModel> getClients(RealmModel realm);\n+    /**\n+     * Returns all the clients of the given realm.\n+     * Effectively the same as the call {@code getClients(realm, null, null)}.\n+     * @param realm Realm.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n+    default List<ClientModel> getClients(RealmModel realm) {\n+        return this.getClients(realm, null, null);\n+    };\n \n-    ClientModel addClient(RealmModel realm, String clientId);\n+    /**\n+     * Adds a client with given {@code clientId} to the given realm.\n+     * The internal ID of the client will be created automatically.\n+     * @param realm Realm owning this client.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     */\n+    default ClientModel addClient(RealmModel realm, String clientId) {\n+        return addClient(realm, null, clientId);\n+    }\n \n+    /**\n+     * Adds a client with given internal ID and {@code clientId} to the given realm.\n+     * @param realm Realm owning this client.\n+     * @param id Internal ID of the client or {@code null} if one is to be created by the underlying store\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     * @throws IllegalArgumentException If {@code id} does not conform\n+     *   the format understood by the underlying store.\n+     */\n     ClientModel addClient(RealmModel realm, String id, String clientId);\n \n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String name);\n-\n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String id, String name);\n+    /**\n+     * Returns number of clients in the given realm\n+     * @param realm Realm.\n+     * @return Number of the clients in the given realm.\n+     */\n+    long getClientsCount(RealmModel realm);\n \n-    RoleModel getClientRole(RealmModel realm, ClientModel client, String name);\n+    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);\n \n-    Set<RoleModel> getClientRoles(RealmModel realm, ClientModel client);\n+    /**\n+     * Removes given client from the given realm.\n+     * @param id Internal ID of the client\n+     * @param realm Realm.\n+     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.\n+     * @deprecated Use {@link #removeClient(RealmModel, String)} instead.\n+     */\n+    default boolean removeClient(String id, RealmModel realm) { return this.removeClient(realm, id); }\n \n-    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);\n+    /**\n+     * Removes given client from the given realm.\n+     * @param realm Realm.\n+     * @param id Internal ID of the client\n+     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.\n+     */\n+    default boolean removeClient(RealmModel realm, String id) { return this.removeClient(id, realm); }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg0MTA5Mg==", "bodyText": "Yup, you're right, I'll remove that one", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454841092", "createdAt": "2020-07-15T07:15:15Z", "author": {"login": "hmlnarik"}, "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "diffHunk": "@@ -20,30 +20,87 @@\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n-import java.util.Set;\n \n /**\n+ * Provider of the client records.\n+ *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ClientProvider extends ClientLookupProvider, Provider {\n+\n+    /**\n+     * Returns the clients of the given realm.\n+     * @param realm Realm.\n+     * @param firstResult First result to return. Ignored if negative or {@code null}.\n+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n     List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults);\n \n-    List<ClientModel> getClients(RealmModel realm);\n+    /**\n+     * Returns all the clients of the given realm.\n+     * Effectively the same as the call {@code getClients(realm, null, null)}.\n+     * @param realm Realm.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n+    default List<ClientModel> getClients(RealmModel realm) {\n+        return this.getClients(realm, null, null);\n+    };\n \n-    ClientModel addClient(RealmModel realm, String clientId);\n+    /**\n+     * Adds a client with given {@code clientId} to the given realm.\n+     * The internal ID of the client will be created automatically.\n+     * @param realm Realm owning this client.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     */\n+    default ClientModel addClient(RealmModel realm, String clientId) {\n+        return addClient(realm, null, clientId);\n+    }\n \n+    /**\n+     * Adds a client with given internal ID and {@code clientId} to the given realm.\n+     * @param realm Realm owning this client.\n+     * @param id Internal ID of the client or {@code null} if one is to be created by the underlying store\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     * @throws IllegalArgumentException If {@code id} does not conform\n+     *   the format understood by the underlying store.\n+     */\n     ClientModel addClient(RealmModel realm, String id, String clientId);\n \n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String name);\n-\n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String id, String name);\n+    /**\n+     * Returns number of clients in the given realm\n+     * @param realm Realm.\n+     * @return Number of the clients in the given realm.\n+     */\n+    long getClientsCount(RealmModel realm);\n \n-    RoleModel getClientRole(RealmModel realm, ClientModel client, String name);\n+    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);\n \n-    Set<RoleModel> getClientRoles(RealmModel realm, ClientModel client);\n+    /**\n+     * Removes given client from the given realm.\n+     * @param id Internal ID of the client\n+     * @param realm Realm.\n+     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.\n+     * @deprecated Use {@link #removeClient(RealmModel, String)} instead.\n+     */\n+    default boolean removeClient(String id, RealmModel realm) { return this.removeClient(realm, id); }\n \n-    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);\n+    /**\n+     * Removes given client from the given realm.\n+     * @param realm Realm.\n+     * @param id Internal ID of the client\n+     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.\n+     */\n+    default boolean removeClient(RealmModel realm, String id) { return this.removeClient(id, realm); }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyMjM4Ng=="}, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDkxNzc5OnYy", "diffSide": "RIGHT", "path": "server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzozMToyM1rOGxd9dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzozMToyM1rOGxd9dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNDI3OQ==", "bodyText": "@author", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454524279", "createdAt": "2020-07-14T17:31:23Z", "author": {"login": "vramik"}, "path": "server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.provider.ProviderFactory;\n+import org.keycloak.provider.Spi;\n+\n+/**\n+ * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDkxODk1OnYy", "diffSide": "RIGHT", "path": "server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzozMTo0NFrOGxd-NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjowNDowNFrOGx6-VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNDQ2OA==", "bodyText": "year?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454524468", "createdAt": "2020-07-14T17:31:44Z", "author": {"login": "vramik"}, "path": "server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5OTYzNg==", "bodyText": "May be fix in the next iteration if there would be any further.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454999636", "createdAt": "2020-07-15T12:04:04Z", "author": {"login": "hmlnarik"}, "path": "server-spi-private/src/main/java/org/keycloak/models/ClientSpi.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNDQ2OA=="}, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDkyMDMyOnYy", "diffSide": "RIGHT", "path": "server-spi-private/src/main/java/org/keycloak/models/ClientProviderFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzozMjowOVrOGxd_HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzozMjowOVrOGxd_HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNDcwMA==", "bodyText": "year", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454524700", "createdAt": "2020-07-14T17:32:09Z", "author": {"login": "vramik"}, "path": "server-spi-private/src/main/java/org/keycloak/models/ClientProviderFactory.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDk1MTg3OnYy", "diffSide": "RIGHT", "path": "model/jpa/src/main/resources/META-INF/services/org.keycloak.models.ClientProviderFactory", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzozOTo0M1rOGxeRsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzozOTo0M1rOGxeRsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyOTQ1Nw==", "bodyText": "year", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454529457", "createdAt": "2020-07-14T17:39:43Z", "author": {"login": "vramik"}, "path": "model/jpa/src/main/resources/META-INF/services/org.keycloak.models.ClientProviderFactory", "diffHunk": "@@ -0,0 +1,18 @@\n+#\n+# Copyright 2016 Red Hat, Inc. and/or its affiliates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDk3MDkyOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNzo0NDo0M1rOGxedbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNjo0OTo1NlrOGxwmSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUzMjQ2Mw==", "bodyText": "Shouldn't we use equals instead of == on strings?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454532463", "createdAt": "2020-07-14T17:44:43Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgyOTY0Mw==", "bodyText": "This is object equality to cover also for nulls. For string contents comparison, compareTo is used (below).", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r454829643", "createdAt": "2020-07-15T06:49:56Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUzMjQ2Mw=="}, "originalCommit": {"oid": "427831cd54cffb6ab6bba6f14bbda511028401a3"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTU5OTU0OnYy", "diffSide": "RIGHT", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/ClientAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzoyMTowNFrOGydVqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzoyMTowNFrOGydVqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2MjY2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updated = cacheSession.getClientDelegate().getClientById(cached.getId(), cachedRealm);\n          \n          \n            \n                        updated = cacheSession.getClientDelegate().getClientById(cachedRealm, cached.getId());\n          \n      \n    \n    \n  \n\nWe should use new non-deprecated method instead.\nNewly depricated ClientLookupProvider.getClientById(String, RealmModel), ClientLookupProvider.getClientByClientId(String, RealmModel) and ClientLookupProvider.searchClientsByClientId(String, Integer, Integer, RealmModel) are used in several places in codebase including testsuite.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r455562664", "createdAt": "2020-07-16T07:21:04Z", "author": {"login": "vramik"}, "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/ClientAdapter.java", "diffHunk": "@@ -53,7 +53,7 @@ public ClientAdapter(RealmModel cachedRealm, CachedClient cached, RealmCacheSess\n     private void getDelegateForUpdate() {\n         if (updated == null) {\n             cacheSession.registerClientInvalidation(cached.getId(), cached.getClientId(), cachedRealm.getId());\n-            updated = cacheSession.getRealmDelegate().getClientById(cached.getId(), cachedRealm);\n+            updated = cacheSession.getClientDelegate().getClientById(cached.getId(), cachedRealm);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15a70c6ae3d596f216b2b39e01652daf3b3e236b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTYwOTY2OnYy", "diffSide": "RIGHT", "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzoyNDoxN1rOGydb-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzoyNDoxN1rOGydb-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2NDI4MQ==", "bodyText": "dtto, this deprecated method is still used in the codebase", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r455564281", "createdAt": "2020-07-16T07:24:17Z", "author": {"login": "vramik"}, "path": "server-spi/src/main/java/org/keycloak/models/ClientProvider.java", "diffHunk": "@@ -20,30 +20,92 @@\n import org.keycloak.storage.client.ClientLookupProvider;\n \n import java.util.List;\n-import java.util.Set;\n \n /**\n+ * Provider of the client records.\n+ *\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ClientProvider extends ClientLookupProvider, Provider {\n+\n+    /**\n+     * Returns the clients of the given realm.\n+     * @param realm Realm.\n+     * @param firstResult First result to return. Ignored if negative or {@code null}.\n+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n     List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults);\n \n-    List<ClientModel> getClients(RealmModel realm);\n+    /**\n+     * Returns all the clients of the given realm.\n+     * Effectively the same as the call {@code getClients(realm, null, null)}.\n+     * @param realm Realm.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n+    default List<ClientModel> getClients(RealmModel realm) {\n+        return this.getClients(realm, null, null);\n+    }\n \n-    ClientModel addClient(RealmModel realm, String clientId);\n+    /**\n+     * Adds a client with given {@code clientId} to the given realm.\n+     * The internal ID of the client will be created automatically.\n+     * @param realm Realm owning this client.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     */\n+    default ClientModel addClient(RealmModel realm, String clientId) {\n+        return addClient(realm, null, clientId);\n+    }\n \n+    /**\n+     * Adds a client with given internal ID and {@code clientId} to the given realm.\n+     * @param realm Realm owning this client.\n+     * @param id Internal ID of the client or {@code null} if one is to be created by the underlying store\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the created client.\n+     * @throws IllegalArgumentException If {@code id} does not conform\n+     *   the format understood by the underlying store.\n+     */\n     ClientModel addClient(RealmModel realm, String id, String clientId);\n \n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String name);\n-\n-    RoleModel addClientRole(RealmModel realm, ClientModel client, String id, String name);\n+    /**\n+     * Returns number of clients in the given realm\n+     * @param realm Realm.\n+     * @return Number of the clients in the given realm.\n+     */\n+    long getClientsCount(RealmModel realm);\n \n-    RoleModel getClientRole(RealmModel realm, ClientModel client, String name);\n+    /**\n+     * Returns a list of clients that are expected to always show up in account console.\n+     * @param realm Realm owning the clients.\n+     * @return List of the clients. Never returns {@code null}.\n+     */\n+    List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm);\n \n-    Set<RoleModel> getClientRoles(RealmModel realm, ClientModel client);\n+    /**\n+     * Removes given client from the given realm.\n+     * @param id Internal ID of the client\n+     * @param realm Realm.\n+     * @return {@code true} if the client existed and has been removed, {@code false} otherwise.\n+     * @deprecated Use {@link #removeClient(RealmModel, String)} instead.\n+     */\n+    default boolean removeClient(String id, RealmModel realm) { return this.removeClient(realm, id); }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15a70c6ae3d596f216b2b39e01652daf3b3e236b"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjgwODI4OnYy", "diffSide": "RIGHT", "path": "server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMTowNDoyMFrOGzO6DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMToxMzo0NlrOGzPIaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3NDc5Ng==", "bodyText": "This one is actually not deprecated, right?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456374796", "createdAt": "2020-07-17T11:04:20Z", "author": {"login": "vramik"}, "path": "server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java", "diffHunk": "@@ -28,7 +28,66 @@\n  * @version $Revision: 1 $\n  */\n public interface ClientLookupProvider {\n-    ClientModel getClientById(String id, RealmModel realm);\n-    ClientModel getClientByClientId(String clientId, RealmModel realm);\n-    List<ClientModel> searchClientsByClientId(String clientId, Integer firstResult, Integer maxResults, RealmModel realm);\n+    \n+    /**\n+     * Exact search for a client by its internal ID.\n+     * @param realm Realm to limit the search.\n+     * @param id Internal ID\n+     * @return Model of the client, or {@code null} if no client is found.\n+     */\n+    ClientModel getClientById(RealmModel realm, String id);\n+\n+    /**\n+     * Exact search for a client by its internal ID.\n+     * @param realm Realm to limit the search.\n+     * @param id Internal ID\n+     * @return Model of the client, or {@code null} if no client is found.\n+     * @deprecated Use {@link #getClientById(org.keycloak.models.RealmModel, java.lang.String)} instead.\n+     */\n+    default ClientModel getClientById(String id, RealmModel realm) { return getClientById(realm, id); }\n+\n+    /**\n+     * Exact search for a client by its public client identifier.\n+     * @param realm Realm to limit the search for clients.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the client, or {@code null} if no client is found.\n+     */\n+    ClientModel getClientByClientId(RealmModel realm, String clientId);\n+\n+    /**\n+     * Exact search for a client by its public client identifier.\n+     * @param realm Realm to limit the search.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the client, or {@code null} if no client is found.\n+     * @deprecated Use {@link #getClientByClientId(org.keycloak.models.RealmModel, java.lang.String)} instead.\n+     */\n+    default ClientModel getClientByClientId(String clientId, RealmModel realm) { return getClientByClientId(realm, clientId); }\n+\n+    /**\n+     * Case-insensitive search for clients that contain the given string in their public client identifier.\n+     * @param realm Realm to limit the search for clients.\n+     * @param clientId Searched substring of the public client\n+     *   identifier ({@code client_id} in OIDC or {@code entityID} in SAML.)\n+     * @param firstResult First result to return. Ignored if negative or {@code null}.\n+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n+     * @return Model of the client, or {@code null} if no client is found.\n+     * @deprecated Use {@link #searchClientsByClientId} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3ODQ3Mg==", "bodyText": "Indeed, thanks for spotting this!", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456378472", "createdAt": "2020-07-17T11:13:46Z", "author": {"login": "hmlnarik"}, "path": "server-spi/src/main/java/org/keycloak/storage/client/ClientLookupProvider.java", "diffHunk": "@@ -28,7 +28,66 @@\n  * @version $Revision: 1 $\n  */\n public interface ClientLookupProvider {\n-    ClientModel getClientById(String id, RealmModel realm);\n-    ClientModel getClientByClientId(String clientId, RealmModel realm);\n-    List<ClientModel> searchClientsByClientId(String clientId, Integer firstResult, Integer maxResults, RealmModel realm);\n+    \n+    /**\n+     * Exact search for a client by its internal ID.\n+     * @param realm Realm to limit the search.\n+     * @param id Internal ID\n+     * @return Model of the client, or {@code null} if no client is found.\n+     */\n+    ClientModel getClientById(RealmModel realm, String id);\n+\n+    /**\n+     * Exact search for a client by its internal ID.\n+     * @param realm Realm to limit the search.\n+     * @param id Internal ID\n+     * @return Model of the client, or {@code null} if no client is found.\n+     * @deprecated Use {@link #getClientById(org.keycloak.models.RealmModel, java.lang.String)} instead.\n+     */\n+    default ClientModel getClientById(String id, RealmModel realm) { return getClientById(realm, id); }\n+\n+    /**\n+     * Exact search for a client by its public client identifier.\n+     * @param realm Realm to limit the search for clients.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the client, or {@code null} if no client is found.\n+     */\n+    ClientModel getClientByClientId(RealmModel realm, String clientId);\n+\n+    /**\n+     * Exact search for a client by its public client identifier.\n+     * @param realm Realm to limit the search.\n+     * @param clientId String that identifies the client to the external parties.\n+     *   Maps to {@code client_id} in OIDC or {@code entityID} in SAML.\n+     * @return Model of the client, or {@code null} if no client is found.\n+     * @deprecated Use {@link #getClientByClientId(org.keycloak.models.RealmModel, java.lang.String)} instead.\n+     */\n+    default ClientModel getClientByClientId(String clientId, RealmModel realm) { return getClientByClientId(realm, clientId); }\n+\n+    /**\n+     * Case-insensitive search for clients that contain the given string in their public client identifier.\n+     * @param realm Realm to limit the search for clients.\n+     * @param clientId Searched substring of the public client\n+     *   identifier ({@code client_id} in OIDC or {@code entityID} in SAML.)\n+     * @param firstResult First result to return. Ignored if negative or {@code null}.\n+     * @param maxResults Maximim number of results to return. Ignored if negative or {@code null}.\n+     * @return Model of the client, or {@code null} if no client is found.\n+     * @deprecated Use {@link #searchClientsByClientId} instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3NDc5Ng=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzAwMjY2OnYy", "diffSide": "RIGHT", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMjoxNjozMlrOGzQuIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo1NDowNFrOGzYVPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQwNDUxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final ClientModel client = getClientById(realm, id);\n          \n          \n            \n                    final ClientModel client = session.clients().getClientById(realm, id);", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456404512", "createdAt": "2020-07-17T12:16:32Z", "author": {"login": "mhajas"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java", "diffHunk": "@@ -688,12 +686,26 @@ public ClientModel getClientByClientId(String clientId, RealmModel realm) {\n         query.setParameter(\"realm\", realm.getId());\n         List<String> results = query.getResultList();\n         if (results.isEmpty()) return Collections.EMPTY_LIST;\n-        return results.stream().map(id -> session.realms().getClientById(id, realm)).collect(Collectors.toList());\n+        return results.stream().map(id -> session.clients().getClientById(realm, id)).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public void removeClients(RealmModel realm) {\n+        TypedQuery<String> query = em.createNamedQuery(\"getClientIdsByRealm\", String.class);\n+        query.setParameter(\"realm\", realm.getId());\n+        List<String> clients = query.getResultList();\n+        for (String client : clients) {\n+            // No need to go through cache. Clients were already invalidated\n+            removeClient(realm, client);\n+        }\n     }\n \n     @Override\n-    public boolean removeClient(String id, RealmModel realm) {\n-        final ClientModel client = getClientById(id, realm);\n+    public boolean removeClient(RealmModel realm, String id) {\n+\n+        logger.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        final ClientModel client = getClientById(realm, id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxMTgwOA==", "bodyText": "This client needs to be in this particular provider, so it needs to be getClientById only", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456511808", "createdAt": "2020-07-17T15:23:24Z", "author": {"login": "hmlnarik"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java", "diffHunk": "@@ -688,12 +686,26 @@ public ClientModel getClientByClientId(String clientId, RealmModel realm) {\n         query.setParameter(\"realm\", realm.getId());\n         List<String> results = query.getResultList();\n         if (results.isEmpty()) return Collections.EMPTY_LIST;\n-        return results.stream().map(id -> session.realms().getClientById(id, realm)).collect(Collectors.toList());\n+        return results.stream().map(id -> session.clients().getClientById(realm, id)).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public void removeClients(RealmModel realm) {\n+        TypedQuery<String> query = em.createNamedQuery(\"getClientIdsByRealm\", String.class);\n+        query.setParameter(\"realm\", realm.getId());\n+        List<String> clients = query.getResultList();\n+        for (String client : clients) {\n+            // No need to go through cache. Clients were already invalidated\n+            removeClient(realm, client);\n+        }\n     }\n \n     @Override\n-    public boolean removeClient(String id, RealmModel realm) {\n-        final ClientModel client = getClientById(id, realm);\n+    public boolean removeClient(RealmModel realm, String id) {\n+\n+        logger.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        final ClientModel client = getClientById(realm, id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQwNDUxMg=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyOTIxMw==", "bodyText": "Yeah, we discussed it already, not sure why github included this comment. When I submitted the review, there were only 4 comments.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456529213", "createdAt": "2020-07-17T15:54:04Z", "author": {"login": "mhajas"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java", "diffHunk": "@@ -688,12 +686,26 @@ public ClientModel getClientByClientId(String clientId, RealmModel realm) {\n         query.setParameter(\"realm\", realm.getId());\n         List<String> results = query.getResultList();\n         if (results.isEmpty()) return Collections.EMPTY_LIST;\n-        return results.stream().map(id -> session.realms().getClientById(id, realm)).collect(Collectors.toList());\n+        return results.stream().map(id -> session.clients().getClientById(realm, id)).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public void removeClients(RealmModel realm) {\n+        TypedQuery<String> query = em.createNamedQuery(\"getClientIdsByRealm\", String.class);\n+        query.setParameter(\"realm\", realm.getId());\n+        List<String> clients = query.getResultList();\n+        for (String client : clients) {\n+            // No need to go through cache. Clients were already invalidated\n+            removeClient(realm, client);\n+        }\n     }\n \n     @Override\n-    public boolean removeClient(String id, RealmModel realm) {\n-        final ClientModel client = getClientById(id, realm);\n+    public boolean removeClient(RealmModel realm, String id) {\n+\n+        logger.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        final ClientModel client = getClientById(realm, id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQwNDUxMg=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzM1NTQzOnYy", "diffSide": "RIGHT", "path": "server-spi/src/main/java/org/keycloak/models/ScopeContainerModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzo1NjowMlrOGzUAoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTozMzoyNlrOGzXoNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1ODQwMQ==", "bodyText": "If a user doesn't provide any of these two methods, it will end up with the infinite loop. Should we remove one of these defaults, to avoid this?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456458401", "createdAt": "2020-07-17T13:56:02Z", "author": {"login": "mhajas"}, "path": "server-spi/src/main/java/org/keycloak/models/ScopeContainerModel.java", "diffHunk": "@@ -18,21 +18,35 @@\n package org.keycloak.models;\n \n import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ScopeContainerModel {\n \n-    Set<RoleModel> getScopeMappings();\n+    @Deprecated\n+    default Set<RoleModel> getScopeMappings() {\n+        return getScopeMappingsStream().collect(Collectors.toSet());\n+    }\n+\n+    default Stream<RoleModel> getScopeMappingsStream() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxNzY4NQ==", "bodyText": "This is a good point and omission on my end. Thanks!", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456517685", "createdAt": "2020-07-17T15:33:26Z", "author": {"login": "hmlnarik"}, "path": "server-spi/src/main/java/org/keycloak/models/ScopeContainerModel.java", "diffHunk": "@@ -18,21 +18,35 @@\n package org.keycloak.models;\n \n import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n  * @version $Revision: 1 $\n  */\n public interface ScopeContainerModel {\n \n-    Set<RoleModel> getScopeMappings();\n+    @Deprecated\n+    default Set<RoleModel> getScopeMappings() {\n+        return getScopeMappingsStream().collect(Collectors.toSet());\n+    }\n+\n+    default Stream<RoleModel> getScopeMappingsStream() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1ODQwMQ=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzUwODkwOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDozNTo1NFrOGzVe4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo1Mjo1OVrOGzYTAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4MjUzMA==", "bodyText": "can cache contain updated client, for example, with different roles? If yes, we should use session.clients() here.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final ClientModel client = getClientById(realm, id);\n          \n          \n            \n                    final ClientModel client = session.clients().getClientById(realm, id);", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456482530", "createdAt": "2020-07-17T14:35:54Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0\n+              : c1 == null ? -1\n+              : c2 == null ? 1\n+              : c1.compareTo(c2);\n+\n+        }\n+    };\n+\n+    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n+        this.session = session;\n+        this.clientStore = clientStore;\n+        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n+        this.tx = new MapKeycloakTransaction<>(clientStore);\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n+\n+    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n+        return new RealmModel.ClientUpdatedEvent() {\n+            @Override\n+            public ClientModel getUpdatedClient() {\n+                return c;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        };\n+    }\n+\n+    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n+        final MapClientEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+            @Override\n+            public void updateClient() {\n+                // commit\n+                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n+                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n+            }\n+\n+            /** This is runtime information and should have never been part of the adapter */\n+            @Override\n+            public Map<String, Integer> getRegisteredNodes() {\n+                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n+            }\n+\n+            @Override\n+            public void registerNode(String nodeHost, int registrationTime) {\n+                Map<String, Integer> value = getRegisteredNodes();\n+                value.put(nodeHost, registrationTime);\n+            }\n+\n+            @Override\n+            public void unregisterNode(String nodeHost) {\n+                getRegisteredNodes().remove(nodeHost);\n+            }\n+\n+        };\n+    }\n+\n+    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapClientProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<ClientModel> s = getClientsStream(realm);\n+        if (firstResult >= 0) {\n+            s = s.skip(firstResult);\n+        }\n+        if (maxResults >= 0) {\n+            s = s.limit(maxResults);\n+        }\n+        return s.collect(Collectors.toList());\n+    }\n+\n+    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n+        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n+    }\n+\n+//    @Override\n+    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n+        return getNotRemovedUpdatedClientsStream()\n+          .filter(entityRealmFilter(realm))\n+          .sorted(COMPARE_BY_CLIENT_ID)\n+          .map(entityToAdapterFunc(realm))\n+        ;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm) {\n+        return getClientsStream(realm).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        if (clientId == null) {\n+            clientId = entityId.toString();\n+        }\n+\n+        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n+\n+        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n+        entity.setClientId(clientId);\n+        entity.setEnabled(true);\n+        entity.setStandardFlowEnabled(true);\n+        if (tx.get(entity.getId(), clientStore::get) != null) {\n+            throw new ModelDuplicateException(\"Client exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        final ClientModel resource = entityToAdapterFunc(realm).apply(entity);\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish((RealmModel.ClientCreationEvent) () -> resource);\n+        resource.updateClient();        // This is actualy strange contract - it should be the store code to call updateClient\n+\n+        return resource;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm) {\n+        return getClientsStream(realm)\n+                .filter(ClientModel::isAlwaysDisplayInConsole)\n+                .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public void removeClients(RealmModel realm) {\n+        LOG.tracef(\"removeClients(%s)%s\", realm, getShortStackTrace());\n+\n+        getClientsStream(realm)\n+          .map(ClientModel::getId)\n+          .collect(Collectors.toSet())  // This is necessary to read out all the client IDs before removing the clients\n+          .forEach(cid -> removeClient(realm, cid));\n+    }\n+\n+    @Override\n+    public boolean removeClient(RealmModel realm, String id) {\n+        if (id == null) {\n+            return false;\n+        }\n+\n+        LOG.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        // TODO: Sending an event (and client role removal) should be extracted to store layer\n+        final ClientModel client = getClientById(realm, id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxNjk5NQ==", "bodyText": "For client removal it is very unlikely. Furthermore, role deletion will soon be treated in a separate store.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456516995", "createdAt": "2020-07-17T15:32:12Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0\n+              : c1 == null ? -1\n+              : c2 == null ? 1\n+              : c1.compareTo(c2);\n+\n+        }\n+    };\n+\n+    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n+        this.session = session;\n+        this.clientStore = clientStore;\n+        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n+        this.tx = new MapKeycloakTransaction<>(clientStore);\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n+\n+    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n+        return new RealmModel.ClientUpdatedEvent() {\n+            @Override\n+            public ClientModel getUpdatedClient() {\n+                return c;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        };\n+    }\n+\n+    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n+        final MapClientEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+            @Override\n+            public void updateClient() {\n+                // commit\n+                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n+                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n+            }\n+\n+            /** This is runtime information and should have never been part of the adapter */\n+            @Override\n+            public Map<String, Integer> getRegisteredNodes() {\n+                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n+            }\n+\n+            @Override\n+            public void registerNode(String nodeHost, int registrationTime) {\n+                Map<String, Integer> value = getRegisteredNodes();\n+                value.put(nodeHost, registrationTime);\n+            }\n+\n+            @Override\n+            public void unregisterNode(String nodeHost) {\n+                getRegisteredNodes().remove(nodeHost);\n+            }\n+\n+        };\n+    }\n+\n+    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapClientProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<ClientModel> s = getClientsStream(realm);\n+        if (firstResult >= 0) {\n+            s = s.skip(firstResult);\n+        }\n+        if (maxResults >= 0) {\n+            s = s.limit(maxResults);\n+        }\n+        return s.collect(Collectors.toList());\n+    }\n+\n+    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n+        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n+    }\n+\n+//    @Override\n+    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n+        return getNotRemovedUpdatedClientsStream()\n+          .filter(entityRealmFilter(realm))\n+          .sorted(COMPARE_BY_CLIENT_ID)\n+          .map(entityToAdapterFunc(realm))\n+        ;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm) {\n+        return getClientsStream(realm).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        if (clientId == null) {\n+            clientId = entityId.toString();\n+        }\n+\n+        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n+\n+        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n+        entity.setClientId(clientId);\n+        entity.setEnabled(true);\n+        entity.setStandardFlowEnabled(true);\n+        if (tx.get(entity.getId(), clientStore::get) != null) {\n+            throw new ModelDuplicateException(\"Client exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        final ClientModel resource = entityToAdapterFunc(realm).apply(entity);\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish((RealmModel.ClientCreationEvent) () -> resource);\n+        resource.updateClient();        // This is actualy strange contract - it should be the store code to call updateClient\n+\n+        return resource;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm) {\n+        return getClientsStream(realm)\n+                .filter(ClientModel::isAlwaysDisplayInConsole)\n+                .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public void removeClients(RealmModel realm) {\n+        LOG.tracef(\"removeClients(%s)%s\", realm, getShortStackTrace());\n+\n+        getClientsStream(realm)\n+          .map(ClientModel::getId)\n+          .collect(Collectors.toSet())  // This is necessary to read out all the client IDs before removing the clients\n+          .forEach(cid -> removeClient(realm, cid));\n+    }\n+\n+    @Override\n+    public boolean removeClient(RealmModel realm, String id) {\n+        if (id == null) {\n+            return false;\n+        }\n+\n+        LOG.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        // TODO: Sending an event (and client role removal) should be extracted to store layer\n+        final ClientModel client = getClientById(realm, id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4MjUzMA=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyODY0Mg==", "bodyText": "ok", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456528642", "createdAt": "2020-07-17T15:52:59Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0\n+              : c1 == null ? -1\n+              : c2 == null ? 1\n+              : c1.compareTo(c2);\n+\n+        }\n+    };\n+\n+    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n+        this.session = session;\n+        this.clientStore = clientStore;\n+        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n+        this.tx = new MapKeycloakTransaction<>(clientStore);\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n+\n+    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n+        return new RealmModel.ClientUpdatedEvent() {\n+            @Override\n+            public ClientModel getUpdatedClient() {\n+                return c;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        };\n+    }\n+\n+    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n+        final MapClientEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+            @Override\n+            public void updateClient() {\n+                // commit\n+                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n+                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n+            }\n+\n+            /** This is runtime information and should have never been part of the adapter */\n+            @Override\n+            public Map<String, Integer> getRegisteredNodes() {\n+                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n+            }\n+\n+            @Override\n+            public void registerNode(String nodeHost, int registrationTime) {\n+                Map<String, Integer> value = getRegisteredNodes();\n+                value.put(nodeHost, registrationTime);\n+            }\n+\n+            @Override\n+            public void unregisterNode(String nodeHost) {\n+                getRegisteredNodes().remove(nodeHost);\n+            }\n+\n+        };\n+    }\n+\n+    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapClientProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<ClientModel> s = getClientsStream(realm);\n+        if (firstResult >= 0) {\n+            s = s.skip(firstResult);\n+        }\n+        if (maxResults >= 0) {\n+            s = s.limit(maxResults);\n+        }\n+        return s.collect(Collectors.toList());\n+    }\n+\n+    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n+        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n+    }\n+\n+//    @Override\n+    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n+        return getNotRemovedUpdatedClientsStream()\n+          .filter(entityRealmFilter(realm))\n+          .sorted(COMPARE_BY_CLIENT_ID)\n+          .map(entityToAdapterFunc(realm))\n+        ;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm) {\n+        return getClientsStream(realm).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        if (clientId == null) {\n+            clientId = entityId.toString();\n+        }\n+\n+        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n+\n+        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n+        entity.setClientId(clientId);\n+        entity.setEnabled(true);\n+        entity.setStandardFlowEnabled(true);\n+        if (tx.get(entity.getId(), clientStore::get) != null) {\n+            throw new ModelDuplicateException(\"Client exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        final ClientModel resource = entityToAdapterFunc(realm).apply(entity);\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish((RealmModel.ClientCreationEvent) () -> resource);\n+        resource.updateClient();        // This is actualy strange contract - it should be the store code to call updateClient\n+\n+        return resource;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getAlwaysDisplayInConsoleClients(RealmModel realm) {\n+        return getClientsStream(realm)\n+                .filter(ClientModel::isAlwaysDisplayInConsole)\n+                .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public void removeClients(RealmModel realm) {\n+        LOG.tracef(\"removeClients(%s)%s\", realm, getShortStackTrace());\n+\n+        getClientsStream(realm)\n+          .map(ClientModel::getId)\n+          .collect(Collectors.toSet())  // This is necessary to read out all the client IDs before removing the clients\n+          .forEach(cid -> removeClient(realm, cid));\n+    }\n+\n+    @Override\n+    public boolean removeClient(RealmModel realm, String id) {\n+        if (id == null) {\n+            return false;\n+        }\n+\n+        LOG.tracef(\"removeClient(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        // TODO: Sending an event (and client role removal) should be extracted to store layer\n+        final ClientModel client = getClientById(realm, id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4MjUzMA=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzYyNDM5OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTowNDo0NFrOGzWlQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTo1MDoyM1rOGzYNhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMDU0NA==", "bodyText": "This function is used, for example, to find out whether a client exists. What if there is a client with desired id in the store, and within this session, it was updated with some MapTask without value. This function will return null and the code will think the client doesn't exist. Should there be defaultValueFunc call on this line?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456500544", "createdAt": "2020-07-17T15:04:44Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.KeycloakTransaction;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import org.jboss.logging.Logger;\n+\n+public class MapKeycloakTransaction<K, V> implements KeycloakTransaction {\n+\n+    private final static Logger log = Logger.getLogger(MapKeycloakTransaction.class);\n+\n+    private enum MapOperation {\n+        PUT {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.put(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        PUT_IF_ABSENT {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.putIfAbsent(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        REMOVE {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(null) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.remove(key);\n+                    }\n+                };\n+            }\n+        },\n+        REPLACE {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.replace(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        ;\n+\n+        protected abstract <K, V> MapTask<K, V> taskFor(K key, V value);\n+\n+    }\n+\n+    private boolean active;\n+    private boolean rollback;\n+    private final Map<K, MapTask<K, V>> tasks = new LinkedHashMap<>();\n+    private final MapStorage<K, V> map;\n+\n+    public MapKeycloakTransaction(MapStorage<K, V> map) {\n+        this.map = map;\n+    }\n+\n+    @Override\n+    public void begin() {\n+        active = true;\n+    }\n+\n+    @Override\n+    public void commit() {\n+        if (rollback) {\n+            throw new RuntimeException(\"Rollback only!\");\n+        }\n+\n+        for (MapTask<K, V> value : tasks.values()) {\n+            value.execute(map);\n+        }\n+    }\n+\n+    @Override\n+    public void rollback() {\n+        tasks.clear();\n+    }\n+\n+    @Override\n+    public void setRollbackOnly() {\n+        rollback = true;\n+    }\n+\n+    @Override\n+    public boolean getRollbackOnly() {\n+        return rollback;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    /**\n+     * Adds a given task if not exists for the given key\n+     * @return {@code true} if a task for the given key already exists\n+     * @throws IllegalStateException\n+     */\n+    private void addTask(MapOperation op, K key, V value) throws IllegalStateException {\n+        log.tracev(\"Adding operation {0} for {1}\", op, key);\n+\n+        K taskKey = key;\n+        tasks.merge(taskKey, op.taskFor(key, value), MapTaskCompose::new);\n+    }\n+\n+    // This is for possibility to lookup for session by id, which was created in this transaction\n+    public V get(K key, Function<K, V> defaultValueFunc) {\n+        MapTask current = tasks.get(key);\n+        if (current != null) {\n+            if (current instanceof MapTaskWithValue) {\n+                return ((MapTaskWithValue<K, V>) current).getValue();\n+            }\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxOTYzMA==", "bodyText": "Actually, there is currently no MapTask, all instances are MapTaskWithValues, so this will never happen. Perhaps the code is worth simplifying.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456519630", "createdAt": "2020-07-17T15:36:50Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.KeycloakTransaction;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import org.jboss.logging.Logger;\n+\n+public class MapKeycloakTransaction<K, V> implements KeycloakTransaction {\n+\n+    private final static Logger log = Logger.getLogger(MapKeycloakTransaction.class);\n+\n+    private enum MapOperation {\n+        PUT {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.put(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        PUT_IF_ABSENT {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.putIfAbsent(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        REMOVE {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(null) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.remove(key);\n+                    }\n+                };\n+            }\n+        },\n+        REPLACE {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.replace(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        ;\n+\n+        protected abstract <K, V> MapTask<K, V> taskFor(K key, V value);\n+\n+    }\n+\n+    private boolean active;\n+    private boolean rollback;\n+    private final Map<K, MapTask<K, V>> tasks = new LinkedHashMap<>();\n+    private final MapStorage<K, V> map;\n+\n+    public MapKeycloakTransaction(MapStorage<K, V> map) {\n+        this.map = map;\n+    }\n+\n+    @Override\n+    public void begin() {\n+        active = true;\n+    }\n+\n+    @Override\n+    public void commit() {\n+        if (rollback) {\n+            throw new RuntimeException(\"Rollback only!\");\n+        }\n+\n+        for (MapTask<K, V> value : tasks.values()) {\n+            value.execute(map);\n+        }\n+    }\n+\n+    @Override\n+    public void rollback() {\n+        tasks.clear();\n+    }\n+\n+    @Override\n+    public void setRollbackOnly() {\n+        rollback = true;\n+    }\n+\n+    @Override\n+    public boolean getRollbackOnly() {\n+        return rollback;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    /**\n+     * Adds a given task if not exists for the given key\n+     * @return {@code true} if a task for the given key already exists\n+     * @throws IllegalStateException\n+     */\n+    private void addTask(MapOperation op, K key, V value) throws IllegalStateException {\n+        log.tracev(\"Adding operation {0} for {1}\", op, key);\n+\n+        K taskKey = key;\n+        tasks.merge(taskKey, op.taskFor(key, value), MapTaskCompose::new);\n+    }\n+\n+    // This is for possibility to lookup for session by id, which was created in this transaction\n+    public V get(K key, Function<K, V> defaultValueFunc) {\n+        MapTask current = tasks.get(key);\n+        if (current != null) {\n+            if (current instanceof MapTaskWithValue) {\n+                return ((MapTaskWithValue<K, V>) current).getValue();\n+            }\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMDU0NA=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyNzIzNg==", "bodyText": "I agree, currently, it should not happen, but in future, somebody can add such a task. Anyway, it can stay as it is, I don't have any strong reason to change it, I just wanted to point it out.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456527236", "createdAt": "2020-07-17T15:50:23Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.KeycloakTransaction;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import org.jboss.logging.Logger;\n+\n+public class MapKeycloakTransaction<K, V> implements KeycloakTransaction {\n+\n+    private final static Logger log = Logger.getLogger(MapKeycloakTransaction.class);\n+\n+    private enum MapOperation {\n+        PUT {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.put(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        PUT_IF_ABSENT {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.putIfAbsent(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        REMOVE {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(null) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.remove(key);\n+                    }\n+                };\n+            }\n+        },\n+        REPLACE {\n+            @Override\n+            protected <K, V> MapTask<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.replace(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        ;\n+\n+        protected abstract <K, V> MapTask<K, V> taskFor(K key, V value);\n+\n+    }\n+\n+    private boolean active;\n+    private boolean rollback;\n+    private final Map<K, MapTask<K, V>> tasks = new LinkedHashMap<>();\n+    private final MapStorage<K, V> map;\n+\n+    public MapKeycloakTransaction(MapStorage<K, V> map) {\n+        this.map = map;\n+    }\n+\n+    @Override\n+    public void begin() {\n+        active = true;\n+    }\n+\n+    @Override\n+    public void commit() {\n+        if (rollback) {\n+            throw new RuntimeException(\"Rollback only!\");\n+        }\n+\n+        for (MapTask<K, V> value : tasks.values()) {\n+            value.execute(map);\n+        }\n+    }\n+\n+    @Override\n+    public void rollback() {\n+        tasks.clear();\n+    }\n+\n+    @Override\n+    public void setRollbackOnly() {\n+        rollback = true;\n+    }\n+\n+    @Override\n+    public boolean getRollbackOnly() {\n+        return rollback;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    /**\n+     * Adds a given task if not exists for the given key\n+     * @return {@code true} if a task for the given key already exists\n+     * @throws IllegalStateException\n+     */\n+    private void addTask(MapOperation op, K key, V value) throws IllegalStateException {\n+        log.tracev(\"Adding operation {0} for {1}\", op, key);\n+\n+        K taskKey = key;\n+        tasks.merge(taskKey, op.taskFor(key, value), MapTaskCompose::new);\n+    }\n+\n+    // This is for possibility to lookup for session by id, which was created in this transaction\n+    public V get(K key, Function<K, V> defaultValueFunc) {\n+        MapTask current = tasks.get(key);\n+        if (current != null) {\n+            if (current instanceof MapTaskWithValue) {\n+                return ((MapTaskWithValue<K, V>) current).getValue();\n+            }\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMDU0NA=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzYzMTk1OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNTowNjozOFrOGzWp0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoxOTowOFrOGza-dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTcxNQ==", "bodyText": "Why putIfAbsent()? We checked there is no client with the same id.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456501715", "createdAt": "2020-07-17T15:06:38Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0\n+              : c1 == null ? -1\n+              : c2 == null ? 1\n+              : c1.compareTo(c2);\n+\n+        }\n+    };\n+\n+    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n+        this.session = session;\n+        this.clientStore = clientStore;\n+        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n+        this.tx = new MapKeycloakTransaction<>(clientStore);\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n+\n+    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n+        return new RealmModel.ClientUpdatedEvent() {\n+            @Override\n+            public ClientModel getUpdatedClient() {\n+                return c;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        };\n+    }\n+\n+    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n+        final MapClientEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+            @Override\n+            public void updateClient() {\n+                // commit\n+                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n+                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n+            }\n+\n+            /** This is runtime information and should have never been part of the adapter */\n+            @Override\n+            public Map<String, Integer> getRegisteredNodes() {\n+                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n+            }\n+\n+            @Override\n+            public void registerNode(String nodeHost, int registrationTime) {\n+                Map<String, Integer> value = getRegisteredNodes();\n+                value.put(nodeHost, registrationTime);\n+            }\n+\n+            @Override\n+            public void unregisterNode(String nodeHost) {\n+                getRegisteredNodes().remove(nodeHost);\n+            }\n+\n+        };\n+    }\n+\n+    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapClientProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<ClientModel> s = getClientsStream(realm);\n+        if (firstResult >= 0) {\n+            s = s.skip(firstResult);\n+        }\n+        if (maxResults >= 0) {\n+            s = s.limit(maxResults);\n+        }\n+        return s.collect(Collectors.toList());\n+    }\n+\n+    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n+        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n+    }\n+\n+//    @Override\n+    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n+        return getNotRemovedUpdatedClientsStream()\n+          .filter(entityRealmFilter(realm))\n+          .sorted(COMPARE_BY_CLIENT_ID)\n+          .map(entityToAdapterFunc(realm))\n+        ;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm) {\n+        return getClientsStream(realm).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        if (clientId == null) {\n+            clientId = entityId.toString();\n+        }\n+\n+        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n+\n+        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n+        entity.setClientId(clientId);\n+        entity.setEnabled(true);\n+        entity.setStandardFlowEnabled(true);\n+        if (tx.get(entity.getId(), clientStore::get) != null) {\n+            throw new ModelDuplicateException(\"Client exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxNjA0Nw==", "bodyText": "Because this needs to be done in a transaction.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456516047", "createdAt": "2020-07-17T15:30:34Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0\n+              : c1 == null ? -1\n+              : c2 == null ? 1\n+              : c1.compareTo(c2);\n+\n+        }\n+    };\n+\n+    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n+        this.session = session;\n+        this.clientStore = clientStore;\n+        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n+        this.tx = new MapKeycloakTransaction<>(clientStore);\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n+\n+    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n+        return new RealmModel.ClientUpdatedEvent() {\n+            @Override\n+            public ClientModel getUpdatedClient() {\n+                return c;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        };\n+    }\n+\n+    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n+        final MapClientEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+            @Override\n+            public void updateClient() {\n+                // commit\n+                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n+                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n+            }\n+\n+            /** This is runtime information and should have never been part of the adapter */\n+            @Override\n+            public Map<String, Integer> getRegisteredNodes() {\n+                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n+            }\n+\n+            @Override\n+            public void registerNode(String nodeHost, int registrationTime) {\n+                Map<String, Integer> value = getRegisteredNodes();\n+                value.put(nodeHost, registrationTime);\n+            }\n+\n+            @Override\n+            public void unregisterNode(String nodeHost) {\n+                getRegisteredNodes().remove(nodeHost);\n+            }\n+\n+        };\n+    }\n+\n+    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapClientProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<ClientModel> s = getClientsStream(realm);\n+        if (firstResult >= 0) {\n+            s = s.skip(firstResult);\n+        }\n+        if (maxResults >= 0) {\n+            s = s.limit(maxResults);\n+        }\n+        return s.collect(Collectors.toList());\n+    }\n+\n+    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n+        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n+    }\n+\n+//    @Override\n+    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n+        return getNotRemovedUpdatedClientsStream()\n+          .filter(entityRealmFilter(realm))\n+          .sorted(COMPARE_BY_CLIENT_ID)\n+          .map(entityToAdapterFunc(realm))\n+        ;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm) {\n+        return getClientsStream(realm).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        if (clientId == null) {\n+            clientId = entityId.toString();\n+        }\n+\n+        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n+\n+        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n+        entity.setClientId(clientId);\n+        entity.setEnabled(true);\n+        entity.setStandardFlowEnabled(true);\n+        if (tx.get(entity.getId(), clientStore::get) != null) {\n+            throw new ModelDuplicateException(\"Client exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTcxNQ=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyNDUxNA==", "bodyText": "MapKeycloakTransaction supports also put()", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456524514", "createdAt": "2020-07-17T15:45:23Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0\n+              : c1 == null ? -1\n+              : c2 == null ? 1\n+              : c1.compareTo(c2);\n+\n+        }\n+    };\n+\n+    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n+        this.session = session;\n+        this.clientStore = clientStore;\n+        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n+        this.tx = new MapKeycloakTransaction<>(clientStore);\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n+\n+    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n+        return new RealmModel.ClientUpdatedEvent() {\n+            @Override\n+            public ClientModel getUpdatedClient() {\n+                return c;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        };\n+    }\n+\n+    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n+        final MapClientEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+            @Override\n+            public void updateClient() {\n+                // commit\n+                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n+                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n+            }\n+\n+            /** This is runtime information and should have never been part of the adapter */\n+            @Override\n+            public Map<String, Integer> getRegisteredNodes() {\n+                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n+            }\n+\n+            @Override\n+            public void registerNode(String nodeHost, int registrationTime) {\n+                Map<String, Integer> value = getRegisteredNodes();\n+                value.put(nodeHost, registrationTime);\n+            }\n+\n+            @Override\n+            public void unregisterNode(String nodeHost) {\n+                getRegisteredNodes().remove(nodeHost);\n+            }\n+\n+        };\n+    }\n+\n+    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapClientProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<ClientModel> s = getClientsStream(realm);\n+        if (firstResult >= 0) {\n+            s = s.skip(firstResult);\n+        }\n+        if (maxResults >= 0) {\n+            s = s.limit(maxResults);\n+        }\n+        return s.collect(Collectors.toList());\n+    }\n+\n+    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n+        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n+    }\n+\n+//    @Override\n+    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n+        return getNotRemovedUpdatedClientsStream()\n+          .filter(entityRealmFilter(realm))\n+          .sorted(COMPARE_BY_CLIENT_ID)\n+          .map(entityToAdapterFunc(realm))\n+        ;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm) {\n+        return getClientsStream(realm).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        if (clientId == null) {\n+            clientId = entityId.toString();\n+        }\n+\n+        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n+\n+        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n+        entity.setClientId(clientId);\n+        entity.setEnabled(true);\n+        entity.setStandardFlowEnabled(true);\n+        if (tx.get(entity.getId(), clientStore::get) != null) {\n+            throw new ModelDuplicateException(\"Client exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTcxNQ=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU1ODM3Mw==", "bodyText": "Yup, but the transaction is only committed after the request is almost processed. The get above provides a preliminary check during processing the request - a fail-fast functionality. If a concurrent transaction (e.g. concurrent request) adds the same client, this transaction should not force replacing the client.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456558373", "createdAt": "2020-07-17T16:50:40Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0\n+              : c1 == null ? -1\n+              : c2 == null ? 1\n+              : c1.compareTo(c2);\n+\n+        }\n+    };\n+\n+    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n+        this.session = session;\n+        this.clientStore = clientStore;\n+        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n+        this.tx = new MapKeycloakTransaction<>(clientStore);\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n+\n+    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n+        return new RealmModel.ClientUpdatedEvent() {\n+            @Override\n+            public ClientModel getUpdatedClient() {\n+                return c;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        };\n+    }\n+\n+    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n+        final MapClientEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+            @Override\n+            public void updateClient() {\n+                // commit\n+                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n+                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n+            }\n+\n+            /** This is runtime information and should have never been part of the adapter */\n+            @Override\n+            public Map<String, Integer> getRegisteredNodes() {\n+                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n+            }\n+\n+            @Override\n+            public void registerNode(String nodeHost, int registrationTime) {\n+                Map<String, Integer> value = getRegisteredNodes();\n+                value.put(nodeHost, registrationTime);\n+            }\n+\n+            @Override\n+            public void unregisterNode(String nodeHost) {\n+                getRegisteredNodes().remove(nodeHost);\n+            }\n+\n+        };\n+    }\n+\n+    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapClientProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<ClientModel> s = getClientsStream(realm);\n+        if (firstResult >= 0) {\n+            s = s.skip(firstResult);\n+        }\n+        if (maxResults >= 0) {\n+            s = s.limit(maxResults);\n+        }\n+        return s.collect(Collectors.toList());\n+    }\n+\n+    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n+        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n+    }\n+\n+//    @Override\n+    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n+        return getNotRemovedUpdatedClientsStream()\n+          .filter(entityRealmFilter(realm))\n+          .sorted(COMPARE_BY_CLIENT_ID)\n+          .map(entityToAdapterFunc(realm))\n+        ;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm) {\n+        return getClientsStream(realm).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        if (clientId == null) {\n+            clientId = entityId.toString();\n+        }\n+\n+        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n+\n+        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n+        entity.setClientId(clientId);\n+        entity.setEnabled(true);\n+        entity.setStandardFlowEnabled(true);\n+        if (tx.get(entity.getId(), clientStore::get) != null) {\n+            throw new ModelDuplicateException(\"Client exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTcxNQ=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3MjUzNQ==", "bodyText": "Ok I see, thanks", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456572535", "createdAt": "2020-07-17T17:19:08Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapClientProvider implements ClientProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapClientProvider.class);\n+    private static final Predicate<MapClientEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapClientEntity> tx;\n+    private final MapStorage<UUID, MapClientEntity> clientStore;\n+    private final ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore;\n+\n+    private static final Comparator<MapClientEntity> COMPARE_BY_CLIENT_ID = new Comparator<MapClientEntity>() {\n+        @Override\n+        public int compare(MapClientEntity o1, MapClientEntity o2) {\n+            String c1 = o1 == null ? null : o1.getClientId();\n+            String c2 = o2 == null ? null : o2.getClientId();\n+            return c1 == c2 ? 0\n+              : c1 == null ? -1\n+              : c2 == null ? 1\n+              : c1.compareTo(c2);\n+\n+        }\n+    };\n+\n+    public MapClientProvider(KeycloakSession session, MapStorage<UUID, MapClientEntity> clientStore, ConcurrentMap<UUID, ConcurrentMap<String, Integer>> clientRegisteredNodesStore) {\n+        this.session = session;\n+        this.clientStore = clientStore;\n+        this.clientRegisteredNodesStore = clientRegisteredNodesStore;\n+        this.tx = new MapKeycloakTransaction<>(clientStore);\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n+\n+    private ClientUpdatedEvent clientUpdatedEvent(ClientModel c) {\n+        return new RealmModel.ClientUpdatedEvent() {\n+            @Override\n+            public ClientModel getUpdatedClient() {\n+                return c;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        };\n+    }\n+\n+    private MapClientEntity registerEntityForChanges(MapClientEntity origEntity) {\n+        final MapClientEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapClientEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapClientEntity, ClientModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapClientAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+            @Override\n+            public void updateClient() {\n+                // commit\n+                MapClientProvider.this.tx.replace(entity.getId(), this.entity);\n+                session.getKeycloakSessionFactory().publish(clientUpdatedEvent(this));\n+            }\n+\n+            /** This is runtime information and should have never been part of the adapter */\n+            @Override\n+            public Map<String, Integer> getRegisteredNodes() {\n+                return clientRegisteredNodesStore.computeIfAbsent(entity.getId(), k -> new ConcurrentHashMap<>());\n+            }\n+\n+            @Override\n+            public void registerNode(String nodeHost, int registrationTime) {\n+                Map<String, Integer> value = getRegisteredNodes();\n+                value.put(nodeHost, registrationTime);\n+            }\n+\n+            @Override\n+            public void unregisterNode(String nodeHost) {\n+                getRegisteredNodes().remove(nodeHost);\n+            }\n+\n+        };\n+    }\n+\n+    private Predicate<MapClientEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapClientProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<ClientModel> s = getClientsStream(realm);\n+        if (firstResult >= 0) {\n+            s = s.skip(firstResult);\n+        }\n+        if (maxResults >= 0) {\n+            s = s.limit(maxResults);\n+        }\n+        return s.collect(Collectors.toList());\n+    }\n+\n+    private Stream<MapClientEntity> getNotRemovedUpdatedClientsStream() {\n+        Stream<MapClientEntity> updatedAndNotRemovedClientsStream = clientStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(clientStore.keySet()), updatedAndNotRemovedClientsStream);\n+    }\n+\n+//    @Override\n+    public Stream<ClientModel> getClientsStream(RealmModel realm) {\n+        return getNotRemovedUpdatedClientsStream()\n+          .filter(entityRealmFilter(realm))\n+          .sorted(COMPARE_BY_CLIENT_ID)\n+          .map(entityToAdapterFunc(realm))\n+        ;\n+    }\n+\n+    @Override\n+    public List<ClientModel> getClients(RealmModel realm) {\n+        return getClientsStream(realm).collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public ClientModel addClient(RealmModel realm, String id, String clientId) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        if (clientId == null) {\n+            clientId = entityId.toString();\n+        }\n+\n+        LOG.tracef(\"addClient(%s, %s, %s)%s\", realm, id, clientId, getShortStackTrace());\n+\n+        MapClientEntity entity = new MapClientEntity(entityId, realm.getId());\n+        entity.setClientId(clientId);\n+        entity.setEnabled(true);\n+        entity.setStandardFlowEnabled(true);\n+        if (tx.get(entity.getId(), clientStore::get) != null) {\n+            throw new ModelDuplicateException(\"Client exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTcxNQ=="}, "originalCommit": {"oid": "05894a46f62f04960bb89e0d76ceb46948926726"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTI3Nzg1OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjoyMTozMVrOGz0whA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo0NTowNVrOGz5dOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NDk0OA==", "bodyText": "Shouldn't the 2 lines above be swapped?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456994948", "createdAt": "2020-07-20T02:21:31Z", "author": {"login": "sguilhen"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.client;\n+\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.map.common.AbstractEntity;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public abstract class AbstractClientEntity<K> implements AbstractEntity<K> {\n+\n+    private K id;\n+    private String realmId;\n+\n+    private String clientId;\n+    private String name;\n+    private String description;\n+    private Set<String> redirectUris = new HashSet<>();\n+    private boolean enabled;\n+    private boolean alwaysDisplayInConsole;\n+    private String clientAuthenticatorType;\n+    private String secret;\n+    private String registrationToken;\n+    private String protocol;\n+    private Map<String, String> attributes = new HashMap<>();\n+    private Map<String, String> authFlowBindings = new HashMap<>();\n+    private boolean publicClient;\n+    private boolean fullScopeAllowed;\n+    private boolean frontchannelLogout;\n+    private int notBefore;\n+    private Set<String> scope = new HashSet<>();\n+    private Set<String> webOrigins = new HashSet<>();\n+    private Map<String, ProtocolMapperModel> protocolMappers = new HashMap<>();\n+    private Map<String, Boolean> clientScopes = new HashMap<>();\n+    private Set<String> scopeMappings = new LinkedHashSet<>();\n+    private List<String> defaultRoles = new LinkedList<>();\n+    private boolean surrogateAuthRequired;\n+    private String managementUrl;\n+    private String rootUrl;\n+    private String baseUrl;\n+    private boolean bearerOnly;\n+    private boolean consentRequired;\n+    private boolean standardFlowEnabled;\n+    private boolean implicitFlowEnabled;\n+    private boolean directAccessGrantsEnabled;\n+    private boolean serviceAccountsEnabled;\n+    private int nodeReRegistrationTimeout;\n+\n+    /**\n+     * Flag signalizing that any of the setters has been meaningfully used.\n+     */\n+    protected boolean updated;\n+\n+    protected AbstractClientEntity() {\n+        this.id = null;\n+        this.realmId = null;\n+    }\n+\n+    public AbstractClientEntity(K id, String realmId) {\n+        Objects.requireNonNull(id, \"id\");\n+        Objects.requireNonNull(realmId, \"realmId\");\n+\n+        this.id = id;\n+        this.realmId = realmId;\n+    }\n+\n+    @Override\n+    public K getId() {\n+        return this.id;\n+    }\n+\n+    @Override\n+    public boolean isUpdated() {\n+        return this.updated;\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    public void setClientId(String clientId) {\n+        this.updated |= ! Objects.equals(this.clientId, clientId);\n+        this.clientId = clientId;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.updated |= ! Objects.equals(this.name, name);\n+        this.name = name;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(String description) {\n+        this.updated |= ! Objects.equals(this.description, description);\n+        this.description = description;\n+    }\n+\n+    public Set<String> getRedirectUris() {\n+        return redirectUris;\n+    }\n+\n+    public void setRedirectUris(Set<String> redirectUris) {\n+        this.updated |= ! Objects.equals(this.redirectUris, redirectUris);\n+        this.redirectUris = redirectUris;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.updated |= ! Objects.equals(this.enabled, enabled);\n+        this.enabled = enabled;\n+    }\n+\n+    public boolean isAlwaysDisplayInConsole() {\n+        return alwaysDisplayInConsole;\n+    }\n+\n+    public void setAlwaysDisplayInConsole(boolean alwaysDisplayInConsole) {\n+        this.updated |= ! Objects.equals(this.alwaysDisplayInConsole, alwaysDisplayInConsole);\n+        this.alwaysDisplayInConsole = alwaysDisplayInConsole;\n+    }\n+\n+    public String getClientAuthenticatorType() {\n+        return clientAuthenticatorType;\n+    }\n+\n+    public void setClientAuthenticatorType(String clientAuthenticatorType) {\n+        this.updated |= ! Objects.equals(this.clientAuthenticatorType, clientAuthenticatorType);\n+        this.clientAuthenticatorType = clientAuthenticatorType;\n+    }\n+\n+    public String getSecret() {\n+        return secret;\n+    }\n+\n+    public void setSecret(String secret) {\n+        this.updated |= ! Objects.equals(this.secret, secret);\n+        this.secret = secret;\n+    }\n+\n+    public String getRegistrationToken() {\n+        return registrationToken;\n+    }\n+\n+    public void setRegistrationToken(String registrationToken) {\n+        this.updated |= ! Objects.equals(this.registrationToken, registrationToken);\n+        this.registrationToken = registrationToken;\n+    }\n+\n+    public String getProtocol() {\n+        return protocol;\n+    }\n+\n+    public void setProtocol(String protocol) {\n+        this.updated |= ! Objects.equals(this.protocol, protocol);\n+        this.protocol = protocol;\n+    }\n+\n+    public Map<String, String> getAttributes() {\n+        return attributes;\n+    }\n+\n+    public void setAttributes(Map<String, String> attributes) {\n+        this.updated |= ! Objects.equals(this.attributes, attributes);\n+        this.attributes = attributes;\n+    }\n+\n+    public Map<String, String> getAuthFlowBindings() {\n+        return authFlowBindings;\n+    }\n+\n+    public void setAuthFlowBindings(Map<String, String> authFlowBindings) {\n+        this.updated |= ! Objects.equals(this.authFlowBindings, authFlowBindings);\n+        this.authFlowBindings = authFlowBindings;\n+    }\n+\n+    public boolean isPublicClient() {\n+        return publicClient;\n+    }\n+\n+    public void setPublicClient(boolean publicClient) {\n+        this.updated |= ! Objects.equals(this.publicClient, publicClient);\n+        this.publicClient = publicClient;\n+    }\n+\n+    public boolean isFullScopeAllowed() {\n+        return fullScopeAllowed;\n+    }\n+\n+    public void setFullScopeAllowed(boolean fullScopeAllowed) {\n+        this.updated |= ! Objects.equals(this.fullScopeAllowed, fullScopeAllowed);\n+        this.fullScopeAllowed = fullScopeAllowed;\n+    }\n+\n+    public boolean isFrontchannelLogout() {\n+        return frontchannelLogout;\n+    }\n+\n+    public void setFrontchannelLogout(boolean frontchannelLogout) {\n+        this.updated |= ! Objects.equals(this.frontchannelLogout, frontchannelLogout);\n+        this.frontchannelLogout = frontchannelLogout;\n+    }\n+\n+    public int getNotBefore() {\n+        return notBefore;\n+    }\n+\n+    public void setNotBefore(int notBefore) {\n+        this.updated |= ! Objects.equals(this.notBefore, notBefore);\n+        this.notBefore = notBefore;\n+    }\n+\n+    public Set<String> getScope() {\n+        return scope;\n+    }\n+\n+    public void setScope(Set<String> scope) {\n+        this.updated |= ! Objects.equals(this.scope, scope);\n+        this.scope.clear();\n+        this.scope.addAll(scope);\n+    }\n+\n+    public Set<String> getWebOrigins() {\n+        return webOrigins;\n+    }\n+\n+    public void setWebOrigins(Set<String> webOrigins) {\n+        this.updated |= ! Objects.equals(this.webOrigins, webOrigins);\n+        this.webOrigins.clear();\n+        this.webOrigins.addAll(webOrigins);\n+    }\n+\n+    public ProtocolMapperModel addProtocolMapper(ProtocolMapperModel model) {\n+        updated = true;\n+        Objects.requireNonNull(model.getId(), \"protocolMapper.id\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a9cc8739377e11be40306ffb9f8341742ba8e"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3MTkyOA==", "bodyText": "Yup, thanks for spotting this!", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457071928", "createdAt": "2020-07-20T05:45:05Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.client;\n+\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.map.common.AbstractEntity;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public abstract class AbstractClientEntity<K> implements AbstractEntity<K> {\n+\n+    private K id;\n+    private String realmId;\n+\n+    private String clientId;\n+    private String name;\n+    private String description;\n+    private Set<String> redirectUris = new HashSet<>();\n+    private boolean enabled;\n+    private boolean alwaysDisplayInConsole;\n+    private String clientAuthenticatorType;\n+    private String secret;\n+    private String registrationToken;\n+    private String protocol;\n+    private Map<String, String> attributes = new HashMap<>();\n+    private Map<String, String> authFlowBindings = new HashMap<>();\n+    private boolean publicClient;\n+    private boolean fullScopeAllowed;\n+    private boolean frontchannelLogout;\n+    private int notBefore;\n+    private Set<String> scope = new HashSet<>();\n+    private Set<String> webOrigins = new HashSet<>();\n+    private Map<String, ProtocolMapperModel> protocolMappers = new HashMap<>();\n+    private Map<String, Boolean> clientScopes = new HashMap<>();\n+    private Set<String> scopeMappings = new LinkedHashSet<>();\n+    private List<String> defaultRoles = new LinkedList<>();\n+    private boolean surrogateAuthRequired;\n+    private String managementUrl;\n+    private String rootUrl;\n+    private String baseUrl;\n+    private boolean bearerOnly;\n+    private boolean consentRequired;\n+    private boolean standardFlowEnabled;\n+    private boolean implicitFlowEnabled;\n+    private boolean directAccessGrantsEnabled;\n+    private boolean serviceAccountsEnabled;\n+    private int nodeReRegistrationTimeout;\n+\n+    /**\n+     * Flag signalizing that any of the setters has been meaningfully used.\n+     */\n+    protected boolean updated;\n+\n+    protected AbstractClientEntity() {\n+        this.id = null;\n+        this.realmId = null;\n+    }\n+\n+    public AbstractClientEntity(K id, String realmId) {\n+        Objects.requireNonNull(id, \"id\");\n+        Objects.requireNonNull(realmId, \"realmId\");\n+\n+        this.id = id;\n+        this.realmId = realmId;\n+    }\n+\n+    @Override\n+    public K getId() {\n+        return this.id;\n+    }\n+\n+    @Override\n+    public boolean isUpdated() {\n+        return this.updated;\n+    }\n+\n+    public String getClientId() {\n+        return clientId;\n+    }\n+\n+    public void setClientId(String clientId) {\n+        this.updated |= ! Objects.equals(this.clientId, clientId);\n+        this.clientId = clientId;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.updated |= ! Objects.equals(this.name, name);\n+        this.name = name;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(String description) {\n+        this.updated |= ! Objects.equals(this.description, description);\n+        this.description = description;\n+    }\n+\n+    public Set<String> getRedirectUris() {\n+        return redirectUris;\n+    }\n+\n+    public void setRedirectUris(Set<String> redirectUris) {\n+        this.updated |= ! Objects.equals(this.redirectUris, redirectUris);\n+        this.redirectUris = redirectUris;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void setEnabled(boolean enabled) {\n+        this.updated |= ! Objects.equals(this.enabled, enabled);\n+        this.enabled = enabled;\n+    }\n+\n+    public boolean isAlwaysDisplayInConsole() {\n+        return alwaysDisplayInConsole;\n+    }\n+\n+    public void setAlwaysDisplayInConsole(boolean alwaysDisplayInConsole) {\n+        this.updated |= ! Objects.equals(this.alwaysDisplayInConsole, alwaysDisplayInConsole);\n+        this.alwaysDisplayInConsole = alwaysDisplayInConsole;\n+    }\n+\n+    public String getClientAuthenticatorType() {\n+        return clientAuthenticatorType;\n+    }\n+\n+    public void setClientAuthenticatorType(String clientAuthenticatorType) {\n+        this.updated |= ! Objects.equals(this.clientAuthenticatorType, clientAuthenticatorType);\n+        this.clientAuthenticatorType = clientAuthenticatorType;\n+    }\n+\n+    public String getSecret() {\n+        return secret;\n+    }\n+\n+    public void setSecret(String secret) {\n+        this.updated |= ! Objects.equals(this.secret, secret);\n+        this.secret = secret;\n+    }\n+\n+    public String getRegistrationToken() {\n+        return registrationToken;\n+    }\n+\n+    public void setRegistrationToken(String registrationToken) {\n+        this.updated |= ! Objects.equals(this.registrationToken, registrationToken);\n+        this.registrationToken = registrationToken;\n+    }\n+\n+    public String getProtocol() {\n+        return protocol;\n+    }\n+\n+    public void setProtocol(String protocol) {\n+        this.updated |= ! Objects.equals(this.protocol, protocol);\n+        this.protocol = protocol;\n+    }\n+\n+    public Map<String, String> getAttributes() {\n+        return attributes;\n+    }\n+\n+    public void setAttributes(Map<String, String> attributes) {\n+        this.updated |= ! Objects.equals(this.attributes, attributes);\n+        this.attributes = attributes;\n+    }\n+\n+    public Map<String, String> getAuthFlowBindings() {\n+        return authFlowBindings;\n+    }\n+\n+    public void setAuthFlowBindings(Map<String, String> authFlowBindings) {\n+        this.updated |= ! Objects.equals(this.authFlowBindings, authFlowBindings);\n+        this.authFlowBindings = authFlowBindings;\n+    }\n+\n+    public boolean isPublicClient() {\n+        return publicClient;\n+    }\n+\n+    public void setPublicClient(boolean publicClient) {\n+        this.updated |= ! Objects.equals(this.publicClient, publicClient);\n+        this.publicClient = publicClient;\n+    }\n+\n+    public boolean isFullScopeAllowed() {\n+        return fullScopeAllowed;\n+    }\n+\n+    public void setFullScopeAllowed(boolean fullScopeAllowed) {\n+        this.updated |= ! Objects.equals(this.fullScopeAllowed, fullScopeAllowed);\n+        this.fullScopeAllowed = fullScopeAllowed;\n+    }\n+\n+    public boolean isFrontchannelLogout() {\n+        return frontchannelLogout;\n+    }\n+\n+    public void setFrontchannelLogout(boolean frontchannelLogout) {\n+        this.updated |= ! Objects.equals(this.frontchannelLogout, frontchannelLogout);\n+        this.frontchannelLogout = frontchannelLogout;\n+    }\n+\n+    public int getNotBefore() {\n+        return notBefore;\n+    }\n+\n+    public void setNotBefore(int notBefore) {\n+        this.updated |= ! Objects.equals(this.notBefore, notBefore);\n+        this.notBefore = notBefore;\n+    }\n+\n+    public Set<String> getScope() {\n+        return scope;\n+    }\n+\n+    public void setScope(Set<String> scope) {\n+        this.updated |= ! Objects.equals(this.scope, scope);\n+        this.scope.clear();\n+        this.scope.addAll(scope);\n+    }\n+\n+    public Set<String> getWebOrigins() {\n+        return webOrigins;\n+    }\n+\n+    public void setWebOrigins(Set<String> webOrigins) {\n+        this.updated |= ! Objects.equals(this.webOrigins, webOrigins);\n+        this.webOrigins.clear();\n+        this.webOrigins.addAll(webOrigins);\n+    }\n+\n+    public ProtocolMapperModel addProtocolMapper(ProtocolMapperModel model) {\n+        updated = true;\n+        Objects.requireNonNull(model.getId(), \"protocolMapper.id\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NDk0OA=="}, "originalCommit": {"oid": "405a9cc8739377e11be40306ffb9f8341742ba8e"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTI3OTQ4OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjoyMjo0OFrOGz0xfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjoyMjo0OFrOGz0xfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NTE5Ng==", "bodyText": "Minor: wrong year", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456995196", "createdAt": "2020-07-20T02:22:48Z", "author": {"login": "sguilhen"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a9cc8739377e11be40306ffb9f8341742ba8e"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTI3OTc5OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjoyMjo1OFrOGz0xpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjoyMjo1OFrOGz0xpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NTIzNg==", "bodyText": "Wrong author", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456995236", "createdAt": "2020-07-20T02:22:58Z", "author": {"login": "sguilhen"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2016 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.client;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RealmModel.ClientUpdatedEvent;\n+import org.keycloak.models.RealmProvider;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+\n+/**\n+ * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n+ * @version $Revision: 1 $", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a9cc8739377e11be40306ffb9f8341742ba8e"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTI4NDcwOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/resources/META-INF/services/org.keycloak.models.map.storage.MapStorageProvider", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjoyNjoxM1rOGz00dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjoyNjoxM1rOGz00dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NTk1OQ==", "bodyText": "Missing copyright header", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456995959", "createdAt": "2020-07-20T02:26:13Z", "author": {"login": "sguilhen"}, "path": "model/map/src/main/resources/META-INF/services/org.keycloak.models.map.storage.MapStorageProvider", "diffHunk": "@@ -0,0 +1 @@\n+org.keycloak.models.map.storage.ConcurrentHashMapStorageProvider", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a9cc8739377e11be40306ffb9f8341742ba8e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTI4NTAzOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/resources/META-INF/services/org.keycloak.provider.Spi", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjoyNjoyNVrOGz00og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjoyNjoyNVrOGz00og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NjAwMg==", "bodyText": "Minor: wrong year", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456996002", "createdAt": "2020-07-20T02:26:25Z", "author": {"login": "sguilhen"}, "path": "model/map/src/main/resources/META-INF/services/org.keycloak.provider.Spi", "diffHunk": "@@ -0,0 +1,18 @@\n+#\n+# Copyright 2016 Red Hat, Inc. and/or its affiliates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a9cc8739377e11be40306ffb9f8341742ba8e"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTMwNjYwOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMjo0MDoxNVrOGz1AnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo0NzowNlrOGz5g4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5OTA2OA==", "bodyText": "Method doesn't return any value", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r456999068", "createdAt": "2020-07-20T02:40:15Z", "author": {"login": "sguilhen"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.KeycloakTransaction;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import org.jboss.logging.Logger;\n+\n+public class MapKeycloakTransaction<K, V> implements KeycloakTransaction {\n+\n+    private final static Logger log = Logger.getLogger(MapKeycloakTransaction.class);\n+\n+    private enum MapOperation {\n+        PUT {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.put(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        PUT_IF_ABSENT {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.putIfAbsent(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        REMOVE {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(null) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.remove(key);\n+                    }\n+                };\n+            }\n+        },\n+        REPLACE {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.replace(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        ;\n+\n+        protected abstract <K, V> MapTaskWithValue<K, V> taskFor(K key, V value);\n+\n+    }\n+\n+    private boolean active;\n+    private boolean rollback;\n+    private final Map<K, MapTaskWithValue<K, V>> tasks = new LinkedHashMap<>();\n+    private final MapStorage<K, V> map;\n+\n+    public MapKeycloakTransaction(MapStorage<K, V> map) {\n+        this.map = map;\n+    }\n+\n+    @Override\n+    public void begin() {\n+        active = true;\n+    }\n+\n+    @Override\n+    public void commit() {\n+        if (rollback) {\n+            throw new RuntimeException(\"Rollback only!\");\n+        }\n+\n+        for (MapTaskWithValue<K, V> value : tasks.values()) {\n+            value.execute(map);\n+        }\n+    }\n+\n+    @Override\n+    public void rollback() {\n+        tasks.clear();\n+    }\n+\n+    @Override\n+    public void setRollbackOnly() {\n+        rollback = true;\n+    }\n+\n+    @Override\n+    public boolean getRollbackOnly() {\n+        return rollback;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    /**\n+     * Adds a given task if not exists for the given key\n+     * @return {@code true} if a task for the given key already exists", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b51c8c093982984e11bea86a7d7c45ddcd9701a"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3Mjg2NA==", "bodyText": "That's true :-) Fixed, thanks!", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457072864", "createdAt": "2020-07-20T05:47:06Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/MapKeycloakTransaction.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.models.KeycloakTransaction;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import org.jboss.logging.Logger;\n+\n+public class MapKeycloakTransaction<K, V> implements KeycloakTransaction {\n+\n+    private final static Logger log = Logger.getLogger(MapKeycloakTransaction.class);\n+\n+    private enum MapOperation {\n+        PUT {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.put(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        PUT_IF_ABSENT {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.putIfAbsent(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        REMOVE {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(null) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.remove(key);\n+                    }\n+                };\n+            }\n+        },\n+        REPLACE {\n+            @Override\n+            protected <K, V> MapTaskWithValue<K, V> taskFor(K key, V value) {\n+                return new MapTaskWithValue<K, V>(value) {\n+                    @Override\n+                    public void execute(MapStorage<K, V> map) {\n+                        map.replace(key, getValue());\n+                    }\n+                };\n+            }\n+        },\n+        ;\n+\n+        protected abstract <K, V> MapTaskWithValue<K, V> taskFor(K key, V value);\n+\n+    }\n+\n+    private boolean active;\n+    private boolean rollback;\n+    private final Map<K, MapTaskWithValue<K, V>> tasks = new LinkedHashMap<>();\n+    private final MapStorage<K, V> map;\n+\n+    public MapKeycloakTransaction(MapStorage<K, V> map) {\n+        this.map = map;\n+    }\n+\n+    @Override\n+    public void begin() {\n+        active = true;\n+    }\n+\n+    @Override\n+    public void commit() {\n+        if (rollback) {\n+            throw new RuntimeException(\"Rollback only!\");\n+        }\n+\n+        for (MapTaskWithValue<K, V> value : tasks.values()) {\n+            value.execute(map);\n+        }\n+    }\n+\n+    @Override\n+    public void rollback() {\n+        tasks.clear();\n+    }\n+\n+    @Override\n+    public void setRollbackOnly() {\n+        rollback = true;\n+    }\n+\n+    @Override\n+    public boolean getRollbackOnly() {\n+        return rollback;\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return active;\n+    }\n+\n+    /**\n+     * Adds a given task if not exists for the given key\n+     * @return {@code true} if a task for the given key already exists", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5OTA2OA=="}, "originalCommit": {"oid": "5b51c8c093982984e11bea86a7d7c45ddcd9701a"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MjE2MjkzOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/storage/ConcurrentHashMapStorageProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNzowNjowOFrOGz8HDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNzowNjowOFrOGz8HDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzExNTQwNg==", "bodyText": "When running KeycloakServer.java from idea the working directory is set to keycloak root directory. Therefore this fails with file or directory doesn't exists because target directory is not there. Can we use project.build.directory variable? Also how this will work if we will run it on wildfly or using quarkus jar file? Should we provide some env variable to set this path?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457115406", "createdAt": "2020-07-20T07:06:08Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/storage/ConcurrentHashMapStorageProvider.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.storage;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.models.map.common.AbstractEntity;\n+import org.keycloak.models.map.common.Serialization;\n+import com.fasterxml.jackson.databind.JavaType;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.jboss.logging.Logger;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class ConcurrentHashMapStorageProvider implements MapStorageProvider {\n+\n+    private static class ConcurrentHashMapStorage<K, V> extends ConcurrentHashMap<K, V> implements MapStorage<K, V> {\n+    }\n+\n+    private static final String PROVIDER_ID = \"concurrenthashmap\";\n+\n+    private static final Logger LOG = Logger.getLogger(ConcurrentHashMapStorageProvider.class);\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<?,?>> storages = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public MapStorageProvider create(KeycloakSession session) {\n+        return this;\n+    }\n+\n+    @Override\n+    public void init(Scope config) {\n+    }\n+\n+    @Override\n+    public void postInit(KeycloakSessionFactory factory) {\n+    }\n+\n+    @Override\n+    public void close() {\n+        storages.forEach(ConcurrentHashMapStorageProvider::storeMap);\n+    }\n+\n+    private static void storeMap(String fileName, ConcurrentHashMap<?, ?> store) {\n+        if (fileName != null) {\n+            final File f = new File(\"target/map-\" + fileName + \".json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f69556e084053f12500968b7d3f65b0ac309d74"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MzY1ODE3OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMjoyMDo0N1rOG0JVKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzo0MDoyOVrOG0NGEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMzMjAwOQ==", "bodyText": "In regards to methods returning a Collection, would it break other places if we return an unmodifiable collection?\nI'm wondering if not doing so, client code could change state by changing those collections directly without reflecting on the update state.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457332009", "createdAt": "2020-07-20T12:20:47Z", "author": {"login": "pedroigor"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.client;\n+\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.map.common.AbstractEntity;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public abstract class AbstractClientEntity<K> implements AbstractEntity<K> {\n+\n+    private K id;\n+    private String realmId;\n+\n+    private String clientId;\n+    private String name;\n+    private String description;\n+    private Set<String> redirectUris = new HashSet<>();\n+    private boolean enabled;\n+    private boolean alwaysDisplayInConsole;\n+    private String clientAuthenticatorType;\n+    private String secret;\n+    private String registrationToken;\n+    private String protocol;\n+    private Map<String, String> attributes = new HashMap<>();\n+    private Map<String, String> authFlowBindings = new HashMap<>();\n+    private boolean publicClient;\n+    private boolean fullScopeAllowed;\n+    private boolean frontchannelLogout;\n+    private int notBefore;\n+    private Set<String> scope = new HashSet<>();\n+    private Set<String> webOrigins = new HashSet<>();\n+    private Map<String, ProtocolMapperModel> protocolMappers = new HashMap<>();\n+    private Map<String, Boolean> clientScopes = new HashMap<>();\n+    private Set<String> scopeMappings = new LinkedHashSet<>();\n+    private List<String> defaultRoles = new LinkedList<>();\n+    private boolean surrogateAuthRequired;\n+    private String managementUrl;\n+    private String rootUrl;\n+    private String baseUrl;\n+    private boolean bearerOnly;\n+    private boolean consentRequired;\n+    private boolean standardFlowEnabled;\n+    private boolean implicitFlowEnabled;\n+    private boolean directAccessGrantsEnabled;\n+    private boolean serviceAccountsEnabled;\n+    private int nodeReRegistrationTimeout;\n+\n+    /**\n+     * Flag signalizing that any of the setters has been meaningfully used.\n+     */\n+    protected boolean updated;\n+\n+    protected AbstractClientEntity() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5MzY4Mw==", "bodyText": "*Entity is private class and the high-level code only uses *Model implementations.\nIn the particular case of map models introduced here, if the client code fails to update the updated state, then the entity is never persisted (see MapKeycloakTransaction.putIfChanged(K, V, Predicate<V>)). Other implementations can choose another mechanism, e.g. by returning unmodifiable collections as you suggested.\nGenerally, the model implementations ensure that the contract of updating the updated is properly maintained, e.g. by only exposing read-only collections for getters, and separate methods for modifying the collections. Cf. ProtocolMappers handling in MapClientAdapter.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457393683", "createdAt": "2020-07-20T13:40:29Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/AbstractClientEntity.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.client;\n+\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.map.common.AbstractEntity;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public abstract class AbstractClientEntity<K> implements AbstractEntity<K> {\n+\n+    private K id;\n+    private String realmId;\n+\n+    private String clientId;\n+    private String name;\n+    private String description;\n+    private Set<String> redirectUris = new HashSet<>();\n+    private boolean enabled;\n+    private boolean alwaysDisplayInConsole;\n+    private String clientAuthenticatorType;\n+    private String secret;\n+    private String registrationToken;\n+    private String protocol;\n+    private Map<String, String> attributes = new HashMap<>();\n+    private Map<String, String> authFlowBindings = new HashMap<>();\n+    private boolean publicClient;\n+    private boolean fullScopeAllowed;\n+    private boolean frontchannelLogout;\n+    private int notBefore;\n+    private Set<String> scope = new HashSet<>();\n+    private Set<String> webOrigins = new HashSet<>();\n+    private Map<String, ProtocolMapperModel> protocolMappers = new HashMap<>();\n+    private Map<String, Boolean> clientScopes = new HashMap<>();\n+    private Set<String> scopeMappings = new LinkedHashSet<>();\n+    private List<String> defaultRoles = new LinkedList<>();\n+    private boolean surrogateAuthRequired;\n+    private String managementUrl;\n+    private String rootUrl;\n+    private String baseUrl;\n+    private boolean bearerOnly;\n+    private boolean consentRequired;\n+    private boolean standardFlowEnabled;\n+    private boolean implicitFlowEnabled;\n+    private boolean directAccessGrantsEnabled;\n+    private boolean serviceAccountsEnabled;\n+    private int nodeReRegistrationTimeout;\n+\n+    /**\n+     * Flag signalizing that any of the setters has been meaningfully used.\n+     */\n+    protected boolean updated;\n+\n+    protected AbstractClientEntity() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMzMjAwOQ=="}, "originalCommit": {"oid": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MzY4NzM1OnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientAdapter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMjoyNzoxMVrOG0Jl9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzoyNDoyNFrOG0MNFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMzNjMwOA==", "bodyText": "Any reason why those methods are not in AbstractClientModel ? Are we supposed to have other implementations of AbstractClientModel ?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457336308", "createdAt": "2020-07-20T12:27:11Z", "author": {"login": "pedroigor"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientAdapter.java", "diffHunk": "@@ -0,0 +1,540 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.client;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import com.google.common.base.Functions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public abstract class MapClientAdapter extends AbstractClientModel<MapClientEntity> implements ClientModel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM3OTA5Mw==", "bodyText": "AbstractClientModel only contains methods that operate on data that are not directly stored in entity and are delegated via session object. The implementation can choose to store the physical format (i.e. the entity) in any way - e.g. json, POJO, DB columns in tables - and should implement the ClientModel methods accordingly without any prescription from a predecessor.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457379093", "createdAt": "2020-07-20T13:24:24Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/client/MapClientAdapter.java", "diffHunk": "@@ -0,0 +1,540 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.client;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import com.google.common.base.Functions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public abstract class MapClientAdapter extends AbstractClientModel<MapClientEntity> implements ClientModel {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMzNjMwOA=="}, "originalCommit": {"oid": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Mzc4ODgzOnYy", "diffSide": "RIGHT", "path": "model/map/src/main/java/org/keycloak/models/map/common/Serialization.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMjo0NzoxNVrOG0KfDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzoxOToxMlrOG0L62Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM1MDkyNg==", "bodyText": "Does it need to be public? Wondering if public would cause people misusing this instance and not using the method.\nI think I understand why you have another instance of ObjectMapper and JsonSerialization is not enough. But is there some way to just reuse JsonSerialization ?", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457350926", "createdAt": "2020-07-20T12:47:15Z", "author": {"login": "pedroigor"}, "path": "model/map/src/main/java/org/keycloak/models/map/common/Serialization.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.common;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.PropertyAccessor;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class Serialization {\n+\n+    public static final ObjectMapper MAPPER = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM3NDQyNQ==", "bodyText": "Does it need to be public?\n\nNo, it need not, yet having it public helps in ConcurrentHashMapStorageProvider to use the same way of entity serialization as this \"cloning\" utility, and that in turn helps to debug issues with storing a representation of entities.\n\nWondering if public would cause people misusing this instance and not using the method.\n\nThis instance should not be ordinarily visible to the public since model/map module (as well as any from the model/ modules) is not usually included as a dependency.\n\nI think I understand why you have another instance of ObjectMapper and JsonSerialization is not enough. But is there some way to just reuse JsonSerialization ?\n\nHaving these two separately is a better option, since the aim is to minimize impact on the existing code. The way of serialization is different (fields vs getters/setters), and aim is to have the entitites decoupled from serialization annotations. In the case of this Serialization class, jackson annotations on the fields (e.g. @JsonIgnore) are never in the entity, and are located in the serialization logics, i.e. in Serialization class. This makes it easy to decouple entities from their physical storage layout.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457374425", "createdAt": "2020-07-20T13:19:12Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/common/Serialization.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.common;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.PropertyAccessor;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ * @author hmlnarik\n+ */\n+public class Serialization {\n+\n+    public static final ObjectMapper MAPPER = new ObjectMapper();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM1MDkyNg=="}, "originalCommit": {"oid": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NzQ2NDg1OnYy", "diffSide": "RIGHT", "path": "testsuite/utils/src/main/resources/META-INF/keycloak-server.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNzo1OToyN1rOG0sk5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoyNjoxNlrOG033gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkwOTQ3OA==", "bodyText": "The JPA store should still be the default for developers. For those that are not working on the new store this would be a distraction and potential cause of failures. Personally for example I use KeycloakServer quite heavily, and often use it with a persisted H2 db.\nI'd also suggest setting up a GitHub Actions workflow (or add a job to existing workflow) specifically for the new map store that.", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r457909478", "createdAt": "2020-07-21T07:59:27Z", "author": {"login": "stianst"}, "path": "testsuite/utils/src/main/resources/META-INF/keycloak-server.json", "diffHunk": "@@ -18,6 +18,17 @@\n         \"provider\": \"${keycloak.realm.provider:}\"\n     },\n \n+    \"client\": {\n+        \"provider\": \"${keycloak.client.provider:map}\"\n+    },\n+\n+    \"mapStorage\": {\n+        \"provider\": \"${keycloak.mapStorage.provider:concurrenthashmap}\",\n+        \"concurrenthashmap\": {\n+            \"dir\": \"${project.build.directory:target}\"\n+        }\n+    },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA5NDQ2NA==", "bodyText": "The store has been reverted to default to JPA for the developers, and GH Actions was added to test Undertow with map provider. Thanks for the suggestions!", "url": "https://github.com/keycloak/keycloak/pull/7231#discussion_r458094464", "createdAt": "2020-07-21T13:26:16Z", "author": {"login": "hmlnarik"}, "path": "testsuite/utils/src/main/resources/META-INF/keycloak-server.json", "diffHunk": "@@ -18,6 +18,17 @@\n         \"provider\": \"${keycloak.realm.provider:}\"\n     },\n \n+    \"client\": {\n+        \"provider\": \"${keycloak.client.provider:map}\"\n+    },\n+\n+    \"mapStorage\": {\n+        \"provider\": \"${keycloak.mapStorage.provider:concurrenthashmap}\",\n+        \"concurrenthashmap\": {\n+            \"dir\": \"${project.build.directory:target}\"\n+        }\n+    },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkwOTQ3OA=="}, "originalCommit": {"oid": "59d9466ddd510f6cfebdaec5ff3c72aa1f55be9d"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3458, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}