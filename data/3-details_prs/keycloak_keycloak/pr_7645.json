{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MTU4MjAw", "number": 7645, "title": "KEYCLOAK-15847 Add MapUserProvider", "bodyText": "", "createdAt": "2020-11-26T15:50:35Z", "url": "https://github.com/keycloak/keycloak/pull/7645", "merged": true, "mergeCommit": {"oid": "8e376aef51b4b5d7ade4e5196ee628a086c1749a"}, "closed": true, "closedAt": "2020-12-10T07:57:54Z", "author": {"login": "mhajas"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgVGOWgBqjQwNDMxNDkzODE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkunqkAFqTU0ODkzMTkxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e0e50d3cd84e8831d93d87388680b691b3add958", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/e0e50d3cd84e8831d93d87388680b691b3add958", "committedDate": "2020-11-26T15:50:13Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}, "afterCommit": {"oid": "63c2c90dc52f776f070c49204c0582809db089c4", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/63c2c90dc52f776f070c49204c0582809db089c4", "committedDate": "2020-11-26T15:57:27Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63c2c90dc52f776f070c49204c0582809db089c4", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/63c2c90dc52f776f070c49204c0582809db089c4", "committedDate": "2020-11-26T15:57:27Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}, "afterCommit": {"oid": "1d1d9e83439ef636785f5549efdf1cdaadc579ba", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/1d1d9e83439ef636785f5549efdf1cdaadc579ba", "committedDate": "2020-11-27T09:18:06Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1d1d9e83439ef636785f5549efdf1cdaadc579ba", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/1d1d9e83439ef636785f5549efdf1cdaadc579ba", "committedDate": "2020-11-27T09:18:06Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}, "afterCommit": {"oid": "e08a2518cfcc9456a6022a90e982f591577ae0a4", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/e08a2518cfcc9456a6022a90e982f591577ae0a4", "committedDate": "2020-11-27T09:23:03Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e08a2518cfcc9456a6022a90e982f591577ae0a4", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/e08a2518cfcc9456a6022a90e982f591577ae0a4", "committedDate": "2020-11-27T09:23:03Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}, "afterCommit": {"oid": "8df17fe710c6b7ad8c41a65a18137885f2692c53", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/8df17fe710c6b7ad8c41a65a18137885f2692c53", "committedDate": "2020-11-27T09:59:54Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzA2NDM5", "url": "https://github.com/keycloak/keycloak/pull/7645#pullrequestreview-544706439", "createdAt": "2020-12-04T07:17:52Z", "commit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzoxNzo1MlrOH_D2NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODoyNToyMVrOH_F3Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4NTM2NQ==", "bodyText": "Why is this change here?", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535885365", "createdAt": "2020-12-04T07:17:52Z", "author": {"login": "hmlnarik"}, "path": "testsuite/integration-arquillian/tests/base/src/test/resources/export/partialexport-testrealm.json", "diffHunk": "@@ -1155,6 +1155,9 @@\n           ],\n           \"authType\": [\n             \"simple\"\n+          ],\n+          \"enabled\": [\n+            \"false\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5MjczMA==", "bodyText": "This file should remain unchanged.", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535892730", "createdAt": "2020-12-04T07:35:02Z", "author": {"login": "hmlnarik"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java", "diffHunk": "@@ -334,7 +334,7 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, Integer firstResult, Integer maxResults) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5NDA5Nw==", "bodyText": "They should not. Even if rare in practice, latest version of RFC 5336 says that the local part of email is case-sensitive. OTOH, most email servers (e.g. GMail, Postfix) ignore letter case.\nIs this because of search? Then we need to stress that it needs to be searchable, but that will be done later in the search operation of the underlying storage.", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535894097", "createdAt": "2020-12-04T07:37:57Z", "author": {"login": "hmlnarik"}, "path": "server-spi/src/main/java/org/keycloak/models/UserModel.java", "diffHunk": "@@ -143,6 +158,11 @@\n \n     String getEmail();\n \n+    /**\n+     * Sets email for this user, email should be switched to lowercase before setting.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwMzE0Ng==", "bodyText": "First sentence should explain the purpose of this method, and state what it does not should only come after that.", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535903146", "createdAt": "2020-12-04T07:56:37Z", "author": {"login": "hmlnarik"}, "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java", "diffHunk": "@@ -18,15 +18,52 @@\n package org.keycloak.events;\n \n import org.keycloak.events.admin.AdminEvent;\n+import org.keycloak.models.KeycloakTransaction;\n import org.keycloak.provider.Provider;\n \n /**\n  * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n+ *\n+ * Note that invocation of any of {@code onEvent} methods doesn't mean that the event happened at the moment but that it\n+ * will happen during the main transaction commit. This means the execution, corresponding to the triggered event,\n+ * may end up with a failure. Therefore, each implementation of this interface should consider using an internal\n+ * {@link KeycloakTransaction} for firing events only in case the main transaction ends up successfuly. This can be\n+ * achieved by enlisting the internal transaction to {@link org.keycloak.models.KeycloakTransactionManager} using the\n+ * {@link org.keycloak.models.KeycloakTransactionManager#enlistAfterCompletion(KeycloakTransaction)} method.\n+ *\n  */\n public interface EventListenerProvider extends Provider {\n \n+    /**\n+     *\n+     * Invocation of this method doesn't mean the execution described by the event will truly happen. It can be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwMzE5OA==", "bodyText": "same as above", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535903198", "createdAt": "2020-12-04T07:56:46Z", "author": {"login": "hmlnarik"}, "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java", "diffHunk": "@@ -18,15 +18,52 @@\n package org.keycloak.events;\n \n import org.keycloak.events.admin.AdminEvent;\n+import org.keycloak.models.KeycloakTransaction;\n import org.keycloak.provider.Provider;\n \n /**\n  * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n+ *\n+ * Note that invocation of any of {@code onEvent} methods doesn't mean that the event happened at the moment but that it\n+ * will happen during the main transaction commit. This means the execution, corresponding to the triggered event,\n+ * may end up with a failure. Therefore, each implementation of this interface should consider using an internal\n+ * {@link KeycloakTransaction} for firing events only in case the main transaction ends up successfuly. This can be\n+ * achieved by enlisting the internal transaction to {@link org.keycloak.models.KeycloakTransactionManager} using the\n+ * {@link org.keycloak.models.KeycloakTransactionManager#enlistAfterCompletion(KeycloakTransaction)} method.\n+ *\n  */\n public interface EventListenerProvider extends Provider {\n \n+    /**\n+     *\n+     * Invocation of this method doesn't mean the execution described by the event will truly happen. It can be\n+     * rolled back by the {@link org.keycloak.models.KeycloakTransactionManager} in case of some failure. It is \n+     * recommended to use this method just for saving events to be able to fire them only in case of the successful\n+     * transaction.\n+     * \n+     * Note that this method should be always invoked in time when the main transaction is active, therefore it can be\n+     * used, for example, to make some changes in the database, ldap storage etc.\n+     * \n+     * \n+     * @param event to be triggered\n+     */\n     void onEvent(Event event);\n \n+    /**\n+     *\n+     * Invocation of this method doesn't mean the execution described by the event will truly happen. It can be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwNDc4Ng==", "bodyText": "First paragraph should explain what is purpose of this interface, when it would be called etc. This explanation should only come after that.", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535904786", "createdAt": "2020-12-04T07:59:49Z", "author": {"login": "hmlnarik"}, "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java", "diffHunk": "@@ -18,15 +18,52 @@\n package org.keycloak.events;\n \n import org.keycloak.events.admin.AdminEvent;\n+import org.keycloak.models.KeycloakTransaction;\n import org.keycloak.provider.Provider;\n \n /**\n  * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n+ *\n+ * Note that invocation of any of {@code onEvent} methods doesn't mean that the event happened at the moment but that it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwNTg5NA==", "bodyText": "Firing an event should be precondition for this interface's methods to be invoked. Maybe persisting would express the intention? (same in the javadocs below)", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535905894", "createdAt": "2020-12-04T08:01:58Z", "author": {"login": "hmlnarik"}, "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java", "diffHunk": "@@ -18,15 +18,52 @@\n package org.keycloak.events;\n \n import org.keycloak.events.admin.AdminEvent;\n+import org.keycloak.models.KeycloakTransaction;\n import org.keycloak.provider.Provider;\n \n /**\n  * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n+ *\n+ * Note that invocation of any of {@code onEvent} methods doesn't mean that the event happened at the moment but that it\n+ * will happen during the main transaction commit. This means the execution, corresponding to the triggered event,\n+ * may end up with a failure. Therefore, each implementation of this interface should consider using an internal\n+ * {@link KeycloakTransaction} for firing events only in case the main transaction ends up successfuly. This can be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkxMTQyMw==", "bodyText": "It should not, there is demand for case-sensitive username support. See e.g. https://issues.redhat.com/browse/KEYCLOAK-5699.\nFor this moment, Keycloak uses case-insensitive usernames. Is this because of search? Then we need to stress that it needs to be case-insensitive searchable, but that will be done later in the search operation of the underlying storage.", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535911423", "createdAt": "2020-12-04T08:12:32Z", "author": {"login": "hmlnarik"}, "path": "server-spi/src/main/java/org/keycloak/models/UserModel.java", "diffHunk": "@@ -56,7 +59,13 @@\n     // No default method here to allow Abstract subclasses where the username is provided in a different manner\n     String getUsername();\n \n-    // No default method here to allow Abstract subclasses where the username is provided in a different manner\n+    /**\n+     * Sets username for this user, username should be switched to lowercase before setting.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkxMTcyNg==", "bodyText": "There should be check for action != null (even though I appreciate it's not there in the original JPA variant)", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535911726", "createdAt": "2020-12-04T08:13:09Z", "author": {"login": "hmlnarik"}, "path": "server-spi/src/main/java/org/keycloak/models/UserModel.java", "diffHunk": "@@ -129,9 +138,15 @@\n \n     void removeRequiredAction(String action);\n \n-    void addRequiredAction(RequiredAction action);\n+    default void addRequiredAction(RequiredAction action) {\n+        String actionName = action.name();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkxODMzOQ==", "bodyText": "Should compare irrespective of case?", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535918339", "createdAt": "2020-12-04T08:25:21Z", "author": {"login": "hmlnarik"}, "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserEntity.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.user;\n+\n+import java.util.Comparator;\n+import java.util.UUID;\n+\n+public class MapUserEntity extends AbstractUserEntity<UUID> {\n+\n+    public static final Comparator<MapUserEntity> COMPARE_BY_USERNAME = Comparator.comparing(MapUserEntity::getUsername);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bae9cf0feb576039b88009062309846d02e19f96"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bcd5c300e859914ffdbf7f1003c5afb5a9aa8586", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/bcd5c300e859914ffdbf7f1003c5afb5a9aa8586", "committedDate": "2020-12-07T11:18:20Z", "message": "KEYCLOAK-15847 Fix Hynek's comments"}, "afterCommit": {"oid": "c13e24d57064e1c494faeb5213ae61225f70f6c0", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/c13e24d57064e1c494faeb5213ae61225f70f6c0", "committedDate": "2020-12-08T11:13:19Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/2414212e6ac1e91ad9c902eb5833dfc62cb89084", "committedDate": "2020-12-08T11:14:46Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c13e24d57064e1c494faeb5213ae61225f70f6c0", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/c13e24d57064e1c494faeb5213ae61225f70f6c0", "committedDate": "2020-12-08T11:13:19Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}, "afterCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/2414212e6ac1e91ad9c902eb5833dfc62cb89084", "committedDate": "2020-12-08T11:14:46Z", "message": "KEYCLOAK-15847 Add MapUserProvider"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMjM0OTI4", "url": "https://github.com/keycloak/keycloak/pull/7645#pullrequestreview-542234928", "createdAt": "2020-12-01T19:40:15Z", "commit": {"oid": "8df17fe710c6b7ad8c41a65a18137885f2692c53"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOTo0MDoxNVrOH882LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOTowNDozMFrOIBxghw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MzUxNg==", "bodyText": "Shouldn't this method (right at the bottom, before returning the results stream) be using the paginateQuery method you've added to validate the firstResult and maxResults params?", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r533673516", "createdAt": "2020-12-01T19:40:15Z", "author": {"login": "sguilhen"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -810,7 +797,7 @@ public int getUsersCount(Map<String, String> params, RealmModel realm, Set<Strin\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm, Integer firstResult, Integer maxResults) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8df17fe710c6b7ad8c41a65a18137885f2692c53"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3NDA1NQ==", "bodyText": "Just a question: where are we now deleting the federated identity?", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r533674055", "createdAt": "2020-12-01T19:41:09Z", "author": {"login": "sguilhen"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -152,18 +162,10 @@ private void removeUser(UserEntity user) {\n         String id = user.getId();\n         em.createNamedQuery(\"deleteUserRoleMappingsByUser\").setParameter(\"user\", user).executeUpdate();\n         em.createNamedQuery(\"deleteUserGroupMembershipsByUser\").setParameter(\"user\", user).executeUpdate();\n-        em.createNamedQuery(\"deleteFederatedIdentityByUser\").setParameter(\"user\", user).executeUpdate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8df17fe710c6b7ad8c41a65a18137885f2692c53"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3NTE1NA==", "bodyText": "I guess this answers my question above about the federated identities. :)", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r533675154", "createdAt": "2020-12-01T19:43:06Z", "author": {"login": "sguilhen"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/entities/UserEntity.java", "diffHunk": "@@ -110,7 +110,7 @@\n     @BatchSize(size = 20)\n     protected Collection<CredentialEntity> credentials;\n \n-    @OneToMany(mappedBy=\"user\")\n+    @OneToMany(cascade = CascadeType.REMOVE, orphanRemoval = true, mappedBy=\"user\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8df17fe710c6b7ad8c41a65a18137885f2692c53"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY4MzU4OQ==", "bodyText": "This has now to implement UserCredentialStore.Streams", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538683589", "createdAt": "2020-12-08T18:15:02Z", "author": {"login": "sguilhen"}, "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java", "diffHunk": "@@ -0,0 +1,875 @@\n+package org.keycloak.models.map.user;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.jboss.logging.Logger;\n+import org.keycloak.authorization.AuthorizationProvider;\n+import org.keycloak.authorization.store.ResourceStore;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.credential.CredentialModel;\n+import org.keycloak.credential.UserCredentialStore;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.FederatedIdentityModel;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.IdentityProviderModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RequiredActionProviderModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserProvider;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+import org.keycloak.models.utils.DefaultRoles;\n+import org.keycloak.storage.StorageId;\n+import org.keycloak.storage.UserStorageProvider;\n+import org.keycloak.storage.client.ClientStorageProvider;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import static org.keycloak.models.UserModel.EMAIL;\n+import static org.keycloak.models.UserModel.EMAIL_VERIFIED;\n+import static org.keycloak.models.UserModel.FIRST_NAME;\n+import static org.keycloak.models.UserModel.LAST_NAME;\n+import static org.keycloak.models.UserModel.USERNAME;\n+\n+public class MapUserProvider implements UserProvider.Streams, UserCredentialStore {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMTI1OQ==", "bodyText": "Out of curiosity, why a registered entity in a getter?", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538711259", "createdAt": "2020-12-08T18:41:48Z", "author": {"login": "sguilhen"}, "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java", "diffHunk": "@@ -0,0 +1,875 @@\n+package org.keycloak.models.map.user;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.jboss.logging.Logger;\n+import org.keycloak.authorization.AuthorizationProvider;\n+import org.keycloak.authorization.store.ResourceStore;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.credential.CredentialModel;\n+import org.keycloak.credential.UserCredentialStore;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.FederatedIdentityModel;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.IdentityProviderModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RequiredActionProviderModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserProvider;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+import org.keycloak.models.utils.DefaultRoles;\n+import org.keycloak.storage.StorageId;\n+import org.keycloak.storage.UserStorageProvider;\n+import org.keycloak.storage.client.ClientStorageProvider;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import static org.keycloak.models.UserModel.EMAIL;\n+import static org.keycloak.models.UserModel.EMAIL_VERIFIED;\n+import static org.keycloak.models.UserModel.FIRST_NAME;\n+import static org.keycloak.models.UserModel.LAST_NAME;\n+import static org.keycloak.models.UserModel.USERNAME;\n+\n+public class MapUserProvider implements UserProvider.Streams, UserCredentialStore {\n+\n+    private static final Logger LOG = Logger.getLogger(MapUserProvider.class);\n+    private static final Predicate<MapUserEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapUserEntity> tx;\n+    private final MapStorage<UUID, MapUserEntity> userStore;\n+\n+    public MapUserProvider(KeycloakSession session, MapStorage<UUID, MapUserEntity> store) {\n+        this.session = session;\n+        this.userStore = store;\n+        this.tx = new MapKeycloakTransaction<>(userStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private MapUserEntity registerEntityForChanges(MapUserEntity origEntity) {\n+        MapUserEntity res = tx.get(origEntity.getId(), id -> Serialization.from(origEntity));\n+        tx.putIfChanged(origEntity.getId(), res, MapUserEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapUserEntity, UserModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+        return origEntity -> new MapUserAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+\n+            @Override\n+            public boolean checkEmailUniqueness(RealmModel realm, String email) {\n+                return getUserByEmail(email, realm) != null;\n+            }\n+\n+            @Override\n+            public boolean checkUsernameUniqueness(RealmModel realm, String username) {\n+                return getUserByUsername(username, realm) != null;\n+            }\n+        };\n+    }\n+\n+    private Predicate<MapUserEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapUserProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private ModelException userDoesntExistException() {\n+        return new ModelException(\"Specified user doesn't exist.\");\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, String id) {\n+        try {\n+            return getEntityById(realm, UUID.fromString(id));\n+        } catch (IllegalArgumentException ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private MapUserEntity getEntityByIdOrThrow(RealmModel realm, String id) {\n+        return getEntityById(realm, id)\n+                .orElseThrow(this::userDoesntExistException);\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, UUID id) {\n+        MapUserEntity mapUserEntity = tx.get(id, userStore::get);\n+        if (mapUserEntity != null && entityRealmFilter(realm).test(mapUserEntity)) {\n+            return Optional.of(mapUserEntity);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private Optional<MapUserEntity> getRegisteredEntityById(RealmModel realm, String id) {\n+        return getEntityById(realm, id).map(this::registerEntityForChanges);\n+    }\n+\n+    private Stream<MapUserEntity> getNotRemovedUpdatedUsersStream() {\n+        Stream<MapUserEntity> updatedAndNotRemovedUsersStream = userStore.entrySet().stream()\n+                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n+                .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedUsersStream);\n+    }\n+\n+    private Stream<MapUserEntity> getUnsortedUserEntitiesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedUsersStream()\n+                .filter(entityRealmFilter(realm));\n+    }\n+    \n+    private <T> Stream<T> paginatedStream(Stream<T> originalStream, Integer first, Integer max) {\n+        if (first != null && first > 0) {\n+            originalStream = originalStream.skip(first);\n+        }\n+\n+        if (max != null && max >= 0) {\n+            originalStream = originalStream.limit(max);\n+        }\n+\n+        return originalStream;\n+    }\n+\n+    @Override\n+    public void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIdentityModel socialLink) {\n+        if (user == null || user.getId() == null) {\n+            return;\n+        }\n+        LOG.tracef(\"addFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialLink.getIdentityProvider(), getShortStackTrace());\n+\n+        getRegisteredEntityById(realm, user.getId())\n+                .ifPresent(userEntity ->\n+                        userEntity.addFederatedIdentity(UserFederatedIdentityEntity.fromModel(socialLink)));\n+    }\n+\n+    @Override\n+    public boolean removeFederatedIdentity(RealmModel realm, UserModel user, String socialProvider) {\n+        LOG.tracef(\"removeFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())\n+                .map(entity -> entity.removeFederatedIdentity(socialProvider))\n+                .orElse(false);\n+    }\n+\n+    @Override\n+    public void preRemove(RealmModel realm, IdentityProviderModel provider) {\n+        String socialProvider = provider.getAlias();\n+        LOG.tracef(\"preRemove[RealmModel realm, IdentityProviderModel provider](%s, %s)%s\", realm, socialProvider, getShortStackTrace());\n+        getUnsortedUserEntitiesStream(realm)\n+                .map(this::registerEntityForChanges)\n+                .forEach(userEntity -> userEntity.removeFederatedIdentity(socialProvider));\n+    }\n+\n+    @Override\n+    public void updateFederatedIdentity(RealmModel realm, UserModel federatedUser, FederatedIdentityModel federatedIdentityModel) {\n+        LOG.tracef(\"updateFederatedIdentity(%s, %s, %s)%s\", realm, federatedUser.getId(), federatedIdentityModel.getIdentityProvider(), getShortStackTrace());\n+        getRegisteredEntityById(realm, federatedUser.getId())\n+                .ifPresent(entity -> entity.updateFederatedIdentity(UserFederatedIdentityEntity.fromModel(federatedIdentityModel)));\n+    }\n+\n+    @Override\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentitiesStream(%s, %s)%s\", realm, user.getId(), getShortStackTrace());\n+        return getEntityById(realm, user.getId())\n+                .map(AbstractUserEntity::getFederatedIdentities).orElseGet(Stream::empty)\n+                .map(UserFederatedIdentityEntity::toModel);\n+    }\n+\n+    @Override\n+    public FederatedIdentityModel getFederatedIdentity(UserModel user, String socialProvider, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMDQ5Mg==", "bodyText": "Typo? \"Consent or not found... \"", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538730492", "createdAt": "2020-12-08T19:04:17Z", "author": {"login": "sguilhen"}, "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java", "diffHunk": "@@ -0,0 +1,875 @@\n+package org.keycloak.models.map.user;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.jboss.logging.Logger;\n+import org.keycloak.authorization.AuthorizationProvider;\n+import org.keycloak.authorization.store.ResourceStore;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.credential.CredentialModel;\n+import org.keycloak.credential.UserCredentialStore;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.FederatedIdentityModel;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.IdentityProviderModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RequiredActionProviderModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserProvider;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+import org.keycloak.models.utils.DefaultRoles;\n+import org.keycloak.storage.StorageId;\n+import org.keycloak.storage.UserStorageProvider;\n+import org.keycloak.storage.client.ClientStorageProvider;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import static org.keycloak.models.UserModel.EMAIL;\n+import static org.keycloak.models.UserModel.EMAIL_VERIFIED;\n+import static org.keycloak.models.UserModel.FIRST_NAME;\n+import static org.keycloak.models.UserModel.LAST_NAME;\n+import static org.keycloak.models.UserModel.USERNAME;\n+\n+public class MapUserProvider implements UserProvider.Streams, UserCredentialStore {\n+\n+    private static final Logger LOG = Logger.getLogger(MapUserProvider.class);\n+    private static final Predicate<MapUserEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapUserEntity> tx;\n+    private final MapStorage<UUID, MapUserEntity> userStore;\n+\n+    public MapUserProvider(KeycloakSession session, MapStorage<UUID, MapUserEntity> store) {\n+        this.session = session;\n+        this.userStore = store;\n+        this.tx = new MapKeycloakTransaction<>(userStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private MapUserEntity registerEntityForChanges(MapUserEntity origEntity) {\n+        MapUserEntity res = tx.get(origEntity.getId(), id -> Serialization.from(origEntity));\n+        tx.putIfChanged(origEntity.getId(), res, MapUserEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapUserEntity, UserModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+        return origEntity -> new MapUserAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+\n+            @Override\n+            public boolean checkEmailUniqueness(RealmModel realm, String email) {\n+                return getUserByEmail(email, realm) != null;\n+            }\n+\n+            @Override\n+            public boolean checkUsernameUniqueness(RealmModel realm, String username) {\n+                return getUserByUsername(username, realm) != null;\n+            }\n+        };\n+    }\n+\n+    private Predicate<MapUserEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapUserProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private ModelException userDoesntExistException() {\n+        return new ModelException(\"Specified user doesn't exist.\");\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, String id) {\n+        try {\n+            return getEntityById(realm, UUID.fromString(id));\n+        } catch (IllegalArgumentException ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private MapUserEntity getEntityByIdOrThrow(RealmModel realm, String id) {\n+        return getEntityById(realm, id)\n+                .orElseThrow(this::userDoesntExistException);\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, UUID id) {\n+        MapUserEntity mapUserEntity = tx.get(id, userStore::get);\n+        if (mapUserEntity != null && entityRealmFilter(realm).test(mapUserEntity)) {\n+            return Optional.of(mapUserEntity);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private Optional<MapUserEntity> getRegisteredEntityById(RealmModel realm, String id) {\n+        return getEntityById(realm, id).map(this::registerEntityForChanges);\n+    }\n+\n+    private Stream<MapUserEntity> getNotRemovedUpdatedUsersStream() {\n+        Stream<MapUserEntity> updatedAndNotRemovedUsersStream = userStore.entrySet().stream()\n+                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n+                .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedUsersStream);\n+    }\n+\n+    private Stream<MapUserEntity> getUnsortedUserEntitiesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedUsersStream()\n+                .filter(entityRealmFilter(realm));\n+    }\n+    \n+    private <T> Stream<T> paginatedStream(Stream<T> originalStream, Integer first, Integer max) {\n+        if (first != null && first > 0) {\n+            originalStream = originalStream.skip(first);\n+        }\n+\n+        if (max != null && max >= 0) {\n+            originalStream = originalStream.limit(max);\n+        }\n+\n+        return originalStream;\n+    }\n+\n+    @Override\n+    public void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIdentityModel socialLink) {\n+        if (user == null || user.getId() == null) {\n+            return;\n+        }\n+        LOG.tracef(\"addFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialLink.getIdentityProvider(), getShortStackTrace());\n+\n+        getRegisteredEntityById(realm, user.getId())\n+                .ifPresent(userEntity ->\n+                        userEntity.addFederatedIdentity(UserFederatedIdentityEntity.fromModel(socialLink)));\n+    }\n+\n+    @Override\n+    public boolean removeFederatedIdentity(RealmModel realm, UserModel user, String socialProvider) {\n+        LOG.tracef(\"removeFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())\n+                .map(entity -> entity.removeFederatedIdentity(socialProvider))\n+                .orElse(false);\n+    }\n+\n+    @Override\n+    public void preRemove(RealmModel realm, IdentityProviderModel provider) {\n+        String socialProvider = provider.getAlias();\n+        LOG.tracef(\"preRemove[RealmModel realm, IdentityProviderModel provider](%s, %s)%s\", realm, socialProvider, getShortStackTrace());\n+        getUnsortedUserEntitiesStream(realm)\n+                .map(this::registerEntityForChanges)\n+                .forEach(userEntity -> userEntity.removeFederatedIdentity(socialProvider));\n+    }\n+\n+    @Override\n+    public void updateFederatedIdentity(RealmModel realm, UserModel federatedUser, FederatedIdentityModel federatedIdentityModel) {\n+        LOG.tracef(\"updateFederatedIdentity(%s, %s, %s)%s\", realm, federatedUser.getId(), federatedIdentityModel.getIdentityProvider(), getShortStackTrace());\n+        getRegisteredEntityById(realm, federatedUser.getId())\n+                .ifPresent(entity -> entity.updateFederatedIdentity(UserFederatedIdentityEntity.fromModel(federatedIdentityModel)));\n+    }\n+\n+    @Override\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentitiesStream(%s, %s)%s\", realm, user.getId(), getShortStackTrace());\n+        return getEntityById(realm, user.getId())\n+                .map(AbstractUserEntity::getFederatedIdentities).orElseGet(Stream::empty)\n+                .map(UserFederatedIdentityEntity::toModel);\n+    }\n+\n+    @Override\n+    public FederatedIdentityModel getFederatedIdentity(UserModel user, String socialProvider, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())\n+                .map(userEntity -> userEntity.getFederatedIdentity(socialProvider))\n+                .map(UserFederatedIdentityEntity::toModel)\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public UserModel getUserByFederatedIdentity(FederatedIdentityModel socialLink, RealmModel realm) {\n+        LOG.tracef(\"getUserByFederatedIdentity(%s, %s)%s\", realm, socialLink, getShortStackTrace());\n+        return getUnsortedUserEntitiesStream(realm)\n+                .filter(userEntity -> Objects.nonNull(userEntity.getFederatedIdentity(socialLink.getIdentityProvider())))\n+                .filter(userEntity -> Objects.equals(userEntity.getFederatedIdentity(socialLink.getIdentityProvider()).getUserId(), socialLink.getUserId()))\n+                .collect(Collectors.collectingAndThen(\n+                        Collectors.toList(),\n+                        list -> {\n+                            if (list.size() == 0) {\n+                                return null;\n+                            } else if (list.size() != 1) {\n+                                throw new IllegalStateException(\"More results found for identityProvider=\" + socialLink.getIdentityProvider() +\n+                                        \", userId=\" + socialLink.getUserId() + \", results=\" + list);\n+                            }\n+\n+                            return entityToAdapterFunc(realm).apply(list.get(0));\n+                        }));\n+    }\n+\n+    @Override\n+    public void addConsent(RealmModel realm, String userId, UserConsentModel consent) {\n+        LOG.tracef(\"addConsent(%s, %s, %s)%s\", realm, userId, consent, getShortStackTrace());\n+\n+        UserConsentEntity consentEntity = UserConsentEntity.fromModel(consent);\n+        getRegisteredEntityById(realm, userId).ifPresent(userEntity -> userEntity.addUserConsent(consentEntity));\n+    }\n+\n+    @Override\n+    public UserConsentModel getConsentByClient(RealmModel realm, String userId, String clientInternalId) {\n+        LOG.tracef(\"getConsentByClient(%s, %s, %s)%s\", realm, userId, clientInternalId, getShortStackTrace());\n+        return getEntityById(realm, userId)\n+                .map(userEntity -> userEntity.getUserConsent(clientInternalId))\n+                .map(consent -> UserConsentEntity.toModel(realm, consent))\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public Stream<UserConsentModel> getConsentsStream(RealmModel realm, String userId) {\n+        LOG.tracef(\"getConsentByClientStream(%s, %s)%s\", realm, userId, getShortStackTrace());\n+        return getRegisteredEntityById(realm, userId)\n+                .map(AbstractUserEntity::getUserConsents)\n+                .orElse(Stream.empty())\n+                .map(consent -> UserConsentEntity.toModel(realm, consent));\n+    }\n+\n+    @Override\n+    public void updateConsent(RealmModel realm, String userId, UserConsentModel consent) {\n+        LOG.tracef(\"updateConsent(%s, %s, %s)%s\", realm, userId, consent, getShortStackTrace());\n+\n+        MapUserEntity user = getEntityByIdOrThrow(realm, userId);\n+        UserConsentEntity userConsentEntity = user.getUserConsent(consent.getClient().getId());\n+        if (userConsentEntity == null) {\n+            throw new ModelException(\"Consent or not found for client [\" + consent.getClient().getId() + \"] and user [\" + userId + \"]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMDYzMQ==", "bodyText": "Not sure if I fully understand how all this works but shouldn't this update happen in a transaction?", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538730631", "createdAt": "2020-12-08T19:04:30Z", "author": {"login": "sguilhen"}, "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java", "diffHunk": "@@ -0,0 +1,875 @@\n+package org.keycloak.models.map.user;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.jboss.logging.Logger;\n+import org.keycloak.authorization.AuthorizationProvider;\n+import org.keycloak.authorization.store.ResourceStore;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.credential.CredentialModel;\n+import org.keycloak.credential.UserCredentialStore;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.FederatedIdentityModel;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.IdentityProviderModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RequiredActionProviderModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserProvider;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+import org.keycloak.models.utils.DefaultRoles;\n+import org.keycloak.storage.StorageId;\n+import org.keycloak.storage.UserStorageProvider;\n+import org.keycloak.storage.client.ClientStorageProvider;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import static org.keycloak.models.UserModel.EMAIL;\n+import static org.keycloak.models.UserModel.EMAIL_VERIFIED;\n+import static org.keycloak.models.UserModel.FIRST_NAME;\n+import static org.keycloak.models.UserModel.LAST_NAME;\n+import static org.keycloak.models.UserModel.USERNAME;\n+\n+public class MapUserProvider implements UserProvider.Streams, UserCredentialStore {\n+\n+    private static final Logger LOG = Logger.getLogger(MapUserProvider.class);\n+    private static final Predicate<MapUserEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapUserEntity> tx;\n+    private final MapStorage<UUID, MapUserEntity> userStore;\n+\n+    public MapUserProvider(KeycloakSession session, MapStorage<UUID, MapUserEntity> store) {\n+        this.session = session;\n+        this.userStore = store;\n+        this.tx = new MapKeycloakTransaction<>(userStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private MapUserEntity registerEntityForChanges(MapUserEntity origEntity) {\n+        MapUserEntity res = tx.get(origEntity.getId(), id -> Serialization.from(origEntity));\n+        tx.putIfChanged(origEntity.getId(), res, MapUserEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapUserEntity, UserModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+        return origEntity -> new MapUserAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+\n+            @Override\n+            public boolean checkEmailUniqueness(RealmModel realm, String email) {\n+                return getUserByEmail(email, realm) != null;\n+            }\n+\n+            @Override\n+            public boolean checkUsernameUniqueness(RealmModel realm, String username) {\n+                return getUserByUsername(username, realm) != null;\n+            }\n+        };\n+    }\n+\n+    private Predicate<MapUserEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapUserProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private ModelException userDoesntExistException() {\n+        return new ModelException(\"Specified user doesn't exist.\");\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, String id) {\n+        try {\n+            return getEntityById(realm, UUID.fromString(id));\n+        } catch (IllegalArgumentException ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private MapUserEntity getEntityByIdOrThrow(RealmModel realm, String id) {\n+        return getEntityById(realm, id)\n+                .orElseThrow(this::userDoesntExistException);\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, UUID id) {\n+        MapUserEntity mapUserEntity = tx.get(id, userStore::get);\n+        if (mapUserEntity != null && entityRealmFilter(realm).test(mapUserEntity)) {\n+            return Optional.of(mapUserEntity);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private Optional<MapUserEntity> getRegisteredEntityById(RealmModel realm, String id) {\n+        return getEntityById(realm, id).map(this::registerEntityForChanges);\n+    }\n+\n+    private Stream<MapUserEntity> getNotRemovedUpdatedUsersStream() {\n+        Stream<MapUserEntity> updatedAndNotRemovedUsersStream = userStore.entrySet().stream()\n+                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n+                .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedUsersStream);\n+    }\n+\n+    private Stream<MapUserEntity> getUnsortedUserEntitiesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedUsersStream()\n+                .filter(entityRealmFilter(realm));\n+    }\n+    \n+    private <T> Stream<T> paginatedStream(Stream<T> originalStream, Integer first, Integer max) {\n+        if (first != null && first > 0) {\n+            originalStream = originalStream.skip(first);\n+        }\n+\n+        if (max != null && max >= 0) {\n+            originalStream = originalStream.limit(max);\n+        }\n+\n+        return originalStream;\n+    }\n+\n+    @Override\n+    public void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIdentityModel socialLink) {\n+        if (user == null || user.getId() == null) {\n+            return;\n+        }\n+        LOG.tracef(\"addFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialLink.getIdentityProvider(), getShortStackTrace());\n+\n+        getRegisteredEntityById(realm, user.getId())\n+                .ifPresent(userEntity ->\n+                        userEntity.addFederatedIdentity(UserFederatedIdentityEntity.fromModel(socialLink)));\n+    }\n+\n+    @Override\n+    public boolean removeFederatedIdentity(RealmModel realm, UserModel user, String socialProvider) {\n+        LOG.tracef(\"removeFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())\n+                .map(entity -> entity.removeFederatedIdentity(socialProvider))\n+                .orElse(false);\n+    }\n+\n+    @Override\n+    public void preRemove(RealmModel realm, IdentityProviderModel provider) {\n+        String socialProvider = provider.getAlias();\n+        LOG.tracef(\"preRemove[RealmModel realm, IdentityProviderModel provider](%s, %s)%s\", realm, socialProvider, getShortStackTrace());\n+        getUnsortedUserEntitiesStream(realm)\n+                .map(this::registerEntityForChanges)\n+                .forEach(userEntity -> userEntity.removeFederatedIdentity(socialProvider));\n+    }\n+\n+    @Override\n+    public void updateFederatedIdentity(RealmModel realm, UserModel federatedUser, FederatedIdentityModel federatedIdentityModel) {\n+        LOG.tracef(\"updateFederatedIdentity(%s, %s, %s)%s\", realm, federatedUser.getId(), federatedIdentityModel.getIdentityProvider(), getShortStackTrace());\n+        getRegisteredEntityById(realm, federatedUser.getId())\n+                .ifPresent(entity -> entity.updateFederatedIdentity(UserFederatedIdentityEntity.fromModel(federatedIdentityModel)));\n+    }\n+\n+    @Override\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentitiesStream(%s, %s)%s\", realm, user.getId(), getShortStackTrace());\n+        return getEntityById(realm, user.getId())\n+                .map(AbstractUserEntity::getFederatedIdentities).orElseGet(Stream::empty)\n+                .map(UserFederatedIdentityEntity::toModel);\n+    }\n+\n+    @Override\n+    public FederatedIdentityModel getFederatedIdentity(UserModel user, String socialProvider, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())\n+                .map(userEntity -> userEntity.getFederatedIdentity(socialProvider))\n+                .map(UserFederatedIdentityEntity::toModel)\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public UserModel getUserByFederatedIdentity(FederatedIdentityModel socialLink, RealmModel realm) {\n+        LOG.tracef(\"getUserByFederatedIdentity(%s, %s)%s\", realm, socialLink, getShortStackTrace());\n+        return getUnsortedUserEntitiesStream(realm)\n+                .filter(userEntity -> Objects.nonNull(userEntity.getFederatedIdentity(socialLink.getIdentityProvider())))\n+                .filter(userEntity -> Objects.equals(userEntity.getFederatedIdentity(socialLink.getIdentityProvider()).getUserId(), socialLink.getUserId()))\n+                .collect(Collectors.collectingAndThen(\n+                        Collectors.toList(),\n+                        list -> {\n+                            if (list.size() == 0) {\n+                                return null;\n+                            } else if (list.size() != 1) {\n+                                throw new IllegalStateException(\"More results found for identityProvider=\" + socialLink.getIdentityProvider() +\n+                                        \", userId=\" + socialLink.getUserId() + \", results=\" + list);\n+                            }\n+\n+                            return entityToAdapterFunc(realm).apply(list.get(0));\n+                        }));\n+    }\n+\n+    @Override\n+    public void addConsent(RealmModel realm, String userId, UserConsentModel consent) {\n+        LOG.tracef(\"addConsent(%s, %s, %s)%s\", realm, userId, consent, getShortStackTrace());\n+\n+        UserConsentEntity consentEntity = UserConsentEntity.fromModel(consent);\n+        getRegisteredEntityById(realm, userId).ifPresent(userEntity -> userEntity.addUserConsent(consentEntity));\n+    }\n+\n+    @Override\n+    public UserConsentModel getConsentByClient(RealmModel realm, String userId, String clientInternalId) {\n+        LOG.tracef(\"getConsentByClient(%s, %s, %s)%s\", realm, userId, clientInternalId, getShortStackTrace());\n+        return getEntityById(realm, userId)\n+                .map(userEntity -> userEntity.getUserConsent(clientInternalId))\n+                .map(consent -> UserConsentEntity.toModel(realm, consent))\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public Stream<UserConsentModel> getConsentsStream(RealmModel realm, String userId) {\n+        LOG.tracef(\"getConsentByClientStream(%s, %s)%s\", realm, userId, getShortStackTrace());\n+        return getRegisteredEntityById(realm, userId)\n+                .map(AbstractUserEntity::getUserConsents)\n+                .orElse(Stream.empty())\n+                .map(consent -> UserConsentEntity.toModel(realm, consent));\n+    }\n+\n+    @Override\n+    public void updateConsent(RealmModel realm, String userId, UserConsentModel consent) {\n+        LOG.tracef(\"updateConsent(%s, %s, %s)%s\", realm, userId, consent, getShortStackTrace());\n+\n+        MapUserEntity user = getEntityByIdOrThrow(realm, userId);\n+        UserConsentEntity userConsentEntity = user.getUserConsent(consent.getClient().getId());\n+        if (userConsentEntity == null) {\n+            throw new ModelException(\"Consent or not found for client [\" + consent.getClient().getId() + \"] and user [\" + userId + \"]\");\n+        }\n+\n+        userConsentEntity.setGrantedClientScopesIds(\n+                consent.getGrantedClientScopes().stream()\n+                        .map(ClientScopeModel::getId)\n+                        .collect(Collectors.toSet())\n+        );\n+\n+        userConsentEntity.setLastUpdatedDate(Time.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 270}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzODg5MjEw", "url": "https://github.com/keycloak/keycloak/pull/7645#pullrequestreview-543889210", "createdAt": "2020-12-03T12:09:23Z", "commit": {"oid": "8df17fe710c6b7ad8c41a65a18137885f2692c53"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMjowOToyM1rOH-YURw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMDoxNzozOVrOIB0UUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE3MjE2Nw==", "bodyText": "This is really nit, probably forgotten here.", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535172167", "createdAt": "2020-12-03T12:09:23Z", "author": {"login": "vramik"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/LoginTest.java", "diffHunk": "@@ -89,11 +90,11 @@\n  * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n  */\n public class LoginTest extends AbstractTestRealmKeycloakTest {\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8df17fe710c6b7ad8c41a65a18137885f2692c53"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDAwNQ==", "bodyText": "Should we also update UserPropertyFileStorage from testsuite-providers to implement stream-Integer variant instead of the deprecated one?", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538754005", "createdAt": "2020-12-08T19:40:43Z", "author": {"login": "vramik"}, "path": "server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java", "diffHunk": "@@ -214,7 +214,7 @@ default int getUsersCount(RealmModel realm, boolean includeServiceAccount) {\n      * @param firstResult\n      * @param maxResults\n      * @return\n-     * @deprecated Use {@link #searchForUserStream(String, RealmModel, int, int) searchForUserStream} instead.\n+     * @deprecated Use {@link #searchForUserStream(String, RealmModel, Integer, Integer) searchForUserStream} instead.\n      */\n     @Deprecated\n     List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODI2MQ==", "bodyText": "This is really nit, probably forgotten here.", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538758261", "createdAt": "2020-12-08T19:47:35Z", "author": {"login": "vramik"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/events/TestEventsListenerProvider.java", "diffHunk": "@@ -19,30 +19,36 @@\n \n import org.keycloak.events.Event;\n import org.keycloak.events.EventListenerProvider;\n+import org.keycloak.events.EventListenerTransaction;\n import org.keycloak.events.admin.AdminEvent;\n+import org.keycloak.models.KeycloakSession;\n \n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n \n /**\n  * @author <a href=\"mailto:mstrukel@redhat.com\">Marko Strukelj</a>\n  */\n-public class EventsListenerProvider implements EventListenerProvider {\n+public class TestEventsListenerProvider implements EventListenerProvider {\n \n     private static final BlockingQueue<Event> events = new LinkedBlockingQueue<Event>();\n     private static final BlockingQueue<AdminEvent> adminEvents = new LinkedBlockingQueue<>();\n+    private final EventListenerTransaction tx = new EventListenerTransaction((event, includeRepre) -> adminEvents.add(event), events::add);\n+\n+    public TestEventsListenerProvider(KeycloakSession session) {\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n \n     @Override\n     public void onEvent(Event event) {\n-        events.add(event);\n+        tx.addEvent(event);\n     }\n \n     @Override\n     public void onEvent(AdminEvent event, boolean includeRepresentation) {\n-        // Save the copy for case when same AdminEventBuilder is used more times during same transaction to avoid overwriting previously referenced event\n-        adminEvents.add(copy(event));\n+        tx.addAdminEvent(event, includeRepresentation);\n     }\n-\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MzUwNQ==", "bodyText": "missing copyright", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538763505", "createdAt": "2020-12-08T19:55:58Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java", "diffHunk": "@@ -0,0 +1,875 @@\n+package org.keycloak.models.map.user;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NDk3Ng==", "bodyText": "missing copyright", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538764976", "createdAt": "2020-12-08T19:58:15Z", "author": {"login": "vramik"}, "path": "model/map/src/main/test/java/org/keycloak/models/map/user/AbstractUserEntityCredentialsOrderTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.keycloak.models.map.user;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NTExMg==", "bodyText": "missing copyright", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538765112", "createdAt": "2020-12-08T19:58:29Z", "author": {"login": "vramik"}, "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java", "diffHunk": "@@ -18,15 +18,54 @@\n package org.keycloak.events;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NTI3MQ==", "bodyText": "missing copyright", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538765271", "createdAt": "2020-12-08T19:58:44Z", "author": {"login": "vramik"}, "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerTransaction.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.keycloak.events;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NzAwNg==", "bodyText": "This import is not necessary here.", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538767006", "createdAt": "2020-12-08T20:01:30Z", "author": {"login": "vramik"}, "path": "testsuite/model/src/test/java/org/keycloak/testsuite/model/UserModelTest.java", "diffHunk": "@@ -37,13 +37,17 @@\n import java.util.stream.IntStream;\n import org.hamcrest.Matchers;\n import org.junit.Test;\n+import org.keycloak.testsuite.federation.UserMapStorage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NzA4OQ==", "bodyText": "dtto", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538767089", "createdAt": "2020-12-08T20:01:39Z", "author": {"login": "vramik"}, "path": "testsuite/model/src/test/java/org/keycloak/testsuite/model/UserModelTest.java", "diffHunk": "@@ -37,13 +37,17 @@\n import java.util.stream.IntStream;\n import org.hamcrest.Matchers;\n import org.junit.Test;\n+import org.keycloak.testsuite.federation.UserMapStorage;\n+\n import static org.hamcrest.Matchers.hasItem;\n import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.is;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertThat;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assume.assumeThat;\n+import static org.junit.Assume.assumeTrue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2ODcwNQ==", "bodyText": "If I understand it correctly the test is actually changed to test something else than before, right? Can you please explain to me what has changed?", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538768705", "createdAt": "2020-12-08T20:04:20Z", "author": {"login": "vramik"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPBinaryAttributesTest.java", "diffHunk": "@@ -156,18 +158,16 @@ public void test03WritableMapper() {\n         // Assert he is found including jpegPhoto\n         joe = getUserAndAssertPhoto(\"joephoto\", true);\n \n+        // Assert that local storage doesn't contain LDAPConstants.JPEG_PHOTO, it should be stored in the LDAP\n+        String joeId = joe.getId();\n+        testingClient.server().run(session -> {\n+            RealmModel test = session.realms().getRealmByName(\"test\");\n+            UserModel userById = session.userLocalStorage().getUserById(joeId, test);\n+\n+            assertThat(userById.getAttributes().get(LDAPConstants.JPEG_PHOTO), is(nullValue()));\n+        });\n \n-        // Try to update him with some big non-LDAP mapped attribute. It will fail\n-        try {\n-            joe.getAttributes().put(\"someOtherPhoto\", Arrays.asList(JPEG_PHOTO_BASE64));\n-            adminClient.realm(\"test\").users().get(joe.getId()).update(joe);\n-            Assert.fail(\"Not expected to successfully update user\");\n-        } catch (ClientErrorException cee) {\n-            // Expected\n-        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MTI0Nw==", "bodyText": "missing copyright", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538771247", "createdAt": "2020-12-08T20:08:45Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/user/UserCredentialEntity.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package org.keycloak.models.map.user;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MTM4Mw==", "bodyText": "missing copyright", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538771383", "createdAt": "2020-12-08T20:08:58Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/user/UserConsentEntity.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package org.keycloak.models.map.user;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MTUxMg==", "bodyText": "missing copyright", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538771512", "createdAt": "2020-12-08T20:09:10Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/user/UserFederatedIdentityEntity.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.keycloak.models.map.user;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDM5NQ==", "bodyText": "nit: the javadoc's params are not aligned with actual method contract", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538774395", "createdAt": "2020-12-08T20:14:01Z", "author": {"login": "vramik"}, "path": "server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java", "diffHunk": "@@ -405,17 +405,17 @@ default int getUsersCount(RealmModel realm, boolean includeServiceAccount) {\n      * @return a non-null {@link Stream} of users that have the specified role.\n      */\n     default Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n-        return Stream.empty();\n+        return getRoleMembersStream(realm, role, null, null);\n     }\n \n     /**\n      * Search for users that have a specific role with a specific roleId.\n      *\n+     * @param role", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjY1OA==", "bodyText": "out of curiosity: can you please explain to me why we need to send admin event before commiting the transaction?", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538776658", "createdAt": "2020-12-08T20:17:39Z", "author": {"login": "vramik"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/ClientScopeResource.java", "diffHunk": "@@ -101,10 +101,11 @@ public Response update(final ClientScopeRepresentation rep) {\n \n         try {\n             RepresentationToModel.updateClientScope(rep, clientScope);\n+            adminEvent.operation(OperationType.UPDATE).resourcePath(session.getContext().getUri()).representation(rep).success();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0ddcec30e6e57cb6a58bfc6695942242c91ef29", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/c0ddcec30e6e57cb6a58bfc6695942242c91ef29", "committedDate": "2020-12-09T08:01:35Z", "message": "KEYCLOAK-15847 Incorporate Stefan's suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9842f4581ba691ca33a4ba2619d660c438e3038", "author": {"user": {"login": "mhajas", "name": "Michal Hajas"}}, "url": "https://github.com/keycloak/keycloak/commit/e9842f4581ba691ca33a4ba2619d660c438e3038", "committedDate": "2020-12-09T08:59:05Z", "message": "KEYCLOAK-15847 Incorporate Vlasta's suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4MTI2MDk0", "url": "https://github.com/keycloak/keycloak/pull/7645#pullrequestreview-548126094", "createdAt": "2020-12-09T12:19:14Z", "commit": {"oid": "e9842f4581ba691ca33a4ba2619d660c438e3038"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NjM4ODI1", "url": "https://github.com/keycloak/keycloak/pull/7645#pullrequestreview-548638825", "createdAt": "2020-12-09T21:49:11Z", "commit": {"oid": "e9842f4581ba691ca33a4ba2619d660c438e3038"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4OTMxOTE4", "url": "https://github.com/keycloak/keycloak/pull/7645#pullrequestreview-548931918", "createdAt": "2020-12-10T07:57:28Z", "commit": {"oid": "e9842f4581ba691ca33a4ba2619d660c438e3038"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3276, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}