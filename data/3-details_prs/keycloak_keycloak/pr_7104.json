{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNTQ5NTk5", "number": 7104, "title": "KEYCLOAK-14189 Client Policy : Basics", "bodyText": "This PR is for KEYCLOAK-14189 Client Policy : Basics that is a sub task of KEYCLOAK-13933 Client Policies whose design document is Client Policies .\nThis PR implements the basics of condition, executor and policy. This PR does not implement\nactual conditions and executors. Following PRs for sub tasks of KEYCLOAK-13933 Client Policies will implement actual conditions and executors following the design document of Client Policies after merging this PR.", "createdAt": "2020-05-25T05:18:19Z", "url": "https://github.com/keycloak/keycloak/pull/7104", "merged": true, "mergeCommit": {"oid": "e0fbfa722ec70c429c3e8da19e5298dfbe9c57c1"}, "closed": true, "closedAt": "2020-07-21T05:50:09Z", "author": {"login": "tnorimat"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABckqEm0ABqjMzNjg5NzkzMjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc2_rK_AFqTQ1MjE0MzMwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e8ecb22a4c330095430a037c37b4ebdf64e45cd5", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/e8ecb22a4c330095430a037c37b4ebdf64e45cd5", "committedDate": "2020-05-25T05:14:35Z", "message": "KEYCLOAK-14189 Client Policy : Basics"}, "afterCommit": {"oid": "57524c993ce43c8958221f1c63f19a9360672bd2", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/57524c993ce43c8958221f1c63f19a9360672bd2", "committedDate": "2020-05-25T06:27:47Z", "message": "KEYCLOAK-14189 Client Policy : Basics"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "57524c993ce43c8958221f1c63f19a9360672bd2", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/57524c993ce43c8958221f1c63f19a9360672bd2", "committedDate": "2020-05-25T06:27:47Z", "message": "KEYCLOAK-14189 Client Policy : Basics"}, "afterCommit": {"oid": "5954e30e4438d9be8e34198b7df95a6ac1d4a65e", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/5954e30e4438d9be8e34198b7df95a6ac1d4a65e", "committedDate": "2020-05-25T07:50:28Z", "message": "KEYCLOAK-14189 Client Policy : Basics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4ODkxNjI5", "url": "https://github.com/keycloak/keycloak/pull/7104#pullrequestreview-418891629", "createdAt": "2020-05-27T06:31:14Z", "commit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNjozMToxNFrOGa7K5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNzowNDozNlrOGboMkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NTYwNA==", "bodyText": "One issue I see here is that it will be relatively expensive to loop through the component model and initialise all policies for all requests. A better option may be to follow something more along the lines of what is done with keys. See https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/keys/DefaultKeyManager.java. It caches the keys with the realm, which means it doesn't have to parse the config and load keys for every request.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430885604", "createdAt": "2020-05-27T06:31:14Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NTc1MA==", "bodyText": "See comment on ClientPolicyManager, but this should be something like session.clientPolicy().trigger...", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430885750", "createdAt": "2020-05-27T06:31:44Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/AuthorizationEndpoint.java", "diffHunk": "@@ -153,6 +155,12 @@ private Response process(MultivaluedMap<String, String> params) {\n             return errorResponse;\n         }\n \n+        try {\n+            ClientPolicyManager.triggerOnAuthorizationRequest(parsedResponseType, request, redirectUri, session);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NjUzNg==", "bodyText": "Change to errorDetail", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430886536", "createdAt": "2020-05-27T06:33:45Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyException.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+public class ClientPolicyException extends Exception {\n+    private String error;\n+    private String error_detail;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4ODAxMw==", "bodyText": "Shouldn't we remove this, and always use error/errorDetails?", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430888013", "createdAt": "2020-05-27T06:37:27Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyException.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+public class ClientPolicyException extends Exception {\n+    private String error;\n+    private String error_detail;\n+\n+    public ClientPolicyException(String message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4ODE4NA==", "bodyText": "See above. Perhaps add \"public ClientPolicyException(String error, String error_detail, Throwable throwable)\" instead", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430888184", "createdAt": "2020-05-27T06:37:53Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyException.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+public class ClientPolicyException extends Exception {\n+    private String error;\n+    private String error_detail;\n+\n+    public ClientPolicyException(String message) {\n+        super(message);\n+    }\n+\n+    public ClientPolicyException(String message, Throwable throwable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzA0NA==", "bodyText": "Rename to ClientPolicyExecutorProvider", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430893044", "createdAt": "2020-05-27T06:50:27Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorSpi.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.provider.ProviderFactory;\n+import org.keycloak.provider.Spi;\n+\n+public class ClientPolicyExecutorSpi implements Spi {\n+\n+    @Override\n+    public boolean isInternal() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"client-policy-executor\";\n+    }\n+\n+    @Override\n+    public Class<? extends Provider> getProviderClass() {\n+        return ClientPolicyExecutor.class;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzE3OQ==", "bodyText": "Rename to ClientPolicyExecutorProviderFactory", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430893179", "createdAt": "2020-05-27T06:50:43Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorSpi.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.provider.ProviderFactory;\n+import org.keycloak.provider.Spi;\n+\n+public class ClientPolicyExecutorSpi implements Spi {\n+\n+    @Override\n+    public boolean isInternal() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"client-policy-executor\";\n+    }\n+\n+    @Override\n+    public Class<? extends Provider> getProviderClass() {\n+        return ClientPolicyExecutor.class;\n+    }\n+\n+    @Override\n+    public Class<? extends ProviderFactory> getProviderFactoryClass() {\n+        return ClientPolicyExecutorFactory.class;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzM1Mw==", "bodyText": "Rename to ClientPolicyConditionProvider", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430893353", "createdAt": "2020-05-27T06:51:07Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionSpi.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.provider.ProviderFactory;\n+import org.keycloak.provider.Spi;\n+\n+public class ClientPolicyConditionSpi implements Spi {\n+\n+    @Override\n+    public boolean isInternal() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"client-policy-condition\";\n+    }\n+\n+    @Override\n+    public Class<? extends Provider> getProviderClass() {\n+        return ClientPolicyCondition.class;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzQzNA==", "bodyText": "Rename to ClientPolicyConditionProviderFactory", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430893434", "createdAt": "2020-05-27T06:51:17Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionSpi.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.provider.ProviderFactory;\n+import org.keycloak.provider.Spi;\n+\n+public class ClientPolicyConditionSpi implements Spi {\n+\n+    @Override\n+    public boolean isInternal() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"client-policy-condition\";\n+    }\n+\n+    @Override\n+    public Class<? extends Provider> getProviderClass() {\n+        return ClientPolicyCondition.class;\n+    }\n+\n+    @Override\n+    public Class<? extends ProviderFactory> getProviderFactoryClass() {\n+        return ClientPolicyConditionFactory.class;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5NjQzOQ==", "bodyText": "Very often a condition is going to have the same code for create/update as well as if it's admin or dynamic. So I would rather see something like:\ndefault boolean isSatisfiedOnClientUpdate(ClientUpdateContext context)\nWhere ClientUpdateContext contains information about who is updating it, and if it's a create or update.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430896439", "createdAt": "2020-05-27T06:58:09Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyCondition.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.provider.Provider;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.\n+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this condition to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyCondition extends Provider {\n+\n+    @Override\n+    default void close() {}\n+\n+    /**\n+     * returns true if this condition is evaluated to check\n+     * whether the client satisfies this condition on the event specified as a parameter.\n+     * A condition can be implemented to be evaluated on some events while not on others.\n+     * On the event specified as the parameter, this condition is skipped if this method returns false.\n+     *\n+     * @param event defined in {@link ClientPolicyEvent}\n+     * @return true if this condition is evaluated on the event.\n+     */\n+    default boolean isEvaluatedOnEvent(String event) {return true;}\n+\n+    /**\n+     * returns true if the client satisfies this condition\n+     * on Dynamic Registration Endpoint access for creating client.\n+     *\n+     * @param context\n+     * @param authType\n+     * @return true if the client satisfies this condition.\n+     */\n+    default boolean isSatisfiedOnDynamicClientRegister(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5NzM0Ng==", "bodyText": "doPolicyOperation", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430897346", "createdAt": "2020-05-27T07:00:13Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNjk1MQ==", "bodyText": "Would it not be better if this was an enum?", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431606951", "createdAt": "2020-05-28T06:24:56Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+public interface ClientPolicyEvent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODAxMA==", "bodyText": "I wonder if it would be better if a ClientPolicyProvider returns lists of ClientPolicyCondition/ClientPolicyExecutor instead of ids. That would allow creating ClientPolicyProviders that don't use ComponentModel, but just hard-codes some conditions/executors instead.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431608010", "createdAt": "2020-05-28T06:27:45Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProvider.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+\n+import org.keycloak.provider.Provider;\n+\n+/**\n+ * Provides Client Policy which accommodates several Conditions and Executors.\n+ */\n+public interface ClientPolicyProvider extends Provider {\n+\n+    /**\n+     * returns the list of condition's id which this provider accommodates.\n+     *\n+     * @return list of condition's id\n+     */\n+    List<String> getConditionIds();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODkzNA==", "bodyText": "Why is this here? I can't see it being called anywhere.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431608934", "createdAt": "2020-05-28T06:30:03Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProviderFactory.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+\n+import org.keycloak.component.ComponentFactory;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.provider.ProviderConfigProperty;\n+\n+public interface ClientPolicyProviderFactory extends ComponentFactory<ClientPolicyProvider, ClientPolicyProvider> {\n+\n+    List<ProviderConfigProperty> getConfigProperties(KeycloakSession session);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTE2Ng==", "bodyText": "Doesn't this mean that if a ClientPolicyCondition throws an exception it is ignored and only a trace level logging is shown? An exception in a ClientPolicyCondition/Executor should result in an error handling the request I'd say.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431611166", "createdAt": "2020-05-28T06:35:48Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMzE0NQ==", "bodyText": "If no conditions are evaluated it should return true right? Otherwise no matches would return in not accepting the request.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431613145", "createdAt": "2020-05-28T06:41:01Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMzczOQ==", "bodyText": "Doesn't this mean an exception always results in false? That's okay, but there's no feedback to the user other than the request failed.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431613739", "createdAt": "2020-05-28T06:42:30Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");\n+            return false;\n+        }\n+\n+        if (conditions.stream().anyMatch(t -> {\n+                    try {return !op.run(t);} catch (ClientPolicyException e) {\n+                        ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNDEzOA==", "bodyText": "There's no feedback to the user why this request has failed, and information is only available in trace level logging, which may not be enabled and would not always be available to application developers as often they wont have access to logs.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431614138", "createdAt": "2020-05-28T06:43:26Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");\n+            return false;\n+        }\n+\n+        if (conditions.stream().anyMatch(t -> {\n+                    try {return !op.run(t);} catch (ClientPolicyException e) {\n+                        ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                        return false;\n+                    }\n+            })) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. Not all conditones satisfied.\");\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNDY3NQ==", "bodyText": "This should be a single log statement, not 3", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431614675", "createdAt": "2020-05-28T06:44:42Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNDc1Mg==", "bodyText": "This should be a single log statement, not 3", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431614752", "createdAt": "2020-05-28T06:44:52Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");\n+            return false;\n+        }\n+\n+        if (conditions.stream().anyMatch(t -> {\n+                    try {return !op.run(t);} catch (ClientPolicyException e) {\n+                        ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                        return false;\n+                    }\n+            })) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. Not all conditones satisfied.\");\n+            return false;\n+        }\n+\n+        ClientPolicyLogger.log(logger, \"POSITIVE :: This policy is applied.\");\n+        return true;\n+ \n+    }\n+\n+    private static void execute(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientExecutorFilter filter,\n+            ClientExecutorOperation op) throws ClientPolicyException {\n+\n+        List<String> executorIds = policy.getExecutorIds();\n+\n+        if (executorIds == null || executorIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. No executor registered.\");\n+            return;\n+        }\n+\n+        List<ClientPolicyExecutor> executors = executorIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Executor ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Executor Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Executor Provider ID = \" + conditionModel.getProviderId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTE1NQ==", "bodyText": "This swallows exceptions, with only information in trace level logging. An exception should probably result in an error to handle request (500).", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431615155", "createdAt": "2020-05-28T06:45:49Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");\n+            return false;\n+        }\n+\n+        if (conditions.stream().anyMatch(t -> {\n+                    try {return !op.run(t);} catch (ClientPolicyException e) {\n+                        ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                        return false;\n+                    }\n+            })) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. Not all conditones satisfied.\");\n+            return false;\n+        }\n+\n+        ClientPolicyLogger.log(logger, \"POSITIVE :: This policy is applied.\");\n+        return true;\n+ \n+    }\n+\n+    private static void execute(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientExecutorFilter filter,\n+            ClientExecutorOperation op) throws ClientPolicyException {\n+\n+        List<String> executorIds = policy.getExecutorIds();\n+\n+        if (executorIds == null || executorIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. No executor registered.\");\n+            return;\n+        }\n+\n+        List<ClientPolicyExecutor> executors = executorIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Executor ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Executor Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Executor Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyExecutor.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTg4Ng==", "bodyText": "Using exceptions when the executor is not happy is fine, but in that case it should be an exception that doesn't fill the stack trace, as otherwise you have stack traces being loaded during \"normal behaviour\", which doesn't come for free.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431615886", "createdAt": "2020-05-28T06:47:50Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");\n+            return false;\n+        }\n+\n+        if (conditions.stream().anyMatch(t -> {\n+                    try {return !op.run(t);} catch (ClientPolicyException e) {\n+                        ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                        return false;\n+                    }\n+            })) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. Not all conditones satisfied.\");\n+            return false;\n+        }\n+\n+        ClientPolicyLogger.log(logger, \"POSITIVE :: This policy is applied.\");\n+        return true;\n+ \n+    }\n+\n+    private static void execute(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientExecutorFilter filter,\n+            ClientExecutorOperation op) throws ClientPolicyException {\n+\n+        List<String> executorIds = policy.getExecutorIds();\n+\n+        if (executorIds == null || executorIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. No executor registered.\");\n+            return;\n+        }\n+\n+        List<ClientPolicyExecutor> executors = executorIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Executor ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Executor Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Executor Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyExecutor.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (executors == null || executors.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. No executor executable.\");\n+            return;\n+        }\n+\n+        for (ClientPolicyExecutor executor : executors) op.run(executor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNzQwMg==", "bodyText": "Do we need the split between isEvaulated on and the isSatisfied? The default implementation should just return true that it is satisfied, which means you don't need a separate method to check if it should be called or not.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431617402", "createdAt": "2020-05-28T06:51:26Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyCondition.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.provider.Provider;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.\n+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this condition to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyCondition extends Provider {\n+\n+    @Override\n+    default void close() {}\n+\n+    /**\n+     * returns true if this condition is evaluated to check\n+     * whether the client satisfies this condition on the event specified as a parameter.\n+     * A condition can be implemented to be evaluated on some events while not on others.\n+     * On the event specified as the parameter, this condition is skipped if this method returns false.\n+     *\n+     * @param event defined in {@link ClientPolicyEvent}\n+     * @return true if this condition is evaluated on the event.\n+     */\n+    default boolean isEvaluatedOnEvent(String event) {return true;}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNzg2MA==", "bodyText": "Why is this here? Can't see it being invoked anywhere.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431617860", "createdAt": "2020-05-28T06:52:28Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionFactory.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import java.util.List;\n+\n+import org.keycloak.component.ComponentFactory;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.provider.ProviderConfigProperty;\n+\n+public interface ClientPolicyConditionFactory extends ComponentFactory<ClientPolicyCondition, ClientPolicyCondition> {\n+\n+    List<ProviderConfigProperty> getConfigProperties(KeycloakSession session);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxODQ4Ng==", "bodyText": "Same as with ClientPolicyCondition I don't think there's a need for a separate isExecutedOn as default methods should just be empty. That makes it easier to implement as you just implement those methods/events that you want", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431618486", "createdAt": "2020-05-28T06:53:47Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.provider.Provider;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.\n+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this executor to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyExecutor extends Provider {\n+\n+    @Override\n+    default void close() {\n+    }\n+\n+    /**\n+     * returns true if this executor is executed against the client.\n+     * A executor can be implemented to be executed on some events while not on others.\n+     * On the event specified as the parameter, this executor is skipped if this method returns false.\n+     *\n+     * @param event defined in {@link ClientPolicyEvent}\n+     * @return true if this executor is executed on the event.\n+     */\n+    default boolean isExecutedOnEvent(String event) {return true;}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxODk3Nw==", "bodyText": "Default should just be an empty method, it should not throw an exception\nSame as with ClientPolicyCondition I think it would be better to have a single method for create/update clients for both dynamic and client. As in most cases the code will be the same, and a context object would allow different behaviour for specific cases.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431618977", "createdAt": "2020-05-28T06:54:49Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.provider.Provider;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.\n+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this executor to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyExecutor extends Provider {\n+\n+    @Override\n+    default void close() {\n+    }\n+\n+    /**\n+     * returns true if this executor is executed against the client.\n+     * A executor can be implemented to be executed on some events while not on others.\n+     * On the event specified as the parameter, this executor is skipped if this method returns false.\n+     *\n+     * @param event defined in {@link ClientPolicyEvent}\n+     * @return true if this executor is executed on the event.\n+     */\n+    default boolean isExecutedOnEvent(String event) {return true;}\n+\n+    /**\n+     * execute actions against the client\n+     * on Dynamic Registration Endpoint access for creating client.\n+     *\n+     * @param context\n+     * @param authType\n+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions\n+     */\n+    default void executeOnDynamicClientRegister(\n+            ClientRegistrationContext context,\n+            RegistrationAuth authType)  throws ClientPolicyException {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxOTE3Ng==", "bodyText": "Default should just be an empty method, it should not throw an exception. Applies to all default methods below.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431619176", "createdAt": "2020-05-28T06:55:13Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.provider.Provider;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.\n+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this executor to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyExecutor extends Provider {\n+\n+    @Override\n+    default void close() {\n+    }\n+\n+    /**\n+     * returns true if this executor is executed against the client.\n+     * A executor can be implemented to be executed on some events while not on others.\n+     * On the event specified as the parameter, this executor is skipped if this method returns false.\n+     *\n+     * @param event defined in {@link ClientPolicyEvent}\n+     * @return true if this executor is executed on the event.\n+     */\n+    default boolean isExecutedOnEvent(String event) {return true;}\n+\n+    /**\n+     * execute actions against the client\n+     * on Dynamic Registration Endpoint access for creating client.\n+     *\n+     * @param context\n+     * @param authType\n+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions\n+     */\n+    default void executeOnDynamicClientRegister(\n+            ClientRegistrationContext context,\n+            RegistrationAuth authType)  throws ClientPolicyException {}\n+\n+    /**\n+     * execute actions against the client\n+     * on Dynamic Registration Endpoint access for updating client.\n+     *\n+     * @param context\n+     * @param authType\n+     * @param client - current client's model\n+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions\n+     */\n+    default void executeOnDynamicClientUpdate(\n+            ClientRegistrationContext context,\n+            RegistrationAuth authType,\n+            ClientModel client)  throws ClientPolicyException {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxOTM3OQ==", "bodyText": "I'm not too keen on the use of an AbstractClientPolicyExecutor here as this shows possibly a weakness in the interface.\nFor update events the augment for all executors needs to be done prior to the isSatisfied as it could be that one executor adds something that a different executor requires.\nI would probably rather have something like ClientPolicyExecutor#augumentClientConfig(ClientConfigContext context) and ClientPolicyExecutor#validateClientConfig(ClientConfigContext context), this would replace the AbstractClientPoicyExecutor and the executeOnClient methods.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431619379", "createdAt": "2020-05-28T06:55:40Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/AbstractClientPoicyExecutor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor.impl;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * Executor can override the client settings to enforce some actions.\n+ * This feature can be activated or deactivated.\n+ */\n+public abstract class AbstractClientPoicyExecutor implements ClientPolicyExecutor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMTE2OQ==", "bodyText": "Same as in Condition/Executor there is no need for a separate isAugumentRequired method as the augment method should have a default empty method.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431621169", "createdAt": "2020-05-28T06:59:39Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/AbstractClientPoicyExecutor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor.impl;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * Executor can override the client settings to enforce some actions.\n+ * This feature can be activated or deactivated.\n+ */\n+public abstract class AbstractClientPoicyExecutor implements ClientPolicyExecutor {\n+\n+    protected static final Logger logger = Logger.getLogger(AbstractClientPoicyExecutor.class);\n+\n+    protected final KeycloakSession session;\n+    protected final ComponentModel componentModel;\n+\n+    public AbstractClientPoicyExecutor(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    // on Dynamic Registration Endpoint access for creating client\n+    @Override\n+    public void executeOnDynamicClientRegister(\n+            ClientRegistrationContext context,\n+            RegistrationAuth authType) throws ClientPolicyException {\n+        if(isAugmentRequired()) augment(context.getClient());\n+        validate(context.getClient());\n+    }\n+\n+    // on Dynamic Registration Endpoint access for updating client\n+    @Override\n+    public void executeOnDynamicClientUpdate(\n+            ClientRegistrationContext context,\n+            RegistrationAuth authType,\n+            ClientModel client)  throws ClientPolicyException {\n+        if(isAugmentRequired()) augment(context.getClient());\n+        validate(context.getClient());\n+    }\n+ \n+    // on Admin REST API Registration access for creating client\n+    @Override\n+    public void executeOnClientRegister(\n+            ClientRepresentation rep,\n+            AdminAuth admin) throws ClientPolicyException {\n+        if(isAugmentRequired()) augment(rep);\n+        validate(rep);\n+    };\n+\n+    // on Admin REST API Registration access for updating client\n+    @Override\n+    public void executeOnClientUpdate(\n+            ClientRepresentation rep,\n+            AdminAuth admin,\n+            ClientModel client) throws ClientPolicyException {\n+        if(isAugmentRequired()) augment(rep);\n+        validate(rep);\n+    };\n+\n+    /**\n+     * returns true if this executor overrides the client settings. \n+     *\n+     * @return true if this executor overrides the client settings\n+     */\n+    protected abstract boolean isAugmentRequired();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMzMxNA==", "bodyText": "I couldn't find how the ClientPolicyManager has replaced the ClientRegistrationPolicyManager yet? Can you explain how the old client registration policies are executed now?", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431623314", "createdAt": "2020-05-28T07:04:36Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientregistration/ClientRegistrationAuth.java", "diffHunk": "@@ -149,8 +151,8 @@ public RegistrationAuth requireCreate(ClientRegistrationContext context) {\n         }\n \n         try {\n-            ClientRegistrationPolicyManager.triggerBeforeRegister(context, registrationAuth);\n-        } catch (ClientRegistrationPolicyException crpe) {\n+            ClientPolicyManager.triggerBeforeRegister(context, registrationAuth);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8264b230f76bf1ecdaf55eff84c4567467c05b3"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMjUzMTU5", "url": "https://github.com/keycloak/keycloak/pull/7104#pullrequestreview-432253159", "createdAt": "2020-06-17T10:07:35Z", "commit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMDowNzozNlrOGk_Bwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMjo0NDowNVrOGmTfUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNDU2Mg==", "bodyText": "This is not used right? So should be removed", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441434562", "createdAt": "2020-06-17T10:07:36Z", "author": {"login": "stianst"}, "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProviderFactory.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+\n+import org.keycloak.component.ComponentFactory;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.provider.ProviderConfigProperty;\n+\n+public interface ClientPolicyProviderFactory extends ComponentFactory<ClientPolicyProvider, ClientPolicyProvider> {\n+\n+    List<ProviderConfigProperty> getConfigProperties(KeycloakSession session);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNTQ5OA==", "bodyText": "Nitpick to improve readability a bit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                default boolean isSatisfiedOnEvent(ClientPolicyContext context) throws ClientPolicyException {return true;}\n          \n          \n            \n                default boolean isSatisfiedOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n          \n          \n            \n                    return true;\n          \n          \n            \n                }", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441435498", "createdAt": "2020-06-17T10:09:16Z", "author": {"login": "stianst"}, "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionProvider.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+\n+/**\n+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.\n+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this condition to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyConditionProvider extends Provider {\n+\n+    final String SKIP_EVALUATION = \"skip-evaluation\";\n+\n+    @Override\n+    default void close() {}\n+\n+    /**\n+     * returns true if the client satisfies this condition on the event defined in {@link ClientPolicyEvent}.\n+     *\n+     * @param context - the context of the event.\n+     * @return true if the client satisfies this condition.\n+     * @throws {@link ClientPolicyException} - thrown if the condition is not evaluated in its nature on the event specified by context.\n+     */\n+    default boolean isSatisfiedOnEvent(ClientPolicyContext context) throws ClientPolicyException {return true;}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNjU5OA==", "bodyText": "What's the purpose of ClientPolicyException with skip-evaluation error? Shouldn't a condition just return true rather than throw an exception with skip-evaluation?", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441436598", "createdAt": "2020-06-17T10:11:09Z", "author": {"login": "stianst"}, "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionProvider.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+\n+/**\n+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.\n+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this condition to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyConditionProvider extends Provider {\n+\n+    final String SKIP_EVALUATION = \"skip-evaluation\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNzMxOQ==", "bodyText": "Nitpick to improve readability a bit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                default void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {}\n          \n          \n            \n                default void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n          \n          \n            \n                }", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441437319", "createdAt": "2020-06-17T10:12:22Z", "author": {"login": "stianst"}, "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorProvider.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+\n+/**\n+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.\n+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this executor to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyExecutorProvider extends Provider {\n+\n+    @Override\n+    default void close() {}\n+\n+    /**\n+     * execute actions against the client on the event defined in {@link ClientPolicyEvent}.\n+     * \n+     * @param context - the context of the event.\n+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions.\n+     */\n+    default void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0MjI3Mg==", "bodyText": "I would rename this to something like AbstractAugumentingClientRegistrationPolicyExecutor. This is not really an abstract client policy executor, but rather a specific type of client policy exectuor.\nI'd also move the IS_AUGMENT field from ClientPolicyExecutorProviderFactory and move it to this class, then add the logic if (Boolean.valueOf(componentModel.getConfig().getFirst(ClientPolicyExecutorProviderFactory.IS_AUGMENT))) here instead of requiring the implementing classes to do that.\nFinally I would also add the augument config property options to this class, so sub-classes don't have to add it. If they just want to add something they can do something like:\ngetConfigProperties() {\n    List<ProviderConfigProperty l = super.getConfigProperties();\n    l.add(...)\n}", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441442272", "createdAt": "2020-06-17T10:21:27Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/AbstractClientPoicyExecutor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor.impl;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientUpdateContext;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+\n+public abstract class AbstractClientPoicyExecutor implements ClientPolicyExecutorProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0NzI0OQ==", "bodyText": "What's the use-case for this one? It seems to enable a policy if the client has a specific role, but couldn't think why you would want that.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441447249", "createdAt": "2020-06-17T10:31:02Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestClientRolesCondition.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition.impl;\n+\n+import java.util.List;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.impl.ClientPolicyLogger;\n+\n+public class TestClientRolesCondition implements ClientPolicyConditionProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0OTkxNA==", "bodyText": "Not sure these are quite correct. It shouldn't matter if you are using admin-apis or dynamic client registration apis. It's more down to who you are. So options should be something more like:\n\nauthenticated-user\nanonymous\ninitial-access-token\n\nFor initial-access-token it would actually be nice if we have a way in the future to generate different tokens for different groups of users or something, so an admin can issue tokens with different rights. That's certainly out of scope for this PR though.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441449914", "createdAt": "2020-06-17T10:36:03Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestAuthnMethodsConditionFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.provider.ProviderConfigProperty;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+\n+public class TestAuthnMethodsConditionFactory implements ClientPolicyConditionProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"test-authnmethods-condition\";\n+\n+    public static final String AUTH_METHOD = \"auth-method\";\n+    public static final String BY_ADMIN_REST_API = \"ByAdminRestAPI\";\n+    public static final String BY_DYNAMIC_ANONYMOUS = RegistrationAuth.ANONYMOUS.name();\n+    public static final String BY_DYNAMIC_AUTHENTICATED = RegistrationAuth.AUTHENTICATED.name();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MDg1OQ==", "bodyText": "pkce-enforce and drop Test from class name, see previous comment for details", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441450859", "createdAt": "2020-06-17T10:37:52Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/TestPKCEEnforceExecutorFactory.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor.impl;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.provider.ProviderConfigProperty;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProviderFactory;\n+\n+public class TestPKCEEnforceExecutorFactory implements ClientPolicyExecutorProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"test-pkce-enforce-executor\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1Mjg2Mw==", "bodyText": "Wonder if we actually care if it's dynamic or admin register/update. It's more down to who did the update, rather than what endpoint they used. So perhaps it would be better to just have REGISTER and UPDATE?", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441452863", "createdAt": "2020-06-17T10:41:49Z", "author": {"login": "stianst"}, "path": "server-spi/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+public enum ClientPolicyEvent {\n+\n+    DYNAMIC_REGISTER,\n+    DYNAMIC_UPDATE,\n+    ADMIN_REGISTER,\n+    ADMIN_UPDATE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNDc5Mw==", "bodyText": "See comment on AbstractClientPoicyExecutor. I would remove this from here.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r442814793", "createdAt": "2020-06-19T12:36:25Z", "author": {"login": "stianst"}, "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorProviderFactory.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.keycloak.component.ComponentFactory;\n+\n+public interface ClientPolicyExecutorProviderFactory extends ComponentFactory<ClientPolicyExecutorProvider, ClientPolicyExecutorProvider> {\n+\n+    public static final String IS_AUGMENT = \"is-augment\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNTgxMw==", "bodyText": "I would prefer if there's a single way to get auth context rather than two separate depending on what API is used. That is enhancements/polish we can do later though.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r442815813", "createdAt": "2020-06-19T12:38:38Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientUpdateContext.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * Represents the context in the client registration/update by Dynamic Client Registration or Admin REST API.\n+ */\n+public interface ClientUpdateContext extends ClientPolicyContext {\n+\n+    /**\n+     * returns {@link ClientModel} of the current client that will be updated.\n+     *\n+     * @return {@link ClientModel}\n+     */\n+    default ClientModel getCurrentClientModel() {return null;}\n+\n+    /**\n+     * returns {@link ClientRepresentation} for updating the current client by Admin REST API.\n+     *\n+     * @return {@link ClientRepresentation}\n+     */\n+    default ClientRepresentation getProposedClientRepresentation() {return null;}\n+\n+    /**\n+     * returns {@link RegistrationAuth} by Dynamic Client Registration.\n+     *\n+     * @return {@link RegistrationAuth}\n+     */\n+    default RegistrationAuth getDynamicRegistrationAuth() {return null;}\n+\n+    /**\n+     * returns {@link AdminAuth} by Admin REST API.\n+     *\n+     * @return {@link AdminAuth}\n+     */\n+    default AdminAuth getAdminAuth() {return null;}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNzE1MQ==", "bodyText": "Having Test prefix on class name is confusing to me. At first I was thinking this had to do with testing.\nAnother thing is classes being in impl package, this is not a convention we use in Keycloak codebase elsewhere.\nPROVIDER_ID should just be \"authnmethods\". I find \"Test\" confusing and \"condition\" is already implied as it's \"authnmethods\" of \"client-policy-condition\" SPI.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r442817151", "createdAt": "2020-06-19T12:41:26Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestAuthnMethodsConditionFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.provider.ProviderConfigProperty;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+\n+public class TestAuthnMethodsConditionFactory implements ClientPolicyConditionProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"test-authnmethods-condition\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxODA2NA==", "bodyText": "I'd just use clientroles and drop Test from class-name, see previous comment for more details", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r442818064", "createdAt": "2020-06-19T12:43:24Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestClientRolesConditionFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.provider.ProviderConfigProperty;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;\n+\n+public class TestClientRolesConditionFactory implements ClientPolicyConditionProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"test-clientroles-condition\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxODM4NQ==", "bodyText": "client-authn and drop Test from class name. See previous comment for more details", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r442818385", "createdAt": "2020-06-19T12:44:05Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/TestClientAuthenticationExecutorFactory.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor.impl;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.authentication.authenticators.client.JWTClientAuthenticator;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.provider.ProviderConfigProperty;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProviderFactory;\n+\n+public class TestClientAuthenticationExecutorFactory implements ClientPolicyExecutorProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"test-client-authn-executor\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "267c19c87e70cbd3f728c20aac3843d4a0ec823d"}, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "540b93adbbeaaf9a98afffd7a0c0ed57c604a301", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/540b93adbbeaaf9a98afffd7a0c0ed57c604a301", "committedDate": "2020-06-22T06:59:34Z", "message": "WIP revised codes for 2nd round review comments feedback"}, "afterCommit": {"oid": "ae04e159b2cfda874f63fa67a38b4450b0067e1e", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/ae04e159b2cfda874f63fa67a38b4450b0067e1e", "committedDate": "2020-06-25T03:36:50Z", "message": "revise codes for 2nd iteration review comments feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae04e159b2cfda874f63fa67a38b4450b0067e1e", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/ae04e159b2cfda874f63fa67a38b4450b0067e1e", "committedDate": "2020-06-25T03:36:50Z", "message": "revise codes for 2nd iteration review comments feedback"}, "afterCommit": {"oid": "f54ad3200705b542359bf59d5320ea2a364af621", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/f54ad3200705b542359bf59d5320ea2a364af621", "committedDate": "2020-06-25T05:54:51Z", "message": "revise codes for 2nd iteration review comments feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a19c33155d28c8d3628f6dba9509471896a03510", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/a19c33155d28c8d3628f6dba9509471896a03510", "committedDate": "2020-06-28T00:10:28Z", "message": "support GET method on UserInfo Endpoint"}, "afterCommit": {"oid": "1a21f1d0cc2a8014ac9beee62ab6cc08aebc4406", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/1a21f1d0cc2a8014ac9beee62ab6cc08aebc4406", "committedDate": "2020-06-28T03:13:36Z", "message": "support GET method on UserInfo Endpoint"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzI2Njgz", "url": "https://github.com/keycloak/keycloak/pull/7104#pullrequestreview-444726683", "createdAt": "2020-07-08T12:45:05Z", "commit": {"oid": "1a21f1d0cc2a8014ac9beee62ab6cc08aebc4406"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMjo0NTowNVrOGumVhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxMjo0NTowNVrOGumVhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUxNTc4Mw==", "bodyText": "Thinking about this some more I wonder if skipping the policies on an exception is a good thing. It could result in some error in a condition resulting in accepting things that shouldn't be accepted. Wonder if we should fail the request in this case instead.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r451515783", "createdAt": "2020-07-08T12:45:05Z", "author": {"login": "stianst"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/DefaultClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.Profile;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyManager;\n+import org.keycloak.services.clientpolicy.ClientPolicyProvider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+\n+public class DefaultClientPolicyManager implements ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(DefaultClientPolicyManager.class);\n+\n+    private final KeycloakSession session;\n+    private final Map<String, List<ClientPolicyProvider>> providersMap = new HashMap<>();\n+\n+    public DefaultClientPolicyManager(KeycloakSession session) {\n+        this.session = session;\n+    }\n+\n+    @Override\n+    public void triggerOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        if (!Profile.isFeatureEnabled(Profile.Feature.CLIENT_POLICIES)) return;\n+        ClientPolicyLogger.logv(logger, \"Client Policy Operation : event = {0}\", context.getEvent());\n+        doPolicyOperation(\n+                (ClientPolicyConditionProvider condition) -> condition.isSatisfiedOnEvent(context),\n+                (ClientPolicyExecutorProvider executor) -> executor.executeOnEvent(context)\n+            );\n+    }\n+\n+    private void doPolicyOperation(ClientConditionOperation condition, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        for (ClientPolicyProvider policy : getProviders(realm)) {\n+            ClientPolicyLogger.logv(logger, \"Policy Operation : name = {0}, provider id = {1}\", policy.getName(), policy.getProviderId());\n+            if (!isSatisfied(policy, condition)) continue;\n+            execute(policy, executor);\n+        }\n+    }\n+\n+    private List<ClientPolicyProvider> getProviders(RealmModel realm) {\n+        List<ClientPolicyProvider> providers = providersMap.get(realm.getId());\n+        if (providers == null) {\n+            providers = new LinkedList<>();\n+            List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+            for (ComponentModel policyModel : policyModels) {\n+                try {\n+                    ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+                    ClientPolicyLogger.logv(logger, \"Loaded Policy Name = {0}\", policyModel.getName());\n+                    session.enlistForClose(policy);\n+                    providers.add(policy);\n+                } catch (Throwable t) {\n+                    logger.errorv(t, \"Failed to load provider {0}\", policyModel.getId());\n+                }\n+            }\n+            providersMap.put(realm.getId(), providers);\n+        } else {\n+            ClientPolicyLogger.log(logger, \"Use cached policies.\");\n+        }\n+        return providers;\n+    }\n+\n+    private boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            ClientConditionOperation op) {\n+\n+        List<ClientPolicyConditionProvider> conditions = policy.getConditions();\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition exists.\");\n+            return false;\n+        }\n+\n+        boolean ret = false;\n+        for (ClientPolicyConditionProvider condition : conditions) {\n+            try {\n+                if (!op.run(condition)) {\n+                    ClientPolicyLogger.logv(logger, \"NEGATIVE :: This policy is not applied. condition not satisfied. name = {0}, provider id = {1}, \", condition.getName(), condition.getProviderId());\n+                    return false;\n+                } else {\n+                    ret = true;\n+                }\n+            } catch (ClientPolicyException cpe) {\n+                if (cpe.getError().equals(ClientPolicyConditionProvider.SKIP_EVALUATION)) {\n+                    ClientPolicyLogger.logv(logger, \"SKIP : This condition is not evaluated due to its nature. name = {0}, provider id = {1}\", condition.getName(), condition.getProviderId());\n+                    continue;\n+                }\n+                ClientPolicyLogger.logv(logger, \"CONDITION EXCEPTION : name = {0}, provider id = {1}, error = {2}, error_detail = {3}\", condition.getName(), condition.getProviderId(), cpe.getError(), cpe.getErrorDetail());\n+                return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a21f1d0cc2a8014ac9beee62ab6cc08aebc4406"}, "originalPosition": 115}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b7d70711e4bc2fdc773cfe89834871af55519d69", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/b7d70711e4bc2fdc773cfe89834871af55519d69", "committedDate": "2020-07-09T02:14:53Z", "message": "28. ClientPolicyConditionProvider : request fails if an exception happens"}, "afterCommit": {"oid": "9896dc6404d47fa3d0751e5b888a67e8e119b0e3", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/9896dc6404d47fa3d0751e5b888a67e8e119b0e3", "committedDate": "2020-07-09T06:04:14Z", "message": "28. ClientPolicyConditionProvider : request fails if an exception happens"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MzQ2ODk5", "url": "https://github.com/keycloak/keycloak/pull/7104#pullrequestreview-445346899", "createdAt": "2020-07-09T07:15:33Z", "commit": {"oid": "9896dc6404d47fa3d0751e5b888a67e8e119b0e3"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MjQ1ODAw", "url": "https://github.com/keycloak/keycloak/pull/7104#pullrequestreview-447245800", "createdAt": "2020-07-13T13:24:01Z", "commit": {"oid": "35a6a86b15d709bad843a57a3bf91191e43930d7"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NzgxODI4", "url": "https://github.com/keycloak/keycloak/pull/7104#pullrequestreview-447781828", "createdAt": "2020-07-14T04:44:50Z", "commit": {"oid": "35a6a86b15d709bad843a57a3bf91191e43930d7"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5Njk3NzM0", "url": "https://github.com/keycloak/keycloak/pull/7104#pullrequestreview-449697734", "createdAt": "2020-07-16T09:56:03Z", "commit": {"oid": "35a6a86b15d709bad843a57a3bf91191e43930d7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwOTo1NjowM1rOGyjzMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzoyOToxOVrOGy1J-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY2ODUzMA==", "bodyText": "Very minor typo (two occurences of \"to which\")", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455668530", "createdAt": "2020-07-16T09:56:03Z", "author": {"login": "mposolda"}, "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorProvider.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+\n+/**\n+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a6a86b15d709bad843a57a3bf91191e43930d7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzI1Ng==", "bodyText": "Is this needed in the pull request? Some other tests, which rely on profile features, don't need to set this system property explicitly?", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455937256", "createdAt": "2020-07-16T17:03:48Z", "author": {"login": "mposolda"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java", "diffHunk": "@@ -0,0 +1,938 @@\n+package org.keycloak.testsuite.client;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.keycloak.testsuite.admin.AbstractAdminTest.loadJson;\n+import static org.keycloak.testsuite.admin.ApiUtil.findUserByUsername;\n+\n+import java.io.IOException;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.core.Response;\n+\n+import org.hamcrest.Matchers;\n+import org.jboss.logging.Logger;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.admin.client.resource.ClientResource;\n+import org.keycloak.authentication.authenticators.client.ClientIdAndSecretAuthenticator;\n+import org.keycloak.authentication.authenticators.client.JWTClientAuthenticator;\n+import org.keycloak.authentication.authenticators.client.JWTClientSecretAuthenticator;\n+import org.keycloak.authentication.authenticators.client.X509ClientAuthenticator;\n+import org.keycloak.client.registration.Auth;\n+import org.keycloak.client.registration.ClientRegistration;\n+import org.keycloak.client.registration.ClientRegistrationException;\n+import org.keycloak.common.Profile;\n+import org.keycloak.common.util.Base64Url;\n+import org.keycloak.common.util.MultivaluedHashMap;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventType;\n+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.representations.AccessToken;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.representations.idm.ClientInitialAccessCreatePresentation;\n+import org.keycloak.representations.idm.ClientInitialAccessPresentation;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.ComponentRepresentation;\n+import org.keycloak.representations.idm.EventRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.oidc.OIDCClientRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyProvider;\n+import org.keycloak.services.clientpolicy.DefaultClientPolicyProviderFactory;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+import org.keycloak.testsuite.AbstractKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.admin.ApiUtil;\n+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestAuthnMethodsConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestClientRolesConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestRaiseExeptionConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.executor.TestClientAuthenticationExecutorFactory;\n+import org.keycloak.testsuite.services.clientpolicy.executor.TestPKCEEnforceExecutorFactory;\n+import org.keycloak.testsuite.util.OAuthClient;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+@EnableFeature(value = Profile.Feature.CLIENT_POLICIES, skipRestart = true)\n+public class ClientPolicyBasicsTest extends AbstractKeycloakTest {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyBasicsTest.class);\n+\n+    static final String REALM_NAME = \"test\";\n+    static final String TEST_CLIENT = \"test-app\";\n+\n+    ClientRegistration reg;\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    @Before\n+    public void before() throws Exception {\n+        // get initial access token for Dynamic Client Registration with authentication\n+        reg = ClientRegistration.create().url(suiteContext.getAuthServerInfo().getContextRoot() + \"/auth\", REALM_NAME).build();\n+        ClientInitialAccessPresentation token = adminClient.realm(REALM_NAME).clientInitialAccess().create(new ClientInitialAccessCreatePresentation(0, 10));\n+        reg.auth(Auth.token(token));\n+\n+        System.setProperty(\"keycloak.profile\", \"preview\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a6a86b15d709bad843a57a3bf91191e43930d7"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzM0Nw==", "bodyText": "Same comment as above", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455937347", "createdAt": "2020-07-16T17:03:59Z", "author": {"login": "mposolda"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java", "diffHunk": "@@ -0,0 +1,938 @@\n+package org.keycloak.testsuite.client;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.keycloak.testsuite.admin.AbstractAdminTest.loadJson;\n+import static org.keycloak.testsuite.admin.ApiUtil.findUserByUsername;\n+\n+import java.io.IOException;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.core.Response;\n+\n+import org.hamcrest.Matchers;\n+import org.jboss.logging.Logger;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.admin.client.resource.ClientResource;\n+import org.keycloak.authentication.authenticators.client.ClientIdAndSecretAuthenticator;\n+import org.keycloak.authentication.authenticators.client.JWTClientAuthenticator;\n+import org.keycloak.authentication.authenticators.client.JWTClientSecretAuthenticator;\n+import org.keycloak.authentication.authenticators.client.X509ClientAuthenticator;\n+import org.keycloak.client.registration.Auth;\n+import org.keycloak.client.registration.ClientRegistration;\n+import org.keycloak.client.registration.ClientRegistrationException;\n+import org.keycloak.common.Profile;\n+import org.keycloak.common.util.Base64Url;\n+import org.keycloak.common.util.MultivaluedHashMap;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventType;\n+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.representations.AccessToken;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.representations.idm.ClientInitialAccessCreatePresentation;\n+import org.keycloak.representations.idm.ClientInitialAccessPresentation;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.ComponentRepresentation;\n+import org.keycloak.representations.idm.EventRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.oidc.OIDCClientRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyProvider;\n+import org.keycloak.services.clientpolicy.DefaultClientPolicyProviderFactory;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+import org.keycloak.testsuite.AbstractKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.admin.ApiUtil;\n+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestAuthnMethodsConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestClientRolesConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestRaiseExeptionConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.executor.TestClientAuthenticationExecutorFactory;\n+import org.keycloak.testsuite.services.clientpolicy.executor.TestPKCEEnforceExecutorFactory;\n+import org.keycloak.testsuite.util.OAuthClient;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+@EnableFeature(value = Profile.Feature.CLIENT_POLICIES, skipRestart = true)\n+public class ClientPolicyBasicsTest extends AbstractKeycloakTest {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyBasicsTest.class);\n+\n+    static final String REALM_NAME = \"test\";\n+    static final String TEST_CLIENT = \"test-app\";\n+\n+    ClientRegistration reg;\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    @Before\n+    public void before() throws Exception {\n+        // get initial access token for Dynamic Client Registration with authentication\n+        reg = ClientRegistration.create().url(suiteContext.getAuthServerInfo().getContextRoot() + \"/auth\", REALM_NAME).build();\n+        ClientInitialAccessPresentation token = adminClient.realm(REALM_NAME).clientInitialAccess().create(new ClientInitialAccessCreatePresentation(0, 10));\n+        reg.auth(Auth.token(token));\n+\n+        System.setProperty(\"keycloak.profile\", \"preview\");\n+        Profile.init();\n+\n+    }\n+\n+    @After\n+    public void after() throws Exception {\n+        reg.close();\n+\n+        System.getProperties().remove(\"keycloak.profile\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a6a86b15d709bad843a57a3bf91191e43930d7"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0MzE2NQ==", "bodyText": "Does this interface need to have default methods? I see that most of the implementations need to override all the methods (with the exception of getClientToBeUpdated in case of \"Register\" classes). IMO it will be better if this interface don't have default methods - maybe with the exception of \"getClientToBeUpdated\" method.", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455943165", "createdAt": "2020-07-16T17:13:34Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientUpdateContext.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.representations.JsonWebToken;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+\n+/**\n+ * Represents the context in the client registration/update by Dynamic Client Registration or Admin REST API.\n+ */\n+public interface ClientUpdateContext extends ClientPolicyContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a6a86b15d709bad843a57a3bf91191e43930d7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0ODkzMA==", "bodyText": "@tnorimat @stianst Maybe you discuss this already, but I am not 100% sure if ClientPolicyProvider need to be really Java provider? Isn't it rather just a ComponentModel?\nPer my understanding, the ClientPolicy provides binding between the set of conditions and executors. Hence usually I the typical administrator will create the policy instance in the admin console. And then he create some conditions and executors and bind them to this policy.\nI am probably missing some use-case why the ClientPolicyProvider is beneficial as a java provider rather than as a \"model\" ?", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455948930", "createdAt": "2020-07-16T17:22:56Z", "author": {"login": "mposolda"}, "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProvider.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+\n+/**\n+ * Provides Client Policy which accommodates several Conditions and Executors.\n+ */\n+public interface ClientPolicyProvider extends Provider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a6a86b15d709bad843a57a3bf91191e43930d7"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1Mjg5MA==", "bodyText": "@tnorimat @stianst I have some concerns about the security of this.\nI am thinking of some scenario like:\n\nAdministrator start the server with the CLIENT_POLICIES feature enabled\nAdministrator configures some client policies\nAdministrator restart the server, but he forgets to enable the CLIENT_POLICIES feature for some reason (For example he is migrating from one environment to another and startup commands are slightly different etc).\nClient policies now won't be triggered at all, which can result in some potential unexpected issues (in theory even security issues).\n\nDo we want some better protection against this scenario? For example if CLIENT_POLICIES feature is not enabled, BUT there are some client policies in the DB, then throw the exception at startup - or at least big warning.\nI've just checked that for example WebAuthn works this way (If there is WebAuthn feature disabled BUT WebAuthn required action is registered in the realm, then the exception is thrown during attempt to authenticate user).", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455952890", "createdAt": "2020-07-16T17:29:19Z", "author": {"login": "mposolda"}, "path": "services/src/main/java/org/keycloak/services/clientpolicy/DefaultClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.Profile;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyManager;\n+import org.keycloak.services.clientpolicy.ClientPolicyProvider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+\n+public class DefaultClientPolicyManager implements ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(DefaultClientPolicyManager.class);\n+\n+    private final KeycloakSession session;\n+    private final Map<String, List<ClientPolicyProvider>> providersMap = new HashMap<>();\n+\n+    public DefaultClientPolicyManager(KeycloakSession session) {\n+        this.session = session;\n+    }\n+\n+    @Override\n+    public void triggerOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        if (!Profile.isFeatureEnabled(Profile.Feature.CLIENT_POLICIES)) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a6a86b15d709bad843a57a3bf91191e43930d7"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec158b896517ad47df7d196319bb35b9cdf9d3c4", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/ec158b896517ad47df7d196319bb35b9cdf9d3c4", "committedDate": "2020-07-20T07:55:58Z", "message": "KEYCLOAK-14189 Client Policy : Basics"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c2be37550149929bb6151048a5302bfd3389123", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/2c2be37550149929bb6151048a5302bfd3389123", "committedDate": "2020-07-16T21:41:20Z", "message": "No.31 ClientUpdateContext : remove unnecessary default methods"}, "afterCommit": {"oid": "ec158b896517ad47df7d196319bb35b9cdf9d3c4", "author": {"user": {"login": "tnorimat", "name": "Takashi Norimatsu"}}, "url": "https://github.com/keycloak/keycloak/commit/ec158b896517ad47df7d196319bb35b9cdf9d3c4", "committedDate": "2020-07-20T07:55:58Z", "message": "KEYCLOAK-14189 Client Policy : Basics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNjQ5NDI2", "url": "https://github.com/keycloak/keycloak/pull/7104#pullrequestreview-451649426", "createdAt": "2020-07-20T14:17:34Z", "commit": {"oid": "ec158b896517ad47df7d196319bb35b9cdf9d3c4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMTQzMzAy", "url": "https://github.com/keycloak/keycloak/pull/7104#pullrequestreview-452143302", "createdAt": "2020-07-21T05:49:10Z", "commit": {"oid": "ec158b896517ad47df7d196319bb35b9cdf9d3c4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3088, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}