{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3NzM0ODA0", "number": 7524, "title": "[KEYCLOAK-15200] Complement methods for accessing users with Stream v\u2026", "bodyText": "\u2026ariants", "createdAt": "2020-10-21T17:35:10Z", "url": "https://github.com/keycloak/keycloak/pull/7524", "merged": true, "mergeCommit": {"oid": "aa4673517308a2f6b8214b192eb2151554564718"}, "closed": true, "closedAt": "2020-11-10T14:13:13Z", "author": {"login": "sguilhen"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWUwUjgFqTUxNjU0OTI4Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbKAPLAFqTUyNzI0MDYxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NTQ5Mjgz", "url": "https://github.com/keycloak/keycloak/pull/7524#pullrequestreview-516549283", "createdAt": "2020-10-26T08:23:53Z", "commit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwODoyMzo1M1rOHoE11g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMzo1MDowOVrOHoQY8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4NDQwNg==", "bodyText": "ldapQuery.getResultList() doesn't seem to return null so maybe this if may be removed?", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511784406", "createdAt": "2020-10-26T08:23:53Z", "author": {"login": "martin-kanis"}, "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -257,23 +256,18 @@ public boolean supportsCredentialAuthenticationFor(String type) {\n              List<LDAPObject> ldapObjects = ldapQuery.getResultList();\n \n              if (ldapObjects == null || ldapObjects.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5NDAxNA==", "bodyText": "I think we need to be more careful with skip which throws an IllegalArgumentException when a negative number is provided.", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511794014", "createdAt": "2020-10-26T08:41:43Z", "author": {"login": "martin-kanis"}, "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5OTIyOQ==", "bodyText": "This lambda can be avoided like this: ((Predicate<List>) List::isEmpty).negate()", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511799229", "createdAt": "2020-10-26T08:51:05Z", "author": {"login": "martin-kanis"}, "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMDcxNQ==", "bodyText": "Maybe it can be simplified like\nreturn...\n.map(List::stream)\n.findFirst().orElse(Stream.empty());", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511800715", "createdAt": "2020-10-26T08:53:45Z", "author": {"login": "martin-kanis"}, "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTQ2MA==", "bodyText": "Same as above", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511801460", "createdAt": "2020-10-26T08:55:00Z", "author": {"login": "martin-kanis"}, "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role) {\n-        return getRoleMembers(realm, role, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n+        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getRoleMembers(realm, role, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .filter(list -> list.size() > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTU3Mg==", "bodyText": "Same as above", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511801572", "createdAt": "2020-10-26T08:55:10Z", "author": {"login": "martin-kanis"}, "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role) {\n-        return getRoleMembers(realm, role, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n+        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getRoleMembers(realm, role, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .filter(list -> list.size() > 0)\n+                .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzMzQ0NA==", "bodyText": "Is this equal to the collection variant? Shouldn't there be Stream.concat(super.getRequiredActionsStream(), Stream.of(RequiredAction.UPDATE_PASSWORD.toString())).distinct(); ?", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511833444", "createdAt": "2020-10-26T09:47:50Z", "author": {"login": "martin-kanis"}, "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java", "diffHunk": "@@ -299,18 +300,13 @@ public void removeRequiredAction(String action) {\n         }\n \n         @Override\n-        public Set<String> getRequiredActions() {\n-            Set<String> requiredActions = super.getRequiredActions();\n-\n+        public Stream<String> getRequiredActionsStream() {\n             if (ldapProvider.getEditMode() == UserStorageProvider.EditMode.WRITABLE) {\n                 if (getPwdLastSet() == 0 || getUserAccountControl(ldapUser).has(UserAccountControl.PASSWORD_EXPIRED)) {\n-                    requiredActions = new HashSet<>(requiredActions);\n-                    requiredActions.add(RequiredAction.UPDATE_PASSWORD.toString());\n-                    return requiredActions;\n+                    return Stream.of(RequiredAction.UPDATE_PASSWORD.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NzI4Nw==", "bodyText": "Couldn't we just return already obtained identities? federatedIdentities.stream();?", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511857287", "createdAt": "2020-10-26T10:27:18Z", "author": {"login": "martin-kanis"}, "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -578,64 +576,65 @@ public int getUsersCount(Map<String, String> params, RealmModel realm, Set<Strin\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {\n-        return getDelegate().getUsers(realm, firstResult, maxResults, includeServiceAccounts);\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {\n+        return getDelegate().getUsersStream(realm, firstResult, maxResults, includeServiceAccounts);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n-        return getUsers(realm, false);\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n+        return getUsersStream(realm, false);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n-         return getUsers(realm, firstResult, maxResults, false);\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n+         return getUsersStream(realm, firstResult, maxResults, false);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm) {\n-        return getDelegate().searchForUser(search, realm);\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n+        return getDelegate().searchForUserStream(search, realm);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n-        return getDelegate().searchForUser(search, realm, firstResult, maxResults);\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n+        return getDelegate().searchForUserStream(search, realm, firstResult, maxResults);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm) {\n-        return getDelegate().searchForUser(attributes, realm);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm) {\n+        return getDelegate().searchForUserStream(attributes, realm);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n-        return getDelegate().searchForUser(attributes, realm, firstResult, maxResults);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n+        return getDelegate().searchForUserStream(attributes, realm, firstResult, maxResults);\n     }\n \n     @Override\n-    public List<UserModel> searchForUserByUserAttribute(String attrName, String attrValue, RealmModel realm) {\n-        return getDelegate().searchForUserByUserAttribute(attrName, attrValue, realm);\n+    public Stream<UserModel> searchForUserByUserAttributeStream(String attrName, String attrValue, RealmModel realm) {\n+        return getDelegate().searchForUserByUserAttributeStream(attrName, attrValue, realm);\n     }\n \n     @Override\n-    public Set<FederatedIdentityModel> getFederatedIdentities(UserModel user, RealmModel realm) {\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n         logger.tracev(\"getFederatedIdentities: {0}\", user.getUsername());\n \n         String cacheKey = getFederatedIdentityLinksCacheKey(user.getId());\n         if (realmInvalidations.contains(realm.getId()) || invalidations.contains(user.getId()) || invalidations.contains(cacheKey)) {\n-            return getDelegate().getFederatedIdentities(user, realm);\n+            return getDelegate().getFederatedIdentitiesStream(user, realm);\n         }\n \n         CachedFederatedIdentityLinks cachedLinks = cache.get(cacheKey, CachedFederatedIdentityLinks.class);\n \n         if (cachedLinks == null) {\n             Long loaded = cache.getCurrentRevision(cacheKey);\n-            Set<FederatedIdentityModel> federatedIdentities = getDelegate().getFederatedIdentities(user, realm);\n+            Set<FederatedIdentityModel> federatedIdentities = getDelegate().getFederatedIdentitiesStream(user, realm)\n+                    .collect(Collectors.toSet());\n             cachedLinks = new CachedFederatedIdentityLinks(loaded, cacheKey, realm, federatedIdentities);\n             cache.addRevisioned(cachedLinks, startupRevision);\n-            return federatedIdentities;\n+            return getDelegate().getFederatedIdentitiesStream(user, realm);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1ODQ0NQ==", "bodyText": "Couldn't we just return already obtained consents? consents.stream();?", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511858445", "createdAt": "2020-10-26T10:29:14Z", "author": {"login": "martin-kanis"}, "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -708,31 +707,25 @@ public UserConsentModel getConsentByClient(RealmModel realm, String userId, Stri\n     }\n \n     @Override\n-    public List<UserConsentModel> getConsents(RealmModel realm, String userId) {\n+    public Stream<UserConsentModel> getConsentsStream(RealmModel realm, String userId) {\n         logger.tracev(\"getConsents: {0}\", userId);\n \n         String cacheKey = getConsentCacheKey(userId);\n         if (realmInvalidations.contains(realm.getId()) || invalidations.contains(userId) || invalidations.contains(cacheKey)) {\n-            return getDelegate().getConsents(realm, userId);\n+            return getDelegate().getConsentsStream(realm, userId);\n         }\n \n         CachedUserConsents cached = cache.get(cacheKey, CachedUserConsents.class);\n \n         if (cached == null) {\n             Long loaded = cache.getCurrentRevision(cacheKey);\n-            List<UserConsentModel> consents = getDelegate().getConsents(realm, userId);\n+            List<UserConsentModel> consents = getDelegate().getConsentsStream(realm, userId).collect(Collectors.toList());\n             cached = new CachedUserConsents(loaded, cacheKey, realm, consents);\n             cache.addRevisioned(cached, startupRevision);\n-            return consents;\n+            return getDelegate().getConsentsStream(realm, userId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg2MTcxOA==", "bodyText": "I know you didn't introduce this star import but maybe it's right time to fix it now :)", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511861718", "createdAt": "2020-10-26T10:34:37Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -59,8 +59,13 @@\n import javax.persistence.criteria.Subquery;\n import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4OTY2NQ==", "bodyText": "Missing closing of the stream.", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511889665", "createdAt": "2020-10-26T11:25:13Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -164,12 +163,12 @@ public void removeAttribute(RealmModel realm, String userId, String name) {\n     }\n \n     @Override\n-    public List<String> getUsersByUserAttribute(RealmModel realm, String name, String value) {\n+    public Stream<String> getUsersByUserAttributeStream(RealmModel realm, String name, String value) {\n         TypedQuery<String> query = em.createNamedQuery(\"getFederatedAttributesByNameAndValue\", String.class)\n                 .setParameter(\"realmId\", realm.getId())\n                 .setParameter(\"name\", name)\n                 .setParameter(\"value\", value);\n-        return query.getResultList();\n+        return query.getResultStream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTk4Mw==", "bodyText": "Maybe also use distinct() here.", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511891983", "createdAt": "2020-10-26T11:29:45Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -489,28 +476,21 @@ public void leaveGroup(RealmModel realm, String userId, GroupModel group) {\n         if (max != -1) {\n             query.setMaxResults(max);\n         }\n-\n-        return query.getResultList();\n+        return closing(query.getResultStream());\n     }\n \n     @Override\n-    public Set<String> getRequiredActions(RealmModel realm, String userId) {\n-        Set<String> set = new HashSet<>();\n-        List<FederatedUserRequiredActionEntity> values = getRequiredActionEntities(realm, userId, LockModeType.NONE);\n-        for (FederatedUserRequiredActionEntity entity : values) {\n-            set.add(entity.getAction());\n-        }\n-\n-        return set;\n-\n+    public Stream<String> getRequiredActionsStream(RealmModel realm, String userId) {\n+        return this.getRequiredActionEntitiesStream(realm, userId, LockModeType.NONE).\n+                map(FederatedUserRequiredActionEntity::getAction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjI2MA==", "bodyText": "You kept the original deprecated method on purpose?", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511896260", "createdAt": "2020-10-26T11:38:22Z", "author": {"login": "martin-kanis"}, "path": "server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java", "diffHunk": "@@ -160,6 +160,11 @@ public String getFirstAttribute(String name) {\n         return value;\n     }\n \n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjM2MA==", "bodyText": "Same as above", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511896360", "createdAt": "2020-10-26T11:38:33Z", "author": {"login": "martin-kanis"}, "path": "server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java", "diffHunk": "@@ -170,6 +175,11 @@ public String getFirstAttribute(String name) {\n         return requiredActions;\n     }\n \n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5OTM1Mw==", "bodyText": "Missing Javadoc.", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511899353", "createdAt": "2020-10-26T11:44:16Z", "author": {"login": "martin-kanis"}, "path": "server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java", "diffHunk": "@@ -38,6 +38,15 @@\n \n     void joinGroup(RealmModel realm, String userId, GroupModel group);\n     void leaveGroup(RealmModel realm, String userId, GroupModel group);\n-    List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max);\n+\n+    /**\n+     * @deprecated Use {@link #getMembershipStream(RealmModel, GroupModel, int, int) getMembershipStream} instead.\n+     */\n+    @Deprecated\n+    default List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max) {\n+        return this.getMembershipStream(realm, group, firstResult, max).collect(Collectors.toList());\n+    }\n+\n+    Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMTY4NQ==", "bodyText": "To avoid extra lambda  (int) users.filter(u -> u.getGroupsStream().map(GroupModel::getId).anyMatch(groupIds::contains)).count();", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511911685", "createdAt": "2020-10-26T12:08:19Z", "author": {"login": "martin-kanis"}, "path": "server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java", "diffHunk": "@@ -126,10 +122,8 @@ default int getUsersCount(Map<String, String> params, RealmModel realm, Set<Stri\n      * @param groupIds id of groups that should be checked for\n      * @return number of users that are in at least one of the groups\n      */\n-    static int countUsersInGroups(List<UserModel> users, Set<String> groupIds) {\n-        return (int) users.stream()\n-                .filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId())))\n-                .count();\n+    static int countUsersInGroups(Stream<UserModel> users, Set<String> groupIds) {\n+        return (int) users.filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId()))).count();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ==", "bodyText": "I'm wondering if we should time bound the results from federated storage same as we did in ClientStorageManager.searchClientsByClientIdStream whenever we concat local and federated entities.", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511955159", "createdAt": "2020-10-26T13:24:00Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/storage/UserStorageManager.java", "diffHunk": "@@ -608,14 +600,13 @@ public UserModel getServiceAccount(ClientModel client) {\n     }\n \n     @Override\n-    public Set<FederatedIdentityModel> getFederatedIdentities(UserModel user, RealmModel realm) {\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n         if (user == null) throw new IllegalStateException(\"Federated user no longer valid\");\n-        Set<FederatedIdentityModel> set = new HashSet<>();\n-        if (StorageId.isLocalStorage(user)) {\n-            set.addAll(localStorage().getFederatedIdentities(user, realm));\n-        }\n-        if (getFederatedStorage() != null) set.addAll(getFederatedStorage().getFederatedIdentities(user.getId(), realm));\n-        return set;\n+        Stream<FederatedIdentityModel> stream = StorageId.isLocalStorage(user) ?\n+                localStorage().getFederatedIdentitiesStream(user, realm) : Stream.empty();\n+        if (getFederatedStorage() != null)\n+            stream = Streams.concat(stream, getFederatedStorage().getFederatedIdentitiesStream(user.getId(), realm));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NzcwNw==", "bodyText": "Here again \"-1\" in skip will cause an IllegalStateException.", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511957707", "createdAt": "2020-10-26T13:27:56Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -293,49 +291,45 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n         return userPasswords.keySet().stream()\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .skip(firstResult)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1OTU2OA==", "bodyText": "Negative number in skip.", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511959568", "createdAt": "2020-10-26T13:30:21Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -293,49 +291,45 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n         return userPasswords.keySet().stream()\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .skip(firstResult)\n           .limit(maxResults)\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .filter(userName -> userName.contains(search))\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .filter(userName -> userName.contains(search))\n           .skip(firstResult)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MTQyNA==", "bodyText": "Negative number in skip.", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511961424", "createdAt": "2020-10-26T13:33:02Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -361,30 +355,27 @@ public int getUsersCount(RealmModel realm) {\n         return userStream\n           .skip(firstResult)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MjM1OA==", "bodyText": "Negative number in skip.", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511962358", "createdAt": "2020-10-26T13:34:20Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -412,15 +403,14 @@ public void leaveGroup(RealmModel realm, String userId, GroupModel group) {\n     }\n \n     @Override\n-    public List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max) {\n+    public Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max) {\n         return userGroups.entrySet().stream()\n           .filter(me -> me.getValue().contains(group.getId()))\n           .map(Map.Entry::getKey)\n           .filter(realmUser -> realmUser.startsWith(realm.getId()))\n           .map(realmUser -> realmUser.substring(realmUser.indexOf(\"/\") + 1))\n           .skip(firstResult)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MzYxOQ==", "bodyText": "What \"-1\" in maxResults actually should achieve? If that means we don't want limit number of results shouldn't we use Integer.MAX_VALUE - 1 ? Not sure if limit(0) will do the same.\nIf \"-1\" means I don't want any results (which doesn't make sense to me :D ) then it's, I guess correct.", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511973619", "createdAt": "2020-10-26T13:50:09Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java", "diffHunk": "@@ -146,88 +144,64 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n-        List<UserModel> users = new LinkedList<>();\n-        for (Object username : userPasswords.keySet()) {\n-            users.add(createUser(realm, (String)username));\n-        }\n-        return users;\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n+        return userPasswords.keySet().stream().map(obj -> createUser(realm, (String) obj));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm) {\n-        return searchForUser(attributes, realm, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm) {\n+        return searchForUserStream(attributes, realm, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n-        if (maxResults == 0) return Collections.EMPTY_LIST;\n-        List<UserModel> users = new LinkedList<>();\n-        int count = 0;\n-        for (Object un : userPasswords.keySet()) {\n-            if (count++ < firstResult) continue;\n-            String username = (String)un;\n-            users.add(createUser(realm, username));\n-            if (users.size() + 1 > maxResults) break;\n-        }\n-        return users;\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n+        return userPasswords.keySet().stream().skip(firstResult < 0 ? 0 : firstResult).limit(maxResults < 0 ? 0 : maxResults)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac"}, "originalPosition": 49}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "committedDate": "2020-10-20T17:56:03Z", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants"}, "afterCommit": {"oid": "b839690d32f81140a94289f9a443ed61111fa8e5", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/b839690d32f81140a94289f9a443ed61111fa8e5", "committedDate": "2020-10-29T17:23:27Z", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b839690d32f81140a94289f9a443ed61111fa8e5", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/b839690d32f81140a94289f9a443ed61111fa8e5", "committedDate": "2020-10-29T17:23:27Z", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants"}, "afterCommit": {"oid": "73b8207ab295a9a00c192d2d5debc14317a05816", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/73b8207ab295a9a00c192d2d5debc14317a05816", "committedDate": "2020-10-30T19:28:40Z", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce4c5764c2a2c85c895f63957dda72b22bd0a289", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/ce4c5764c2a2c85c895f63957dda72b22bd0a289", "committedDate": "2020-11-09T12:21:05Z", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "73b8207ab295a9a00c192d2d5debc14317a05816", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/73b8207ab295a9a00c192d2d5debc14317a05816", "committedDate": "2020-10-30T19:28:40Z", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants"}, "afterCommit": {"oid": "ce4c5764c2a2c85c895f63957dda72b22bd0a289", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/ce4c5764c2a2c85c895f63957dda72b22bd0a289", "committedDate": "2020-11-09T12:21:05Z", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2MjYwODU1", "url": "https://github.com/keycloak/keycloak/pull/7524#pullrequestreview-526260855", "createdAt": "2020-11-09T13:34:36Z", "commit": {"oid": "ce4c5764c2a2c85c895f63957dda72b22bd0a289"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MjQwNjEw", "url": "https://github.com/keycloak/keycloak/pull/7524#pullrequestreview-527240610", "createdAt": "2020-11-10T14:12:30Z", "commit": {"oid": "ce4c5764c2a2c85c895f63957dda72b22bd0a289"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3366, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}