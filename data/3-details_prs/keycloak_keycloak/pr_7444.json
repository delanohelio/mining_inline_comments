{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxOTI5MDk4", "number": 7444, "title": " KEYCLOAK-14977 create MapRoleProvider", "bodyText": "", "createdAt": "2020-09-23T17:24:23Z", "url": "https://github.com/keycloak/keycloak/pull/7444", "merged": true, "mergeCommit": {"oid": "785f2e78bc99e2829479847ec9ce1c4e675dda17"}, "closed": true, "closedAt": "2020-10-30T07:15:23Z", "author": {"login": "vramik"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLwJ1LgFqTQ5NDg4ODU2NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXhbJqgFqTUyMDQxOTc2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0ODg4NTY0", "url": "https://github.com/keycloak/keycloak/pull/7444#pullrequestreview-494888564", "createdAt": "2020-09-23T17:29:06Z", "commit": {"oid": "d1d75597b9d722e48e2b3fe5ec78187ed3c96d4f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNzoyOTowNlrOHW5G6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNzozNjoyMVrOHW5XxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc2NjM3Ng==", "bodyText": "This step is intentionally left separated from others for now. The reason is to isolate map role provider. I plan to change that once the PR is ready for review.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r493766376", "createdAt": "2020-09-23T17:29:06Z", "author": {"login": "vramik"}, "path": ".github/workflows/ci.yml", "diffHunk": "@@ -70,5 +70,7 @@ jobs:\n         run: tar -xzvf maven-repo.tgz -C ~\n       - name: Build testsuite\n         run: mvn clean install -B -DskipTests -f testsuite/pom.xml\n+      - name: Run base tests - role map provider", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1d75597b9d722e48e2b3fe5ec78187ed3c96d4f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3MDY5Mw==", "bodyText": "When realm is being deleted I get ConcurrentModificationException here. It seems the problem is that while we iterate over underlying collection we also remove from it.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r493770693", "createdAt": "2020-09-23T17:36:21Z", "author": {"login": "vramik"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        entity.setRealmId(client.getRealm().getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        realm.removeDefaultRoles(role.getName());\n+        \n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+              .filter(pair -> role.equals(pair.getV()))\n+              .forEach(pair -> pair.getK().removeCompositeRole(role));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1d75597b9d722e48e2b3fe5ec78187ed3c96d4f"}, "originalPosition": 193}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyODYzMTU4", "url": "https://github.com/keycloak/keycloak/pull/7444#pullrequestreview-502863158", "createdAt": "2020-10-06T12:01:02Z", "commit": {"oid": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMjowMTowMlrOHdC6PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzowODoyMVrOHdFf_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIxODQyOA==", "bodyText": "Here we can get rid of lambda by this:\n.map(RoleModel::getId)\n.forEach(realm.getDefaultRolesIds()::remove);", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500218428", "createdAt": "2020-10-06T12:01:02Z", "author": {"login": "mhajas"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -716,74 +716,46 @@ public void updateRequiredCredentials(Set<String> creds) {\n         return Collections.unmodifiableList(requiredCredentialModels);\n     }\n \n-\n     @Override\n     public Stream<String> getDefaultRolesStream() {\n-        Collection<RoleEntity> entities = realm.getDefaultRoles();\n-        if (entities == null || entities.isEmpty()) return Stream.empty();\n-        return entities.stream().map(RoleEntity::getName);\n+        return realm.getDefaultRolesIds().stream().map(this::getRoleNameById);\n+    }\n+\n+    private String getRoleNameById(String id) {\n+        return getRoleById(id).getName();\n     }\n \n     @Override\n     public void addDefaultRole(String name) {\n-        RoleModel role = getRole(name);\n-        if (role == null) {\n-            role = addRole(name);\n-        }\n-        Collection<RoleEntity> entities = realm.getDefaultRoles();\n-        for (RoleEntity entity : entities) {\n-            if (entity.getId().equals(role.getId())) {\n-                return;\n-            }\n+        if (realm.getDefaultRolesIds().add(getOrAddRoleId(name))) {\n+            em.flush();\n         }\n-        RoleEntity roleEntity = RoleAdapter.toRoleEntity(role, em);\n-        entities.add(roleEntity);\n-        em.flush();\n     }\n \n-    public static boolean contains(String str, String[] array) {\n-        for (String s : array) {\n-            if (str.equals(s)) return true;\n+    private String getOrAddRoleId(String name) {\n+        RoleModel role = getRole(name);\n+        if (role == null) {\n+            role = addRole(name);\n         }\n-        return false;\n+        return role.getId();\n     }\n \n     @Override\n     public void updateDefaultRoles(String[] defaultRoles) {\n-        Collection<RoleEntity> entities = realm.getDefaultRoles();\n-        Set<String> already = new HashSet<String>();\n-        List<RoleEntity> remove = new ArrayList<RoleEntity>();\n-        for (RoleEntity rel : entities) {\n-            if (!contains(rel.getName(), defaultRoles)) {\n-                remove.add(rel);\n-            } else {\n-                already.add(rel.getName());\n-            }\n-        }\n-        for (RoleEntity entity : remove) {\n-            entities.remove(entity);\n-        }\n-        em.flush();\n-        for (String roleName : defaultRoles) {\n-            if (!already.contains(roleName)) {\n-                addDefaultRole(roleName);\n-            }\n-        }\n+        Set<String> newDefaultRolesIds = Arrays.stream(defaultRoles)\n+                .map(this::getOrAddRoleId)\n+                .collect(Collectors.toSet());\n+        realm.getDefaultRolesIds().retainAll(newDefaultRolesIds);\n+        realm.getDefaultRolesIds().addAll(newDefaultRolesIds);\n         em.flush();\n     }\n \n     @Override\n     public void removeDefaultRoles(String... defaultRoles) {\n-        Collection<RoleEntity> entities = realm.getDefaultRoles();\n-        List<RoleEntity> remove = new ArrayList<RoleEntity>();\n-        for (RoleEntity rel : entities) {\n-            if (contains(rel.getName(), defaultRoles)) {\n-                remove.add(rel);\n-            }\n-        }\n-        for (RoleEntity entity : remove) {\n-            entities.remove(entity);\n-        }\n+        Arrays.stream(defaultRoles)\n+                .map(this::getRole)\n+                .filter(Objects::nonNull)\n+                .forEach(role -> realm.getDefaultRolesIds().remove(role.getId()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyMTUzMg==", "bodyText": "Is there any advantage of having this function static? Also, do we need the model instanceof RoleAdapter check? Is there any way this would be called from something which is not an instance of jpa.RoleAdapter?", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500221532", "createdAt": "2020-10-06T12:06:36Z", "author": {"login": "mhajas"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RoleAdapter.java", "diffHunk": "@@ -214,7 +201,7 @@ public int hashCode() {\n         return getId().hashCode();\n     }\n \n-    public static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {\n+    private static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI1NzUwNA==", "bodyText": "Here we should check that there is no client role with the name for the client. This is enforced here for the jpa layer.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500257504", "createdAt": "2020-10-06T13:03:36Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI1ODU2NQ==", "bodyText": "Here we should check that there is no realm role with the name for the realm. This is enforced here for the jpa layer.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500258565", "createdAt": "2020-10-06T13:05:05Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI2MDMxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (first != null && first >= 0) {\n          \n          \n            \n                    if (first != null && first > 0) {", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500260315", "createdAt": "2020-10-06T13:07:31Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI2MDczOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (first != null && first >= 0) {\n          \n          \n            \n                    if (first != null && first > 0) {", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500260739", "createdAt": "2020-10-06T13:08:10Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        realm.removeDefaultRoles(role.getName());\n+        \n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                .filter(pair -> role.equals(pair.getV()))\n+                .collect(Collectors.toSet())\n+                .forEach(pair -> pair.getK().removeCompositeRole(role));\n+        }\n+        \n+        //remove role from client-roles composites\n+        session.clients().getClientsStream(realm).forEach(client -> {\n+            client.deleteScopeMapping(role);\n+            client.removeDefaultRoles(role.getName());\n+            try (Stream<RoleModel> baseStream = getClientRolesStream(client).filter(RoleModel::isComposite)) {\n+                StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                    .filter(pair -> role.equals(pair.getV()))\n+                    .collect(Collectors.toSet())\n+                    .forEach(pair -> pair.getK().removeCompositeRole(role));\n+            }\n+        });\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish(new RoleContainerModel.RoleRemovedEvent() {\n+            @Override\n+            public RoleModel getRole() {\n+                return role;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        });\n+        // TODO: ^^^^^^^ Up to here\n+\n+        tx.remove(UUID.fromString(role.getId()));\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public void removeRoles(RealmModel realm) {\n+        getRealmRolesStream(realm).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public void removeRoles(ClientModel client) {\n+        getClientRolesStream(client).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public RoleModel getRealmRole(RealmModel realm, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getRealmRole(%s, %s)%s\", realm, name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(realm))\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public RoleModel getClientRole(ClientModel client, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getClientRole(%s, %s)%s\", client, name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(client.getRealm()))\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public RoleModel getRoleById(RealmModel realm, String id) {\n+        if (id == null) {\n+            return null;\n+        }\n+\n+        LOG.tracef(\"getRoleById(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        MapRoleEntity entity = tx.get(UUID.fromString(id), roleStore::get);\n+        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+          ? null\n+          : entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> searchForRolesStream(RealmModel realm, String search, Integer first, Integer max) {\n+        if (search == null) {\n+            return Stream.empty();\n+        }\n+        String searchLower = search.toLowerCase();\n+        Stream<MapRoleEntity> s = getNotRemovedUpdatedRolesStream()\n+            .filter(entityRealmFilter(realm))\n+            .filter(entity -> \n+                (entity.getName() != null && entity.getName().toLowerCase().contains(searchLower)) || \n+                (entity.getDescription() != null && entity.getDescription().toLowerCase().contains(searchLower))\n+            )\n+            .sorted(COMPARE_BY_NAME);\n+\n+        if (first != null && first >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI2MDg2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (first != null && first >= 0) {\n          \n          \n            \n                    if (first != null && first > 0) {", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500260863", "createdAt": "2020-10-06T13:08:21Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        realm.removeDefaultRoles(role.getName());\n+        \n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                .filter(pair -> role.equals(pair.getV()))\n+                .collect(Collectors.toSet())\n+                .forEach(pair -> pair.getK().removeCompositeRole(role));\n+        }\n+        \n+        //remove role from client-roles composites\n+        session.clients().getClientsStream(realm).forEach(client -> {\n+            client.deleteScopeMapping(role);\n+            client.removeDefaultRoles(role.getName());\n+            try (Stream<RoleModel> baseStream = getClientRolesStream(client).filter(RoleModel::isComposite)) {\n+                StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                    .filter(pair -> role.equals(pair.getV()))\n+                    .collect(Collectors.toSet())\n+                    .forEach(pair -> pair.getK().removeCompositeRole(role));\n+            }\n+        });\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish(new RoleContainerModel.RoleRemovedEvent() {\n+            @Override\n+            public RoleModel getRole() {\n+                return role;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        });\n+        // TODO: ^^^^^^^ Up to here\n+\n+        tx.remove(UUID.fromString(role.getId()));\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public void removeRoles(RealmModel realm) {\n+        getRealmRolesStream(realm).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public void removeRoles(ClientModel client) {\n+        getClientRolesStream(client).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public RoleModel getRealmRole(RealmModel realm, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getRealmRole(%s, %s)%s\", realm, name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(realm))\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public RoleModel getClientRole(ClientModel client, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getClientRole(%s, %s)%s\", client, name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(client.getRealm()))\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public RoleModel getRoleById(RealmModel realm, String id) {\n+        if (id == null) {\n+            return null;\n+        }\n+\n+        LOG.tracef(\"getRoleById(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        MapRoleEntity entity = tx.get(UUID.fromString(id), roleStore::get);\n+        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+          ? null\n+          : entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> searchForRolesStream(RealmModel realm, String search, Integer first, Integer max) {\n+        if (search == null) {\n+            return Stream.empty();\n+        }\n+        String searchLower = search.toLowerCase();\n+        Stream<MapRoleEntity> s = getNotRemovedUpdatedRolesStream()\n+            .filter(entityRealmFilter(realm))\n+            .filter(entity -> \n+                (entity.getName() != null && entity.getName().toLowerCase().contains(searchLower)) || \n+                (entity.getDescription() != null && entity.getDescription().toLowerCase().contains(searchLower))\n+            )\n+            .sorted(COMPARE_BY_NAME);\n+\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+\n+        return s.map(entityToAdapterFunc(realm));\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> searchForClientRolesStream(ClientModel client, String search, Integer first, Integer max) {\n+        if (search == null) {\n+            return Stream.empty();\n+        }\n+        String searchLower = search.toLowerCase();\n+        Stream<MapRoleEntity> s = getNotRemovedUpdatedRolesStream()\n+            .filter(entityRealmFilter(client.getRealm()))\n+            .filter(entityClientFilter(client))\n+            .filter(entity -> \n+                (entity.getName() != null && entity.getName().toLowerCase().contains(searchLower)) || \n+                (entity.getDescription() != null && entity.getDescription().toLowerCase().contains(searchLower))\n+            )\n+            .sorted(COMPARE_BY_NAME);\n+\n+        if (first != null && first >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e"}, "originalPosition": 331}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/f669ad6e428e45a08896d0dafbbc800de7ec7c4e", "committedDate": "2020-10-05T18:33:40Z", "message": "KEYCLOAK-14977 TO BE REVERTED - make keycloak.role.provider=map"}, "afterCommit": {"oid": "78794c591f81f4b63b84105725fc1dddd167f750", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/78794c591f81f4b63b84105725fc1dddd167f750", "committedDate": "2020-10-21T07:33:55Z", "message": "KEYCLOAK-14977 fixes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8b53763afc98bb74894f5c9325a5b190b1bbdffb", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/8b53763afc98bb74894f5c9325a5b190b1bbdffb", "committedDate": "2020-10-21T07:42:12Z", "message": "KEYCLOAK-14977 fixes"}, "afterCommit": {"oid": "99b7d897c8cb54e060bf7671409ef6f0b160624f", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/99b7d897c8cb54e060bf7671409ef6f0b160624f", "committedDate": "2020-10-21T13:36:53Z", "message": "KEYCLOAK-14977 fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2NzEyODYy", "url": "https://github.com/keycloak/keycloak/pull/7444#pullrequestreview-516712862", "createdAt": "2020-10-26T12:07:29Z", "commit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjowNzoyOVrOHoMljw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMzoyMDo1NFrOHoPI6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMTMxMQ==", "bodyText": "We can remove EntityManager parameter since it is not static anymore.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511911311", "createdAt": "2020-10-26T12:07:29Z", "author": {"login": "mhajas"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RoleAdapter.java", "diffHunk": "@@ -214,7 +201,7 @@ public int hashCode() {\n         return getId().hashCode();\n     }\n \n-    public static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {\n+    private RoleEntity toRoleEntity(RoleModel model, EntityManager em) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNDM0MQ==", "bodyText": "Should this be String instead of K? Just wondering if it is possible to have a composite role with roles from some external RoleProvider. Therefore the role id would be something like f:......... Is it possible?", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511914341", "createdAt": "2020-10-26T12:13:40Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/AbstractRoleEntity.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.role;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.keycloak.models.map.common.AbstractEntity;\n+\n+public abstract class AbstractRoleEntity<K> implements AbstractEntity<K> {\n+\n+    private K id;\n+    private String realmId;\n+\n+    private String name;\n+    private String description;\n+    private boolean clientRole;\n+    private String clientId;\n+    private Set<K> compositeRoles = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkyOTcxOA==", "bodyText": "Does this make sense?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.updated = true;\n          \n          \n            \n                    this.updated |= !Objects.equals(this.attributes.put(name, values), values);", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511929718", "createdAt": "2020-10-26T12:41:47Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/AbstractRoleEntity.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.role;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.keycloak.models.map.common.AbstractEntity;\n+\n+public abstract class AbstractRoleEntity<K> implements AbstractEntity<K> {\n+\n+    private K id;\n+    private String realmId;\n+\n+    private String name;\n+    private String description;\n+    private boolean clientRole;\n+    private String clientId;\n+    private Set<K> compositeRoles = new HashSet<>();\n+    private Map<String, List<String>> attributes = new HashMap<>();\n+\n+    /**\n+     * Flag signalizing that any of the setters has been meaningfully used.\n+     */\n+    protected boolean updated;\n+\n+    protected AbstractRoleEntity() {\n+        this.id = null;\n+        this.realmId = null;\n+    }\n+\n+    public AbstractRoleEntity(K id, String realmId) {\n+        Objects.requireNonNull(id, \"id\");\n+        Objects.requireNonNull(realmId, \"realmId\");\n+\n+        this.id = id;\n+        this.realmId = realmId;\n+    }\n+\n+    @Override\n+    public K getId() {\n+        return this.id;\n+    }\n+\n+    @Override\n+    public boolean isUpdated() {\n+        return this.updated;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.updated |= ! Objects.equals(this.name, name);\n+        this.name = name;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(String description) {\n+        this.updated |= ! Objects.equals(this.description, description);\n+        this.description = description;\n+    }\n+\n+    public Map<String, List<String>> getAttributes() {\n+        return attributes;\n+    }\n+\n+    public void setAttributes(Map<String, List<String>> attributes) {\n+        this.updated |= ! Objects.equals(this.attributes, attributes);\n+        this.attributes = attributes;\n+    }\n+\n+    public void setAttribute(String name, List<String> values) {\n+        this.updated = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzNTk4Mw==", "bodyText": "Missing exception message.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511935983", "createdAt": "2020-10-26T12:52:52Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzNjA0NQ==", "bodyText": "Missing exception message.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511936045", "createdAt": "2020-10-26T12:53:01Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        if (getClientRole(client, name) != null) {\n+            throw new ModelDuplicateException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzODYxOQ==", "bodyText": "Each call to this function is followed by filtering by realm. There could be an other function with realm filtering or it can be added to this one.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511938619", "createdAt": "2020-10-26T12:57:17Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0NTEwOQ==", "bodyText": "Should we create RoleModel for each entity? We can work with entities and then turn to model only those that need to be updated (so that we add entities to transaction). Or we can maybe get rid of models here completely and work with entities only. Because if I see correctly, the MapRoleAdapter just call an operation on the entity. WDYT? @hmlnarik Maybe you could have also something to say to this.\nI am asking also because I am doing something similar for users, so if it is incorrect I need to make few changes.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511945109", "createdAt": "2020-10-26T13:08:37Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        if (getClientRole(client, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first > 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        RoleContainerModel container = role.getContainer();\n+        if (container.getDefaultRolesStream().anyMatch(r -> Objects.equals(r, role.getName()))) {\n+            container.removeDefaultRoles(role.getName());\n+        }\n+\n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0OTQ2NA==", "bodyText": "The same here.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511949464", "createdAt": "2020-10-26T13:15:27Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        if (getClientRole(client, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first > 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        RoleContainerModel container = role.getContainer();\n+        if (container.getDefaultRolesStream().anyMatch(r -> Objects.equals(r, role.getName()))) {\n+            container.removeDefaultRoles(role.getName());\n+        }\n+\n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                .filter(pair -> role.equals(pair.getV()))\n+                .collect(Collectors.toSet())\n+                .forEach(pair -> pair.getK().removeCompositeRole(role));\n+        }\n+\n+        //remove role from client-roles composites\n+        session.clients().getClientsStream(realm).forEach(client -> {\n+            client.deleteScopeMapping(role);\n+            try (Stream<RoleModel> baseStream = getClientRolesStream(client).filter(RoleModel::isComposite)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1MjgwNw==", "bodyText": "Replace with method reference", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511952807", "createdAt": "2020-10-26T13:20:28Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        if (getClientRole(client, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first > 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        RoleContainerModel container = role.getContainer();\n+        if (container.getDefaultRolesStream().anyMatch(r -> Objects.equals(r, role.getName()))) {\n+            container.removeDefaultRoles(role.getName());\n+        }\n+\n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                .filter(pair -> role.equals(pair.getV()))\n+                .collect(Collectors.toSet())\n+                .forEach(pair -> pair.getK().removeCompositeRole(role));\n+        }\n+\n+        //remove role from client-roles composites\n+        session.clients().getClientsStream(realm).forEach(client -> {\n+            client.deleteScopeMapping(role);\n+            try (Stream<RoleModel> baseStream = getClientRolesStream(client).filter(RoleModel::isComposite)) {\n+                StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                    .filter(pair -> role.equals(pair.getV()))\n+                    .collect(Collectors.toSet())\n+                    .forEach(pair -> pair.getK().removeCompositeRole(role));\n+            }\n+        });\n+        session.groups().preRemove(realm, role);\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish(new RoleContainerModel.RoleRemovedEvent() {\n+            @Override\n+            public RoleModel getRole() {\n+                return role;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        });\n+        // TODO: ^^^^^^^ Up to here\n+\n+        tx.remove(UUID.fromString(role.getId()));\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public void removeRoles(RealmModel realm) {\n+        getRealmRolesStream(realm).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public void removeRoles(ClientModel client) {\n+        getClientRolesStream(client).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public RoleModel getRealmRole(RealmModel realm, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getRealmRole(%s, %s)%s\", realm.getName(), name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        String roleId = getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(realm))\n+                .map(entity -> entity.getId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1MzEyOA==", "bodyText": "Replace with method reference.", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511953128", "createdAt": "2020-10-26T13:20:54Z", "author": {"login": "mhajas"}, "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        if (getClientRole(client, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first > 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        RoleContainerModel container = role.getContainer();\n+        if (container.getDefaultRolesStream().anyMatch(r -> Objects.equals(r, role.getName()))) {\n+            container.removeDefaultRoles(role.getName());\n+        }\n+\n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                .filter(pair -> role.equals(pair.getV()))\n+                .collect(Collectors.toSet())\n+                .forEach(pair -> pair.getK().removeCompositeRole(role));\n+        }\n+\n+        //remove role from client-roles composites\n+        session.clients().getClientsStream(realm).forEach(client -> {\n+            client.deleteScopeMapping(role);\n+            try (Stream<RoleModel> baseStream = getClientRolesStream(client).filter(RoleModel::isComposite)) {\n+                StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                    .filter(pair -> role.equals(pair.getV()))\n+                    .collect(Collectors.toSet())\n+                    .forEach(pair -> pair.getK().removeCompositeRole(role));\n+            }\n+        });\n+        session.groups().preRemove(realm, role);\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish(new RoleContainerModel.RoleRemovedEvent() {\n+            @Override\n+            public RoleModel getRole() {\n+                return role;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        });\n+        // TODO: ^^^^^^^ Up to here\n+\n+        tx.remove(UUID.fromString(role.getId()));\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public void removeRoles(RealmModel realm) {\n+        getRealmRolesStream(realm).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public void removeRoles(ClientModel client) {\n+        getClientRolesStream(client).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public RoleModel getRealmRole(RealmModel realm, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getRealmRole(%s, %s)%s\", realm.getName(), name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        String roleId = getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(realm))\n+                .map(entity -> entity.getId())\n+                .findFirst()\n+                .orElse(null);\n+        //we need to go via session.roles() not to bypass cache\n+        return roleId == null ? null : session.roles().getRoleById(realm, roleId);\n+    }\n+\n+    @Override\n+    public RoleModel getClientRole(ClientModel client, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getClientRole(%s, %s)%s\", client.getClientId(), name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        String roleId = getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(client.getRealm()))\n+                .map(entity -> entity.getId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884f3011ecd10bf7cb45e6cc925feefce588f25f"}, "originalPosition": 288}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cd0f186ce2d1c9245581472efa55f178febb971f", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/cd0f186ce2d1c9245581472efa55f178febb971f", "committedDate": "2020-10-27T21:21:32Z", "message": "KEYCLOAK-14977 address comments - part3 - final"}, "afterCommit": {"oid": "e6be5a0340b6db0f0e87480185f9ef47663c27eb", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/e6be5a0340b6db0f0e87480185f9ef47663c27eb", "committedDate": "2020-10-27T21:42:58Z", "message": "KEYCLOAK-14977 address comments - part3 - final"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6be5a0340b6db0f0e87480185f9ef47663c27eb", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/e6be5a0340b6db0f0e87480185f9ef47663c27eb", "committedDate": "2020-10-27T21:42:58Z", "message": "KEYCLOAK-14977 address comments - part3 - final"}, "afterCommit": {"oid": "1198b340c7780ac7543be054cc9447f0d3146c08", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/1198b340c7780ac7543be054cc9447f0d3146c08", "committedDate": "2020-10-27T21:45:02Z", "message": "KEYCLOAK-14977 address comments - part3 - final"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5Nzc1NzU4", "url": "https://github.com/keycloak/keycloak/pull/7444#pullrequestreview-519775758", "createdAt": "2020-10-29T15:15:29Z", "commit": {"oid": "1198b340c7780ac7543be054cc9447f0d3146c08"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f7d8417118e87dd8318224267d05ac67c6c01b8", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/5f7d8417118e87dd8318224267d05ac67c6c01b8", "committedDate": "2020-10-29T19:02:51Z", "message": "KEYCLOAK-14977 create MapRoleProvider"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1198b340c7780ac7543be054cc9447f0d3146c08", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/1198b340c7780ac7543be054cc9447f0d3146c08", "committedDate": "2020-10-27T21:45:02Z", "message": "KEYCLOAK-14977 address comments - part3 - final"}, "afterCommit": {"oid": "5f7d8417118e87dd8318224267d05ac67c6c01b8", "author": {"user": {"login": "vramik", "name": "Vlasta Ramik"}}, "url": "https://github.com/keycloak/keycloak/commit/5f7d8417118e87dd8318224267d05ac67c6c01b8", "committedDate": "2020-10-29T19:02:51Z", "message": "KEYCLOAK-14977 create MapRoleProvider"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNDE5NzYx", "url": "https://github.com/keycloak/keycloak/pull/7444#pullrequestreview-520419761", "createdAt": "2020-10-30T07:14:01Z", "commit": {"oid": "5f7d8417118e87dd8318224267d05ac67c6c01b8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3428, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}