{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5NTY1NDg3", "number": 7599, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNToxMjo0OVrOE4tDaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODo1MDo0M1rOFAsTQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODkzODY1OnYy", "diffSide": "RIGHT", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNToxMjo0OVrOHyyLoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1OToyNVrOH58cww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAxMzAyNQ==", "bodyText": "Maybe we could keep stream here and pass it to UserFullInvalidationEvent.create while replacing for loop with stream processing inside the method.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r523013025", "createdAt": "2020-11-13T15:12:49Z", "author": {"login": "martin-kanis"}, "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -796,7 +792,8 @@ public UserModel addUser(RealmModel realm, String username) {\n \n     // just in case the transaction is rolled back you need to invalidate the user and all cache queries for that user\n     protected void fullyInvalidateUser(RealmModel realm, UserModel user) {\n-        Set<FederatedIdentityModel> federatedIdentities = realm.isIdentityFederationEnabled() ? getFederatedIdentities(user, realm) : null;\n+        Set<FederatedIdentityModel> federatedIdentities = realm.isIdentityFederationEnabled() ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMTI4Mw==", "bodyText": "Good suggestion, changed", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530521283", "createdAt": "2020-11-25T16:59:25Z", "author": {"login": "sguilhen"}, "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -796,7 +792,8 @@ public UserModel addUser(RealmModel realm, String username) {\n \n     // just in case the transaction is rolled back you need to invalidate the user and all cache queries for that user\n     protected void fullyInvalidateUser(RealmModel realm, UserModel user) {\n-        Set<FederatedIdentityModel> federatedIdentities = realm.isIdentityFederationEnabled() ? getFederatedIdentities(user, realm) : null;\n+        Set<FederatedIdentityModel> federatedIdentities = realm.isIdentityFederationEnabled() ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAxMzAyNQ=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODk5NTQxOnYy", "diffSide": "RIGHT", "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNToyNTo0N1rOHyyt6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzozMDoyOVrOH6biBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyMTgwMg==", "bodyText": "This part confuses me little bit. We wanted to keep original collection based methods in UserCredentialStore and deprecate those in UserFederatedUserCredentialStore?\nI know we had some discussion around this but I don't remember exact outcome.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r523021802", "createdAt": "2020-11-13T15:25:47Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -691,12 +691,12 @@ public CredentialModel getStoredCredentialById(RealmModel realm, UserModel user,\n \n     @Override\n     public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        return getStoredCredentials(realm, user.getId());\n+        return getStoredCredentialsStream(realm, user.getId()).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNjM4MA==", "bodyText": "The other way around - things in the federated package need to preserve the original collection-based methods.\nThe original PR that introduced the streams for User interfaces ended up changing the interfaces in the federated package (as they are tightly related) but it didn't touch the UserCredentialStore, this is why this particular method hasn't been updated yet. Once we streamify UserCredentialStore it will be replaced with the Stream-based implementation.\nIf you feel like UserCredentialStore should be changed as well as part of this work I can change this PR to include the its streamification and change everything at once.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530526380", "createdAt": "2020-11-25T17:07:44Z", "author": {"login": "sguilhen"}, "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -691,12 +691,12 @@ public CredentialModel getStoredCredentialById(RealmModel realm, UserModel user,\n \n     @Override\n     public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        return getStoredCredentials(realm, user.getId());\n+        return getStoredCredentialsStream(realm, user.getId()).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyMTgwMg=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAzMDUzMw==", "bodyText": "Update: for consistency I've decided to streamify the UserCredentialStore and UserCredentialManager interfaces as part of this work (see second commit in this PR).", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r531030533", "createdAt": "2020-11-26T13:30:29Z", "author": {"login": "sguilhen"}, "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -691,12 +691,12 @@ public CredentialModel getStoredCredentialById(RealmModel realm, UserModel user,\n \n     @Override\n     public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        return getStoredCredentials(realm, user.getId());\n+        return getStoredCredentialsStream(realm, user.getId()).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyMTgwMg=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTAyMzQyOnYy", "diffSide": "RIGHT", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/UserAttributeLDAPStorageMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNTozMjoyOFrOHyy-2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzowOTowOFrOH580GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNjEzOA==", "bodyText": "It's not your change but maybe worth to use isEmpty().", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r523026138", "createdAt": "2020-11-13T15:32:28Z", "author": {"login": "martin-kanis"}, "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/UserAttributeLDAPStorageMapper.java", "diffHunk": "@@ -121,13 +122,13 @@ public void onRegisterUserToLDAP(LDAPObject ldapUser, UserModel localUser, Realm\n         } else {\n \n             // we don't have java property. Let's set attribute\n-            List<String> attrValues = localUser.getAttribute(userModelAttrName);\n+            List<String> attrValues = localUser.getAttributeStream(userModelAttrName).collect(Collectors.toList());\n \n             if (attrValues.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNzI1Nw==", "bodyText": "Yeah, changing.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530527257", "createdAt": "2020-11-25T17:09:08Z", "author": {"login": "sguilhen"}, "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/UserAttributeLDAPStorageMapper.java", "diffHunk": "@@ -121,13 +122,13 @@ public void onRegisterUserToLDAP(LDAPObject ldapUser, UserModel localUser, Realm\n         } else {\n \n             // we don't have java property. Let's set attribute\n-            List<String> attrValues = localUser.getAttribute(userModelAttrName);\n+            List<String> attrValues = localUser.getAttributeStream(userModelAttrName).collect(Collectors.toList());\n \n             if (attrValues.size() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNjEzOA=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzI3NTM5OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwODozMjoxNFrOH1iXFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzoxMDo0MFrOH584Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg5OTU0Mw==", "bodyText": "users != null can be omitted. Same in the return statement.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525899543", "createdAt": "2020-11-18T08:32:14Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java", "diffHunk": "@@ -61,14 +62,14 @@ public UserModel find(AuthenticationFlowContext context, Object userIdentity) th\n             if (_customAttributes.isEmpty() || userIdentityValues.isEmpty() || (_customAttributes.size() != userIdentityValues.size())) {\n                 return null;\n             }\n-            List<UserModel> users = session.users().searchForUserByUserAttribute(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n+            Stream<UserModel> usersStream = session.users().searchForUserByUserAttributeStream(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n             \n             for (int i = 1; i <_customAttributes.size(); ++i) {\n                 String customAttribute = _customAttributes.get(i);\n                 String userIdentityValue = userIdentityValues.get(i);\n-                \n-                users = users.stream().filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue)).collect(Collectors.toList());\n+                usersStream = usersStream.filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue));\n             }\n+            List<UserModel> users = usersStream.collect(Collectors.toList());\n             if (users != null && users.size() > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyODI4Ng==", "bodyText": "Good catch", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530528286", "createdAt": "2020-11-25T17:10:40Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java", "diffHunk": "@@ -61,14 +62,14 @@ public UserModel find(AuthenticationFlowContext context, Object userIdentity) th\n             if (_customAttributes.isEmpty() || userIdentityValues.isEmpty() || (_customAttributes.size() != userIdentityValues.size())) {\n                 return null;\n             }\n-            List<UserModel> users = session.users().searchForUserByUserAttribute(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n+            Stream<UserModel> usersStream = session.users().searchForUserByUserAttributeStream(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n             \n             for (int i = 1; i <_customAttributes.size(); ++i) {\n                 String customAttribute = _customAttributes.get(i);\n                 String userIdentityValue = userIdentityValues.get(i);\n-                \n-                users = users.stream().filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue)).collect(Collectors.toList());\n+                usersStream = usersStream.filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue));\n             }\n+            List<UserModel> users = usersStream.collect(Collectors.toList());\n             if (users != null && users.size() > 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg5OTU0Mw=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzMyNzg1OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/authentication/requiredactions/util/UserUpdateProfileContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwODo0NTo1MFrOH1i3dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzozNjozM1rOH59zWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkwNzgzMQ==", "bodyText": "I think this method and all its usages are worth to \"streamify\".", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525907831", "createdAt": "2020-11-18T08:45:50Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/authentication/requiredactions/util/UserUpdateProfileContext.java", "diffHunk": "@@ -103,6 +104,6 @@ public String getFirstAttribute(String name) {\n \n     @Override\n     public List<String> getAttribute(String key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0MzQ1MA==", "bodyText": "Working on it", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530543450", "createdAt": "2020-11-25T17:36:33Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/authentication/requiredactions/util/UserUpdateProfileContext.java", "diffHunk": "@@ -103,6 +104,6 @@ public String getFirstAttribute(String name) {\n \n     @Override\n     public List<String> getAttribute(String key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkwNzgzMQ=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzQyMzkwOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/AccountFederatedIdentityBean.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTowOToyNFrOH1jylQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0NjowN1rOH5-I4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkyMjk2NQ==", "bodyText": "Here can you confirm my assumption the cached version of getFederatedIdentitiesStream(user, realm) will be used to prevent multiple database calls?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525922965", "createdAt": "2020-11-18T09:09:24Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/AccountFederatedIdentityBean.java", "diffHunk": "@@ -47,15 +48,13 @@\n     public AccountFederatedIdentityBean(KeycloakSession session, RealmModel realm, UserModel user, URI baseUri, String stateChecker) {\n         this.session = session;\n \n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n-\n         AtomicInteger availableIdentities = new AtomicInteger(0);\n         this.identities = realm.getIdentityProvidersStream()\n                 .filter(IdentityProviderModel::isEnabled)\n                 .map(provider -> {\n                     String providerId = provider.getAlias();\n \n-                    FederatedIdentityModel identity = getIdentity(identities, providerId);\n+                    FederatedIdentityModel identity = getIdentity(session.users().getFederatedIdentitiesStream(user, realm), providerId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0ODk2Mg==", "bodyText": "I believe it is the version that goes through UserCacheSession, so it should be cached. The session.users() implementation tries to obtain the UserCache provider first and if it exists it returns the cached version, otherwise the UserStorageManager is returned.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530548962", "createdAt": "2020-11-25T17:46:07Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/AccountFederatedIdentityBean.java", "diffHunk": "@@ -47,15 +48,13 @@\n     public AccountFederatedIdentityBean(KeycloakSession session, RealmModel realm, UserModel user, URI baseUri, String stateChecker) {\n         this.session = session;\n \n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n-\n         AtomicInteger availableIdentities = new AtomicInteger(0);\n         this.identities = realm.getIdentityProvidersStream()\n                 .filter(IdentityProviderModel::isEnabled)\n                 .map(provider -> {\n                     String providerId = provider.getAlias();\n \n-                    FederatedIdentityModel identity = getIdentity(identities, providerId);\n+                    FederatedIdentityModel identity = getIdentity(session.users().getFederatedIdentitiesStream(user, realm), providerId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkyMjk2NQ=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzQ1MTI5OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOToxNTo1MVrOH1kDlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzo0MzozOVrOH5-DCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkyNzMxNg==", "bodyText": "This could be probably slightly changed to use map + collect instead of foreach.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525927316", "createdAt": "2020-11-18T09:15:51Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java", "diffHunk": "@@ -52,10 +51,9 @@\n     public ApplicationsBean(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        for (ClientModel client : getApplications(session, realm, user)) {\n-            if (isAdminClient(client) && ! AdminPermissions.realms(session, realm, user).isAdmin()) {\n-                continue;\n-            }\n+        this.getApplications(session, realm, user)\n+                .filter(client -> !isAdminClient(client) || AdminPermissions.realms(session, realm, user).isAdmin())\n+                .forEach(client -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0NzQ2Ng==", "bodyText": "+1", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530547466", "createdAt": "2020-11-25T17:43:39Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java", "diffHunk": "@@ -52,10 +51,9 @@\n     public ApplicationsBean(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        for (ClientModel client : getApplications(session, realm, user)) {\n-            if (isAdminClient(client) && ! AdminPermissions.realms(session, realm, user).isAdmin()) {\n-                continue;\n-            }\n+        this.getApplications(session, realm, user)\n+                .filter(client -> !isAdminClient(client) || AdminPermissions.realms(session, realm, user).isAdmin())\n+                .forEach(client -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkyNzMxNg=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzU3NzgyOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo0NToxOVrOH1lRUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODowMTowNVrOH5-pWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0NzIxNw==", "bodyText": "Maybe you can do similar thing which you did in one of the previous classes? toLinkedAccountRepresentation(provider, socialIds, session.users().getFederatedIdentitiesStream(user, realm)); + rewrite getIdentity method to accept a stream.  But only if the same predicate about caching is valid to avoid performance degradation.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525947217", "createdAt": "2020-11-18T09:45:19Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java", "diffHunk": "@@ -110,7 +111,8 @@ public Response linkedAccounts() {\n \n     public SortedSet<LinkedAccountRepresentation> getLinkedAccounts(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<String> socialIds = findSocialIds();\n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n+        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentitiesStream(user, realm)\n+                .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1NzI3Mg==", "bodyText": "That's a good suggestion, makes this code a little bit simpler. Implementing it.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530557272", "createdAt": "2020-11-25T18:01:05Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java", "diffHunk": "@@ -110,7 +111,8 @@ public Response linkedAccounts() {\n \n     public SortedSet<LinkedAccountRepresentation> getLinkedAccounts(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<String> socialIds = findSocialIds();\n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n+        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentitiesStream(user, realm)\n+                .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0NzIxNw=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODQ5MTA3OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMzozMzowOVrOH1t-XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODowMzowOVrOH5-tQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA4OTgyMQ==", "bodyText": "Not needed", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r526089821", "createdAt": "2020-11-18T13:33:09Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "diffHunk": "@@ -358,30 +358,24 @@ public UserRepresentation getUser() {\n     /**\n      * Get social logins associated with the user\n      *\n-     * @return\n+     * @return a non-null {@code Stream} of social logins (federated identities).\n      */\n     @Path(\"federated-identity\")\n     @GET\n     @NoCache\n     @Produces(MediaType.APPLICATION_JSON)\n-    public List<FederatedIdentityRepresentation> getFederatedIdentity() {\n+    public Stream<FederatedIdentityRepresentation> getFederatedIdentity() {\n         auth.users().requireView(user);\n-\n         return getFederatedIdentities(user);\n     }\n \n-    private List<FederatedIdentityRepresentation> getFederatedIdentities(UserModel user) {\n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n-        List<FederatedIdentityRepresentation> result = new ArrayList<FederatedIdentityRepresentation>();\n+    private Stream<FederatedIdentityRepresentation> getFederatedIdentities(UserModel user) {\n         Set<String> idps = realm.getIdentityProvidersStream().map(IdentityProviderModel::getAlias).collect(Collectors.toSet());\n+        List<FederatedIdentityRepresentation> result = new ArrayList<FederatedIdentityRepresentation>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU1ODI3Mg==", "bodyText": "Oops, forgot to clean this up.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530558272", "createdAt": "2020-11-25T18:03:09Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "diffHunk": "@@ -358,30 +358,24 @@ public UserRepresentation getUser() {\n     /**\n      * Get social logins associated with the user\n      *\n-     * @return\n+     * @return a non-null {@code Stream} of social logins (federated identities).\n      */\n     @Path(\"federated-identity\")\n     @GET\n     @NoCache\n     @Produces(MediaType.APPLICATION_JSON)\n-    public List<FederatedIdentityRepresentation> getFederatedIdentity() {\n+    public Stream<FederatedIdentityRepresentation> getFederatedIdentity() {\n         auth.users().requireView(user);\n-\n         return getFederatedIdentities(user);\n     }\n \n-    private List<FederatedIdentityRepresentation> getFederatedIdentities(UserModel user) {\n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n-        List<FederatedIdentityRepresentation> result = new ArrayList<FederatedIdentityRepresentation>();\n+    private Stream<FederatedIdentityRepresentation> getFederatedIdentities(UserModel user) {\n         Set<String> idps = realm.getIdentityProvidersStream().map(IdentityProviderModel::getAlias).collect(Collectors.toSet());\n+        List<FederatedIdentityRepresentation> result = new ArrayList<FederatedIdentityRepresentation>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA4OTgyMQ=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODUxNjkwOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMzozOToyM1rOH1uN-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODowNjozOFrOH5-0Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA5MzgxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    models.forEach(c -> c.setSecretData(null));\n          \n          \n            \n                    return session.userCredentialManager().getStoredCredentials(realm, user)\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .peek(c -> c.setSecretData(null))\n          \n          \n            \n                            .map(ModelToRepresentation::toRepresentation);", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r526093819", "createdAt": "2020-11-18T13:39:23Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "diffHunk": "@@ -607,11 +600,11 @@ public void resetPassword(CredentialRepresentation cred) {\n     @Path(\"credentials\")\n     @NoCache\n     @Produces(MediaType.APPLICATION_JSON)\n-    public List<CredentialRepresentation> credentials(){\n+    public Stream<CredentialRepresentation> credentials(){\n         auth.users().requireManage(user);\n         List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);\n         models.forEach(c -> c.setSecretData(null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU2MDA2Ng==", "bodyText": "Great point, I completely missed the opportunity to rewrite the logic here.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r530560066", "createdAt": "2020-11-25T18:06:38Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "diffHunk": "@@ -607,11 +600,11 @@ public void resetPassword(CredentialRepresentation cred) {\n     @Path(\"credentials\")\n     @NoCache\n     @Produces(MediaType.APPLICATION_JSON)\n-    public List<CredentialRepresentation> credentials(){\n+    public Stream<CredentialRepresentation> credentials(){\n         auth.users().requireManage(user);\n         List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);\n         models.forEach(c -> c.setSecretData(null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA5MzgxOQ=="}, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjM3NTc2OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzoxMjowNFrOH8FFmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyMjoyNFrOH8yDvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1OTk2MQ==", "bodyText": "Star import.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532759961", "createdAt": "2020-11-30T17:12:04Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java", "diffHunk": "@@ -21,6 +21,8 @@\n import java.security.MessageDigest;\n import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5Njc2NA==", "bodyText": "Thanks for spotting this", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533496764", "createdAt": "2020-12-01T15:22:24Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java", "diffHunk": "@@ -21,6 +21,8 @@\n import java.security.MessageDigest;\n import java.util.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1OTk2MQ=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjQ0MjIyOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzoyNzoxM1rOH8Fugw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyMjo1MlrOH8yFOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3MDQzNQ==", "bodyText": "Wouldn't be possible to extract this huge map body to a separate method for better readability?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532770435", "createdAt": "2020-11-30T17:27:13Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java", "diffHunk": "@@ -52,72 +52,64 @@\n     public ApplicationsBean(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        for (ClientModel client : getApplications(session, realm, user)) {\n-            if (isAdminClient(client) && ! AdminPermissions.realms(session, realm, user).isAdmin()) {\n-                continue;\n-            }\n-\n-            // Construct scope parameter with all optional scopes to see all potentially available roles\n-            Stream<ClientScopeModel> allClientScopes = Stream.concat(\n-                    client.getClientScopes(true, true).values().stream(),\n-                    client.getClientScopes(false, true).values().stream());\n-            allClientScopes = Stream.concat(allClientScopes, Stream.of(client)).distinct();\n-\n-            Set<RoleModel> availableRoles = TokenManager.getAccess(user, client, allClientScopes);\n-\n-            // Don't show applications, which user doesn't have access into (any available roles)\n-            // unless this is can be changed by approving/revoking consent\n-            if (! isAdminClient(client) && availableRoles.isEmpty() && ! client.isConsentRequired()) {\n-                continue;\n-            }\n-\n-            List<RoleModel> realmRolesAvailable = new LinkedList<>();\n-            MultivaluedHashMap<String, ClientRoleEntry> resourceRolesAvailable = new MultivaluedHashMap<>();\n-            processRoles(availableRoles, realmRolesAvailable, resourceRolesAvailable);\n-\n-            List<ClientScopeModel> orderedScopes = new LinkedList<>();\n-            if (client.isConsentRequired()) {\n-                UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n-\n-                if (consent != null) {\n-                    orderedScopes.addAll(consent.getGrantedClientScopes());\n-                }\n-            }\n-            List<String> clientScopesGranted = orderedScopes.stream()\n-                    .sorted(OrderedModel.OrderedModelComparator.getInstance())\n-                    .map(ClientScopeModel::getConsentScreenText)\n-                    .collect(Collectors.toList());\n-\n-            List<String> additionalGrants = new ArrayList<>();\n-            if (offlineClients.contains(client)) {\n-                additionalGrants.add(\"${offlineToken}\");\n-            }\n-\n-            applications.add(new ApplicationEntry(session, realmRolesAvailable, resourceRolesAvailable, client, clientScopesGranted, additionalGrants));\n-        }\n+        this.applications = this.getApplications(session, realm, user)\n+                .filter(client -> !isAdminClient(client) || AdminPermissions.realms(session, realm, user).isAdmin())\n+                .map(client -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NzE0NA==", "bodyText": "Yeah, I could do that.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533497144", "createdAt": "2020-12-01T15:22:52Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java", "diffHunk": "@@ -52,72 +52,64 @@\n     public ApplicationsBean(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        for (ClientModel client : getApplications(session, realm, user)) {\n-            if (isAdminClient(client) && ! AdminPermissions.realms(session, realm, user).isAdmin()) {\n-                continue;\n-            }\n-\n-            // Construct scope parameter with all optional scopes to see all potentially available roles\n-            Stream<ClientScopeModel> allClientScopes = Stream.concat(\n-                    client.getClientScopes(true, true).values().stream(),\n-                    client.getClientScopes(false, true).values().stream());\n-            allClientScopes = Stream.concat(allClientScopes, Stream.of(client)).distinct();\n-\n-            Set<RoleModel> availableRoles = TokenManager.getAccess(user, client, allClientScopes);\n-\n-            // Don't show applications, which user doesn't have access into (any available roles)\n-            // unless this is can be changed by approving/revoking consent\n-            if (! isAdminClient(client) && availableRoles.isEmpty() && ! client.isConsentRequired()) {\n-                continue;\n-            }\n-\n-            List<RoleModel> realmRolesAvailable = new LinkedList<>();\n-            MultivaluedHashMap<String, ClientRoleEntry> resourceRolesAvailable = new MultivaluedHashMap<>();\n-            processRoles(availableRoles, realmRolesAvailable, resourceRolesAvailable);\n-\n-            List<ClientScopeModel> orderedScopes = new LinkedList<>();\n-            if (client.isConsentRequired()) {\n-                UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n-\n-                if (consent != null) {\n-                    orderedScopes.addAll(consent.getGrantedClientScopes());\n-                }\n-            }\n-            List<String> clientScopesGranted = orderedScopes.stream()\n-                    .sorted(OrderedModel.OrderedModelComparator.getInstance())\n-                    .map(ClientScopeModel::getConsentScreenText)\n-                    .collect(Collectors.toList());\n-\n-            List<String> additionalGrants = new ArrayList<>();\n-            if (offlineClients.contains(client)) {\n-                additionalGrants.add(\"${offlineToken}\");\n-            }\n-\n-            applications.add(new ApplicationEntry(session, realmRolesAvailable, resourceRolesAvailable, client, clientScopesGranted, additionalGrants));\n-        }\n+        this.applications = this.getApplications(session, realm, user)\n+                .filter(client -> !isAdminClient(client) || AdminPermissions.realms(session, realm, user).isAdmin())\n+                .map(client -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3MDQzNQ=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjQ5ODAwOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzo0MDoxM1rOH8GQmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODo1Nzo1M1rOH87VFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTE2MQ==", "bodyText": "Will be the getDisableableCredentialTypes method streamified?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532779161", "createdAt": "2020-11-30T17:40:13Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -218,23 +218,20 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {\n+        Stream<String> types = Stream.empty();\n         String providerId = StorageId.isLocalStorage(user) ? user.getFederationLink() : StorageId.resolveProviderId(user);\n         if (providerId != null) {\n             UserStorageProviderModel model = getStorageProviderModel(realm, providerId);\n-            if (model == null || !model.isEnabled()) return Collections.EMPTY_SET;\n+            if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types.addAll(updater.getDisableableCredentialTypes(realm, user));\n+            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NzQ0MQ==", "bodyText": "It could, I thought about it at the time I was making this change. I'll re-evaluate.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533497441", "createdAt": "2020-12-01T15:23:15Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -218,23 +218,20 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {\n+        Stream<String> types = Stream.empty();\n         String providerId = StorageId.isLocalStorage(user) ? user.getFederationLink() : StorageId.resolveProviderId(user);\n         if (providerId != null) {\n             UserStorageProviderModel model = getStorageProviderModel(realm, providerId);\n-            if (model == null || !model.isEnabled()) return Collections.EMPTY_SET;\n+            if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types.addAll(updater.getDisableableCredentialTypes(realm, user));\n+            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTE2MQ=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0ODY2Mg==", "bodyText": "Done, it was indeed better to streamify this one as well.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533648662", "createdAt": "2020-12-01T18:57:53Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -218,23 +218,20 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {\n+        Stream<String> types = Stream.empty();\n         String providerId = StorageId.isLocalStorage(user) ? user.getFederationLink() : StorageId.resolveProviderId(user);\n         if (providerId != null) {\n             UserStorageProviderModel model = getStorageProviderModel(realm, providerId);\n-            if (model == null || !model.isEnabled()) return Collections.EMPTY_SET;\n+            if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types.addAll(updater.getDisableableCredentialTypes(realm, user));\n+            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTE2MQ=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjUwMjQ1OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzo0MToxMVrOH8GTRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyMzo1NVrOH8yIYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTg0NQ==", "bodyText": "Maybe distinct() is missing?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532779845", "createdAt": "2020-11-30T17:41:11Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -218,23 +218,20 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {\n+        Stream<String> types = Stream.empty();\n         String providerId = StorageId.isLocalStorage(user) ? user.getFederationLink() : StorageId.resolveProviderId(user);\n         if (providerId != null) {\n             UserStorageProviderModel model = getStorageProviderModel(realm, providerId);\n-            if (model == null || !model.isEnabled()) return Collections.EMPTY_SET;\n+            if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types.addAll(updater.getDisableableCredentialTypes(realm, user));\n+            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();\n         }\n \n-        types.addAll(getCredentialProviders(session, CredentialInputUpdater.class)\n+        return Stream.concat(types, getCredentialProviders(session, CredentialInputUpdater.class)\n                 .map(updater -> updater.getDisableableCredentialTypes(realm, user))\n-                .flatMap(Set::stream)\n-                .collect(Collectors.toSet()));\n-\n-        return types;\n+                .flatMap(Set::stream));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5Nzk1Mg==", "bodyText": "Will double check", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533497952", "createdAt": "2020-12-01T15:23:55Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -218,23 +218,20 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {\n+        Stream<String> types = Stream.empty();\n         String providerId = StorageId.isLocalStorage(user) ? user.getFederationLink() : StorageId.resolveProviderId(user);\n         if (providerId != null) {\n             UserStorageProviderModel model = getStorageProviderModel(realm, providerId);\n-            if (model == null || !model.isEnabled()) return Collections.EMPTY_SET;\n+            if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types.addAll(updater.getDisableableCredentialTypes(realm, user));\n+            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();\n         }\n \n-        types.addAll(getCredentialProviders(session, CredentialInputUpdater.class)\n+        return Stream.concat(types, getCredentialProviders(session, CredentialInputUpdater.class)\n                 .map(updater -> updater.getDisableableCredentialTypes(realm, user))\n-                .flatMap(Set::stream)\n-                .collect(Collectors.toSet()));\n-\n-        return types;\n+                .flatMap(Set::stream));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTg0NQ=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjYwNzk2OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODowNjozNVrOH8HTRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyMzozNVrOH8yHXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NjIyOA==", "bodyText": "Isn't the ConcurrentModificationException possible here?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532796228", "createdAt": "2020-11-30T18:06:35Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java", "diffHunk": "@@ -115,14 +116,11 @@ public CredentialModel createCredential(RealmModel realm, UserModel user, Passwo\n         }\n         \n         // 3) remove old password history items\n-        List<CredentialModel> passwordHistoryList = getCredentialStore().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n         final int passwordHistoryListMaxSize = Math.max(0, expiredPasswordsPolicyValue - 1);\n-        if (passwordHistoryList.size() > passwordHistoryListMaxSize) {\n-            passwordHistoryList.stream()\n-                    .sorted(CredentialModel.comparingByStartDateDesc())\n-                    .skip(passwordHistoryListMaxSize)\n-                    .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));\n-        }\n+        getCredentialStore().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY)\n+                .sorted(CredentialModel.comparingByStartDateDesc())\n+                .skip(passwordHistoryListMaxSize)\n+                .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NzY5Mg==", "bodyText": "Yes, thanks!", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533497692", "createdAt": "2020-12-01T15:23:35Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java", "diffHunk": "@@ -115,14 +116,11 @@ public CredentialModel createCredential(RealmModel realm, UserModel user, Passwo\n         }\n         \n         // 3) remove old password history items\n-        List<CredentialModel> passwordHistoryList = getCredentialStore().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n         final int passwordHistoryListMaxSize = Math.max(0, expiredPasswordsPolicyValue - 1);\n-        if (passwordHistoryList.size() > passwordHistoryListMaxSize) {\n-            passwordHistoryList.stream()\n-                    .sorted(CredentialModel.comparingByStartDateDesc())\n-                    .skip(passwordHistoryListMaxSize)\n-                    .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));\n-        }\n+        getCredentialStore().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY)\n+                .sorted(CredentialModel.comparingByStartDateDesc())\n+                .skip(passwordHistoryListMaxSize)\n+                .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NjIyOA=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjgyMTUxOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTowMToxOVrOH8JTLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyNDoxNVrOH8yJVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyODk3Mw==", "bodyText": "Rather use Objects.equals as it's null safe.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532828973", "createdAt": "2020-11-30T19:01:19Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java", "diffHunk": "@@ -61,18 +62,18 @@ public UserModel find(AuthenticationFlowContext context, Object userIdentity) th\n             if (_customAttributes.isEmpty() || userIdentityValues.isEmpty() || (_customAttributes.size() != userIdentityValues.size())) {\n                 return null;\n             }\n-            List<UserModel> users = session.users().searchForUserByUserAttribute(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n+            Stream<UserModel> usersStream = session.users().searchForUserByUserAttributeStream(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n             \n             for (int i = 1; i <_customAttributes.size(); ++i) {\n                 String customAttribute = _customAttributes.get(i);\n                 String userIdentityValue = userIdentityValues.get(i);\n-                \n-                users = users.stream().filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue)).collect(Collectors.toList());\n+                usersStream = usersStream.filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5ODE5OQ==", "bodyText": "Noted!", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533498199", "createdAt": "2020-12-01T15:24:15Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java", "diffHunk": "@@ -61,18 +62,18 @@ public UserModel find(AuthenticationFlowContext context, Object userIdentity) th\n             if (_customAttributes.isEmpty() || userIdentityValues.isEmpty() || (_customAttributes.size() != userIdentityValues.size())) {\n                 return null;\n             }\n-            List<UserModel> users = session.users().searchForUserByUserAttribute(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n+            Stream<UserModel> usersStream = session.users().searchForUserByUserAttributeStream(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n             \n             for (int i = 1; i <_customAttributes.size(); ++i) {\n                 String customAttribute = _customAttributes.get(i);\n                 String userIdentityValue = userIdentityValues.get(i);\n-                \n-                users = users.stream().filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue)).collect(Collectors.toList());\n+                usersStream = usersStream.filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyODk3Mw=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjg1ODM1OnYy", "diffSide": "RIGHT", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOToxMTowMFrOH8JpFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyNDoyM1rOH8yJwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDU4Mw==", "bodyText": "Rather use Objects.equals as it's null safe.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532834583", "createdAt": "2020-11-30T19:11:00Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentials(realm, user).stream().filter(credential -> type.equals(credential.getType())).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n+        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5ODMwNA==", "bodyText": "Noted!", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533498304", "createdAt": "2020-12-01T15:24:23Z", "author": {"login": "sguilhen"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentials(realm, user).stream().filter(credential -> type.equals(credential.getType())).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n+        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDU4Mw=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjg2MDI4OnYy", "diffSide": "RIGHT", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOToxMTozNVrOH8JqWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyNDowM1rOH8yIug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDkwNA==", "bodyText": "Again Objects.equals", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532834904", "createdAt": "2020-11-30T19:11:35Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentials(realm, user).stream().filter(credential -> type.equals(credential.getType())).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n+        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));\n     }\n \n     @Override\n     public CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserModel user, String name, String type) {\n-        List<CredentialModel> results = getStoredCredentials(realm, user).stream().filter(credential ->\n-                type.equals(credential.getType()) && name.equals(credential.getUserLabel())).collect(Collectors.toList());\n-        if (results.isEmpty()) return null;\n-        return results.get(0);\n+        return getStoredCredentialsStream(realm, user).filter(credential ->\n+                type.equals(credential.getType()) && name.equals(credential.getUserLabel()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5ODA0Mg==", "bodyText": "Noted!", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533498042", "createdAt": "2020-12-01T15:24:03Z", "author": {"login": "sguilhen"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentials(realm, user).stream().filter(credential -> type.equals(credential.getType())).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n+        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));\n     }\n \n     @Override\n     public CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserModel user, String name, String type) {\n-        List<CredentialModel> results = getStoredCredentials(realm, user).stream().filter(credential ->\n-                type.equals(credential.getType()) && name.equals(credential.getUserLabel())).collect(Collectors.toList());\n-        if (results.isEmpty()) return null;\n-        return results.get(0);\n+        return getStoredCredentialsStream(realm, user).filter(credential ->\n+                type.equals(credential.getType()) && name.equals(credential.getUserLabel()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDkwNA=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjg3NTA1OnYy", "diffSide": "RIGHT", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOToxNToxOVrOH8Jy4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyNDo0N1rOH8yLBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNzA5MQ==", "bodyText": "It's sorted in SQL query. Is it needed to sort again with streams?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532837091", "createdAt": "2020-11-30T19:15:19Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5ODYyOA==", "bodyText": "Ugh, I haven't checked the query.. I think you have a point, remember seeing a comment about it somewhere.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533498628", "createdAt": "2020-12-01T15:24:47Z", "author": {"login": "sguilhen"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNzA5MQ=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjg5NDQ4OnYy", "diffSide": "RIGHT", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOToyMDoxMlrOH8J-fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyNDo1OVrOH8yLjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MDA2MQ==", "bodyText": "Unused imports LinkedList, Collectors", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532840061", "createdAt": "2020-11-30T19:20:12Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -1022,27 +1022,20 @@ protected CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        return credentialStore.getStoredCredentials(realm, user);\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return credentialStore.getStoredCredentialsStream(realm, user);\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        List<CredentialEntity> results;\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n         UserEntity userEntity = userInEntityManagerContext(user.getId());\n         if (userEntity != null) {\n-\n             // user already in persistence context, no need to execute a query\n-            results = userEntity.getCredentials().stream().filter(it -> type.equals(it.getType()))\n+            return userEntity.getCredentials().stream().filter(it -> type.equals(it.getType()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5ODc2Ng==", "bodyText": "Noted!", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533498766", "createdAt": "2020-12-01T15:24:59Z", "author": {"login": "sguilhen"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -1022,27 +1022,20 @@ protected CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        return credentialStore.getStoredCredentials(realm, user);\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return credentialStore.getStoredCredentialsStream(realm, user);\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        List<CredentialEntity> results;\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n         UserEntity userEntity = userInEntityManagerContext(user.getId());\n         if (userEntity != null) {\n-\n             // user already in persistence context, no need to execute a query\n-            results = userEntity.getCredentials().stream().filter(it -> type.equals(it.getType()))\n+            return userEntity.getCredentials().stream().filter(it -> type.equals(it.getType()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MDA2MQ=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjkyOTA1OnYy", "diffSide": "RIGHT", "path": "server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOToyOToxNlrOH8KTcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyNToxOVrOH8yMpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NTQyNg==", "bodyText": "Maybe worth to consider this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()\n          \n          \n            \n                        if (session.userCredentialManager()\n          \n          \n            \n                                .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n          \n          \n            \n                                .map(PasswordCredentialModel::createFromCredentialModel)\n          \n          \n            \n                                .anyMatch(passwordCredential -> {\n          \n          \n            \n                                    PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n          \n          \n            \n                                    return hash != null && hash.verify(password, passwordCredential);\n          \n          \n            \n                                })) {\n          \n          \n            \n                            return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n          \n          \n            \n                        }", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532845426", "createdAt": "2020-11-30T19:29:16Z", "author": {"login": "martin-kanis"}, "path": "server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java", "diffHunk": "@@ -53,21 +54,23 @@ public PolicyError validate(RealmModel realm, UserModel user, String password) {\n         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();\n         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);\n         if (passwordHistoryPolicyValue != -1) {\n-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);\n-            for (CredentialModel cred : storedPasswords) {\n-                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5OTA0Ng==", "bodyText": "Ahh, yes, this looks a lot better, thanks for the suggestion.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533499046", "createdAt": "2020-12-01T15:25:19Z", "author": {"login": "sguilhen"}, "path": "server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java", "diffHunk": "@@ -53,21 +54,23 @@ public PolicyError validate(RealmModel realm, UserModel user, String password) {\n         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();\n         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);\n         if (passwordHistoryPolicyValue != -1) {\n-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);\n-            for (CredentialModel cred : storedPasswords) {\n-                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NTQyNg=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjkzNTk0OnYy", "diffSide": "RIGHT", "path": "server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTozMDo0N1rOH8KXcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyNToyNVrOH8yNAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NjQ1MQ==", "bodyText": "Maybe something similar could be used as in suggestion above.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532846451", "createdAt": "2020-11-30T19:30:47Z", "author": {"login": "martin-kanis"}, "path": "server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java", "diffHunk": "@@ -53,21 +54,23 @@ public PolicyError validate(RealmModel realm, UserModel user, String password) {\n         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();\n         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);\n         if (passwordHistoryPolicyValue != -1) {\n-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);\n-            for (CredentialModel cred : storedPasswords) {\n-                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()\n+                    .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n+                    .map(PasswordCredentialModel::createFromCredentialModel)\n+                    .collect(Collectors.toList());\n+            for (PasswordCredentialModel passwordCredential : passwordCredentials) {\n                 PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n-                if (hash == null) continue;\n-                if (hash.verify(password, passwordCredential)) {\n+                if (hash != null && hash.verify(password, passwordCredential)) {\n                     return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n                 }\n             }\n \n             if (passwordHistoryPolicyValue > 0) {\n-                List<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n-                List<CredentialModel> recentPasswordHistory = getRecent(passwordHistory, passwordHistoryPolicyValue - 1);\n-                for (CredentialModel cred : recentPasswordHistory) {\n-                    PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+                Stream<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n+                List<PasswordCredentialModel> recentPasswordHistory = this.getRecent(passwordHistory, passwordHistoryPolicyValue - 1)\n+                        .map(PasswordCredentialModel::createFromCredentialModel)\n+                        .collect(Collectors.toList());\n+                for (PasswordCredentialModel passwordCredential : recentPasswordHistory) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5OTEzOA==", "bodyText": "Definitely!", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r533499138", "createdAt": "2020-12-01T15:25:25Z", "author": {"login": "sguilhen"}, "path": "server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java", "diffHunk": "@@ -53,21 +54,23 @@ public PolicyError validate(RealmModel realm, UserModel user, String password) {\n         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();\n         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);\n         if (passwordHistoryPolicyValue != -1) {\n-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);\n-            for (CredentialModel cred : storedPasswords) {\n-                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()\n+                    .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n+                    .map(PasswordCredentialModel::createFromCredentialModel)\n+                    .collect(Collectors.toList());\n+            for (PasswordCredentialModel passwordCredential : passwordCredentials) {\n                 PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n-                if (hash == null) continue;\n-                if (hash.verify(password, passwordCredential)) {\n+                if (hash != null && hash.verify(password, passwordCredential)) {\n                     return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n                 }\n             }\n \n             if (passwordHistoryPolicyValue > 0) {\n-                List<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n-                List<CredentialModel> recentPasswordHistory = getRecent(passwordHistory, passwordHistoryPolicyValue - 1);\n-                for (CredentialModel cred : recentPasswordHistory) {\n-                    PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+                Stream<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n+                List<PasswordCredentialModel> recentPasswordHistory = this.getRecent(passwordHistory, passwordHistoryPolicyValue - 1)\n+                        .map(PasswordCredentialModel::createFromCredentialModel)\n+                        .collect(Collectors.toList());\n+                for (PasswordCredentialModel passwordCredential : recentPasswordHistory) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NjQ1MQ=="}, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MTUyODEzOnYy", "diffSide": "RIGHT", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMzo0Nzo1OFrOH9br5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMToyMzoxNlrOH91JzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3ODc5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Optional<CredentialModel> existing = session.userFederatedStorage()\n          \n          \n            \n                        return session.userFederatedStorage()\n          \n          \n            \n                                .getStoredCredentialsByTypeStream(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\")\n          \n          \n            \n                                .map(CredentialModel::getSecretData)\n          \n          \n            \n                                .anyMatch(Predicate.isEqual(\"{\\\"value\\\":\\\"\" + input.getChallengeResponse() + \"\\\"}\"));", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534178790", "createdAt": "2020-12-02T13:47:58Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "diffHunk": "@@ -80,9 +82,12 @@ public boolean isValid(RealmModel realm, UserModel user, CredentialInput input)\n              if (INITIAL_PASSWORD.equals(input.getChallengeResponse())) {\n                  return true;\n              }\n-            List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\");\n-            if (existing.isEmpty()) return false;\n-            return existing.get(0).getSecretData().equals(\"{\\\"value\\\":\\\"\" + input.getChallengeResponse() + \"\\\"}\");\n+            Optional<CredentialModel> existing = session.userFederatedStorage()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU5NjA0NA==", "bodyText": "Thanks for the suggestion, it is indeed clearer.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534596044", "createdAt": "2020-12-03T01:23:16Z", "author": {"login": "sguilhen"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "diffHunk": "@@ -80,9 +82,12 @@ public boolean isValid(RealmModel realm, UserModel user, CredentialInput input)\n              if (INITIAL_PASSWORD.equals(input.getChallengeResponse())) {\n                  return true;\n              }\n-            List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\");\n-            if (existing.isEmpty()) return false;\n-            return existing.get(0).getSecretData().equals(\"{\\\"value\\\":\\\"\" + input.getChallengeResponse() + \"\\\"}\");\n+            Optional<CredentialModel> existing = session.userFederatedStorage()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3ODc5MA=="}, "originalCommit": {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MjMxMjcxOnYy", "diffSide": "LEFT", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNjoyNTo1MVrOH9jSRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNjo1MDoxMVrOH9-hxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMzMwMA==", "bodyText": "You switched the content between if and else blocks on purpose?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534303300", "createdAt": "2020-12-02T16:25:51Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "diffHunk": "@@ -91,18 +96,19 @@ public boolean isValid(RealmModel realm, UserModel user, CredentialInput input)\n     public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n         // testing federated credential attributes\n         if (input.getType().equals(PasswordCredentialModel.TYPE)) {\n-            List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\");\n-            if (existing.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU5NzM0Mw==", "bodyText": "Yeah, do you think I should have preserved the original logic instead?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534597343", "createdAt": "2020-12-03T01:26:38Z", "author": {"login": "sguilhen"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "diffHunk": "@@ -91,18 +96,19 @@ public boolean isValid(RealmModel realm, UserModel user, CredentialInput input)\n     public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n         // testing federated credential attributes\n         if (input.getType().equals(PasswordCredentialModel.TYPE)) {\n-            List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\");\n-            if (existing.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMzMwMA=="}, "originalCommit": {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc0OTYzOA==", "bodyText": "No it's OK. I didn't notice the difference in existing.isEmpty() vs existing.isPresent() :)", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534749638", "createdAt": "2020-12-03T06:50:11Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "diffHunk": "@@ -91,18 +96,19 @@ public boolean isValid(RealmModel realm, UserModel user, CredentialInput input)\n     public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n         // testing federated credential attributes\n         if (input.getType().equals(PasswordCredentialModel.TYPE)) {\n-            List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\");\n-            if (existing.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMzMwMA=="}, "originalCommit": {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MjcwMTQ3OnYy", "diffSide": "RIGHT", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODo1MDo0M1rOH_GxaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODo1MDo0M1rOH_GxaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkzMzI4OQ==", "bodyText": "Please keep the original variant in this particular storage.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r535933289", "createdAt": "2020-12-04T08:50:43Z", "author": {"login": "hmlnarik"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java", "diffHunk": "@@ -209,15 +207,9 @@ private MyUser getMyUser(UserModel user) {\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n-\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9851cfdc7a1881bd1cebd8116df2eecf9147468d"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3186, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}