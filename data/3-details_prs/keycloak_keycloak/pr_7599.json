{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5NTY1NDg3", "number": 7599, "title": "[KEYCLOAK-16232] Replace usages of deprecated collection-based method\u2026", "bodyText": "\u2026s with the respective stream variants\nThis is a follow up to https://issues.redhat.com/browse/KEYCLOAK-15200", "createdAt": "2020-11-12T02:12:55Z", "url": "https://github.com/keycloak/keycloak/pull/7599", "merged": true, "mergeCommit": {"oid": "edef93cd491e545de642fd39d0df0a53cecee830"}, "closed": true, "closedAt": "2020-12-07T18:48:37Z", "author": {"login": "sguilhen"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdbyh7RABqjM5ODg2NjE0OTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdj6HHXgFqTU0NjQzNDE3Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ef7c48ffa037ac28c89940666416c05b04fc5377", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/ef7c48ffa037ac28c89940666416c05b04fc5377", "committedDate": "2020-11-12T02:10:52Z", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}, "afterCommit": {"oid": "3367c7bac6e2a8d1b80486b4bdbc1030d1c75f70", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/3367c7bac6e2a8d1b80486b4bdbc1030d1c75f70", "committedDate": "2020-11-12T13:25:09Z", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3367c7bac6e2a8d1b80486b4bdbc1030d1c75f70", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/3367c7bac6e2a8d1b80486b4bdbc1030d1c75f70", "committedDate": "2020-11-12T13:25:09Z", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}, "afterCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "committedDate": "2020-11-12T13:34:30Z", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwMTQ0MDkx", "url": "https://github.com/keycloak/keycloak/pull/7599#pullrequestreview-530144091", "createdAt": "2020-11-13T15:12:48Z", "commit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNToxMjo0OVrOHyyLoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxMzozOToyM1rOH1uN-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAxMzAyNQ==", "bodyText": "Maybe we could keep stream here and pass it to UserFullInvalidationEvent.create while replacing for loop with stream processing inside the method.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r523013025", "createdAt": "2020-11-13T15:12:49Z", "author": {"login": "martin-kanis"}, "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -796,7 +792,8 @@ public UserModel addUser(RealmModel realm, String username) {\n \n     // just in case the transaction is rolled back you need to invalidate the user and all cache queries for that user\n     protected void fullyInvalidateUser(RealmModel realm, UserModel user) {\n-        Set<FederatedIdentityModel> federatedIdentities = realm.isIdentityFederationEnabled() ? getFederatedIdentities(user, realm) : null;\n+        Set<FederatedIdentityModel> federatedIdentities = realm.isIdentityFederationEnabled() ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyMTgwMg==", "bodyText": "This part confuses me little bit. We wanted to keep original collection based methods in UserCredentialStore and deprecate those in UserFederatedUserCredentialStore?\nI know we had some discussion around this but I don't remember exact outcome.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r523021802", "createdAt": "2020-11-13T15:25:47Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -691,12 +691,12 @@ public CredentialModel getStoredCredentialById(RealmModel realm, UserModel user,\n \n     @Override\n     public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        return getStoredCredentials(realm, user.getId());\n+        return getStoredCredentialsStream(realm, user.getId()).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNjEzOA==", "bodyText": "It's not your change but maybe worth to use isEmpty().", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r523026138", "createdAt": "2020-11-13T15:32:28Z", "author": {"login": "martin-kanis"}, "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/UserAttributeLDAPStorageMapper.java", "diffHunk": "@@ -121,13 +122,13 @@ public void onRegisterUserToLDAP(LDAPObject ldapUser, UserModel localUser, Realm\n         } else {\n \n             // we don't have java property. Let's set attribute\n-            List<String> attrValues = localUser.getAttribute(userModelAttrName);\n+            List<String> attrValues = localUser.getAttributeStream(userModelAttrName).collect(Collectors.toList());\n \n             if (attrValues.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg5OTU0Mw==", "bodyText": "users != null can be omitted. Same in the return statement.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525899543", "createdAt": "2020-11-18T08:32:14Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java", "diffHunk": "@@ -61,14 +62,14 @@ public UserModel find(AuthenticationFlowContext context, Object userIdentity) th\n             if (_customAttributes.isEmpty() || userIdentityValues.isEmpty() || (_customAttributes.size() != userIdentityValues.size())) {\n                 return null;\n             }\n-            List<UserModel> users = session.users().searchForUserByUserAttribute(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n+            Stream<UserModel> usersStream = session.users().searchForUserByUserAttributeStream(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n             \n             for (int i = 1; i <_customAttributes.size(); ++i) {\n                 String customAttribute = _customAttributes.get(i);\n                 String userIdentityValue = userIdentityValues.get(i);\n-                \n-                users = users.stream().filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue)).collect(Collectors.toList());\n+                usersStream = usersStream.filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue));\n             }\n+            List<UserModel> users = usersStream.collect(Collectors.toList());\n             if (users != null && users.size() > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkwNzgzMQ==", "bodyText": "I think this method and all its usages are worth to \"streamify\".", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525907831", "createdAt": "2020-11-18T08:45:50Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/authentication/requiredactions/util/UserUpdateProfileContext.java", "diffHunk": "@@ -103,6 +104,6 @@ public String getFirstAttribute(String name) {\n \n     @Override\n     public List<String> getAttribute(String key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkyMjk2NQ==", "bodyText": "Here can you confirm my assumption the cached version of getFederatedIdentitiesStream(user, realm) will be used to prevent multiple database calls?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525922965", "createdAt": "2020-11-18T09:09:24Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/AccountFederatedIdentityBean.java", "diffHunk": "@@ -47,15 +48,13 @@\n     public AccountFederatedIdentityBean(KeycloakSession session, RealmModel realm, UserModel user, URI baseUri, String stateChecker) {\n         this.session = session;\n \n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n-\n         AtomicInteger availableIdentities = new AtomicInteger(0);\n         this.identities = realm.getIdentityProvidersStream()\n                 .filter(IdentityProviderModel::isEnabled)\n                 .map(provider -> {\n                     String providerId = provider.getAlias();\n \n-                    FederatedIdentityModel identity = getIdentity(identities, providerId);\n+                    FederatedIdentityModel identity = getIdentity(session.users().getFederatedIdentitiesStream(user, realm), providerId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkyNzMxNg==", "bodyText": "This could be probably slightly changed to use map + collect instead of foreach.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525927316", "createdAt": "2020-11-18T09:15:51Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java", "diffHunk": "@@ -52,10 +51,9 @@\n     public ApplicationsBean(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        for (ClientModel client : getApplications(session, realm, user)) {\n-            if (isAdminClient(client) && ! AdminPermissions.realms(session, realm, user).isAdmin()) {\n-                continue;\n-            }\n+        this.getApplications(session, realm, user)\n+                .filter(client -> !isAdminClient(client) || AdminPermissions.realms(session, realm, user).isAdmin())\n+                .forEach(client -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0NzIxNw==", "bodyText": "Maybe you can do similar thing which you did in one of the previous classes? toLinkedAccountRepresentation(provider, socialIds, session.users().getFederatedIdentitiesStream(user, realm)); + rewrite getIdentity method to accept a stream.  But only if the same predicate about caching is valid to avoid performance degradation.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r525947217", "createdAt": "2020-11-18T09:45:19Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java", "diffHunk": "@@ -110,7 +111,8 @@ public Response linkedAccounts() {\n \n     public SortedSet<LinkedAccountRepresentation> getLinkedAccounts(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<String> socialIds = findSocialIds();\n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n+        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentitiesStream(user, realm)\n+                .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA4OTgyMQ==", "bodyText": "Not needed", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r526089821", "createdAt": "2020-11-18T13:33:09Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "diffHunk": "@@ -358,30 +358,24 @@ public UserRepresentation getUser() {\n     /**\n      * Get social logins associated with the user\n      *\n-     * @return\n+     * @return a non-null {@code Stream} of social logins (federated identities).\n      */\n     @Path(\"federated-identity\")\n     @GET\n     @NoCache\n     @Produces(MediaType.APPLICATION_JSON)\n-    public List<FederatedIdentityRepresentation> getFederatedIdentity() {\n+    public Stream<FederatedIdentityRepresentation> getFederatedIdentity() {\n         auth.users().requireView(user);\n-\n         return getFederatedIdentities(user);\n     }\n \n-    private List<FederatedIdentityRepresentation> getFederatedIdentities(UserModel user) {\n-        Set<FederatedIdentityModel> identities = session.users().getFederatedIdentities(user, realm);\n-        List<FederatedIdentityRepresentation> result = new ArrayList<FederatedIdentityRepresentation>();\n+    private Stream<FederatedIdentityRepresentation> getFederatedIdentities(UserModel user) {\n         Set<String> idps = realm.getIdentityProvidersStream().map(IdentityProviderModel::getAlias).collect(Collectors.toSet());\n+        List<FederatedIdentityRepresentation> result = new ArrayList<FederatedIdentityRepresentation>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA5MzgxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    models.forEach(c -> c.setSecretData(null));\n          \n          \n            \n                    return session.userCredentialManager().getStoredCredentials(realm, user)\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .peek(c -> c.setSecretData(null))\n          \n          \n            \n                            .map(ModelToRepresentation::toRepresentation);", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r526093819", "createdAt": "2020-11-18T13:39:23Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/admin/UserResource.java", "diffHunk": "@@ -607,11 +600,11 @@ public void resetPassword(CredentialRepresentation cred) {\n     @Path(\"credentials\")\n     @NoCache\n     @Produces(MediaType.APPLICATION_JSON)\n-    public List<CredentialRepresentation> credentials(){\n+    public Stream<CredentialRepresentation> credentials(){\n         auth.users().requireManage(user);\n         List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);\n         models.forEach(c -> c.setSecretData(null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2"}, "originalPosition": 73}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/f99ae5d8ee4c0ad47d3402879822ef81fef059f2", "committedDate": "2020-11-12T13:34:30Z", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}, "afterCommit": {"oid": "d82758c2e07debd26ffe80de6badb4374ae60377", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/d82758c2e07debd26ffe80de6badb4374ae60377", "committedDate": "2020-11-25T18:15:40Z", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9b49d5339afad57fe52a7e9607248a05720c3d56", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/9b49d5339afad57fe52a7e9607248a05720c3d56", "committedDate": "2020-11-26T13:25:06Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, "afterCommit": {"oid": "28430f5e4fa9df85c833677165bd579c607d41aa", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/28430f5e4fa9df85c833677165bd579c607d41aa", "committedDate": "2020-11-26T13:27:33Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "28430f5e4fa9df85c833677165bd579c607d41aa", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/28430f5e4fa9df85c833677165bd579c607d41aa", "committedDate": "2020-11-26T13:27:33Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, "afterCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/74341de5f2d1ea877d611c78cd416ecca2a3ad45", "committedDate": "2020-11-26T14:39:59Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTE5MDk3", "url": "https://github.com/keycloak/keycloak/pull/7599#pullrequestreview-541119097", "createdAt": "2020-11-30T17:12:04Z", "commit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzoxMjowNFrOH8FFmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTozMDo0N1rOH8KXcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1OTk2MQ==", "bodyText": "Star import.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532759961", "createdAt": "2020-11-30T17:12:04Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/account/LinkedAccountsResource.java", "diffHunk": "@@ -21,6 +21,8 @@\n import java.security.MessageDigest;\n import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3MDQzNQ==", "bodyText": "Wouldn't be possible to extract this huge map body to a separate method for better readability?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532770435", "createdAt": "2020-11-30T17:27:13Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/forms/account/freemarker/model/ApplicationsBean.java", "diffHunk": "@@ -52,72 +52,64 @@\n     public ApplicationsBean(KeycloakSession session, RealmModel realm, UserModel user) {\n         Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);\n \n-        for (ClientModel client : getApplications(session, realm, user)) {\n-            if (isAdminClient(client) && ! AdminPermissions.realms(session, realm, user).isAdmin()) {\n-                continue;\n-            }\n-\n-            // Construct scope parameter with all optional scopes to see all potentially available roles\n-            Stream<ClientScopeModel> allClientScopes = Stream.concat(\n-                    client.getClientScopes(true, true).values().stream(),\n-                    client.getClientScopes(false, true).values().stream());\n-            allClientScopes = Stream.concat(allClientScopes, Stream.of(client)).distinct();\n-\n-            Set<RoleModel> availableRoles = TokenManager.getAccess(user, client, allClientScopes);\n-\n-            // Don't show applications, which user doesn't have access into (any available roles)\n-            // unless this is can be changed by approving/revoking consent\n-            if (! isAdminClient(client) && availableRoles.isEmpty() && ! client.isConsentRequired()) {\n-                continue;\n-            }\n-\n-            List<RoleModel> realmRolesAvailable = new LinkedList<>();\n-            MultivaluedHashMap<String, ClientRoleEntry> resourceRolesAvailable = new MultivaluedHashMap<>();\n-            processRoles(availableRoles, realmRolesAvailable, resourceRolesAvailable);\n-\n-            List<ClientScopeModel> orderedScopes = new LinkedList<>();\n-            if (client.isConsentRequired()) {\n-                UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n-\n-                if (consent != null) {\n-                    orderedScopes.addAll(consent.getGrantedClientScopes());\n-                }\n-            }\n-            List<String> clientScopesGranted = orderedScopes.stream()\n-                    .sorted(OrderedModel.OrderedModelComparator.getInstance())\n-                    .map(ClientScopeModel::getConsentScreenText)\n-                    .collect(Collectors.toList());\n-\n-            List<String> additionalGrants = new ArrayList<>();\n-            if (offlineClients.contains(client)) {\n-                additionalGrants.add(\"${offlineToken}\");\n-            }\n-\n-            applications.add(new ApplicationEntry(session, realmRolesAvailable, resourceRolesAvailable, client, clientScopesGranted, additionalGrants));\n-        }\n+        this.applications = this.getApplications(session, realm, user)\n+                .filter(client -> !isAdminClient(client) || AdminPermissions.realms(session, realm, user).isAdmin())\n+                .map(client -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTE2MQ==", "bodyText": "Will be the getDisableableCredentialTypes method streamified?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532779161", "createdAt": "2020-11-30T17:40:13Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -218,23 +218,20 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {\n+        Stream<String> types = Stream.empty();\n         String providerId = StorageId.isLocalStorage(user) ? user.getFederationLink() : StorageId.resolveProviderId(user);\n         if (providerId != null) {\n             UserStorageProviderModel model = getStorageProviderModel(realm, providerId);\n-            if (model == null || !model.isEnabled()) return Collections.EMPTY_SET;\n+            if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types.addAll(updater.getDisableableCredentialTypes(realm, user));\n+            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc3OTg0NQ==", "bodyText": "Maybe distinct() is missing?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532779845", "createdAt": "2020-11-30T17:41:11Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -218,23 +218,20 @@ public void disableCredentialType(RealmModel realm, UserModel user, String crede\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {\n+        Stream<String> types = Stream.empty();\n         String providerId = StorageId.isLocalStorage(user) ? user.getFederationLink() : StorageId.resolveProviderId(user);\n         if (providerId != null) {\n             UserStorageProviderModel model = getStorageProviderModel(realm, providerId);\n-            if (model == null || !model.isEnabled()) return Collections.EMPTY_SET;\n+            if (model == null || !model.isEnabled()) return types;\n \n             CredentialInputUpdater updater = getStorageProviderInstance(model, CredentialInputUpdater.class);\n-            if (updater != null) types.addAll(updater.getDisableableCredentialTypes(realm, user));\n+            if (updater != null) types = updater.getDisableableCredentialTypes(realm, user).stream();\n         }\n \n-        types.addAll(getCredentialProviders(session, CredentialInputUpdater.class)\n+        return Stream.concat(types, getCredentialProviders(session, CredentialInputUpdater.class)\n                 .map(updater -> updater.getDisableableCredentialTypes(realm, user))\n-                .flatMap(Set::stream)\n-                .collect(Collectors.toSet()));\n-\n-        return types;\n+                .flatMap(Set::stream));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NjIyOA==", "bodyText": "Isn't the ConcurrentModificationException possible here?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532796228", "createdAt": "2020-11-30T18:06:35Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java", "diffHunk": "@@ -115,14 +116,11 @@ public CredentialModel createCredential(RealmModel realm, UserModel user, Passwo\n         }\n         \n         // 3) remove old password history items\n-        List<CredentialModel> passwordHistoryList = getCredentialStore().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n         final int passwordHistoryListMaxSize = Math.max(0, expiredPasswordsPolicyValue - 1);\n-        if (passwordHistoryList.size() > passwordHistoryListMaxSize) {\n-            passwordHistoryList.stream()\n-                    .sorted(CredentialModel.comparingByStartDateDesc())\n-                    .skip(passwordHistoryListMaxSize)\n-                    .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));\n-        }\n+        getCredentialStore().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY)\n+                .sorted(CredentialModel.comparingByStartDateDesc())\n+                .skip(passwordHistoryListMaxSize)\n+                .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyODk3Mw==", "bodyText": "Rather use Objects.equals as it's null safe.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532828973", "createdAt": "2020-11-30T19:01:19Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/authentication/authenticators/x509/UserIdentityToModelMapper.java", "diffHunk": "@@ -61,18 +62,18 @@ public UserModel find(AuthenticationFlowContext context, Object userIdentity) th\n             if (_customAttributes.isEmpty() || userIdentityValues.isEmpty() || (_customAttributes.size() != userIdentityValues.size())) {\n                 return null;\n             }\n-            List<UserModel> users = session.users().searchForUserByUserAttribute(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n+            Stream<UserModel> usersStream = session.users().searchForUserByUserAttributeStream(_customAttributes.get(0), userIdentityValues.get(0), context.getRealm());\n             \n             for (int i = 1; i <_customAttributes.size(); ++i) {\n                 String customAttribute = _customAttributes.get(i);\n                 String userIdentityValue = userIdentityValues.get(i);\n-                \n-                users = users.stream().filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue)).collect(Collectors.toList());\n+                usersStream = usersStream.filter(user -> user.getFirstAttribute(customAttribute).equals(userIdentityValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDU4Mw==", "bodyText": "Rather use Objects.equals as it's null safe.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532834583", "createdAt": "2020-11-30T19:11:00Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentials(realm, user).stream().filter(credential -> type.equals(credential.getType())).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n+        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNDkwNA==", "bodyText": "Again Objects.equals", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532834904", "createdAt": "2020-11-30T19:11:35Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        return getStoredCredentials(realm, user).stream().filter(credential -> type.equals(credential.getType())).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n+        return getStoredCredentialsStream(realm, user).filter(credential -> type.equals(credential.getType()));\n     }\n \n     @Override\n     public CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserModel user, String name, String type) {\n-        List<CredentialModel> results = getStoredCredentials(realm, user).stream().filter(credential ->\n-                type.equals(credential.getType()) && name.equals(credential.getUserLabel())).collect(Collectors.toList());\n-        if (results.isEmpty()) return null;\n-        return results.get(0);\n+        return getStoredCredentialsStream(realm, user).filter(credential ->\n+                type.equals(credential.getType()) && name.equals(credential.getUserLabel()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzNzA5MQ==", "bodyText": "It's sorted in SQL query. Is it needed to sort again with streams?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532837091", "createdAt": "2020-11-30T19:15:19Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java", "diffHunk": "@@ -106,31 +110,27 @@ CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        List<CredentialEntity> results = getStoredCredentialEntities(realm, user);\n-\n-        // list is ordered correctly by priority (lowest priority value first)\n-        return results.stream().map(this::toModel).collect(Collectors.toList());\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return this.getStoredCredentialEntities(realm, user).map(this::toModel);\n     }\n \n-    private List<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n+    private Stream<CredentialEntity> getStoredCredentialEntities(RealmModel realm, UserModel user) {\n         UserEntity userEntity = em.getReference(UserEntity.class, user.getId());\n         TypedQuery<CredentialEntity> query = em.createNamedQuery(\"credentialByUser\", CredentialEntity.class)\n                 .setParameter(\"user\", userEntity);\n-        return query.getResultList();\n+        return closing(query.getResultStream().sorted(Comparator.comparingInt(CredentialEntity::getPriority)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0MDA2MQ==", "bodyText": "Unused imports LinkedList, Collectors", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532840061", "createdAt": "2020-11-30T19:20:12Z", "author": {"login": "martin-kanis"}, "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -1022,27 +1022,20 @@ protected CredentialModel toModel(CredentialEntity entity) {\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {\n-        return credentialStore.getStoredCredentials(realm, user);\n+    public Stream<CredentialModel> getStoredCredentialsStream(RealmModel realm, UserModel user) {\n+        return credentialStore.getStoredCredentialsStream(realm, user);\n     }\n \n     @Override\n-    public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {\n-        List<CredentialEntity> results;\n+    public Stream<CredentialModel> getStoredCredentialsByTypeStream(RealmModel realm, UserModel user, String type) {\n         UserEntity userEntity = userInEntityManagerContext(user.getId());\n         if (userEntity != null) {\n-\n             // user already in persistence context, no need to execute a query\n-            results = userEntity.getCredentials().stream().filter(it -> type.equals(it.getType()))\n+            return userEntity.getCredentials().stream().filter(it -> type.equals(it.getType()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NTQyNg==", "bodyText": "Maybe worth to consider this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()\n          \n          \n            \n                        if (session.userCredentialManager()\n          \n          \n            \n                                .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n          \n          \n            \n                                .map(PasswordCredentialModel::createFromCredentialModel)\n          \n          \n            \n                                .anyMatch(passwordCredential -> {\n          \n          \n            \n                                    PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n          \n          \n            \n                                    return hash != null && hash.verify(password, passwordCredential);\n          \n          \n            \n                                })) {\n          \n          \n            \n                            return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n          \n          \n            \n                        }", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532845426", "createdAt": "2020-11-30T19:29:16Z", "author": {"login": "martin-kanis"}, "path": "server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java", "diffHunk": "@@ -53,21 +54,23 @@ public PolicyError validate(RealmModel realm, UserModel user, String password) {\n         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();\n         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);\n         if (passwordHistoryPolicyValue != -1) {\n-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);\n-            for (CredentialModel cred : storedPasswords) {\n-                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0NjQ1MQ==", "bodyText": "Maybe something similar could be used as in suggestion above.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r532846451", "createdAt": "2020-11-30T19:30:47Z", "author": {"login": "martin-kanis"}, "path": "server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java", "diffHunk": "@@ -53,21 +54,23 @@ public PolicyError validate(RealmModel realm, UserModel user, String password) {\n         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();\n         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);\n         if (passwordHistoryPolicyValue != -1) {\n-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);\n-            for (CredentialModel cred : storedPasswords) {\n-                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+            List<PasswordCredentialModel> passwordCredentials = session.userCredentialManager()\n+                    .getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.TYPE)\n+                    .map(PasswordCredentialModel::createFromCredentialModel)\n+                    .collect(Collectors.toList());\n+            for (PasswordCredentialModel passwordCredential : passwordCredentials) {\n                 PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());\n-                if (hash == null) continue;\n-                if (hash.verify(password, passwordCredential)) {\n+                if (hash != null && hash.verify(password, passwordCredential)) {\n                     return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);\n                 }\n             }\n \n             if (passwordHistoryPolicyValue > 0) {\n-                List<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n-                List<CredentialModel> recentPasswordHistory = getRecent(passwordHistory, passwordHistoryPolicyValue - 1);\n-                for (CredentialModel cred : recentPasswordHistory) {\n-                    PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);\n+                Stream<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByTypeStream(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);\n+                List<PasswordCredentialModel> recentPasswordHistory = this.getRecent(passwordHistory, passwordHistoryPolicyValue - 1)\n+                        .map(PasswordCredentialModel::createFromCredentialModel)\n+                        .collect(Collectors.toList());\n+                for (PasswordCredentialModel passwordCredential : recentPasswordHistory) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45"}, "originalPosition": 37}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "74341de5f2d1ea877d611c78cd416ecca2a3ad45", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/74341de5f2d1ea877d611c78cd416ecca2a3ad45", "committedDate": "2020-11-26T14:39:59Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, "afterCommit": {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "committedDate": "2020-12-01T19:26:21Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODUwMjE4", "url": "https://github.com/keycloak/keycloak/pull/7599#pullrequestreview-542850218", "createdAt": "2020-12-02T13:47:58Z", "commit": {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMzo0Nzo1OFrOH9br5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNjoyNTo1MVrOH9jSRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3ODc5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Optional<CredentialModel> existing = session.userFederatedStorage()\n          \n          \n            \n                        return session.userFederatedStorage()\n          \n          \n            \n                                .getStoredCredentialsByTypeStream(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\")\n          \n          \n            \n                                .map(CredentialModel::getSecretData)\n          \n          \n            \n                                .anyMatch(Predicate.isEqual(\"{\\\"value\\\":\\\"\" + input.getChallengeResponse() + \"\\\"}\"));", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534178790", "createdAt": "2020-12-02T13:47:58Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "diffHunk": "@@ -80,9 +82,12 @@ public boolean isValid(RealmModel realm, UserModel user, CredentialInput input)\n              if (INITIAL_PASSWORD.equals(input.getChallengeResponse())) {\n                  return true;\n              }\n-            List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\");\n-            if (existing.isEmpty()) return false;\n-            return existing.get(0).getSecretData().equals(\"{\\\"value\\\":\\\"\" + input.getChallengeResponse() + \"\\\"}\");\n+            Optional<CredentialModel> existing = session.userFederatedStorage()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMzMwMA==", "bodyText": "You switched the content between if and else blocks on purpose?", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r534303300", "createdAt": "2020-12-02T16:25:51Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java", "diffHunk": "@@ -91,18 +96,19 @@ public boolean isValid(RealmModel realm, UserModel user, CredentialInput input)\n     public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n         // testing federated credential attributes\n         if (input.getType().equals(PasswordCredentialModel.TYPE)) {\n-            List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), \"CLEAR_TEXT_PASSWORD\");\n-            if (existing.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1"}, "originalPosition": 42}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/80fd09d1d26f966b65de61fd87ff2e4f6fd3a9d1", "committedDate": "2020-12-01T19:26:21Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, "afterCommit": {"oid": "9851cfdc7a1881bd1cebd8116df2eecf9147468d", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/9851cfdc7a1881bd1cebd8116df2eecf9147468d", "committedDate": "2020-12-03T01:27:25Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNjUyMTYx", "url": "https://github.com/keycloak/keycloak/pull/7599#pullrequestreview-543652161", "createdAt": "2020-12-03T06:55:24Z", "commit": {"oid": "9851cfdc7a1881bd1cebd8116df2eecf9147468d"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzU5OTQ1", "url": "https://github.com/keycloak/keycloak/pull/7599#pullrequestreview-544759945", "createdAt": "2020-12-04T08:50:43Z", "commit": {"oid": "9851cfdc7a1881bd1cebd8116df2eecf9147468d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODo1MDo0M1rOH_GxaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwODo1MDo0M1rOH_GxaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkzMzI4OQ==", "bodyText": "Please keep the original variant in this particular storage.", "url": "https://github.com/keycloak/keycloak/pull/7599#discussion_r535933289", "createdAt": "2020-12-04T08:50:43Z", "author": {"login": "hmlnarik"}, "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java", "diffHunk": "@@ -209,15 +207,9 @@ private MyUser getMyUser(UserModel user) {\n     }\n \n     @Override\n-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n-        Set<String> types = new HashSet<>();\n-\n+    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9851cfdc7a1881bd1cebd8116df2eecf9147468d"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzYxMzI2", "url": "https://github.com/keycloak/keycloak/pull/7599#pullrequestreview-544761326", "createdAt": "2020-12-04T08:52:39Z", "commit": {"oid": "9851cfdc7a1881bd1cebd8116df2eecf9147468d"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a278c1372b39f998c9832647150bc74abbab5d1f", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/a278c1372b39f998c9832647150bc74abbab5d1f", "committedDate": "2020-12-07T13:15:45Z", "message": "[KEYCLOAK-16232] Replace usages of deprecated collection-based methods with the respective stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9851cfdc7a1881bd1cebd8116df2eecf9147468d", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/9851cfdc7a1881bd1cebd8116df2eecf9147468d", "committedDate": "2020-12-03T01:27:25Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, "afterCommit": {"oid": "f4199bf4a7e6fd3e3d6c9d0f7f88a817c0e0b31a", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/f4199bf4a7e6fd3e3d6c9d0f7f88a817c0e0b31a", "committedDate": "2020-12-07T13:15:45Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ef87c568740141848eb305353f8bdf472c88d2d", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/5ef87c568740141848eb305353f8bdf472c88d2d", "committedDate": "2020-12-07T16:47:29Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f4199bf4a7e6fd3e3d6c9d0f7f88a817c0e0b31a", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/f4199bf4a7e6fd3e3d6c9d0f7f88a817c0e0b31a", "committedDate": "2020-12-07T13:15:45Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}, "afterCommit": {"oid": "5ef87c568740141848eb305353f8bdf472c88d2d", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/5ef87c568740141848eb305353f8bdf472c88d2d", "committedDate": "2020-12-07T16:47:29Z", "message": "[KEYCLOAK-16232] Streamify the UserCredentialStore and UserCredentialManager interfaces"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDM0MTcz", "url": "https://github.com/keycloak/keycloak/pull/7599#pullrequestreview-546434173", "createdAt": "2020-12-07T18:46:51Z", "commit": {"oid": "5ef87c568740141848eb305353f8bdf472c88d2d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3245, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}