{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNDkwMjIz", "number": 7652, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwODoxMTowMVrOFAC0rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODoxNjo0NVrOFCymyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NTkwNTczOnYy", "diffSide": "RIGHT", "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwODoxMTowMVrOH-Ge-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNzo1Njo1MFrOIAzN7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg3OTk5NQ==", "bodyText": "I'm wondering whether it's nicer to avoid the iterator:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Iterator<UserSessionEntity> itr = cache.entrySet().stream()\n          \n          \n            \n                    List<UserSessionModel> resultSessions = cache.entrySet().stream()\n          \n          \n            \n                            .filter(predicate)\n          \n          \n            \n                            .map(Mappers.userSessionEntity())\n          \n          \n            \n                            .map(entity -> wrap(realm, entity, offline))\n          \n          \n            \n                            .collect(Collectors.toList());\n          \n          \n            \n                    \n          \n          \n            \n                    return resultSessions.stream();", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534879995", "createdAt": "2020-12-03T08:11:01Z", "author": {"login": "martin-kanis"}, "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -270,25 +270,25 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool\n     }\n \n \n-    protected List<UserSessionModel> getUserSessions(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n+    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n         Cache<String, SessionEntityWrapper<UserSessionEntity>> cache = getCache(offline);\n-\n         cache = CacheDecorators.skipCacheLoaders(cache);\n \n-        Stream<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> cacheStream = cache.entrySet().stream();\n-\n-        List<UserSessionModel> resultSessions = new LinkedList<>();\n-\n-        Iterator<UserSessionEntity> itr = cacheStream.filter(predicate)\n+        Iterator<UserSessionEntity> itr = cache.entrySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMDA2Mw==", "bodyText": "It is, but as discussed there was an issue with the infinispan cache trying to serialize things that are not supposed to be sent through the wire. I've been able to get around this by \"wrapping\" the cache stream with one that uses the spliterator from the cache and thus obtains the elements one by one without incurring in serialization issues.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537710063", "createdAt": "2020-12-07T17:56:50Z", "author": {"login": "sguilhen"}, "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -270,25 +270,25 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool\n     }\n \n \n-    protected List<UserSessionModel> getUserSessions(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n+    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n         Cache<String, SessionEntityWrapper<UserSessionEntity>> cache = getCache(offline);\n-\n         cache = CacheDecorators.skipCacheLoaders(cache);\n \n-        Stream<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> cacheStream = cache.entrySet().stream();\n-\n-        List<UserSessionModel> resultSessions = new LinkedList<>();\n-\n-        Iterator<UserSessionEntity> itr = cacheStream.filter(predicate)\n+        Iterator<UserSessionEntity> itr = cache.entrySet().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg3OTk5NQ=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NTkwNzA2OnYy", "diffSide": "RIGHT", "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwODoxMTowOVrOH-Gf-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNzo1NzoxN1rOIAzPRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg4MDI1MA==", "bodyText": "Same note as above.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534880250", "createdAt": "2020-12-03T08:11:09Z", "author": {"login": "martin-kanis"}, "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -357,16 +357,17 @@ public UserSessionModel getUserSessionByBrokerSessionId(RealmModel realm, String\n             stream = stream.limit(maxResults);\n         }\n \n-        final List<UserSessionModel> sessions = new LinkedList<>();\n+        // while it looks natural to just do another map(entity -> wrap(realm, entity, offline)) on the stream and return it\n+        // directly, we need to pre-consume the stream from the infinispan cache using an iterator to avoid a serialization\n+        // error from infinispan when the stream is later consumed (by e.g. a call to collect or forEach) in certain cross-dc\n+        // scenarios.\n+        List<UserSessionModel> resultSessions = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMDQwNw==", "bodyText": "Same explanation :)", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537710407", "createdAt": "2020-12-07T17:57:17Z", "author": {"login": "sguilhen"}, "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -357,16 +357,17 @@ public UserSessionModel getUserSessionByBrokerSessionId(RealmModel realm, String\n             stream = stream.limit(maxResults);\n         }\n \n-        final List<UserSessionModel> sessions = new LinkedList<>();\n+        // while it looks natural to just do another map(entity -> wrap(realm, entity, offline)) on the stream and return it\n+        // directly, we need to pre-consume the stream from the infinispan cache using an iterator to avoid a serialization\n+        // error from infinispan when the stream is later consumed (by e.g. a call to collect or forEach) in certain cross-dc\n+        // scenarios.\n+        List<UserSessionModel> resultSessions = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg4MDI1MA=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NjUxMzIxOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOToxNjowMFrOH-M9nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOToxNjowMFrOH-M9nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4NjE0MQ==", "bodyText": "Star import.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534986141", "createdAt": "2020-12-03T09:16:00Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java", "diffHunk": "@@ -98,6 +99,8 @@\n import org.w3c.dom.Element;\n \n import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NjUxMzc0OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOToxNjowNlrOH-M98Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODowODo1MFrOIAztyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4NjIyNQ==", "bodyText": "Could you please extract this forEach block to a separate method for better readability?", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534986225", "createdAt": "2020-12-03T09:16:06Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java", "diffHunk": "@@ -296,22 +299,22 @@ protected Response handleSamlRequest(String samlRequest, String relayState) {\n         protected Response logoutRequest(LogoutRequestType request, String relayState) {\n             String brokerUserId = config.getAlias() + \".\" + request.getNameID().getValue();\n             if (request.getSessionIndex() == null || request.getSessionIndex().isEmpty()) {\n-                List<UserSessionModel> userSessions = session.sessions().getUserSessionByBrokerUserId(realm, brokerUserId);\n-                for (UserSessionModel userSession : userSessions) {\n-                    if (userSession.getState() == UserSessionModel.State.LOGGING_OUT || userSession.getState() == UserSessionModel.State.LOGGED_OUT) {\n-                        continue;\n-                    }\n-\n-                    for(Iterator<SamlAuthenticationPreprocessor> it = SamlSessionUtils.getSamlAuthenticationPreprocessorIterator(session); it.hasNext();) {\n-                        request = it.next().beforeProcessingLogoutRequest(request, userSession, null);\n-                    }\n-\n-                    try {\n-                        AuthenticationManager.backchannelLogout(session, realm, userSession, session.getContext().getUri(), clientConnection, headers, false);\n-                    } catch (Exception e) {\n-                        logger.warn(\"failed to do backchannel logout for userSession\", e);\n-                    }\n-                }\n+                AtomicReference<LogoutRequestType> ref = new AtomicReference<>(request);\n+                session.sessions().getUserSessionByBrokerUserIdStream(realm, brokerUserId)\n+                        .filter(userSession -> userSession.getState() != UserSessionModel.State.LOGGING_OUT &&\n+                                userSession.getState() != UserSessionModel.State.LOGGED_OUT)\n+                        .collect(Collectors.toList()) // collect to avoid concurrent modification as backchannelLogout removes the user sessions.\n+                        .forEach(userSession -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODIxNg==", "bodyText": "Done!", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537718216", "createdAt": "2020-12-07T18:08:50Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java", "diffHunk": "@@ -296,22 +299,22 @@ protected Response handleSamlRequest(String samlRequest, String relayState) {\n         protected Response logoutRequest(LogoutRequestType request, String relayState) {\n             String brokerUserId = config.getAlias() + \".\" + request.getNameID().getValue();\n             if (request.getSessionIndex() == null || request.getSessionIndex().isEmpty()) {\n-                List<UserSessionModel> userSessions = session.sessions().getUserSessionByBrokerUserId(realm, brokerUserId);\n-                for (UserSessionModel userSession : userSessions) {\n-                    if (userSession.getState() == UserSessionModel.State.LOGGING_OUT || userSession.getState() == UserSessionModel.State.LOGGED_OUT) {\n-                        continue;\n-                    }\n-\n-                    for(Iterator<SamlAuthenticationPreprocessor> it = SamlSessionUtils.getSamlAuthenticationPreprocessorIterator(session); it.hasNext();) {\n-                        request = it.next().beforeProcessingLogoutRequest(request, userSession, null);\n-                    }\n-\n-                    try {\n-                        AuthenticationManager.backchannelLogout(session, realm, userSession, session.getContext().getUri(), clientConnection, headers, false);\n-                    } catch (Exception e) {\n-                        logger.warn(\"failed to do backchannel logout for userSession\", e);\n-                    }\n-                }\n+                AtomicReference<LogoutRequestType> ref = new AtomicReference<>(request);\n+                session.sessions().getUserSessionByBrokerUserIdStream(realm, brokerUserId)\n+                        .filter(userSession -> userSession.getState() != UserSessionModel.State.LOGGING_OUT &&\n+                                userSession.getState() != UserSessionModel.State.LOGGED_OUT)\n+                        .collect(Collectors.toList()) // collect to avoid concurrent modification as backchannelLogout removes the user sessions.\n+                        .forEach(userSession -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4NjIyNQ=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NjUyOTQ4OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOToxOTozNFrOH-NHaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoxMDowNFrOIAzxBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4ODY1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .forEach(offlineUserSession -> userSessionManager.revokeOfflineUserSession(offlineUserSession));\n          \n          \n            \n                            .forEach(userSessionManager::revokeOfflineUserSession);", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534988651", "createdAt": "2020-12-03T09:19:34Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java", "diffHunk": "@@ -345,34 +345,29 @@ private BackchannelLogoutResponse backchannelLogoutFederatedUserId(String federa\n         BackchannelLogoutResponse backchannelLogoutResponse = new BackchannelLogoutResponse();\n         backchannelLogoutResponse.setLocalLogoutSucceeded(true);\n         identityProviderAliases.forEach(identityProviderAlias -> {\n-            List<UserSessionModel> userSessions = session.sessions().getUserSessionByBrokerUserId(realm,\n-                    identityProviderAlias + \".\" + federatedUserId);\n \n             if (logoutOfflineSessions) {\n                 logoutOfflineUserSessions(identityProviderAlias + \".\" + federatedUserId);\n             }\n \n-            for (UserSessionModel userSession : userSessions) {\n-                BackchannelLogoutResponse userBackchannelLogoutResponse;\n-                userBackchannelLogoutResponse = logoutUserSession(userSession);\n-                backchannelLogoutResponse.setLocalLogoutSucceeded(backchannelLogoutResponse.getLocalLogoutSucceeded()\n-                        && userBackchannelLogoutResponse.getLocalLogoutSucceeded());\n-                userBackchannelLogoutResponse.getClientResponses()\n-                        .forEach(backchannelLogoutResponse::addClientResponses);\n-            }\n+            session.sessions().getUserSessionByBrokerUserIdStream(realm, identityProviderAlias + \".\" + federatedUserId)\n+                    .collect(Collectors.toList()) // collect to avoid concurrent modification as backchannelLogout removes the user sessions.\n+                    .forEach(userSession -> {\n+                        BackchannelLogoutResponse userBackchannelLogoutResponse = this.logoutUserSession(userSession);\n+                        backchannelLogoutResponse.setLocalLogoutSucceeded(backchannelLogoutResponse.getLocalLogoutSucceeded()\n+                                && userBackchannelLogoutResponse.getLocalLogoutSucceeded());\n+                        userBackchannelLogoutResponse.getClientResponses()\n+                                .forEach(backchannelLogoutResponse::addClientResponses);\n+                    });\n         });\n \n         return backchannelLogoutResponse;\n     }\n \n     private void logoutOfflineUserSessions(String brokerUserId) {\n-        List<UserSessionModel> offlineUserSessions =\n-                session.sessions().getOfflineUserSessionByBrokerUserId(realm, brokerUserId);\n-\n         UserSessionManager userSessionManager = new UserSessionManager(session);\n-        for (UserSessionModel offlineUserSession : offlineUserSessions) {\n-            userSessionManager.revokeOfflineUserSession(offlineUserSession);\n-        }\n+        session.sessions().getOfflineUserSessionByBrokerUserIdStream(realm, brokerUserId).collect(Collectors.toList())\n+                .forEach(offlineUserSession -> userSessionManager.revokeOfflineUserSession(offlineUserSession));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxOTA0Ng==", "bodyText": "Good catch, thanks!", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537719046", "createdAt": "2020-12-07T18:10:04Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java", "diffHunk": "@@ -345,34 +345,29 @@ private BackchannelLogoutResponse backchannelLogoutFederatedUserId(String federa\n         BackchannelLogoutResponse backchannelLogoutResponse = new BackchannelLogoutResponse();\n         backchannelLogoutResponse.setLocalLogoutSucceeded(true);\n         identityProviderAliases.forEach(identityProviderAlias -> {\n-            List<UserSessionModel> userSessions = session.sessions().getUserSessionByBrokerUserId(realm,\n-                    identityProviderAlias + \".\" + federatedUserId);\n \n             if (logoutOfflineSessions) {\n                 logoutOfflineUserSessions(identityProviderAlias + \".\" + federatedUserId);\n             }\n \n-            for (UserSessionModel userSession : userSessions) {\n-                BackchannelLogoutResponse userBackchannelLogoutResponse;\n-                userBackchannelLogoutResponse = logoutUserSession(userSession);\n-                backchannelLogoutResponse.setLocalLogoutSucceeded(backchannelLogoutResponse.getLocalLogoutSucceeded()\n-                        && userBackchannelLogoutResponse.getLocalLogoutSucceeded());\n-                userBackchannelLogoutResponse.getClientResponses()\n-                        .forEach(backchannelLogoutResponse::addClientResponses);\n-            }\n+            session.sessions().getUserSessionByBrokerUserIdStream(realm, identityProviderAlias + \".\" + federatedUserId)\n+                    .collect(Collectors.toList()) // collect to avoid concurrent modification as backchannelLogout removes the user sessions.\n+                    .forEach(userSession -> {\n+                        BackchannelLogoutResponse userBackchannelLogoutResponse = this.logoutUserSession(userSession);\n+                        backchannelLogoutResponse.setLocalLogoutSucceeded(backchannelLogoutResponse.getLocalLogoutSucceeded()\n+                                && userBackchannelLogoutResponse.getLocalLogoutSucceeded());\n+                        userBackchannelLogoutResponse.getClientResponses()\n+                                .forEach(backchannelLogoutResponse::addClientResponses);\n+                    });\n         });\n \n         return backchannelLogoutResponse;\n     }\n \n     private void logoutOfflineUserSessions(String brokerUserId) {\n-        List<UserSessionModel> offlineUserSessions =\n-                session.sessions().getOfflineUserSessionByBrokerUserId(realm, brokerUserId);\n-\n         UserSessionManager userSessionManager = new UserSessionManager(session);\n-        for (UserSessionModel offlineUserSession : offlineUserSessions) {\n-            userSessionManager.revokeOfflineUserSession(offlineUserSession);\n-        }\n+        session.sessions().getOfflineUserSessionByBrokerUserIdStream(realm, brokerUserId).collect(Collectors.toList())\n+                .forEach(offlineUserSession -> userSessionManager.revokeOfflineUserSession(offlineUserSession));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4ODY1MQ=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NjY4NTQ1OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/managers/UserSessionManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOTo0MDozMVrOH-Ou8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOTozNTo0N1rOIByvdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxNTE1Mw==", "bodyText": "Would this work?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    kcSession.sessions().getOfflineUserSessionsStream(realm, user).collect(Collectors.toList())\n          \n          \n            \n                    kcSession.sessions().getOfflineUserSessionsStream(realm, user)\n          \n          \n            \n                            .map(userSession -> userSession.getAuthenticatedClientSessionByClient(client.getId()))\n          \n          \n            \n                            .filter(Objects::nonNull)\n          \n          \n            \n                            .collect(Collectors.toList())\n          \n          \n            \n                            .forEach(clientSession -> {\n          \n          \n            \n                                if (logger.isTraceEnabled()) {\n          \n          \n            \n                                    logger.tracef(\"Removing existing offline token for user '%s' and client '%s' .\",\n          \n          \n            \n                                            user.getUsername(), client.getClientId());\n          \n          \n            \n                                }\n          \n          \n            \n            \n          \n          \n            \n                                UserSessionModel userSession = clientSession.getUserSession();\n          \n          \n            \n                                clientSession.detachFromUserSession();\n          \n          \n            \n                                persister.removeClientSession(userSession.getId(), client.getId(), true);\n          \n          \n            \n                                checkOfflineUserSessionHasClientSessions(realm, user, userSession);\n          \n          \n            \n                                anyRemoved.set(true);\n          \n          \n            \n                            });", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535015153", "createdAt": "2020-12-03T09:40:31Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/managers/UserSessionManager.java", "diffHunk": "@@ -77,43 +78,42 @@ public UserSessionModel findOfflineUserSession(RealmModel realm, String userSess\n     }\n \n     public Set<ClientModel> findClientsWithOfflineToken(RealmModel realm, UserModel user) {\n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        Set<ClientModel> clients = new HashSet<>();\n-        for (UserSessionModel userSession : userSessions) {\n-            Set<String> clientIds = userSession.getAuthenticatedClientSessions().keySet();\n-            for (String clientUUID : clientIds) {\n-                ClientModel client = realm.getClientById(clientUUID);\n-                clients.add(client);\n-            }\n-        }\n-        return clients;\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user)\n+                .flatMap(userSession -> userSession.getAuthenticatedClientSessions().keySet().stream())\n+                .map(clientUUID -> realm.getClientById(clientUUID))\n+                .collect(Collectors.toSet());\n     }\n \n+    @Deprecated\n     public List<UserSessionModel> findOfflineSessions(RealmModel realm, UserModel user) {\n-        return kcSession.sessions().getOfflineUserSessions(realm, user);\n+        return this.findOfflineSessionsStream(realm, user).collect(Collectors.toList());\n+    }\n+\n+    public Stream<UserSessionModel> findOfflineSessionsStream(RealmModel realm, UserModel user) {\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user);\n     }\n \n     public boolean revokeOfflineToken(UserModel user, ClientModel client) {\n         RealmModel realm = client.getRealm();\n \n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        boolean anyRemoved = false;\n-        for (UserSessionModel userSession : userSessions) {\n-            AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(client.getId());\n-            if (clientSession != null) {\n-                if (logger.isTraceEnabled()) {\n-                    logger.tracef(\"Removing existing offline token for user '%s' and client '%s' .\",\n-                            user.getUsername(), client.getClientId());\n-                }\n-\n-                clientSession.detachFromUserSession();\n-                persister.removeClientSession(userSession.getId(), client.getId(), true);\n-                checkOfflineUserSessionHasClientSessions(realm, user, userSession);\n-                anyRemoved = true;\n-            }\n-        }\n-\n-        return anyRemoved;\n+        AtomicBoolean anyRemoved = new AtomicBoolean(false);\n+        kcSession.sessions().getOfflineUserSessionsStream(realm, user).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyMjU2MA==", "bodyText": "I don't think it would because after you map it you lose the reference to the userSession that is used in the forEach block. That is, the forEach in your suggestion has only a reference to a clientSession, the userSession is gone by then.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537722560", "createdAt": "2020-12-07T18:15:30Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/services/managers/UserSessionManager.java", "diffHunk": "@@ -77,43 +78,42 @@ public UserSessionModel findOfflineUserSession(RealmModel realm, String userSess\n     }\n \n     public Set<ClientModel> findClientsWithOfflineToken(RealmModel realm, UserModel user) {\n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        Set<ClientModel> clients = new HashSet<>();\n-        for (UserSessionModel userSession : userSessions) {\n-            Set<String> clientIds = userSession.getAuthenticatedClientSessions().keySet();\n-            for (String clientUUID : clientIds) {\n-                ClientModel client = realm.getClientById(clientUUID);\n-                clients.add(client);\n-            }\n-        }\n-        return clients;\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user)\n+                .flatMap(userSession -> userSession.getAuthenticatedClientSessions().keySet().stream())\n+                .map(clientUUID -> realm.getClientById(clientUUID))\n+                .collect(Collectors.toSet());\n     }\n \n+    @Deprecated\n     public List<UserSessionModel> findOfflineSessions(RealmModel realm, UserModel user) {\n-        return kcSession.sessions().getOfflineUserSessions(realm, user);\n+        return this.findOfflineSessionsStream(realm, user).collect(Collectors.toList());\n+    }\n+\n+    public Stream<UserSessionModel> findOfflineSessionsStream(RealmModel realm, UserModel user) {\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user);\n     }\n \n     public boolean revokeOfflineToken(UserModel user, ClientModel client) {\n         RealmModel realm = client.getRealm();\n \n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        boolean anyRemoved = false;\n-        for (UserSessionModel userSession : userSessions) {\n-            AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(client.getId());\n-            if (clientSession != null) {\n-                if (logger.isTraceEnabled()) {\n-                    logger.tracef(\"Removing existing offline token for user '%s' and client '%s' .\",\n-                            user.getUsername(), client.getClientId());\n-                }\n-\n-                clientSession.detachFromUserSession();\n-                persister.removeClientSession(userSession.getId(), client.getId(), true);\n-                checkOfflineUserSessionHasClientSessions(realm, user, userSession);\n-                anyRemoved = true;\n-            }\n-        }\n-\n-        return anyRemoved;\n+        AtomicBoolean anyRemoved = new AtomicBoolean(false);\n+        kcSession.sessions().getOfflineUserSessionsStream(realm, user).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxNTE1Mw=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0OTUyMg==", "bodyText": "I workaround it by UserSessionModel userSession = clientSession.getUserSession(); inside the forEach block. But anyway the pros of my suggestion are disputable :)\nWhatever works better for you.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r538449522", "createdAt": "2020-12-08T14:43:53Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/managers/UserSessionManager.java", "diffHunk": "@@ -77,43 +78,42 @@ public UserSessionModel findOfflineUserSession(RealmModel realm, String userSess\n     }\n \n     public Set<ClientModel> findClientsWithOfflineToken(RealmModel realm, UserModel user) {\n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        Set<ClientModel> clients = new HashSet<>();\n-        for (UserSessionModel userSession : userSessions) {\n-            Set<String> clientIds = userSession.getAuthenticatedClientSessions().keySet();\n-            for (String clientUUID : clientIds) {\n-                ClientModel client = realm.getClientById(clientUUID);\n-                clients.add(client);\n-            }\n-        }\n-        return clients;\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user)\n+                .flatMap(userSession -> userSession.getAuthenticatedClientSessions().keySet().stream())\n+                .map(clientUUID -> realm.getClientById(clientUUID))\n+                .collect(Collectors.toSet());\n     }\n \n+    @Deprecated\n     public List<UserSessionModel> findOfflineSessions(RealmModel realm, UserModel user) {\n-        return kcSession.sessions().getOfflineUserSessions(realm, user);\n+        return this.findOfflineSessionsStream(realm, user).collect(Collectors.toList());\n+    }\n+\n+    public Stream<UserSessionModel> findOfflineSessionsStream(RealmModel realm, UserModel user) {\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user);\n     }\n \n     public boolean revokeOfflineToken(UserModel user, ClientModel client) {\n         RealmModel realm = client.getRealm();\n \n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        boolean anyRemoved = false;\n-        for (UserSessionModel userSession : userSessions) {\n-            AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(client.getId());\n-            if (clientSession != null) {\n-                if (logger.isTraceEnabled()) {\n-                    logger.tracef(\"Removing existing offline token for user '%s' and client '%s' .\",\n-                            user.getUsername(), client.getClientId());\n-                }\n-\n-                clientSession.detachFromUserSession();\n-                persister.removeClientSession(userSession.getId(), client.getId(), true);\n-                checkOfflineUserSessionHasClientSessions(realm, user, userSession);\n-                anyRemoved = true;\n-            }\n-        }\n-\n-        return anyRemoved;\n+        AtomicBoolean anyRemoved = new AtomicBoolean(false);\n+        kcSession.sessions().getOfflineUserSessionsStream(realm, user).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxNTE1Mw=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MDgzNw==", "bodyText": "Ugh, missed that. I guess your approach works then, which at least makes the scope of the forEach block smaller. I'll give it a try.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r538750837", "createdAt": "2020-12-08T19:35:47Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/services/managers/UserSessionManager.java", "diffHunk": "@@ -77,43 +78,42 @@ public UserSessionModel findOfflineUserSession(RealmModel realm, String userSess\n     }\n \n     public Set<ClientModel> findClientsWithOfflineToken(RealmModel realm, UserModel user) {\n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        Set<ClientModel> clients = new HashSet<>();\n-        for (UserSessionModel userSession : userSessions) {\n-            Set<String> clientIds = userSession.getAuthenticatedClientSessions().keySet();\n-            for (String clientUUID : clientIds) {\n-                ClientModel client = realm.getClientById(clientUUID);\n-                clients.add(client);\n-            }\n-        }\n-        return clients;\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user)\n+                .flatMap(userSession -> userSession.getAuthenticatedClientSessions().keySet().stream())\n+                .map(clientUUID -> realm.getClientById(clientUUID))\n+                .collect(Collectors.toSet());\n     }\n \n+    @Deprecated\n     public List<UserSessionModel> findOfflineSessions(RealmModel realm, UserModel user) {\n-        return kcSession.sessions().getOfflineUserSessions(realm, user);\n+        return this.findOfflineSessionsStream(realm, user).collect(Collectors.toList());\n+    }\n+\n+    public Stream<UserSessionModel> findOfflineSessionsStream(RealmModel realm, UserModel user) {\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user);\n     }\n \n     public boolean revokeOfflineToken(UserModel user, ClientModel client) {\n         RealmModel realm = client.getRealm();\n \n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        boolean anyRemoved = false;\n-        for (UserSessionModel userSession : userSessions) {\n-            AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(client.getId());\n-            if (clientSession != null) {\n-                if (logger.isTraceEnabled()) {\n-                    logger.tracef(\"Removing existing offline token for user '%s' and client '%s' .\",\n-                            user.getUsername(), client.getClientId());\n-                }\n-\n-                clientSession.detachFromUserSession();\n-                persister.removeClientSession(userSession.getId(), client.getId(), true);\n-                checkOfflineUserSessionHasClientSessions(realm, user, userSession);\n-                anyRemoved = true;\n-            }\n-        }\n-\n-        return anyRemoved;\n+        AtomicBoolean anyRemoved = new AtomicBoolean(false);\n+        kcSession.sessions().getOfflineUserSessionsStream(realm, user).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxNTE1Mw=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1Njk0MDA4OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMDoxOToxOFrOH-RVwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMTo0ODo1MlrOIA8PGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA1Nzg1OA==", "bodyText": "Maybe this could work? WDYT?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    checkAccountApiEnabled();\n          \n          \n            \n                    public Stream<ClientRepresentation> applications(@QueryParam(\"name\") String name) {\n          \n          \n            \n                    checkAccountApiEnabled();\n          \n          \n            \n                    auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_APPLICATIONS);\n          \n          \n            \n            \n          \n          \n            \n                    List<String> inUseClients = new LinkedList<>();\n          \n          \n            \n                    Stream<ClientModel> clients = session.sessions().getUserSessionsStream(realm, user)\n          \n          \n            \n                            .flatMap(s -> s.getAuthenticatedClientSessions().values().stream())\n          \n          \n            \n                            .map(AuthenticatedClientSessionModel::getClient)\n          \n          \n            \n                            .peek(client -> inUseClients.add(client.getClientId()));\n          \n          \n            \n            \n          \n          \n            \n                    List<String> offlineClients = new LinkedList<>();\n          \n          \n            \n                    clients = Streams.concat(session.sessions().getOfflineUserSessionsStream(realm, user)\n          \n          \n            \n                            .flatMap(s -> s.getAuthenticatedClientSessions().values().stream())\n          \n          \n            \n                            .map(AuthenticatedClientSessionModel::getClient)\n          \n          \n            \n                            .peek(client -> offlineClients.add(client.getClientId())), clients).distinct();\n          \n          \n            \n            \n          \n          \n            \n                    Map<String, UserConsentModel> consentModels = new HashMap<>();\n          \n          \n            \n                    clients = Streams.concat(session.users().getConsentsStream(realm, user.getId())\n          \n          \n            \n                            .peek(consent -> consentModels.put(consent.getClient().getClientId(), consent))\n          \n          \n            \n                            .map(UserConsentModel::getClient), clients).distinct();\n          \n          \n            \n            \n          \n          \n            \n                    clients = Streams.concat(realm.getAlwaysDisplayInConsoleClientsStream(), clients).distinct();\n          \n          \n            \n            \n          \n          \n            \n                    return clients.filter(client -> !client.isBearerOnly() && client.getBaseUrl() != null && !client.getBaseUrl().isEmpty())\n          \n          \n            \n                            .filter(client -> matches(client, name))\n          \n          \n            \n                            .map(client -> modelToRepresentation(client, inUseClients, offlineClients, consentModels));\n          \n          \n            \n                }", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535057858", "createdAt": "2020-12-03T10:19:18Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java", "diffHunk": "@@ -405,26 +405,20 @@ public LinkedAccountsResource linkedAccounts() {\n         checkAccountApiEnabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3MDkwNQ==", "bodyText": "Yeah, I like this approach", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537770905", "createdAt": "2020-12-07T19:29:25Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java", "diffHunk": "@@ -405,26 +405,20 @@ public LinkedAccountsResource linkedAccounts() {\n         checkAccountApiEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA1Nzg1OA=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1NzgxNw==", "bodyText": "EDIT: this breaks several tests in AccountRestServiceTest because the intermediary inUseClients, offlineClients and consentModels are not fully formed when the last map operation is performed. As the stream elements are processed one by one these intermediary collections that are needed to convert to ClientRepresentation are not totally in place by the time the modelToRepresentation call is made.\nBecause of that I had to collect each of the intermediary streams in order to force the processing of the intermediary collections and ensure they are fully formed when modelToRepresentation is called on each client.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537857817", "createdAt": "2020-12-07T21:48:52Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java", "diffHunk": "@@ -405,26 +405,20 @@ public LinkedAccountsResource linkedAccounts() {\n         checkAccountApiEnabled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA1Nzg1OA=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NzIxMjM2OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/keycloak/services/resources/account/SessionResource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMTowMTowM1rOH-UHDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo1NzozMlrOIA1q4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEwMzI0NA==", "bodyText": "Maybe this could be slightly changed and return stream instead a collection?\nSomething like distinctByKey in this example.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535103244", "createdAt": "2020-12-03T11:01:03Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/account/SessionResource.java", "diffHunk": "@@ -88,33 +89,31 @@ public SessionResource(KeycloakSession session, Auth auth, HttpRequest request)\n     @NoCache\n     public Collection<DeviceRepresentation> devices() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MDI0MA==", "bodyText": "We can change it to stream, but I don't see how to make use of something like you mentioned. If I could map the session into devices then I could filter the devices as shown in that example, but then I would no longer have a reference to the session and it is needed to properly create the device representation.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537750240", "createdAt": "2020-12-07T18:57:32Z", "author": {"login": "sguilhen"}, "path": "services/src/main/java/org/keycloak/services/resources/account/SessionResource.java", "diffHunk": "@@ -88,33 +89,31 @@ public SessionResource(KeycloakSession session, Auth auth, HttpRequest request)\n     @NoCache\n     public Collection<DeviceRepresentation> devices() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEwMzI0NA=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NzUyMTUyOnYy", "diffSide": "RIGHT", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMTo1MDoxN1rOH-XQtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoxODo1N1rOIA0HcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE1NDg2OQ==", "bodyText": "assertNotEquals could be used", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535154869", "createdAt": "2020-12-03T11:50:17Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderTest.java", "diffHunk": "@@ -773,11 +778,12 @@ public static void testOnUserRemoved(KeycloakSession session) {\n \n         session.userStorageManager().removeUser(realm, user1);\n \n-        assertTrue(session.sessions().getUserSessions(realm, user1).isEmpty());\n+        assertEquals(0, session.sessions().getUserSessionsStream(realm, user1).count());\n \n         session.getTransactionManager().commit();\n \n-        assertFalse(session.sessions().getUserSessions(realm, session.users().getUserByUsername(\"user2\", realm)).isEmpty());\n+        assertFalse(session.sessions().getUserSessionsStream(realm, session.users().getUserByUsername(\"user2\", realm))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNDc4NQ==", "bodyText": "Changed", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537724785", "createdAt": "2020-12-07T18:18:57Z", "author": {"login": "sguilhen"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderTest.java", "diffHunk": "@@ -773,11 +778,12 @@ public static void testOnUserRemoved(KeycloakSession session) {\n \n         session.userStorageManager().removeUser(realm, user1);\n \n-        assertTrue(session.sessions().getUserSessions(realm, user1).isEmpty());\n+        assertEquals(0, session.sessions().getUserSessionsStream(realm, user1).count());\n \n         session.getTransactionManager().commit();\n \n-        assertFalse(session.sessions().getUserSessions(realm, session.users().getUserByUsername(\"user2\", realm)).isEmpty());\n+        assertFalse(session.sessions().getUserSessionsStream(realm, session.users().getUserByUsername(\"user2\", realm))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE1NDg2OQ=="}, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NDEyNTI3OnYy", "diffSide": "RIGHT", "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDozNDoyMlrOH_ThEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODoxNzozMlrOIA0D_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MjA5Nw==", "bodyText": "Would the following work as well?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return StreamSupport.stream(Spliterators.spliteratorUnknownSize(cache.entrySet().stream().iterator(), 0), true)\n          \n          \n            \n                    return StreamSupport.stream(cache.entrySet().stream().spliterator(), true)", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r536142097", "createdAt": "2020-12-04T14:34:22Z", "author": {"login": "hmlnarik"}, "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -270,25 +272,16 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool\n     }\n \n \n-    protected List<UserSessionModel> getUserSessions(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n+    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n         Cache<String, SessionEntityWrapper<UserSessionEntity>> cache = getCache(offline);\n-\n         cache = CacheDecorators.skipCacheLoaders(cache);\n \n-        Stream<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> cacheStream = cache.entrySet().stream();\n-\n-        List<UserSessionModel> resultSessions = new LinkedList<>();\n-\n-        Iterator<UserSessionEntity> itr = cacheStream.filter(predicate)\n+        // return a stream that 'wraps' the infinispan cache stream so that the cache stream's elements are read one by one\n+        // and then filtered/mapped locally to avoid serialization issues when trying to manipulate the cache stream directly.\n+        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(cache.entrySet().stream().iterator(), 0), true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae3c85bf7f8c202627bc8d3f3302c4179d8e522"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyMzkwMA==", "bodyText": "Yes, it does. Not sure why I haven't tried it first.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537723900", "createdAt": "2020-12-07T18:17:32Z", "author": {"login": "sguilhen"}, "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -270,25 +272,16 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool\n     }\n \n \n-    protected List<UserSessionModel> getUserSessions(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n+    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n         Cache<String, SessionEntityWrapper<UserSessionEntity>> cache = getCache(offline);\n-\n         cache = CacheDecorators.skipCacheLoaders(cache);\n \n-        Stream<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> cacheStream = cache.entrySet().stream();\n-\n-        List<UserSessionModel> resultSessions = new LinkedList<>();\n-\n-        Iterator<UserSessionEntity> itr = cacheStream.filter(predicate)\n+        // return a stream that 'wraps' the infinispan cache stream so that the cache stream's elements are read one by one\n+        // and then filtered/mapped locally to avoid serialization issues when trying to manipulate the cache stream directly.\n+        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(cache.entrySet().stream().iterator(), 0), true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MjA5Nw=="}, "originalCommit": {"oid": "6ae3c85bf7f8c202627bc8d3f3302c4179d8e522"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDcwMzI4OnYy", "diffSide": "RIGHT", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODoxNjoxN1rOICHzLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNjo0ODozMlrOIC5O1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NTg1Mw==", "bodyText": "Maybe we can replace collect + forEach with collectToMap + putAll\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        currentSession.sessions().getUserSessionsStream(realm, testApp).collect(Collectors.toList())\n          \n          \n            \n                        offlineSessions.putAll(currentSession.sessions().getUserSessionsStream(realm, testApp)\n          \n          \n            \n                                .collect(Collectors.toMap(UserSessionModel::getId,\n          \n          \n            \n                                        userSession -> createOfflineSessionIncludeClientSessions(currentSession, userSession))));", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539095853", "createdAt": "2020-12-09T08:16:17Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "diffHunk": "@@ -112,10 +113,8 @@ public void testOfflineSessionsCrud(KeycloakSession session) {\n             // Key is userSession ID, values are client UUIDS\n             // Persist 3 created userSessions and clientSessions as offline\n             ClientModel testApp = realm.getClientByClientId(\"test-app\");\n-            List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp);\n-            for (UserSessionModel userSession : userSessions) {\n-                offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession));\n-            }\n+            currentSession.sessions().getUserSessionsStream(realm, testApp).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgwODIwOA==", "bodyText": "It doesn't work in this case because createOfflineSessionIncludeClientSessions is creating new sessions while the stream is still being processed, which leads to concurrent modification exception. The prior approach collects the elements first and then attempts to add new offline sessions which now doesn't make changes to the stream source.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539808208", "createdAt": "2020-12-10T03:01:33Z", "author": {"login": "sguilhen"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "diffHunk": "@@ -112,10 +113,8 @@ public void testOfflineSessionsCrud(KeycloakSession session) {\n             // Key is userSession ID, values are client UUIDS\n             // Persist 3 created userSessions and clientSessions as offline\n             ClientModel testApp = realm.getClientByClientId(\"test-app\");\n-            List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp);\n-            for (UserSessionModel userSession : userSessions) {\n-                offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession));\n-            }\n+            currentSession.sessions().getUserSessionsStream(realm, testApp).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NTg1Mw=="}, "originalCommit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkwNTc1MA==", "bodyText": "I see. Thank you for the explanation.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539905750", "createdAt": "2020-12-10T06:48:32Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "diffHunk": "@@ -112,10 +113,8 @@ public void testOfflineSessionsCrud(KeycloakSession session) {\n             // Key is userSession ID, values are client UUIDS\n             // Persist 3 created userSessions and clientSessions as offline\n             ClientModel testApp = realm.getClientByClientId(\"test-app\");\n-            List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp);\n-            for (UserSessionModel userSession : userSessions) {\n-                offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession));\n-            }\n+            currentSession.sessions().getUserSessionsStream(realm, testApp).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NTg1Mw=="}, "originalCommit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDcwNjAzOnYy", "diffSide": "RIGHT", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODoxNjo0NVrOICH0oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMzowMjowOFrOICzS4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NjIyNA==", "bodyText": "Again collectToMap + putAll", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539096224", "createdAt": "2020-12-09T08:16:45Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "diffHunk": "@@ -462,10 +463,8 @@ public void testExpired(KeycloakSession session) {\n \n                 // Persist 3 created userSessions and clientSessions as offline\n                 testApp[0] = realm.getClientByClientId(\"test-app\");\n-                List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp[0]);\n-                for (UserSessionModel userSession : userSessions) {\n-                    offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession));\n-                }\n+                currentSession.sessions().getUserSessionsStream(realm, testApp[0]).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgwODQ4Mg==", "bodyText": "Same as above. Test fails because it cannot create the offline sessions while the stream is still \"live\"", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539808482", "createdAt": "2020-12-10T03:02:08Z", "author": {"login": "sguilhen"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "diffHunk": "@@ -462,10 +463,8 @@ public void testExpired(KeycloakSession session) {\n \n                 // Persist 3 created userSessions and clientSessions as offline\n                 testApp[0] = realm.getClientByClientId(\"test-app\");\n-                List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp[0]);\n-                for (UserSessionModel userSession : userSessions) {\n-                    offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession));\n-                }\n+                currentSession.sessions().getUserSessionsStream(realm, testApp[0]).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NjIyNA=="}, "originalCommit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3223, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}