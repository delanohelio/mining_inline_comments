{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNDkwMjIz", "number": 7652, "title": "[KEYCLOAK-16508] Complement methods for accessing user sessions with \u2026", "bodyText": "\u2026Stream variants", "createdAt": "2020-12-01T18:23:15Z", "url": "https://github.com/keycloak/keycloak/pull/7652", "merged": true, "mergeCommit": {"oid": "d6422e415c02e6831a9268b396ea2f8cf554f3f1"}, "closed": true, "closedAt": "2020-12-15T18:52:32Z", "author": {"login": "sguilhen"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiNfEtABqjQwNjIwMjM2OTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmWhhYgFqTU1MjIzMzAwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "122656847e12b1d13f7a2dafbe8bd707b2998bf7", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/122656847e12b1d13f7a2dafbe8bd707b2998bf7", "committedDate": "2020-12-01T18:12:16Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}, "afterCommit": {"oid": "dbcce24f889fb3d5629648c1d13d3e856e101d7e", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/dbcce24f889fb3d5629648c1d13d3e856e101d7e", "committedDate": "2020-12-02T12:13:03Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dbcce24f889fb3d5629648c1d13d3e856e101d7e", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/dbcce24f889fb3d5629648c1d13d3e856e101d7e", "committedDate": "2020-12-02T12:13:03Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}, "afterCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/a24ef953d17ea87db7beefe8c25e410c63b53296", "committedDate": "2020-12-03T01:15:14Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNjk1MTM2", "url": "https://github.com/keycloak/keycloak/pull/7652#pullrequestreview-543695136", "createdAt": "2020-12-03T08:11:01Z", "commit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwODoxMTowMVrOH-Ge-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMTo1MDoxN1rOH-XQtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg3OTk5NQ==", "bodyText": "I'm wondering whether it's nicer to avoid the iterator:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Iterator<UserSessionEntity> itr = cache.entrySet().stream()\n          \n          \n            \n                    List<UserSessionModel> resultSessions = cache.entrySet().stream()\n          \n          \n            \n                            .filter(predicate)\n          \n          \n            \n                            .map(Mappers.userSessionEntity())\n          \n          \n            \n                            .map(entity -> wrap(realm, entity, offline))\n          \n          \n            \n                            .collect(Collectors.toList());\n          \n          \n            \n                    \n          \n          \n            \n                    return resultSessions.stream();", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534879995", "createdAt": "2020-12-03T08:11:01Z", "author": {"login": "martin-kanis"}, "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -270,25 +270,25 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool\n     }\n \n \n-    protected List<UserSessionModel> getUserSessions(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n+    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n         Cache<String, SessionEntityWrapper<UserSessionEntity>> cache = getCache(offline);\n-\n         cache = CacheDecorators.skipCacheLoaders(cache);\n \n-        Stream<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> cacheStream = cache.entrySet().stream();\n-\n-        List<UserSessionModel> resultSessions = new LinkedList<>();\n-\n-        Iterator<UserSessionEntity> itr = cacheStream.filter(predicate)\n+        Iterator<UserSessionEntity> itr = cache.entrySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg4MDI1MA==", "bodyText": "Same note as above.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534880250", "createdAt": "2020-12-03T08:11:09Z", "author": {"login": "martin-kanis"}, "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -357,16 +357,17 @@ public UserSessionModel getUserSessionByBrokerSessionId(RealmModel realm, String\n             stream = stream.limit(maxResults);\n         }\n \n-        final List<UserSessionModel> sessions = new LinkedList<>();\n+        // while it looks natural to just do another map(entity -> wrap(realm, entity, offline)) on the stream and return it\n+        // directly, we need to pre-consume the stream from the infinispan cache using an iterator to avoid a serialization\n+        // error from infinispan when the stream is later consumed (by e.g. a call to collect or forEach) in certain cross-dc\n+        // scenarios.\n+        List<UserSessionModel> resultSessions = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4NjE0MQ==", "bodyText": "Star import.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534986141", "createdAt": "2020-12-03T09:16:00Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java", "diffHunk": "@@ -98,6 +99,8 @@\n import org.w3c.dom.Element;\n \n import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4NjIyNQ==", "bodyText": "Could you please extract this forEach block to a separate method for better readability?", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534986225", "createdAt": "2020-12-03T09:16:06Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java", "diffHunk": "@@ -296,22 +299,22 @@ protected Response handleSamlRequest(String samlRequest, String relayState) {\n         protected Response logoutRequest(LogoutRequestType request, String relayState) {\n             String brokerUserId = config.getAlias() + \".\" + request.getNameID().getValue();\n             if (request.getSessionIndex() == null || request.getSessionIndex().isEmpty()) {\n-                List<UserSessionModel> userSessions = session.sessions().getUserSessionByBrokerUserId(realm, brokerUserId);\n-                for (UserSessionModel userSession : userSessions) {\n-                    if (userSession.getState() == UserSessionModel.State.LOGGING_OUT || userSession.getState() == UserSessionModel.State.LOGGED_OUT) {\n-                        continue;\n-                    }\n-\n-                    for(Iterator<SamlAuthenticationPreprocessor> it = SamlSessionUtils.getSamlAuthenticationPreprocessorIterator(session); it.hasNext();) {\n-                        request = it.next().beforeProcessingLogoutRequest(request, userSession, null);\n-                    }\n-\n-                    try {\n-                        AuthenticationManager.backchannelLogout(session, realm, userSession, session.getContext().getUri(), clientConnection, headers, false);\n-                    } catch (Exception e) {\n-                        logger.warn(\"failed to do backchannel logout for userSession\", e);\n-                    }\n-                }\n+                AtomicReference<LogoutRequestType> ref = new AtomicReference<>(request);\n+                session.sessions().getUserSessionByBrokerUserIdStream(realm, brokerUserId)\n+                        .filter(userSession -> userSession.getState() != UserSessionModel.State.LOGGING_OUT &&\n+                                userSession.getState() != UserSessionModel.State.LOGGED_OUT)\n+                        .collect(Collectors.toList()) // collect to avoid concurrent modification as backchannelLogout removes the user sessions.\n+                        .forEach(userSession -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4ODY1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .forEach(offlineUserSession -> userSessionManager.revokeOfflineUserSession(offlineUserSession));\n          \n          \n            \n                            .forEach(userSessionManager::revokeOfflineUserSession);", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534988651", "createdAt": "2020-12-03T09:19:34Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java", "diffHunk": "@@ -345,34 +345,29 @@ private BackchannelLogoutResponse backchannelLogoutFederatedUserId(String federa\n         BackchannelLogoutResponse backchannelLogoutResponse = new BackchannelLogoutResponse();\n         backchannelLogoutResponse.setLocalLogoutSucceeded(true);\n         identityProviderAliases.forEach(identityProviderAlias -> {\n-            List<UserSessionModel> userSessions = session.sessions().getUserSessionByBrokerUserId(realm,\n-                    identityProviderAlias + \".\" + federatedUserId);\n \n             if (logoutOfflineSessions) {\n                 logoutOfflineUserSessions(identityProviderAlias + \".\" + federatedUserId);\n             }\n \n-            for (UserSessionModel userSession : userSessions) {\n-                BackchannelLogoutResponse userBackchannelLogoutResponse;\n-                userBackchannelLogoutResponse = logoutUserSession(userSession);\n-                backchannelLogoutResponse.setLocalLogoutSucceeded(backchannelLogoutResponse.getLocalLogoutSucceeded()\n-                        && userBackchannelLogoutResponse.getLocalLogoutSucceeded());\n-                userBackchannelLogoutResponse.getClientResponses()\n-                        .forEach(backchannelLogoutResponse::addClientResponses);\n-            }\n+            session.sessions().getUserSessionByBrokerUserIdStream(realm, identityProviderAlias + \".\" + federatedUserId)\n+                    .collect(Collectors.toList()) // collect to avoid concurrent modification as backchannelLogout removes the user sessions.\n+                    .forEach(userSession -> {\n+                        BackchannelLogoutResponse userBackchannelLogoutResponse = this.logoutUserSession(userSession);\n+                        backchannelLogoutResponse.setLocalLogoutSucceeded(backchannelLogoutResponse.getLocalLogoutSucceeded()\n+                                && userBackchannelLogoutResponse.getLocalLogoutSucceeded());\n+                        userBackchannelLogoutResponse.getClientResponses()\n+                                .forEach(backchannelLogoutResponse::addClientResponses);\n+                    });\n         });\n \n         return backchannelLogoutResponse;\n     }\n \n     private void logoutOfflineUserSessions(String brokerUserId) {\n-        List<UserSessionModel> offlineUserSessions =\n-                session.sessions().getOfflineUserSessionByBrokerUserId(realm, brokerUserId);\n-\n         UserSessionManager userSessionManager = new UserSessionManager(session);\n-        for (UserSessionModel offlineUserSession : offlineUserSessions) {\n-            userSessionManager.revokeOfflineUserSession(offlineUserSession);\n-        }\n+        session.sessions().getOfflineUserSessionByBrokerUserIdStream(realm, brokerUserId).collect(Collectors.toList())\n+                .forEach(offlineUserSession -> userSessionManager.revokeOfflineUserSession(offlineUserSession));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxNTE1Mw==", "bodyText": "Would this work?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    kcSession.sessions().getOfflineUserSessionsStream(realm, user).collect(Collectors.toList())\n          \n          \n            \n                    kcSession.sessions().getOfflineUserSessionsStream(realm, user)\n          \n          \n            \n                            .map(userSession -> userSession.getAuthenticatedClientSessionByClient(client.getId()))\n          \n          \n            \n                            .filter(Objects::nonNull)\n          \n          \n            \n                            .collect(Collectors.toList())\n          \n          \n            \n                            .forEach(clientSession -> {\n          \n          \n            \n                                if (logger.isTraceEnabled()) {\n          \n          \n            \n                                    logger.tracef(\"Removing existing offline token for user '%s' and client '%s' .\",\n          \n          \n            \n                                            user.getUsername(), client.getClientId());\n          \n          \n            \n                                }\n          \n          \n            \n            \n          \n          \n            \n                                UserSessionModel userSession = clientSession.getUserSession();\n          \n          \n            \n                                clientSession.detachFromUserSession();\n          \n          \n            \n                                persister.removeClientSession(userSession.getId(), client.getId(), true);\n          \n          \n            \n                                checkOfflineUserSessionHasClientSessions(realm, user, userSession);\n          \n          \n            \n                                anyRemoved.set(true);\n          \n          \n            \n                            });", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535015153", "createdAt": "2020-12-03T09:40:31Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/managers/UserSessionManager.java", "diffHunk": "@@ -77,43 +78,42 @@ public UserSessionModel findOfflineUserSession(RealmModel realm, String userSess\n     }\n \n     public Set<ClientModel> findClientsWithOfflineToken(RealmModel realm, UserModel user) {\n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        Set<ClientModel> clients = new HashSet<>();\n-        for (UserSessionModel userSession : userSessions) {\n-            Set<String> clientIds = userSession.getAuthenticatedClientSessions().keySet();\n-            for (String clientUUID : clientIds) {\n-                ClientModel client = realm.getClientById(clientUUID);\n-                clients.add(client);\n-            }\n-        }\n-        return clients;\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user)\n+                .flatMap(userSession -> userSession.getAuthenticatedClientSessions().keySet().stream())\n+                .map(clientUUID -> realm.getClientById(clientUUID))\n+                .collect(Collectors.toSet());\n     }\n \n+    @Deprecated\n     public List<UserSessionModel> findOfflineSessions(RealmModel realm, UserModel user) {\n-        return kcSession.sessions().getOfflineUserSessions(realm, user);\n+        return this.findOfflineSessionsStream(realm, user).collect(Collectors.toList());\n+    }\n+\n+    public Stream<UserSessionModel> findOfflineSessionsStream(RealmModel realm, UserModel user) {\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user);\n     }\n \n     public boolean revokeOfflineToken(UserModel user, ClientModel client) {\n         RealmModel realm = client.getRealm();\n \n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        boolean anyRemoved = false;\n-        for (UserSessionModel userSession : userSessions) {\n-            AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(client.getId());\n-            if (clientSession != null) {\n-                if (logger.isTraceEnabled()) {\n-                    logger.tracef(\"Removing existing offline token for user '%s' and client '%s' .\",\n-                            user.getUsername(), client.getClientId());\n-                }\n-\n-                clientSession.detachFromUserSession();\n-                persister.removeClientSession(userSession.getId(), client.getId(), true);\n-                checkOfflineUserSessionHasClientSessions(realm, user, userSession);\n-                anyRemoved = true;\n-            }\n-        }\n-\n-        return anyRemoved;\n+        AtomicBoolean anyRemoved = new AtomicBoolean(false);\n+        kcSession.sessions().getOfflineUserSessionsStream(realm, user).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA1Nzg1OA==", "bodyText": "Maybe this could work? WDYT?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    checkAccountApiEnabled();\n          \n          \n            \n                    public Stream<ClientRepresentation> applications(@QueryParam(\"name\") String name) {\n          \n          \n            \n                    checkAccountApiEnabled();\n          \n          \n            \n                    auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_APPLICATIONS);\n          \n          \n            \n            \n          \n          \n            \n                    List<String> inUseClients = new LinkedList<>();\n          \n          \n            \n                    Stream<ClientModel> clients = session.sessions().getUserSessionsStream(realm, user)\n          \n          \n            \n                            .flatMap(s -> s.getAuthenticatedClientSessions().values().stream())\n          \n          \n            \n                            .map(AuthenticatedClientSessionModel::getClient)\n          \n          \n            \n                            .peek(client -> inUseClients.add(client.getClientId()));\n          \n          \n            \n            \n          \n          \n            \n                    List<String> offlineClients = new LinkedList<>();\n          \n          \n            \n                    clients = Streams.concat(session.sessions().getOfflineUserSessionsStream(realm, user)\n          \n          \n            \n                            .flatMap(s -> s.getAuthenticatedClientSessions().values().stream())\n          \n          \n            \n                            .map(AuthenticatedClientSessionModel::getClient)\n          \n          \n            \n                            .peek(client -> offlineClients.add(client.getClientId())), clients).distinct();\n          \n          \n            \n            \n          \n          \n            \n                    Map<String, UserConsentModel> consentModels = new HashMap<>();\n          \n          \n            \n                    clients = Streams.concat(session.users().getConsentsStream(realm, user.getId())\n          \n          \n            \n                            .peek(consent -> consentModels.put(consent.getClient().getClientId(), consent))\n          \n          \n            \n                            .map(UserConsentModel::getClient), clients).distinct();\n          \n          \n            \n            \n          \n          \n            \n                    clients = Streams.concat(realm.getAlwaysDisplayInConsoleClientsStream(), clients).distinct();\n          \n          \n            \n            \n          \n          \n            \n                    return clients.filter(client -> !client.isBearerOnly() && client.getBaseUrl() != null && !client.getBaseUrl().isEmpty())\n          \n          \n            \n                            .filter(client -> matches(client, name))\n          \n          \n            \n                            .map(client -> modelToRepresentation(client, inUseClients, offlineClients, consentModels));\n          \n          \n            \n                }", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535057858", "createdAt": "2020-12-03T10:19:18Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java", "diffHunk": "@@ -405,26 +405,20 @@ public LinkedAccountsResource linkedAccounts() {\n         checkAccountApiEnabled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEwMzI0NA==", "bodyText": "Maybe this could be slightly changed and return stream instead a collection?\nSomething like distinctByKey in this example.", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535103244", "createdAt": "2020-12-03T11:01:03Z", "author": {"login": "martin-kanis"}, "path": "services/src/main/java/org/keycloak/services/resources/account/SessionResource.java", "diffHunk": "@@ -88,33 +89,31 @@ public SessionResource(KeycloakSession session, Auth auth, HttpRequest request)\n     @NoCache\n     public Collection<DeviceRepresentation> devices() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE1NDg2OQ==", "bodyText": "assertNotEquals could be used", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535154869", "createdAt": "2020-12-03T11:50:17Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderTest.java", "diffHunk": "@@ -773,11 +778,12 @@ public static void testOnUserRemoved(KeycloakSession session) {\n \n         session.userStorageManager().removeUser(realm, user1);\n \n-        assertTrue(session.sessions().getUserSessions(realm, user1).isEmpty());\n+        assertEquals(0, session.sessions().getUserSessionsStream(realm, user1).count());\n \n         session.getTransactionManager().commit();\n \n-        assertFalse(session.sessions().getUserSessions(realm, session.users().getUserByUsername(\"user2\", realm)).isEmpty());\n+        assertFalse(session.sessions().getUserSessionsStream(realm, session.users().getUserByUsername(\"user2\", realm))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296"}, "originalPosition": 94}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/a24ef953d17ea87db7beefe8c25e410c63b53296", "committedDate": "2020-12-03T01:15:14Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}, "afterCommit": {"oid": "6ae3c85bf7f8c202627bc8d3f3302c4179d8e522", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/6ae3c85bf7f8c202627bc8d3f3302c4179d8e522", "committedDate": "2020-12-04T13:07:07Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MDEwNTk2", "url": "https://github.com/keycloak/keycloak/pull/7652#pullrequestreview-545010596", "createdAt": "2020-12-04T14:34:22Z", "commit": {"oid": "6ae3c85bf7f8c202627bc8d3f3302c4179d8e522"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDozNDoyMlrOH_ThEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNDozNDoyMlrOH_ThEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MjA5Nw==", "bodyText": "Would the following work as well?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return StreamSupport.stream(Spliterators.spliteratorUnknownSize(cache.entrySet().stream().iterator(), 0), true)\n          \n          \n            \n                    return StreamSupport.stream(cache.entrySet().stream().spliterator(), true)", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r536142097", "createdAt": "2020-12-04T14:34:22Z", "author": {"login": "hmlnarik"}, "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -270,25 +272,16 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool\n     }\n \n \n-    protected List<UserSessionModel> getUserSessions(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n+    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n         Cache<String, SessionEntityWrapper<UserSessionEntity>> cache = getCache(offline);\n-\n         cache = CacheDecorators.skipCacheLoaders(cache);\n \n-        Stream<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> cacheStream = cache.entrySet().stream();\n-\n-        List<UserSessionModel> resultSessions = new LinkedList<>();\n-\n-        Iterator<UserSessionEntity> itr = cacheStream.filter(predicate)\n+        // return a stream that 'wraps' the infinispan cache stream so that the cache stream's elements are read one by one\n+        // and then filtered/mapped locally to avoid serialization issues when trying to manipulate the cache stream directly.\n+        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(cache.entrySet().stream().iterator(), 0), true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae3c85bf7f8c202627bc8d3f3302c4179d8e522"}, "originalPosition": 33}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6ae3c85bf7f8c202627bc8d3f3302c4179d8e522", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/6ae3c85bf7f8c202627bc8d3f3302c4179d8e522", "committedDate": "2020-12-04T13:07:07Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}, "afterCommit": {"oid": "ebc62865c2b9116d4f430072517a9c9fcd6ad31c", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/ebc62865c2b9116d4f430072517a9c9fcd6ad31c", "committedDate": "2020-12-07T16:03:53Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ebc62865c2b9116d4f430072517a9c9fcd6ad31c", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/ebc62865c2b9116d4f430072517a9c9fcd6ad31c", "committedDate": "2020-12-07T16:03:53Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}, "afterCommit": {"oid": "ec0fc5930bbbc5cfd9a84daa72cdb8d6798696e5", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/ec0fc5930bbbc5cfd9a84daa72cdb8d6798696e5", "committedDate": "2020-12-07T19:32:02Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec0fc5930bbbc5cfd9a84daa72cdb8d6798696e5", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/ec0fc5930bbbc5cfd9a84daa72cdb8d6798696e5", "committedDate": "2020-12-07T19:32:02Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}, "afterCommit": {"oid": "93c87a3571f35763cbf20d49baca938fd94a978a", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/93c87a3571f35763cbf20d49baca938fd94a978a", "committedDate": "2020-12-07T20:39:38Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93c87a3571f35763cbf20d49baca938fd94a978a", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/93c87a3571f35763cbf20d49baca938fd94a978a", "committedDate": "2020-12-07T20:39:38Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}, "afterCommit": {"oid": "aedb9753638c2bc9a7574fb4a4fe78d7cdac3857", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/aedb9753638c2bc9a7574fb4a4fe78d7cdac3857", "committedDate": "2020-12-07T21:49:28Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aedb9753638c2bc9a7574fb4a4fe78d7cdac3857", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/aedb9753638c2bc9a7574fb4a4fe78d7cdac3857", "committedDate": "2020-12-07T21:49:28Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}, "afterCommit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/4792c9816231da91a7bd69608afdcf0fec11147d", "committedDate": "2020-12-07T23:22:21Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3OTMzMTk5", "url": "https://github.com/keycloak/keycloak/pull/7652#pullrequestreview-547933199", "createdAt": "2020-12-09T08:16:17Z", "commit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODoxNjoxN1rOICHzLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODoxNjo0NVrOICH0oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NTg1Mw==", "bodyText": "Maybe we can replace collect + forEach with collectToMap + putAll\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        currentSession.sessions().getUserSessionsStream(realm, testApp).collect(Collectors.toList())\n          \n          \n            \n                        offlineSessions.putAll(currentSession.sessions().getUserSessionsStream(realm, testApp)\n          \n          \n            \n                                .collect(Collectors.toMap(UserSessionModel::getId,\n          \n          \n            \n                                        userSession -> createOfflineSessionIncludeClientSessions(currentSession, userSession))));", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539095853", "createdAt": "2020-12-09T08:16:17Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "diffHunk": "@@ -112,10 +113,8 @@ public void testOfflineSessionsCrud(KeycloakSession session) {\n             // Key is userSession ID, values are client UUIDS\n             // Persist 3 created userSessions and clientSessions as offline\n             ClientModel testApp = realm.getClientByClientId(\"test-app\");\n-            List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp);\n-            for (UserSessionModel userSession : userSessions) {\n-                offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession));\n-            }\n+            currentSession.sessions().getUserSessionsStream(realm, testApp).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NjIyNA==", "bodyText": "Again collectToMap + putAll", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539096224", "createdAt": "2020-12-09T08:16:45Z", "author": {"login": "martin-kanis"}, "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "diffHunk": "@@ -462,10 +463,8 @@ public void testExpired(KeycloakSession session) {\n \n                 // Persist 3 created userSessions and clientSessions as offline\n                 testApp[0] = realm.getClientByClientId(\"test-app\");\n-                List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp[0]);\n-                for (UserSessionModel userSession : userSessions) {\n-                    offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession));\n-                }\n+                currentSession.sessions().getUserSessionsStream(realm, testApp[0]).collect(Collectors.toList())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4ODk1OTY5", "url": "https://github.com/keycloak/keycloak/pull/7652#pullrequestreview-548895969", "createdAt": "2020-12-10T06:48:51Z", "commit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa6513ed9176955b15cae4770579cb5e4b0ac1fa", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/aa6513ed9176955b15cae4770579cb5e4b0ac1fa", "committedDate": "2020-12-10T12:32:25Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/4792c9816231da91a7bd69608afdcf0fec11147d", "committedDate": "2020-12-07T23:22:21Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}, "afterCommit": {"oid": "aa6513ed9176955b15cae4770579cb5e4b0ac1fa", "author": {"user": {"login": "sguilhen", "name": "Stefan Guilhen"}}, "url": "https://github.com/keycloak/keycloak/commit/aa6513ed9176955b15cae4770579cb5e4b0ac1fa", "committedDate": "2020-12-10T12:32:25Z", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTMwMTE4", "url": "https://github.com/keycloak/keycloak/pull/7652#pullrequestreview-549930118", "createdAt": "2020-12-11T09:25:57Z", "commit": {"oid": "aa6513ed9176955b15cae4770579cb5e4b0ac1fa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTM0NTE4", "url": "https://github.com/keycloak/keycloak/pull/7652#pullrequestreview-549934518", "createdAt": "2020-12-11T09:31:35Z", "commit": {"oid": "aa6513ed9176955b15cae4770579cb5e4b0ac1fa"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMTUxOTMz", "url": "https://github.com/keycloak/keycloak/pull/7652#pullrequestreview-551151933", "createdAt": "2020-12-14T08:48:57Z", "commit": {"oid": "aa6513ed9176955b15cae4770579cb5e4b0ac1fa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMjMzMDA0", "url": "https://github.com/keycloak/keycloak/pull/7652#pullrequestreview-552233004", "createdAt": "2020-12-15T09:00:53Z", "commit": {"oid": "aa6513ed9176955b15cae4770579cb5e4b0ac1fa"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3292, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}