{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzNjIyMjEz", "number": 2663, "title": "Adding ability check the registry for manifests and push `builtImages` concurrently to the server", "bodyText": "This PR allows jib to pushes the multiple manifest files of the built images to the registry in the case that the manifest dont already exist in the registry.", "createdAt": "2020-08-05T20:21:14Z", "url": "https://github.com/GoogleContainerTools/jib/pull/2663", "merged": true, "mergeCommit": {"oid": "b3f33760822d8d50bfb8940cead06509d4ecf543"}, "closed": true, "closedAt": "2020-08-11T18:38:18Z", "author": {"login": "louismurerwa"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8TAo9AH2gAyNDYzNjIyMjEzOjVlNWJmNWFlNzY4NTgwZGM3M2U2ZWM5MGU3NjI4YzE5ZWM1MThlNzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc96wn8AFqTQ2NTMwNDg0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "committedDate": "2020-08-06T17:10:26Z", "message": "Adding functionality to push up image manifests to the registry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "08fac36ce7cc278f2b88038926a0757da24cf2e1", "author": {"user": {"login": "mpeddada1", "name": "Mridula"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/08fac36ce7cc278f2b88038926a0757da24cf2e1", "committedDate": "2020-08-06T16:23:05Z", "message": "update changelog after release (#2662)"}, "afterCommit": {"oid": "5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "committedDate": "2020-08-06T17:10:26Z", "message": "Adding functionality to push up image manifests to the registry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78cd01de020acbaa61bbbcd9f41760880fd5dc48", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/78cd01de020acbaa61bbbcd9f41760880fd5dc48", "committedDate": "2020-08-06T19:38:14Z", "message": "Style Fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bbc64253adf78befa8bb0cac7e5a97401c72c77", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/0bbc64253adf78befa8bb0cac7e5a97401c72c77", "committedDate": "2020-08-06T19:41:02Z", "message": "Removing commented out lines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/4fae9f105d0c4f4c3796607f047a06f54b546668", "committedDate": "2020-08-06T20:11:14Z", "message": "Fixing the Null Away Error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyODg5MjUw", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#pullrequestreview-462889250", "createdAt": "2020-08-06T21:28:26Z", "commit": {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMToyODoyNlrOG9E3_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMTo0MDoxMlrOG9FLSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjE5MQ==", "bodyText": "I don't think this is correct. As the original code, it should depend on baseImagesAndLayers. Depending on builtImages... means that this code will block until you complete building Images.", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466696191", "createdAt": "2020-08-06T21:28:26Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -331,20 +333,22 @@ private void pushBaseImageLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImageLayerPushResults =\n+    results.builtImagesAndLayerPushResults =\n         executorService.submit(\n             () -> {\n-              List<List<Future<BlobDescriptor>>> pushResults = new ArrayList<>();\n-              for (List<Future<PreparedLayer>> baseImageLayers :\n-                  results.baseImagesAndLayers.get().values()) {\n+              Map<Future<Image>, List<Future<BlobDescriptor>>> pushResults = new HashMap<>();\n+\n+              for (Map.Entry<Future<Image>, List<Future<PreparedLayer>>> entry :\n+                  results.builtImagesAndLayers.get().entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjQ1OA==", "bodyText": "builtImagesAndBaseImageLayerPushResults", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466696458", "createdAt": "2020-08-06T21:29:04Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -331,20 +333,22 @@ private void pushBaseImageLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImageLayerPushResults =\n+    results.builtImagesAndLayerPushResults =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NzA0NQ==", "bodyText": "Since we won't use builtImagesAndLayers in pushBaseImageLayers() (see my other comment), perhaps we don't need to change buildImages() code?", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466697045", "createdAt": "2020-08-06T21:30:27Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -379,9 +384,9 @@ private void buildImages() {\n                                     realizeFutures(Verify.verifyNotNull(entry.getValue())),\n                                     realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n                                 .call());\n-                builtImages.add(builtImage);\n+                builtImagesAndLayers.put(builtImage, entry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5ODQ5NA==", "bodyText": "I think we should keep using builtImages. I think using builtImagesAndContainerConfigurationPushResults to get an Image causes confusion and feels like abusing.", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466698494", "createdAt": "2020-08-06T21:33:54Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5OTQ1Ng==", "bodyText": "Do we really need this change? I was aware that we can always use .iterator().next() to retrieve a value from a single-entry map, but you've been so far consistently calling Map.get(). Mixing patterns makes it harder to understand code.", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466699456", "createdAt": "2020-08-06T21:36:04Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDY4Mg==", "bodyText": "It takes some seconds to get what entry.getKey() means. I suggest declaring a local variable Future<Image> builtImage = entry.getKey() before this realizeFutures(). The same goes for entry.getValue().", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466700682", "createdAt": "2020-08-06T21:39:13Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults\n+                                    .get()\n+                                    .keySet()\n+                                    .iterator()\n+                                    .next())\n+                            .get())\n                     .call());\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              for (Map.Entry<Future<Image>, Future<BlobDescriptor>> entry :\n+                  results.builtImagesAndContainerConfigurationPushResults.get().entrySet()) {\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .builtImagesAndLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(entry.getKey())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMTA4OQ==", "bodyText": "ditto about the .iterator().next() practice.", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466701089", "createdAt": "2020-08-06T21:40:07Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults\n+                                    .get()\n+                                    .keySet()\n+                                    .iterator()\n+                                    .next())\n+                            .get())\n                     .call());\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              for (Map.Entry<Future<Image>, Future<BlobDescriptor>> entry :\n+                  results.builtImagesAndContainerConfigurationPushResults.get().entrySet()) {\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .builtImagesAndLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(entry.getKey())));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(entry.getValue()).get(),\n+                                      entry.getKey().get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(entry.getValue()).get().getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  results\n+                                      .builtImagesAndLayers\n+                                      .get()\n+                                      .keySet()\n+                                      .iterator()\n+                                      .next()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMTEyOA==", "bodyText": "ditto", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466701128", "createdAt": "2020-08-06T21:40:12Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults\n+                                    .get()\n+                                    .keySet()\n+                                    .iterator()\n+                                    .next())\n+                            .get())\n                     .call());\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              for (Map.Entry<Future<Image>, Future<BlobDescriptor>> entry :\n+                  results.builtImagesAndContainerConfigurationPushResults.get().entrySet()) {\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .builtImagesAndLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(entry.getKey())));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(entry.getValue()).get(),\n+                                      entry.getKey().get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(entry.getValue()).get().getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  results\n+                                      .builtImagesAndLayers\n+                                      .get()\n+                                      .keySet()\n+                                      .iterator()\n+                                      .next()\n+                                      .get())\n+                              .call());\n+              buildResults.add(buildResult);\n+              return buildResults;\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new WriteTarFileStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  outputPath,\n+                                  results\n+                                      .builtImagesAndLayers\n+                                      .get()\n+                                      .keySet()\n+                                      .iterator()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668"}, "originalPosition": 250}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55054594749e03da22349101ae6cc3bf8032941a", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/55054594749e03da22349101ae6cc3bf8032941a", "committedDate": "2020-08-07T15:43:52Z", "message": "Style Fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae90ce7407aecb5bcd45d88811a5461ec3afdbf8", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/ae90ce7407aecb5bcd45d88811a5461ec3afdbf8", "committedDate": "2020-08-07T19:23:29Z", "message": "Updating the code structure and adding functionality to match baseimage -> builtimage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b88b7bc4f8c8d3105f924dd4a4bea41b5336caf1", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/b88b7bc4f8c8d3105f924dd4a4bea41b5336caf1", "committedDate": "2020-08-07T19:56:42Z", "message": "Style Fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "committedDate": "2020-08-07T20:02:20Z", "message": "Style Fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNjUxNzIy", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#pullrequestreview-463651722", "createdAt": "2020-08-07T21:32:44Z", "commit": {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMTozMjo0NFrOG9opkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMTo1MzoxN1rOG9pm6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4MjMyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                results.baseImagesAndbaseImageLayerPushResults =\n          \n          \n            \n                results.baseImagesAndBaseImageLayerPushResults =\n          \n      \n    \n    \n  \n\nbut because this time it's all about base images, I think we can go with\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                results.baseImagesAndbaseImageLayerPushResults =\n          \n          \n            \n                results.baseImagesAndLayerPushResults =", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467282320", "createdAt": "2020-08-07T21:32:44Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -331,20 +332,23 @@ private void pushBaseImageLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImageLayerPushResults =\n+    results.baseImagesAndbaseImageLayerPushResults =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4NTAyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            builtImagesAndBaseImages.put(builtImage, entry.getKey());\n          \n          \n            \n                            builtImagesAndBaseImages.put(builtImage, entry.getKey() /* base Image */);", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467285020", "createdAt": "2020-08-07T21:36:19Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -379,21 +383,21 @@ private void buildImages() {\n                                     realizeFutures(Verify.verifyNotNull(entry.getValue())),\n                                     realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n                                 .call());\n-                builtImages.add(builtImage);\n+                builtImagesAndBaseImages.put(builtImage, entry.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4NzY3OQ==", "bodyText": "You only need the key, so no need for entrySet(). And let's add a check; I'm certain the check will become useful going forward.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          Future<Image> builtImage = entry.getKey();\n          \n          \n            \n                          Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n          \n          \n            \n                          Future<Image> builtImage = results.builtImagesAndBaseImages.get().keySet().iterator().next();", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467287679", "createdAt": "2020-08-07T21:39:54Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NTU4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          Future<Image> builtImage = entry.getKey();\n          \n          \n            \n                          Verify.verify(results.builtImagesAndBaseImages.get().size() == 1, \"multi-platform image building not supported when pushing to Docker engine\");\n          \n          \n            \n                          Future<Image> builtImage = results.builtImagesAndBaseImages.get().keySet().iterator().next();", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467295585", "createdAt": "2020-08-07T21:50:09Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjU1NA==", "bodyText": "Can be simplified by return Collections.singletonList(executorService.submit(...)).", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467296554", "createdAt": "2020-08-07T21:51:23Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzQ1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          Map.Entry<Future<Image>, Image> entry =\n          \n          \n            \n                              results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n          \n          \n            \n                          Future<Image> builtImage = entry.getKey();\n          \n          \n            \n                          Verify.verify(results.builtImagesAndBaseImages.get().size() == 1, \"multi-platform image building not supported when building a local tar image\");\n          \n          \n            \n                          Future<Image> builtImage = results.builtImagesAndBaseImages.get().keySet().iterator().next();", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467297456", "createdAt": "2020-08-07T21:52:33Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call());\n+              buildResults.add(buildResult);\n+              return buildResults;\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5ODAyNg==", "bodyText": "Ditto. No need to create an array.", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467298026", "createdAt": "2020-08-07T21:53:17Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call());\n+              buildResults.add(buildResult);\n+              return buildResults;\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f"}, "originalPosition": 283}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "committedDate": "2020-08-10T14:34:24Z", "message": "Style Fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDUzODUz", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#pullrequestreview-464453853", "createdAt": "2020-08-10T18:00:03Z", "commit": {"oid": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODowMDowM1rOG-ZbsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxODozMTozN1rOG-adnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA4MTU4NA==", "bodyText": "I think we can block until we get the built Image?\n              Image builtImage =\n                  results.builtImagesAndBaseImages.get().keySet().iterator().next().get();\nNext, I think we should avoid scheduling another thread. We can use Futures.immediateFuture (a utility method to directly instantiate a Future from a concrete value) that just wraps a value instead of actually scheduling a thread.\n              Image builtImage =\n                  results.builtImagesAndBaseImages.get().keySet().iterator().next().get();\n\n              return Collections.singletonList(\n                  Futures.immediateFuture(\n                      new LoadDockerStep(\n                              buildContext,\n                              childProgressDispatcherFactory,\n                              dockerClient,\n                              builtImage)\n                          .call()));", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468081584", "createdAt": "2020-08-10T18:00:03Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +435,133 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n-                                  results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n+                                  results.baseImagesAndLayerPushResults.get().get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(\n+                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  \"multi-platform image building not supported when pushing to Docker engine\");\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+\n+              return Collections.singletonList(\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call()));\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODQ2MA==", "bodyText": "ditto", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468098460", "createdAt": "2020-08-10T18:31:37Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +435,133 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n-                                  results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n+                                  results.baseImagesAndLayerPushResults.get().get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(\n+                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  \"multi-platform image building not supported when pushing to Docker engine\");\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+\n+              return Collections.singletonList(\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call()));\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(\n+                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  \"multi-platform image building not supported when building a local tar image\");\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+\n+              return Collections.singletonList(\n+                  executorService.submit(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df"}, "originalPosition": 284}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTE3NDAx", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#pullrequestreview-464517401", "createdAt": "2020-08-10T19:29:05Z", "commit": {"oid": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOToyOTowNVrOG-civw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOToyOTowNVrOG-civw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMjU0Mw==", "bodyText": "This is also used on line 500, so I suggest refactor out into a local variable. I think it will considerable improve readability.", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468132543", "createdAt": "2020-08-10T19:29:05Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +435,133 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n-                                  results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n+                                  results.baseImagesAndLayerPushResults.get().get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df"}, "originalPosition": 186}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a92200f852c12e1925e2e08dc0c88817ed3009b", "author": {"user": {"login": "louismurerwa", "name": "Louis Murerwa"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/8a92200f852c12e1925e2e08dc0c88817ed3009b", "committedDate": "2020-08-11T15:31:09Z", "message": "Style Fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97dfb42924055a67eb73b3a63b50bf0704fd0f17", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/97dfb42924055a67eb73b3a63b50bf0704fd0f17", "committedDate": "2020-08-11T16:16:45Z", "message": "Refactor code; no behavior change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "718c32c8dd92987a3d7c1cdfb6e735426593eb62", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/718c32c8dd92987a3d7c1cdfb6e735426593eb62", "committedDate": "2020-08-11T16:17:05Z", "message": "Merge remote-tracking branch 'origin/master' into pushImages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3c7019d986039014fa140888af5eac73ecd447c", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/d3c7019d986039014fa140888af5eac73ecd447c", "committedDate": "2020-08-11T16:19:20Z", "message": "Update comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzA0ODQy", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#pullrequestreview-465304842", "createdAt": "2020-08-11T18:03:04Z", "commit": {"oid": "d3c7019d986039014fa140888af5eac73ecd447c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4938, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}