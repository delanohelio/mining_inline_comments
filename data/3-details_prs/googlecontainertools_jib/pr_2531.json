{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1MzAyMDQx", "number": 2531, "title": "New option to skip pushing images (manifests) if the image (manifest) already exists in the target registry", "bodyText": "Fixes #2360.\nSee #2387.", "createdAt": "2020-06-16T15:36:12Z", "url": "https://github.com/GoogleContainerTools/jib/pull/2531", "merged": true, "mergeCommit": {"oid": "dd0a18627a56034fab245d0db21381617c4aec09"}, "closed": true, "closedAt": "2020-07-07T15:18:56Z", "author": {"login": "karlmuscat"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcU_YLqAH2gAyNDM1MzAyMDQxOjgxZGQ4ODQ5NjUyN2ZlMmUyN2FjNjFiNTVmMjQ2MjNkMzBmNTkxNzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcym3lWAFqTQ0Mzk1ODAzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "81dd88496527fe2e27ac61b55f24623d30f59177", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/81dd88496527fe2e27ac61b55f24623d30f59177", "committedDate": "2020-04-06T14:15:00Z", "message": "Adds proposal to control the pushing of tags on existing images in target registry."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9eaf43bc9b05540afe487039408c0bf6a26a9a4c", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/9eaf43bc9b05540afe487039408c0bf6a26a9a4c", "committedDate": "2020-04-14T12:01:23Z", "message": "Updates proposal with more detail."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a5faaf2ad4da52ca224566469ee73a92e266eee", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/7a5faaf2ad4da52ca224566469ee73a92e266eee", "committedDate": "2020-04-15T08:24:15Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "987c58cfec454be74a4c14c387c6e3446d43c47b", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/987c58cfec454be74a4c14c387c6e3446d43c47b", "committedDate": "2020-05-08T19:08:35Z", "message": "Work for tags-on-existing-images.md"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75a9b926d90690cf01dc499cce722490a233be0e", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/75a9b926d90690cf01dc499cce722490a233be0e", "committedDate": "2020-05-08T19:08:51Z", "message": "Merge branch 'master' of https://github.com/GoogleContainerTools/jib"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8719adbd4662aad591573ae8d31c130622556932", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/8719adbd4662aad591573ae8d31c130622556932", "committedDate": "2020-06-14T12:05:54Z", "message": "Cleanup."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1533d8f0be3de9c54e119a996fcfca0df2838bd1", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/1533d8f0be3de9c54e119a996fcfca0df2838bd1", "committedDate": "2020-06-14T12:07:38Z", "message": "Merge remote-tracking branch 'upstream/master'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82b1f34206ee6f9a309b521e29c3016de21bf591", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/82b1f34206ee6f9a309b521e29c3016de21bf591", "committedDate": "2020-06-16T15:05:00Z", "message": "* Simplified implementation:\n  * Removed newly added class ManifestDescriptor, replaced it with already existing ManifestAndDigest.\n  * Removed the CheckImageStep and incorporated the check within the PushImageStep. Implementation now follows similar checks, eg, in PushBlopStep.\n* Adds unit and integration tests.\n* Fixes resulting from testing."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/cb5acaa9a3a12d311e1f94a840b052c9daabb536", "committedDate": "2020-06-16T15:31:13Z", "message": "Code formatting changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODA3Nzk1", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#pullrequestreview-435807795", "createdAt": "2020-06-23T13:55:29Z", "commit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMzo1NToyOVrOGnqdFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMzo1NToyOVrOGnqdFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0MzIyMw==", "bodyText": "this comment seems to be off? maybe should be unknown ?", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r444243223", "createdAt": "2020-06-23T13:55:29Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/ManifestCheckerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.google.cloud.tools.jib.api.RegistryException;\n+import com.google.cloud.tools.jib.event.EventHandlers;\n+import com.google.cloud.tools.jib.http.FailoverHttpClient;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import java.io.IOException;\n+import java.util.Optional;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+/** Integration tests for {@link ManifestChecker}. */\n+public class ManifestCheckerIntegrationTest {\n+\n+  /** A known manifest list sha for openjdk:11-jre-slim. */\n+  public static final String KNOWN_MANIFEST =\n+      \"sha256:8ab7b3078b01ba66b937b7fbe0b9eccf60449cc101c42e99aeefaba0e1781155\";\n+\n+  /** A known manifest list sha for openjdk:11-jre-slim. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODA4Nzky", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#pullrequestreview-435808792", "createdAt": "2020-06-23T13:56:29Z", "commit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMzo1NjoyOVrOGnqgHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMzo1NjoyOVrOGnqgHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0Mzk5Nw==", "bodyText": "is this necessary? who's using busybox? Actually the whole localRegistry harness maybe isn't used? we can remove it?", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r444243997", "createdAt": "2020-06-23T13:56:29Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/ManifestCheckerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.google.cloud.tools.jib.api.RegistryException;\n+import com.google.cloud.tools.jib.event.EventHandlers;\n+import com.google.cloud.tools.jib.http.FailoverHttpClient;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import java.io.IOException;\n+import java.util.Optional;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+/** Integration tests for {@link ManifestChecker}. */\n+public class ManifestCheckerIntegrationTest {\n+\n+  /** A known manifest list sha for openjdk:11-jre-slim. */\n+  public static final String KNOWN_MANIFEST =\n+      \"sha256:8ab7b3078b01ba66b937b7fbe0b9eccf60449cc101c42e99aeefaba0e1781155\";\n+\n+  /** A known manifest list sha for openjdk:11-jre-slim. */\n+  public static final String UNKNOWN_MANIFEST =\n+      \"sha256:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n+\n+  @ClassRule public static final LocalRegistry localRegistry = new LocalRegistry(5000);\n+\n+  @BeforeClass\n+  public static void setUp() throws IOException, InterruptedException {\n+    localRegistry.pullAndPushToLocal(\"busybox\", \"busybox\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODEwMDY0", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#pullrequestreview-435810064", "createdAt": "2020-06-23T13:57:43Z", "commit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMzo1Nzo0NFrOGnqj_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMzo1Nzo0NFrOGnqj_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NDk5MA==", "bodyText": "2018 -> 2020", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r444244990", "createdAt": "2020-06-23T13:57:44Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ManifestChecker.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2018 Google LLC.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODEzNjg0", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#pullrequestreview-435813684", "createdAt": "2020-06-23T14:01:18Z", "commit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNDowMToxOFrOGnqueg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNDowMToxOFrOGnqueg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA==", "bodyText": "I don't think we should be duplicating code like this, the code in ManifestPuller and this can go out of sync. Is there a way provide a shared resource that both can refrence?", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r444247674", "createdAt": "2020-06-23T14:01:18Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ManifestChecker.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.api.client.http.HttpMethods;\n+import com.google.api.client.http.HttpStatusCodes;\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.hash.Digests;\n+import com.google.cloud.tools.jib.http.BlobHttpContent;\n+import com.google.cloud.tools.jib.http.Response;\n+import com.google.cloud.tools.jib.http.ResponseException;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.OciManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.UnknownManifestFormatException;\n+import com.google.cloud.tools.jib.image.json.V21ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestListTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/** Checks an image's manifest. */\n+public class ManifestChecker<T extends ManifestTemplate>\n+    implements RegistryEndpointProvider<Optional<ManifestAndDigest<T>>> {\n+\n+  private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n+  private final String imageDescriptor;\n+  private final Class<T> manifestTemplateClass;\n+\n+  ManifestChecker(\n+      RegistryEndpointRequestProperties registryEndpointRequestProperties,\n+      String imageDescriptor,\n+      Class<T> manifestTemplateClass) {\n+    this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n+    this.imageDescriptor = imageDescriptor;\n+    this.manifestTemplateClass = manifestTemplateClass;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public BlobHttpContent getContent() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAccept() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MDAzODM2", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#pullrequestreview-437003836", "createdAt": "2020-06-24T21:01:33Z", "commit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTowMTozM1rOGoi_pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMToxMjo0OFrOGojUpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTU3NQ==", "bodyText": "This check is still suffering from the concurrency issue I mentioned in #2387 (comment). As we discussed, you should follow the design outlined in the proposal to create a separate -Step class to call registryClient.checkImage(). If the program control already reached here, it means multiple PushImageSteps are scheduled and running.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445169575", "createdAt": "2020-06-24T21:01:33Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushImageStep.java", "diffHunk": "@@ -47,23 +45,25 @@\n       ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n       RegistryClient registryClient,\n       BlobDescriptor containerConfigurationDigestAndSize,\n-      Image builtImage)\n-      throws IOException {\n+      BuildableManifestTemplate manifestTemplate,\n+      DescriptorDigest imageDigest)\n+      throws IOException, RegistryException {\n     Set<String> tags = buildContext.getAllTargetImageTags();\n \n+    EventHandlers eventHandlers = buildContext.getEventHandlers();\n+\n     try (TimerEventDispatcher ignored =\n-            new TimerEventDispatcher(\n-                buildContext.getEventHandlers(), \"Preparing manifest pushers\");\n+            new TimerEventDispatcher(eventHandlers, \"Preparing manifest pushers\");\n         ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"launching manifest pushers\", tags.size())) {\n \n-      // Gets the image manifest to push.\n-      BuildableManifestTemplate manifestTemplate =\n-          new ImageToJsonTranslator(builtImage)\n-              .getManifestTemplate(\n-                  buildContext.getTargetFormat(), containerConfigurationDigestAndSize);\n+      if (JibSystemProperties.skipExistingImages()\n+          && registryClient.checkImage(imageDigest.toString()).isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTg2OA==", "bodyText": "2020", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445169868", "createdAt": "2020-06-24T21:02:08Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/ManifestCheckerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2018 Google LLC.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDM1OA==", "bodyText": "Please catch the specific exception and verify the exception message (assertEquals(..., ex.getMessage()) or assertThat(ex.getMessage(), ....containsString(...)) for example).", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445170358", "createdAt": "2020-06-24T21:03:11Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());\n+\n+    // Push the same image with a different tag, with SKIP_EXISTING_IMAGES enabled.\n+    JibContainer image2 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"new_testtag\"),\n+            Collections.emptyList());\n+\n+    // Test that the pull request throws an exception, indicating that the new tag was not pushed.\n+    String imageReference3 = \"localhost:5000/testimagerepo:new_testtag\";\n+    try {\n+      localRegistry.pull(imageReference3);\n+      Assert.fail(\n+          \"jib.skipExistingImages was enabled and digest was already pushed, \"\n+              + \"hence testtag2 shouldn't have been pushed.\");\n+    } catch (RuntimeException ignore) {\n+      // As expected, registry throws exception that manifest is unknown.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MTc5NQ==", "bodyText": "We use @Rule RestoreSystemProperties to clean up system properties, because cleaning this way is fragile unless it's wrapper around try { ... } finally { ...}.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445171795", "createdAt": "2020-06-24T21:06:11Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());\n+\n+    // Push the same image with a different tag, with SKIP_EXISTING_IMAGES enabled.\n+    JibContainer image2 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"new_testtag\"),\n+            Collections.emptyList());\n+\n+    // Test that the pull request throws an exception, indicating that the new tag was not pushed.\n+    String imageReference3 = \"localhost:5000/testimagerepo:new_testtag\";\n+    try {\n+      localRegistry.pull(imageReference3);\n+      Assert.fail(\n+          \"jib.skipExistingImages was enabled and digest was already pushed, \"\n+              + \"hence testtag2 shouldn't have been pushed.\");\n+    } catch (RuntimeException ignore) {\n+      // As expected, registry throws exception that manifest is unknown.\n+    }\n+\n+    // Test that both images have the same properties.\n+    Assert.assertEquals(image1.getDigest(), image2.getDigest());\n+    Assert.assertEquals(image1.getImageId(), image2.getImageId());\n+\n+    // Cleanup. Disable option to not disrupt other tests.\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"false\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MzIwNw==", "bodyText": "I think we can skip this testing, as the target of this test method is to test SKIP_EXISTING_IMAGES. Our integration are increasing running more Docker images and getting slower.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445173207", "createdAt": "2020-06-24T21:09:17Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MzY5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String imageReference3 = \"localhost:5000/testimagerepo:new_testtag\";\n          \n          \n            \n                try {\n          \n          \n            \n                  localRegistry.pull(imageReference3);\n          \n          \n            \n                try {\n          \n          \n            \n                  localRegistry.pull(\"localhost:5000/testimagerepo:new_testtag\");", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445173699", "createdAt": "2020-06-24T21:10:13Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());\n+\n+    // Push the same image with a different tag, with SKIP_EXISTING_IMAGES enabled.\n+    JibContainer image2 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"new_testtag\"),\n+            Collections.emptyList());\n+\n+    // Test that the pull request throws an exception, indicating that the new tag was not pushed.\n+    String imageReference3 = \"localhost:5000/testimagerepo:new_testtag\";\n+    try {\n+      localRegistry.pull(imageReference3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3NDE4Ng==", "bodyText": "Agreed. I really think we should not duplicate this much amount of code.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445174186", "createdAt": "2020-06-24T21:11:20Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ManifestChecker.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.api.client.http.HttpMethods;\n+import com.google.api.client.http.HttpStatusCodes;\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.hash.Digests;\n+import com.google.cloud.tools.jib.http.BlobHttpContent;\n+import com.google.cloud.tools.jib.http.Response;\n+import com.google.cloud.tools.jib.http.ResponseException;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.OciManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.UnknownManifestFormatException;\n+import com.google.cloud.tools.jib.image.json.V21ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestListTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/** Checks an image's manifest. */\n+public class ManifestChecker<T extends ManifestTemplate>\n+    implements RegistryEndpointProvider<Optional<ManifestAndDigest<T>>> {\n+\n+  private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n+  private final String imageDescriptor;\n+  private final Class<T> manifestTemplateClass;\n+\n+  ManifestChecker(\n+      RegistryEndpointRequestProperties registryEndpointRequestProperties,\n+      String imageDescriptor,\n+      Class<T> manifestTemplateClass) {\n+    this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n+    this.imageDescriptor = imageDescriptor;\n+    this.manifestTemplateClass = manifestTemplateClass;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public BlobHttpContent getContent() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAccept() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA=="}, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3NDk0OA==", "bodyText": "I didn't find any usage of passing manifestTemplateClass in this PR. Maybe just\n  public Optional<ManifestAndDigest<ManifestTemplate>> checkImage(String imageDigest)\n\n?", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445174948", "createdAt": "2020-06-24T21:12:48Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -367,6 +367,31 @@ private Authorization refreshBearerAuth(@Nullable String wwwAuthenticate)\n     return Verify.verifyNotNull(initialBearerAuthenticator.get()).authenticatePush(credential);\n   }\n \n+  /**\n+   * Check if an image is on the registry.\n+   *\n+   * @param <T> child type of ManifestTemplate\n+   * @param manifestTemplateClass the specific version of manifest template to check\n+   * @param imageDigest the image digest to check for\n+   * @return the image's {@link ManifestAndDigest} if the image exists on the registry, or {@link\n+   *     Optional#empty()} if it doesn't\n+   * @throws IOException if communicating with the endpoint fails\n+   * @throws RegistryException if communicating with the endpoint fails\n+   */\n+  public <T extends ManifestTemplate> Optional<ManifestAndDigest<T>> checkImage(\n+      String imageDigest, Class<T> manifestTemplateClass) throws IOException, RegistryException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "150be620a68238860cef42149dfae580238e092a", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/150be620a68238860cef42149dfae580238e092a", "committedDate": "2020-07-06T08:42:44Z", "message": "Code cleanup, post-review."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMDczMTUx", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#pullrequestreview-443073151", "createdAt": "2020-07-06T13:26:35Z", "commit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMzoyNjozNVrOGtXLdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMzo0ODo1OFrOGtYC3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIxODg3MA==", "bodyText": "Sorry, I mean this \"Hello, world\" assertion on this line and and assertDockerInpsect() on line 243. Also remove them on line 236 and 237.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450218870", "createdAt": "2020-07-06T13:26:35Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MzIwNw=="}, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyMjgwMg==", "bodyText": "Sounds good. Please verify the message.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450222802", "createdAt": "2020-07-06T13:32:52Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());\n+\n+    // Push the same image with a different tag, with SKIP_EXISTING_IMAGES enabled.\n+    JibContainer image2 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"new_testtag\"),\n+            Collections.emptyList());\n+\n+    // Test that the pull request throws an exception, indicating that the new tag was not pushed.\n+    String imageReference3 = \"localhost:5000/testimagerepo:new_testtag\";\n+    try {\n+      localRegistry.pull(imageReference3);\n+      Assert.fail(\n+          \"jib.skipExistingImages was enabled and digest was already pushed, \"\n+              + \"hence testtag2 shouldn't have been pushed.\");\n+    } catch (RuntimeException ignore) {\n+      // As expected, registry throws exception that manifest is unknown.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDM1OA=="}, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyMzY0NA==", "bodyText": "Just in case, I will \"unresolve\" conversations (include this) until I can verify actual changes. :)", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450223644", "createdAt": "2020-07-06T13:34:13Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());\n+\n+    // Push the same image with a different tag, with SKIP_EXISTING_IMAGES enabled.\n+    JibContainer image2 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"new_testtag\"),\n+            Collections.emptyList());\n+\n+    // Test that the pull request throws an exception, indicating that the new tag was not pushed.\n+    String imageReference3 = \"localhost:5000/testimagerepo:new_testtag\";\n+    try {\n+      localRegistry.pull(imageReference3);\n+      Assert.fail(\n+          \"jib.skipExistingImages was enabled and digest was already pushed, \"\n+              + \"hence testtag2 shouldn't have been pushed.\");\n+    } catch (RuntimeException ignore) {\n+      // As expected, registry throws exception that manifest is unknown.\n+    }\n+\n+    // Test that both images have the same properties.\n+    Assert.assertEquals(image1.getDigest(), image2.getDigest());\n+    Assert.assertEquals(image1.getImageId(), image2.getImageId());\n+\n+    // Cleanup. Disable option to not disrupt other tests.\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"false\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MTc5NQ=="}, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNTc1NQ==", "bodyText": "Oh, I jumped into the conclusion too early after I saw this check in this file.\nHowever, you still need to create a separate Step for a blocking network call. makeList() should just create and return necessary Steps instantaneously and should never block thread scheduling in StepsRunner.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450225755", "createdAt": "2020-07-06T13:37:43Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushImageStep.java", "diffHunk": "@@ -47,23 +45,25 @@\n       ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n       RegistryClient registryClient,\n       BlobDescriptor containerConfigurationDigestAndSize,\n-      Image builtImage)\n-      throws IOException {\n+      BuildableManifestTemplate manifestTemplate,\n+      DescriptorDigest imageDigest)\n+      throws IOException, RegistryException {\n     Set<String> tags = buildContext.getAllTargetImageTags();\n \n+    EventHandlers eventHandlers = buildContext.getEventHandlers();\n+\n     try (TimerEventDispatcher ignored =\n-            new TimerEventDispatcher(\n-                buildContext.getEventHandlers(), \"Preparing manifest pushers\");\n+            new TimerEventDispatcher(eventHandlers, \"Preparing manifest pushers\");\n         ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"launching manifest pushers\", tags.size())) {\n \n-      // Gets the image manifest to push.\n-      BuildableManifestTemplate manifestTemplate =\n-          new ImageToJsonTranslator(builtImage)\n-              .getManifestTemplate(\n-                  buildContext.getTargetFormat(), containerConfigurationDigestAndSize);\n+      if (JibSystemProperties.skipExistingImages()\n+          && registryClient.checkImage(imageDigest.toString()).isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTU3NQ=="}, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMTE2OA==", "bodyText": "Would you mind if I push changes to your PR?", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450231168", "createdAt": "2020-07-06T13:46:02Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ManifestChecker.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.api.client.http.HttpMethods;\n+import com.google.api.client.http.HttpStatusCodes;\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.hash.Digests;\n+import com.google.cloud.tools.jib.http.BlobHttpContent;\n+import com.google.cloud.tools.jib.http.Response;\n+import com.google.cloud.tools.jib.http.ResponseException;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.OciManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.UnknownManifestFormatException;\n+import com.google.cloud.tools.jib.image.json.V21ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestListTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/** Checks an image's manifest. */\n+public class ManifestChecker<T extends ManifestTemplate>\n+    implements RegistryEndpointProvider<Optional<ManifestAndDigest<T>>> {\n+\n+  private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n+  private final String imageDescriptor;\n+  private final Class<T> manifestTemplateClass;\n+\n+  ManifestChecker(\n+      RegistryEndpointRequestProperties registryEndpointRequestProperties,\n+      String imageDescriptor,\n+      Class<T> manifestTemplateClass) {\n+    this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n+    this.imageDescriptor = imageDescriptor;\n+    this.manifestTemplateClass = manifestTemplateClass;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public BlobHttpContent getContent() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAccept() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA=="}, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMzA1Mw==", "bodyText": "Could you explain these two checks (responseException.getContext() and ErrorCodes.MANIFEST_UNKNOWN)? I am asking because we've seen different registries have different behaviors that are not really conformant to the Registry API standard, and would like to know if these checks are specific to a certain registry implementation.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450233053", "createdAt": "2020-07-06T13:48:58Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ManifestChecker.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.api.client.http.HttpMethods;\n+import com.google.api.client.http.HttpStatusCodes;\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.hash.Digests;\n+import com.google.cloud.tools.jib.http.BlobHttpContent;\n+import com.google.cloud.tools.jib.http.Response;\n+import com.google.cloud.tools.jib.http.ResponseException;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.OciManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.UnknownManifestFormatException;\n+import com.google.cloud.tools.jib.image.json.V21ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestListTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/** Checks an image's manifest. */\n+public class ManifestChecker<T extends ManifestTemplate>\n+    implements RegistryEndpointProvider<Optional<ManifestAndDigest<T>>> {\n+\n+  private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n+  private final String imageDescriptor;\n+  private final Class<T> manifestTemplateClass;\n+\n+  ManifestChecker(\n+      RegistryEndpointRequestProperties registryEndpointRequestProperties,\n+      String imageDescriptor,\n+      Class<T> manifestTemplateClass) {\n+    this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n+    this.imageDescriptor = imageDescriptor;\n+    this.manifestTemplateClass = manifestTemplateClass;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public BlobHttpContent getContent() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAccept() {\n+    if (manifestTemplateClass.equals(V21ManifestTemplate.class)) {\n+      return Collections.singletonList(V21ManifestTemplate.MEDIA_TYPE);\n+    }\n+    if (manifestTemplateClass.equals(V22ManifestTemplate.class)) {\n+      return Collections.singletonList(V22ManifestTemplate.MANIFEST_MEDIA_TYPE);\n+    }\n+    if (manifestTemplateClass.equals(OciManifestTemplate.class)) {\n+      return Collections.singletonList(OciManifestTemplate.MANIFEST_MEDIA_TYPE);\n+    }\n+    if (manifestTemplateClass.equals(V22ManifestListTemplate.class)) {\n+      return Collections.singletonList(V22ManifestListTemplate.MANIFEST_MEDIA_TYPE);\n+    }\n+\n+    // V22ManifestListTemplate is not included by default, we don't explicitly accept\n+    // it, we only handle it if referenced by sha256 (see getManifestTemplateFromJson) in which\n+    // case registries ignore the \"accept\" directive and just return a manifest list anyway.\n+    return Arrays.asList(\n+        OciManifestTemplate.MANIFEST_MEDIA_TYPE,\n+        V22ManifestTemplate.MANIFEST_MEDIA_TYPE,\n+        V21ManifestTemplate.MEDIA_TYPE);\n+  }\n+\n+  /** Parses the response body into a {@link ManifestAndDigest}. */\n+  @Override\n+  public Optional<ManifestAndDigest<T>> handleResponse(Response response)\n+      throws IOException, UnknownManifestFormatException {\n+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+    DescriptorDigest digest =\n+        Digests.computeDigest(response.getBody(), byteArrayOutputStream).getDigest();\n+    String jsonString = byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n+    T manifestTemplate = getManifestTemplateFromJson(jsonString);\n+    return Optional.of(new ManifestAndDigest<>(manifestTemplate, digest));\n+  }\n+\n+  @Override\n+  public URL getApiRoute(String apiRouteBase) throws MalformedURLException {\n+    return new URL(\n+        apiRouteBase\n+            + registryEndpointRequestProperties.getImageName()\n+            + \"/manifests/\"\n+            + imageDescriptor);\n+  }\n+\n+  @Override\n+  public String getHttpMethod() {\n+    return HttpMethods.GET;\n+  }\n+\n+  @Override\n+  public String getActionDescription() {\n+    return \"pull image manifest for \"\n+        + registryEndpointRequestProperties.getServerUrl()\n+        + \"/\"\n+        + registryEndpointRequestProperties.getImageName()\n+        + \":\"\n+        + imageDescriptor;\n+  }\n+\n+  /**\n+   * Instantiates a {@link ManifestTemplate} from a JSON string. This checks the {@code\n+   * schemaVersion} field of the JSON to determine which manifest version to use.\n+   */\n+  private T getManifestTemplateFromJson(String jsonString)\n+      throws IOException, UnknownManifestFormatException {\n+    ObjectNode node = new ObjectMapper().readValue(jsonString, ObjectNode.class);\n+    if (!node.has(\"schemaVersion\")) {\n+      throw new UnknownManifestFormatException(\"Cannot find field 'schemaVersion' in manifest\");\n+    }\n+\n+    int schemaVersion = node.get(\"schemaVersion\").asInt(-1);\n+    if (schemaVersion == -1) {\n+      throw new UnknownManifestFormatException(\"`schemaVersion` field is not an integer\");\n+    }\n+\n+    if (schemaVersion == 1) {\n+      return manifestTemplateClass.cast(\n+          JsonTemplateMapper.readJson(jsonString, V21ManifestTemplate.class));\n+    }\n+    if (schemaVersion == 2) {\n+      // 'schemaVersion' of 2 can be either Docker V2.2 or OCI.\n+      String mediaType = node.get(\"mediaType\").asText();\n+      if (V22ManifestTemplate.MANIFEST_MEDIA_TYPE.equals(mediaType)) {\n+        return manifestTemplateClass.cast(\n+            JsonTemplateMapper.readJson(jsonString, V22ManifestTemplate.class));\n+      }\n+      if (OciManifestTemplate.MANIFEST_MEDIA_TYPE.equals(mediaType)) {\n+        return manifestTemplateClass.cast(\n+            JsonTemplateMapper.readJson(jsonString, OciManifestTemplate.class));\n+      }\n+      if (V22ManifestListTemplate.MANIFEST_MEDIA_TYPE.equals(mediaType)) {\n+        return manifestTemplateClass.cast(\n+            JsonTemplateMapper.readJson(jsonString, V22ManifestListTemplate.class));\n+      }\n+      throw new UnknownManifestFormatException(\"Unknown mediaType: \" + mediaType);\n+    }\n+    throw new UnknownManifestFormatException(\n+        \"Unknown schemaVersion: \" + schemaVersion + \" - only 1 and 2 are supported\");\n+  }\n+\n+  @Override\n+  public Optional<ManifestAndDigest<T>> handleHttpResponseException(\n+      ResponseException responseException) throws ResponseException {\n+    if (responseException.getStatusCode() != HttpStatusCodes.STATUS_CODE_NOT_FOUND) {\n+      throw responseException;\n+    }\n+\n+    // Finds a MANIFEST_BLOB_UNKNOWN error response code.\n+    if (responseException.getContent() == null) {\n+      return Optional.empty();\n+    }\n+\n+    ErrorCodes errorCode = ErrorResponseUtil.getErrorCode(responseException);\n+    if (errorCode == ErrorCodes.MANIFEST_UNKNOWN) {\n+      return Optional.empty();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 185}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eb1ec9d4c19347ce5064d3e7b015f0f29727807", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/0eb1ec9d4c19347ce5064d3e7b015f0f29727807", "committedDate": "2020-07-06T14:14:18Z", "message": "Code cleanup, post-review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27c22cd9455b645f5307798e8571a963fa099d61", "author": {"user": {"login": "karlmuscat", "name": "Karl"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/27c22cd9455b645f5307798e8571a963fa099d61", "committedDate": "2020-07-06T16:01:25Z", "message": "* Adds a new CheckImageStep and integrates it in the StepsRunner.\n* Reverts PushImageStep to the state before the PR started, apart from the manifest existence check."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMjE2NTQz", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#pullrequestreview-443216543", "createdAt": "2020-07-06T16:10:48Z", "commit": {"oid": "27c22cd9455b645f5307798e8571a963fa099d61"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxMDo0OVrOGtd6Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxODo0MzoxMlrOGti_Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMyOTE4Mg==", "bodyText": "Make the fields private final.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450329182", "createdAt": "2020-07-06T16:10:49Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/CheckImageStep.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.builder.steps;\n+\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryException;\n+import com.google.cloud.tools.jib.blob.BlobDescriptor;\n+import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n+import com.google.cloud.tools.jib.builder.TimerEventDispatcher;\n+import com.google.cloud.tools.jib.configuration.BuildContext;\n+import com.google.cloud.tools.jib.event.EventHandlers;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.hash.Digests;\n+import com.google.cloud.tools.jib.image.Image;\n+import com.google.cloud.tools.jib.image.json.BuildableManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.ImageToJsonTranslator;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import com.google.cloud.tools.jib.registry.ManifestAndDigest;\n+import com.google.cloud.tools.jib.registry.RegistryClient;\n+import java.io.IOException;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+/** Checks the existence of a manifest. */\n+class CheckImageStep implements Callable<Optional<ManifestAndDigest<ManifestTemplate>>> {\n+\n+  private static final String DESCRIPTION = \"Checking existence of manifest\";\n+\n+  BuildContext buildContext;\n+  ProgressEventDispatcher.Factory progressEventDispatcherFactory;\n+  RegistryClient registryClient;\n+  BlobDescriptor containerConfigurationDigestAndSize;\n+  Image image;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27c22cd9455b645f5307798e8571a963fa099d61"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0MDcyMw==", "bodyText": "On second thought, we could make makeList() always return a non-empty list and have PushImageStep.call() decide whether to skip pushing, but I can take care of this later in a follow-up PR. But at the same time, I think this approach is still acceptable.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450340723", "createdAt": "2020-07-06T16:29:04Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -394,10 +415,15 @@ private void pushImages() {\n                           childProgressDispatcherFactory,\n                           results.targetRegistryClient.get(),\n                           results.containerConfigurationPushResult.get(),\n-                          results.builtImage.get()));\n+                          results.builtImage.get(),\n+                          results.manifestCheckResult.get().isPresent()));\n               realizeFutures(manifestPushResults);\n               // Manifest pushers return the same BuildResult.\n-              return manifestPushResults.get(0).get();\n+              return manifestPushResults.isEmpty()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27c22cd9455b645f5307798e8571a963fa099d61"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxMTg3NA==", "bodyText": "Alright, I will look into the Registry API specification later for this part and will probably take care of this one way or another in a follow-up PR. But I think at least this works and doesn't actually break things, since this is just an extra manifest check; the worst case would be getting an error later. So I think we are good to go.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450411874", "createdAt": "2020-07-06T18:42:08Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ManifestChecker.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.api.client.http.HttpMethods;\n+import com.google.api.client.http.HttpStatusCodes;\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.hash.Digests;\n+import com.google.cloud.tools.jib.http.BlobHttpContent;\n+import com.google.cloud.tools.jib.http.Response;\n+import com.google.cloud.tools.jib.http.ResponseException;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.OciManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.UnknownManifestFormatException;\n+import com.google.cloud.tools.jib.image.json.V21ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestListTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/** Checks an image's manifest. */\n+public class ManifestChecker<T extends ManifestTemplate>\n+    implements RegistryEndpointProvider<Optional<ManifestAndDigest<T>>> {\n+\n+  private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n+  private final String imageDescriptor;\n+  private final Class<T> manifestTemplateClass;\n+\n+  ManifestChecker(\n+      RegistryEndpointRequestProperties registryEndpointRequestProperties,\n+      String imageDescriptor,\n+      Class<T> manifestTemplateClass) {\n+    this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n+    this.imageDescriptor = imageDescriptor;\n+    this.manifestTemplateClass = manifestTemplateClass;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public BlobHttpContent getContent() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAccept() {\n+    if (manifestTemplateClass.equals(V21ManifestTemplate.class)) {\n+      return Collections.singletonList(V21ManifestTemplate.MEDIA_TYPE);\n+    }\n+    if (manifestTemplateClass.equals(V22ManifestTemplate.class)) {\n+      return Collections.singletonList(V22ManifestTemplate.MANIFEST_MEDIA_TYPE);\n+    }\n+    if (manifestTemplateClass.equals(OciManifestTemplate.class)) {\n+      return Collections.singletonList(OciManifestTemplate.MANIFEST_MEDIA_TYPE);\n+    }\n+    if (manifestTemplateClass.equals(V22ManifestListTemplate.class)) {\n+      return Collections.singletonList(V22ManifestListTemplate.MANIFEST_MEDIA_TYPE);\n+    }\n+\n+    // V22ManifestListTemplate is not included by default, we don't explicitly accept\n+    // it, we only handle it if referenced by sha256 (see getManifestTemplateFromJson) in which\n+    // case registries ignore the \"accept\" directive and just return a manifest list anyway.\n+    return Arrays.asList(\n+        OciManifestTemplate.MANIFEST_MEDIA_TYPE,\n+        V22ManifestTemplate.MANIFEST_MEDIA_TYPE,\n+        V21ManifestTemplate.MEDIA_TYPE);\n+  }\n+\n+  /** Parses the response body into a {@link ManifestAndDigest}. */\n+  @Override\n+  public Optional<ManifestAndDigest<T>> handleResponse(Response response)\n+      throws IOException, UnknownManifestFormatException {\n+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+    DescriptorDigest digest =\n+        Digests.computeDigest(response.getBody(), byteArrayOutputStream).getDigest();\n+    String jsonString = byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n+    T manifestTemplate = getManifestTemplateFromJson(jsonString);\n+    return Optional.of(new ManifestAndDigest<>(manifestTemplate, digest));\n+  }\n+\n+  @Override\n+  public URL getApiRoute(String apiRouteBase) throws MalformedURLException {\n+    return new URL(\n+        apiRouteBase\n+            + registryEndpointRequestProperties.getImageName()\n+            + \"/manifests/\"\n+            + imageDescriptor);\n+  }\n+\n+  @Override\n+  public String getHttpMethod() {\n+    return HttpMethods.GET;\n+  }\n+\n+  @Override\n+  public String getActionDescription() {\n+    return \"pull image manifest for \"\n+        + registryEndpointRequestProperties.getServerUrl()\n+        + \"/\"\n+        + registryEndpointRequestProperties.getImageName()\n+        + \":\"\n+        + imageDescriptor;\n+  }\n+\n+  /**\n+   * Instantiates a {@link ManifestTemplate} from a JSON string. This checks the {@code\n+   * schemaVersion} field of the JSON to determine which manifest version to use.\n+   */\n+  private T getManifestTemplateFromJson(String jsonString)\n+      throws IOException, UnknownManifestFormatException {\n+    ObjectNode node = new ObjectMapper().readValue(jsonString, ObjectNode.class);\n+    if (!node.has(\"schemaVersion\")) {\n+      throw new UnknownManifestFormatException(\"Cannot find field 'schemaVersion' in manifest\");\n+    }\n+\n+    int schemaVersion = node.get(\"schemaVersion\").asInt(-1);\n+    if (schemaVersion == -1) {\n+      throw new UnknownManifestFormatException(\"`schemaVersion` field is not an integer\");\n+    }\n+\n+    if (schemaVersion == 1) {\n+      return manifestTemplateClass.cast(\n+          JsonTemplateMapper.readJson(jsonString, V21ManifestTemplate.class));\n+    }\n+    if (schemaVersion == 2) {\n+      // 'schemaVersion' of 2 can be either Docker V2.2 or OCI.\n+      String mediaType = node.get(\"mediaType\").asText();\n+      if (V22ManifestTemplate.MANIFEST_MEDIA_TYPE.equals(mediaType)) {\n+        return manifestTemplateClass.cast(\n+            JsonTemplateMapper.readJson(jsonString, V22ManifestTemplate.class));\n+      }\n+      if (OciManifestTemplate.MANIFEST_MEDIA_TYPE.equals(mediaType)) {\n+        return manifestTemplateClass.cast(\n+            JsonTemplateMapper.readJson(jsonString, OciManifestTemplate.class));\n+      }\n+      if (V22ManifestListTemplate.MANIFEST_MEDIA_TYPE.equals(mediaType)) {\n+        return manifestTemplateClass.cast(\n+            JsonTemplateMapper.readJson(jsonString, V22ManifestListTemplate.class));\n+      }\n+      throw new UnknownManifestFormatException(\"Unknown mediaType: \" + mediaType);\n+    }\n+    throw new UnknownManifestFormatException(\n+        \"Unknown schemaVersion: \" + schemaVersion + \" - only 1 and 2 are supported\");\n+  }\n+\n+  @Override\n+  public Optional<ManifestAndDigest<T>> handleHttpResponseException(\n+      ResponseException responseException) throws ResponseException {\n+    if (responseException.getStatusCode() != HttpStatusCodes.STATUS_CODE_NOT_FOUND) {\n+      throw responseException;\n+    }\n+\n+    // Finds a MANIFEST_BLOB_UNKNOWN error response code.\n+    if (responseException.getContent() == null) {\n+      return Optional.empty();\n+    }\n+\n+    ErrorCodes errorCode = ErrorResponseUtil.getErrorCode(responseException);\n+    if (errorCode == ErrorCodes.MANIFEST_UNKNOWN) {\n+      return Optional.empty();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMzA1Mw=="}, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxMjM4Ng==", "bodyText": "Discussed this with @loosebazooka. I can take care of code duplication in a follow-up PR.", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450412386", "createdAt": "2020-07-06T18:43:12Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ManifestChecker.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.api.client.http.HttpMethods;\n+import com.google.api.client.http.HttpStatusCodes;\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.hash.Digests;\n+import com.google.cloud.tools.jib.http.BlobHttpContent;\n+import com.google.cloud.tools.jib.http.Response;\n+import com.google.cloud.tools.jib.http.ResponseException;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.OciManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.UnknownManifestFormatException;\n+import com.google.cloud.tools.jib.image.json.V21ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestListTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/** Checks an image's manifest. */\n+public class ManifestChecker<T extends ManifestTemplate>\n+    implements RegistryEndpointProvider<Optional<ManifestAndDigest<T>>> {\n+\n+  private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n+  private final String imageDescriptor;\n+  private final Class<T> manifestTemplateClass;\n+\n+  ManifestChecker(\n+      RegistryEndpointRequestProperties registryEndpointRequestProperties,\n+      String imageDescriptor,\n+      Class<T> manifestTemplateClass) {\n+    this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n+    this.imageDescriptor = imageDescriptor;\n+    this.manifestTemplateClass = manifestTemplateClass;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public BlobHttpContent getContent() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAccept() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA=="}, "originalCommit": {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzQ1NTU1", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#pullrequestreview-443345555", "createdAt": "2020-07-06T19:20:03Z", "commit": {"oid": "27c22cd9455b645f5307798e8571a963fa099d61"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxOToyMDowNFrOGtkGlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxOToyMDowNFrOGtkGlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQzMDYxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return ImmutableList.<PushImageStep>builder().build();\n          \n          \n            \n                    return ImmutableList.of();", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450430612", "createdAt": "2020-07-06T19:20:04Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushImageStep.java", "diffHunk": "@@ -47,16 +48,25 @@\n       ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n       RegistryClient registryClient,\n       BlobDescriptor containerConfigurationDigestAndSize,\n-      Image builtImage)\n+      Image builtImage,\n+      boolean manifestAlreadyExists)\n       throws IOException {\n     Set<String> tags = buildContext.getAllTargetImageTags();\n \n+    EventHandlers eventHandlers = buildContext.getEventHandlers();\n+\n     try (TimerEventDispatcher ignored =\n-            new TimerEventDispatcher(\n-                buildContext.getEventHandlers(), \"Preparing manifest pushers\");\n+            new TimerEventDispatcher(eventHandlers, \"Preparing manifest pushers\");\n         ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"launching manifest pushers\", tags.size())) {\n \n+      if (JibSystemProperties.skipExistingImages() && manifestAlreadyExists) {\n+        eventHandlers.dispatch(\n+            LogEvent.info(\"Skipping pushing manifest; manifest already exists.\"));\n+\n+        return ImmutableList.<PushImageStep>builder().build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27c22cd9455b645f5307798e8571a963fa099d61"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3fb5093898c56728164b36b74b306a70931ecd3", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/c3fb5093898c56728164b36b74b306a70931ecd3", "committedDate": "2020-07-06T21:09:08Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f132d74cc7a8efd4cf47abe9410e4924c2ae45e0", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/f132d74cc7a8efd4cf47abe9410e4924c2ae45e0", "committedDate": "2020-07-06T21:25:23Z", "message": "Merge remote-tracking branch 'origin/master' into karlmuscat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "026f2e29653f446fbce772981e9085440c1d95c2", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/026f2e29653f446fbce772981e9085440c1d95c2", "committedDate": "2020-07-06T22:01:19Z", "message": "CHANGELOG"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6756f1cfe3b6e5b3ba882be59d603a37424dfa3f", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/6756f1cfe3b6e5b3ba882be59d603a37424dfa3f", "committedDate": "2020-07-06T22:05:52Z", "message": "Update comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ebc0610c67a319664eea8f21c3a8b7a7762e34f", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/2ebc0610c67a319664eea8f21c3a8b7a7762e34f", "committedDate": "2020-07-07T14:21:37Z", "message": "Improve test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTU4MDMy", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#pullrequestreview-443958032", "createdAt": "2020-07-07T14:39:24Z", "commit": {"oid": "2ebc0610c67a319664eea8f21c3a8b7a7762e34f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 42, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}