{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzMzYzMDYz", "number": 2789, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwMjo0MDozOVrOEoVDFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwMzowMDo1MVrOEoVQxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNzIzMzQ5OnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwMjo0MDozOVrOHZWexA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNToxNjo0NFrOHaitKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NDc3Mg==", "bodyText": "should we actually do LogEvent.warn here with some guidance on reporting this, so that we may identify misbehaving servers by user reports?", "url": "https://github.com/GoogleContainerTools/jib/pull/2789#discussion_r496344772", "createdAt": "2020-09-29T02:40:39Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -140,40 +143,43 @@ public ImagesAndRegistryClient call()\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        Credential registryCredential =\n+        Credential credential =\n             RegistryCredentialRetriever.getBaseImageCredential(buildContext).orElse(null);\n-\n         RegistryClient registryClient =\n             buildContext\n                 .newBaseImageRegistryClientFactory()\n-                .setCredential(registryCredential)\n+                .setCredential(credential)\n                 .newRegistryClient();\n \n-        try {\n-          // TODO: refactor the code (https://github.com/GoogleContainerTools/jib/pull/2202)\n-          if (registryCredential == null || registryCredential.isOAuth2RefreshToken()) {\n-            throw ex;\n-          }\n-\n-          eventHandlers.dispatch(LogEvent.debug(\"Trying basic auth for \" + imageReference + \"...\"));\n-          registryClient.configureBasicAuth();\n+        String wwwAuthenticate = ex.getHttpResponseException().getHeaders().getAuthenticate();\n+        if (wwwAuthenticate != null) {\n+          eventHandlers.dispatch(\n+              LogEvent.debug(\"WWW-Authenticate for \" + imageReference + \": \" + wwwAuthenticate));\n+          registryClient.authPullByWwwAuthenticate(wwwAuthenticate);\n           return new ImagesAndRegistryClient(\n               pullBaseImages(registryClient, progressEventDispatcher), registryClient);\n \n-        } catch (RegistryUnauthorizedException registryUnauthorizedException) {\n-          // The registry requires us to authenticate using the Docker Token Authentication.\n-          // See https://docs.docker.com/registry/spec/auth/token\n-          eventHandlers.dispatch(\n-              LogEvent.debug(\"Trying bearer auth for \" + imageReference + \"...\"));\n-          if (registryClient.doPullBearerAuth()) {\n-            return new ImagesAndRegistryClient(\n-                pullBaseImages(registryClient, progressEventDispatcher), registryClient);\n+        } else {\n+          // Not getting WWW-Authenticate is unexpected in practice, and we may just blame the\n+          // server and fail. However, to keep some old behavior, try a few things as a last resort.\n+          // TODO: consider removing this fallback branch.\n+          if (credential != null && !credential.isOAuth2RefreshToken()) {\n+            eventHandlers.dispatch(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93c5daf32a1e4e6c8abd2334d955226a9b5a0b8f"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5Mjg3MQ==", "bodyText": "I still think this is a good idea to identify registries that are acting strange. But up to you.", "url": "https://github.com/GoogleContainerTools/jib/pull/2789#discussion_r497092871", "createdAt": "2020-09-29T22:17:27Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -140,40 +143,43 @@ public ImagesAndRegistryClient call()\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        Credential registryCredential =\n+        Credential credential =\n             RegistryCredentialRetriever.getBaseImageCredential(buildContext).orElse(null);\n-\n         RegistryClient registryClient =\n             buildContext\n                 .newBaseImageRegistryClientFactory()\n-                .setCredential(registryCredential)\n+                .setCredential(credential)\n                 .newRegistryClient();\n \n-        try {\n-          // TODO: refactor the code (https://github.com/GoogleContainerTools/jib/pull/2202)\n-          if (registryCredential == null || registryCredential.isOAuth2RefreshToken()) {\n-            throw ex;\n-          }\n-\n-          eventHandlers.dispatch(LogEvent.debug(\"Trying basic auth for \" + imageReference + \"...\"));\n-          registryClient.configureBasicAuth();\n+        String wwwAuthenticate = ex.getHttpResponseException().getHeaders().getAuthenticate();\n+        if (wwwAuthenticate != null) {\n+          eventHandlers.dispatch(\n+              LogEvent.debug(\"WWW-Authenticate for \" + imageReference + \": \" + wwwAuthenticate));\n+          registryClient.authPullByWwwAuthenticate(wwwAuthenticate);\n           return new ImagesAndRegistryClient(\n               pullBaseImages(registryClient, progressEventDispatcher), registryClient);\n \n-        } catch (RegistryUnauthorizedException registryUnauthorizedException) {\n-          // The registry requires us to authenticate using the Docker Token Authentication.\n-          // See https://docs.docker.com/registry/spec/auth/token\n-          eventHandlers.dispatch(\n-              LogEvent.debug(\"Trying bearer auth for \" + imageReference + \"...\"));\n-          if (registryClient.doPullBearerAuth()) {\n-            return new ImagesAndRegistryClient(\n-                pullBaseImages(registryClient, progressEventDispatcher), registryClient);\n+        } else {\n+          // Not getting WWW-Authenticate is unexpected in practice, and we may just blame the\n+          // server and fail. However, to keep some old behavior, try a few things as a last resort.\n+          // TODO: consider removing this fallback branch.\n+          if (credential != null && !credential.isOAuth2RefreshToken()) {\n+            eventHandlers.dispatch(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NDc3Mg=="}, "originalCommit": {"oid": "93c5daf32a1e4e6c8abd2334d955226a9b5a0b8f"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5MzY0MA==", "bodyText": "Sorry, I missed this comment. I thought about that, and I agree logging a warning will be very valuable to us. But I think a warning should be something actionable and fixable on the user side, so that's my hesitation. I've seen some people regard a warning seriously (probably because of a 0-warning policy auto-enforced by some system). Gathering information is really useful to us, but I feel we should be careful for dual-purposing a warning.", "url": "https://github.com/GoogleContainerTools/jib/pull/2789#discussion_r497593640", "createdAt": "2020-09-30T15:16:44Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -140,40 +143,43 @@ public ImagesAndRegistryClient call()\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        Credential registryCredential =\n+        Credential credential =\n             RegistryCredentialRetriever.getBaseImageCredential(buildContext).orElse(null);\n-\n         RegistryClient registryClient =\n             buildContext\n                 .newBaseImageRegistryClientFactory()\n-                .setCredential(registryCredential)\n+                .setCredential(credential)\n                 .newRegistryClient();\n \n-        try {\n-          // TODO: refactor the code (https://github.com/GoogleContainerTools/jib/pull/2202)\n-          if (registryCredential == null || registryCredential.isOAuth2RefreshToken()) {\n-            throw ex;\n-          }\n-\n-          eventHandlers.dispatch(LogEvent.debug(\"Trying basic auth for \" + imageReference + \"...\"));\n-          registryClient.configureBasicAuth();\n+        String wwwAuthenticate = ex.getHttpResponseException().getHeaders().getAuthenticate();\n+        if (wwwAuthenticate != null) {\n+          eventHandlers.dispatch(\n+              LogEvent.debug(\"WWW-Authenticate for \" + imageReference + \": \" + wwwAuthenticate));\n+          registryClient.authPullByWwwAuthenticate(wwwAuthenticate);\n           return new ImagesAndRegistryClient(\n               pullBaseImages(registryClient, progressEventDispatcher), registryClient);\n \n-        } catch (RegistryUnauthorizedException registryUnauthorizedException) {\n-          // The registry requires us to authenticate using the Docker Token Authentication.\n-          // See https://docs.docker.com/registry/spec/auth/token\n-          eventHandlers.dispatch(\n-              LogEvent.debug(\"Trying bearer auth for \" + imageReference + \"...\"));\n-          if (registryClient.doPullBearerAuth()) {\n-            return new ImagesAndRegistryClient(\n-                pullBaseImages(registryClient, progressEventDispatcher), registryClient);\n+        } else {\n+          // Not getting WWW-Authenticate is unexpected in practice, and we may just blame the\n+          // server and fail. However, to keep some old behavior, try a few things as a last resort.\n+          // TODO: consider removing this fallback branch.\n+          if (credential != null && !credential.isOAuth2RefreshToken()) {\n+            eventHandlers.dispatch(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NDc3Mg=="}, "originalCommit": {"oid": "93c5daf32a1e4e6c8abd2334d955226a9b5a0b8f"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNzIzOTU3OnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwMjo0NDoxMVrOHZWiPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjozNjozMlrOHZ3S0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NTY2MA==", "bodyText": "It seems a little strange that we have so much auth code in PullBaseImage step and not somewhere else like RegistryAuthenticator?", "url": "https://github.com/GoogleContainerTools/jib/pull/2789#discussion_r496345660", "createdAt": "2020-09-29T02:44:11Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -140,40 +143,43 @@ public ImagesAndRegistryClient call()\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        Credential registryCredential =\n+        Credential credential =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93c5daf32a1e4e6c8abd2334d955226a9b5a0b8f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4MjM4NA==", "bodyText": "(First of all, I don't know the initial intention of RegistryAuthenticator, but in reality it has always been \"BearerAuthenticator\" that's only about bearer auth.)\nAs discussed offline, we could have introduced an overarching RegistryClient.doRightAuth() that perhaps does\nif (!doPull/PushBearerAuth()) {\n ... \n configureBasicAuth();\n}\nI expect this flow should work for both pull and push auth with any registries, and this is exactly the flow we do for target registry auth. However, we were taking a different flow for base image registries (as can be seen in the PR), and what is one of the reasons we don't have doRightAuth().\nGiven this and that RegistryClient is a low-level API, it also seemed reasonable to have separate nobs for configuring basic auth and completing bearer auth. Another factor to this is the difference between configuring basic auth and completing the whole bearer auth leg: configuring basic auth means that you'll just send the credentials going forward no matter what, while completing bearer auth means interacting with a registry server and an auth server with two round-trips to get another form of credentials to send going forward.", "url": "https://github.com/GoogleContainerTools/jib/pull/2789#discussion_r496882384", "createdAt": "2020-09-29T16:36:32Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -140,40 +143,43 @@ public ImagesAndRegistryClient call()\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        Credential registryCredential =\n+        Credential credential =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NTY2MA=="}, "originalCommit": {"oid": "93c5daf32a1e4e6c8abd2334d955226a9b5a0b8f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNzI2ODUyOnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwMzowMDo1MVrOHZWzFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMjoxNjo1NVrOHaEIRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0OTk3NA==", "bodyText": "I find this flow a little confusing. Should we just have multiple types of credentials instead of checking the state of the Credential everywhere?", "url": "https://github.com/GoogleContainerTools/jib/pull/2789#discussion_r496349974", "createdAt": "2020-09-29T03:00:51Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -366,6 +377,27 @@ private Authorization refreshBearerAuth(@Nullable String wwwAuthenticate)\n     return Verify.verifyNotNull(initialBearerAuthenticator.get()).authenticatePush(credential);\n   }\n \n+  /**\n+   * Configure basic authentication or attempts bearer authentication for pulling based on the\n+   * specified authentication method in a server response.\n+   *\n+   * @param wwwAuthenticate {@code WWW-Authenticate} HTTP header value from a server response\n+   *     specifying a required authentication method\n+   * @throws RegistryException if communicating with the endpoint fails\n+   * @throws RegistryAuthenticationFailedException if authentication fails\n+   * @throws RegistryCredentialsNotSentException if authentication failed and credentials were not\n+   */\n+  public void authPullByWwwAuthenticate(String wwwAuthenticate) throws RegistryException {\n+    Optional<RegistryAuthenticator> authenticator =\n+        RegistryAuthenticator.fromAuthenticationMethod(\n+            wwwAuthenticate, registryEndpointRequestProperties, getUserAgent(), httpClient);\n+    if (authenticator.isPresent()) {\n+      doBearerAuth(true, authenticator.get());\n+    } else if (credential != null && !credential.isOAuth2RefreshToken()) {\n+      configureBasicAuth();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93c5daf32a1e4e6c8abd2334d955226a9b5a0b8f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4MzI2NQ==", "bodyText": "Like defining subclasses of Credentials?", "url": "https://github.com/GoogleContainerTools/jib/pull/2789#discussion_r496883265", "createdAt": "2020-09-29T16:37:54Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -366,6 +377,27 @@ private Authorization refreshBearerAuth(@Nullable String wwwAuthenticate)\n     return Verify.verifyNotNull(initialBearerAuthenticator.get()).authenticatePush(credential);\n   }\n \n+  /**\n+   * Configure basic authentication or attempts bearer authentication for pulling based on the\n+   * specified authentication method in a server response.\n+   *\n+   * @param wwwAuthenticate {@code WWW-Authenticate} HTTP header value from a server response\n+   *     specifying a required authentication method\n+   * @throws RegistryException if communicating with the endpoint fails\n+   * @throws RegistryAuthenticationFailedException if authentication fails\n+   * @throws RegistryCredentialsNotSentException if authentication failed and credentials were not\n+   */\n+  public void authPullByWwwAuthenticate(String wwwAuthenticate) throws RegistryException {\n+    Optional<RegistryAuthenticator> authenticator =\n+        RegistryAuthenticator.fromAuthenticationMethod(\n+            wwwAuthenticate, registryEndpointRequestProperties, getUserAgent(), httpClient);\n+    if (authenticator.isPresent()) {\n+      doBearerAuth(true, authenticator.get());\n+    } else if (credential != null && !credential.isOAuth2RefreshToken()) {\n+      configureBasicAuth();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0OTk3NA=="}, "originalCommit": {"oid": "93c5daf32a1e4e6c8abd2334d955226a9b5a0b8f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5MjY3OA==", "bodyText": "Yeah I don't know, I've haven't done much in this section of the code base, so it's all a little strange.", "url": "https://github.com/GoogleContainerTools/jib/pull/2789#discussion_r497092678", "createdAt": "2020-09-29T22:16:55Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -366,6 +377,27 @@ private Authorization refreshBearerAuth(@Nullable String wwwAuthenticate)\n     return Verify.verifyNotNull(initialBearerAuthenticator.get()).authenticatePush(credential);\n   }\n \n+  /**\n+   * Configure basic authentication or attempts bearer authentication for pulling based on the\n+   * specified authentication method in a server response.\n+   *\n+   * @param wwwAuthenticate {@code WWW-Authenticate} HTTP header value from a server response\n+   *     specifying a required authentication method\n+   * @throws RegistryException if communicating with the endpoint fails\n+   * @throws RegistryAuthenticationFailedException if authentication fails\n+   * @throws RegistryCredentialsNotSentException if authentication failed and credentials were not\n+   */\n+  public void authPullByWwwAuthenticate(String wwwAuthenticate) throws RegistryException {\n+    Optional<RegistryAuthenticator> authenticator =\n+        RegistryAuthenticator.fromAuthenticationMethod(\n+            wwwAuthenticate, registryEndpointRequestProperties, getUserAgent(), httpClient);\n+    if (authenticator.isPresent()) {\n+      doBearerAuth(true, authenticator.get());\n+    } else if (credential != null && !credential.isOAuth2RefreshToken()) {\n+      configureBasicAuth();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0OTk3NA=="}, "originalCommit": {"oid": "93c5daf32a1e4e6c8abd2334d955226a9b5a0b8f"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4931, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}