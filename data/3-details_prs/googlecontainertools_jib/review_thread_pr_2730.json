{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0MTU0MDgz", "number": 2730, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTowNjowOFrOEdQ9oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0MDo1N1rOEdXKIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTIyMDgxOnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNTowNjowOFrOHIUujw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODo1MTo0MlrOHIdEKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5MDI1NQ==", "bodyText": "I thought we could still run into an issue where we don't have all the necessary platform information for an image/platform that wasn't previously referenced?\nI assume downloading all the image layers for all the images is impractical?", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478490255", "createdAt": "2020-08-27T15:06:08Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -105,28 +106,21 @@ public ImagesAndRegistryClient call()\n         LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n     if (buildContext.isOffline()) {\n-      Optional<Image> image = getCachedBaseImage();\n-      if (image.isPresent()) {\n-        if (!checkImagePlatform(image.get())) {\n-          throw new IllegalStateException(\n-              \"The cached base image manifest does not match the configured platform due to the \"\n-                  + \"current implementation of limited platform support. As a workaround, re-run \"\n-                  + \"Jib online once to re-cache the right image manifest.\");\n-        }\n-        return new ImagesAndRegistryClient(Collections.singletonList(image.get()), null);\n+      List<Image> images = getCachedBaseImages();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c01c470fcc2106783f163fb9ae23e5573e5ed96d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYyNjg1Ng==", "bodyText": "where we don't have all the necessary platform information for an image/platform that wasn't previously referenced?\n\nIn this case, the getCachedBaseImages() in this PR returns an empty list (i.e., cache miss). Offline building will fail and suggest to re-run online once. The digest reference case will fall through to normal operation (contacting the base image repository).", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478626856", "createdAt": "2020-08-27T18:51:42Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -105,28 +106,21 @@ public ImagesAndRegistryClient call()\n         LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n     if (buildContext.isOffline()) {\n-      Optional<Image> image = getCachedBaseImage();\n-      if (image.isPresent()) {\n-        if (!checkImagePlatform(image.get())) {\n-          throw new IllegalStateException(\n-              \"The cached base image manifest does not match the configured platform due to the \"\n-                  + \"current implementation of limited platform support. As a workaround, re-run \"\n-                  + \"Jib online once to re-cache the right image manifest.\");\n-        }\n-        return new ImagesAndRegistryClient(Collections.singletonList(image.get()), null);\n+      List<Image> images = getCachedBaseImages();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5MDI1NQ=="}, "originalCommit": {"oid": "c01c470fcc2106783f163fb9ae23e5573e5ed96d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTcxNzA5OnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/image/json/ManifestAndConfigTemplate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNzowODoyM1rOHIZk5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODo1MjoyMlrOHIdFhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2OTcwMQ==", "bodyText": "maybe \"the registry manifest\"?", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478569701", "createdAt": "2020-08-27T17:08:23Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/image/json/ManifestAndConfigTemplate.java", "diffHunk": "@@ -43,13 +43,36 @@\n   @SuppressWarnings(\"unused\")\n   private ManifestAndConfigTemplate() {}\n \n+  /**\n+   * Creates an instance.\n+   *\n+   * @param manifest the manifest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6426994e5e7a5c8a77b7aa6dd39e4f133c51fe16"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYyNzIwNw==", "bodyText": "I think \"the image manifest\" is more suitable.", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478627207", "createdAt": "2020-08-27T18:52:22Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/image/json/ManifestAndConfigTemplate.java", "diffHunk": "@@ -43,13 +43,36 @@\n   @SuppressWarnings(\"unused\")\n   private ManifestAndConfigTemplate() {}\n \n+  /**\n+   * Creates an instance.\n+   *\n+   * @param manifest the manifest", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2OTcwMQ=="}, "originalCommit": {"oid": "6426994e5e7a5c8a77b7aa6dd39e4f133c51fe16"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjE4Nzc3OnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOToyNjowNlrOHIeK6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNDoxOTo0M1rOHJIZfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0NDk3MQ==", "bodyText": "So this section is for when the base image reference is a single manifest?", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478644971", "createdAt": "2020-08-27T19:26:06Z", "author": {"login": "mpeddada1"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -351,35 +330,67 @@ private ContainerConfigurationTemplate pullContainerConfigJson(\n   }\n \n   /**\n-   * Retrieves the cached base image.\n+   * Retrieves the cached base images. If a base image reference is not a manifest list, returns a\n+   * single image (if cached). If a manifest list, returns all the images matching the configured\n+   * platforms in the manifest list but only when all of the images are cached.\n    *\n-   * @return the cached image, if found\n+   * @return the cached images, if found\n    * @throws IOException when an I/O exception occurs\n    * @throws CacheCorruptedException if the cache is corrupted\n    * @throws LayerPropertyNotFoundException if adding image layers fails\n    * @throws BadContainerConfigurationFormatException if the container configuration is in a bad\n    *     format\n+   * @throws UnlistedPlatformInManifestListException if a cached manifest list has no manifests\n+   *     matching the configured platform\n    */\n-  private Optional<Image> getCachedBaseImage()\n+  @VisibleForTesting\n+  List<Image> getCachedBaseImages()\n       throws IOException, CacheCorruptedException, BadContainerConfigurationFormatException,\n-          LayerCountMismatchException {\n+          LayerCountMismatchException, UnlistedPlatformInManifestListException {\n     ImageReference baseImage = buildContext.getBaseImageConfiguration().getImage();\n     Optional<ImageMetadataTemplate> metadata =\n         buildContext.getBaseImageLayersCache().retrieveMetadata(baseImage);\n     if (!metadata.isPresent()) {\n-      return Optional.empty();\n+      return Collections.emptyList();\n     }\n \n+    ManifestTemplate manifestList = metadata.get().getManifestList();\n     List<ManifestAndConfigTemplate> manifestsAndConfigs = metadata.get().getManifestsAndConfigs();\n-    Verify.verify(manifestsAndConfigs.size() == 1);\n-    ManifestTemplate manifest = Verify.verifyNotNull(manifestsAndConfigs.get(0).getManifest());\n-    if (manifest instanceof V21ManifestTemplate) {\n-      return Optional.of(JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+\n+    if (manifestList == null) {\n+      Verify.verify(manifestsAndConfigs.size() == 1);\n+      ManifestTemplate manifest = manifestsAndConfigs.get(0).getManifest();\n+      if (manifest instanceof V21ManifestTemplate) {\n+        return Collections.singletonList(\n+            JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+      }\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(\n+              (BuildableManifestTemplate) Verify.verifyNotNull(manifest),\n+              Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e170f76f600c57753f3b19e7cca38c93fa89084a"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MzY4NQ==", "bodyText": "Exactly. When the image reference is an image manifest and not a manifest list. In the cache metadata, manifestList is null in this case.", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478653685", "createdAt": "2020-08-27T19:43:11Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -351,35 +330,67 @@ private ContainerConfigurationTemplate pullContainerConfigJson(\n   }\n \n   /**\n-   * Retrieves the cached base image.\n+   * Retrieves the cached base images. If a base image reference is not a manifest list, returns a\n+   * single image (if cached). If a manifest list, returns all the images matching the configured\n+   * platforms in the manifest list but only when all of the images are cached.\n    *\n-   * @return the cached image, if found\n+   * @return the cached images, if found\n    * @throws IOException when an I/O exception occurs\n    * @throws CacheCorruptedException if the cache is corrupted\n    * @throws LayerPropertyNotFoundException if adding image layers fails\n    * @throws BadContainerConfigurationFormatException if the container configuration is in a bad\n    *     format\n+   * @throws UnlistedPlatformInManifestListException if a cached manifest list has no manifests\n+   *     matching the configured platform\n    */\n-  private Optional<Image> getCachedBaseImage()\n+  @VisibleForTesting\n+  List<Image> getCachedBaseImages()\n       throws IOException, CacheCorruptedException, BadContainerConfigurationFormatException,\n-          LayerCountMismatchException {\n+          LayerCountMismatchException, UnlistedPlatformInManifestListException {\n     ImageReference baseImage = buildContext.getBaseImageConfiguration().getImage();\n     Optional<ImageMetadataTemplate> metadata =\n         buildContext.getBaseImageLayersCache().retrieveMetadata(baseImage);\n     if (!metadata.isPresent()) {\n-      return Optional.empty();\n+      return Collections.emptyList();\n     }\n \n+    ManifestTemplate manifestList = metadata.get().getManifestList();\n     List<ManifestAndConfigTemplate> manifestsAndConfigs = metadata.get().getManifestsAndConfigs();\n-    Verify.verify(manifestsAndConfigs.size() == 1);\n-    ManifestTemplate manifest = Verify.verifyNotNull(manifestsAndConfigs.get(0).getManifest());\n-    if (manifest instanceof V21ManifestTemplate) {\n-      return Optional.of(JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+\n+    if (manifestList == null) {\n+      Verify.verify(manifestsAndConfigs.size() == 1);\n+      ManifestTemplate manifest = manifestsAndConfigs.get(0).getManifest();\n+      if (manifest instanceof V21ManifestTemplate) {\n+        return Collections.singletonList(\n+            JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+      }\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(\n+              (BuildableManifestTemplate) Verify.verifyNotNull(manifest),\n+              Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0NDk3MQ=="}, "originalCommit": {"oid": "e170f76f600c57753f3b19e7cca38c93fa89084a"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1NTM1MA==", "bodyText": "Ah gotcha, is there a particular reason why we chose null instead of an empty list for manifestList?", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478655350", "createdAt": "2020-08-27T19:46:14Z", "author": {"login": "mpeddada1"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -351,35 +330,67 @@ private ContainerConfigurationTemplate pullContainerConfigJson(\n   }\n \n   /**\n-   * Retrieves the cached base image.\n+   * Retrieves the cached base images. If a base image reference is not a manifest list, returns a\n+   * single image (if cached). If a manifest list, returns all the images matching the configured\n+   * platforms in the manifest list but only when all of the images are cached.\n    *\n-   * @return the cached image, if found\n+   * @return the cached images, if found\n    * @throws IOException when an I/O exception occurs\n    * @throws CacheCorruptedException if the cache is corrupted\n    * @throws LayerPropertyNotFoundException if adding image layers fails\n    * @throws BadContainerConfigurationFormatException if the container configuration is in a bad\n    *     format\n+   * @throws UnlistedPlatformInManifestListException if a cached manifest list has no manifests\n+   *     matching the configured platform\n    */\n-  private Optional<Image> getCachedBaseImage()\n+  @VisibleForTesting\n+  List<Image> getCachedBaseImages()\n       throws IOException, CacheCorruptedException, BadContainerConfigurationFormatException,\n-          LayerCountMismatchException {\n+          LayerCountMismatchException, UnlistedPlatformInManifestListException {\n     ImageReference baseImage = buildContext.getBaseImageConfiguration().getImage();\n     Optional<ImageMetadataTemplate> metadata =\n         buildContext.getBaseImageLayersCache().retrieveMetadata(baseImage);\n     if (!metadata.isPresent()) {\n-      return Optional.empty();\n+      return Collections.emptyList();\n     }\n \n+    ManifestTemplate manifestList = metadata.get().getManifestList();\n     List<ManifestAndConfigTemplate> manifestsAndConfigs = metadata.get().getManifestsAndConfigs();\n-    Verify.verify(manifestsAndConfigs.size() == 1);\n-    ManifestTemplate manifest = Verify.verifyNotNull(manifestsAndConfigs.get(0).getManifest());\n-    if (manifest instanceof V21ManifestTemplate) {\n-      return Optional.of(JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+\n+    if (manifestList == null) {\n+      Verify.verify(manifestsAndConfigs.size() == 1);\n+      ManifestTemplate manifest = manifestsAndConfigs.get(0).getManifest();\n+      if (manifest instanceof V21ManifestTemplate) {\n+        return Collections.singletonList(\n+            JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+      }\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(\n+              (BuildableManifestTemplate) Verify.verifyNotNull(manifest),\n+              Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0NDk3MQ=="}, "originalCommit": {"oid": "e170f76f600c57753f3b19e7cca38c93fa89084a"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1ODczMg==", "bodyText": "Good question. A \"manifest list\" is not a List in Java but a class called ManifestTemplate.", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478658732", "createdAt": "2020-08-27T19:52:42Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -351,35 +330,67 @@ private ContainerConfigurationTemplate pullContainerConfigJson(\n   }\n \n   /**\n-   * Retrieves the cached base image.\n+   * Retrieves the cached base images. If a base image reference is not a manifest list, returns a\n+   * single image (if cached). If a manifest list, returns all the images matching the configured\n+   * platforms in the manifest list but only when all of the images are cached.\n    *\n-   * @return the cached image, if found\n+   * @return the cached images, if found\n    * @throws IOException when an I/O exception occurs\n    * @throws CacheCorruptedException if the cache is corrupted\n    * @throws LayerPropertyNotFoundException if adding image layers fails\n    * @throws BadContainerConfigurationFormatException if the container configuration is in a bad\n    *     format\n+   * @throws UnlistedPlatformInManifestListException if a cached manifest list has no manifests\n+   *     matching the configured platform\n    */\n-  private Optional<Image> getCachedBaseImage()\n+  @VisibleForTesting\n+  List<Image> getCachedBaseImages()\n       throws IOException, CacheCorruptedException, BadContainerConfigurationFormatException,\n-          LayerCountMismatchException {\n+          LayerCountMismatchException, UnlistedPlatformInManifestListException {\n     ImageReference baseImage = buildContext.getBaseImageConfiguration().getImage();\n     Optional<ImageMetadataTemplate> metadata =\n         buildContext.getBaseImageLayersCache().retrieveMetadata(baseImage);\n     if (!metadata.isPresent()) {\n-      return Optional.empty();\n+      return Collections.emptyList();\n     }\n \n+    ManifestTemplate manifestList = metadata.get().getManifestList();\n     List<ManifestAndConfigTemplate> manifestsAndConfigs = metadata.get().getManifestsAndConfigs();\n-    Verify.verify(manifestsAndConfigs.size() == 1);\n-    ManifestTemplate manifest = Verify.verifyNotNull(manifestsAndConfigs.get(0).getManifest());\n-    if (manifest instanceof V21ManifestTemplate) {\n-      return Optional.of(JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+\n+    if (manifestList == null) {\n+      Verify.verify(manifestsAndConfigs.size() == 1);\n+      ManifestTemplate manifest = manifestsAndConfigs.get(0).getManifest();\n+      if (manifest instanceof V21ManifestTemplate) {\n+        return Collections.singletonList(\n+            JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+      }\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(\n+              (BuildableManifestTemplate) Verify.verifyNotNull(manifest),\n+              Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0NDk3MQ=="}, "originalCommit": {"oid": "e170f76f600c57753f3b19e7cca38c93fa89084a"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMzNjgzMQ==", "bodyText": "Right my bad, thanks for clarifying:)", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r479336831", "createdAt": "2020-08-28T14:19:43Z", "author": {"login": "mpeddada1"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -351,35 +330,67 @@ private ContainerConfigurationTemplate pullContainerConfigJson(\n   }\n \n   /**\n-   * Retrieves the cached base image.\n+   * Retrieves the cached base images. If a base image reference is not a manifest list, returns a\n+   * single image (if cached). If a manifest list, returns all the images matching the configured\n+   * platforms in the manifest list but only when all of the images are cached.\n    *\n-   * @return the cached image, if found\n+   * @return the cached images, if found\n    * @throws IOException when an I/O exception occurs\n    * @throws CacheCorruptedException if the cache is corrupted\n    * @throws LayerPropertyNotFoundException if adding image layers fails\n    * @throws BadContainerConfigurationFormatException if the container configuration is in a bad\n    *     format\n+   * @throws UnlistedPlatformInManifestListException if a cached manifest list has no manifests\n+   *     matching the configured platform\n    */\n-  private Optional<Image> getCachedBaseImage()\n+  @VisibleForTesting\n+  List<Image> getCachedBaseImages()\n       throws IOException, CacheCorruptedException, BadContainerConfigurationFormatException,\n-          LayerCountMismatchException {\n+          LayerCountMismatchException, UnlistedPlatformInManifestListException {\n     ImageReference baseImage = buildContext.getBaseImageConfiguration().getImage();\n     Optional<ImageMetadataTemplate> metadata =\n         buildContext.getBaseImageLayersCache().retrieveMetadata(baseImage);\n     if (!metadata.isPresent()) {\n-      return Optional.empty();\n+      return Collections.emptyList();\n     }\n \n+    ManifestTemplate manifestList = metadata.get().getManifestList();\n     List<ManifestAndConfigTemplate> manifestsAndConfigs = metadata.get().getManifestsAndConfigs();\n-    Verify.verify(manifestsAndConfigs.size() == 1);\n-    ManifestTemplate manifest = Verify.verifyNotNull(manifestsAndConfigs.get(0).getManifest());\n-    if (manifest instanceof V21ManifestTemplate) {\n-      return Optional.of(JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+\n+    if (manifestList == null) {\n+      Verify.verify(manifestsAndConfigs.size() == 1);\n+      ManifestTemplate manifest = manifestsAndConfigs.get(0).getManifest();\n+      if (manifest instanceof V21ManifestTemplate) {\n+        return Collections.singletonList(\n+            JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+      }\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(\n+              (BuildableManifestTemplate) Verify.verifyNotNull(manifest),\n+              Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0NDk3MQ=="}, "originalCommit": {"oid": "e170f76f600c57753f3b19e7cca38c93fa89084a"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjIwMjYzOnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozMDozM1rOHIeT-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0MTo1NFrOHIeqaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0NzI5MQ==", "bodyText": "Why do we make sure to return the images matching the configured platforms in the manifest list only if all the images are cached?", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478647291", "createdAt": "2020-08-27T19:30:33Z", "author": {"login": "mpeddada1"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -351,35 +330,67 @@ private ContainerConfigurationTemplate pullContainerConfigJson(\n   }\n \n   /**\n-   * Retrieves the cached base image.\n+   * Retrieves the cached base images. If a base image reference is not a manifest list, returns a\n+   * single image (if cached). If a manifest list, returns all the images matching the configured\n+   * platforms in the manifest list but only when all of the images are cached.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e170f76f600c57753f3b19e7cca38c93fa89084a"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MzAzNQ==", "bodyText": "If we have cached only a subset of what we really need (i.e., Jib needs to build, say, three Images, but the cache has only two Images), then it's not a cache hit as a whole, thus a cache miss.\nTheoretically you could say, Jib could re-download only the missing Images, but note that performance is not the reason for caching. It's about whether we can completely avoid accessing the Internet or not. So, if any image is missing in the cache, I am saying \"cache miss\" for simplicity.", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478653035", "createdAt": "2020-08-27T19:41:54Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -351,35 +330,67 @@ private ContainerConfigurationTemplate pullContainerConfigJson(\n   }\n \n   /**\n-   * Retrieves the cached base image.\n+   * Retrieves the cached base images. If a base image reference is not a manifest list, returns a\n+   * single image (if cached). If a manifest list, returns all the images matching the configured\n+   * platforms in the manifest list but only when all of the images are cached.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0NzI5MQ=="}, "originalCommit": {"oid": "e170f76f600c57753f3b19e7cca38c93fa89084a"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjIzNTg1OnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0MDo1N1rOHIeoew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNDoyMDozNFrOHJIbuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MjUzOQ==", "bodyText": "I may be missing something here but what's the reasoning behind checking if these values are null?/ When would they be null?", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478652539", "createdAt": "2020-08-27T19:40:57Z", "author": {"login": "mpeddada1"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -351,35 +330,67 @@ private ContainerConfigurationTemplate pullContainerConfigJson(\n   }\n \n   /**\n-   * Retrieves the cached base image.\n+   * Retrieves the cached base images. If a base image reference is not a manifest list, returns a\n+   * single image (if cached). If a manifest list, returns all the images matching the configured\n+   * platforms in the manifest list but only when all of the images are cached.\n    *\n-   * @return the cached image, if found\n+   * @return the cached images, if found\n    * @throws IOException when an I/O exception occurs\n    * @throws CacheCorruptedException if the cache is corrupted\n    * @throws LayerPropertyNotFoundException if adding image layers fails\n    * @throws BadContainerConfigurationFormatException if the container configuration is in a bad\n    *     format\n+   * @throws UnlistedPlatformInManifestListException if a cached manifest list has no manifests\n+   *     matching the configured platform\n    */\n-  private Optional<Image> getCachedBaseImage()\n+  @VisibleForTesting\n+  List<Image> getCachedBaseImages()\n       throws IOException, CacheCorruptedException, BadContainerConfigurationFormatException,\n-          LayerCountMismatchException {\n+          LayerCountMismatchException, UnlistedPlatformInManifestListException {\n     ImageReference baseImage = buildContext.getBaseImageConfiguration().getImage();\n     Optional<ImageMetadataTemplate> metadata =\n         buildContext.getBaseImageLayersCache().retrieveMetadata(baseImage);\n     if (!metadata.isPresent()) {\n-      return Optional.empty();\n+      return Collections.emptyList();\n     }\n \n+    ManifestTemplate manifestList = metadata.get().getManifestList();\n     List<ManifestAndConfigTemplate> manifestsAndConfigs = metadata.get().getManifestsAndConfigs();\n-    Verify.verify(manifestsAndConfigs.size() == 1);\n-    ManifestTemplate manifest = Verify.verifyNotNull(manifestsAndConfigs.get(0).getManifest());\n-    if (manifest instanceof V21ManifestTemplate) {\n-      return Optional.of(JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+\n+    if (manifestList == null) {\n+      Verify.verify(manifestsAndConfigs.size() == 1);\n+      ManifestTemplate manifest = manifestsAndConfigs.get(0).getManifest();\n+      if (manifest instanceof V21ManifestTemplate) {\n+        return Collections.singletonList(\n+            JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+      }\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(\n+              (BuildableManifestTemplate) Verify.verifyNotNull(manifest),\n+              Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));\n     }\n \n-    return Optional.of(\n-        JsonToImageTranslator.toImage(\n-            (BuildableManifestTemplate) manifest,\n-            Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));\n+    // Manifest list cached. Identify matching platforms and check if all of them are cached.\n+    ImmutableList.Builder<Image> images = ImmutableList.builder();\n+    for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n+      String manifestDigest =\n+          lookUpPlatformSpecificImageManifest((V22ManifestListTemplate) manifestList, platform);\n+\n+      Optional<ManifestAndConfigTemplate> manifestAndConfigFound =\n+          manifestsAndConfigs\n+              .stream()\n+              .filter(entry -> manifestDigest.equals(entry.getManifestDigest()))\n+              .findFirst();\n+      if (!manifestAndConfigFound.isPresent()) {\n+        return Collections.emptyList();\n+      }\n+\n+      ManifestTemplate manifest = Verify.verifyNotNull(manifestAndConfigFound.get().getManifest());\n+      ContainerConfigurationTemplate containerConfig =\n+          Verify.verifyNotNull(manifestAndConfigFound.get().getConfig());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e170f76f600c57753f3b19e7cca38c93fa89084a"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY2MTI5MQ==", "bodyText": "It's our assumption and how we designed the cache to work. If any ManifestAndConfig entry (which is just a pair of a manifest and a config) is saved (cached), their values should never be null; otherwise, something got terribly wrong.\nNow, we then use Verify.verifyNotNull() to signal the NullAway check (it's a check we set up in our repo to catch potential NPE) that manifest and containerConfig are not supposed to be null. Otherwise, because JsonToImageTranslator.toImage() doesn't accept @Nullable parameters, NullAway will complain that you're passing potentially null parameters.", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r478661291", "createdAt": "2020-08-27T19:57:32Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -351,35 +330,67 @@ private ContainerConfigurationTemplate pullContainerConfigJson(\n   }\n \n   /**\n-   * Retrieves the cached base image.\n+   * Retrieves the cached base images. If a base image reference is not a manifest list, returns a\n+   * single image (if cached). If a manifest list, returns all the images matching the configured\n+   * platforms in the manifest list but only when all of the images are cached.\n    *\n-   * @return the cached image, if found\n+   * @return the cached images, if found\n    * @throws IOException when an I/O exception occurs\n    * @throws CacheCorruptedException if the cache is corrupted\n    * @throws LayerPropertyNotFoundException if adding image layers fails\n    * @throws BadContainerConfigurationFormatException if the container configuration is in a bad\n    *     format\n+   * @throws UnlistedPlatformInManifestListException if a cached manifest list has no manifests\n+   *     matching the configured platform\n    */\n-  private Optional<Image> getCachedBaseImage()\n+  @VisibleForTesting\n+  List<Image> getCachedBaseImages()\n       throws IOException, CacheCorruptedException, BadContainerConfigurationFormatException,\n-          LayerCountMismatchException {\n+          LayerCountMismatchException, UnlistedPlatformInManifestListException {\n     ImageReference baseImage = buildContext.getBaseImageConfiguration().getImage();\n     Optional<ImageMetadataTemplate> metadata =\n         buildContext.getBaseImageLayersCache().retrieveMetadata(baseImage);\n     if (!metadata.isPresent()) {\n-      return Optional.empty();\n+      return Collections.emptyList();\n     }\n \n+    ManifestTemplate manifestList = metadata.get().getManifestList();\n     List<ManifestAndConfigTemplate> manifestsAndConfigs = metadata.get().getManifestsAndConfigs();\n-    Verify.verify(manifestsAndConfigs.size() == 1);\n-    ManifestTemplate manifest = Verify.verifyNotNull(manifestsAndConfigs.get(0).getManifest());\n-    if (manifest instanceof V21ManifestTemplate) {\n-      return Optional.of(JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+\n+    if (manifestList == null) {\n+      Verify.verify(manifestsAndConfigs.size() == 1);\n+      ManifestTemplate manifest = manifestsAndConfigs.get(0).getManifest();\n+      if (manifest instanceof V21ManifestTemplate) {\n+        return Collections.singletonList(\n+            JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+      }\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(\n+              (BuildableManifestTemplate) Verify.verifyNotNull(manifest),\n+              Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));\n     }\n \n-    return Optional.of(\n-        JsonToImageTranslator.toImage(\n-            (BuildableManifestTemplate) manifest,\n-            Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));\n+    // Manifest list cached. Identify matching platforms and check if all of them are cached.\n+    ImmutableList.Builder<Image> images = ImmutableList.builder();\n+    for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n+      String manifestDigest =\n+          lookUpPlatformSpecificImageManifest((V22ManifestListTemplate) manifestList, platform);\n+\n+      Optional<ManifestAndConfigTemplate> manifestAndConfigFound =\n+          manifestsAndConfigs\n+              .stream()\n+              .filter(entry -> manifestDigest.equals(entry.getManifestDigest()))\n+              .findFirst();\n+      if (!manifestAndConfigFound.isPresent()) {\n+        return Collections.emptyList();\n+      }\n+\n+      ManifestTemplate manifest = Verify.verifyNotNull(manifestAndConfigFound.get().getManifest());\n+      ContainerConfigurationTemplate containerConfig =\n+          Verify.verifyNotNull(manifestAndConfigFound.get().getConfig());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MjUzOQ=="}, "originalCommit": {"oid": "e170f76f600c57753f3b19e7cca38c93fa89084a"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMzNzQwMQ==", "bodyText": "Oh I see! Makes sense", "url": "https://github.com/GoogleContainerTools/jib/pull/2730#discussion_r479337401", "createdAt": "2020-08-28T14:20:34Z", "author": {"login": "mpeddada1"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -351,35 +330,67 @@ private ContainerConfigurationTemplate pullContainerConfigJson(\n   }\n \n   /**\n-   * Retrieves the cached base image.\n+   * Retrieves the cached base images. If a base image reference is not a manifest list, returns a\n+   * single image (if cached). If a manifest list, returns all the images matching the configured\n+   * platforms in the manifest list but only when all of the images are cached.\n    *\n-   * @return the cached image, if found\n+   * @return the cached images, if found\n    * @throws IOException when an I/O exception occurs\n    * @throws CacheCorruptedException if the cache is corrupted\n    * @throws LayerPropertyNotFoundException if adding image layers fails\n    * @throws BadContainerConfigurationFormatException if the container configuration is in a bad\n    *     format\n+   * @throws UnlistedPlatformInManifestListException if a cached manifest list has no manifests\n+   *     matching the configured platform\n    */\n-  private Optional<Image> getCachedBaseImage()\n+  @VisibleForTesting\n+  List<Image> getCachedBaseImages()\n       throws IOException, CacheCorruptedException, BadContainerConfigurationFormatException,\n-          LayerCountMismatchException {\n+          LayerCountMismatchException, UnlistedPlatformInManifestListException {\n     ImageReference baseImage = buildContext.getBaseImageConfiguration().getImage();\n     Optional<ImageMetadataTemplate> metadata =\n         buildContext.getBaseImageLayersCache().retrieveMetadata(baseImage);\n     if (!metadata.isPresent()) {\n-      return Optional.empty();\n+      return Collections.emptyList();\n     }\n \n+    ManifestTemplate manifestList = metadata.get().getManifestList();\n     List<ManifestAndConfigTemplate> manifestsAndConfigs = metadata.get().getManifestsAndConfigs();\n-    Verify.verify(manifestsAndConfigs.size() == 1);\n-    ManifestTemplate manifest = Verify.verifyNotNull(manifestsAndConfigs.get(0).getManifest());\n-    if (manifest instanceof V21ManifestTemplate) {\n-      return Optional.of(JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+\n+    if (manifestList == null) {\n+      Verify.verify(manifestsAndConfigs.size() == 1);\n+      ManifestTemplate manifest = manifestsAndConfigs.get(0).getManifest();\n+      if (manifest instanceof V21ManifestTemplate) {\n+        return Collections.singletonList(\n+            JsonToImageTranslator.toImage((V21ManifestTemplate) manifest));\n+      }\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(\n+              (BuildableManifestTemplate) Verify.verifyNotNull(manifest),\n+              Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));\n     }\n \n-    return Optional.of(\n-        JsonToImageTranslator.toImage(\n-            (BuildableManifestTemplate) manifest,\n-            Verify.verifyNotNull(manifestsAndConfigs.get(0).getConfig())));\n+    // Manifest list cached. Identify matching platforms and check if all of them are cached.\n+    ImmutableList.Builder<Image> images = ImmutableList.builder();\n+    for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n+      String manifestDigest =\n+          lookUpPlatformSpecificImageManifest((V22ManifestListTemplate) manifestList, platform);\n+\n+      Optional<ManifestAndConfigTemplate> manifestAndConfigFound =\n+          manifestsAndConfigs\n+              .stream()\n+              .filter(entry -> manifestDigest.equals(entry.getManifestDigest()))\n+              .findFirst();\n+      if (!manifestAndConfigFound.isPresent()) {\n+        return Collections.emptyList();\n+      }\n+\n+      ManifestTemplate manifest = Verify.verifyNotNull(manifestAndConfigFound.get().getManifest());\n+      ContainerConfigurationTemplate containerConfig =\n+          Verify.verifyNotNull(manifestAndConfigFound.get().getConfig());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MjUzOQ=="}, "originalCommit": {"oid": "e170f76f600c57753f3b19e7cca38c93fa89084a"}, "originalPosition": 198}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 160, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}