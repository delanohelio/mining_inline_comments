{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxODY2MjY3", "number": 2818, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOToyODowOVrOEuJCOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowOTowOFrOEvhczw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODE3OTc2OnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/api/Containerizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOToyODowOVrOHiWz3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOToyODowOVrOHiWz3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4NzM1Ng==", "bodyText": "Remove.", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505787356", "createdAt": "2020-10-15T19:28:09Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/api/Containerizer.java", "diffHunk": "@@ -109,6 +109,7 @@ public static Containerizer to(TarImage tarImage) {\n \n     ImageConfiguration imageConfiguration =\n         ImageConfiguration.builder(tarImage.getImageReference().get()).build();\n+    // ImageConfiguration.builder(tarImage.getImageReference().get()).setTarPath(tarImage.getPath()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODE5Mzc4OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTozMTo1NlrOHiW8IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0ODowMVrOHiZwWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4OTQ3Mw==", "bodyText": "It's not possible to have both --username and --to-username given, right? Is it worth checking that here?\nPreconditions.checkArgument(!(buildOptions.getUsernamePassword().isPresent() && buildOptinos.getToUsernamePassword.isPresent()));", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505789473", "createdAt": "2020-10-15T19:31:56Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   */\n+  public static Containerizer from(JibCli buildOptions) throws InvalidImageReferenceException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyLogger(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    applyCredentialConfig(\n+        registryImage,\n+        CredentialRetrieverFactory.forImage(\n+            imageReference, logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())),\n+        buildOptions);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyCredentialConfig(\n+      RegistryImage registryImage, CredentialRetrieverFactory factory, JibCli buildOptions) {\n+    if (buildOptions.getUsernamePassword().isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNTYwOA==", "bodyText": "From the cli, it's impossible. It could be a verify, but this is tested in the JibCli test.", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505835608", "createdAt": "2020-10-15T20:48:01Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   */\n+  public static Containerizer from(JibCli buildOptions) throws InvalidImageReferenceException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyLogger(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    applyCredentialConfig(\n+        registryImage,\n+        CredentialRetrieverFactory.forImage(\n+            imageReference, logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())),\n+        buildOptions);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyCredentialConfig(\n+      RegistryImage registryImage, CredentialRetrieverFactory factory, JibCli buildOptions) {\n+    if (buildOptions.getUsernamePassword().isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc4OTQ3Mw=="}, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODIwMjQyOnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTozNDozOVrOHiXBlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0Njo1MlrOHiZsUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5MDg3MQ==", "bodyText": "I think this needs a little more work for Windows (as in DefaultCredentialRetrievers.asList()). Add a TODO?", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505790871", "createdAt": "2020-10-15T19:34:39Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   */\n+  public static Containerizer from(JibCli buildOptions) throws InvalidImageReferenceException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyLogger(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    applyCredentialConfig(\n+        registryImage,\n+        CredentialRetrieverFactory.forImage(\n+            imageReference, logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())),\n+        buildOptions);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyCredentialConfig(\n+      RegistryImage registryImage, CredentialRetrieverFactory factory, JibCli buildOptions) {\n+    if (buildOptions.getUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getUsernamePassword);\n+    } else if (buildOptions.getToUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getToUsernamePassword);\n+    }\n+    for (String credentialHelper : buildOptions.getCredentialHelpers()) {\n+      Path path = Paths.get(credentialHelper);\n+      if (Files.exists(path)) {\n+        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(path));\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMjczMw==", "bodyText": "oh didn't know about this, basically just pulled this out of brian's code. I can just use that instead.", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505832733", "createdAt": "2020-10-15T20:44:54Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   */\n+  public static Containerizer from(JibCli buildOptions) throws InvalidImageReferenceException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyLogger(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    applyCredentialConfig(\n+        registryImage,\n+        CredentialRetrieverFactory.forImage(\n+            imageReference, logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())),\n+        buildOptions);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyCredentialConfig(\n+      RegistryImage registryImage, CredentialRetrieverFactory factory, JibCli buildOptions) {\n+    if (buildOptions.getUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getUsernamePassword);\n+    } else if (buildOptions.getToUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getToUsernamePassword);\n+    }\n+    for (String credentialHelper : buildOptions.getCredentialHelpers()) {\n+      Path path = Paths.get(credentialHelper);\n+      if (Files.exists(path)) {\n+        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(path));\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5MDg3MQ=="}, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzNDU3Ng==", "bodyText": "Yeah, Brian must have copied the old DefaultCredentialRetrievers code, and then we fixed some Windows issues not long ago.", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505834576", "createdAt": "2020-10-15T20:46:52Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   */\n+  public static Containerizer from(JibCli buildOptions) throws InvalidImageReferenceException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyLogger(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    applyCredentialConfig(\n+        registryImage,\n+        CredentialRetrieverFactory.forImage(\n+            imageReference, logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())),\n+        buildOptions);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyCredentialConfig(\n+      RegistryImage registryImage, CredentialRetrieverFactory factory, JibCli buildOptions) {\n+    if (buildOptions.getUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getUsernamePassword);\n+    } else if (buildOptions.getToUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getToUsernamePassword);\n+    }\n+    for (String credentialHelper : buildOptions.getCredentialHelpers()) {\n+      Path path = Paths.get(credentialHelper);\n+      if (Files.exists(path)) {\n+        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(path));\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5MDg3MQ=="}, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODIyOTM2OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0MjowOFrOHiXR0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0MjowNlrOHiZb7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NTAyNQ==", "bodyText": "We haven't finalized if we'll have a default build output directory somewhere, but we if do, it may make sense to put the application cache into it. But I feel a bit weird for a CLI tool like this to create some output directory.", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505795025", "createdAt": "2020-10-15T19:42:08Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   */\n+  public static Containerizer from(JibCli buildOptions) throws InvalidImageReferenceException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyLogger(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    applyCredentialConfig(\n+        registryImage,\n+        CredentialRetrieverFactory.forImage(\n+            imageReference, logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())),\n+        buildOptions);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyCredentialConfig(\n+      RegistryImage registryImage, CredentialRetrieverFactory factory, JibCli buildOptions) {\n+    if (buildOptions.getUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getUsernamePassword);\n+    } else if (buildOptions.getToUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getToUsernamePassword);\n+    }\n+    for (String credentialHelper : buildOptions.getCredentialHelpers()) {\n+      Path path = Paths.get(credentialHelper);\n+      if (Files.exists(path)) {\n+        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(path));\n+      } else {\n+        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(credentialHelper));\n+      }\n+    }\n+    // then add any other known helpers\n+    registryImage.addCredentialRetriever(factory.dockerConfig());\n+    registryImage.addCredentialRetriever(factory.wellKnownCredentialHelpers());\n+    registryImage.addCredentialRetriever(factory.googleApplicationDefaultCredentials());\n+  }\n+\n+  static void applyConfiguration(Containerizer containerizer, JibCli buildOptions) {\n+    containerizer.setToolName(VersionInfo.TOOL_NAME);\n+    containerizer.setToolVersion(VersionInfo.getVersionSimple());\n+\n+    // TODO: it's strange that we use system properties to set these\n+    // TODO: perhaps we should expose these as configuration options on the containerizer\n+    if (buildOptions.isSendCredentialsOverHttp()) {\n+      System.setProperty(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP, Boolean.TRUE.toString());\n+    }\n+    if (buildOptions.isSerialize()) {\n+      System.setProperty(JibSystemProperties.SERIALIZE, Boolean.TRUE.toString());\n+    }\n+\n+    containerizer.setAllowInsecureRegistries(buildOptions.isAllowInsecureRegistries());\n+    buildOptions.getBaseImageCache().ifPresent(containerizer::setBaseImageLayersCache);\n+    buildOptions.getApplicationCache().ifPresent(containerizer::setApplicationLayersCache);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMDM4Mw==", "bodyText": "the default behavior is to use a temporary directory right now.", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505830383", "createdAt": "2020-10-15T20:42:06Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   */\n+  public static Containerizer from(JibCli buildOptions) throws InvalidImageReferenceException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyLogger(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    applyCredentialConfig(\n+        registryImage,\n+        CredentialRetrieverFactory.forImage(\n+            imageReference, logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())),\n+        buildOptions);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyCredentialConfig(\n+      RegistryImage registryImage, CredentialRetrieverFactory factory, JibCli buildOptions) {\n+    if (buildOptions.getUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getUsernamePassword);\n+    } else if (buildOptions.getToUsernamePassword().isPresent()) {\n+      registryImage.addCredentialRetriever(buildOptions::getToUsernamePassword);\n+    }\n+    for (String credentialHelper : buildOptions.getCredentialHelpers()) {\n+      Path path = Paths.get(credentialHelper);\n+      if (Files.exists(path)) {\n+        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(path));\n+      } else {\n+        registryImage.addCredentialRetriever(factory.dockerCredentialHelper(credentialHelper));\n+      }\n+    }\n+    // then add any other known helpers\n+    registryImage.addCredentialRetriever(factory.dockerConfig());\n+    registryImage.addCredentialRetriever(factory.wellKnownCredentialHelpers());\n+    registryImage.addCredentialRetriever(factory.googleApplicationDefaultCredentials());\n+  }\n+\n+  static void applyConfiguration(Containerizer containerizer, JibCli buildOptions) {\n+    containerizer.setToolName(VersionInfo.TOOL_NAME);\n+    containerizer.setToolVersion(VersionInfo.getVersionSimple());\n+\n+    // TODO: it's strange that we use system properties to set these\n+    // TODO: perhaps we should expose these as configuration options on the containerizer\n+    if (buildOptions.isSendCredentialsOverHttp()) {\n+      System.setProperty(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP, Boolean.TRUE.toString());\n+    }\n+    if (buildOptions.isSerialize()) {\n+      System.setProperty(JibSystemProperties.SERIALIZE, Boolean.TRUE.toString());\n+    }\n+\n+    containerizer.setAllowInsecureRegistries(buildOptions.isAllowInsecureRegistries());\n+    buildOptions.getBaseImageCache().ifPresent(containerizer::setBaseImageLayersCache);\n+    buildOptions.getApplicationCache().ifPresent(containerizer::setApplicationLayersCache);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NTAyNQ=="}, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODIzNjg1OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0Mzo1MlrOHiXWQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0Mzo1MlrOHiXWQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NjE2MQ==", "bodyText": "nit: final", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505796161", "createdAt": "2020-10-15T19:43:52Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.ContainerizerTestProxy;\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import picocli.CommandLine;\n+\n+public class ContainerizersTest {\n+\n+  @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  // Containerizers will add system properties based on cli properties\n+  @Rule public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODI0MjE3OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0NToyMVrOHiXZTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0NToyMVrOHiXZTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5Njk0Mw==", "bodyText": "final", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505796943", "createdAt": "2020-10-15T19:45:21Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.ContainerizerTestProxy;\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import picocli.CommandLine;\n+\n+public class ContainerizersTest {\n+\n+  @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  // Containerizers will add system properties based on cli properties\n+  @Rule public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Test\n+  public void testApplyConfiguration_defaults() throws InvalidImageReferenceException {\n+    JibCli buildOptions = CommandLine.populateCommand(new JibCli(), \"-t\", \"test-image-ref\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isFalse();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isFalse();\n+    assertThat(containerizer.getToolName()).isEqualTo(VersionInfo.TOOL_NAME);\n+    assertThat(containerizer.getToolVersion()).isEqualTo(VersionInfo.getVersionSimple());\n+    assertThat(Boolean.getBoolean(\"sendCredentialsOverHttp\")).isFalse();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isFalse();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory())\n+        .isEqualTo(Containerizer.DEFAULT_BASE_CACHE_DIRECTORY);\n+    // it's a little hard to test applicationLayersCacheDirectory defaults here, so intentionally\n+    // skipped\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of());\n+  }\n+\n+  @Test\n+  public void testApplyConfiguration_withValues()\n+      throws InvalidImageReferenceException, CacheDirectoryCreationException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t=test-image-ref\",\n+            \"--send-credentials-over-http\",\n+            \"--allow-insecure-registries\",\n+            \"--base-image-cache=./bi-cache\",\n+            \"--application-cache=./app-cache\",\n+            \"--additional-tags=tag1,tag2\",\n+            \"--serialize\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isTrue();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isTrue();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isTrue();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory()).isEqualTo(Paths.get(\"./bi-cache\"));\n+    assertThat(containerizer.getApplicationsLayersCacheDirectory())\n+        .isEqualTo(Paths.get(\"./app-cache\"));\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of(\"tag1\", \"tag2\"));\n+  }\n+\n+  @Test\n+  public void testFrom_dockerDaemonImage() throws InvalidImageReferenceException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"docker://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image to Docker daemon\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @Test\n+  public void testFrom_tarImage() throws InvalidImageReferenceException, IOException {\n+    Path tarPath = temporaryFolder.getRoot().toPath().resolve(\"test-tar.tar\");\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t\",\n+            \"tar://\" + tarPath.toAbsolutePath(),\n+            \"--name\",\n+            \"gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image tarball\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty(); // weird, but the way jib currently works\n+  }\n+\n+  @Test\n+  public void testFrom_registryImage() throws InvalidImageReferenceException, IOException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"registry://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    // description from Containerizer.java\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building and pushing image\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isNotEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class CrendentialConfigurationTests {\n+\n+    @Rule public TemporaryFolder testRoot = new TemporaryFolder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODI0MjY2OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0NToyOFrOHiXZmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0NToyOFrOHiXZmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NzAxOA==", "bodyText": "private", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505797018", "createdAt": "2020-10-15T19:45:28Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.ContainerizerTestProxy;\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import picocli.CommandLine;\n+\n+public class ContainerizersTest {\n+\n+  @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  // Containerizers will add system properties based on cli properties\n+  @Rule public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Test\n+  public void testApplyConfiguration_defaults() throws InvalidImageReferenceException {\n+    JibCli buildOptions = CommandLine.populateCommand(new JibCli(), \"-t\", \"test-image-ref\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isFalse();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isFalse();\n+    assertThat(containerizer.getToolName()).isEqualTo(VersionInfo.TOOL_NAME);\n+    assertThat(containerizer.getToolVersion()).isEqualTo(VersionInfo.getVersionSimple());\n+    assertThat(Boolean.getBoolean(\"sendCredentialsOverHttp\")).isFalse();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isFalse();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory())\n+        .isEqualTo(Containerizer.DEFAULT_BASE_CACHE_DIRECTORY);\n+    // it's a little hard to test applicationLayersCacheDirectory defaults here, so intentionally\n+    // skipped\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of());\n+  }\n+\n+  @Test\n+  public void testApplyConfiguration_withValues()\n+      throws InvalidImageReferenceException, CacheDirectoryCreationException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t=test-image-ref\",\n+            \"--send-credentials-over-http\",\n+            \"--allow-insecure-registries\",\n+            \"--base-image-cache=./bi-cache\",\n+            \"--application-cache=./app-cache\",\n+            \"--additional-tags=tag1,tag2\",\n+            \"--serialize\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isTrue();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isTrue();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isTrue();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory()).isEqualTo(Paths.get(\"./bi-cache\"));\n+    assertThat(containerizer.getApplicationsLayersCacheDirectory())\n+        .isEqualTo(Paths.get(\"./app-cache\"));\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of(\"tag1\", \"tag2\"));\n+  }\n+\n+  @Test\n+  public void testFrom_dockerDaemonImage() throws InvalidImageReferenceException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"docker://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image to Docker daemon\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @Test\n+  public void testFrom_tarImage() throws InvalidImageReferenceException, IOException {\n+    Path tarPath = temporaryFolder.getRoot().toPath().resolve(\"test-tar.tar\");\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t\",\n+            \"tar://\" + tarPath.toAbsolutePath(),\n+            \"--name\",\n+            \"gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image tarball\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty(); // weird, but the way jib currently works\n+  }\n+\n+  @Test\n+  public void testFrom_registryImage() throws InvalidImageReferenceException, IOException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"registry://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    // description from Containerizer.java\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building and pushing image\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isNotEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class CrendentialConfigurationTests {\n+\n+    @Rule public TemporaryFolder testRoot = new TemporaryFolder();\n+\n+    @Mock CredentialRetrieverFactory mockCredentialRetrieverFactory;\n+    @Mock CredentialRetriever mockCredentialRetriever;\n+    @Mock RegistryImage mockRegistryImage;\n+\n+    @Mock CredentialRetriever mockCredentialRetrieverFromPath;\n+    @Mock CredentialRetriever mockCredentialRetrieverFromString;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODI0OTI4OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0NzozM1rOHiXdkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0NzozM1rOHiXdkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5ODAzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // verify we added our intended credential helper\n          \n          \n            \n                  // verify we added our intended credential retriever", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505798032", "createdAt": "2020-10-15T19:47:33Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.ContainerizerTestProxy;\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import picocli.CommandLine;\n+\n+public class ContainerizersTest {\n+\n+  @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  // Containerizers will add system properties based on cli properties\n+  @Rule public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Test\n+  public void testApplyConfiguration_defaults() throws InvalidImageReferenceException {\n+    JibCli buildOptions = CommandLine.populateCommand(new JibCli(), \"-t\", \"test-image-ref\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isFalse();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isFalse();\n+    assertThat(containerizer.getToolName()).isEqualTo(VersionInfo.TOOL_NAME);\n+    assertThat(containerizer.getToolVersion()).isEqualTo(VersionInfo.getVersionSimple());\n+    assertThat(Boolean.getBoolean(\"sendCredentialsOverHttp\")).isFalse();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isFalse();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory())\n+        .isEqualTo(Containerizer.DEFAULT_BASE_CACHE_DIRECTORY);\n+    // it's a little hard to test applicationLayersCacheDirectory defaults here, so intentionally\n+    // skipped\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of());\n+  }\n+\n+  @Test\n+  public void testApplyConfiguration_withValues()\n+      throws InvalidImageReferenceException, CacheDirectoryCreationException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t=test-image-ref\",\n+            \"--send-credentials-over-http\",\n+            \"--allow-insecure-registries\",\n+            \"--base-image-cache=./bi-cache\",\n+            \"--application-cache=./app-cache\",\n+            \"--additional-tags=tag1,tag2\",\n+            \"--serialize\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isTrue();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isTrue();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isTrue();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory()).isEqualTo(Paths.get(\"./bi-cache\"));\n+    assertThat(containerizer.getApplicationsLayersCacheDirectory())\n+        .isEqualTo(Paths.get(\"./app-cache\"));\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of(\"tag1\", \"tag2\"));\n+  }\n+\n+  @Test\n+  public void testFrom_dockerDaemonImage() throws InvalidImageReferenceException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"docker://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image to Docker daemon\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @Test\n+  public void testFrom_tarImage() throws InvalidImageReferenceException, IOException {\n+    Path tarPath = temporaryFolder.getRoot().toPath().resolve(\"test-tar.tar\");\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t\",\n+            \"tar://\" + tarPath.toAbsolutePath(),\n+            \"--name\",\n+            \"gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image tarball\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty(); // weird, but the way jib currently works\n+  }\n+\n+  @Test\n+  public void testFrom_registryImage() throws InvalidImageReferenceException, IOException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"registry://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    // description from Containerizer.java\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building and pushing image\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isNotEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class CrendentialConfigurationTests {\n+\n+    @Rule public TemporaryFolder testRoot = new TemporaryFolder();\n+\n+    @Mock CredentialRetrieverFactory mockCredentialRetrieverFactory;\n+    @Mock CredentialRetriever mockCredentialRetriever;\n+    @Mock RegistryImage mockRegistryImage;\n+\n+    @Mock CredentialRetriever mockCredentialRetrieverFromPath;\n+    @Mock CredentialRetriever mockCredentialRetrieverFromString;\n+\n+    @Before\n+    public void setupMocks() {\n+      when(mockCredentialRetrieverFactory.dockerConfig()).thenReturn(mockCredentialRetriever);\n+      when(mockCredentialRetrieverFactory.wellKnownCredentialHelpers())\n+          .thenReturn(mockCredentialRetriever);\n+      when(mockCredentialRetrieverFactory.googleApplicationDefaultCredentials())\n+          .thenReturn(mockCredentialRetriever);\n+\n+      when(mockCredentialRetrieverFactory.dockerCredentialHelper(any(Path.class)))\n+          .thenReturn(mockCredentialRetrieverFromPath);\n+      when(mockCredentialRetrieverFactory.dockerCredentialHelper(any(String.class)))\n+          .thenReturn(mockCredentialRetrieverFromString);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_credhelperString() {\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(), \"--target=ignored.io/igored/ignored\", \"--credential-helper=any-string\");\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper\n+      verify(mockRegistryImage).addCredentialRetriever(mockCredentialRetrieverFromString);\n+      // auto added credentials\n+      verify(mockRegistryImage, times(3)).addCredentialRetriever(mockCredentialRetriever);\n+      verifyNoMoreInteractions(mockRegistryImage);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_credhelperFile() throws IOException {\n+      Path credHelperFile = testRoot.newFile(\"cred-helper.sh\").toPath();\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(),\n+              \"--target=ignored.io/igored/ignored\",\n+              \"--credential-helper\",\n+              credHelperFile.toAbsolutePath().toString());\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper\n+      verify(mockRegistryImage).addCredentialRetriever(mockCredentialRetrieverFromPath);\n+      // auto added credentials\n+      verify(mockRegistryImage, times(3)).addCredentialRetriever(mockCredentialRetriever);\n+      verifyNoMoreInteractions(mockRegistryImage);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_usernamePassword() throws CredentialRetrievalException {\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(),\n+              \"--target=ignored.io/igored/ignored\",\n+              \"--username=test-username\",\n+              \"--password=test-password\");\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODI0OTg3OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0Nzo0NlrOHiXd-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxOTo0Nzo0NlrOHiXd-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5ODEzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // verify we added our intended credential helper\n          \n          \n            \n                  // verify we added our intended credential retriever", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r505798137", "createdAt": "2020-10-15T19:47:46Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/ContainerizersTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.ContainerizerTestProxy;\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import com.google.common.collect.ImmutableSet;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import picocli.CommandLine;\n+\n+public class ContainerizersTest {\n+\n+  @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+  // Containerizers will add system properties based on cli properties\n+  @Rule public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Test\n+  public void testApplyConfiguration_defaults() throws InvalidImageReferenceException {\n+    JibCli buildOptions = CommandLine.populateCommand(new JibCli(), \"-t\", \"test-image-ref\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isFalse();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isFalse();\n+    assertThat(containerizer.getToolName()).isEqualTo(VersionInfo.TOOL_NAME);\n+    assertThat(containerizer.getToolVersion()).isEqualTo(VersionInfo.getVersionSimple());\n+    assertThat(Boolean.getBoolean(\"sendCredentialsOverHttp\")).isFalse();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isFalse();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory())\n+        .isEqualTo(Containerizer.DEFAULT_BASE_CACHE_DIRECTORY);\n+    // it's a little hard to test applicationLayersCacheDirectory defaults here, so intentionally\n+    // skipped\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of());\n+  }\n+\n+  @Test\n+  public void testApplyConfiguration_withValues()\n+      throws InvalidImageReferenceException, CacheDirectoryCreationException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t=test-image-ref\",\n+            \"--send-credentials-over-http\",\n+            \"--allow-insecure-registries\",\n+            \"--base-image-cache=./bi-cache\",\n+            \"--application-cache=./app-cache\",\n+            \"--additional-tags=tag1,tag2\",\n+            \"--serialize\");\n+\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP)).isTrue();\n+    assertThat(Boolean.getBoolean(JibSystemProperties.SERIALIZE)).isTrue();\n+    assertThat(containerizer.getAllowInsecureRegistries()).isTrue();\n+    assertThat(containerizer.getBaseImageLayersCacheDirectory()).isEqualTo(Paths.get(\"./bi-cache\"));\n+    assertThat(containerizer.getApplicationsLayersCacheDirectory())\n+        .isEqualTo(Paths.get(\"./app-cache\"));\n+    assertThat(containerizer.getAdditionalTags()).isEqualTo(ImmutableSet.of(\"tag1\", \"tag2\"));\n+  }\n+\n+  @Test\n+  public void testFrom_dockerDaemonImage() throws InvalidImageReferenceException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"docker://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image to Docker daemon\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @Test\n+  public void testFrom_tarImage() throws InvalidImageReferenceException, IOException {\n+    Path tarPath = temporaryFolder.getRoot().toPath().resolve(\"test-tar.tar\");\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(\n+            new JibCli(),\n+            \"-t\",\n+            \"tar://\" + tarPath.toAbsolutePath(),\n+            \"--name\",\n+            \"gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building image tarball\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty(); // weird, but the way jib currently works\n+  }\n+\n+  @Test\n+  public void testFrom_registryImage() throws InvalidImageReferenceException, IOException {\n+    JibCli buildOptions =\n+        CommandLine.populateCommand(new JibCli(), \"-t\", \"registry://gcr.io/test/test-image-ref\");\n+    ContainerizerTestProxy containerizer =\n+        new ContainerizerTestProxy(Containerizers.from(buildOptions));\n+\n+    // description from Containerizer.java\n+    assertThat(containerizer.getDescription()).isEqualTo(\"Building and pushing image\");\n+    ImageConfiguration config = containerizer.getImageConfiguration();\n+\n+    assertThat(config.getCredentialRetrievers()).isNotEmpty();\n+    assertThat(config.getDockerClient()).isEmpty();\n+    assertThat(config.getImage().toString()).isEqualTo(\"gcr.io/test/test-image-ref\");\n+    assertThat(config.getTarPath()).isEmpty();\n+  }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class CrendentialConfigurationTests {\n+\n+    @Rule public TemporaryFolder testRoot = new TemporaryFolder();\n+\n+    @Mock CredentialRetrieverFactory mockCredentialRetrieverFactory;\n+    @Mock CredentialRetriever mockCredentialRetriever;\n+    @Mock RegistryImage mockRegistryImage;\n+\n+    @Mock CredentialRetriever mockCredentialRetrieverFromPath;\n+    @Mock CredentialRetriever mockCredentialRetrieverFromString;\n+\n+    @Before\n+    public void setupMocks() {\n+      when(mockCredentialRetrieverFactory.dockerConfig()).thenReturn(mockCredentialRetriever);\n+      when(mockCredentialRetrieverFactory.wellKnownCredentialHelpers())\n+          .thenReturn(mockCredentialRetriever);\n+      when(mockCredentialRetrieverFactory.googleApplicationDefaultCredentials())\n+          .thenReturn(mockCredentialRetriever);\n+\n+      when(mockCredentialRetrieverFactory.dockerCredentialHelper(any(Path.class)))\n+          .thenReturn(mockCredentialRetrieverFromPath);\n+      when(mockCredentialRetrieverFactory.dockerCredentialHelper(any(String.class)))\n+          .thenReturn(mockCredentialRetrieverFromString);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_credhelperString() {\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(), \"--target=ignored.io/igored/ignored\", \"--credential-helper=any-string\");\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper\n+      verify(mockRegistryImage).addCredentialRetriever(mockCredentialRetrieverFromString);\n+      // auto added credentials\n+      verify(mockRegistryImage, times(3)).addCredentialRetriever(mockCredentialRetriever);\n+      verifyNoMoreInteractions(mockRegistryImage);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_credhelperFile() throws IOException {\n+      Path credHelperFile = testRoot.newFile(\"cred-helper.sh\").toPath();\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(),\n+              \"--target=ignored.io/igored/ignored\",\n+              \"--credential-helper\",\n+              credHelperFile.toAbsolutePath().toString());\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper\n+      verify(mockRegistryImage).addCredentialRetriever(mockCredentialRetrieverFromPath);\n+      // auto added credentials\n+      verify(mockRegistryImage, times(3)).addCredentialRetriever(mockCredentialRetriever);\n+      verifyNoMoreInteractions(mockRegistryImage);\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_usernamePassword() throws CredentialRetrievalException {\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(),\n+              \"--target=ignored.io/igored/ignored\",\n+              \"--username=test-username\",\n+              \"--password=test-password\");\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper\n+      ArgumentCaptor<CredentialRetriever> captor =\n+          ArgumentCaptor.forClass(CredentialRetriever.class);\n+      verify(mockRegistryImage, times(4)).addCredentialRetriever(captor.capture());\n+      List<CredentialRetriever> configuredRetrievers = captor.getAllValues();\n+\n+      assertThat(configuredRetrievers).hasSize(4);\n+      // remove all auto added credentials\n+      for (int i = 0; i < 3; i++) {\n+        assertThat(configuredRetrievers.remove(mockCredentialRetriever)).isTrue();\n+      }\n+      // check if our credential was added\n+      assertThat(configuredRetrievers.get(0).retrieve())\n+          .hasValue(Credential.from(\"test-username\", \"test-password\"));\n+    }\n+\n+    @Test\n+    public void testApplyCredentialConfig_toUsernamePassword() throws CredentialRetrievalException {\n+      JibCli buildOptions =\n+          CommandLine.populateCommand(\n+              new JibCli(),\n+              \"--target=ignored.io/igored/ignored\",\n+              \"--to-username=test-username\",\n+              \"--to-password=test-password\");\n+      Containerizers.applyCredentialConfig(\n+          mockRegistryImage, mockCredentialRetrieverFactory, buildOptions);\n+\n+      // verify we added our intended credential helper", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c66ce2f6cf51e6e8cf2f0188b090f09f07796941"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY2NDA2OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowODozMVrOHkjbgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowODozMVrOHkjbgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTI2Nw==", "bodyText": "Nit: for consistency, we can use .forEach(containerizer::withAdditionalTag)?", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r508091267", "createdAt": "2020-10-19T22:08:31Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.DefaultCredentialRetrievers;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.io.FileNotFoundException;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   * @throws FileNotFoundException if a credential helper file is not found\n+   */\n+  public static Containerizer from(JibCli buildOptions)\n+      throws InvalidImageReferenceException, FileNotFoundException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyHandlers(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)\n+      throws InvalidImageReferenceException, FileNotFoundException {\n+    String imageSpec = buildOptions.getTargetImage();\n+    if (imageSpec.startsWith(DOCKER_DAEMON_IMAGE_PREFIX)) {\n+      // TODO: allow setting docker env and docker executable (along with path/env)\n+      return Containerizer.to(\n+          DockerDaemonImage.named(imageSpec.replaceFirst(DOCKER_DAEMON_IMAGE_PREFIX, \"\")));\n+    }\n+    if (imageSpec.startsWith(TAR_IMAGE_PREFIX)) {\n+      return Containerizer.to(\n+          TarImage.at(Paths.get(imageSpec.replaceFirst(TAR_IMAGE_PREFIX, \"\")))\n+              .named(buildOptions.getName()));\n+    }\n+    ImageReference imageReference =\n+        ImageReference.parse(imageSpec.replaceFirst(REGISTRY_IMAGE_PREFIX, \"\"));\n+    RegistryImage registryImage = RegistryImage.named(imageReference);\n+    DefaultCredentialRetrievers defaultCredentialRetrievers =\n+        DefaultCredentialRetrievers.init(\n+            CredentialRetrieverFactory.forImage(\n+                imageReference,\n+                logEvent -> logger.log(logEvent.getLevel(), logEvent.getMessage())));\n+    Credentials.getToCredentialRetrievers(buildOptions, defaultCredentialRetrievers)\n+        .forEach(registryImage::addCredentialRetriever);\n+    return Containerizer.to(registryImage);\n+  }\n+\n+  static void applyConfiguration(Containerizer containerizer, JibCli buildOptions) {\n+    containerizer.setToolName(VersionInfo.TOOL_NAME);\n+    containerizer.setToolVersion(VersionInfo.getVersionSimple());\n+\n+    // TODO: it's strange that we use system properties to set these\n+    // TODO: perhaps we should expose these as configuration options on the containerizer\n+    if (buildOptions.isSendCredentialsOverHttp()) {\n+      System.setProperty(JibSystemProperties.SEND_CREDENTIALS_OVER_HTTP, Boolean.TRUE.toString());\n+    }\n+    if (buildOptions.isSerialize()) {\n+      System.setProperty(JibSystemProperties.SERIALIZE, Boolean.TRUE.toString());\n+    }\n+\n+    containerizer.setAllowInsecureRegistries(buildOptions.isAllowInsecureRegistries());\n+    buildOptions.getBaseImageCache().ifPresent(containerizer::setBaseImageLayersCache);\n+    buildOptions.getApplicationCache().ifPresent(containerizer::setApplicationLayersCache);\n+\n+    for (String tag : buildOptions.getAdditionalTags()) {\n+      containerizer.withAdditionalTag(tag);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e236fd4027337c7b212eb77b9f5d42f10387dda"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjY2NTc1OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowOTowOFrOHkjceQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjowOTowOFrOHkjceQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5MTUxMw==", "bodyText": "Can all there methods private?", "url": "https://github.com/GoogleContainerTools/jib/pull/2818#discussion_r508091513", "createdAt": "2020-10-19T22:09:08Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Containerizers.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.cli2;\n+\n+import static com.google.cloud.tools.jib.api.Jib.DOCKER_DAEMON_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.REGISTRY_IMAGE_PREFIX;\n+import static com.google.cloud.tools.jib.api.Jib.TAR_IMAGE_PREFIX;\n+\n+import com.google.cloud.tools.jib.api.Containerizer;\n+import com.google.cloud.tools.jib.api.DockerDaemonImage;\n+import com.google.cloud.tools.jib.api.ImageReference;\n+import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryImage;\n+import com.google.cloud.tools.jib.api.TarImage;\n+import com.google.cloud.tools.jib.cli.cli2.logging.CliLogger;\n+import com.google.cloud.tools.jib.event.events.ProgressEvent;\n+import com.google.cloud.tools.jib.event.progress.ProgressEventHandler;\n+import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.plugins.common.DefaultCredentialRetrievers;\n+import com.google.cloud.tools.jib.plugins.common.logging.ConsoleLogger;\n+import com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator;\n+import java.io.FileNotFoundException;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/** Helper class for creating Containerizers from JibCli specifications. */\n+public class Containerizers {\n+\n+  /**\n+   * Create a Containerizer from a jibcli command line specification.\n+   *\n+   * @param buildOptions JibCli options\n+   * @return a populated Containerizer\n+   * @throws InvalidImageReferenceException if the image reference could not be parsed\n+   * @throws FileNotFoundException if a credential helper file is not found\n+   */\n+  public static Containerizer from(JibCli buildOptions)\n+      throws InvalidImageReferenceException, FileNotFoundException {\n+    ConsoleLogger logger =\n+        CliLogger.newLogger(buildOptions.getVerbosity(), buildOptions.getConsoleOutput());\n+\n+    Containerizer containerizer = create(buildOptions, logger);\n+\n+    applyHandlers(containerizer, logger);\n+    applyConfiguration(containerizer, buildOptions);\n+\n+    return containerizer;\n+  }\n+\n+  static Containerizer create(JibCli buildOptions, ConsoleLogger logger)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e236fd4027337c7b212eb77b9f5d42f10387dda"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4960, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}