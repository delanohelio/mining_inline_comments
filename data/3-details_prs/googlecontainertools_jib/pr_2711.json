{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwOTc5NTc3", "number": 2711, "title": "Implement new manifest cache design: cache manifest lists and manifest+config pairs", "bodyText": "(See #2707 about the new JSON data structure (ImageMetadataTemplate) for the cache file manifests_configs.json.)\nThe new cache supports storing and retrieving both OCI and Docker manifests and manifest lists.\n\nIf a base image ref is not a manifest list, Jib will result in caching a single-element ImageMetadataTemplate.manifestsAndConfigs without caching a manifest list (null ImageMetadataTemplate.manifestList).\nIf a base image ref is a manifest list, Jib will cache the entire original manifest list. However, for actual manifests, it will cache only a subset that are downloaded and used.\n\nCache API Changes\n\n\nCurrent manifest cache API\n\nReturns and writes a single manifest and config pairs (ManifestAndConfigTemplate).\n\n  public Optional<ManifestAndConfigTemplate> retrieveMetadata(ImageReference imageReference)\n  public void writeMetadata(\n      ImageReference imageReference,\n      BuildableManifestTemplate manifestTemplate,\n      ContainerConfigurationTemplate containerConfigurationTemplate)\n\n\nNew API\n\nReturns and writes a manifest list and a list of manifest and config pairs (ImageMetadataTemplate).\n\n  public Optional<ImageMetadataTemplate> retrieveMetadata(ImageReference imageReference)\n  public void writeMetadata(\n      ImageReference imageReference,\n      @Nullable ManifestTemplate manifestList,\n      List<BuildableManifestTemplate> manifests,\n      List<ContainerConfigurationTemplate> containerConfigurations)\n\n\nUpdating Manifest Cache File\nThe implementation replaces manifests_configs.json whenever running Jib online. Jib will store only those manifests and configs Jib downloaded and used in the last build\u2013no accumulation of past manifests and configs.\nCache Invalidation in the New Release\nThe new cache file is manifests_configs.json. Existing manifest.json and config.json will not be used. The user upgrading Jib will lose previous manifest and config caches.", "createdAt": "2020-08-20T15:14:48Z", "url": "https://github.com/GoogleContainerTools/jib/pull/2711", "merged": true, "mergeCommit": {"oid": "e722ab71cff30ad015dbb6f4ee3d1334b7d89b3f"}, "closed": true, "closedAt": "2020-08-25T00:53:50Z", "author": {"login": "chanseokoh"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-k-NTgH2gAyNDcwOTc5NTc3OjRmOWMxYmM1MzZiZWU5M2EwZjBkMzAzOGNhNWI5ODFiNmQzODkyYzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCIhLlAFqTQ3MzgyNzA3Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4f9c1bc536bee93a0f0d3038ca5b981b6d3892c2", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/4f9c1bc536bee93a0f0d3038ca5b981b6d3892c2", "committedDate": "2020-08-13T19:13:55Z", "message": "Implement new manifests_configs.json cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f480cf1829789d97493b0e05326c409ac0486440", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/f480cf1829789d97493b0e05326c409ac0486440", "committedDate": "2020-08-13T19:18:29Z", "message": "Merge branch 'master' into manifest-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abeb080a2f9d0606a7ada30ae15d9a7e8b35d0de", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/abeb080a2f9d0606a7ada30ae15d9a7e8b35d0de", "committedDate": "2020-08-13T19:30:39Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e643c543e1604983c46b480e399ef2652abff6f1", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/e643c543e1604983c46b480e399ef2652abff6f1", "committedDate": "2020-08-16T15:45:54Z", "message": "Implement new manfiest+container config cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1682e3b3bbba37351105ea41755f7e56a4d583f5", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/1682e3b3bbba37351105ea41755f7e56a4d583f5", "committedDate": "2020-08-17T13:07:45Z", "message": "Revert unnecessary code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "999125ef6906c4334612496b77f54e16f1f755bc", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/999125ef6906c4334612496b77f54e16f1f755bc", "committedDate": "2020-08-17T16:20:01Z", "message": "Revert filter(...) to original code to avoid false NullAway positives"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2166d2bf3b631b71dc2653a0aa93314eea3af668", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/2166d2bf3b631b71dc2653a0aa93314eea3af668", "committedDate": "2020-08-18T14:18:55Z", "message": "Convert to polymorphic JSON de-/serialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "595bd1962921f5b59ea5ecf1049b12a6e5610860", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/595bd1962921f5b59ea5ecf1049b12a6e5610860", "committedDate": "2020-08-18T14:29:48Z", "message": "Add manifest+config cache JSON template"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e2c6bcf688b5df766f6535fd950a7655196a404", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/5e2c6bcf688b5df766f6535fd950a7655196a404", "committedDate": "2020-08-18T14:44:31Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a53417dd8f1fc9808d3b0edae23f2b09001582e0", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/a53417dd8f1fc9808d3b0edae23f2b09001582e0", "committedDate": "2020-08-18T17:36:54Z", "message": "Update code comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "126d30d0204d6544c7a58071884f77060cf139f0", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/126d30d0204d6544c7a58071884f77060cf139f0", "committedDate": "2020-08-18T21:55:05Z", "message": "Merge branch 'prepare-manifest-cache' into manifest-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be8d91fadc60cb601c3d39d4b699de9d964ef0dd", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/be8d91fadc60cb601c3d39d4b699de9d964ef0dd", "committedDate": "2020-08-18T22:11:42Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6bada415e26d5dd179e7ce663c8575d909bdc5c", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/c6bada415e26d5dd179e7ce663c8575d909bdc5c", "committedDate": "2020-08-19T14:23:53Z", "message": "Fix wrong cache validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38e00c976b11780285428f5f8393998da6ff52df", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/38e00c976b11780285428f5f8393998da6ff52df", "committedDate": "2020-08-19T14:42:12Z", "message": "Simplify test code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca69545e40e2adb2cde5fa9cb701ae3b1eca7c51", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/ca69545e40e2adb2cde5fa9cb701ae3b1eca7c51", "committedDate": "2020-08-19T15:22:08Z", "message": "Add CacheStorageReader tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "badb776f62e45c82885e05055657b73bcb95c2bc", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/badb776f62e45c82885e05055657b73bcb95c2bc", "committedDate": "2020-08-19T15:40:55Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8ad480f29198f1b5d87a391c84f60192ed4bf26", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/c8ad480f29198f1b5d87a391c84f60192ed4bf26", "committedDate": "2020-08-19T15:42:16Z", "message": "Revert unintended debug code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e20a8367cc8da6e76bad540c994a77dd91e5dfe4", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/e20a8367cc8da6e76bad540c994a77dd91e5dfe4", "committedDate": "2020-08-19T16:21:05Z", "message": "Fix bug in writing metadata cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bfe4ef3c58d55393d688b6d2004b4aa77db1560", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/4bfe4ef3c58d55393d688b6d2004b4aa77db1560", "committedDate": "2020-08-19T16:25:28Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cadf8c6bd0a25cc45bb929385faf13de8a67f36", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/5cadf8c6bd0a25cc45bb929385faf13de8a67f36", "committedDate": "2020-08-19T17:43:23Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcd17f4be005730a6e5b1ba2d737595dee53b867", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/bcd17f4be005730a6e5b1ba2d737595dee53b867", "committedDate": "2020-08-19T18:21:17Z", "message": "Update comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfab7ce329f1dc31e152e30c7296b706828fb487", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/dfab7ce329f1dc31e152e30c7296b706828fb487", "committedDate": "2020-08-19T18:39:03Z", "message": "Update Javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c52ebb8523d7cc071c718e2583085ae911ea1df0", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/c52ebb8523d7cc071c718e2583085ae911ea1df0", "committedDate": "2020-08-19T18:42:49Z", "message": "Rename variables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0a920374f3dac6c50302d1bc8ed477269df2ee2", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/f0a920374f3dac6c50302d1bc8ed477269df2ee2", "committedDate": "2020-08-20T14:49:08Z", "message": "Merge branch 'master' of https://github.com/GoogleContainerTools/jib into manifest-cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNzUzODUx", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#pullrequestreview-471753851", "createdAt": "2020-08-20T15:49:48Z", "commit": {"oid": "f0a920374f3dac6c50302d1bc8ed477269df2ee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo0OTo0OFrOHEIEiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo0OTo0OFrOHEIEiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4ODU4NA==", "bodyText": "Maybe we should check if the platform of the image being returned matches the platform specified by the user . We can use the  Preconditions.checkState(checkImagePlatform(Image image), \"image doesn't match user specified platform\").", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r474088584", "createdAt": "2020-08-20T15:49:48Z", "author": {"login": "louismurerwa"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,133 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n \n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a920374f3dac6c50302d1bc8ed477269df2ee2"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNzYxNjMy", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#pullrequestreview-471761632", "createdAt": "2020-08-20T15:58:39Z", "commit": {"oid": "f0a920374f3dac6c50302d1bc8ed477269df2ee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo1ODozOVrOHEIb8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTo1ODozOVrOHEIb8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NDU3Ng==", "bodyText": "What about the OciManifestListTemplate ?", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r474094576", "createdAt": "2020-08-20T15:58:39Z", "author": {"login": "louismurerwa"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,133 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n \n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));\n+    }\n+\n+    ManifestTemplate manifestList = null;\n+    List<BuildableManifestTemplate> manifests = new ArrayList<>();\n+    List<ContainerConfigurationTemplate> containerConfigs = new ArrayList<>();\n     // If a manifest list, search for the manifests matching the given platforms.\n     if (manifestTemplate instanceof V22ManifestListTemplate) {\n-      ImmutableList.Builder<Image> images = ImmutableList.builder();\n-\n+      manifestList = manifestTemplate;\n       for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n         manifestAndDigest =\n             obtainPlatformSpecificImageManifest(\n-                registryClient, (V22ManifestListTemplate) manifestTemplate, platform);\n-        images.add(jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n+                registryClient, (V22ManifestListTemplate) manifestList, platform);\n+\n+        manifests.add((BuildableManifestTemplate) manifestAndDigest.getManifest());\n+        containerConfigs.add(\n+            pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher));\n       }\n-      return images.build();\n+\n+    } else {\n+      // V22ManifestTemplate or OciManifestTemplate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a920374f3dac6c50302d1bc8ed477269df2ee2"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb0c901c4930a84230800ec17fe5735e6d1c34e8", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/bb0c901c4930a84230800ec17fe5735e6d1c34e8", "committedDate": "2020-08-21T19:39:12Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c5c7a36d4a3df504e466d2e9701fe5c0d238193", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/1c5c7a36d4a3df504e466d2e9701fe5c0d238193", "committedDate": "2020-08-21T19:59:39Z", "message": "Refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0908e25e6c0a384acf5d6d0917b576751b96f372", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/0908e25e6c0a384acf5d6d0917b576751b96f372", "committedDate": "2020-08-21T20:01:52Z", "message": "Merge branch 'manifest-cache' of https://github.com/GoogleContainerTools/jib into manifest-cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMTA4NjM0", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#pullrequestreview-472108634", "createdAt": "2020-08-21T02:48:05Z", "commit": {"oid": "f0a920374f3dac6c50302d1bc8ed477269df2ee2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMjo0ODowNlrOHEZvUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNDo1NDo0MVrOHFFt1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM3ODA2Ng==", "bodyText": "perhaps we should add a bug to track this?", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r474378066", "createdAt": "2020-08-21T02:48:06Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,133 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n \n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));\n+    }\n+\n+    ManifestTemplate manifestList = null;\n+    List<BuildableManifestTemplate> manifests = new ArrayList<>();\n+    List<ContainerConfigurationTemplate> containerConfigs = new ArrayList<>();\n     // If a manifest list, search for the manifests matching the given platforms.\n     if (manifestTemplate instanceof V22ManifestListTemplate) {\n-      ImmutableList.Builder<Image> images = ImmutableList.builder();\n-\n+      manifestList = manifestTemplate;\n       for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n         manifestAndDigest =\n             obtainPlatformSpecificImageManifest(\n-                registryClient, (V22ManifestListTemplate) manifestTemplate, platform);\n-        images.add(jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n+                registryClient, (V22ManifestListTemplate) manifestList, platform);\n+\n+        manifests.add((BuildableManifestTemplate) manifestAndDigest.getManifest());\n+        containerConfigs.add(\n+            pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher));\n       }\n-      return images.build();\n+\n+    } else {\n+      // V22ManifestTemplate or OciManifestTemplate", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5NDU3Ng=="}, "originalCommit": {"oid": "f0a920374f3dac6c50302d1bc8ed477269df2ee2"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxMTI3MA==", "bodyText": "looks like you decided to keep it this way for now?", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475011270", "createdAt": "2020-08-21T23:36:59Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/cache/CacheStorageWriter.java", "diffHunk": "@@ -296,42 +302,59 @@ CachedLayer writeTarLayer(DescriptorDigest diffId, Blob compressedBlob) throws I\n   }\n \n   /**\n-   * Saves the manifest and container configuration for a V2.2 or OCI image.\n+   * Saves image metadata (a manifest list and a list of manifest/container configuration pairs) for\n+   * an image reference.\n    *\n    * @param imageReference the image reference to store the metadata for\n-   * @param manifestTemplate the manifest\n-   * @param containerConfiguration the container configuration\n+   * @param manifestList the V2.2 manifest list or OCI image index. Can be null.\n+   * @param manifests the V2.2 or OCI manifests\n+   * @param containerConfigurations the container configurations\n    */\n   void writeMetadata(\n       ImageReference imageReference,\n-      BuildableManifestTemplate manifestTemplate,\n-      ContainerConfigurationTemplate containerConfiguration)\n+      @Nullable ManifestTemplate manifestList,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e25e6c0a384acf5d6d0917b576751b96f372"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5MDUyNA==", "bodyText": "Just for my own understanding: It seems like we weren't writing cached data at all in this step before? Was that being done somewhere else?", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475090524", "createdAt": "2020-08-22T13:29:47Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,133 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e25e6c0a384acf5d6d0917b576751b96f372"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5ODU4Mw==", "bodyText": "This seems like it should be at the info level.", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475098583", "createdAt": "2020-08-22T14:54:41Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,133 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n \n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));\n+    }\n+\n+    ManifestTemplate manifestList = null;\n+    List<BuildableManifestTemplate> manifests = new ArrayList<>();\n+    List<ContainerConfigurationTemplate> containerConfigs = new ArrayList<>();\n     // If a manifest list, search for the manifests matching the given platforms.\n     if (manifestTemplate instanceof V22ManifestListTemplate) {\n-      ImmutableList.Builder<Image> images = ImmutableList.builder();\n-\n+      manifestList = manifestTemplate;\n       for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n         manifestAndDigest =\n             obtainPlatformSpecificImageManifest(\n-                registryClient, (V22ManifestListTemplate) manifestTemplate, platform);\n-        images.add(jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n+                registryClient, (V22ManifestListTemplate) manifestList, platform);\n+\n+        manifests.add((BuildableManifestTemplate) manifestAndDigest.getManifest());\n+        containerConfigs.add(\n+            pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher));\n       }\n-      return images.build();\n+\n+    } else {\n+      // V22ManifestTemplate or OciManifestTemplate\n+      // TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n+      manifests = Collections.singletonList((BuildableManifestTemplate) manifestTemplate);\n+      containerConfigs =\n+          Collections.singletonList(\n+              pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher));\n     }\n \n-    return Collections.singletonList(\n-        jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n+    cache.writeMetadata(baseImageConfig.getImage(), manifestList, manifests, containerConfigs);\n+\n+    ImmutableList.Builder<Image> images = ImmutableList.builder();\n+    for (int i = 0; i < manifests.size(); i++) {\n+      images.add(JsonToImageTranslator.toImage(manifests.get(i), containerConfigs.get(i)));\n+    }\n+    return images.build();\n   }\n \n   /**\n    * Looks through a manifest list for the manifest matching the {@code platform} and downloads and\n    * returns the first manifest it finds.\n    */\n+  // TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n   @VisibleForTesting\n   ManifestAndDigest<?> obtainPlatformSpecificImageManifest(\n       RegistryClient registryClient,\n       V22ManifestListTemplate manifestListTemplate,\n       Platform platform)\n       throws IOException, RegistryException {\n     EventHandlers eventHandlers = buildContext.getEventHandlers();\n+    String message = \"Searching for architecture=%s, os=%s in the base image manifest list\";\n     eventHandlers.dispatch(\n-        LogEvent.lifecycle(\n-            \"The base image reference is a manifest list, searching for architecture=\"\n-                + platform.getArchitecture()\n-                + \", os=\"\n-                + platform.getOs()));\n+        LogEvent.lifecycle(String.format(message, platform.getArchitecture(), platform.getOs())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e25e6c0a384acf5d6d0917b576751b96f372"}, "originalPosition": 113}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3a0c893335555a0aeb63c704e24bad4ae192476", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/b3a0c893335555a0aeb63c704e24bad4ae192476", "committedDate": "2020-08-24T14:11:03Z", "message": "Decrease log level (lifecycle -> info)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae9f3fa118307a47c04293777e664d8812275e00", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/ae9f3fa118307a47c04293777e664d8812275e00", "committedDate": "2020-08-24T16:04:35Z", "message": "Refactor code"}, "afterCommit": {"oid": "b92f1ff8d84c5ae281b6cee5c186768d778b47d2", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/b92f1ff8d84c5ae281b6cee5c186768d778b47d2", "committedDate": "2020-08-24T16:11:10Z", "message": "New cache API / refactor code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a57ce21b8b6a27899220d268c5caab0bddd01a5", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/8a57ce21b8b6a27899220d268c5caab0bddd01a5", "committedDate": "2020-08-24T16:12:27Z", "message": "New cache API / refactor code"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b92f1ff8d84c5ae281b6cee5c186768d778b47d2", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/b92f1ff8d84c5ae281b6cee5c186768d778b47d2", "committedDate": "2020-08-24T16:11:10Z", "message": "New cache API / refactor code"}, "afterCommit": {"oid": "8a57ce21b8b6a27899220d268c5caab0bddd01a5", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/8a57ce21b8b6a27899220d268c5caab0bddd01a5", "committedDate": "2020-08-24T16:12:27Z", "message": "New cache API / refactor code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNzE5NzA4", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#pullrequestreview-473719708", "createdAt": "2020-08-24T17:40:58Z", "commit": {"oid": "8a57ce21b8b6a27899220d268c5caab0bddd01a5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzo0MDo1OFrOHFvqkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzo0MzowNFrOHFvvAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NTg3NA==", "bodyText": "Does this then throw an error for OciIndexTemplate? Perhaps we can give the user a better error message (I thought Verify is for catching programming/integration issues?)", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475785874", "createdAt": "2020-08-24T17:40:58Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,135 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    EventHandlers eventHandlers = buildContext.getEventHandlers();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n+    eventHandlers.dispatch(\n+        LogEvent.lifecycle(\"Using base image with digest: \" + manifestAndDigest.getDigest()));\n+\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));\n+\n+    } else if (manifestTemplate instanceof BuildableManifestTemplate) {\n+      // V22ManifestTemplate or OciManifestTemplate\n+      BuildableManifestTemplate imageManifest = (BuildableManifestTemplate) manifestTemplate;\n+      ContainerConfigurationTemplate containerConfig =\n+          pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher);\n+      cache.writeMetadata(baseImageConfig.getImage(), imageManifest, containerConfig);\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(imageManifest, containerConfig));\n+    }\n+\n+    // TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n+    Verify.verify(manifestTemplate instanceof V22ManifestListTemplate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a57ce21b8b6a27899220d268c5caab0bddd01a5"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NjYxOQ==", "bodyText": "Similarly here, what happens when schema version is not 2, does this just kill our build with a confusing error message?", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475786619", "createdAt": "2020-08-24T17:42:17Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -215,139 +218,135 @@ private boolean checkImagePlatform(Image image) {\n       RegistryClient registryClient, ProgressEventDispatcher progressEventDispatcher)\n       throws IOException, RegistryException, LayerPropertyNotFoundException,\n           LayerCountMismatchException, BadContainerConfigurationFormatException {\n+    Cache cache = buildContext.getBaseImageLayersCache();\n+    EventHandlers eventHandlers = buildContext.getEventHandlers();\n+    ImageConfiguration baseImageConfig = buildContext.getBaseImageConfiguration();\n+\n     ManifestAndDigest<?> manifestAndDigest =\n-        registryClient.pullManifest(buildContext.getBaseImageConfiguration().getImageQualifier());\n+        registryClient.pullManifest(baseImageConfig.getImageQualifier());\n+    eventHandlers.dispatch(\n+        LogEvent.lifecycle(\"Using base image with digest: \" + manifestAndDigest.getDigest()));\n+\n     ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n+    if (manifestTemplate instanceof V21ManifestTemplate) {\n+      V21ManifestTemplate v21Manifest = (V21ManifestTemplate) manifestTemplate;\n+      cache.writeMetadata(baseImageConfig.getImage(), v21Manifest);\n+      return Collections.singletonList(JsonToImageTranslator.toImage(v21Manifest));\n+\n+    } else if (manifestTemplate instanceof BuildableManifestTemplate) {\n+      // V22ManifestTemplate or OciManifestTemplate\n+      BuildableManifestTemplate imageManifest = (BuildableManifestTemplate) manifestTemplate;\n+      ContainerConfigurationTemplate containerConfig =\n+          pullContainerConfigJson(manifestAndDigest, registryClient, progressEventDispatcher);\n+      cache.writeMetadata(baseImageConfig.getImage(), imageManifest, containerConfig);\n+      return Collections.singletonList(\n+          JsonToImageTranslator.toImage(imageManifest, containerConfig));\n+    }\n+\n+    // TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n+    Verify.verify(manifestTemplate instanceof V22ManifestListTemplate);\n \n+    List<ManifestAndConfigTemplate> manifestsAndConfigs = new ArrayList<>();\n+    ImmutableList.Builder<Image> images = ImmutableList.builder();\n     // If a manifest list, search for the manifests matching the given platforms.\n-    if (manifestTemplate instanceof V22ManifestListTemplate) {\n-      ImmutableList.Builder<Image> images = ImmutableList.builder();\n-\n-      for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n-        manifestAndDigest =\n-            obtainPlatformSpecificImageManifest(\n-                registryClient, (V22ManifestListTemplate) manifestTemplate, platform);\n-        images.add(jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n-      }\n-      return images.build();\n+    for (Platform platform : buildContext.getContainerConfiguration().getPlatforms()) {\n+      String message = \"Searching for architecture=%s, os=%s in the base image manifest list\";\n+      eventHandlers.dispatch(\n+          LogEvent.info(String.format(message, platform.getArchitecture(), platform.getOs())));\n+\n+      ManifestAndDigest<?> imageManifestAndDigest =\n+          obtainPlatformSpecificImageManifest(\n+              registryClient, (V22ManifestListTemplate) manifestTemplate, platform);\n+\n+      BuildableManifestTemplate imageManifest =\n+          (BuildableManifestTemplate) imageManifestAndDigest.getManifest();\n+      ContainerConfigurationTemplate containerConfig =\n+          pullContainerConfigJson(imageManifestAndDigest, registryClient, progressEventDispatcher);\n+\n+      manifestsAndConfigs.add(new ManifestAndConfigTemplate(imageManifest, containerConfig));\n+      images.add(JsonToImageTranslator.toImage(imageManifest, containerConfig));\n     }\n \n-    return Collections.singletonList(\n-        jsonManifestToImage(manifestAndDigest, registryClient, progressEventDispatcher));\n+    cache.writeMetadata(\n+        baseImageConfig.getImage(),\n+        new ImageMetadataTemplate(manifestTemplate /* manifest list */, manifestsAndConfigs));\n+    return images.build();\n   }\n \n   /**\n    * Looks through a manifest list for the manifest matching the {@code platform} and downloads and\n    * returns the first manifest it finds.\n    */\n+  // TODO: support OciIndexTemplate once AbstractManifestPuller starts to accept it.\n   @VisibleForTesting\n   ManifestAndDigest<?> obtainPlatformSpecificImageManifest(\n       RegistryClient registryClient,\n       V22ManifestListTemplate manifestListTemplate,\n       Platform platform)\n       throws IOException, RegistryException {\n     EventHandlers eventHandlers = buildContext.getEventHandlers();\n-    eventHandlers.dispatch(\n-        LogEvent.lifecycle(\n-            \"The base image reference is a manifest list, searching for architecture=\"\n-                + platform.getArchitecture()\n-                + \", os=\"\n-                + platform.getOs()));\n \n     List<String> digests =\n         manifestListTemplate.getDigestsForPlatform(platform.getArchitecture(), platform.getOs());\n     if (digests.size() == 0) {\n       String errorMessage =\n           buildContext.getBaseImageConfiguration().getImage()\n-              + \" is a manifest list, but the list does not contain an image manifest for the platform architecture=\"\n-              + platform.getArchitecture()\n-              + \", os=\"\n-              + platform.getOs()\n-              + \". If your intention was to specify a platform for your image,\"\n-              + \" see https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#how-do-i-specify-a-platform-in-the-manifest-list-or-oci-index-of-a-base-image\"\n-              + \" to learn more about specifying a platform\";\n-\n-      eventHandlers.dispatch(LogEvent.error(errorMessage));\n+              + \" is a manifest list, but the list does not contain an image for architecture=%s, \"\n+              + \"os=%s. If your intention was to specify a platform for your image, see \"\n+              + \"https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#how-do-i-specify-a-platform-in-the-manifest-list-or-oci-index-of-a-base-image\";\n+      eventHandlers.dispatch(\n+          LogEvent.error(\n+              String.format(errorMessage, platform.getArchitecture(), platform.getOs())));\n       throw new RegistryException(errorMessage);\n     }\n+    // TODO: pull multiple manifests (+ container configs) in parallel. (It will be simpler to pull\n+    // a manifest+container config pair in sequence. That is, calling pullContainerConfigJson here.)\n     return registryClient.pullManifest(digests.get(0));\n   }\n \n   /**\n-   * Converts a JSON manifest to an {@link Image}.\n+   * Pulls a container configuration JSON specified in the given manifest.\n    *\n-   * @param manifestAndDigest a manifest list and digest of a {@link Image}\n+   * @param manifestAndDigest a manifest JSON and its digest\n    * @param registryClient to communicate with remote registry\n-   * @param progressEventDispatcher the {@link ProgressEventDispatcher} for emitting {@link\n+   * @param progressDispatcher the {@link ProgressEventDispatcher} for emitting {@link\n    *     ProgressEvent}s\n-   * @return {@link Image}\n+   * @return pulled {@link ContainerConfigurationTemplate}\n    * @throws IOException when an I/O exception occurs during the pulling\n    * @throws LayerCountMismatchException if the manifest and configuration contain conflicting layer\n    *     information\n    * @throws LayerPropertyNotFoundException if adding image layers fails\n    * @throws BadContainerConfigurationFormatException if the container configuration is in a bad\n    *     format\n    */\n-  private Image jsonManifestToImage(\n+  private ContainerConfigurationTemplate pullContainerConfigJson(\n       ManifestAndDigest<?> manifestAndDigest,\n       RegistryClient registryClient,\n-      ProgressEventDispatcher progressEventDispatcher)\n-      throws IOException, LayerPropertyNotFoundException, BadContainerConfigurationFormatException,\n-          UnknownManifestFormatException, LayerCountMismatchException {\n-    EventHandlers eventHandlers = buildContext.getEventHandlers();\n-    ManifestTemplate manifestTemplate = manifestAndDigest.getManifest();\n-    switch (manifestTemplate.getSchemaVersion()) {\n-      case 1:\n-        V21ManifestTemplate v21ManifestTemplate = (V21ManifestTemplate) manifestTemplate;\n-        buildContext\n-            .getBaseImageLayersCache()\n-            .writeMetadata(\n-                buildContext.getBaseImageConfiguration().getImage(), v21ManifestTemplate);\n-        return JsonToImageTranslator.toImage(v21ManifestTemplate);\n-\n-      case 2:\n-        eventHandlers.dispatch(\n-            LogEvent.lifecycle(\"Using base image with digest: \" + manifestAndDigest.getDigest()));\n-        BuildableManifestTemplate buildableManifestTemplate =\n-            (BuildableManifestTemplate) manifestTemplate;\n-        if (buildableManifestTemplate.getContainerConfiguration() == null\n-            || buildableManifestTemplate.getContainerConfiguration().getDigest() == null) {\n-          throw new UnknownManifestFormatException(\n-              \"Invalid container configuration in Docker V2.2/OCI manifest: \\n\"\n-                  + JsonTemplateMapper.toUtf8String(buildableManifestTemplate));\n-        }\n-\n-        DescriptorDigest containerConfigurationDigest =\n-            buildableManifestTemplate.getContainerConfiguration().getDigest();\n-\n-        try (ThrottledProgressEventDispatcherWrapper progressEventDispatcherWrapper =\n-            new ThrottledProgressEventDispatcherWrapper(\n-                progressEventDispatcher.newChildProducer(),\n-                \"pull container configuration \" + containerConfigurationDigest)) {\n-          String containerConfigurationString =\n-              Blobs.writeToString(\n-                  registryClient.pullBlob(\n-                      containerConfigurationDigest,\n-                      progressEventDispatcherWrapper::setProgressTarget,\n-                      progressEventDispatcherWrapper::dispatchProgress));\n-\n-          ContainerConfigurationTemplate containerConfigurationTemplate =\n-              JsonTemplateMapper.readJson(\n-                  containerConfigurationString, ContainerConfigurationTemplate.class);\n-          buildContext\n-              .getBaseImageLayersCache()\n-              .writeMetadata(\n-                  buildContext.getBaseImageConfiguration().getImage(),\n-                  buildableManifestTemplate,\n-                  containerConfigurationTemplate);\n-\n-          return JsonToImageTranslator.toImage(\n-              buildableManifestTemplate, containerConfigurationTemplate);\n-        }\n+      ProgressEventDispatcher progressDispatcher)\n+      throws IOException, LayerPropertyNotFoundException, UnknownManifestFormatException {\n+    BuildableManifestTemplate manifest =\n+        (BuildableManifestTemplate) manifestAndDigest.getManifest();\n+    Preconditions.checkArgument(manifest.getSchemaVersion() == 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a57ce21b8b6a27899220d268c5caab0bddd01a5"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NzAxMA==", "bodyText": "I thought we also write 2.1 manifests down to cache?", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#discussion_r475787010", "createdAt": "2020-08-24T17:43:04Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/cache/Cache.java", "diffHunk": "@@ -66,32 +69,52 @@ private Cache(CacheStorageFiles cacheStorageFiles) {\n   }\n \n   /**\n-   * Saves a manifest and container configuration for a V2.2 or OCI image.\n+   * Saves image metadata (a manifest list and a list of manifest/container configuration pairs) for\n+   * an image reference.\n    *\n-   * @param imageReference the image reference to save the manifest and container configuration for\n-   * @param manifestTemplate the V2.2 or OCI manifest\n-   * @param containerConfigurationTemplate the container configuration\n+   * @param imageReference the image reference to save the metadata for\n+   * @param metadata the image metadata\n+   * @throws IOException if an I/O exception occurs\n+   */\n+  public void writeMetadata(ImageReference imageReference, ImageMetadataTemplate metadata)\n+      throws IOException {\n+    cacheStorageWriter.writeMetadata(imageReference, metadata);\n+  }\n+\n+  /**\n+   * Saves a schema 2 manifest for an image reference. This is a simple wrapper around {@link\n+   * #writeMetadata(ImageReference, ImageMetadataTemplate)} to save a single manifest without a\n+   * manifest list.\n+   *\n+   * @param imageReference the image reference to save the manifest for\n+   * @param manifest the V2.2 or OCI manifest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a57ce21b8b6a27899220d268c5caab0bddd01a5"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODI3MDc2", "url": "https://github.com/GoogleContainerTools/jib/pull/2711#pullrequestreview-473827076", "createdAt": "2020-08-24T20:20:34Z", "commit": {"oid": "8a57ce21b8b6a27899220d268c5caab0bddd01a5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4977, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}