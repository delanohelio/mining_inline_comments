{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5NzM1NDY5", "number": 2214, "title": "Implement update checks", "bodyText": "Fixes #2193.\nA couple changes from the initial design:\n\nInstead of getting/setting the last modified time of a file to check the last update time, the time of the previous update check is stored as contents of the file. It seems Files.setLastModifiedTime() isn't supported on all platforms.\nThe file pulled from GCS contains JSON instead of just the version string, for extensibility.\nThe check is daily instead of weekly.", "createdAt": "2020-01-06T22:11:27Z", "url": "https://github.com/GoogleContainerTools/jib/pull/2214", "merged": true, "mergeCommit": {"oid": "2085d2192adf2f86fcbfcb1e62f0ed113349426f"}, "closed": true, "closedAt": "2020-01-21T17:41:22Z", "author": {"login": "TadCordle"}, "timelineItems": {"totalCount": 66, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb20W4rAH2gAyMzU5NzM1NDY5OjQxMjhjZTkzNWM3YWZiNTQwNzQ1N2ViOTZlNThjOTZjZTk4NTYyMTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb82KI6AFqTM0NjYwMzI5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4128ce935c7afb5407457eb96e58c96ce9856217", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/4128ce935c7afb5407457eb96e58c96ce9856217", "committedDate": "2020-01-03T20:26:54Z", "message": "Progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76fb821a1ce25043cc0276edbdea5bc94a352cb0", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/76fb821a1ce25043cc0276edbdea5bc94a352cb0", "committedDate": "2020-01-03T20:59:53Z", "message": "Add method for retrieving XDG config directory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "907b8fce0c0d5012371352d06d185fb05478e3b8", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/907b8fce0c0d5012371352d06d185fb05478e3b8", "committedDate": "2020-01-03T21:56:07Z", "message": "Merge branch 'xdg-config' of github.com:GoogleContainerTools/jib into i2193-update-checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88a86b896463d85f9200fe4cfd5e5102972ca7ba", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/88a86b896463d85f9200fe4cfd5e5102972ca7ba", "committedDate": "2020-01-03T22:38:15Z", "message": "Progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dbc81f758709cc77a64191b26170f8a31aa8df1", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/0dbc81f758709cc77a64191b26170f8a31aa8df1", "committedDate": "2020-01-06T20:31:56Z", "message": "Add unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b80d27234d7254811042cde15e8b87835325619e", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/b80d27234d7254811042cde15e8b87835325619e", "committedDate": "2020-01-06T21:34:50Z", "message": "Travis?"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f93837068fcf97f28ea2cdea348624d313ef7f4", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/6f93837068fcf97f28ea2cdea348624d313ef7f4", "committedDate": "2020-01-06T22:46:01Z", "message": "Update comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "575b74a7bd8f88a1233eb6591fd0cc0ca31bbae4", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/575b74a7bd8f88a1233eb6591fd0cc0ca31bbae4", "committedDate": "2020-01-07T18:17:23Z", "message": "Return full path"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fefc308ad9d9c4a7608cc5044c731e6eb49cac6e", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/fefc308ad9d9c4a7608cc5044c731e6eb49cac6e", "committedDate": "2020-01-07T18:19:51Z", "message": "Fix comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c75b78fe4f0ad25eb7507ecf31d2f9bfc1ad6dd", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/8c75b78fe4f0ad25eb7507ecf31d2f9bfc1ad6dd", "committedDate": "2020-01-07T18:22:48Z", "message": "Reduce diff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0aed062c9771bd527f8f55476fbee03f68d4218b", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/0aed062c9771bd527f8f55476fbee03f68d4218b", "committedDate": "2020-01-07T18:23:54Z", "message": "Nevermind"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef8ad1e852f9a92e4a69dca25d189895f7ab3a83", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/ef8ad1e852f9a92e4a69dca25d189895f7ab3a83", "committedDate": "2020-01-07T19:57:08Z", "message": "Change base image cache directory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7257f98911d5d41ff1b059c2e50f9d431e7b30fc", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/7257f98911d5d41ff1b059c2e50f9d431e7b30fc", "committedDate": "2020-01-07T21:35:50Z", "message": "Share code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "594bf738f518969d49c5e288efe9a60f974bde12", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/594bf738f518969d49c5e288efe9a60f974bde12", "committedDate": "2020-01-07T21:43:57Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fd8727a326712cf5923fde7190c6dba7d97fe56", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/4fd8727a326712cf5923fde7190c6dba7d97fe56", "committedDate": "2020-01-09T16:48:02Z", "message": "Feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f51248e9f682bb55750b6a5fca1364b7577090ab", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/f51248e9f682bb55750b6a5fca1364b7577090ab", "committedDate": "2020-01-09T17:58:46Z", "message": "Merge branch 'i2216-change-cache-location' of github.com:GoogleContainerTools/jib into i2193-update-checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfe86e9d2fdfadde2c786cc54dd2f88e566eb346", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/dfe86e9d2fdfadde2c786cc54dd2f88e566eb346", "committedDate": "2020-01-09T17:59:37Z", "message": "Fix directory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7709af8eeb9523ff179bc72a0247599e5a4a495", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/c7709af8eeb9523ff179bc72a0247599e5a4a495", "committedDate": "2020-01-09T20:19:52Z", "message": "Add system property for config directory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/3057a5686af6e9063ff02e80edefe9143e198dc1", "committedDate": "2020-01-09T20:22:53Z", "message": "Merge branch 'master' of github.com:GoogleContainerTools/jib into i2193-update-checks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwNzg1NzI3", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-340785727", "createdAt": "2020-01-09T20:11:39Z", "commit": {"oid": "dfe86e9d2fdfadde2c786cc54dd2f88e566eb346"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQyMDoxMTo0MFrOFcCFWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQyMDo1NDowNlrOFcDFJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkzODU4Nw==", "bodyText": "I believe this returns the project version, like <version>0.0.1-SNAPSHOT</version> in pom.xml. We have ProjectInfo.VERSION (which works only when the code is packaged as a JAR).", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364938587", "createdAt": "2020-01-09T20:11:40Z", "author": {"login": "chanseokoh"}, "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildTarMojo.java", "diffHunk": "@@ -65,6 +68,12 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n     MavenProjectProperties projectProperties =\n         MavenProjectProperties.getForProject(\n             getProject(), getSession(), getLog(), tempDirectoryProvider);\n+    UpdateChecker updateChecker =\n+        UpdateChecker.checkForUpdate(\n+            projectProperties.isOffline() || !getLog().isInfoEnabled(),\n+            projectProperties.getVersion(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe86e9d2fdfadde2c786cc54dd2f88e566eb346"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk0NTA5Nw==", "bodyText": "Abort if", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364945097", "createdAt": "2020-01-09T20:28:16Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {\n+    return new UpdateChecker(\n+        executorService.submit(\n+            () -> performUpdateCheck(skip, version, versionUrl, getConfigDir())));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort of update checks are disabled", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk0NzUzNA==", "bodyText": "This is not really necessary given the circumstances, but since it's not a big deal to do it, let's have HttpURLConnection connection = (HttpURLConnection) ... and call connection.disconnect() at the end.\nAnd there should be some way to set some timeout values with HttpURLConnection. It's worth setting them a small value.\nAnd can you verify Maven and Gradle both terminate right away even if this thread is alive, e.g., by putting Thread.sleep(10000) here? (UPDATE: see #2214 (comment).)", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364947534", "createdAt": "2020-01-09T20:34:46Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {\n+    return new UpdateChecker(\n+        executorService.submit(\n+            () -> performUpdateCheck(skip, version, versionUrl, getConfigDir())));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort of update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        JsonTemplateMapper.writeTo(config, Files.newOutputStream(configFile));\n+      }\n+\n+      // Check time of last update check\n+      Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      URLConnection connection = new URL(versionUrl).openConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk0ODg5Mg==", "bodyText": "How about attempting to delete both the config file and lastUpdateCheck? That can fix the situation if any of the files is corrupt.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364948892", "createdAt": "2020-01-09T20:38:15Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {\n+    return new UpdateChecker(\n+        executorService.submit(\n+            () -> performUpdateCheck(skip, version, versionUrl, getConfigDir())));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort of update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        JsonTemplateMapper.writeTo(config, Files.newOutputStream(configFile));\n+      }\n+\n+      // Check time of last update check\n+      Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      URLConnection connection = new URL(versionUrl).openConnection();\n+      BufferedReader bufferedReader =\n+          new BufferedReader(\n+              new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+      String latestVersion = bufferedReader.readLine().trim();\n+      Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+      if (currentVersion.equals(latestVersion)) {\n+        return Optional.empty();\n+      }\n+      return Optional.of(\n+          \"A new version of Jib (\"\n+              + latestVersion\n+              + \") is available (currently using \"\n+              + currentVersion\n+              + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+    } catch (IOException ignored) {\n+      // Fail silently", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MDQ2OQ==", "bodyText": "I think reading and writing files is fast enough, so they don't have to be in a thread? I think it's OK to run only the network connection code in a thread.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364950469", "createdAt": "2020-01-09T20:42:12Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {\n+    return new UpdateChecker(\n+        executorService.submit(\n+            () -> performUpdateCheck(skip, version, versionUrl, getConfigDir())));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MTAyMw==", "bodyText": "Just temporaryFolder.getRoot()?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364951023", "createdAt": "2020-01-09T20:43:33Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Tests for {@link UpdateChecker} */\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.newFolder().toPath();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MjEwNw==", "bodyText": "I think it's nice to write an actual JSON, like Files.write(..., \"{\\\"disableUpdateCheck\\\":true}\".getBytes(...)).", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364952107", "createdAt": "2020-01-09T20:46:38Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Tests for {@link UpdateChecker} */\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.newFolder().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Files.setLastModifiedTime(configDir.resolve(\"lastUpdateCheck\"), modifiedTime);\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_skip() {\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    UpdateChecker.ConfigJsonTemplate config = new UpdateChecker.ConfigJsonTemplate();\n+    config.setDisableUpdateCheck(true);\n+    JsonTemplateMapper.writeTo(config, Files.newOutputStream(configDir.resolve(\"config.json\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MzMzOA==", "bodyText": "Does MoreExecutors.newDirectExecutorService() work? You may be able to remove Thread.sleep(). Otherwise, I think this test can be flaky.\nOr better yet, I think Futures.immediateFuture(Optional.of(\"Hello\")).", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364953338", "createdAt": "2020-01-09T20:49:58Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Tests for {@link UpdateChecker} */\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.newFolder().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Files.setLastModifiedTime(configDir.resolve(\"lastUpdateCheck\"), modifiedTime);\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_skip() {\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    UpdateChecker.ConfigJsonTemplate config = new UpdateChecker.ConfigJsonTemplate();\n+    config.setDisableUpdateCheck(true);\n+    JsonTemplateMapper.writeTo(config, Files.newOutputStream(configDir.resolve(\"config.json\")));\n+\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_failSilently()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    try (TestWebServer badServer = new TestWebServer(false, Collections.singletonList(\"bad\"), 1)) {\n+      Optional<String> message =\n+          UpdateChecker.performUpdateCheck(true, \"1.0.2\", badServer.getEndpoint(), configDir);\n+      Assert.assertFalse(message.isPresent());\n+    }\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_success() throws InterruptedException {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    UpdateChecker updateChecker =\n+        new UpdateChecker(executorService.submit(() -> Optional.of(\"Hello\")));\n+    Thread.sleep(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1NDUyNQ==", "bodyText": "Future is a simple interface, so I think it's better to implement one whose isDone() always returns false.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364954525", "createdAt": "2020-01-09T20:53:01Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Tests for {@link UpdateChecker} */\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.newFolder().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Files.setLastModifiedTime(configDir.resolve(\"lastUpdateCheck\"), modifiedTime);\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_skip() {\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    UpdateChecker.ConfigJsonTemplate config = new UpdateChecker.ConfigJsonTemplate();\n+    config.setDisableUpdateCheck(true);\n+    JsonTemplateMapper.writeTo(config, Files.newOutputStream(configDir.resolve(\"config.json\")));\n+\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_failSilently()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    try (TestWebServer badServer = new TestWebServer(false, Collections.singletonList(\"bad\"), 1)) {\n+      Optional<String> message =\n+          UpdateChecker.performUpdateCheck(true, \"1.0.2\", badServer.getEndpoint(), configDir);\n+      Assert.assertFalse(message.isPresent());\n+    }\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_success() throws InterruptedException {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    UpdateChecker updateChecker =\n+        new UpdateChecker(executorService.submit(() -> Optional.of(\"Hello\")));\n+    Thread.sleep(100);\n+    Optional<String> result = updateChecker.finishUpdateCheck();\n+    Assert.assertTrue(result.isPresent());\n+    Assert.assertEquals(\"Hello\", result.get());\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_notDone() {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    UpdateChecker updateChecker =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1NDkxOA==", "bodyText": "Q: this just writes {}?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364954918", "createdAt": "2020-01-09T20:54:06Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Tests for {@link UpdateChecker} */\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.newFolder().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Files.setLastModifiedTime(configDir.resolve(\"lastUpdateCheck\"), modifiedTime);\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_skip() {\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    UpdateChecker.ConfigJsonTemplate config = new UpdateChecker.ConfigJsonTemplate();\n+    config.setDisableUpdateCheck(true);\n+    JsonTemplateMapper.writeTo(config, Files.newOutputStream(configDir.resolve(\"config.json\")));\n+\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_failSilently()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    try (TestWebServer badServer = new TestWebServer(false, Collections.singletonList(\"bad\"), 1)) {\n+      Optional<String> message =\n+          UpdateChecker.performUpdateCheck(true, \"1.0.2\", badServer.getEndpoint(), configDir);\n+      Assert.assertFalse(message.isPresent());\n+    }\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_success() throws InterruptedException {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    UpdateChecker updateChecker =\n+        new UpdateChecker(executorService.submit(() -> Optional.of(\"Hello\")));\n+    Thread.sleep(100);\n+    Optional<String> result = updateChecker.finishUpdateCheck();\n+    Assert.assertTrue(result.isPresent());\n+    Assert.assertEquals(\"Hello\", result.get());\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_notDone() {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    UpdateChecker updateChecker =\n+        new UpdateChecker(\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    Thread.sleep(100);\n+                  } catch (InterruptedException ignored) {\n+                  }\n+                  return Optional.of(\"Hello\");\n+                }));\n+    Optional<String> result = updateChecker.finishUpdateCheck();\n+    Assert.assertFalse(result.isPresent());\n+  }\n+\n+  private void setupConfigAndLastUpdateCheck() throws IOException {\n+    UpdateChecker.ConfigJsonTemplate config = new UpdateChecker.ConfigJsonTemplate();\n+    JsonTemplateMapper.writeTo(config, Files.newOutputStream(configDir.resolve(\"config.json\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 196}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwODIxMDMz", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-340821033", "createdAt": "2020-01-09T21:19:34Z", "commit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQyMToxOTozNFrOFcDrPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQyMToyMToxN1rOFcDt0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2NDY3MQ==", "bodyText": "It feels weird to put \"skip\" in here?\nCould the maven/gradle calls to checkForUpdate be implemented in a way like\nUpdater.for(ProjectProperties).checkForUpdates()\n\nwhere \"for\" decides whether to skip or not? Or something of that sort.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364964671", "createdAt": "2020-01-09T21:19:34Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2NTMyOA==", "bodyText": "do you have do some work here to shutdown the executor?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364965328", "createdAt": "2020-01-09T21:21:17Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {\n+    return new UpdateChecker(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "committedDate": "2020-01-13T20:37:26Z", "message": "Fixes and feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMTUyNDIy", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-342152422", "createdAt": "2020-01-13T21:30:56Z", "commit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMTozMDo1NlrOFdFPOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMTo1NDoxNlrOFdF2vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzODg0Mg==", "bodyText": "I think s is too short. s --> updateMessage", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366038842", "createdAt": "2020-01-13T21:30:56Z", "author": {"login": "chanseokoh"}, "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/BuildDockerTask.java", "diffHunk": "@@ -145,6 +151,10 @@ public void buildDocker()\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzODg5NA==", "bodyText": "ditto", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366038894", "createdAt": "2020-01-13T21:31:03Z", "author": {"login": "chanseokoh"}, "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/BuildImageTask.java", "diffHunk": "@@ -143,6 +149,10 @@ public void buildImage()\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzOTQ2OA==", "bodyText": "ditto", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366039468", "createdAt": "2020-01-13T21:32:20Z", "author": {"login": "chanseokoh"}, "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/BuildTarTask.java", "diffHunk": "@@ -159,6 +165,10 @@ public void buildTar()\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzOTUwMQ==", "bodyText": "ditto", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366039501", "createdAt": "2020-01-13T21:32:25Z", "author": {"login": "chanseokoh"}, "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildDockerMojo.java", "diffHunk": "@@ -134,6 +139,10 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzOTUzMQ==", "bodyText": "ditto", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366039531", "createdAt": "2020-01-13T21:32:29Z", "author": {"login": "chanseokoh"}, "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildImageMojo.java", "diffHunk": "@@ -148,6 +153,10 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzOTU1Nw==", "bodyText": "ditto", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366039557", "createdAt": "2020-01-13T21:32:33Z", "author": {"login": "chanseokoh"}, "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildTarMojo.java", "diffHunk": "@@ -126,6 +131,10 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0MzI1Mg==", "bodyText": "I can't explain which one is more suitable, but I use Verify.verifyNotNull() in this situation.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366043252", "createdAt": "2020-01-13T21:41:06Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(boolean skip, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    skip,\n+                    Preconditions.checkNotNull(ProjectInfo.VERSION),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0NDA4NA==", "bodyText": "I think it's meaningful to close newOutputStream() in this case.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366044084", "createdAt": "2020-01-13T21:43:03Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(boolean skip, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    skip,\n+                    Preconditions.checkNotNull(ProjectInfo.VERSION),\n+                    versionUrl,\n+                    getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        JsonTemplateMapper.writeTo(config, Files.newOutputStream(configFile));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0NTYwMA==", "bodyText": "I think it's worth putting it in a finally { } block to disconnect early even in an error case.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366045600", "createdAt": "2020-01-13T21:46:30Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(boolean skip, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    skip,\n+                    Preconditions.checkNotNull(ProjectInfo.VERSION),\n+                    versionUrl,\n+                    getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        JsonTemplateMapper.writeTo(config, Files.newOutputStream(configFile));\n+      }\n+\n+      // Check time of last update check\n+      Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      connection.setConnectTimeout(3000);\n+      BufferedReader bufferedReader =\n+          new BufferedReader(\n+              new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+      String latestVersion = bufferedReader.readLine().trim();\n+      connection.disconnect();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0NjUwNQ==", "bodyText": "nit: Files.deleteIfExists(configFile) and Files.deleteIfExists(lastUpdateCheck) after putting these various outside the try block. As this method is very long, I think it helps avoid the mistake of using different path.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366046505", "createdAt": "2020-01-13T21:48:38Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(boolean skip, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    skip,\n+                    Preconditions.checkNotNull(ProjectInfo.VERSION),\n+                    versionUrl,\n+                    getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        JsonTemplateMapper.writeTo(config, Files.newOutputStream(configFile));\n+      }\n+\n+      // Check time of last update check\n+      Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      connection.setConnectTimeout(3000);\n+      BufferedReader bufferedReader =\n+          new BufferedReader(\n+              new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+      String latestVersion = bufferedReader.readLine().trim();\n+      connection.disconnect();\n+\n+      Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+      if (currentVersion.equals(latestVersion)) {\n+        return Optional.empty();\n+      }\n+      return Optional.of(\n+          \"A new version of Jib (\"\n+              + latestVersion\n+              + \") is available (currently using \"\n+              + currentVersion\n+              + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+    } catch (IOException ex) {\n+      try {\n+        Files.deleteIfExists(configDir.resolve(\"config.json\"));\n+        Files.deleteIfExists(configDir.resolve(\"lastUpdateCheck\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0ODk1OQ==", "bodyText": "Is this necessary? If not, remove it, because it's confusing?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366048959", "createdAt": "2020-01-13T21:54:16Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+/** Tests for {@link UpdateChecker} */\n+@RunWith(MockitoJUnitRunner.class)\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.getRoot().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Files.setLastModifiedTime(configDir.resolve(\"lastUpdateCheck\"), modifiedTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55b0f1d76324201c34944f9ab5417a40a7c8ee45", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/55b0f1d76324201c34944f9ab5417a40a7c8ee45", "committedDate": "2020-01-13T22:05:19Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMjA1MTcy", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-342205172", "createdAt": "2020-01-13T23:19:46Z", "commit": {"oid": "55b0f1d76324201c34944f9ab5417a40a7c8ee45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMzoxOTo0NlrOFdHzFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMzoxOTo0NlrOFdHzFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA4MDc5MQ==", "bodyText": "I still kinda think this would be cleaner if we skip wasn't part of the update checker mechanic and we only created an update checker as needed.\nOptional<UpdateChecker> updaterChecker = MavenUpdateChecker.for(projectProperties, getLog())\n\n...\n...\nupdateChecker.ifPresent().finish....", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366080791", "createdAt": "2020-01-13T23:19:46Z", "author": {"login": "loosebazooka"}, "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildDockerMojo.java", "diffHunk": "@@ -73,6 +75,9 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n     MavenProjectProperties projectProperties =\n         MavenProjectProperties.getForProject(\n             getProject(), getSession(), getLog(), tempDirectoryProvider);\n+    UpdateChecker updateChecker =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b0f1d76324201c34944f9ab5417a40a7c8ee45"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb25ca9768f6960807de68c783ce90298b7d8cea", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/bb25ca9768f6960807de68c783ce90298b7d8cea", "committedDate": "2020-01-14T16:21:33Z", "message": "Extract 'skip'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "789defa56482019432632f6bc98aa4baaffbbf0b", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/789defa56482019432632f6bc98aa4baaffbbf0b", "committedDate": "2020-01-14T20:00:02Z", "message": "Fix reversed logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODg4MDEw", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-342888010", "createdAt": "2020-01-14T22:41:45Z", "commit": {"oid": "789defa56482019432632f6bc98aa4baaffbbf0b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjo0MTo0NlrOFdoMJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjo0OToyNVrOFdoWtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMTQ5Mg==", "bodyText": "oh this is cool, didn't know you could do that with optionals.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366611492", "createdAt": "2020-01-14T22:41:46Z", "author": {"login": "loosebazooka"}, "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/BuildDockerTask.java", "diffHunk": "@@ -145,6 +150,12 @@ public void buildDocker()\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .flatMap(UpdateChecker::finishUpdateCheck)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789defa56482019432632f6bc98aa4baaffbbf0b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng==", "bodyText": "I'm not sure I understand what's going on here? why do we delete these files?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366613466", "createdAt": "2020-01-14T22:47:19Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        String latestVersion = bufferedReader.readLine().trim();\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(latestVersion)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + latestVersion\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+      } finally {\n+        connection.disconnect();\n+      }\n+\n+    } catch (IOException ex) {\n+      try {\n+        Files.deleteIfExists(configFile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789defa56482019432632f6bc98aa4baaffbbf0b"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNDE5OQ==", "bodyText": "I think that this just tries to interrupt the process running the thread if it's still running? Do we need to check in performUpdateCheck that the thread hasn't been interrupted?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366614199", "createdAt": "2020-01-14T22:49:25Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        String latestVersion = bufferedReader.readLine().trim();\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(latestVersion)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + latestVersion\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+      } finally {\n+        connection.disconnect();\n+      }\n+\n+    } catch (IOException ex) {\n+      try {\n+        Files.deleteIfExists(configFile);\n+        Files.deleteIfExists(lastUpdateCheck);\n+      } catch (IOException ignored) {\n+        // Fail silently\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  /**\n+   * Returns the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   * otherwise returns the default config directory.\n+   *\n+   * @return the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   *     otherwise returns the default config directory.\n+   */\n+  private static Path getConfigDir() {\n+    String configDirProperty = System.getProperty(PropertyNames.CONFIG_DIRECTORY);\n+    if (!Strings.isNullOrEmpty(configDirProperty)) {\n+      return Paths.get(configDirProperty);\n+    }\n+    return XdgDirectories.getConfigHome();\n+  }\n+\n+  private final Future<Optional<String>> updateMessageFuture;\n+\n+  @VisibleForTesting\n+  UpdateChecker(Future<Optional<String>> updateMessageFuture) {\n+    this.updateMessageFuture = updateMessageFuture;\n+  }\n+\n+  /**\n+   * Returns a message indicating Jib should be upgraded if the check succeeded and the current\n+   * version is outdated, or returns {@code Optional.empty()} if the check was interrupted or did\n+   * not determine that a later version was available.\n+   *\n+   * @return the {@link Optional} message to upgrade Jib if a later version was found, else {@code\n+   *     Optional.empty()}.\n+   */\n+  public Optional<String> finishUpdateCheck() {\n+    if (updateMessageFuture.isDone()) {\n+      try {\n+        return updateMessageFuture.get();\n+      } catch (InterruptedException | ExecutionException ignored) {\n+        // Fail silently;\n+      }\n+    }\n+    updateMessageFuture.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789defa56482019432632f6bc98aa4baaffbbf0b"}, "originalPosition": 190}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a7ab0f9d2bc873ddfadb11ee1cfcde66523a57b", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/3a7ab0f9d2bc873ddfadb11ee1cfcde66523a57b", "committedDate": "2020-01-15T16:18:37Z", "message": "Improve maven formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9aa3c32929106d6c7cb9112b052573f572daa9da", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/9aa3c32929106d6c7cb9112b052573f572daa9da", "committedDate": "2020-01-15T16:24:56Z", "message": "Share gradle code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDYwNjc2", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-343460676", "createdAt": "2020-01-15T19:21:22Z", "commit": {"oid": "9aa3c32929106d6c7cb9112b052573f572daa9da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToyMToyMlrOFeDmFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToyMToyMlrOFeDmFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MDUwMw==", "bodyText": "I feel like a bad configfile should be caught here -- and the user should be informed that it is indeed corrupt. We then should not do an update because there's no way to know if they had previously configured it or not.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367060503", "createdAt": "2020-01-15T19:21:22Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa3c32929106d6c7cb9112b052573f572daa9da"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDYxOTc2", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-343461976", "createdAt": "2020-01-15T19:23:28Z", "commit": {"oid": "9aa3c32929106d6c7cb9112b052573f572daa9da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToyMzoyOVrOFeDp4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToyMzoyOVrOFeDp4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MTQ3Mg==", "bodyText": "perhaps another catch here to cleanup this config file (if we're writing it)", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367061472", "createdAt": "2020-01-15T19:23:29Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa3c32929106d6c7cb9112b052573f572daa9da"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDY1MjYx", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-343465261", "createdAt": "2020-01-15T19:28:49Z", "commit": {"oid": "9aa3c32929106d6c7cb9112b052573f572daa9da"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOToyODo0OVrOFeDz9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxOTozMDoxNFrOFeD2gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2NDA1NA==", "bodyText": "Following @loosebazooka's suggestion, getting here most likely means the file is corrupted.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367064054", "createdAt": "2020-01-15T19:28:49Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9aa3c32929106d6c7cb9112b052573f572daa9da"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2NDcwNQ==", "bodyText": "Yeah, I wanted a simple solution, but in principle I agree it's better to let the user delete the files.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367064705", "createdAt": "2020-01-15T19:30:14Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        String latestVersion = bufferedReader.readLine().trim();\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(latestVersion)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + latestVersion\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+      } finally {\n+        connection.disconnect();\n+      }\n+\n+    } catch (IOException ex) {\n+      try {\n+        Files.deleteIfExists(configFile);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng=="}, "originalCommit": {"oid": "789defa56482019432632f6bc98aa4baaffbbf0b"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "746d7f40aec8f286b7b9cffa8e132459f560e777", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/746d7f40aec8f286b7b9cffa8e132459f560e777", "committedDate": "2020-01-15T20:06:27Z", "message": "More explicit error handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23d9f473aefb4cb717bc619b59adfd7e51e66af8", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/23d9f473aefb4cb717bc619b59adfd7e51e66af8", "committedDate": "2020-01-15T20:09:36Z", "message": "Javadoc and better warning message"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDkwMjIy", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-343490222", "createdAt": "2020-01-15T20:10:53Z", "commit": {"oid": "746d7f40aec8f286b7b9cffa8e132459f560e777"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDoxMDo1M1rOFeE-rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDoxMDo1M1rOFeE-rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4MzE4Mw==", "bodyText": "perhaps we should log debug?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367083183", "createdAt": "2020-01-15T20:10:53Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -137,13 +153,8 @@ public static UpdateChecker checkForUpdate(String versionUrl) {\n         connection.disconnect();\n       }\n \n-    } catch (IOException ex) {\n-      try {\n-        Files.deleteIfExists(configFile);\n-        Files.deleteIfExists(lastUpdateCheck);\n-      } catch (IOException ignored) {\n-        // Fail silently\n-      }\n+    } catch (IOException ignored) {\n+      // Fail other exceptions silently", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "746d7f40aec8f286b7b9cffa8e132459f560e777"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDkxMjQ1", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-343491245", "createdAt": "2020-01-15T20:12:42Z", "commit": {"oid": "23d9f473aefb4cb717bc619b59adfd7e51e66af8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDoxMjo0M1rOFeFBvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDoxMjo0M1rOFeFBvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4Mzk2NA==", "bodyText": "Add the exception message too? I guess better than nothing.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367083964", "createdAt": "2020-01-15T20:12:43Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param warningLogger {@link Consumer} used to log warnings\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<String> warningLogger, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    warningLogger,\n+                    Verify.verifyNotNull(ProjectInfo.VERSION),\n+                    versionUrl,\n+                    getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<String> warningLogger, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          warningLogger.accept(\n+              \"Failed to read global Jib config; you may need to fix or delete \" + configFile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23d9f473aefb4cb717bc619b59adfd7e51e66af8"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/28f4a8c210baed8f40a682860e664e678e0eb594", "committedDate": "2020-01-15T20:34:03Z", "message": "More logging"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTczMTQ2", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-343573146", "createdAt": "2020-01-15T22:44:53Z", "commit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjo0NDo1M1rOFeI4fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjo0NDo1M1rOFeI4fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0NzEzNA==", "bodyText": "I don't think I know what this is about?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367147134", "createdAt": "2020-01-15T22:44:53Z", "author": {"login": "loosebazooka"}, "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/TaskCommon.java", "diffHunk": "@@ -63,7 +87,8 @@ static void disableHttpLogging() {\n     OutputEventListener defaultOutputEventListener = context.getOutputEventListener();\n     context.setOutputEventListener(\n         event -> {\n-          LogEvent logEvent = (LogEvent) event;\n+          org.gradle.internal.logging.events.LogEvent logEvent =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MjYyMjk5", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344262299", "createdAt": "2020-01-16T22:35:04Z", "commit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMjozNTowNFrOFepvTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMjo0MDoxNFrOFep2hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NTQ1NA==", "bodyText": "I think this should be in it's own class outside of UpdateChecker (if we're going to be eventually using a common config file for jib), but we can do this in another PR.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367685454", "createdAt": "2020-01-16T22:35:04Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NjMxNA==", "bodyText": "Similarly we should think about how we want to read configFile earlier (maybe as part of project properties?)?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367686314", "createdAt": "2020-01-16T22:37:39Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NzMwMg==", "bodyText": "can we close the connection here to interrupt a read?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367687302", "createdAt": "2020-01-16T22:40:14Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          Files.deleteIfExists(configFile);\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          Files.delete(lastUpdateCheck);\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        String latestVersion = bufferedReader.readLine().trim();\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(latestVersion)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + latestVersion\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+      } finally {\n+        connection.disconnect();\n+      }\n+\n+    } catch (IOException ex) {\n+      log.accept(LogEvent.debug(\"Update check failed; \" + ex.getMessage()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  /**\n+   * Returns the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   * otherwise returns the default config directory.\n+   *\n+   * @return the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   *     otherwise returns the default config directory.\n+   */\n+  private static Path getConfigDir() {\n+    String configDirProperty = System.getProperty(PropertyNames.CONFIG_DIRECTORY);\n+    if (!Strings.isNullOrEmpty(configDirProperty)) {\n+      return Paths.get(configDirProperty);\n+    }\n+    return XdgDirectories.getConfigHome();\n+  }\n+\n+  private final Future<Optional<String>> updateMessageFuture;\n+\n+  @VisibleForTesting\n+  UpdateChecker(Future<Optional<String>> updateMessageFuture) {\n+    this.updateMessageFuture = updateMessageFuture;\n+  }\n+\n+  /**\n+   * Returns a message indicating Jib should be upgraded if the check succeeded and the current\n+   * version is outdated, or returns {@code Optional.empty()} if the check was interrupted or did\n+   * not determine that a later version was available.\n+   *\n+   * @return the {@link Optional} message to upgrade Jib if a later version was found, else {@code\n+   *     Optional.empty()}.\n+   */\n+  public Optional<String> finishUpdateCheck() {\n+    if (updateMessageFuture.isDone()) {\n+      try {\n+        return updateMessageFuture.get();\n+      } catch (InterruptedException | ExecutionException ignored) {\n+        // Fail silently;\n+      }\n+    }\n+    updateMessageFuture.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MjcxOTEz", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344271913", "createdAt": "2020-01-16T22:58:02Z", "commit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMjo1ODowMlrOFeqMxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMzowMjozNFrOFeqSUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5Mjk5OA==", "bodyText": "It's a minor point, but I guess there's no need to generate the file. We can remove this whole section?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367692998", "createdAt": "2020-01-16T22:58:02Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          Files.deleteIfExists(configFile);\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MzgzNQ==", "bodyText": "I'd put this before Files.delete(). If we got here due to IOException, there's good chance Files.delete() will fail too. deleteIfExists() will be safer?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367693835", "createdAt": "2020-01-16T23:00:40Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          Files.deleteIfExists(configFile);\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          Files.delete(lastUpdateCheck);\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NDQxNg==", "bodyText": "I'm not really concerned about this. Looks like the Maven/Gradle JVM always terminates no matter what I do in the update checker thread. And particularly it doesn't matter much to close the connection if the build is about to exit.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367694416", "createdAt": "2020-01-16T23:02:34Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          Files.deleteIfExists(configFile);\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          Files.delete(lastUpdateCheck);\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        String latestVersion = bufferedReader.readLine().trim();\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(latestVersion)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + latestVersion\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+      } finally {\n+        connection.disconnect();\n+      }\n+\n+    } catch (IOException ex) {\n+      log.accept(LogEvent.debug(\"Update check failed; \" + ex.getMessage()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  /**\n+   * Returns the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   * otherwise returns the default config directory.\n+   *\n+   * @return the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   *     otherwise returns the default config directory.\n+   */\n+  private static Path getConfigDir() {\n+    String configDirProperty = System.getProperty(PropertyNames.CONFIG_DIRECTORY);\n+    if (!Strings.isNullOrEmpty(configDirProperty)) {\n+      return Paths.get(configDirProperty);\n+    }\n+    return XdgDirectories.getConfigHome();\n+  }\n+\n+  private final Future<Optional<String>> updateMessageFuture;\n+\n+  @VisibleForTesting\n+  UpdateChecker(Future<Optional<String>> updateMessageFuture) {\n+    this.updateMessageFuture = updateMessageFuture;\n+  }\n+\n+  /**\n+   * Returns a message indicating Jib should be upgraded if the check succeeded and the current\n+   * version is outdated, or returns {@code Optional.empty()} if the check was interrupted or did\n+   * not determine that a later version was available.\n+   *\n+   * @return the {@link Optional} message to upgrade Jib if a later version was found, else {@code\n+   *     Optional.empty()}.\n+   */\n+  public Optional<String> finishUpdateCheck() {\n+    if (updateMessageFuture.isDone()) {\n+      try {\n+        return updateMessageFuture.get();\n+      } catch (InterruptedException | ExecutionException ignored) {\n+        // Fail silently;\n+      }\n+    }\n+    updateMessageFuture.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NzMwMg=="}, "originalCommit": {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594"}, "originalPosition": 207}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/946626a35f3b27aac3f6016fc44da8c734b31c69", "committedDate": "2020-01-16T23:11:08Z", "message": "Log before deletion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MjgxNzM0", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344281734", "createdAt": "2020-01-16T23:23:46Z", "commit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MzIwMTk0", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344320194", "createdAt": "2020-01-17T01:33:11Z", "commit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMTozMzoxMVrOFesm7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMTo0MTozMFrOFestxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMjQ2MQ==", "bodyText": "Optional, but it seems a bit unusual to have the non-expected case come last", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367732461", "createdAt": "2020-01-17T01:33:11Z", "author": {"login": "briandealwis"}, "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/MojoCommon.java", "diffHunk": "@@ -40,6 +44,27 @@\n   @VisibleForTesting\n   public static final String REQUIRED_VERSION_PROPERTY_NAME = \"jib.requiredVersion\";\n \n+  public static final String VERSION_URL = \"https://storage.googleapis.com/jib-versions/jib-maven\";\n+\n+  static Optional<UpdateChecker> newUpdateChecker(ProjectProperties projectProperties, Log logger) {\n+    if (!projectProperties.isOffline() && logger.isInfoEnabled()) {\n+      return Optional.of(UpdateChecker.checkForUpdate(projectProperties::log, VERSION_URL));\n+    }\n+    return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzA0OA==", "bodyText": "I guess this is plugins.common but there may be some consumer that wants to provide a execution service", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367733048", "createdAt": "2020-01-17T01:35:53Z", "author": {"login": "briandealwis"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzc2Mg==", "bodyText": "If you passed in the instant, that would make this more easily tested", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367733762", "createdAt": "2020-01-17T01:39:15Z", "author": {"login": "briandealwis"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNDIxMw==", "bodyText": "Could we direct them to the change log?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367734213", "createdAt": "2020-01-17T01:41:30Z", "author": {"login": "briandealwis"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+          Files.delete(lastUpdateCheck);\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        String latestVersion = bufferedReader.readLine().trim();\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(latestVersion)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + latestVersion\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "originalPosition": 156}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1fba58ae41fd747e559d54ede4ce45a97675c6f", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/b1fba58ae41fd747e559d54ede4ce45a97675c6f", "committedDate": "2020-01-17T15:47:40Z", "message": "Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjcyOTY1", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344672965", "createdAt": "2020-01-17T15:55:08Z", "commit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNTo1NTowOFrOFe9Yug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjowODoyNFrOFe9zeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwNzM1NA==", "bodyText": "This method is quite large and would benefit from being broken down.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368007354", "createdAt": "2020-01-17T15:55:08Z", "author": {"login": "briandealwis"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwOTQyOQ==", "bodyText": "This doesn't seem right: we're returning an instance whose class name suggests that it exists to perform an update, but the operation is already in progress.  We could just return the future and make this be a static class\nOr maybe skip the executor entirely and leave how to actually schedule the check to the caller.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368009429", "createdAt": "2020-01-17T15:58:50Z", "author": {"login": "briandealwis"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNDIwMg==", "bodyText": "This class is hard to test because all of the logic is hard-coded into this single method.  Extract the last-check time determination, the current-time generation (Supplier), the modification time comparison (BiPredicate), and this class should be testable through unit tests.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368014202", "createdAt": "2020-01-17T16:08:24Z", "author": {"login": "briandealwis"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzc2Mg=="}, "originalCommit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjkxNzI5", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344691729", "createdAt": "2020-01-17T16:23:32Z", "commit": {"oid": "b1fba58ae41fd747e559d54ede4ce45a97675c6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjoyMzozMlrOFe-QTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjoyMzozMlrOFe-QTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTU4Mg==", "bodyText": "2020", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368021582", "createdAt": "2020-01-17T16:23:32Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1fba58ae41fd747e559d54ede4ce45a97675c6f"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjkxODI3", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344691827", "createdAt": "2020-01-17T16:23:40Z", "commit": {"oid": "b1fba58ae41fd747e559d54ede4ce45a97675c6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjoyMzo0MFrOFe-QmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjoyMzo0MFrOFe-QmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTY1Nw==", "bodyText": "2020", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368021657", "createdAt": "2020-01-17T16:23:40Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2019 Google LLC.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1fba58ae41fd747e559d54ede4ce45a97675c6f"}, "originalPosition": 2}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c865371ab7bf8dab76361796af551f485dc743e3", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/c865371ab7bf8dab76361796af551f485dc743e3", "committedDate": "2020-01-17T16:34:34Z", "message": "Copyright"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NzA0OTUz", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344704953", "createdAt": "2020-01-17T16:44:01Z", "commit": {"oid": "c865371ab7bf8dab76361796af551f485dc743e3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo0NDowMVrOFe-3jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo0NDowMVrOFe-3jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMTYyOA==", "bodyText": "Should the logger also be checked that nothing is logged?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368031628", "createdAt": "2020-01-17T16:44:01Z", "author": {"login": "briandealwis"}, "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+/** Tests for {@link UpdateChecker} */\n+@RunWith(MockitoJUnitRunner.class)\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.getRoot().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    Files.write(\n+        configDir.resolve(\"config.json\"),\n+        \"{\\\"disableUpdateCheck\\\":true}\".getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_failSilently()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    try (TestWebServer badServer =\n+        new TestWebServer(false, Collections.singletonList(\"HTTP/1.1 400 Bad Request\\n\\n\"), 1)) {\n+      Optional<String> message =\n+          UpdateChecker.performUpdateCheck(\n+              ignored -> {}, \"1.0.2\", badServer.getEndpoint(), configDir);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c865371ab7bf8dab76361796af551f485dc743e3"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NzA3Mjkx", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344707291", "createdAt": "2020-01-17T16:47:35Z", "commit": {"oid": "c865371ab7bf8dab76361796af551f485dc743e3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo0NzozNVrOFe--vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo0NzozNVrOFe--vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMzQ3MQ==", "bodyText": "Can we also check for invalid content in the config.json, and that the lastUpdateCheck file is removed on invalid content too.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368033471", "createdAt": "2020-01-17T16:47:35Z", "author": {"login": "briandealwis"}, "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+/** Tests for {@link UpdateChecker} */\n+@RunWith(MockitoJUnitRunner.class)\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.getRoot().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    Files.write(\n+        configDir.resolve(\"config.json\"),\n+        \"{\\\"disableUpdateCheck\\\":true}\".getBytes(StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c865371ab7bf8dab76361796af551f485dc743e3"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6a10f157d85e345e649547be19b5baa48829384", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/f6a10f157d85e345e649547be19b5baa48829384", "committedDate": "2020-01-17T16:58:16Z", "message": "Merge branch 'master' of github.com:GoogleContainerTools/jib into i2193-update-checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6a0aa52fd7b38b0cf1d123326e56f82ca6932e0", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/f6a0aa52fd7b38b0cf1d123326e56f82ca6932e0", "committedDate": "2020-01-17T17:16:50Z", "message": "More tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7b70a8cf465db9b498161041c6c16dde6d99a8b", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/a7b70a8cf465db9b498161041c6c16dde6d99a8b", "committedDate": "2020-01-17T17:36:52Z", "message": "Stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8befde7c10b88ddbabcb55bc41154817a456ab7", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/e8befde7c10b88ddbabcb55bc41154817a456ab7", "committedDate": "2020-01-17T17:43:53Z", "message": "Javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODA0MTk3", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344804197", "createdAt": "2020-01-17T19:47:59Z", "commit": {"oid": "e8befde7c10b88ddbabcb55bc41154817a456ab7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxOTo0ODowMFrOFfDgGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDowMTo1OFrOFfD2JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNzU0NA==", "bodyText": "Remember I also suggested ImmediateFuture()? I think there's no good reason to do executorService.submit().", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368107544", "createdAt": "2020-01-17T19:48:00Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.api.LogEvent.Level;\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+/** Tests for {@link UpdateChecker} */\n+@RunWith(MockitoJUnitRunner.class)\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.getRoot().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    Files.write(\n+        configDir.resolve(\"config.json\"),\n+        \"{\\\"disableUpdateCheck\\\":true}\".getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_badConfig() throws IOException {\n+    Files.write(\n+        configDir.resolve(\"config.json\"), \"corrupt config\".getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_badLastUpdateTime() throws IOException {\n+    Instant before = Instant.now();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"), \"bad timestamp\".getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_failSilently()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    try (TestWebServer badServer =\n+        new TestWebServer(false, Collections.singletonList(\"HTTP/1.1 400 Bad Request\\n\\n\"), 1)) {\n+      Optional<String> message =\n+          UpdateChecker.performUpdateCheck(\n+              logEvent -> {\n+                Assert.assertEquals(logEvent.getLevel(), Level.DEBUG);\n+                Assert.assertTrue(logEvent.getMessage().contains(\"Update check failed; \"));\n+              },\n+              \"1.0.2\",\n+              badServer.getEndpoint(),\n+              configDir);\n+      Assert.assertFalse(message.isPresent());\n+    }\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_success() {\n+    ExecutorService executorService = MoreExecutors.newDirectExecutorService();\n+    Future<Optional<String>> updateCheckFuture = executorService.submit(() -> Optional.of(\"Hello\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8befde7c10b88ddbabcb55bc41154817a456ab7"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExMzE4OQ==", "bodyText": "Without saying much, I think a pseudo-code-like high-level branching description as a method like below helps:\nvoid performUpdateCheck() {\n    try {\n      if (!checkGlobalConfig(...)) { // or isUpdateCheckDisabled() or something else\n        return Optional.empty();\n      }\n      if (!checkLastUpdateTime(...)) { // or isTimeToCheckBack() or something else, some name that itself gives you the confidence by just reading it that you don't even feel the necessity to look into the method code\n        return Optional.empty();\n      }\n      ... = fetchUrl(versionUrl); // or something else, the method may have a larger scope than just contacting the server, or it may just be okay to not have a method at this point\n      \n    } catch ( ... ) {\n    }\n  }\nA long method may be comfortable to the repo maintainers, but it may not be so to people new to the repo. Like, what I feel when I try to read this.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368113189", "createdAt": "2020-01-17T20:01:58Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwNzM1NA=="}, "originalCommit": {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODE2MDU4", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-344816058", "createdAt": "2020-01-17T20:11:48Z", "commit": {"oid": "e8befde7c10b88ddbabcb55bc41154817a456ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDoxMTo0OFrOFfEDqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMDoxMTo0OFrOFfEDqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExNjY0OA==", "bodyText": "If newUpdateChecker creates Executors.newSingleThreadExecutor(), let's make it \"close\" it, i.e., calling shutdown() in newUpdateChecker. And although I don't care much since I know our plugins just terminate without even calling shutdown(), I guess it doesn't harm to guarantee it in finally.\n} finally {\n   executorService.shutdown();\n}", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368116648", "createdAt": "2020-01-17T20:11:48Z", "author": {"login": "chanseokoh"}, "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/TaskCommon.java", "diffHunk": "@@ -17,25 +17,58 @@\n package com.google.cloud.tools.jib.gradle;\n \n import com.google.api.client.http.HttpTransport;\n+import com.google.cloud.tools.jib.ProjectInfo;\n import com.google.cloud.tools.jib.api.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.FilePermissions;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.plugins.common.ProjectProperties;\n+import com.google.cloud.tools.jib.plugins.common.UpdateChecker;\n+import com.google.common.util.concurrent.Futures;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n import java.util.logging.Level;\n import javax.annotation.Nullable;\n import org.gradle.api.Project;\n import org.gradle.api.Task;\n import org.gradle.api.UnknownTaskException;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.plugins.WarPlugin;\n import org.gradle.api.tasks.TaskProvider;\n-import org.gradle.internal.logging.events.LogEvent;\n import org.gradle.internal.logging.events.OutputEventListener;\n import org.gradle.internal.logging.slf4j.OutputEventListenerBackedLoggerContext;\n import org.slf4j.LoggerFactory;\n \n /** Collection of common methods to share between Gradle tasks. */\n class TaskCommon {\n \n+  public static final String VERSION_URL = \"https://storage.googleapis.com/jib-versions/jib-gradle\";\n+\n+  static Future<Optional<String>> newUpdateChecker(\n+      ProjectProperties projectProperties, Logger logger) {\n+    if (projectProperties.isOffline() || !logger.isLifecycleEnabled()) {\n+      return Futures.immediateFuture(Optional.empty());\n+    }\n+    return UpdateChecker.checkForUpdate(\n+        Executors.newSingleThreadExecutor(), projectProperties::log, VERSION_URL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8befde7c10b88ddbabcb55bc41154817a456ab7"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c94c7660639458d2e617486ddf1346fc16e67f1", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/0c94c7660639458d2e617486ddf1346fc16e67f1", "committedDate": "2020-01-17T20:26:58Z", "message": "Json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae6288ccd5b1bbe54b2dad2a2d710f76277cb216", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/ae6288ccd5b1bbe54b2dad2a2d710f76277cb216", "committedDate": "2020-01-17T20:33:34Z", "message": "More code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d95d34bd3aaaae05e986bc69760169e7e925aec0", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/d95d34bd3aaaae05e986bc69760169e7e925aec0", "committedDate": "2020-01-17T20:45:41Z", "message": "Fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1OTc5MjMx", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-345979231", "createdAt": "2020-01-21T15:44:43Z", "commit": {"oid": "d95d34bd3aaaae05e986bc69760169e7e925aec0"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNTo0NDo0M1rOFf-yow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNTo0ODoxMFrOFf-7Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA3ODk0Nw==", "bodyText": "any reason for this?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369078947", "createdAt": "2020-01-21T15:44:43Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/PluginConfigurationProcessor.java", "diffHunk": "@@ -166,10 +166,8 @@ public static JibBuildRunner createJibBuildRunnerForRegistryImage(\n         rawConfiguration.getToCredHelper().orElse(null));\n \n     boolean alwaysCacheBaseImage =\n-        Boolean.valueOf(\n-            rawConfiguration\n-                .getProperty(PropertyNames.ALWAYS_CACHE_BASE_IMAGE)\n-                .orElse(Boolean.FALSE.toString()));\n+        Boolean.parseBoolean(\n+            rawConfiguration.getProperty(PropertyNames.ALWAYS_CACHE_BASE_IMAGE).orElse(\"false\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95d34bd3aaaae05e986bc69760169e7e925aec0"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA3OTY1Mg==", "bodyText": "what happens when the verify fails?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369079652", "createdAt": "2020-01-21T15:45:53Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /** JSON template for content downloaded during version check. */\n+  private static class VersionJsonTemplate implements JsonTemplate {\n+    private String latest = \"\";\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param executorService the {@link ExecutorService}\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static Future<Optional<String>> checkForUpdate(\n+      ExecutorService executorService, Consumer<LogEvent> log, String versionUrl) {\n+    return executorService.submit(\n+        () ->\n+            performUpdateCheck(\n+                log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95d34bd3aaaae05e986bc69760169e7e925aec0"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA4MTE3MA==", "bodyText": "I thought we had some sort of static class do this?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369081170", "createdAt": "2020-01-21T15:48:10Z", "author": {"login": "loosebazooka"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /** JSON template for content downloaded during version check. */\n+  private static class VersionJsonTemplate implements JsonTemplate {\n+    private String latest = \"\";\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param executorService the {@link ExecutorService}\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static Future<Optional<String>> checkForUpdate(\n+      ExecutorService executorService, Consumer<LogEvent> log, String versionUrl) {\n+    return executorService.submit(\n+        () ->\n+            performUpdateCheck(\n+                log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+          Files.delete(lastUpdateCheck);\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        VersionJsonTemplate version =\n+            JsonTemplateMapper.readJson(\n+                bufferedReader.readLine().trim(), VersionJsonTemplate.class);\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(version.latest)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + version.latest\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+      } finally {\n+        connection.disconnect();\n+      }\n+\n+    } catch (IOException ex) {\n+      log.accept(LogEvent.debug(\"Update check failed; \" + ex.getMessage()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  /**\n+   * Returns a message indicating Jib should be upgraded if the check succeeded and the current\n+   * version is outdated, or returns {@code Optional.empty()} if the check was interrupted or did\n+   * not determine that a later version was available.\n+   *\n+   * @param updateMessageFuture the {@link Future} returned by {@link UpdateChecker#checkForUpdate}\n+   * @return the {@link Optional} message to upgrade Jib if a later version was found, else {@code\n+   *     Optional.empty()}.\n+   */\n+  public static Optional<String> finishUpdateCheck(Future<Optional<String>> updateMessageFuture) {\n+    if (updateMessageFuture.isDone()) {\n+      try {\n+        return updateMessageFuture.get();\n+      } catch (InterruptedException | ExecutionException ignored) {\n+        // Fail silently;\n+      }\n+    }\n+    updateMessageFuture.cancel(true);\n+    return Optional.empty();\n+  }\n+\n+  /**\n+   * Returns the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   * otherwise returns the default config directory.\n+   *\n+   * @return the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   *     otherwise returns the default config directory.\n+   */\n+  private static Path getConfigDir() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d95d34bd3aaaae05e986bc69760169e7e925aec0"}, "originalPosition": 201}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "216bda4c48975c84729b6e9a123cc23b65157224", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/216bda4c48975c84729b6e9a123cc23b65157224", "committedDate": "2020-01-21T15:49:09Z", "message": "Ignore unknown fields from pulled json"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1OTg2NDM2", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-345986436", "createdAt": "2020-01-21T15:53:30Z", "commit": {"oid": "216bda4c48975c84729b6e9a123cc23b65157224"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNTo1MzozMFrOFf_IwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNTo1MzozMFrOFf_IwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA4NDYwOA==", "bodyText": "readLine() seems unsafe. It will break if our JSON file is not a single-line JSON. I think you used BufferedReader only to use readLine(), so perhaps it's no longer necessary. Maybe use InputStream directly?", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369084608", "createdAt": "2020-01-21T15:53:30Z", "author": {"login": "chanseokoh"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /** JSON template for content downloaded during version check. */\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  private static class VersionJsonTemplate implements JsonTemplate {\n+    private String latest = \"\";\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param executorService the {@link ExecutorService}\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static Future<Optional<String>> checkForUpdate(\n+      ExecutorService executorService, Consumer<LogEvent> log, String versionUrl) {\n+    return executorService.submit(\n+        () ->\n+            performUpdateCheck(\n+                log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+          Files.delete(lastUpdateCheck);\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        VersionJsonTemplate version =\n+            JsonTemplateMapper.readJson(\n+                bufferedReader.readLine().trim(), VersionJsonTemplate.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "216bda4c48975c84729b6e9a123cc23b65157224"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05bd091cf4f3228fcd6b46f2d7241c21668179af", "author": {"user": {"login": "TadCordle", "name": "Tad Cordle"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/05bd091cf4f3228fcd6b46f2d7241c21668179af", "committedDate": "2020-01-21T15:59:52Z", "message": "Input stream"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MDEzNzk3", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-346013797", "createdAt": "2020-01-21T16:27:05Z", "commit": {"oid": "05bd091cf4f3228fcd6b46f2d7241c21668179af"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NjAzMjk5", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#pullrequestreview-346603299", "createdAt": "2020-01-22T13:56:20Z", "commit": {"oid": "05bd091cf4f3228fcd6b46f2d7241c21668179af"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMzo1NjoyMFrOFgc5WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMzo1NjoyMFrOFgc5WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3MjE4NQ==", "bodyText": "I realize that this doesn't handle proxies.", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369572185", "createdAt": "2020-01-22T13:56:20Z", "author": {"login": "briandealwis"}, "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /** JSON template for content downloaded during version check. */\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  private static class VersionJsonTemplate implements JsonTemplate {\n+    private String latest = \"\";\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param executorService the {@link ExecutorService}\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static Future<Optional<String>> checkForUpdate(\n+      ExecutorService executorService, Consumer<LogEvent> log, String versionUrl) {\n+    return executorService.submit(\n+        () ->\n+            performUpdateCheck(\n+                log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+          Files.delete(lastUpdateCheck);\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05bd091cf4f3228fcd6b46f2d7241c21668179af"}, "originalPosition": 142}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 284, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}