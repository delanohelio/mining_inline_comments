{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2NDE4ODc3", "number": 2849, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1MDo0N1rOEvsYdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyODowN1rOEv9tiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDQ1Njg0OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOTo1MDo0N1rOHk0GPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDoxMToxNlrOHk-9Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2NDM0OQ==", "bodyText": "Actually these need to be added in reverse order", "url": "https://github.com/GoogleContainerTools/jib/pull/2849#discussion_r508364349", "createdAt": "2020-10-20T09:50:47Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -96,49 +104,72 @@\n                     .map(Layers::toPathMatcher)\n                     .collect(Collectors.toList());\n             try (Stream<Path> dirWalk = Files.walk(src)) {\n-              dirWalk\n-                  // filter out against excludes\n-                  .filter(path -> excludes.stream().noneMatch(exclude -> exclude.matches(path)))\n-                  .filter(\n-                      path -> {\n-                        // if there are no includes directives, include everything\n-                        if (includes.isEmpty()) {\n-                          return true;\n-                        }\n-                        // TODO: if <dest>/path/to/file.txt is included because of a pattern like\n-                        // TODO: **/file.txt, ensure we create <dest>/path and <dest>/path/to with\n-                        // TODO: the correct directory properties here\n-                        // if there are includes directives, only include those specified\n-                        for (PathMatcher matcher : includes) {\n-                          if (matcher.matches(path)) {\n-                            return true;\n-                          }\n-                        }\n-                        return false;\n-                      })\n-                  .map(\n-                      path -> {\n-                        Path relative = src.relativize(path);\n-                        if (Files.isDirectory(path) || Files.isRegularFile(path)) {\n-                          return new FileEntry(\n-                              path,\n-                              dest.resolve(relative),\n-                              Files.isDirectory(path)\n-                                  ? filePropertiesStack.getDirectoryPermissions()\n-                                  : filePropertiesStack.getFilePermissions(),\n-                              filePropertiesStack.getModificationTime(),\n-                              filePropertiesStack.getOwnership());\n-                        } else {\n-                          throw new UnsupportedOperationException(\n-                              \"Cannot create FileLayers from non-file, non-directory: \"\n-                                  + path.toString());\n-                        }\n-                      })\n-                  .forEach(layerBuiler::addEntry);\n+              List<Path> filtered =\n+                  dirWalk\n+                      // filter out against excludes\n+                      .filter(path -> excludes.stream().noneMatch(exclude -> exclude.matches(path)))\n+                      .filter(\n+                          path -> {\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                      .collect(Collectors.toList());\n+\n+              BiFunction<Path, FilePermissions, FileEntry> newEntry =\n+                  (file, permission) ->\n+                      new FileEntry(\n+                          file,\n+                          dest.resolve(src.relativize(file)),\n+                          permission,\n+                          filePropertiesStack.getModificationTime(),\n+                          filePropertiesStack.getOwnership());\n+\n+              Set<Path> addedDirectories = new HashSet<>();\n+              for (Path path : filtered) {\n+                if (!Files.isDirectory(path) && !Files.isRegularFile(path)) {\n+                  throw new UnsupportedOperationException(\n+                      \"Cannot create FileLayers from non-file, non-directory: \" + src.toString());\n+                }\n+\n+                if (Files.isDirectory(path)) {\n+                  addedDirectories.add(path);\n+                  layerBuiler.addEntry(\n+                      newEntry.apply(path, filePropertiesStack.getDirectoryPermissions()));\n+                } else if (Files.isRegularFile(path)) {\n+                  if (!path.startsWith(src)) {\n+                    // if we end up in a situation where the file added is somehow outside of the\n+                    // tree then we do not know how to properly handle it at the moment. It could\n+                    // be from a link scenario that we do not understand.\n+                    throw new IllegalStateException(\n+                        src.toString() + \" is not a parent of \" + path.toString());\n+                  }\n+                  Path parent = path.getParent();\n+                  while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a71093c50e7de292885eb55ae3c844b1b105ec"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU0MjI4Ng==", "bodyText": "Actually reproducible layer builder should sort these.", "url": "https://github.com/GoogleContainerTools/jib/pull/2849#discussion_r508542286", "createdAt": "2020-10-20T14:11:16Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -96,49 +104,72 @@\n                     .map(Layers::toPathMatcher)\n                     .collect(Collectors.toList());\n             try (Stream<Path> dirWalk = Files.walk(src)) {\n-              dirWalk\n-                  // filter out against excludes\n-                  .filter(path -> excludes.stream().noneMatch(exclude -> exclude.matches(path)))\n-                  .filter(\n-                      path -> {\n-                        // if there are no includes directives, include everything\n-                        if (includes.isEmpty()) {\n-                          return true;\n-                        }\n-                        // TODO: if <dest>/path/to/file.txt is included because of a pattern like\n-                        // TODO: **/file.txt, ensure we create <dest>/path and <dest>/path/to with\n-                        // TODO: the correct directory properties here\n-                        // if there are includes directives, only include those specified\n-                        for (PathMatcher matcher : includes) {\n-                          if (matcher.matches(path)) {\n-                            return true;\n-                          }\n-                        }\n-                        return false;\n-                      })\n-                  .map(\n-                      path -> {\n-                        Path relative = src.relativize(path);\n-                        if (Files.isDirectory(path) || Files.isRegularFile(path)) {\n-                          return new FileEntry(\n-                              path,\n-                              dest.resolve(relative),\n-                              Files.isDirectory(path)\n-                                  ? filePropertiesStack.getDirectoryPermissions()\n-                                  : filePropertiesStack.getFilePermissions(),\n-                              filePropertiesStack.getModificationTime(),\n-                              filePropertiesStack.getOwnership());\n-                        } else {\n-                          throw new UnsupportedOperationException(\n-                              \"Cannot create FileLayers from non-file, non-directory: \"\n-                                  + path.toString());\n-                        }\n-                      })\n-                  .forEach(layerBuiler::addEntry);\n+              List<Path> filtered =\n+                  dirWalk\n+                      // filter out against excludes\n+                      .filter(path -> excludes.stream().noneMatch(exclude -> exclude.matches(path)))\n+                      .filter(\n+                          path -> {\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                      .collect(Collectors.toList());\n+\n+              BiFunction<Path, FilePermissions, FileEntry> newEntry =\n+                  (file, permission) ->\n+                      new FileEntry(\n+                          file,\n+                          dest.resolve(src.relativize(file)),\n+                          permission,\n+                          filePropertiesStack.getModificationTime(),\n+                          filePropertiesStack.getOwnership());\n+\n+              Set<Path> addedDirectories = new HashSet<>();\n+              for (Path path : filtered) {\n+                if (!Files.isDirectory(path) && !Files.isRegularFile(path)) {\n+                  throw new UnsupportedOperationException(\n+                      \"Cannot create FileLayers from non-file, non-directory: \" + src.toString());\n+                }\n+\n+                if (Files.isDirectory(path)) {\n+                  addedDirectories.add(path);\n+                  layerBuiler.addEntry(\n+                      newEntry.apply(path, filePropertiesStack.getDirectoryPermissions()));\n+                } else if (Files.isRegularFile(path)) {\n+                  if (!path.startsWith(src)) {\n+                    // if we end up in a situation where the file added is somehow outside of the\n+                    // tree then we do not know how to properly handle it at the moment. It could\n+                    // be from a link scenario that we do not understand.\n+                    throw new IllegalStateException(\n+                        src.toString() + \" is not a parent of \" + path.toString());\n+                  }\n+                  Path parent = path.getParent();\n+                  while (true) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2NDM0OQ=="}, "originalCommit": {"oid": "f7a71093c50e7de292885eb55ae3c844b1b105ec"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NTk0NjM5OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNToyMTowOVrOHlCk4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjoxMToyNFrOHlGDuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwMTU2OA==", "bodyText": "Is this primarily to guard against symlinks?", "url": "https://github.com/GoogleContainerTools/jib/pull/2849#discussion_r508601568", "createdAt": "2020-10-20T15:21:09Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -71,6 +75,10 @@\n           Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n           AbsoluteUnixPath dest = copySpec.getDest();\n \n+          if (!Files.isDirectory(src) && !Files.isRegularFile(src)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a71093c50e7de292885eb55ae3c844b1b105ec"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1ODYxNg==", "bodyText": "Yeah there's two checks. One for non existence and one for unknown types. Perhaps the messaging should be different", "url": "https://github.com/GoogleContainerTools/jib/pull/2849#discussion_r508658616", "createdAt": "2020-10-20T16:11:24Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -71,6 +75,10 @@\n           Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n           AbsoluteUnixPath dest = copySpec.getDest();\n \n+          if (!Files.isDirectory(src) && !Files.isRegularFile(src)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwMTU2OA=="}, "originalCommit": {"oid": "f7a71093c50e7de292885eb55ae3c844b1b105ec"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI5NjExOnYy", "diffSide": "RIGHT", "path": "jib-cli/src/test/resources/buildfiles/layers/includesExcludesTest/layers.yaml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyODowN1rOHlPyyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyODowN1rOHlPyyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODEyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      # equivalent to \"**/excludedDir/**\"", "url": "https://github.com/GoogleContainerTools/jib/pull/2849#discussion_r508818122", "createdAt": "2020-10-20T20:28:07Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/resources/buildfiles/layers/includesExcludesTest/layers.yaml", "diffHunk": "@@ -33,11 +33,20 @@ entries:\n         excludes:\n           # equivalent to \"**/excludedDir/**\"\n           - \"**/excludedDir/\"\n+  - name: \"exclude dir and contents\"\n+    files:\n+      - src: \"project\"\n+        dest: \"/target/edac\"\n+        excludes:\n+          # equivalent to \"**/excludedDir/**\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7a71093c50e7de292885eb55ae3c844b1b105ec"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4988, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}