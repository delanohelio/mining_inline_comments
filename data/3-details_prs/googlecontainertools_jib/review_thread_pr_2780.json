{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxMTY3ODAy", "number": 2780, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMDoyNDo1OFrOEm1GjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNToxNzoyMVrOEnGFqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTUxMzcyOnYy", "diffSide": "RIGHT", "path": "jib-core/src/test/java/com/google/cloud/tools/jib/builder/steps/StepsRunnerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMDoyNDo1OFrOHXFlOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNDo0NTo0MVrOHXegLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3MDc0NQ==", "bodyText": "The instructions seem to indicate maybe a different approach, but I don't know if you already considered that.\n\nUse TestingExecutors.sameThreadScheduledExecutor, or wrap a real Executor from java.util.concurrent.Executors with MoreExecutors.listeningDecorator", "url": "https://github.com/GoogleContainerTools/jib/pull/2780#discussion_r493970745", "createdAt": "2020-09-24T00:24:58Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/test/java/com/google/cloud/tools/jib/builder/steps/StepsRunnerTest.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.builder.steps;\n+\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n+import com.google.cloud.tools.jib.builder.steps.PullBaseImageStep.ImagesAndRegistryClient;\n+import com.google.cloud.tools.jib.configuration.BuildContext;\n+import com.google.cloud.tools.jib.image.DigestOnlyLayer;\n+import com.google.cloud.tools.jib.image.Image;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.ForwardingExecutorService;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import java.security.DigestException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+/** Tests for {@link StepsRunner}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public class StepsRunnerTest {\n+\n+  // ListeningExecutorService is annotated with @DoNotMock, so define a concrete class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86d4f17cfcc27ab21c965c53c24f8b6200ff51f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3OTA1NA==", "bodyText": "I saw the comment, but I think it cannot apply to what I'm trying to achieve. TestingExecutors.sameThreadScheduledExecutor and MoreExecutors.listeningDecorator actually executes given tasks, whereas here I want to mock it at a higher level to simulate tasks.\nI tried quite a lot of time to find the simplest way to mock ListeningExecutorService.submit(), but this code was the shortest I could get so far.", "url": "https://github.com/GoogleContainerTools/jib/pull/2780#discussion_r494379054", "createdAt": "2020-09-24T14:45:41Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/test/java/com/google/cloud/tools/jib/builder/steps/StepsRunnerTest.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.builder.steps;\n+\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n+import com.google.cloud.tools.jib.builder.steps.PullBaseImageStep.ImagesAndRegistryClient;\n+import com.google.cloud.tools.jib.configuration.BuildContext;\n+import com.google.cloud.tools.jib.image.DigestOnlyLayer;\n+import com.google.cloud.tools.jib.image.Image;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.ForwardingExecutorService;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import java.security.DigestException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+/** Tests for {@link StepsRunner}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public class StepsRunnerTest {\n+\n+  // ListeningExecutorService is annotated with @DoNotMock, so define a concrete class.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3MDc0NQ=="}, "originalCommit": {"oid": "b86d4f17cfcc27ab21c965c53c24f8b6200ff51f"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MTUyNDMxOnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMDozMDoxOVrOHXFrNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNDo0MjoxNlrOHXeVog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3MjI3Ng==", "bodyText": "I thought that maybe this could have threading issues, but we never call this in parallel right? Is there any value in marking this not threadsafe?", "url": "https://github.com/GoogleContainerTools/jib/pull/2780#discussion_r493972276", "createdAt": "2020-09-24T00:30:19Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -306,36 +311,61 @@ private void obtainBaseImagesLayers(\n                       \"scheduling obtaining base images layers\",\n                       results.baseImagesAndRegistryClient.get().images.size())) {\n \n+                Map<DescriptorDigest, Future<PreparedLayer>> preparedLayersCache = new HashMap<>();\n                 Map<Image, List<Future<PreparedLayer>>> baseImagesAndLayers = new HashMap<>();\n                 for (Image baseImage : results.baseImagesAndRegistryClient.get().images) {\n                   List<Future<PreparedLayer>> layers =\n                       obtainBaseImageLayers(\n-                          baseImage, layersRequiredLocally, progressDispatcher.newChildProducer());\n+                          baseImage,\n+                          layersRequiredLocally,\n+                          preparedLayersCache,\n+                          progressDispatcher.newChildProducer());\n                   baseImagesAndLayers.put(baseImage, layers);\n                 }\n                 return baseImagesAndLayers;\n               }\n             });\n   }\n \n-  private List<Future<PreparedLayer>> obtainBaseImageLayers(\n+  @VisibleForTesting\n+  List<Future<PreparedLayer>> obtainBaseImageLayers(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86d4f17cfcc27ab21c965c53c24f8b6200ff51f"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM3NjM1NA==", "bodyText": "Added a comment\n// This method updates the given \"preparedLayersCache\" and should not be called concurrently.\n\n. (FYI, @NotThreadSafe can only be applied to a class.)\nThis non-blocking method is called only by a single thread task inside obtainBaseImagesLayers().", "url": "https://github.com/GoogleContainerTools/jib/pull/2780#discussion_r494376354", "createdAt": "2020-09-24T14:42:16Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -306,36 +311,61 @@ private void obtainBaseImagesLayers(\n                       \"scheduling obtaining base images layers\",\n                       results.baseImagesAndRegistryClient.get().images.size())) {\n \n+                Map<DescriptorDigest, Future<PreparedLayer>> preparedLayersCache = new HashMap<>();\n                 Map<Image, List<Future<PreparedLayer>>> baseImagesAndLayers = new HashMap<>();\n                 for (Image baseImage : results.baseImagesAndRegistryClient.get().images) {\n                   List<Future<PreparedLayer>> layers =\n                       obtainBaseImageLayers(\n-                          baseImage, layersRequiredLocally, progressDispatcher.newChildProducer());\n+                          baseImage,\n+                          layersRequiredLocally,\n+                          preparedLayersCache,\n+                          progressDispatcher.newChildProducer());\n                   baseImagesAndLayers.put(baseImage, layers);\n                 }\n                 return baseImagesAndLayers;\n               }\n             });\n   }\n \n-  private List<Future<PreparedLayer>> obtainBaseImageLayers(\n+  @VisibleForTesting\n+  List<Future<PreparedLayer>> obtainBaseImageLayers(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3MjI3Ng=="}, "originalCommit": {"oid": "b86d4f17cfcc27ab21c965c53c24f8b6200ff51f"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NDI5NjcyOnYy", "diffSide": "RIGHT", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNToxNzoyMVrOHXf-gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNTozNzozOFrOHXg56A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMzIwMw==", "bodyText": "Just a thought: we currently check to see if the layer already exists before pushing a new one, but what would we do if we needed to update a layer?/ Can base image layers be updated?", "url": "https://github.com/GoogleContainerTools/jib/pull/2780#discussion_r494403203", "createdAt": "2020-09-24T15:17:21Z", "author": {"login": "mpeddada1"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -306,36 +311,62 @@ private void obtainBaseImagesLayers(\n                       \"scheduling obtaining base images layers\",\n                       results.baseImagesAndRegistryClient.get().images.size())) {\n \n+                Map<DescriptorDigest, Future<PreparedLayer>> preparedLayersCache = new HashMap<>();\n                 Map<Image, List<Future<PreparedLayer>>> baseImagesAndLayers = new HashMap<>();\n                 for (Image baseImage : results.baseImagesAndRegistryClient.get().images) {\n                   List<Future<PreparedLayer>> layers =\n                       obtainBaseImageLayers(\n-                          baseImage, layersRequiredLocally, progressDispatcher.newChildProducer());\n+                          baseImage,\n+                          layersRequiredLocally,\n+                          preparedLayersCache,\n+                          progressDispatcher.newChildProducer());\n                   baseImagesAndLayers.put(baseImage, layers);\n                 }\n                 return baseImagesAndLayers;\n               }\n             });\n   }\n \n-  private List<Future<PreparedLayer>> obtainBaseImageLayers(\n+  // This method updates the given \"preparedLayersCache\" and should not be called concurrently.\n+  @VisibleForTesting\n+  List<Future<PreparedLayer>> obtainBaseImageLayers(\n       Image baseImage,\n       boolean layersRequiredLocally,\n+      Map<DescriptorDigest, Future<PreparedLayer>> preparedLayersCache,\n       ProgressEventDispatcher.Factory progressDispatcherFactory)\n       throws InterruptedException, ExecutionException {\n-    return scheduleCallables(\n-        layersRequiredLocally\n-            ? ObtainBaseImageLayerStep.makeListForForcedDownload(\n-                buildContext,\n-                progressDispatcherFactory,\n-                baseImage,\n-                results.baseImagesAndRegistryClient.get().registryClient)\n-            : ObtainBaseImageLayerStep.makeListForSelectiveDownload(\n-                buildContext,\n-                progressDispatcherFactory,\n-                baseImage,\n-                results.baseImagesAndRegistryClient.get().registryClient,\n-                results.targetRegistryClient.get()));\n+    List<Future<PreparedLayer>> preparedLayers = new ArrayList<>();\n+\n+    try (ProgressEventDispatcher progressDispatcher =\n+        progressDispatcherFactory.create(\n+            \"launching base image layer pullers\", baseImage.getLayers().size())) {\n+      for (Layer layer : baseImage.getLayers()) {\n+        DescriptorDigest digest = layer.getBlobDescriptor().getDigest();\n+        Future<PreparedLayer> preparedLayer = preparedLayersCache.get(digest);\n+\n+        if (preparedLayer != null) {\n+          progressDispatcher.dispatchProgress(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb953516b271cd37a637601ee251f7041b8687a5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQxMTcyMw==", "bodyText": "Not sure I understand your point. To clarify a few things,\n\nThis section of code is to download a base image layer.\nIn a later stage, base image layers need to be pushed to a target registry (but only those layers missing in the registry).\nA layer is just a block of bytes (blob) identified and addressed by a SHA digest. And every blob is immutable and content-addressable. There's nothing like \"updating\" a blob or an existing image. If the content of a blob or an \"image\" is different, it is a new blob or a new image with different addresses.", "url": "https://github.com/GoogleContainerTools/jib/pull/2780#discussion_r494411723", "createdAt": "2020-09-24T15:28:40Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -306,36 +311,62 @@ private void obtainBaseImagesLayers(\n                       \"scheduling obtaining base images layers\",\n                       results.baseImagesAndRegistryClient.get().images.size())) {\n \n+                Map<DescriptorDigest, Future<PreparedLayer>> preparedLayersCache = new HashMap<>();\n                 Map<Image, List<Future<PreparedLayer>>> baseImagesAndLayers = new HashMap<>();\n                 for (Image baseImage : results.baseImagesAndRegistryClient.get().images) {\n                   List<Future<PreparedLayer>> layers =\n                       obtainBaseImageLayers(\n-                          baseImage, layersRequiredLocally, progressDispatcher.newChildProducer());\n+                          baseImage,\n+                          layersRequiredLocally,\n+                          preparedLayersCache,\n+                          progressDispatcher.newChildProducer());\n                   baseImagesAndLayers.put(baseImage, layers);\n                 }\n                 return baseImagesAndLayers;\n               }\n             });\n   }\n \n-  private List<Future<PreparedLayer>> obtainBaseImageLayers(\n+  // This method updates the given \"preparedLayersCache\" and should not be called concurrently.\n+  @VisibleForTesting\n+  List<Future<PreparedLayer>> obtainBaseImageLayers(\n       Image baseImage,\n       boolean layersRequiredLocally,\n+      Map<DescriptorDigest, Future<PreparedLayer>> preparedLayersCache,\n       ProgressEventDispatcher.Factory progressDispatcherFactory)\n       throws InterruptedException, ExecutionException {\n-    return scheduleCallables(\n-        layersRequiredLocally\n-            ? ObtainBaseImageLayerStep.makeListForForcedDownload(\n-                buildContext,\n-                progressDispatcherFactory,\n-                baseImage,\n-                results.baseImagesAndRegistryClient.get().registryClient)\n-            : ObtainBaseImageLayerStep.makeListForSelectiveDownload(\n-                buildContext,\n-                progressDispatcherFactory,\n-                baseImage,\n-                results.baseImagesAndRegistryClient.get().registryClient,\n-                results.targetRegistryClient.get()));\n+    List<Future<PreparedLayer>> preparedLayers = new ArrayList<>();\n+\n+    try (ProgressEventDispatcher progressDispatcher =\n+        progressDispatcherFactory.create(\n+            \"launching base image layer pullers\", baseImage.getLayers().size())) {\n+      for (Layer layer : baseImage.getLayers()) {\n+        DescriptorDigest digest = layer.getBlobDescriptor().getDigest();\n+        Future<PreparedLayer> preparedLayer = preparedLayersCache.get(digest);\n+\n+        if (preparedLayer != null) {\n+          progressDispatcher.dispatchProgress(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMzIwMw=="}, "originalCommit": {"oid": "eb953516b271cd37a637601ee251f7041b8687a5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQxODQwOA==", "bodyText": "I see, thanks for clarifying! This really clears up some of the key concepts I was missing:)", "url": "https://github.com/GoogleContainerTools/jib/pull/2780#discussion_r494418408", "createdAt": "2020-09-24T15:37:38Z", "author": {"login": "mpeddada1"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -306,36 +311,62 @@ private void obtainBaseImagesLayers(\n                       \"scheduling obtaining base images layers\",\n                       results.baseImagesAndRegistryClient.get().images.size())) {\n \n+                Map<DescriptorDigest, Future<PreparedLayer>> preparedLayersCache = new HashMap<>();\n                 Map<Image, List<Future<PreparedLayer>>> baseImagesAndLayers = new HashMap<>();\n                 for (Image baseImage : results.baseImagesAndRegistryClient.get().images) {\n                   List<Future<PreparedLayer>> layers =\n                       obtainBaseImageLayers(\n-                          baseImage, layersRequiredLocally, progressDispatcher.newChildProducer());\n+                          baseImage,\n+                          layersRequiredLocally,\n+                          preparedLayersCache,\n+                          progressDispatcher.newChildProducer());\n                   baseImagesAndLayers.put(baseImage, layers);\n                 }\n                 return baseImagesAndLayers;\n               }\n             });\n   }\n \n-  private List<Future<PreparedLayer>> obtainBaseImageLayers(\n+  // This method updates the given \"preparedLayersCache\" and should not be called concurrently.\n+  @VisibleForTesting\n+  List<Future<PreparedLayer>> obtainBaseImageLayers(\n       Image baseImage,\n       boolean layersRequiredLocally,\n+      Map<DescriptorDigest, Future<PreparedLayer>> preparedLayersCache,\n       ProgressEventDispatcher.Factory progressDispatcherFactory)\n       throws InterruptedException, ExecutionException {\n-    return scheduleCallables(\n-        layersRequiredLocally\n-            ? ObtainBaseImageLayerStep.makeListForForcedDownload(\n-                buildContext,\n-                progressDispatcherFactory,\n-                baseImage,\n-                results.baseImagesAndRegistryClient.get().registryClient)\n-            : ObtainBaseImageLayerStep.makeListForSelectiveDownload(\n-                buildContext,\n-                progressDispatcherFactory,\n-                baseImage,\n-                results.baseImagesAndRegistryClient.get().registryClient,\n-                results.targetRegistryClient.get()));\n+    List<Future<PreparedLayer>> preparedLayers = new ArrayList<>();\n+\n+    try (ProgressEventDispatcher progressDispatcher =\n+        progressDispatcherFactory.create(\n+            \"launching base image layer pullers\", baseImage.getLayers().size())) {\n+      for (Layer layer : baseImage.getLayers()) {\n+        DescriptorDigest digest = layer.getBlobDescriptor().getDigest();\n+        Future<PreparedLayer> preparedLayer = preparedLayersCache.get(digest);\n+\n+        if (preparedLayer != null) {\n+          progressDispatcher.dispatchProgress(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwMzIwMw=="}, "originalCommit": {"oid": "eb953516b271cd37a637601ee251f7041b8687a5"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4923, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}