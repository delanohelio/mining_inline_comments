{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NjQxMzIx", "number": 2700, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNDozMjoxNFrOEZEk-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMToyNlrOEaojWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzI0ODU5OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNDozMjoxNFrOHBrUhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMjoyMDoyMVrOHCorlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyMDM5MQ==", "bodyText": "are we missing a word here?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471520391", "createdAt": "2020-08-17T14:32:14Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyNTcxNg==", "bodyText": "lol, yes oops", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472525716", "createdAt": "2020-08-18T22:20:21Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyMDM5MQ=="}, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzI5NDEwOnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNDo0Mjo0NlrOHBrwRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMjoyMDoxM1rOHCorWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyNzQ5NA==", "bodyText": "would it be possible to put this if-else logic in a separate method? Might help reduce nesting", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471527494", "createdAt": "2020-08-17T14:42:46Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply\n+                            // TODO: includes to directories\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                  .map(\n+                      path -> {\n+                        Path relative = src.relativize(path);\n+                        if (Files.isDirectory(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getDirectoryPermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else if (Files.isRegularFile(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getFilePermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else {\n+                          throw new UnsupportedOperationException(\n+                              \"Cannot create FileLayers from non-file, non-directory: \"\n+                                  + path.toString());\n+                        }\n+                      })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyNTY1Ng==", "bodyText": "I cleaned it up a little.", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472525656", "createdAt": "2020-08-18T22:20:13Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply\n+                            // TODO: includes to directories\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                  .map(\n+                      path -> {\n+                        Path relative = src.relativize(path);\n+                        if (Files.isDirectory(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getDirectoryPermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else if (Files.isRegularFile(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getFilePermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else {\n+                          throw new UnsupportedOperationException(\n+                              \"Cannot create FileLayers from non-file, non-directory: \"\n+                                  + path.toString());\n+                        }\n+                      })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyNzQ5NA=="}, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzUwMzQ4OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNTozMTozM1rOHBtwOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMjoyNToxNFrOHCoyhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU2MDI1MQ==", "bodyText": "could you elaborate more on this or provide an example?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471560251", "createdAt": "2020-08-17T15:31:33Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyNzQ5NQ==", "bodyText": "hrmm.. yeah lemme go update this comment", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472527495", "createdAt": "2020-08-18T22:25:14Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU2MDI1MQ=="}, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzczNTE1OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjoyOTowOFrOHBv-sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjoyOTowOFrOHBv-sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU5NjcyMQ==", "bodyText": "Nit: I think this casting (Predicate<Path>) is unnecessary (unless for documentation purposes).\nI see excludes always takes precedence. Just my personal preference in style, but how about this?\n                  .filter(path -> excludes.stream().noneMatch(exclude -> exclude.matches(path)))\n                  .filter(\n                      path ->\n                          // if there are no includes directives, include everything\n                          includes.isEmpty()\n                              // TODO: for directories that fail to match the \"include\" directive on\n                              // TODO: files, populate the directories somehow or just never apply\n                              // TODO: includes to directories\n                              // if there are includes directives, only include those specified\n                              || includes.stream().anyMatch(include -> include.matches(path)))", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471596721", "createdAt": "2020-08-17T16:29:08Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODAzNDEwOnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNzoyODozNFrOHBzC_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMjoxNzoyM1rOHComnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0Njk3NQ==", "bodyText": "Just do dest = dest.resolve(src.getFileName()) and use dest below?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471646975", "createdAt": "2020-08-17T17:28:34Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxNDYwMQ==", "bodyText": "I would like to limit how much I change dest, rather not it be a changed var. (I should use final, but not google style)", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472514601", "createdAt": "2020-08-18T21:53:02Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0Njk3NQ=="}, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyNDQ0Nw==", "bodyText": "I think I'll just use a ?: for this?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472524447", "createdAt": "2020-08-18T22:17:23Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0Njk3NQ=="}, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODA4MTY3OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNzo0MTo0MlrOHBzhAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNzo0MTo0MlrOHBzhAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NDY1Nw==", "bodyText": "! ... isEmpty()?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471654657", "createdAt": "2020-08-17T17:41:42Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODA5MjUyOnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNzo0NDo1N1rOHBznYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTo1NDo1OFrOHCoDdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NjI5MA==", "bodyText": "Maybe this part can be factored out as toPathMatchers(List<String> globPatterns) (or globPatternsToPathMatchers()) and reused?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471656290", "createdAt": "2020-08-17T17:44:57Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxNTQ0Ng==", "bodyText": "yeah, also wondering if there's a way to combine path matchers like spring has for https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/PathMatcher.html#combine-java.lang.String-java.lang.String-", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472515446", "createdAt": "2020-08-18T21:54:58Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NjI5MA=="}, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODEwNDc3OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNzo0ODowOVrOHBzuZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMzowOVrOHEL73A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1ODA4Ng==", "bodyText": "Worth thinking about allowing to add an empty layer. But I think Jib will simply drop empty layers anyway, if I'm not mistaken.", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471658086", "createdAt": "2020-08-17T17:48:09Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply\n+                            // TODO: includes to directories\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                  .map(\n+                      path -> {\n+                        Path relative = src.relativize(path);\n+                        if (Files.isDirectory(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getDirectoryPermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else if (Files.isRegularFile(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getFilePermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else {\n+                          throw new UnsupportedOperationException(\n+                              \"Cannot create FileLayers from non-file, non-directory: \"\n+                                  + path.toString());\n+                        }\n+                      })\n+                  .forEach(layerBuiler::addEntry);\n+            }\n+          } else { // other\n+            throw new UnsupportedOperationException(\n+                \"Cannot create FileLayers from non-file, non-directory: \" + src.toString());\n+          }\n+          copySpec.getProperties().ifPresent(ignored -> filePropertiesStack.pop());\n+        }\n+        fileLayer.getProperties().ifPresent(ignored -> filePropertiesStack.pop());\n+        layers.add(layerBuiler.build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyOTU5Mw==", "bodyText": "added todo, and bug in tracker bug", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r472529593", "createdAt": "2020-08-18T22:30:59Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply\n+                            // TODO: includes to directories\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                  .map(\n+                      path -> {\n+                        Path relative = src.relativize(path);\n+                        if (Files.isDirectory(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getDirectoryPermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else if (Files.isRegularFile(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getFilePermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else {\n+                          throw new UnsupportedOperationException(\n+                              \"Cannot create FileLayers from non-file, non-directory: \"\n+                                  + path.toString());\n+                        }\n+                      })\n+                  .forEach(layerBuiler::addEntry);\n+            }\n+          } else { // other\n+            throw new UnsupportedOperationException(\n+                \"Cannot create FileLayers from non-file, non-directory: \" + src.toString());\n+          }\n+          copySpec.getProperties().ifPresent(ignored -> filePropertiesStack.pop());\n+        }\n+        fileLayer.getProperties().ifPresent(ignored -> filePropertiesStack.pop());\n+        layers.add(layerBuiler.build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1ODA4Ng=="}, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MTkwMA==", "bodyText": "Oh interesting, I didn't know empty layers were possible", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474151900", "createdAt": "2020-08-20T17:23:09Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply\n+                            // TODO: includes to directories\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                  .map(\n+                      path -> {\n+                        Path relative = src.relativize(path);\n+                        if (Files.isDirectory(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getDirectoryPermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else if (Files.isRegularFile(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getFilePermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else {\n+                          throw new UnsupportedOperationException(\n+                              \"Cannot create FileLayers from non-file, non-directory: \"\n+                                  + path.toString());\n+                        }\n+                      })\n+                  .forEach(layerBuiler::addEntry);\n+            }\n+          } else { // other\n+            throw new UnsupportedOperationException(\n+                \"Cannot create FileLayers from non-file, non-directory: \" + src.toString());\n+          }\n+          copySpec.getProperties().ifPresent(ignored -> filePropertiesStack.pop());\n+        }\n+        fileLayer.getProperties().ifPresent(ignored -> filePropertiesStack.pop());\n+        layers.add(layerBuiler.build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1ODA4Ng=="}, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzQ3MzA0OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjo0MTo1OFrOHEKVaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMTo1MFrOHEL4fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEyNTY3Mg==", "bodyText": "Does calling assertEquals not log the actual vs expected value? Maybe Assert.assertThat(ImmutableSet.copyOf(layer.getEntries)).containsExactly(expectedEntry1, expectedEntry2) could help.", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474125672", "createdAt": "2020-08-20T16:41:58Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+      throws IOException {\n+    Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n+    List<LayerObject> layers =\n+        Layers.toLayers(\n+            layersSpecYaml.getParent(),\n+            new ObjectMapper(new YAMLFactory())\n+                .readValue(\n+                    Files.newBufferedReader(layersSpecYaml, Charsets.UTF_8), LayersSpec.class));\n+\n+    Assert.assertEquals(expectedLayerCount, layers.size());\n+    List<FileEntriesLayer> fileEntriesLayers = new ArrayList<>(expectedLayerCount);\n+    for (LayerObject layerObject : layers) {\n+      MatcherAssert.assertThat(layerObject, CoreMatchers.instanceOf(FileEntriesLayer.class));\n+      fileEntriesLayers.add((FileEntriesLayer) layerObject);\n+    }\n+    return fileEntriesLayers;\n+  }\n+\n+  private Path getLayersTestRoot(String testName) throws URISyntaxException {\n+    return Paths.get(Resources.getResource(LAYERS_TEST_RESOURCE_DIR + testName).toURI());\n+  }\n+\n+  @Test\n+  public void testToLayers_properties() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"propertiesTest\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 4);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"level 0 passthrough\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"700\", 0, \"0:0\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"000\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(1),\n+        \"level 1 overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"711\", 1000, \"1:1\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"111\", 1000, \"1:1\")));\n+\n+    checkLayer(\n+        layers.get(2),\n+        \"level 2 overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"722\", 2000, \"2:2\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"222\", 2000, \"2:2\")));\n+\n+    checkLayer(\n+        layers.get(3),\n+        \"partial overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"711\", 2000, \"0:2\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"111\", 2000, \"0:2\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_includeExcludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"includesExcludesTest\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 5);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"includes and excludes\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project/include.me\", \"/target/ie/include.me\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(1),\n+        \"includes only\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project/include.me\", \"/target/io/include.me\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(2),\n+        \"excludes only\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/excludedDir\", \"/target/eo/excludedDir\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(3),\n+        \"excludes only shortcut\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/excludedDir\", \"/target/eo/excludedDir\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(4),\n+        \"excludes only wrong\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(\n+                testRoot,\n+                \"project/excludedDir/exclude.me\",\n+                \"/target/eo/excludedDir/exclude.me\",\n+                \"644\",\n+                0,\n+                \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_file() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/default\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 1);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"default\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"toFile.txt\", \"/target/toFile.txt\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"toDir.txt\", \"/target/dir/toDir.txt\", \"644\", 0, \"0:0\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_fileWithIncludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/failWithIncludes\");\n+    try {\n+      parseLayers(testRoot, 0);\n+      Assert.fail();\n+    } catch (UnsupportedOperationException uoe) {\n+      Assert.assertEquals(\n+          \"Cannot apply includes/excludes on single file copy directives.\", uoe.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testToLayers_fileWithExcludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/failWithExcludes\");\n+    try {\n+      parseLayers(testRoot, 0);\n+      Assert.fail();\n+    } catch (UnsupportedOperationException uoe) {\n+      Assert.assertEquals(\n+          \"Cannot apply includes/excludes on single file copy directives.\", uoe.getMessage());\n+    }\n+  }\n+\n+  private static FileEntry newEntry(\n+      Path testRoot,\n+      String src,\n+      String dest,\n+      String octalPermissions,\n+      int millis,\n+      String ownership) {\n+    return new FileEntry(\n+        testRoot.resolve(src),\n+        AbsoluteUnixPath.get(dest),\n+        FilePermissions.fromOctalString(octalPermissions),\n+        Instant.ofEpochMilli(millis),\n+        ownership);\n+  }\n+\n+  private static void checkLayer(\n+      FileEntriesLayer layer, String expectedName, Set<FileEntry> expectedLayerEntries) {\n+    Assert.assertEquals(expectedName, layer.getName());\n+\n+    try {\n+      Assert.assertEquals(expectedLayerEntries, ImmutableSet.copyOf(layer.getEntries()));\n+    } catch (AssertionError ae) {\n+      System.out.println(\"ACTUAL\");\n+      layer\n+          .getEntries()\n+          .forEach(\n+              entry -> {\n+                System.out.println(\"src: \" + entry.getSourceFile());\n+                System.out.println(\"dest: \" + entry.getExtractionPath());\n+                System.out.println(\"permission: \" + entry.getPermissions().toOctalString());\n+                System.out.println(\"time: \" + entry.getModificationTime());\n+                System.out.println(\"ownership: \" + entry.getOwnership());\n+              });\n+      System.out.println(\"EXCPECTED\");\n+      expectedLayerEntries.forEach(\n+          entry -> {\n+            System.out.println(\"src: \" + entry.getSourceFile());\n+            System.out.println(\"dest: \" + entry.getExtractionPath());\n+            System.out.println(\"permission: \" + entry.getPermissions().toOctalString());\n+            System.out.println(\"time: \" + entry.getModificationTime());\n+            System.out.println(\"ownership: \" + entry.getOwnership());\n+          });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0MDAyMw==", "bodyText": "Yeah, that's a good point. Except that this object doest have a toString method. So instead it just prints something like FileEntry@577bcf5.\nWe could go add a toString method to it, but it's part of the build plan, and I'd rather not change it for a test at the moment. Although an argument can probably be made for doing it.", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474140023", "createdAt": "2020-08-20T17:01:09Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+      throws IOException {\n+    Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n+    List<LayerObject> layers =\n+        Layers.toLayers(\n+            layersSpecYaml.getParent(),\n+            new ObjectMapper(new YAMLFactory())\n+                .readValue(\n+                    Files.newBufferedReader(layersSpecYaml, Charsets.UTF_8), LayersSpec.class));\n+\n+    Assert.assertEquals(expectedLayerCount, layers.size());\n+    List<FileEntriesLayer> fileEntriesLayers = new ArrayList<>(expectedLayerCount);\n+    for (LayerObject layerObject : layers) {\n+      MatcherAssert.assertThat(layerObject, CoreMatchers.instanceOf(FileEntriesLayer.class));\n+      fileEntriesLayers.add((FileEntriesLayer) layerObject);\n+    }\n+    return fileEntriesLayers;\n+  }\n+\n+  private Path getLayersTestRoot(String testName) throws URISyntaxException {\n+    return Paths.get(Resources.getResource(LAYERS_TEST_RESOURCE_DIR + testName).toURI());\n+  }\n+\n+  @Test\n+  public void testToLayers_properties() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"propertiesTest\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 4);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"level 0 passthrough\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"700\", 0, \"0:0\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"000\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(1),\n+        \"level 1 overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"711\", 1000, \"1:1\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"111\", 1000, \"1:1\")));\n+\n+    checkLayer(\n+        layers.get(2),\n+        \"level 2 overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"722\", 2000, \"2:2\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"222\", 2000, \"2:2\")));\n+\n+    checkLayer(\n+        layers.get(3),\n+        \"partial overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"711\", 2000, \"0:2\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"111\", 2000, \"0:2\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_includeExcludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"includesExcludesTest\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 5);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"includes and excludes\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project/include.me\", \"/target/ie/include.me\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(1),\n+        \"includes only\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project/include.me\", \"/target/io/include.me\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(2),\n+        \"excludes only\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/excludedDir\", \"/target/eo/excludedDir\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(3),\n+        \"excludes only shortcut\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/excludedDir\", \"/target/eo/excludedDir\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(4),\n+        \"excludes only wrong\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(\n+                testRoot,\n+                \"project/excludedDir/exclude.me\",\n+                \"/target/eo/excludedDir/exclude.me\",\n+                \"644\",\n+                0,\n+                \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_file() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/default\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 1);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"default\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"toFile.txt\", \"/target/toFile.txt\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"toDir.txt\", \"/target/dir/toDir.txt\", \"644\", 0, \"0:0\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_fileWithIncludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/failWithIncludes\");\n+    try {\n+      parseLayers(testRoot, 0);\n+      Assert.fail();\n+    } catch (UnsupportedOperationException uoe) {\n+      Assert.assertEquals(\n+          \"Cannot apply includes/excludes on single file copy directives.\", uoe.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testToLayers_fileWithExcludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/failWithExcludes\");\n+    try {\n+      parseLayers(testRoot, 0);\n+      Assert.fail();\n+    } catch (UnsupportedOperationException uoe) {\n+      Assert.assertEquals(\n+          \"Cannot apply includes/excludes on single file copy directives.\", uoe.getMessage());\n+    }\n+  }\n+\n+  private static FileEntry newEntry(\n+      Path testRoot,\n+      String src,\n+      String dest,\n+      String octalPermissions,\n+      int millis,\n+      String ownership) {\n+    return new FileEntry(\n+        testRoot.resolve(src),\n+        AbsoluteUnixPath.get(dest),\n+        FilePermissions.fromOctalString(octalPermissions),\n+        Instant.ofEpochMilli(millis),\n+        ownership);\n+  }\n+\n+  private static void checkLayer(\n+      FileEntriesLayer layer, String expectedName, Set<FileEntry> expectedLayerEntries) {\n+    Assert.assertEquals(expectedName, layer.getName());\n+\n+    try {\n+      Assert.assertEquals(expectedLayerEntries, ImmutableSet.copyOf(layer.getEntries()));\n+    } catch (AssertionError ae) {\n+      System.out.println(\"ACTUAL\");\n+      layer\n+          .getEntries()\n+          .forEach(\n+              entry -> {\n+                System.out.println(\"src: \" + entry.getSourceFile());\n+                System.out.println(\"dest: \" + entry.getExtractionPath());\n+                System.out.println(\"permission: \" + entry.getPermissions().toOctalString());\n+                System.out.println(\"time: \" + entry.getModificationTime());\n+                System.out.println(\"ownership: \" + entry.getOwnership());\n+              });\n+      System.out.println(\"EXCPECTED\");\n+      expectedLayerEntries.forEach(\n+          entry -> {\n+            System.out.println(\"src: \" + entry.getSourceFile());\n+            System.out.println(\"dest: \" + entry.getExtractionPath());\n+            System.out.println(\"permission: \" + entry.getPermissions().toOctalString());\n+            System.out.println(\"time: \" + entry.getModificationTime());\n+            System.out.println(\"ownership: \" + entry.getOwnership());\n+          });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEyNTY3Mg=="}, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MTAzNg==", "bodyText": "Right. Yeah that's a valid point. It's worth adding (to avoid catching and throwing the same exception) but it can also be done in a different PR since this one is already pretty big:)", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474151036", "createdAt": "2020-08-20T17:21:50Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+      throws IOException {\n+    Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n+    List<LayerObject> layers =\n+        Layers.toLayers(\n+            layersSpecYaml.getParent(),\n+            new ObjectMapper(new YAMLFactory())\n+                .readValue(\n+                    Files.newBufferedReader(layersSpecYaml, Charsets.UTF_8), LayersSpec.class));\n+\n+    Assert.assertEquals(expectedLayerCount, layers.size());\n+    List<FileEntriesLayer> fileEntriesLayers = new ArrayList<>(expectedLayerCount);\n+    for (LayerObject layerObject : layers) {\n+      MatcherAssert.assertThat(layerObject, CoreMatchers.instanceOf(FileEntriesLayer.class));\n+      fileEntriesLayers.add((FileEntriesLayer) layerObject);\n+    }\n+    return fileEntriesLayers;\n+  }\n+\n+  private Path getLayersTestRoot(String testName) throws URISyntaxException {\n+    return Paths.get(Resources.getResource(LAYERS_TEST_RESOURCE_DIR + testName).toURI());\n+  }\n+\n+  @Test\n+  public void testToLayers_properties() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"propertiesTest\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 4);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"level 0 passthrough\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"700\", 0, \"0:0\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"000\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(1),\n+        \"level 1 overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"711\", 1000, \"1:1\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"111\", 1000, \"1:1\")));\n+\n+    checkLayer(\n+        layers.get(2),\n+        \"level 2 overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"722\", 2000, \"2:2\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"222\", 2000, \"2:2\")));\n+\n+    checkLayer(\n+        layers.get(3),\n+        \"partial overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"711\", 2000, \"0:2\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"111\", 2000, \"0:2\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_includeExcludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"includesExcludesTest\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 5);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"includes and excludes\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project/include.me\", \"/target/ie/include.me\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(1),\n+        \"includes only\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project/include.me\", \"/target/io/include.me\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(2),\n+        \"excludes only\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/excludedDir\", \"/target/eo/excludedDir\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(3),\n+        \"excludes only shortcut\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/excludedDir\", \"/target/eo/excludedDir\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(4),\n+        \"excludes only wrong\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(\n+                testRoot,\n+                \"project/excludedDir/exclude.me\",\n+                \"/target/eo/excludedDir/exclude.me\",\n+                \"644\",\n+                0,\n+                \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_file() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/default\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 1);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"default\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"toFile.txt\", \"/target/toFile.txt\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"toDir.txt\", \"/target/dir/toDir.txt\", \"644\", 0, \"0:0\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_fileWithIncludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/failWithIncludes\");\n+    try {\n+      parseLayers(testRoot, 0);\n+      Assert.fail();\n+    } catch (UnsupportedOperationException uoe) {\n+      Assert.assertEquals(\n+          \"Cannot apply includes/excludes on single file copy directives.\", uoe.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testToLayers_fileWithExcludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/failWithExcludes\");\n+    try {\n+      parseLayers(testRoot, 0);\n+      Assert.fail();\n+    } catch (UnsupportedOperationException uoe) {\n+      Assert.assertEquals(\n+          \"Cannot apply includes/excludes on single file copy directives.\", uoe.getMessage());\n+    }\n+  }\n+\n+  private static FileEntry newEntry(\n+      Path testRoot,\n+      String src,\n+      String dest,\n+      String octalPermissions,\n+      int millis,\n+      String ownership) {\n+    return new FileEntry(\n+        testRoot.resolve(src),\n+        AbsoluteUnixPath.get(dest),\n+        FilePermissions.fromOctalString(octalPermissions),\n+        Instant.ofEpochMilli(millis),\n+        ownership);\n+  }\n+\n+  private static void checkLayer(\n+      FileEntriesLayer layer, String expectedName, Set<FileEntry> expectedLayerEntries) {\n+    Assert.assertEquals(expectedName, layer.getName());\n+\n+    try {\n+      Assert.assertEquals(expectedLayerEntries, ImmutableSet.copyOf(layer.getEntries()));\n+    } catch (AssertionError ae) {\n+      System.out.println(\"ACTUAL\");\n+      layer\n+          .getEntries()\n+          .forEach(\n+              entry -> {\n+                System.out.println(\"src: \" + entry.getSourceFile());\n+                System.out.println(\"dest: \" + entry.getExtractionPath());\n+                System.out.println(\"permission: \" + entry.getPermissions().toOctalString());\n+                System.out.println(\"time: \" + entry.getModificationTime());\n+                System.out.println(\"ownership: \" + entry.getOwnership());\n+              });\n+      System.out.println(\"EXCPECTED\");\n+      expectedLayerEntries.forEach(\n+          entry -> {\n+            System.out.println(\"src: \" + entry.getSourceFile());\n+            System.out.println(\"dest: \" + entry.getExtractionPath());\n+            System.out.println(\"permission: \" + entry.getPermissions().toOctalString());\n+            System.out.println(\"time: \" + entry.getModificationTime());\n+            System.out.println(\"ownership: \" + entry.getOwnership());\n+          });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEyNTY3Mg=="}, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzU0NTQ2OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjo1Njo1MFrOHELDYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMjowNzozOFrOHEZHPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzNzQ0Mw==", "bodyText": "For my understanding, this method will be expanded to support other layers in addition to FileLayer in the future?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474137443", "createdAt": "2020-08-20T16:56:50Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to convert between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0MTEyMQ==", "bodyText": "Correct, but I'm not sure what needs to be updated here?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474141121", "createdAt": "2020-08-20T17:03:14Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to convert between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzNzQ0Mw=="}, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwNjI5NQ==", "bodyText": "Nice, might be worth adding a line to the PR summary or a TODO at beginning of the method that mentions that the change is for FileLayer.", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474206295", "createdAt": "2020-08-20T19:02:49Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to convert between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzNzQ0Mw=="}, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM2NzgwNw==", "bodyText": "Added to PR description", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474367807", "createdAt": "2020-08-21T02:07:38Z", "author": {"login": "loosebazooka"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to convert between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzNzQ0Mw=="}, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzYyNzY1OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMToxM1rOHEL3Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMToxM1rOHEL3Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MDY1OA==", "bodyText": "private?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474150658", "createdAt": "2020-08-20T17:21:13Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzYyODA4OnYy", "diffSide": "RIGHT", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMToyMVrOHEL3Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMToyMVrOHEL3Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MDczMA==", "bodyText": "private static?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474150730", "createdAt": "2020-08-20T17:21:21Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzYyODQzOnYy", "diffSide": "RIGHT", "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMToyNlrOHEL3fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMToyNlrOHEL3fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MDc4Mg==", "bodyText": "static?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474150782", "createdAt": "2020-08-20T17:21:26Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+      throws IOException {\n+    Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n+    List<LayerObject> layers =\n+        Layers.toLayers(\n+            layersSpecYaml.getParent(),\n+            new ObjectMapper(new YAMLFactory())\n+                .readValue(\n+                    Files.newBufferedReader(layersSpecYaml, Charsets.UTF_8), LayersSpec.class));\n+\n+    Assert.assertEquals(expectedLayerCount, layers.size());\n+    List<FileEntriesLayer> fileEntriesLayers = new ArrayList<>(expectedLayerCount);\n+    for (LayerObject layerObject : layers) {\n+      MatcherAssert.assertThat(layerObject, CoreMatchers.instanceOf(FileEntriesLayer.class));\n+      fileEntriesLayers.add((FileEntriesLayer) layerObject);\n+    }\n+    return fileEntriesLayers;\n+  }\n+\n+  private Path getLayersTestRoot(String testName) throws URISyntaxException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 121, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}