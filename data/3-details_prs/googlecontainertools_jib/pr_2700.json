{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NjQxMzIx", "number": 2700, "title": "Layers creator classes", "bodyText": "There are still some quirks to layer creation that we will have\nto work out\n\nincludes on file patterns can end up \"excluding\" directories\nwhich will have to be readded, or we can ignore includes\ndirectives on directories and end up with empty directories\neverywhere\ndirectories between a target and root will be configured to\nhave the default properties of ReproducibleLayerBuilder rather\nthat what is configured by the user. This can be dealt with\nby populating directories from root.\nonly handles FileEntriesLayers types\n\npart of #2570", "createdAt": "2020-08-13T21:25:20Z", "url": "https://github.com/GoogleContainerTools/jib/pull/2700", "merged": true, "mergeCommit": {"oid": "cb83cc0a045b22f091accf8e825661c5b47a08e6"}, "closed": true, "closedAt": "2020-08-24T20:28:45Z", "author": {"login": "loosebazooka"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-4AbIAH2gAyNDY3NjQxMzIxOjVkZTZkYTVjOWE5YmQwMzFmNzZjYWI0Zjc4ZmE4MmJkMjAxMGZiN2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCH539AFqTQ3Mzc5OTcyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "author": {"user": {"login": "loosebazooka", "name": "Appu"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "committedDate": "2020-08-14T17:24:32Z", "message": "Layers creator classes\n\nThere are still some quirks to layer creation that we will have\nto work out\n- includes on file patterns can end up \"excluding\" directories\n  which will have to be readded, or we can ignore includes\n  directives on directories and end up with empty directories\n  everywhere\n- directories between a target and root will be configured to\n  have the default properties of ReproducibleLayerBuilder rather\n  that what is configured by the user. This can be dealt with\n  by populating directories from root."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "49032ad07ff7459d78628d98c71f8a84779d194d", "author": {"user": {"login": "loosebazooka", "name": "Appu"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/49032ad07ff7459d78628d98c71f8a84779d194d", "committedDate": "2020-08-13T21:24:46Z", "message": "Layers creator classes\n\nThere are still some quirks to layer creation that we will have\nto work out\n- includes on file patterns can end up \"excluding\" directories\n  which will have to be readded, or we can ignore includes\n  directives on directories and end up with empty directories\n  everywhere\n- directories between a target and root will be configured to\n  have the default properties of ReproducibleLayerBuilder rather\n  that what is configured by the user. This can be dealt with\n  by populating directories from root."}, "afterCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "author": {"user": {"login": "loosebazooka", "name": "Appu"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a", "committedDate": "2020-08-14T17:24:32Z", "message": "Layers creator classes\n\nThere are still some quirks to layer creation that we will have\nto work out\n- includes on file patterns can end up \"excluding\" directories\n  which will have to be readded, or we can ignore includes\n  directives on directories and end up with empty directories\n  everywhere\n- directories between a target and root will be configured to\n  have the default properties of ReproducibleLayerBuilder rather\n  that what is configured by the user. This can be dealt with\n  by populating directories from root."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NTE3NjMw", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#pullrequestreview-468517630", "createdAt": "2020-08-17T14:32:13Z", "commit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNDozMjoxNFrOHBrUhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNTozMTozM1rOHBtwOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyMDM5MQ==", "bodyText": "are we missing a word here?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471520391", "createdAt": "2020-08-17T14:32:14Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyNzQ5NA==", "bodyText": "would it be possible to put this if-else logic in a separate method? Might help reduce nesting", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471527494", "createdAt": "2020-08-17T14:42:46Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply\n+                            // TODO: includes to directories\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                  .map(\n+                      path -> {\n+                        Path relative = src.relativize(path);\n+                        if (Files.isDirectory(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getDirectoryPermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else if (Files.isRegularFile(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getFilePermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else {\n+                          throw new UnsupportedOperationException(\n+                              \"Cannot create FileLayers from non-file, non-directory: \"\n+                                  + path.toString());\n+                        }\n+                      })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU2MDI1MQ==", "bodyText": "could you elaborate more on this or provide an example?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471560251", "createdAt": "2020-08-17T15:31:33Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NjE2NDcw", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#pullrequestreview-468616470", "createdAt": "2020-08-17T16:29:08Z", "commit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjoyOTowOFrOHBv-sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNzo0ODowOVrOHBzuZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU5NjcyMQ==", "bodyText": "Nit: I think this casting (Predicate<Path>) is unnecessary (unless for documentation purposes).\nI see excludes always takes precedence. Just my personal preference in style, but how about this?\n                  .filter(path -> excludes.stream().noneMatch(exclude -> exclude.matches(path)))\n                  .filter(\n                      path ->\n                          // if there are no includes directives, include everything\n                          includes.isEmpty()\n                              // TODO: for directories that fail to match the \"include\" directive on\n                              // TODO: files, populate the directories somehow or just never apply\n                              // TODO: includes to directories\n                              // if there are includes directives, only include those specified\n                              || includes.stream().anyMatch(include -> include.matches(path)))", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471596721", "createdAt": "2020-08-17T16:29:08Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0Njk3NQ==", "bodyText": "Just do dest = dest.resolve(src.getFileName()) and use dest below?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471646975", "createdAt": "2020-08-17T17:28:34Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NDY1Nw==", "bodyText": "! ... isEmpty()?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471654657", "createdAt": "2020-08-17T17:41:42Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NjI5MA==", "bodyText": "Maybe this part can be factored out as toPathMatchers(List<String> globPatterns) (or globPatternsToPathMatchers()) and reused?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471656290", "createdAt": "2020-08-17T17:44:57Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1ODA4Ng==", "bodyText": "Worth thinking about allowing to add an empty layer. But I think Jib will simply drop empty layers anyway, if I'm not mistaken.", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r471658086", "createdAt": "2020-08-17T17:48:09Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Predicate;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {\n+    List<LayerObject> layers = new ArrayList<>();\n+\n+    FilePropertiesStack filePropertiesStack = new FilePropertiesStack();\n+    // base properties\n+    layersSpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+    for (LayerSpec entry : layersSpec.getEntries()) {\n+      // each loop is a new layer\n+      if (entry instanceof FileLayerSpec) {\n+        FileEntriesLayer.Builder layerBuiler = FileEntriesLayer.builder();\n+\n+        FileLayerSpec fileLayer = (FileLayerSpec) entry;\n+        layerBuiler.setName(fileLayer.getName());\n+        // layer properties\n+        fileLayer.getProperties().ifPresent(filePropertiesStack::push);\n+        for (CopySpec copySpec : ((FileLayerSpec) entry).getFiles()) {\n+          // copy spec properties\n+          copySpec.getProperties().ifPresent(filePropertiesStack::push);\n+\n+          // relativize all paths to the buildRoot location\n+          Path rawSrc = copySpec.getSrc();\n+          Path src = rawSrc.isAbsolute() ? rawSrc : buildRoot.resolve(rawSrc);\n+          AbsoluteUnixPath dest = copySpec.getDest();\n+\n+          if (Files.isRegularFile(src)) { // regular file\n+            if (copySpec.getExcludes().size() > 0 || copySpec.getIncludes().size() > 0) {\n+              throw new UnsupportedOperationException(\n+                  \"Cannot apply includes/excludes on single file copy directives.\");\n+            }\n+            AbsoluteUnixPath target = dest;\n+            if (copySpec.isDestEndsWithSlash()) {\n+              target = copySpec.getDest().resolve(src.getFileName());\n+            }\n+            layerBuiler.addEntry(\n+                src,\n+                target,\n+                filePropertiesStack.getFilePermissions(),\n+                filePropertiesStack.getModificationTime(),\n+                filePropertiesStack.getOwnership());\n+          } else if (Files.isDirectory(src)) { // directory\n+            List<PathMatcher> excludes =\n+                copySpec\n+                    .getExcludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(exclude -> FileSystems.getDefault().getPathMatcher(\"glob:\" + exclude))\n+                    .collect(Collectors.toList());\n+            List<PathMatcher> includes =\n+                copySpec\n+                    .getIncludes()\n+                    .stream()\n+                    .map(\n+                        pattern ->\n+                            pattern.endsWith(\"/\") || pattern.endsWith(\"\\\\\")\n+                                ? pattern + \"**\"\n+                                : pattern)\n+                    .map(include -> FileSystems.getDefault().getPathMatcher(\"glob:\" + include))\n+                    .collect(Collectors.toList());\n+            try (Stream<Path> dirWalk = Files.walk(src)) {\n+              dirWalk\n+                  .filter(\n+                      (Predicate<Path>)\n+                          path -> {\n+                            // filter out against excludes\n+                            for (PathMatcher matcher : excludes) {\n+                              if (matcher.matches(path)) {\n+                                return false;\n+                              }\n+                            }\n+                            // if there are no includes directives, include everything\n+                            if (includes.isEmpty()) {\n+                              return true;\n+                            }\n+                            // TODO: for directories that fail to match the \"include\" directive on\n+                            // TODO: files, populate the directories somehow or just never apply\n+                            // TODO: includes to directories\n+                            // if there are includes directives, only include those specified\n+                            for (PathMatcher matcher : includes) {\n+                              if (matcher.matches(path)) {\n+                                return true;\n+                              }\n+                            }\n+                            return false;\n+                          })\n+                  .map(\n+                      path -> {\n+                        Path relative = src.relativize(path);\n+                        if (Files.isDirectory(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getDirectoryPermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else if (Files.isRegularFile(path)) {\n+                          return new FileEntry(\n+                              path,\n+                              dest.resolve(relative),\n+                              filePropertiesStack.getFilePermissions(),\n+                              filePropertiesStack.getModificationTime(),\n+                              filePropertiesStack.getOwnership());\n+                        } else {\n+                          throw new UnsupportedOperationException(\n+                              \"Cannot create FileLayers from non-file, non-directory: \"\n+                                  + path.toString());\n+                        }\n+                      })\n+                  .forEach(layerBuiler::addEntry);\n+            }\n+          } else { // other\n+            throw new UnsupportedOperationException(\n+                \"Cannot create FileLayers from non-file, non-directory: \" + src.toString());\n+          }\n+          copySpec.getProperties().ifPresent(ignored -> filePropertiesStack.pop());\n+        }\n+        fileLayer.getProperties().ifPresent(ignored -> filePropertiesStack.pop());\n+        layers.add(layerBuiler.build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6da5c9a9bd031f76cab4f78fa82bd2010fb7a"}, "originalPosition": 171}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb000213fac4bfef2adf1670ed2a78f681ed2d90", "author": {"user": {"login": "loosebazooka", "name": "Appu"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/bb000213fac4bfef2adf1670ed2a78f681ed2d90", "committedDate": "2020-08-18T22:29:01Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e", "author": {"user": {"login": "loosebazooka", "name": "Appu"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/f8b873ac5896a801ce8e457fae7c88760e69c23e", "committedDate": "2020-08-18T22:33:11Z", "message": "formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxODAwODg0", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#pullrequestreview-471800884", "createdAt": "2020-08-20T16:41:57Z", "commit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjo0MTo1OFrOHEKVaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjo0MTo1OFrOHEKVaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEyNTY3Mg==", "bodyText": "Does calling assertEquals not log the actual vs expected value? Maybe Assert.assertThat(ImmutableSet.copyOf(layer.getEntries)).containsExactly(expectedEntry1, expectedEntry2) could help.", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474125672", "createdAt": "2020-08-20T16:41:58Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+      throws IOException {\n+    Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n+    List<LayerObject> layers =\n+        Layers.toLayers(\n+            layersSpecYaml.getParent(),\n+            new ObjectMapper(new YAMLFactory())\n+                .readValue(\n+                    Files.newBufferedReader(layersSpecYaml, Charsets.UTF_8), LayersSpec.class));\n+\n+    Assert.assertEquals(expectedLayerCount, layers.size());\n+    List<FileEntriesLayer> fileEntriesLayers = new ArrayList<>(expectedLayerCount);\n+    for (LayerObject layerObject : layers) {\n+      MatcherAssert.assertThat(layerObject, CoreMatchers.instanceOf(FileEntriesLayer.class));\n+      fileEntriesLayers.add((FileEntriesLayer) layerObject);\n+    }\n+    return fileEntriesLayers;\n+  }\n+\n+  private Path getLayersTestRoot(String testName) throws URISyntaxException {\n+    return Paths.get(Resources.getResource(LAYERS_TEST_RESOURCE_DIR + testName).toURI());\n+  }\n+\n+  @Test\n+  public void testToLayers_properties() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"propertiesTest\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 4);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"level 0 passthrough\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"700\", 0, \"0:0\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"000\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(1),\n+        \"level 1 overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"711\", 1000, \"1:1\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"111\", 1000, \"1:1\")));\n+\n+    checkLayer(\n+        layers.get(2),\n+        \"level 2 overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"722\", 2000, \"2:2\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"222\", 2000, \"2:2\")));\n+\n+    checkLayer(\n+        layers.get(3),\n+        \"partial overrides\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"dir\", \"/app\", \"711\", 2000, \"0:2\"),\n+            newEntry(testRoot, \"dir/file.txt\", \"/app/file.txt\", \"111\", 2000, \"0:2\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_includeExcludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"includesExcludesTest\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 5);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"includes and excludes\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project/include.me\", \"/target/ie/include.me\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(1),\n+        \"includes only\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project/include.me\", \"/target/io/include.me\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(2),\n+        \"excludes only\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/excludedDir\", \"/target/eo/excludedDir\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(3),\n+        \"excludes only shortcut\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/excludedDir\", \"/target/eo/excludedDir\", \"755\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+\n+    checkLayer(\n+        layers.get(4),\n+        \"excludes only wrong\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"project\", \"/target/eo\", \"755\", 0, \"0:0\"),\n+            newEntry(\n+                testRoot,\n+                \"project/excludedDir/exclude.me\",\n+                \"/target/eo/excludedDir/exclude.me\",\n+                \"644\",\n+                0,\n+                \"0:0\"),\n+            newEntry(testRoot, \"project/include.me\", \"/target/eo/include.me\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"project/wild.card\", \"/target/eo/wild.card\", \"644\", 0, \"0:0\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_file() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/default\");\n+    List<FileEntriesLayer> layers = parseLayers(testRoot, 1);\n+\n+    checkLayer(\n+        layers.get(0),\n+        \"default\",\n+        ImmutableSet.of(\n+            newEntry(testRoot, \"toFile.txt\", \"/target/toFile.txt\", \"644\", 0, \"0:0\"),\n+            newEntry(testRoot, \"toDir.txt\", \"/target/dir/toDir.txt\", \"644\", 0, \"0:0\")));\n+  }\n+\n+  @Test\n+  public void testToLayers_fileWithIncludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/failWithIncludes\");\n+    try {\n+      parseLayers(testRoot, 0);\n+      Assert.fail();\n+    } catch (UnsupportedOperationException uoe) {\n+      Assert.assertEquals(\n+          \"Cannot apply includes/excludes on single file copy directives.\", uoe.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testToLayers_fileWithExcludes() throws IOException, URISyntaxException {\n+    Path testRoot = getLayersTestRoot(\"fileTest/failWithExcludes\");\n+    try {\n+      parseLayers(testRoot, 0);\n+      Assert.fail();\n+    } catch (UnsupportedOperationException uoe) {\n+      Assert.assertEquals(\n+          \"Cannot apply includes/excludes on single file copy directives.\", uoe.getMessage());\n+    }\n+  }\n+\n+  private static FileEntry newEntry(\n+      Path testRoot,\n+      String src,\n+      String dest,\n+      String octalPermissions,\n+      int millis,\n+      String ownership) {\n+    return new FileEntry(\n+        testRoot.resolve(src),\n+        AbsoluteUnixPath.get(dest),\n+        FilePermissions.fromOctalString(octalPermissions),\n+        Instant.ofEpochMilli(millis),\n+        ownership);\n+  }\n+\n+  private static void checkLayer(\n+      FileEntriesLayer layer, String expectedName, Set<FileEntry> expectedLayerEntries) {\n+    Assert.assertEquals(expectedName, layer.getName());\n+\n+    try {\n+      Assert.assertEquals(expectedLayerEntries, ImmutableSet.copyOf(layer.getEntries()));\n+    } catch (AssertionError ae) {\n+      System.out.println(\"ACTUAL\");\n+      layer\n+          .getEntries()\n+          .forEach(\n+              entry -> {\n+                System.out.println(\"src: \" + entry.getSourceFile());\n+                System.out.println(\"dest: \" + entry.getExtractionPath());\n+                System.out.println(\"permission: \" + entry.getPermissions().toOctalString());\n+                System.out.println(\"time: \" + entry.getModificationTime());\n+                System.out.println(\"ownership: \" + entry.getOwnership());\n+              });\n+      System.out.println(\"EXCPECTED\");\n+      expectedLayerEntries.forEach(\n+          entry -> {\n+            System.out.println(\"src: \" + entry.getSourceFile());\n+            System.out.println(\"dest: \" + entry.getExtractionPath());\n+            System.out.println(\"permission: \" + entry.getPermissions().toOctalString());\n+            System.out.println(\"time: \" + entry.getModificationTime());\n+            System.out.println(\"ownership: \" + entry.getOwnership());\n+          });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 234}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxODExODk5", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#pullrequestreview-471811899", "createdAt": "2020-08-20T16:56:50Z", "commit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjo1Njo1MFrOHELDYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjo1Njo1MFrOHELDYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzNzQ0Mw==", "bodyText": "For my understanding, this method will be expanded to support other layers in addition to FileLayer in the future?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474137443", "createdAt": "2020-08-20T16:56:50Z", "author": {"login": "mpeddada1"}, "path": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/Layers.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/** Class to convert between different layer representations. */\n+class Layers {\n+\n+  /**\n+   * Convert a layer spec to a list of layer objects.\n+   *\n+   * <p>Does not handle missing directories for files added via this method. We can either prefill\n+   * directories here, or allow passing of the file entry information directly to the reproducible\n+   * layer builder\n+   *\n+   * @param buildRoot the directory to resolve relative paths, usually the directory where the build\n+   *     config file is located\n+   * @param layersSpec a layersSpec containing configuration for all layers\n+   * @return a {@link List} of {@link LayerObject} to use as part of a buildplan\n+   * @throws IOException if traversing a directory fails\n+   */\n+  static List<LayerObject> toLayers(Path buildRoot, LayersSpec layersSpec) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxODI5MTY1", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#pullrequestreview-471829165", "createdAt": "2020-08-20T17:21:13Z", "commit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMToxM1rOHEL3Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMToyNlrOHEL3fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MDY1OA==", "bodyText": "private?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474150658", "createdAt": "2020-08-20T17:21:13Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MDczMA==", "bodyText": "private static?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474150730", "createdAt": "2020-08-20T17:21:21Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MDc4Mg==", "bodyText": "static?", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#discussion_r474150782", "createdAt": "2020-08-20T17:21:26Z", "author": {"login": "chanseokoh"}, "path": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/LayersTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.cli.buildfile;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.FileEntry;\n+import com.google.cloud.tools.jib.api.buildplan.FilePermissions;\n+import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/** Tests for {@link Layers}. */\n+public class LayersTest {\n+\n+  public static final String LAYERS_TEST_RESOURCE_DIR = \"buildfiles/layers/\";\n+\n+  public List<FileEntriesLayer> parseLayers(Path testDir, int expectedLayerCount)\n+      throws IOException {\n+    Path layersSpecYaml = testDir.resolve(\"layers.yaml\");\n+    List<LayerObject> layers =\n+        Layers.toLayers(\n+            layersSpecYaml.getParent(),\n+            new ObjectMapper(new YAMLFactory())\n+                .readValue(\n+                    Files.newBufferedReader(layersSpecYaml, Charsets.UTF_8), LayersSpec.class));\n+\n+    Assert.assertEquals(expectedLayerCount, layers.size());\n+    List<FileEntriesLayer> fileEntriesLayers = new ArrayList<>(expectedLayerCount);\n+    for (LayerObject layerObject : layers) {\n+      MatcherAssert.assertThat(layerObject, CoreMatchers.instanceOf(FileEntriesLayer.class));\n+      fileEntriesLayers.add((FileEntriesLayer) layerObject);\n+    }\n+    return fileEntriesLayers;\n+  }\n+\n+  private Path getLayersTestRoot(String testName) throws URISyntaxException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8b873ac5896a801ce8e457fae7c88760e69c23e"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a7135e87529c7d682519d885b3cc052df7b5fda", "author": {"user": {"login": "loosebazooka", "name": "Appu"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/2a7135e87529c7d682519d885b3cc052df7b5fda", "committedDate": "2020-08-21T02:08:18Z", "message": "qualifiers in tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNzk5NzI4", "url": "https://github.com/GoogleContainerTools/jib/pull/2700#pullrequestreview-473799728", "createdAt": "2020-08-24T19:37:38Z", "commit": {"oid": "2a7135e87529c7d682519d885b3cc052df7b5fda"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4953, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}