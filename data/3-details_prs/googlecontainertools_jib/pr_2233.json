{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyODk0NDk4", "number": 2233, "title": "Refresh bearer auth token if expired", "bodyText": "Fixes #691.\nI am not particularly happy with how this is done, but there are two many complicated matters intertwined around auth, so this is it.\nThe basic idea is that, instead of returning a working Authorization, some steps in StepsRunner returns a working RegistryClient.\n\nPullBaseImageStep: returns a working RegistryClient (previously returned a working Authorization) for the base image\nAuthenticatePushStep: returns a working RegistryClient (instead of Authorization likewise) for the target image\n\nRegistryClient is now a mutable instance. Calling configureBasicAuth() will make it send a basic Authorization, while calling doBearerAuth() will send a bearer token Authorization. So, you basically create two RegistryClient instances (one for base and the other for target), and then these are used throughout the build (i.e., in other Steps).\nAnd if the RegistryClient succeeded to doBearerAuth(), it will auth-refresh a token if necessary.", "createdAt": "2020-01-14T23:57:58Z", "url": "https://github.com/GoogleContainerTools/jib/pull/2233", "merged": true, "mergeCommit": {"oid": "5ed864049abc73b2921af89aa3422a318564baa2"}, "closed": true, "closedAt": "2020-01-24T17:28:32Z", "author": {"login": "chanseokoh"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4y56kAH2gAyMzYyODk0NDk4OjllMWQwODczNjQzOWIzYmJiYWVjMTZkMjYyZDFhZWYyY2I0ZDQ3YWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9iHxLAFqTM0ODA5ODA1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9e1d08736439b3bbbaec16d262d1aef2cb4d47aa", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/9e1d08736439b3bbbaec16d262d1aef2cb4d47aa", "committedDate": "2020-01-09T23:53:12Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40aee1ff5739274cbce2fc9b146faaefba86620b", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/40aee1ff5739274cbce2fc9b146faaefba86620b", "committedDate": "2020-01-10T00:07:24Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cd295b9cb38f1917b424e4fc6a46f405504ef2f", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/5cd295b9cb38f1917b424e4fc6a46f405504ef2f", "committedDate": "2020-01-13T18:06:27Z", "message": "refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "632a275554607c9d033b8415db7ba0e4c4ea7ff7", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/632a275554607c9d033b8415db7ba0e4c4ea7ff7", "committedDate": "2020-01-13T18:08:55Z", "message": "comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "423bfffbaf5f5e774618f2f6ec520525081d6b2c", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/423bfffbaf5f5e774618f2f6ec520525081d6b2c", "committedDate": "2020-01-13T21:34:24Z", "message": "Refresh works now"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d934edd594622c228fc799f7804747e2d4b9162b", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/d934edd594622c228fc799f7804747e2d4b9162b", "committedDate": "2020-01-14T22:39:16Z", "message": "wip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c80c30d8e6e1c729031c8a9f3d75909ef46f96b", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/0c80c30d8e6e1c729031c8a9f3d75909ef46f96b", "committedDate": "2020-01-15T18:21:41Z", "message": "clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDExODY3", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#pullrequestreview-343411867", "createdAt": "2020-01-15T17:59:06Z", "commit": {"oid": "d934edd594622c228fc799f7804747e2d4b9162b"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzo1OTowNlrOFeBSuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODoxNjo1M1rOFeBxzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMjc3Nw==", "bodyText": "As evident from calling this method, now this new AuthenticatePushStep is a combination of Retrieve(Target)RegistryCredentialsStep (which is now gone) + old AuthenticatePushStep. You can start authenticating only after you have retrieved a credential, so I think there's no point of doing RetrieveRegistryCredentialsStep in a separate thread. So basically I renamed RetrieveRegistryCredentialsStep --> RegistryCredentialRetriever and am retrieving credentials directly here.\nOther than that, this step is doing the same thing. doBearerAuth(readOnlyAuth=false) internally creates RegistryAuthenticator and calls authenticatePush(). And if RegistryAuthenticator cannot be created, you do basic auth (fromBasicCredentials).", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367022777", "createdAt": "2020-01-15T17:59:06Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/AuthenticatePushStep.java", "diffHunk": "@@ -21,58 +21,53 @@\n import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n import com.google.cloud.tools.jib.builder.TimerEventDispatcher;\n import com.google.cloud.tools.jib.configuration.BuildContext;\n-import com.google.cloud.tools.jib.http.Authorization;\n-import com.google.cloud.tools.jib.registry.RegistryAuthenticator;\n+import com.google.cloud.tools.jib.registry.RegistryClient;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n import java.io.IOException;\n-import java.util.Optional;\n import java.util.concurrent.Callable;\n-import javax.annotation.Nullable;\n \n /**\n  * Authenticates push to a target registry using Docker Token Authentication.\n  *\n  * @see <a\n  *     href=\"https://docs.docker.com/registry/spec/auth/token/\">https://docs.docker.com/registry/spec/auth/token/</a>\n  */\n-class AuthenticatePushStep implements Callable<Optional<Authorization>> {\n+class AuthenticatePushStep implements Callable<RegistryClient> {\n \n   private static final String DESCRIPTION = \"Authenticating push to %s\";\n \n   private final BuildContext buildContext;\n   private final ProgressEventDispatcher.Factory progressEventDispatcherFactory;\n-  @Nullable private final Credential registryCredential;\n \n   AuthenticatePushStep(\n-      BuildContext buildContext,\n-      ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n-      @Nullable Credential registryCredential) {\n+      BuildContext buildContext, ProgressEventDispatcher.Factory progressEventDispatcherFactory) {\n     this.buildContext = buildContext;\n     this.progressEventDispatcherFactory = progressEventDispatcherFactory;\n-    this.registryCredential = registryCredential;\n   }\n \n   @Override\n-  public Optional<Authorization> call() throws IOException, RegistryException {\n+  public RegistryClient call() throws CredentialRetrievalException, IOException, RegistryException {\n     String registry = buildContext.getTargetImageConfiguration().getImageRegistry();\n     try (ProgressEventDispatcher ignored =\n             progressEventDispatcherFactory.create(\"authenticating push to \" + registry, 1);\n         TimerEventDispatcher ignored2 =\n             new TimerEventDispatcher(\n                 buildContext.getEventHandlers(), String.format(DESCRIPTION, registry))) {\n-      Optional<RegistryAuthenticator> registryAuthenticator =\n+      Credential credential =\n+          RegistryCredentialRetriever.getTargetImageCredential(buildContext).orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d934edd594622c228fc799f7804747e2d4b9162b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNTQ1Mw==", "bodyText": "Just restructured this part to make the issue #2220 clear.", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367025453", "createdAt": "2020-01-15T18:05:11Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -101,73 +88,77 @@ public ImageAndAuthorization call()\n     ImageReference imageReference = buildContext.getBaseImageConfiguration().getImage();\n     if (imageReference.isScratch()) {\n       eventHandlers.dispatch(LogEvent.progress(\"Getting scratch base image...\"));\n-      return new ImageAndAuthorization(Image.builder(buildContext.getTargetFormat()).build(), null);\n+      return new ImageAndRegistryClient(\n+          Image.builder(buildContext.getTargetFormat()).build(), null);\n     }\n \n     eventHandlers.dispatch(\n         LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n-    if (buildContext.isOffline() || imageReference.isTagDigest()) {\n+    if (buildContext.isOffline()) {\n       Optional<Image> image = getCachedBaseImage();\n       if (image.isPresent()) {\n-        return new ImageAndAuthorization(image.get(), null);\n+        return new ImageAndRegistryClient(image.get(), null);\n       }\n-      if (buildContext.isOffline()) {\n-        throw new IOException(\n-            \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+      throw new IOException(\n+          \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+\n+    } else if (imageReference.isTagDigest()) {\n+      Optional<Image> image = getCachedBaseImage();\n+      if (image.isPresent()) {\n+        RegistryClient noAuthRegistryClient =\n+            buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n+        // TODO: passing noAuthRegistryClient may be problematic. It may return 401 unauthorized if\n+        // layers have to be downloaded. https://github.com/GoogleContainerTools/jib/issues/2220\n+        return new ImageAndRegistryClient(image.get(), noAuthRegistryClient);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d934edd594622c228fc799f7804747e2d4b9162b"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjgxNg==", "bodyText": "This pattern is bad, but I just can't leave it to do the same meaningless no-auth attempt that is destined to fail. This is part of the issue #2202. This part should be restructured later. But I am not doing it here.", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367026816", "createdAt": "2020-01-15T18:08:18Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -101,73 +88,77 @@ public ImageAndAuthorization call()\n     ImageReference imageReference = buildContext.getBaseImageConfiguration().getImage();\n     if (imageReference.isScratch()) {\n       eventHandlers.dispatch(LogEvent.progress(\"Getting scratch base image...\"));\n-      return new ImageAndAuthorization(Image.builder(buildContext.getTargetFormat()).build(), null);\n+      return new ImageAndRegistryClient(\n+          Image.builder(buildContext.getTargetFormat()).build(), null);\n     }\n \n     eventHandlers.dispatch(\n         LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n-    if (buildContext.isOffline() || imageReference.isTagDigest()) {\n+    if (buildContext.isOffline()) {\n       Optional<Image> image = getCachedBaseImage();\n       if (image.isPresent()) {\n-        return new ImageAndAuthorization(image.get(), null);\n+        return new ImageAndRegistryClient(image.get(), null);\n       }\n-      if (buildContext.isOffline()) {\n-        throw new IOException(\n-            \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+      throw new IOException(\n+          \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+\n+    } else if (imageReference.isTagDigest()) {\n+      Optional<Image> image = getCachedBaseImage();\n+      if (image.isPresent()) {\n+        RegistryClient noAuthRegistryClient =\n+            buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n+        // TODO: passing noAuthRegistryClient may be problematic. It may return 401 unauthorized if\n+        // layers have to be downloaded. https://github.com/GoogleContainerTools/jib/issues/2220\n+        return new ImageAndRegistryClient(image.get(), noAuthRegistryClient);\n       }\n     }\n \n     try (ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"pulling base image manifest\", 2);\n         TimerEventDispatcher ignored1 = new TimerEventDispatcher(eventHandlers, DESCRIPTION)) {\n+\n       // First, try with no credentials.\n+      RegistryClient noAuthRegistryClient =\n+          buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n       try {\n-        return new ImageAndAuthorization(pullBaseImage(null, progressEventDispatcher), null);\n+        return new ImageAndRegistryClient(\n+            pullBaseImage(noAuthRegistryClient, progressEventDispatcher), noAuthRegistryClient);\n \n-      } catch (RegistryUnauthorizedException ignored2) {\n+      } catch (RegistryUnauthorizedException ex) {\n         eventHandlers.dispatch(\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        // If failed, then, retrieve base registry credentials and try with retrieved credentials.\n-        // TODO: Refactor the logic in RetrieveRegistryCredentialsStep out to\n-        // registry.credentials.RegistryCredentialsRetriever.\n         Credential registryCredential =\n-            RetrieveRegistryCredentialsStep.forBaseImage(\n-                    buildContext, progressEventDispatcher.newChildProducer())\n-                .call()\n-                .orElse(null);\n+            RegistryCredentialRetriever.getBaseImageCredential(buildContext).orElse(null);\n \n-        Authorization registryAuthorization =\n-            registryCredential == null || registryCredential.isOAuth2RefreshToken()\n-                ? null\n-                : Authorization.fromBasicCredentials(\n-                    registryCredential.getUsername(), registryCredential.getPassword());\n+        RegistryClient registryClient =\n+            buildContext\n+                .newBaseImageRegistryClientFactory()\n+                .setCredential(registryCredential)\n+                .newRegistryClient();\n \n         try {\n-          return new ImageAndAuthorization(\n-              pullBaseImage(registryAuthorization, progressEventDispatcher), registryAuthorization);\n+          // TODO: refactor the code (https://github.com/GoogleContainerTools/jib/pull/2202)\n+          if (registryCredential == null || registryCredential.isOAuth2RefreshToken()) {\n+            throw ex;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d934edd594622c228fc799f7804747e2d4b9162b"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDQwMQ==", "bodyText": "Just renamed from RetrieveRegistryCredentialsStep (and thus simplied).", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367030401", "createdAt": "2020-01-15T18:16:10Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/RegistryCredentialRetriever.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.builder.steps;\n+\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.configuration.BuildContext;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.event.EventHandlers;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import java.util.Optional;\n+\n+/** Attempts to retrieve registry credentials. */\n+class RegistryCredentialRetriever {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d934edd594622c228fc799f7804747e2d4b9162b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDczMw==", "bodyText": "As mentioned, two steps combined.", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367030733", "createdAt": "2020-01-15T18:16:53Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -149,8 +147,7 @@ public StepsRunner registryPushSteps() {\n     rootProgressDescription = \"building image to registry\";\n     boolean layersRequiredLocally = buildContext.getAlwaysCacheBaseImage();\n \n-    stepsToRun.add(this::retrieveTargetRegistryCredentials);\n-    stepsToRun.add(this::authenticatePush);\n+    stepsToRun.add(this::authenticateBearerPush);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d934edd594622c228fc799f7804747e2d4b9162b"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "912c4b9fe6460e9076e21b25359fa4bf59994579", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/912c4b9fe6460e9076e21b25359fa4bf59994579", "committedDate": "2020-01-16T00:10:11Z", "message": "Add tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "634a04f89331823c8b53360cd0c4cf9168ecaaea", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/634a04f89331823c8b53360cd0c4cf9168ecaaea", "committedDate": "2020-01-16T00:04:03Z", "message": "Add tests"}, "afterCommit": {"oid": "912c4b9fe6460e9076e21b25359fa4bf59994579", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/912c4b9fe6460e9076e21b25359fa4bf59994579", "committedDate": "2020-01-16T00:10:11Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4217f3ef42b2391bca989db446dec39a304e278", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/f4217f3ef42b2391bca989db446dec39a304e278", "committedDate": "2020-01-16T00:12:41Z", "message": "typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjI2Nzcz", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#pullrequestreview-344626773", "createdAt": "2020-01-17T14:48:36Z", "commit": {"oid": "f4217f3ef42b2391bca989db446dec39a304e278"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDo0ODozN1rOFe7QVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNTowNDoxN1rOFe7xrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3MjQzNw==", "bodyText": "Would it make sense to swap the order of these parameters?  eventHandlers is an ancillary object passed in for logging purposes, but it appears to have primary importance.", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367972437", "createdAt": "2020-01-17T14:48:37Z", "author": {"login": "briandealwis"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/RegistryCredentialRetriever.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.builder.steps;\n+\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.configuration.BuildContext;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.event.EventHandlers;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import java.util.Optional;\n+\n+/** Attempts to retrieve registry credentials. */\n+class RegistryCredentialRetriever {\n+\n+  /** Retrieves credentials for the base image. */\n+  static Optional<Credential> getBaseImageCredential(BuildContext buildContext)\n+      throws CredentialRetrievalException {\n+    return retrieve(buildContext.getEventHandlers(), buildContext.getBaseImageConfiguration());\n+  }\n+\n+  /** Retrieves credentials for the target image. */\n+  static Optional<Credential> getTargetImageCredential(BuildContext buildContext)\n+      throws CredentialRetrievalException {\n+    return retrieve(buildContext.getEventHandlers(), buildContext.getTargetImageConfiguration());\n+  }\n+\n+  private static Optional<Credential> retrieve(\n+      EventHandlers eventHandlers, ImageConfiguration imageConfiguration)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4217f3ef42b2391bca989db446dec39a304e278"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3NDU0Nw==", "bodyText": "Since we use @Nullable from jsr305 we could use its @ThreadSafe too?", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367974547", "createdAt": "2020-01-17T14:52:26Z", "author": {"login": "briandealwis"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -35,18 +40,21 @@\n import com.google.cloud.tools.jib.json.JsonTemplate;\n import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n import com.google.common.collect.ImmutableSetMultimap;\n import com.google.common.collect.Multimap;\n import java.io.IOException;\n import java.net.URL;\n import java.util.List;\n import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.Consumer;\n import java.util.stream.Stream;\n import javax.annotation.Nullable;\n \n-/** Interfaces with a registry. */\n+/** Interfaces with a registry. Thread-safe. */\n public class RegistryClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4217f3ef42b2391bca989db446dec39a304e278"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4MDk3NA==", "bodyText": "PlainHttpClient?", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367980974", "createdAt": "2020-01-17T15:04:17Z", "author": {"login": "briandealwis"}, "path": "jib-core/src/test/java/com/google/cloud/tools/jib/registry/HttpOnlyFailoverHttpClient.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import com.google.api.client.http.GenericUrl;\n+import com.google.cloud.tools.jib.http.FailoverHttpClient;\n+import com.google.cloud.tools.jib.http.Request;\n+import com.google.cloud.tools.jib.http.Response;\n+import java.io.IOException;\n+import java.net.URL;\n+\n+/** Forces sending all requests in plain-HTTP protocol. For testing only. */\n+class HttpOnlyFailoverHttpClient extends FailoverHttpClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4217f3ef42b2391bca989db446dec39a304e278"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ee4cdd3779efa3f50e16ff5723203f2ea5a1271", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/4ee4cdd3779efa3f50e16ff5723203f2ea5a1271", "committedDate": "2020-01-17T15:55:38Z", "message": "Swap arguments, rename method, add @ThreadSafe, add test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjY5OTM5", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#pullrequestreview-344669939", "createdAt": "2020-01-17T15:50:58Z", "commit": {"oid": "f4217f3ef42b2391bca989db446dec39a304e278"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNTo1MDo1OVrOFe9P0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNTo1MDo1OVrOFe9P0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwNTA3NA==", "bodyText": "We've never used it, so this will be our first usage. \ud83d\ude05", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368005074", "createdAt": "2020-01-17T15:50:59Z", "author": {"login": "chanseokoh"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -35,18 +40,21 @@\n import com.google.cloud.tools.jib.json.JsonTemplate;\n import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n import com.google.common.collect.ImmutableSetMultimap;\n import com.google.common.collect.Multimap;\n import java.io.IOException;\n import java.net.URL;\n import java.util.List;\n import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.Consumer;\n import java.util.stream.Stream;\n import javax.annotation.Nullable;\n \n-/** Interfaces with a registry. */\n+/** Interfaces with a registry. Thread-safe. */\n public class RegistryClient {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3NDU0Nw=="}, "originalCommit": {"oid": "f4217f3ef42b2391bca989db446dec39a304e278"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35ec93f531770eb9f8698f6773ba218bfd81c63b", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/35ec93f531770eb9f8698f6773ba218bfd81c63b", "committedDate": "2020-01-17T20:33:23Z", "message": "Make it safer, just in case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODQyOTY3", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#pullrequestreview-344842967", "createdAt": "2020-01-17T21:09:49Z", "commit": {"oid": "35ec93f531770eb9f8698f6773ba218bfd81c63b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMTowOTo0OVrOFfFVTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMTowOTo0OVrOFfFVTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzNzU1MQ==", "bodyText": "should readOnly be a fixed value of a registry client? Do we intend to reuse a registry client to do readonly once and then write later?\nPerhaps this can go on the factory?", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368137551", "createdAt": "2020-01-17T21:09:49Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -242,46 +252,113 @@ public static Factory factory(\n   }\n \n   private final EventHandlers eventHandlers;\n-  @Nullable private final Authorization authorization;\n+  @Nullable private final Credential credential;\n   private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n   private final String userAgent;\n   private final FailoverHttpClient httpClient;\n \n+  // mutable\n+  private final AtomicReference<Authorization> authorization = new AtomicReference<>();\n+  private boolean readOnlyBearerAuth;\n+\n   /**\n    * Instantiate with {@link #factory}.\n    *\n    * @param eventHandlers the event handlers used for dispatching log events\n-   * @param authorization the {@link Authorization} to access the registry/repository\n+   * @param credential credential for registry/repository; will not be used unless {@link\n+   *     #configureBasicAuth} or {@link #doBearerAuth} is called\n    * @param registryEndpointRequestProperties properties of registry endpoint requests\n    * @param userAgent {@code User-Agent} header to send with the request\n    * @param httpClient HTTP client\n    */\n   private RegistryClient(\n       EventHandlers eventHandlers,\n-      @Nullable Authorization authorization,\n+      @Nullable Credential credential,\n       RegistryEndpointRequestProperties registryEndpointRequestProperties,\n       String userAgent,\n       FailoverHttpClient httpClient) {\n     this.eventHandlers = eventHandlers;\n-    this.authorization = authorization;\n+    this.credential = credential;\n     this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n     this.userAgent = userAgent;\n     this.httpClient = httpClient;\n   }\n \n+  public void configureBasicAuth() {\n+    Preconditions.checkNotNull(credential);\n+    Preconditions.checkState(!credential.isOAuth2RefreshToken());\n+\n+    authorization.set(\n+        Authorization.fromBasicCredentials(credential.getUsername(), credential.getPassword()));\n+\n+    String registry = registryEndpointRequestProperties.getServerUrl();\n+    String repository = registryEndpointRequestProperties.getImageName();\n+    eventHandlers.dispatch(\n+        LogEvent.debug(\"configured basic auth for \" + registry + \"/\" + repository));\n+  }\n+\n   /**\n-   * @return the {@link RegistryAuthenticator} to authenticate pulls/pushes with the registry, or\n-   *     {@link Optional#empty()} if no token authentication is necessary\n+   * Attempts bearer authentication.\n+   *\n+   * @param readOnlyBearerAuth true to request pull scope only; false for pull and push", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ec93f531770eb9f8698f6773ba218bfd81c63b"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0ODQ2Mzg4", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#pullrequestreview-344846388", "createdAt": "2020-01-17T21:17:52Z", "commit": {"oid": "35ec93f531770eb9f8698f6773ba218bfd81c63b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMToxNzo1M1rOFfFfkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMToxODo1N1rOFfFg_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0MDE3Ng==", "bodyText": "Should we use readOnly to validate registry calls (you cannot use a readOnlyClient auth'd to do writes?)", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368140176", "createdAt": "2020-01-17T21:17:53Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -242,46 +252,113 @@ public static Factory factory(\n   }\n \n   private final EventHandlers eventHandlers;\n-  @Nullable private final Authorization authorization;\n+  @Nullable private final Credential credential;\n   private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n   private final String userAgent;\n   private final FailoverHttpClient httpClient;\n \n+  // mutable\n+  private final AtomicReference<Authorization> authorization = new AtomicReference<>();\n+  private boolean readOnlyBearerAuth;\n+\n   /**\n    * Instantiate with {@link #factory}.\n    *\n    * @param eventHandlers the event handlers used for dispatching log events\n-   * @param authorization the {@link Authorization} to access the registry/repository\n+   * @param credential credential for registry/repository; will not be used unless {@link\n+   *     #configureBasicAuth} or {@link #doBearerAuth} is called\n    * @param registryEndpointRequestProperties properties of registry endpoint requests\n    * @param userAgent {@code User-Agent} header to send with the request\n    * @param httpClient HTTP client\n    */\n   private RegistryClient(\n       EventHandlers eventHandlers,\n-      @Nullable Authorization authorization,\n+      @Nullable Credential credential,\n       RegistryEndpointRequestProperties registryEndpointRequestProperties,\n       String userAgent,\n       FailoverHttpClient httpClient) {\n     this.eventHandlers = eventHandlers;\n-    this.authorization = authorization;\n+    this.credential = credential;\n     this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n     this.userAgent = userAgent;\n     this.httpClient = httpClient;\n   }\n \n+  public void configureBasicAuth() {\n+    Preconditions.checkNotNull(credential);\n+    Preconditions.checkState(!credential.isOAuth2RefreshToken());\n+\n+    authorization.set(\n+        Authorization.fromBasicCredentials(credential.getUsername(), credential.getPassword()));\n+\n+    String registry = registryEndpointRequestProperties.getServerUrl();\n+    String repository = registryEndpointRequestProperties.getImageName();\n+    eventHandlers.dispatch(\n+        LogEvent.debug(\"configured basic auth for \" + registry + \"/\" + repository));\n+  }\n+\n   /**\n-   * @return the {@link RegistryAuthenticator} to authenticate pulls/pushes with the registry, or\n-   *     {@link Optional#empty()} if no token authentication is necessary\n+   * Attempts bearer authentication.\n+   *\n+   * @param readOnlyBearerAuth true to request pull scope only; false for pull and push\n+   * @return true if bearer authentication succeeded; false if the server expects basic\n+   *     authentication (and thus bearer authentication was not attempted)\n    * @throws IOException if communicating with the endpoint fails\n    * @throws RegistryException if communicating with the endpoint fails\n+   * @throws RegistryAuthenticationFailedException if authentication fails\n+   * @throws RegistryCredentialsNotSentException if authentication failed and credentials were not\n+   *     sent over plain HTTP\n    */\n-  public Optional<RegistryAuthenticator> getRegistryAuthenticator()\n-      throws IOException, RegistryException {\n-    // Gets the WWW-Authenticate header (eg. 'WWW-Authenticate: Bearer\n-    // realm=\"https://gcr.io/v2/token\",service=\"gcr.io\"')\n-    return callRegistryEndpoint(\n-        new AuthenticationMethodRetriever(\n-            registryEndpointRequestProperties, getUserAgent(), httpClient));\n+  public boolean doBearerAuth(boolean readOnlyBearerAuth) throws IOException, RegistryException {\n+    this.readOnlyBearerAuth = readOnlyBearerAuth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ec93f531770eb9f8698f6773ba218bfd81c63b"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0MDU0Mg==", "bodyText": "perhaps 5 should be configurable or a const?", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368140542", "createdAt": "2020-01-17T21:18:57Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -463,13 +544,31 @@ String getUserAgent() {\n    */\n   private <T> T callRegistryEndpoint(RegistryEndpointProvider<T> registryEndpointProvider)\n       throws IOException, RegistryException {\n-    return new RegistryEndpointCaller<>(\n-            eventHandlers,\n-            userAgent,\n-            registryEndpointProvider,\n-            authorization,\n-            registryEndpointRequestProperties,\n-            httpClient)\n-        .call();\n+    int bearerTokenRefreshes = 0;\n+    while (true) {\n+      try {\n+        return new RegistryEndpointCaller<>(\n+                eventHandlers,\n+                getUserAgent(),\n+                registryEndpointProvider,\n+                authorization.get(),\n+                registryEndpointRequestProperties,\n+                httpClient)\n+            .call();\n+\n+      } catch (RegistryUnauthorizedException ex) {\n+        if (ex.getHttpResponseException().getStatusCode()\n+                != HttpStatusCodes.STATUS_CODE_UNAUTHORIZED\n+            || !isBearerAuth(authorization.get())\n+            || ++bearerTokenRefreshes >= 5) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ec93f531770eb9f8698f6773ba218bfd81c63b"}, "originalPosition": 263}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcc620a61100454b367359ef348e0c3d6a83fb5e", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/bcc620a61100454b367359ef348e0c3d6a83fb5e", "committedDate": "2020-01-17T22:31:59Z", "message": "Add checks, extract as a constant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "112f91f213f4914e6441df3dd5d4ba5a1b099ea2", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/112f91f213f4914e6441df3dd5d4ba5a1b099ea2", "committedDate": "2020-01-21T18:06:12Z", "message": "Merge branch 'master' into i691-new-refresh-token"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af9618933a0c4c308f85bceb244a1777ab338a7c", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/af9618933a0c4c308f85bceb244a1777ab338a7c", "committedDate": "2020-01-21T18:10:59Z", "message": ">="}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTI5Mzkw", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#pullrequestreview-346129390", "createdAt": "2020-01-21T19:22:00Z", "commit": {"oid": "af9618933a0c4c308f85bceb244a1777ab338a7c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOToyMjowMFrOFgF4kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMTo0Mzo1OVrOFgJyLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5NTE1NA==", "bodyText": "I wonder if we should combine these integration tests into one file at some point, like RegistryClientIntegrationTest or something.", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369195154", "createdAt": "2020-01-21T19:22:00Z", "author": {"login": "TadCordle"}, "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/BearerAuthenticationIntegrationTest.java", "diffHunk": "@@ -18,15 +18,12 @@\n \n import com.google.cloud.tools.jib.api.RegistryException;\n import com.google.cloud.tools.jib.event.EventHandlers;\n-import com.google.cloud.tools.jib.http.Authorization;\n import com.google.cloud.tools.jib.http.FailoverHttpClient;\n import java.io.IOException;\n-import java.util.Optional;\n-import org.junit.Assert;\n import org.junit.Test;\n \n-/** Integration tests for {@link AuthenticationMethodRetriever}. */\n-public class AuthenticationMethodRetrieverIntegrationTest {\n+/** Integration tests for bearer authentication. */\n+public class BearerAuthenticationIntegrationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af9618933a0c4c308f85bceb244a1777ab338a7c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1OTA1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                              \"The registry asked for basic authentication, but the registry had refused basic\"\n          \n          \n            \n                              \"The registry asked for basic authentication, but the registry had refused basic \"", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369259053", "createdAt": "2020-01-21T21:43:59Z", "author": {"login": "TadCordle"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -101,73 +88,81 @@ public ImageAndAuthorization call()\n     ImageReference imageReference = buildContext.getBaseImageConfiguration().getImage();\n     if (imageReference.isScratch()) {\n       eventHandlers.dispatch(LogEvent.progress(\"Getting scratch base image...\"));\n-      return new ImageAndAuthorization(Image.builder(buildContext.getTargetFormat()).build(), null);\n+      return new ImageAndRegistryClient(\n+          Image.builder(buildContext.getTargetFormat()).build(), null);\n     }\n \n     eventHandlers.dispatch(\n         LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n-    if (buildContext.isOffline() || imageReference.isTagDigest()) {\n+    if (buildContext.isOffline()) {\n       Optional<Image> image = getCachedBaseImage();\n       if (image.isPresent()) {\n-        return new ImageAndAuthorization(image.get(), null);\n+        return new ImageAndRegistryClient(image.get(), null);\n       }\n-      if (buildContext.isOffline()) {\n-        throw new IOException(\n-            \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+      throw new IOException(\n+          \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+\n+    } else if (imageReference.isTagDigest()) {\n+      Optional<Image> image = getCachedBaseImage();\n+      if (image.isPresent()) {\n+        RegistryClient noAuthRegistryClient =\n+            buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n+        // TODO: passing noAuthRegistryClient may be problematic. It may return 401 unauthorized if\n+        // layers have to be downloaded. https://github.com/GoogleContainerTools/jib/issues/2220\n+        return new ImageAndRegistryClient(image.get(), noAuthRegistryClient);\n       }\n     }\n \n     try (ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"pulling base image manifest\", 2);\n         TimerEventDispatcher ignored1 = new TimerEventDispatcher(eventHandlers, DESCRIPTION)) {\n+\n       // First, try with no credentials.\n+      RegistryClient noAuthRegistryClient =\n+          buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n       try {\n-        return new ImageAndAuthorization(pullBaseImage(null, progressEventDispatcher), null);\n+        return new ImageAndRegistryClient(\n+            pullBaseImage(noAuthRegistryClient, progressEventDispatcher), noAuthRegistryClient);\n \n-      } catch (RegistryUnauthorizedException ignored2) {\n+      } catch (RegistryUnauthorizedException ex) {\n         eventHandlers.dispatch(\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        // If failed, then, retrieve base registry credentials and try with retrieved credentials.\n-        // TODO: Refactor the logic in RetrieveRegistryCredentialsStep out to\n-        // registry.credentials.RegistryCredentialsRetriever.\n         Credential registryCredential =\n-            RetrieveRegistryCredentialsStep.forBaseImage(\n-                    buildContext, progressEventDispatcher.newChildProducer())\n-                .call()\n-                .orElse(null);\n+            RegistryCredentialRetriever.getBaseImageCredential(buildContext).orElse(null);\n \n-        Authorization registryAuthorization =\n-            registryCredential == null || registryCredential.isOAuth2RefreshToken()\n-                ? null\n-                : Authorization.fromBasicCredentials(\n-                    registryCredential.getUsername(), registryCredential.getPassword());\n+        RegistryClient registryClient =\n+            buildContext\n+                .newBaseImageRegistryClientFactory()\n+                .setCredential(registryCredential)\n+                .newRegistryClient();\n \n         try {\n-          return new ImageAndAuthorization(\n-              pullBaseImage(registryAuthorization, progressEventDispatcher), registryAuthorization);\n+          // TODO: refactor the code (https://github.com/GoogleContainerTools/jib/pull/2202)\n+          if (registryCredential == null || registryCredential.isOAuth2RefreshToken()) {\n+            throw ex;\n+          }\n+\n+          eventHandlers.dispatch(LogEvent.debug(\"Trying basic auth for \" + imageReference + \"...\"));\n+          registryClient.configureBasicAuth();\n+          return new ImageAndRegistryClient(\n+              pullBaseImage(registryClient, progressEventDispatcher), registryClient);\n \n         } catch (RegistryUnauthorizedException registryUnauthorizedException) {\n           // The registry requires us to authenticate using the Docker Token Authentication.\n           // See https://docs.docker.com/registry/spec/auth/token\n-          Optional<RegistryAuthenticator> registryAuthenticator =\n-              buildContext\n-                  .newBaseImageRegistryClientFactory()\n-                  .newRegistryClient()\n-                  .getRegistryAuthenticator();\n-          if (registryAuthenticator.isPresent()) {\n-            Authorization pullAuthorization =\n-                registryAuthenticator.get().authenticatePull(registryCredential);\n-\n-            return new ImageAndAuthorization(\n-                pullBaseImage(pullAuthorization, progressEventDispatcher), pullAuthorization);\n+          eventHandlers.dispatch(\n+              LogEvent.debug(\"Trying bearer auth for \" + imageReference + \"...\"));\n+          if (registryClient.doBearerAuth(true)) {\n+            return new ImageAndRegistryClient(\n+                pullBaseImage(registryClient, progressEventDispatcher), registryClient);\n           }\n           eventHandlers.dispatch(\n               LogEvent.error(\n-                  \"Failed to retrieve authentication challenge for registry that required token \"\n-                      + \"authentication\"));\n+                  \"The registry asked for basic authentication, but the registry had refused basic\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af9618933a0c4c308f85bceb244a1777ab338a7c"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MjY4MjE0", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#pullrequestreview-346268214", "createdAt": "2020-01-21T23:45:58Z", "commit": {"oid": "af9618933a0c4c308f85bceb244a1777ab338a7c"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMzo0NTo1OFrOFgMioQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMDowNTowMlrOFgM34w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwNDIyNQ==", "bodyText": "I think for public methods, people generally are discourage from using boolean as a parameter? I think(?) that this is only an internal API so it's okay. Just wondering how you feel about doing doReadOnlyBearerAuth and doReadWriteBearerAuth that call into this?", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369304225", "createdAt": "2020-01-21T23:45:58Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -242,46 +254,112 @@ public static Factory factory(\n   }\n \n   private final EventHandlers eventHandlers;\n-  @Nullable private final Authorization authorization;\n+  @Nullable private final Credential credential;\n   private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n   private final String userAgent;\n   private final FailoverHttpClient httpClient;\n \n+  // mutable\n+  private final AtomicReference<Authorization> authorization = new AtomicReference<>();\n+  private boolean readOnlyBearerAuth;\n+\n   /**\n    * Instantiate with {@link #factory}.\n    *\n    * @param eventHandlers the event handlers used for dispatching log events\n-   * @param authorization the {@link Authorization} to access the registry/repository\n+   * @param credential credential for registry/repository; will not be used unless {@link\n+   *     #configureBasicAuth} or {@link #doBearerAuth} is called\n    * @param registryEndpointRequestProperties properties of registry endpoint requests\n    * @param userAgent {@code User-Agent} header to send with the request\n    * @param httpClient HTTP client\n    */\n   private RegistryClient(\n       EventHandlers eventHandlers,\n-      @Nullable Authorization authorization,\n+      @Nullable Credential credential,\n       RegistryEndpointRequestProperties registryEndpointRequestProperties,\n       String userAgent,\n       FailoverHttpClient httpClient) {\n     this.eventHandlers = eventHandlers;\n-    this.authorization = authorization;\n+    this.credential = credential;\n     this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n     this.userAgent = userAgent;\n     this.httpClient = httpClient;\n   }\n \n+  public void configureBasicAuth() {\n+    Preconditions.checkNotNull(credential);\n+    Preconditions.checkState(!credential.isOAuth2RefreshToken());\n+\n+    authorization.set(\n+        Authorization.fromBasicCredentials(credential.getUsername(), credential.getPassword()));\n+\n+    String registry = registryEndpointRequestProperties.getServerUrl();\n+    String repository = registryEndpointRequestProperties.getImageName();\n+    eventHandlers.dispatch(\n+        LogEvent.debug(\"configured basic auth for \" + registry + \"/\" + repository));\n+  }\n+\n   /**\n-   * @return the {@link RegistryAuthenticator} to authenticate pulls/pushes with the registry, or\n-   *     {@link Optional#empty()} if no token authentication is necessary\n+   * Attempts bearer authentication.\n+   *\n+   * @param readOnlyBearerAuth true to request pull scope only; false for pull and push\n+   * @return true if bearer authentication succeeded; false if the server expects basic\n+   *     authentication (and thus bearer authentication was not attempted)\n    * @throws IOException if communicating with the endpoint fails\n    * @throws RegistryException if communicating with the endpoint fails\n+   * @throws RegistryAuthenticationFailedException if authentication fails\n+   * @throws RegistryCredentialsNotSentException if authentication failed and credentials were not\n+   *     sent over plain HTTP\n    */\n-  public Optional<RegistryAuthenticator> getRegistryAuthenticator()\n-      throws IOException, RegistryException {\n-    // Gets the WWW-Authenticate header (eg. 'WWW-Authenticate: Bearer\n-    // realm=\"https://gcr.io/v2/token\",service=\"gcr.io\"')\n-    return callRegistryEndpoint(\n-        new AuthenticationMethodRetriever(\n-            registryEndpointRequestProperties, getUserAgent(), httpClient));\n+  public boolean doBearerAuth(boolean readOnlyBearerAuth) throws IOException, RegistryException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af9618933a0c4c308f85bceb244a1777ab338a7c"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTM1MA==", "bodyText": "is the restructure required before we do a 2.0.0?", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369309350", "createdAt": "2020-01-22T00:03:53Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -101,73 +88,77 @@ public ImageAndAuthorization call()\n     ImageReference imageReference = buildContext.getBaseImageConfiguration().getImage();\n     if (imageReference.isScratch()) {\n       eventHandlers.dispatch(LogEvent.progress(\"Getting scratch base image...\"));\n-      return new ImageAndAuthorization(Image.builder(buildContext.getTargetFormat()).build(), null);\n+      return new ImageAndRegistryClient(\n+          Image.builder(buildContext.getTargetFormat()).build(), null);\n     }\n \n     eventHandlers.dispatch(\n         LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n-    if (buildContext.isOffline() || imageReference.isTagDigest()) {\n+    if (buildContext.isOffline()) {\n       Optional<Image> image = getCachedBaseImage();\n       if (image.isPresent()) {\n-        return new ImageAndAuthorization(image.get(), null);\n+        return new ImageAndRegistryClient(image.get(), null);\n       }\n-      if (buildContext.isOffline()) {\n-        throw new IOException(\n-            \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+      throw new IOException(\n+          \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+\n+    } else if (imageReference.isTagDigest()) {\n+      Optional<Image> image = getCachedBaseImage();\n+      if (image.isPresent()) {\n+        RegistryClient noAuthRegistryClient =\n+            buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n+        // TODO: passing noAuthRegistryClient may be problematic. It may return 401 unauthorized if\n+        // layers have to be downloaded. https://github.com/GoogleContainerTools/jib/issues/2220\n+        return new ImageAndRegistryClient(image.get(), noAuthRegistryClient);\n       }\n     }\n \n     try (ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"pulling base image manifest\", 2);\n         TimerEventDispatcher ignored1 = new TimerEventDispatcher(eventHandlers, DESCRIPTION)) {\n+\n       // First, try with no credentials.\n+      RegistryClient noAuthRegistryClient =\n+          buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n       try {\n-        return new ImageAndAuthorization(pullBaseImage(null, progressEventDispatcher), null);\n+        return new ImageAndRegistryClient(\n+            pullBaseImage(noAuthRegistryClient, progressEventDispatcher), noAuthRegistryClient);\n \n-      } catch (RegistryUnauthorizedException ignored2) {\n+      } catch (RegistryUnauthorizedException ex) {\n         eventHandlers.dispatch(\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        // If failed, then, retrieve base registry credentials and try with retrieved credentials.\n-        // TODO: Refactor the logic in RetrieveRegistryCredentialsStep out to\n-        // registry.credentials.RegistryCredentialsRetriever.\n         Credential registryCredential =\n-            RetrieveRegistryCredentialsStep.forBaseImage(\n-                    buildContext, progressEventDispatcher.newChildProducer())\n-                .call()\n-                .orElse(null);\n+            RegistryCredentialRetriever.getBaseImageCredential(buildContext).orElse(null);\n \n-        Authorization registryAuthorization =\n-            registryCredential == null || registryCredential.isOAuth2RefreshToken()\n-                ? null\n-                : Authorization.fromBasicCredentials(\n-                    registryCredential.getUsername(), registryCredential.getPassword());\n+        RegistryClient registryClient =\n+            buildContext\n+                .newBaseImageRegistryClientFactory()\n+                .setCredential(registryCredential)\n+                .newRegistryClient();\n \n         try {\n-          return new ImageAndAuthorization(\n-              pullBaseImage(registryAuthorization, progressEventDispatcher), registryAuthorization);\n+          // TODO: refactor the code (https://github.com/GoogleContainerTools/jib/pull/2202)\n+          if (registryCredential == null || registryCredential.isOAuth2RefreshToken()) {\n+            throw ex;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjgxNg=="}, "originalCommit": {"oid": "d934edd594622c228fc799f7804747e2d4b9162b"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTY2Nw==", "bodyText": "probably don't need had either.\n- the registry had refused\n+ the registry refused", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369309667", "createdAt": "2020-01-22T00:05:02Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -101,73 +88,81 @@ public ImageAndAuthorization call()\n     ImageReference imageReference = buildContext.getBaseImageConfiguration().getImage();\n     if (imageReference.isScratch()) {\n       eventHandlers.dispatch(LogEvent.progress(\"Getting scratch base image...\"));\n-      return new ImageAndAuthorization(Image.builder(buildContext.getTargetFormat()).build(), null);\n+      return new ImageAndRegistryClient(\n+          Image.builder(buildContext.getTargetFormat()).build(), null);\n     }\n \n     eventHandlers.dispatch(\n         LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n-    if (buildContext.isOffline() || imageReference.isTagDigest()) {\n+    if (buildContext.isOffline()) {\n       Optional<Image> image = getCachedBaseImage();\n       if (image.isPresent()) {\n-        return new ImageAndAuthorization(image.get(), null);\n+        return new ImageAndRegistryClient(image.get(), null);\n       }\n-      if (buildContext.isOffline()) {\n-        throw new IOException(\n-            \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+      throw new IOException(\n+          \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+\n+    } else if (imageReference.isTagDigest()) {\n+      Optional<Image> image = getCachedBaseImage();\n+      if (image.isPresent()) {\n+        RegistryClient noAuthRegistryClient =\n+            buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n+        // TODO: passing noAuthRegistryClient may be problematic. It may return 401 unauthorized if\n+        // layers have to be downloaded. https://github.com/GoogleContainerTools/jib/issues/2220\n+        return new ImageAndRegistryClient(image.get(), noAuthRegistryClient);\n       }\n     }\n \n     try (ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"pulling base image manifest\", 2);\n         TimerEventDispatcher ignored1 = new TimerEventDispatcher(eventHandlers, DESCRIPTION)) {\n+\n       // First, try with no credentials.\n+      RegistryClient noAuthRegistryClient =\n+          buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n       try {\n-        return new ImageAndAuthorization(pullBaseImage(null, progressEventDispatcher), null);\n+        return new ImageAndRegistryClient(\n+            pullBaseImage(noAuthRegistryClient, progressEventDispatcher), noAuthRegistryClient);\n \n-      } catch (RegistryUnauthorizedException ignored2) {\n+      } catch (RegistryUnauthorizedException ex) {\n         eventHandlers.dispatch(\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        // If failed, then, retrieve base registry credentials and try with retrieved credentials.\n-        // TODO: Refactor the logic in RetrieveRegistryCredentialsStep out to\n-        // registry.credentials.RegistryCredentialsRetriever.\n         Credential registryCredential =\n-            RetrieveRegistryCredentialsStep.forBaseImage(\n-                    buildContext, progressEventDispatcher.newChildProducer())\n-                .call()\n-                .orElse(null);\n+            RegistryCredentialRetriever.getBaseImageCredential(buildContext).orElse(null);\n \n-        Authorization registryAuthorization =\n-            registryCredential == null || registryCredential.isOAuth2RefreshToken()\n-                ? null\n-                : Authorization.fromBasicCredentials(\n-                    registryCredential.getUsername(), registryCredential.getPassword());\n+        RegistryClient registryClient =\n+            buildContext\n+                .newBaseImageRegistryClientFactory()\n+                .setCredential(registryCredential)\n+                .newRegistryClient();\n \n         try {\n-          return new ImageAndAuthorization(\n-              pullBaseImage(registryAuthorization, progressEventDispatcher), registryAuthorization);\n+          // TODO: refactor the code (https://github.com/GoogleContainerTools/jib/pull/2202)\n+          if (registryCredential == null || registryCredential.isOAuth2RefreshToken()) {\n+            throw ex;\n+          }\n+\n+          eventHandlers.dispatch(LogEvent.debug(\"Trying basic auth for \" + imageReference + \"...\"));\n+          registryClient.configureBasicAuth();\n+          return new ImageAndRegistryClient(\n+              pullBaseImage(registryClient, progressEventDispatcher), registryClient);\n \n         } catch (RegistryUnauthorizedException registryUnauthorizedException) {\n           // The registry requires us to authenticate using the Docker Token Authentication.\n           // See https://docs.docker.com/registry/spec/auth/token\n-          Optional<RegistryAuthenticator> registryAuthenticator =\n-              buildContext\n-                  .newBaseImageRegistryClientFactory()\n-                  .newRegistryClient()\n-                  .getRegistryAuthenticator();\n-          if (registryAuthenticator.isPresent()) {\n-            Authorization pullAuthorization =\n-                registryAuthenticator.get().authenticatePull(registryCredential);\n-\n-            return new ImageAndAuthorization(\n-                pullBaseImage(pullAuthorization, progressEventDispatcher), pullAuthorization);\n+          eventHandlers.dispatch(\n+              LogEvent.debug(\"Trying bearer auth for \" + imageReference + \"...\"));\n+          if (registryClient.doBearerAuth(true)) {\n+            return new ImageAndRegistryClient(\n+                pullBaseImage(registryClient, progressEventDispatcher), registryClient);\n           }\n           eventHandlers.dispatch(\n               LogEvent.error(\n-                  \"Failed to retrieve authentication challenge for registry that required token \"\n-                      + \"authentication\"));\n+                  \"The registry asked for basic authentication, but the registry had refused basic\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1OTA1Mw=="}, "originalCommit": {"oid": "af9618933a0c4c308f85bceb244a1777ab338a7c"}, "originalPosition": 182}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90414b3e391d87eefb80def73f40192c945699a8", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/90414b3e391d87eefb80def73f40192c945699a8", "committedDate": "2020-01-22T15:53:08Z", "message": "review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2ODYwOTk4", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#pullrequestreview-346860998", "createdAt": "2020-01-22T19:55:21Z", "commit": {"oid": "90414b3e391d87eefb80def73f40192c945699a8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxOTo1NToyMlrOFgpCsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxOTo1NToyMlrOFgpCsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3MTE4NA==", "bodyText": "{@code true} and {@code false}?", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369771184", "createdAt": "2020-01-22T19:55:22Z", "author": {"login": "TadCordle"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -242,46 +254,131 @@ public static Factory factory(\n   }\n \n   private final EventHandlers eventHandlers;\n-  @Nullable private final Authorization authorization;\n+  @Nullable private final Credential credential;\n   private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n   private final String userAgent;\n   private final FailoverHttpClient httpClient;\n \n+  // mutable\n+  private final AtomicReference<Authorization> authorization = new AtomicReference<>();\n+  private boolean readOnlyBearerAuth;\n+\n   /**\n    * Instantiate with {@link #factory}.\n    *\n    * @param eventHandlers the event handlers used for dispatching log events\n-   * @param authorization the {@link Authorization} to access the registry/repository\n+   * @param credential credential for registry/repository; will not be used unless {@link\n+   *     #configureBasicAuth} or {@link #doBearerAuth} is called\n    * @param registryEndpointRequestProperties properties of registry endpoint requests\n    * @param userAgent {@code User-Agent} header to send with the request\n    * @param httpClient HTTP client\n    */\n   private RegistryClient(\n       EventHandlers eventHandlers,\n-      @Nullable Authorization authorization,\n+      @Nullable Credential credential,\n       RegistryEndpointRequestProperties registryEndpointRequestProperties,\n       String userAgent,\n       FailoverHttpClient httpClient) {\n     this.eventHandlers = eventHandlers;\n-    this.authorization = authorization;\n+    this.credential = credential;\n     this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n     this.userAgent = userAgent;\n     this.httpClient = httpClient;\n   }\n \n+  public void configureBasicAuth() {\n+    Preconditions.checkNotNull(credential);\n+    Preconditions.checkState(!credential.isOAuth2RefreshToken());\n+\n+    authorization.set(\n+        Authorization.fromBasicCredentials(credential.getUsername(), credential.getPassword()));\n+\n+    String registry = registryEndpointRequestProperties.getServerUrl();\n+    String repository = registryEndpointRequestProperties.getImageName();\n+    eventHandlers.dispatch(\n+        LogEvent.debug(\"configured basic auth for \" + registry + \"/\" + repository));\n+  }\n+\n   /**\n-   * @return the {@link RegistryAuthenticator} to authenticate pulls/pushes with the registry, or\n-   *     {@link Optional#empty()} if no token authentication is necessary\n+   * Attempts bearer authentication for pull.\n+   *\n+   * @return true if bearer authentication succeeded; false if the server expects basic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90414b3e391d87eefb80def73f40192c945699a8"}, "originalPosition": 141}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9f9dfeb1ffb89b379405e9229b42e8116c3eb86", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/c9f9dfeb1ffb89b379405e9229b42e8116c3eb86", "committedDate": "2020-01-22T21:35:15Z", "message": "javadocs and minor cleanups"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2OTU2NjEw", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#pullrequestreview-346956610", "createdAt": "2020-01-22T22:43:41Z", "commit": {"oid": "c9f9dfeb1ffb89b379405e9229b42e8116c3eb86"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMjo0Mzo0MVrOFgtoKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMjo1MjozM1rOFgt0-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg0NjMxMw==", "bodyText": "Does it make sense to make this 2 allocation units now, or is it so quick, this doesn't really matter.", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369846313", "createdAt": "2020-01-22T22:43:41Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/AuthenticatePushStep.java", "diffHunk": "@@ -21,58 +21,53 @@\n import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n import com.google.cloud.tools.jib.builder.TimerEventDispatcher;\n import com.google.cloud.tools.jib.configuration.BuildContext;\n-import com.google.cloud.tools.jib.http.Authorization;\n-import com.google.cloud.tools.jib.registry.RegistryAuthenticator;\n+import com.google.cloud.tools.jib.registry.RegistryClient;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n import java.io.IOException;\n-import java.util.Optional;\n import java.util.concurrent.Callable;\n-import javax.annotation.Nullable;\n \n /**\n  * Authenticates push to a target registry using Docker Token Authentication.\n  *\n  * @see <a\n  *     href=\"https://docs.docker.com/registry/spec/auth/token/\">https://docs.docker.com/registry/spec/auth/token/</a>\n  */\n-class AuthenticatePushStep implements Callable<Optional<Authorization>> {\n+class AuthenticatePushStep implements Callable<RegistryClient> {\n \n   private static final String DESCRIPTION = \"Authenticating push to %s\";\n \n   private final BuildContext buildContext;\n   private final ProgressEventDispatcher.Factory progressEventDispatcherFactory;\n-  @Nullable private final Credential registryCredential;\n \n   AuthenticatePushStep(\n-      BuildContext buildContext,\n-      ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n-      @Nullable Credential registryCredential) {\n+      BuildContext buildContext, ProgressEventDispatcher.Factory progressEventDispatcherFactory) {\n     this.buildContext = buildContext;\n     this.progressEventDispatcherFactory = progressEventDispatcherFactory;\n-    this.registryCredential = registryCredential;\n   }\n \n   @Override\n-  public Optional<Authorization> call() throws IOException, RegistryException {\n+  public RegistryClient call() throws CredentialRetrievalException, IOException, RegistryException {\n     String registry = buildContext.getTargetImageConfiguration().getImageRegistry();\n     try (ProgressEventDispatcher ignored =\n             progressEventDispatcherFactory.create(\"authenticating push to \" + registry, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9f9dfeb1ffb89b379405e9229b42e8116c3eb86"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg0OTU5Mw==", "bodyText": "I find this flow to be a little strange. But maybe that's just a consequence of our code, should the registry client just handle this basic auth stuff?\nIs there a reason we want the steps of authorizing the client to exist separate and outside the client?", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369849593", "createdAt": "2020-01-22T22:52:33Z", "author": {"login": "loosebazooka"}, "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/AuthenticatePushStep.java", "diffHunk": "@@ -21,58 +21,53 @@\n import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n import com.google.cloud.tools.jib.builder.TimerEventDispatcher;\n import com.google.cloud.tools.jib.configuration.BuildContext;\n-import com.google.cloud.tools.jib.http.Authorization;\n-import com.google.cloud.tools.jib.registry.RegistryAuthenticator;\n+import com.google.cloud.tools.jib.registry.RegistryClient;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n import java.io.IOException;\n-import java.util.Optional;\n import java.util.concurrent.Callable;\n-import javax.annotation.Nullable;\n \n /**\n  * Authenticates push to a target registry using Docker Token Authentication.\n  *\n  * @see <a\n  *     href=\"https://docs.docker.com/registry/spec/auth/token/\">https://docs.docker.com/registry/spec/auth/token/</a>\n  */\n-class AuthenticatePushStep implements Callable<Optional<Authorization>> {\n+class AuthenticatePushStep implements Callable<RegistryClient> {\n \n   private static final String DESCRIPTION = \"Authenticating push to %s\";\n \n   private final BuildContext buildContext;\n   private final ProgressEventDispatcher.Factory progressEventDispatcherFactory;\n-  @Nullable private final Credential registryCredential;\n \n   AuthenticatePushStep(\n-      BuildContext buildContext,\n-      ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n-      @Nullable Credential registryCredential) {\n+      BuildContext buildContext, ProgressEventDispatcher.Factory progressEventDispatcherFactory) {\n     this.buildContext = buildContext;\n     this.progressEventDispatcherFactory = progressEventDispatcherFactory;\n-    this.registryCredential = registryCredential;\n   }\n \n   @Override\n-  public Optional<Authorization> call() throws IOException, RegistryException {\n+  public RegistryClient call() throws CredentialRetrievalException, IOException, RegistryException {\n     String registry = buildContext.getTargetImageConfiguration().getImageRegistry();\n     try (ProgressEventDispatcher ignored =\n             progressEventDispatcherFactory.create(\"authenticating push to \" + registry, 1);\n         TimerEventDispatcher ignored2 =\n             new TimerEventDispatcher(\n                 buildContext.getEventHandlers(), String.format(DESCRIPTION, registry))) {\n-      Optional<RegistryAuthenticator> registryAuthenticator =\n+      Credential credential =\n+          RegistryCredentialRetriever.getTargetImageCredential(buildContext).orElse(null);\n+\n+      RegistryClient registryClient =\n           buildContext\n               .newTargetImageRegistryClientFactory()\n-              .newRegistryClient()\n-              .getRegistryAuthenticator();\n-      if (registryAuthenticator.isPresent()) {\n-        return Optional.of(registryAuthenticator.get().authenticatePush(registryCredential));\n+              .setCredential(credential)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9f9dfeb1ffb89b379405e9229b42e8116c3eb86"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4eb78eccfc4ab22795dfdbe258b9ec78b50e446", "author": {"user": {"login": "chanseokoh", "name": "Chanseok Oh"}}, "url": "https://github.com/GoogleContainerTools/jib/commit/a4eb78eccfc4ab22795dfdbe258b9ec78b50e446", "committedDate": "2020-01-23T16:28:55Z", "message": "CHANGELOG and progress dispatch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDk4MDUx", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#pullrequestreview-348098051", "createdAt": "2020-01-24T17:09:34Z", "commit": {"oid": "a4eb78eccfc4ab22795dfdbe258b9ec78b50e446"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 301, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}