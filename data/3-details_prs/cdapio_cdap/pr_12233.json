{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1Njk3NzY3", "number": 12233, "title": "[CDAP-16835] REST API for upgrading Application and support for config upgrade for DataPipelineApp.", "bodyText": "JIRA: https://issues.cask.co/browse/CDAP-16835\nhttps://builds.cask.co/browse/CDAP-DUT7228-18\nThis PR contains following changes -\n\nAdded DefaultApplicationUpdateContext which will be used for upgrading application config.\nAdded upgradeApplication REST for upgrading one app and upgradeApplications REST api for upgrading list of apps.\nAdded support for upgrading ETLBatchConfig for DataPipelineApp.\nIt includes logic for ETLBatchConfig to upgrade itself, which in turn includes logic for ETLStage to\nupgrade itself, which in turn includes logic to upgrade plugin used by the stage.\nAdded end to end unit tests with various scenarios.\n\nUpgrading a config includes following step:\n\n\nTry to find latest version of the artifact that application using (i.e cdap-data-pipeline) with the same scope as before. It might be that the latest version is same as previous version (means application artifact does not have new version available) which will essentially be a no-op for upgrading application artifact version.\n\n\nAfter choosing which artifact version to upgrade, updateApplicationInternal ApplicationLifeCycleService will try to update app config by asking the Application class to update via ApplicationUpdateContext. If Application supports updating config, it will return new config by running update actions on older config. Actions include, upgrading plugin artifact in ETLStage config.\n\n\nNOTE: This PR only supports upgrading plugin artifact via trying to find latest artifact in SYSTEM scope only.", "createdAt": "2020-06-01T00:45:15Z", "url": "https://github.com/cdapio/cdap/pull/12233", "merged": true, "mergeCommit": {"oid": "f082c6192188115a2040d3a2202b9cdcf72af301"}, "closed": true, "closedAt": "2020-06-09T16:55:32Z", "author": {"login": "pandyajay10"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnh_sbABqjM0MDAzODc1MzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpnpMQABqjM0MjU3OTc5MzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6efbfb5080d1da848e53248ed9c71b2e98e7bc1", "author": {"user": null}, "url": "https://github.com/cdapio/cdap/commit/f6efbfb5080d1da848e53248ed9c71b2e98e7bc1", "committedDate": "2020-05-29T19:39:31Z", "message": "First changes for upgrade data pipeline app"}, "afterCommit": {"oid": "bd786d9e66f86ac643fde9e7f109fb561f7c8259", "author": {"user": null}, "url": "https://github.com/cdapio/cdap/commit/bd786d9e66f86ac643fde9e7f109fb561f7c8259", "committedDate": "2020-06-03T04:43:38Z", "message": "Changes for upgrade api"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTc2NzM3", "url": "https://github.com/cdapio/cdap/pull/12233#pullrequestreview-424176737", "createdAt": "2020-06-04T07:35:14Z", "commit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNzozNToxNFrOGe5Z7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNzo0NToxNVrOGe5uHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MDk5MQ==", "bodyText": "Why response with 200 OK if the operation failed?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435050991", "createdAt": "2020-06-04T07:35:14Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {\n+\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    } catch (Exception e) {\n+      LOG.error(\"Upgrade application failure\", e);\n+      ApplicationUpdateDetails detail = new ApplicationUpdateDetails(\n+          new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                               HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MTU3MA==", "bodyText": "Don't use map as response for batch request. Response with array of objects. This is better to preserve the same ordering as the request.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435051570", "createdAt": "2020-06-04T07:36:25Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {\n+\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    } catch (Exception e) {\n+      LOG.error(\"Upgrade application failure\", e);\n+      ApplicationUpdateDetails detail = new ApplicationUpdateDetails(\n+          new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                               HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    }\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   *\n+   * The response will be map of Application ID to {@link ApplicationUpdateDetails} object, which either indicates a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MjMwNA==", "bodyText": "Mark fields as final whenever possible.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435052304", "createdAt": "2020-06-04T07:37:53Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MjQxNQ==", "bodyText": "Make a defensive copy.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435052415", "createdAt": "2020-06-04T07:38:05Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MzI3MQ==", "bodyText": "The type may not be a Class. Use TypeToken.of(configType).getRawType() to make sure you get a Class.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435053271", "createdAt": "2020-06-04T07:39:40Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MzkyOQ==", "bodyText": "No need to have this local file. You can just return directly at the place where you construct the new instance.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435053929", "createdAt": "2020-06-04T07:41:01Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1NDUxNg==", "bodyText": "When writing doc for a method, please with the method javadoc syntax instead of line comment.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435054516", "createdAt": "2020-06-04T07:42:08Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1NjE1OA==", "bodyText": "It is better not to have this logic in this class, but rather an argument to this class (e.g. boolean allowSnapshot)", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435056158", "createdAt": "2020-06-04T07:45:15Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.\n+  // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = new Predicate<io.cdap.cdap.proto.id.ArtifactId>() {\n+      @Override\n+      public boolean apply(io.cdap.cdap.proto.id.ArtifactId input) {\n+        // should check if the artifact is from SYSTEM namespace, if not, check if it is from the scoped namespace.\n+        // should check if plugin is in given range if provided.\n+        return (((pluginScope == null && NamespaceId.SYSTEM.equals(input.getParent()))\n+               || pluginArtifactNamespace.equals(input.getParent())) &&\n+               (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+      }\n+    };\n+\n+    try {\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+          artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                        Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                        pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0Njc5ODQ5", "url": "https://github.com/cdapio/cdap/pull/12233#pullrequestreview-424679849", "createdAt": "2020-06-04T17:38:30Z", "commit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "state": "COMMENTED", "comments": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzozODozMVrOGfQtzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODozNjoxNFrOGfS8eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzMjkwOQ==", "bodyText": "don't need the Schema.unionOf() right now if we're just making it null", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435432909", "createdAt": "2020-06-04T17:38:31Z", "author": {"login": "albertshau"}, "path": "cdap-api/src/main/java/io/cdap/cdap/internal/io/AbstractSchemaGenerator.java", "diffHunk": "@@ -69,7 +69,10 @@\n     simpleSchemas.put(byte[].class, Schema.of(Schema.Type.BYTES));\n     simpleSchemas.put(ByteBuffer.class, Schema.of(Schema.Type.BYTES));\n \n-        // Some extra ones for some common build-in types. Need corresponding handling in DatumReader/Writer\n+    // TODO: Convert Object class mapping to union of all simple schema types.\n+    simpleSchemas.put(Object.class, Schema.unionOf(Schema.of(Schema.Type.NULL)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzNTEzOQ==", "bodyText": "Does upgradeApplication() throw NotFoundException, BadRequestException, etc? If so, this isn't guaranteed to be an internal error.\nIt seems like you can just let the exception propagate and not catch it here at all.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435435139", "createdAt": "2020-06-04T17:42:18Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {\n+\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    } catch (Exception e) {\n+      LOG.error(\"Upgrade application failure\", e);\n+      ApplicationUpdateDetails detail = new ApplicationUpdateDetails(\n+          new ServiceException(\"Upgrade failed due to internal error.\", null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzNTY4MA==", "bodyText": "the current code can't actually throw all of these exceptions (your IDE should flag this as a warning)", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435435680", "createdAt": "2020-06-04T17:43:09Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzNTkyNQ==", "bodyText": "is it really always an internal error here? For example, can't the upgrade fail because the new pipeline is invalid in some way (in which case it would be a 400 instead of a 500)?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435435925", "createdAt": "2020-06-04T17:43:33Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {\n+\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    } catch (Exception e) {\n+      LOG.error(\"Upgrade application failure\", e);\n+      ApplicationUpdateDetails detail = new ApplicationUpdateDetails(\n+          new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                               HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    }\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   *\n+   * The response will be map of Application ID to {@link ApplicationUpdateDetails} object, which either indicates a\n+   * success (200) or failure for each of the requested application. The failure also indicates reason for the error.\n+   */\n+  @POST\n+  @Path(\"/upgrade\")\n+  public void upgradeApplications(FullHttpRequest request, HttpResponder responder,\n+                                  @PathParam(\"namespace-id\") String namespace) throws Exception {\n+    List<ApplicationId> appIds = decodeAndValidateBatchApplication(validateNamespace(namespace), request);\n+    Map<ApplicationId, ApplicationUpdateDetails> details = new HashMap<>();\n+    for (ApplicationId appId : appIds) {\n+      try {\n+        details.put(appId, applicationLifecycleService.upgradeApplication(appId, createProgramTerminator()));\n+      } catch (Exception e) {\n+        ApplicationUpdateDetails errorDetail = new ApplicationUpdateDetails(\n+            new ServiceException(\"Upgrade failed due to internal error.\", null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzNjI4Mw==", "bodyText": "this should only error log if it really is an internal error. Failure to update because of invalid input should not result in an error log.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435436283", "createdAt": "2020-06-04T17:44:06Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +382,70 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName)\n+      throws NotFoundException, BadRequestException, UnauthorizedException, IOException {\n+\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    } catch (Exception e) {\n+      LOG.error(\"Upgrade application failure\", e);\n+      ApplicationUpdateDetails detail = new ApplicationUpdateDetails(\n+          new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                               HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+    }\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   *\n+   * The response will be map of Application ID to {@link ApplicationUpdateDetails} object, which either indicates a\n+   * success (200) or failure for each of the requested application. The failure also indicates reason for the error.\n+   */\n+  @POST\n+  @Path(\"/upgrade\")\n+  public void upgradeApplications(FullHttpRequest request, HttpResponder responder,\n+                                  @PathParam(\"namespace-id\") String namespace) throws Exception {\n+    List<ApplicationId> appIds = decodeAndValidateBatchApplication(validateNamespace(namespace), request);\n+    Map<ApplicationId, ApplicationUpdateDetails> details = new HashMap<>();\n+    for (ApplicationId appId : appIds) {\n+      try {\n+        details.put(appId, applicationLifecycleService.upgradeApplication(appId, createProgramTerminator()));\n+      } catch (Exception e) {\n+        ApplicationUpdateDetails errorDetail = new ApplicationUpdateDetails(\n+            new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                                 HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+\n+        details.put(appId, errorDetail);\n+        LOG.error(\"Upgrading application {} failed due to exception \", appId, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzOTA4OQ==", "bodyText": "can use closure syntax (your IDE should have a way to auto-convert this for you too):\npredicate = input -> {\n  return ...\n}", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435439089", "createdAt": "2020-06-04T17:48:36Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.\n+  // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = new Predicate<io.cdap.cdap.proto.id.ArtifactId>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0MzAwNQ==", "bodyText": "the number of parentheses makes this hard to understand, can you break it up into multiple lines?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435443005", "createdAt": "2020-06-04T17:55:03Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.\n+  // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = new Predicate<io.cdap.cdap.proto.id.ArtifactId>() {\n+      @Override\n+      public boolean apply(io.cdap.cdap.proto.id.ArtifactId input) {\n+        // should check if the artifact is from SYSTEM namespace, if not, check if it is from the scoped namespace.\n+        // should check if plugin is in given range if provided.\n+        return (((pluginScope == null && NamespaceId.SYSTEM.equals(input.getParent()))\n+               || pluginArtifactNamespace.equals(input.getParent())) &&\n+               (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0MzMwNg==", "bodyText": "pluginScope should be annotated as @Nullable if it is allowed to be null. Though it seems like it shouldn't be allowed, the caller should default it themselves to an appropriate value.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435443306", "createdAt": "2020-06-04T17:55:33Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.\n+  // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = new Predicate<io.cdap.cdap.proto.id.ArtifactId>() {\n+      @Override\n+      public boolean apply(io.cdap.cdap.proto.id.ArtifactId input) {\n+        // should check if the artifact is from SYSTEM namespace, if not, check if it is from the scoped namespace.\n+        // should check if plugin is in given range if provided.\n+        return (((pluginScope == null && NamespaceId.SYSTEM.equals(input.getParent()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NDgwMw==", "bodyText": "exceptions getting plugins should not be swallowed and ignored. They need to be propagated up and result in update failure.\nyou probably need to update the interface and potentially add new exception classes to the cdap-api.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435444803", "createdAt": "2020-06-04T17:58:03Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Predicate;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+      registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private String configString;\n+  private List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = updateActions;\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    C appConfig;\n+\n+    if (configString.isEmpty()) {\n+      try {\n+        appConfig = ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        appConfig = GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+    return appConfig;\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  // Returns plugin artifacts using given filters in ascending order.\n+  // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = new Predicate<io.cdap.cdap.proto.id.ArtifactId>() {\n+      @Override\n+      public boolean apply(io.cdap.cdap.proto.id.ArtifactId input) {\n+        // should check if the artifact is from SYSTEM namespace, if not, check if it is from the scoped namespace.\n+        // should check if plugin is in given range if provided.\n+        return (((pluginScope == null && NamespaceId.SYSTEM.equals(input.getParent()))\n+               || pluginArtifactNamespace.equals(input.getParent())) &&\n+               (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+      }\n+    };\n+\n+    try {\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+          artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                        Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                        pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {\n+          pluginArtifacts.add(plugin);\n+        }\n+      }\n+    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NjIxMQ==", "bodyText": "remove", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435446211", "createdAt": "2020-06-04T18:00:37Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NjM4NA==", "bodyText": "indentation", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435446384", "createdAt": "2020-06-04T18:00:53Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NzMzOA==", "bodyText": "it's basically never a good idea to throw a generic Exception in an internal method, as it makes it impossible for the caller to handle errors properly. Can this throw more specific exceptions?\nWe have a lot of bad existing code that does this, so if it may not be possible right now,\nbut you should at least add javadocs about the more specific exceptions that you know it can throw.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435447338", "createdAt": "2020-06-04T18:02:38Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0NjM4NA=="}, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ0ODAxMA==", "bodyText": "indentation should be 2 spaces. Same comment for rest of PR", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435448010", "createdAt": "2020-06-04T18:03:45Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MDE4NA==", "bodyText": "should not log a warning. This is a normal, expected situation from app-fabric's point of view, caused by bad user input.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435450184", "createdAt": "2020-06-04T18:07:30Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MDg0Mw==", "bodyText": "should limit 1 with descending order", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435450843", "createdAt": "2020-06-04T18:08:41Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MTQ1NA==", "bodyText": "this is possible if the user deleted the artifact manually (we allow them to delete the artifact even if it is being used by apps). This should not be an internal error, it should result in an ApplicationUpdateDetail being returned.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435451454", "createdAt": "2020-06-04T18:09:54Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MTg3Mw==", "bodyText": "don't throw InternalError. This is a java language error meant for fatal java issues. You should almost never have to throw an Error in normal code.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435451873", "createdAt": "2020-06-04T18:10:38Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MzAzMw==", "bodyText": "I don't think this should be possible, did you see this during testing?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435453033", "createdAt": "2020-06-04T18:12:42Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MzgzMw==", "bodyText": "this is not possible, you passed the artifact name to artifactRepository.getArtifactSummaries() earlier.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435453833", "createdAt": "2020-06-04T18:14:13Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1NDYyOQ==", "bodyText": "seems like these should all result in an object being returned, and not in an exception being thrown.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435454629", "createdAt": "2020-06-04T18:15:35Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1NTE3Ng==", "bodyText": "current name -> current scope\nthough this seems like a confusing message, the user is not going to know what this means. Also, can this even happen? Isn't the namespace passed to the getArtifactSummaries() call?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435455176", "createdAt": "2020-06-04T18:16:35Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1NzY4Nw==", "bodyText": "E -> e", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435457687", "createdAt": "2020-06-04T18:20:46Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),\n+                detail.getError());\n+      return new ApplicationUpdateDetails(\"upgrade successful.\", null);\n+    } catch (UnsupportedOperationException E) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1OTMzMg==", "bodyText": "also, I thought there was some boolean that can be used to check if update is supported?\nUnsupportedOperationException can be thrown by other things (for example, trying to write to an UnmodifiableMap), so it's better to base this off the API", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435459332", "createdAt": "2020-06-04T18:22:38Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),\n+                detail.getError());\n+      return new ApplicationUpdateDetails(\"upgrade successful.\", null);\n+    } catch (UnsupportedOperationException E) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1NzY4Nw=="}, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1OTUzMg==", "bodyText": "there will never be an error if it sucessful right?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435459532", "createdAt": "2020-06-04T18:22:51Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MDY5NQ==", "bodyText": "should not have these 1 line methods", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435460695", "createdAt": "2020-06-04T18:24:13Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/ArtifactSelectorConfig.java", "diffHunk": "@@ -85,4 +87,22 @@ public String toString() {\n       \", version='\" + version + '\\'' +\n       '}';\n   }\n+\n+  public io.cdap.cdap.api.artifact.ArtifactVersion getApiArtifactVersion() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MTY5MA==", "bodyText": "don't need this, can just always pass Collections.emptyList() in the build() method", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435461690", "createdAt": "2020-06-04T18:25:25Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLBatchConfig.java", "diffHunk": "@@ -181,9 +204,12 @@ public static ETLBatchConfig forSystemService() {\n     private Engine engine;\n     private List<ETLStage> endingActions;\n     private Integer maxConcurrentRuns;\n+    // Only used for upgrade purpose.\n+    private List<String> comments;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MjUxOQ==", "bodyText": "why do these need to be made protected?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435462519", "createdAt": "2020-06-04T18:26:19Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLConfig.java", "diffHunk": "@@ -41,20 +41,23 @@\n // though not marked nullable, fields can be null since these objects are created through gson deserialization\n @SuppressWarnings(\"ConstantConditions\")\n public class ETLConfig extends Config implements UpgradeableConfig {\n-  private final String description;\n-  private final Set<ETLStage> stages;\n-  private final Set<Connection> connections;\n-  private final Resources resources;\n-  private final Resources driverResources;\n-  private final Resources clientResources;\n-  private final Boolean stageLoggingEnabled;\n-  private final Boolean processTimingEnabled;\n-  private final Integer numOfRecordsPreview;\n-  private final Map<String, String> properties;\n+  protected final String description;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2Mjk0MA==", "bodyText": "Details -> Detail", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435462940", "createdAt": "2020-06-04T18:27:02Z", "author": {"login": "albertshau"}, "path": "cdap-proto/src/main/java/io/cdap/cdap/proto/ApplicationUpdateDetails.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.proto;\n+\n+import io.cdap.cdap.api.common.HttpErrorStatusProvider;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Represents an application update result of an {@link ApplicationDetail}.\n+ */\n+public class ApplicationUpdateDetails {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MzI0MA==", "bodyText": "do we need both an error field and this field? Seems like we could just have a 'message' field since the status code indicates where it succeeded or failed", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435463240", "createdAt": "2020-06-04T18:27:24Z", "author": {"login": "albertshau"}, "path": "cdap-proto/src/main/java/io/cdap/cdap/proto/ApplicationUpdateDetails.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.proto;\n+\n+import io.cdap.cdap.api.common.HttpErrorStatusProvider;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Represents an application update result of an {@link ApplicationDetail}.\n+ */\n+public class ApplicationUpdateDetails {\n+\n+  private final int statusCode;\n+  private final String error;\n+  private final String updateDetails;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NjUyMw==", "bodyText": "InvalidArtifactException is used when there is something wrong with the artifact itself, which is not the case here.\nThe ApplicationSpecification is looked up earlier, this should never happen right? If not, can throw an IllegalStateException, and add a comment that this should never happen.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435466523", "createdAt": "2020-06-04T18:32:14Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),\n+                detail.getError());\n+      return new ApplicationUpdateDetails(\"upgrade successful.\", null);\n+    } catch (UnsupportedOperationException E) {\n+      String errorMessage = String.format(\"Upgrade failed for application %s as artifact %s does not support upgrade.\",\n+                                          appId, newArtifact);\n+      return new ApplicationUpdateDetails(new NotImplementedException(errorMessage));\n+    }\n+  }\n+\n+  // Updates an application config by applying given update actions. The app should know how to apply these actions\n+  // to its config.\n+  private ApplicationUpdateDetails updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,\n+                                                             @Nullable String appVersion,\n+                                                             @Nullable String currentConfigStr,\n+                                                             ProgramTerminator programTerminator,\n+                                                             ArtifactDetail artifactDetail,\n+                                                             List<ApplicationConfigUpdateAction> updateActions,\n+                                                             @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                             boolean updateSchedules) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      throw new InvalidArtifactException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2ODg1MQ==", "bodyText": "should not log an error", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435468851", "createdAt": "2020-06-04T18:35:36Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),\n+                detail.getError());\n+      return new ApplicationUpdateDetails(\"upgrade successful.\", null);\n+    } catch (UnsupportedOperationException E) {\n+      String errorMessage = String.format(\"Upgrade failed for application %s as artifact %s does not support upgrade.\",\n+                                          appId, newArtifact);\n+      return new ApplicationUpdateDetails(new NotImplementedException(errorMessage));\n+    }\n+  }\n+\n+  // Updates an application config by applying given update actions. The app should know how to apply these actions\n+  // to its config.\n+  private ApplicationUpdateDetails updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,\n+                                                             @Nullable String appVersion,\n+                                                             @Nullable String currentConfigStr,\n+                                                             ProgramTerminator programTerminator,\n+                                                             ArtifactDetail artifactDetail,\n+                                                             List<ApplicationConfigUpdateAction> updateActions,\n+                                                             @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                             boolean updateSchedules) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      throw new InvalidArtifactException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                         artifactDetail.getDescriptor().getArtifactId(), namespaceId));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+        Artifacts.toProtoArtifactId(namespaceId, artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+    ClassLoader artifactClassLoader =\n+        artifactRepository.createArtifactClassLoader(artifactDetail.getDescriptor().getLocation(),\n+                                                     classLoaderImpersonator);\n+\n+    String updatedAppConfig = \"\";\n+    DefaultApplicationUpdateContext updateContext =\n+        new DefaultApplicationUpdateContext(namespaceId, applicationId, artifactDetail.getDescriptor().getArtifactId(),\n+                                            artifactRepository, currentConfigStr, updateActions);\n+\n+    // Run config update logic for the application to generate updated config.\n+    try {\n+      Object appMain = artifactClassLoader.loadClass(appClass.getClassName()).newInstance();\n+      if (!(appMain instanceof Application)) {\n+        throw new IllegalStateException(\n+            String.format(\"Application main class is of invalid type: %s\",\n+                          appMain.getClass().getName()));\n+      }\n+      Application app = (Application) appMain;\n+      Type configType = Artifacts.getConfigType(app.getClass());\n+      try {\n+        ApplicationUpdateResult<?> updateResult = app.updateConfig(updateContext);\n+        updatedAppConfig = GSON.toJson(updateResult.getNewConfig(), configType);\n+      } catch (UnsupportedOperationException ex) {\n+        String errorMessage = String.format(\"application of type %s does not support update.\",\n+                                            appMain.getClass().getName());\n+        LOG.error(\"Application update failed due to \" + errorMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2OTQzMw==", "bodyText": "what are the different exception that can be thrown here? Not all exceptions have a cause", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435469433", "createdAt": "2020-06-04T18:36:14Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      LOG.error(\"No artifacts found for artifact {} \", currentArtifact);\n+      throw new InternalError(\"Issues in trying to find application artifact for upgrading app \" + appId);\n+    }\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(availableArtifacts.size() - 1);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+    if (candidateArtifactVersion.getVersion() == null) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version '%s' is invalid\", candidateArtifact.getVersion()));\n+    }\n+\n+    // Check conditions for validity of candidate artifact such as name and scope should be same. Also check that\n+    // candidate artifact should have higher version than current artifact.\n+    // In ideal cases, these conditions should never happen.\n+    if (!currentArtifact.getName().equals(candidateArtifact.getName())) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact name %s does not match with current name %s.\", candidateArtifact.getName(),\n+          currentArtifact.getName()));\n+    }\n+    if (currentArtifact.getScope() != candidateArtifact.getScope()) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact scope %s does not match with current name %s.\", candidateArtifact.getScope(),\n+          currentArtifact.getScope()));\n+    }\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      throw new InvalidArtifactException(String.format(\n+          \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+          currentArtifact.getVersion()));\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+    try {\n+      ApplicationUpdateDetails detail =\n+          updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false);\n+      LOG.debug(\"Application upgrade successful. Update details: {}. Error: {}\", detail.getUpdateDetails(),\n+                detail.getError());\n+      return new ApplicationUpdateDetails(\"upgrade successful.\", null);\n+    } catch (UnsupportedOperationException E) {\n+      String errorMessage = String.format(\"Upgrade failed for application %s as artifact %s does not support upgrade.\",\n+                                          appId, newArtifact);\n+      return new ApplicationUpdateDetails(new NotImplementedException(errorMessage));\n+    }\n+  }\n+\n+  // Updates an application config by applying given update actions. The app should know how to apply these actions\n+  // to its config.\n+  private ApplicationUpdateDetails updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,\n+                                                             @Nullable String appVersion,\n+                                                             @Nullable String currentConfigStr,\n+                                                             ProgramTerminator programTerminator,\n+                                                             ArtifactDetail artifactDetail,\n+                                                             List<ApplicationConfigUpdateAction> updateActions,\n+                                                             @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                             boolean updateSchedules) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      throw new InvalidArtifactException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                         artifactDetail.getDescriptor().getArtifactId(), namespaceId));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+        Artifacts.toProtoArtifactId(namespaceId, artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+    ClassLoader artifactClassLoader =\n+        artifactRepository.createArtifactClassLoader(artifactDetail.getDescriptor().getLocation(),\n+                                                     classLoaderImpersonator);\n+\n+    String updatedAppConfig = \"\";\n+    DefaultApplicationUpdateContext updateContext =\n+        new DefaultApplicationUpdateContext(namespaceId, applicationId, artifactDetail.getDescriptor().getArtifactId(),\n+                                            artifactRepository, currentConfigStr, updateActions);\n+\n+    // Run config update logic for the application to generate updated config.\n+    try {\n+      Object appMain = artifactClassLoader.loadClass(appClass.getClassName()).newInstance();\n+      if (!(appMain instanceof Application)) {\n+        throw new IllegalStateException(\n+            String.format(\"Application main class is of invalid type: %s\",\n+                          appMain.getClass().getName()));\n+      }\n+      Application app = (Application) appMain;\n+      Type configType = Artifacts.getConfigType(app.getClass());\n+      try {\n+        ApplicationUpdateResult<?> updateResult = app.updateConfig(updateContext);\n+        updatedAppConfig = GSON.toJson(updateResult.getNewConfig(), configType);\n+      } catch (UnsupportedOperationException ex) {\n+        String errorMessage = String.format(\"application of type %s does not support update.\",\n+                                            appMain.getClass().getName());\n+        LOG.error(\"Application update failed due to \" + errorMessage);\n+        throw ex;\n+      }\n+    } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 228}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODkzMDc2", "url": "https://github.com/cdapio/cdap/pull/12233#pullrequestreview-424893076", "createdAt": "2020-06-04T23:05:13Z", "commit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "state": "COMMENTED", "comments": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMzowNToxM1rOGfa44A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMzo0NzozNVrOGfb_lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5OTU4NA==", "bodyText": "indentation should be 2 spaces", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435599584", "createdAt": "2020-06-04T23:05:13Z", "author": {"login": "albertshau"}, "path": "cdap-api/src/main/java/io/cdap/cdap/api/app/Application.java", "diffHunk": "@@ -46,7 +46,8 @@ default boolean isUpdateSupported() {\n    * @param applicationUpdateContext Used to access methods helpful for operations like upgrading plugin version for\n    * config.\n    */\n-  default ApplicationUpdateResult<T> updateConfig(ApplicationUpdateContext applicationUpdateContext) {\n+  default ApplicationUpdateResult<T> updateConfig(ApplicationUpdateContext applicationUpdateContext)\n+      throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5OTgwOQ==", "bodyText": "javadoc should include @throws and describe what will happen if an exception is thrown.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435599809", "createdAt": "2020-06-04T23:05:57Z", "author": {"login": "albertshau"}, "path": "cdap-api/src/main/java/io/cdap/cdap/api/app/Application.java", "diffHunk": "@@ -46,7 +46,8 @@ default boolean isUpdateSupported() {\n    * @param applicationUpdateContext Used to access methods helpful for operations like upgrading plugin version for\n    * config.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5OTkxNg==", "bodyText": "don't put TODOs in the api", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435599916", "createdAt": "2020-06-04T23:06:18Z", "author": {"login": "albertshau"}, "path": "cdap-api/src/main/java/io/cdap/cdap/api/app/ApplicationUpdateContext.java", "diffHunk": "@@ -62,12 +62,14 @@\n    *         Returns empty list if no artifact for the plugin found.\n    */\n   default List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n-                                              @Nullable ArtifactVersionRange pluginRange) {\n+                                              @Nullable ArtifactVersionRange pluginRange) throws Exception {\n     return getPluginArtifacts(pluginType, pluginName, pluginScope, pluginRange, Integer.MAX_VALUE);\n   }\n \n   /**\n    * Gets list of plugin artifacts based on given parameters in sorted in ascending order by version.\n+   * Returns plugin artifacts using given filters in ascending order.\n+   * TODO: Pass ArtifactSortOrder as argument for better flexibility.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMDI2Ng==", "bodyText": "doesn't need to be final", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435600266", "createdAt": "2020-06-04T23:07:34Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,56 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMDMxMA==", "bodyText": "doesn't need to be final", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435600310", "createdAt": "2020-06-04T23:07:43Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,56 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") final String namespaceId,\n+                                 @PathParam(\"app-id\") final String appName) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMDc4MA==", "bodyText": "is this the right exception?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435600780", "createdAt": "2020-06-04T23:09:25Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMTQzMA==", "bodyText": "should update this comment", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435601430", "createdAt": "2020-06-04T23:11:24Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,160 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @return\n+   * @throws Exception\n+   */\n+  public ApplicationUpdateDetails upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.warn(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetails(new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+        ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+        artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), Integer.MAX_VALUE,\n+                                                ArtifactSortOrder.ASC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ1MTQ1NA=="}, "originalCommit": {"oid": "0cf76f6579ed8b50c43d6eb616b1eb7414a2ca74"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjM5Mg==", "bodyText": "This is a confusing error message because the user didn't request any artifact version, all they did was make an upgrade call. Would be better to say something like:\nThe current artifact has a version higher than any existing artifact.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435602392", "createdAt": "2020-06-04T23:14:37Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjU5Mg==", "bodyText": "indentation", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435602592", "createdAt": "2020-06-04T23:15:20Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjY4Mw==", "bodyText": "remove inline comment", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435602683", "createdAt": "2020-06-04T23:15:40Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false, \"Upgrade\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjgyNA==", "bodyText": "indentation, variables are not lined up", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435602824", "createdAt": "2020-06-04T23:16:02Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjk1Nw==", "bodyText": "this can't be null right?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435602957", "createdAt": "2020-06-04T23:16:30Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMzQxNA==", "bodyText": "also, shouldn't need to pass in namespace, app, or version is ApplicationId is passed in.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435603414", "createdAt": "2020-06-04T23:18:02Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjk1Nw=="}, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDEwNg==", "bodyText": "the type is a java classname that will likely just confused people. You can just say that the application does not support updates.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435604106", "createdAt": "2020-06-04T23:20:22Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading appliation artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      // This should not be possible as at least the current used artifact should be there.\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\", error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"Requested artifact version %s is older than current artifact version %s.\", candidateArtifact.getVersion(),\n+        currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed.\" , error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+        new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, appId.getParent(), appId.getApplication(), null,\n+                                    currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                    upgradeActions, ownerAdmin.getOwner(appId), /*updateSchedules=*/false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId applicationId,\n+                                                             NamespaceId namespaceId,\n+                                                             @Nullable String appName,\n+                                                             @Nullable String appVersion,\n+                                                             @Nullable String currentConfigStr,\n+                                                             ProgramTerminator programTerminator,\n+                                                             ArtifactDetail artifactDetail,\n+                                                             List<ApplicationConfigUpdateAction> updateActions,\n+                                                             @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                             boolean updateSchedules,\n+                                                             String userAction) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      // This should never happen.\n+      throw new IllegalStateException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                         artifactDetail.getDescriptor().getArtifactId(), namespaceId));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+      Artifacts.toProtoArtifactId(namespaceId, artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+    ClassLoader artifactClassLoader =\n+      artifactRepository.createArtifactClassLoader(artifactDetail.getDescriptor().getLocation(),\n+                                                   classLoaderImpersonator);\n+\n+    String updatedAppConfig = \"\";\n+    DefaultApplicationUpdateContext updateContext =\n+      new DefaultApplicationUpdateContext(namespaceId, applicationId, artifactDetail.getDescriptor().getArtifactId(),\n+                                          artifactRepository, currentConfigStr, updateActions);\n+\n+    // Run config update logic for the application to generate updated config.\n+    Object appMain = artifactClassLoader.loadClass(appClass.getClassName()).newInstance();\n+    if (!(appMain instanceof Application)) {\n+      throw new IllegalStateException(\n+        String.format(\"Application main class is of invalid type: %s\",\n+                      appMain.getClass().getName()));\n+    }\n+    Application app = (Application) appMain;\n+    Type configType = Artifacts.getConfigType(app.getClass());\n+    if (!app.isUpdateSupported()) {\n+      String status = String.format(\"%s failed.\", userAction);\n+      String errorMessage = String.format(\"application of type %s does not support update.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDUwMw==", "bodyText": "indentation", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435604503", "createdAt": "2020-06-04T23:21:44Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/DataPipelineApp.java", "diffHunk": "@@ -76,4 +78,17 @@ public void configure() {\n       schedule(scheduleBuilder.triggerByTime(timeSchedule));\n     }\n   }\n+\n+  @Override\n+  public boolean isUpdateSupported() {\n+    return true;\n+  }\n+\n+  @Override\n+  public ApplicationUpdateResult<ETLBatchConfig> updateConfig(ApplicationUpdateContext updateContext)\n+      throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDYyMw==", "bodyText": "indentation", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435604623", "createdAt": "2020-06-04T23:22:14Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/test/java/io/cdap/cdap/datapipeline/DataPipelineTest.java", "diffHunk": "@@ -3493,4 +3520,175 @@ private long getMetric(ApplicationId appId, String metric) {\n                                                Constants.Metrics.Tag.WORKFLOW, SmartWorkflow.NAME);\n     return getMetricsManager().getTotalMetric(tags, \"user.\" + metric);\n   }\n+\n+  /* Unit test tests upgrade for a deployed application.\n+     1. Deploy an application with older application artifact (1.0.0) and older filter plugin version (1.0.0).\n+     2. Add new version of application artifact (1.0.1) and filter plugin artifact (1.1.0).\n+     3. Upgrade the older deployed application.\n+     4. Verify that after upgrading, application artifact and filter plugin artifact is upgraded to use latest version\n+        in its config.\n+   */\n+  @Test\n+  public void testSimpleUpgradePipelines() throws Exception {\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"1.0.0\");\n+\n+    Engine engine = Engine.MAPREDUCE;\n+    String sourceName = \"testSource\" + engine.name();\n+    String sinkName = \"testSink\" + engine.name();\n+    ETLBatchConfig etlConfig = ETLBatchConfig.builder()\n+        .setEngine(engine)\n+        .addStage(new ETLStage(\"source\", MockSource.getPlugin(sourceName)))\n+        .addStage(new ETLStage(\"filter\", PluggableFilterTransform.getPlugin(\n+            ValueFilter.NAME, ValueFilter.getProperties(\"${field}\", \"${value}\"), currentArtifactSelector)))\n+        .addStage(new ETLStage(\"sink\", MockSink.getPlugin(sinkName)))\n+        .addConnection(\"source\", \"filter\")\n+        .addConnection(\"filter\", \"sink\")\n+        .build();\n+\n+    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n+    ApplicationId appId = NamespaceId.DEFAULT.app(\"sparkProgramTest\");\n+    // Deploy app with artifact version 1.0.0.\n+    ApplicationManager appManager = deployApplication(appId, appRequest);\n+    ApplicationDetail oldAppDetail = getAppDetail(appId);\n+    ETLBatchConfig oldBatchConfig = GSON.fromJson(oldAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> oldStageMap = oldBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Upgrade application.\n+    appManager.upgrade();\n+\n+    ApplicationDetail upgradedAppDetail = getAppDetail(appId);\n+    ETLBatchConfig newBatchConfig = GSON.fromJson(upgradedAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> newStageMap = newBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Compare stages that should be same after upgrade.\n+    Assert.assertEquals(oldStageMap.get(\"source\"), newStageMap.get(\"source\"));\n+    Assert.assertEquals(oldStageMap.get(\"sink\"), newStageMap.get(\"sink\"));\n+\n+    // Verify that after upgrade, application upgrades artifact version to latest version available.\n+    Assert.assertEquals(upgradedAppDetail.getArtifact().getVersion(), UPGRADE_APP_ARTIFACT_ID_2.getVersion());\n+    // Check if the filter stage, for which version should be upgraded to desired version in SYSTEM scope.\n+    ETLPlugin upgradedPlugin = newStageMap.get(\"filter\").getPlugin();\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getVersion(), \"1.1.0\");\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getApiArtifactScope(), ArtifactScope.SYSTEM);\n+  }\n+\n+  /* Unit test tests upgrade for a deployed application with a plugin using plugin range.\n+   1. Deploy an application with older application artifact (1.0.0) and older filter plugin version with range\n+      [1.0.0-1.0.5).\n+   2. Add multiple versions of same application artifact with latest being (1.2.0).\n+   3. Bind newer version of filter plugin 1.1.0 with it.\n+   3. Upgrade the older deployed application.\n+   4. Verify that after upgrading, application artifact and filter plugin artifact is upgraded to use latest version\n+      in its config. Also verify that plugin version range for filter stage is changed to use newest version of plugin.\n+ */\n+  @Test\n+  public void testUpgradePipelinesWithPluginRange() throws Exception {\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"[1.0.0,1.0.5)\");\n+\n+    Engine engine = Engine.MAPREDUCE;\n+    String sourceName = \"testSource\" + engine.name();\n+    String sinkName = \"testSink\" + engine.name();\n+    ETLBatchConfig etlConfig = ETLBatchConfig.builder()\n+        .setEngine(engine)\n+        .addStage(new ETLStage(\"source\", MockSource.getPlugin(sourceName)))\n+        .addStage(new ETLStage(\"filter\", PluggableFilterTransform.getPlugin(\n+            ValueFilter.NAME, ValueFilter.getProperties(\"${field}\", \"${value}\"), currentArtifactSelector)))\n+        .addStage(new ETLStage(\"sink\", MockSink.getPlugin(sinkName)))\n+        .addConnection(\"source\", \"filter\")\n+        .addConnection(\"filter\", \"sink\")\n+        .build();\n+\n+    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n+    ApplicationId appId = NamespaceId.DEFAULT.app(\"sparkProgramTest\");\n+    // Deploy app with artifact version 1.0.0.\n+    ApplicationManager appManager = deployApplication(appId, appRequest);\n+    ApplicationDetail oldAppDetail = getAppDetail(appId);\n+    ETLBatchConfig oldBatchConfig = GSON.fromJson(oldAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> oldStageMap = oldBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Upgrade application.\n+    appManager.upgrade();\n+\n+    ApplicationDetail upgradedAppDetail = getAppDetail(appId);\n+    ETLBatchConfig newBatchConfig = GSON.fromJson(upgradedAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> newStageMap = newBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Compare stages that should be same after upgrade.\n+    Assert.assertEquals(oldStageMap.get(\"source\"), newStageMap.get(\"source\"));\n+    Assert.assertEquals(oldStageMap.get(\"sink\"), newStageMap.get(\"sink\"));\n+\n+    // Verify that after upgrade, application upgrades artifact version to latest version available.\n+    Assert.assertEquals(upgradedAppDetail.getArtifact().getVersion(), UPGRADE_APP_ARTIFACT_ID_2.getVersion());\n+    // Check if the filter stage, for which version range should be upgraded to include latest plugin version in SYSTEM\n+    // scope.\n+    ETLPlugin upgradedPlugin = newStageMap.get(\"filter\").getPlugin();\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getVersion(), \"[1.0.0,1.1.0]\");\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getApiArtifactScope(), ArtifactScope.SYSTEM);\n+  }\n+\n+  /* Unit test tests upgrade for a deployed application with a plugin using plugin range.\n+ 1. Deploy an application with older application artifact (1.0.0) and filter plugin version with range\n+    [1.0.0-2.0.0) to make sure latest version of plugin should be included in it.\n+ 2. Add multiple versions of same application artifact with latest being (1.2.0).\n+ 3. Bind newer version of filter plugin 1.1.0 with it.\n+ 3. Upgrade the older deployed application.\n+ 4. Verify that after upgrading, application artifact uses latest version in its config.\n+    But plugin range is not updated as latest version of plugin is still included in the range.\n+*/\n+  @Test\n+  public void testUpgradePipelinesWithNoChangeInPluginRange() throws Exception {\n+    // Since filter plugin is not going to upgrade due to its range, the scope of filter plugin still stays USER.\n+    // Add a filter plugin in DEFAULT namespace in the proposed range for upgraded artifact version.\n+    // Needed to make deployment successful.\n+    addPluginArtifact(NamespaceId.DEFAULT.artifact(\"test-plugins\", \"1.1.0\"), UPGRADE_APP_ARTIFACT_ID_2,\n+                      PluggableFilterTransform.class);\n+\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"[1.0.0,2.0.0)\");\n+\n+    Engine engine = Engine.MAPREDUCE;\n+    String sourceName = \"testSource\" + engine.name();\n+    String sinkName = \"testSink\" + engine.name();\n+    ETLBatchConfig etlConfig = ETLBatchConfig.builder()\n+        .setEngine(engine)\n+        .addStage(new ETLStage(\"source\", MockSource.getPlugin(sourceName)))\n+        .addStage(new ETLStage(\"filter\", PluggableFilterTransform.getPlugin(\n+            ValueFilter.NAME, ValueFilter.getProperties(\"${field}\", \"${value}\"), currentArtifactSelector)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDY1Mg==", "bodyText": "indentation", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435604652", "createdAt": "2020-06-04T23:22:20Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/test/java/io/cdap/cdap/datapipeline/DataPipelineTest.java", "diffHunk": "@@ -3493,4 +3520,175 @@ private long getMetric(ApplicationId appId, String metric) {\n                                                Constants.Metrics.Tag.WORKFLOW, SmartWorkflow.NAME);\n     return getMetricsManager().getTotalMetric(tags, \"user.\" + metric);\n   }\n+\n+  /* Unit test tests upgrade for a deployed application.\n+     1. Deploy an application with older application artifact (1.0.0) and older filter plugin version (1.0.0).\n+     2. Add new version of application artifact (1.0.1) and filter plugin artifact (1.1.0).\n+     3. Upgrade the older deployed application.\n+     4. Verify that after upgrading, application artifact and filter plugin artifact is upgraded to use latest version\n+        in its config.\n+   */\n+  @Test\n+  public void testSimpleUpgradePipelines() throws Exception {\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"1.0.0\");\n+\n+    Engine engine = Engine.MAPREDUCE;\n+    String sourceName = \"testSource\" + engine.name();\n+    String sinkName = \"testSink\" + engine.name();\n+    ETLBatchConfig etlConfig = ETLBatchConfig.builder()\n+        .setEngine(engine)\n+        .addStage(new ETLStage(\"source\", MockSource.getPlugin(sourceName)))\n+        .addStage(new ETLStage(\"filter\", PluggableFilterTransform.getPlugin(\n+            ValueFilter.NAME, ValueFilter.getProperties(\"${field}\", \"${value}\"), currentArtifactSelector)))\n+        .addStage(new ETLStage(\"sink\", MockSink.getPlugin(sinkName)))\n+        .addConnection(\"source\", \"filter\")\n+        .addConnection(\"filter\", \"sink\")\n+        .build();\n+\n+    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n+    ApplicationId appId = NamespaceId.DEFAULT.app(\"sparkProgramTest\");\n+    // Deploy app with artifact version 1.0.0.\n+    ApplicationManager appManager = deployApplication(appId, appRequest);\n+    ApplicationDetail oldAppDetail = getAppDetail(appId);\n+    ETLBatchConfig oldBatchConfig = GSON.fromJson(oldAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> oldStageMap = oldBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Upgrade application.\n+    appManager.upgrade();\n+\n+    ApplicationDetail upgradedAppDetail = getAppDetail(appId);\n+    ETLBatchConfig newBatchConfig = GSON.fromJson(upgradedAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> newStageMap = newBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Compare stages that should be same after upgrade.\n+    Assert.assertEquals(oldStageMap.get(\"source\"), newStageMap.get(\"source\"));\n+    Assert.assertEquals(oldStageMap.get(\"sink\"), newStageMap.get(\"sink\"));\n+\n+    // Verify that after upgrade, application upgrades artifact version to latest version available.\n+    Assert.assertEquals(upgradedAppDetail.getArtifact().getVersion(), UPGRADE_APP_ARTIFACT_ID_2.getVersion());\n+    // Check if the filter stage, for which version should be upgraded to desired version in SYSTEM scope.\n+    ETLPlugin upgradedPlugin = newStageMap.get(\"filter\").getPlugin();\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getVersion(), \"1.1.0\");\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getApiArtifactScope(), ArtifactScope.SYSTEM);\n+  }\n+\n+  /* Unit test tests upgrade for a deployed application with a plugin using plugin range.\n+   1. Deploy an application with older application artifact (1.0.0) and older filter plugin version with range\n+      [1.0.0-1.0.5).\n+   2. Add multiple versions of same application artifact with latest being (1.2.0).\n+   3. Bind newer version of filter plugin 1.1.0 with it.\n+   3. Upgrade the older deployed application.\n+   4. Verify that after upgrading, application artifact and filter plugin artifact is upgraded to use latest version\n+      in its config. Also verify that plugin version range for filter stage is changed to use newest version of plugin.\n+ */\n+  @Test\n+  public void testUpgradePipelinesWithPluginRange() throws Exception {\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"[1.0.0,1.0.5)\");\n+\n+    Engine engine = Engine.MAPREDUCE;\n+    String sourceName = \"testSource\" + engine.name();\n+    String sinkName = \"testSink\" + engine.name();\n+    ETLBatchConfig etlConfig = ETLBatchConfig.builder()\n+        .setEngine(engine)\n+        .addStage(new ETLStage(\"source\", MockSource.getPlugin(sourceName)))\n+        .addStage(new ETLStage(\"filter\", PluggableFilterTransform.getPlugin(\n+            ValueFilter.NAME, ValueFilter.getProperties(\"${field}\", \"${value}\"), currentArtifactSelector)))\n+        .addStage(new ETLStage(\"sink\", MockSink.getPlugin(sinkName)))\n+        .addConnection(\"source\", \"filter\")\n+        .addConnection(\"filter\", \"sink\")\n+        .build();\n+\n+    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n+    ApplicationId appId = NamespaceId.DEFAULT.app(\"sparkProgramTest\");\n+    // Deploy app with artifact version 1.0.0.\n+    ApplicationManager appManager = deployApplication(appId, appRequest);\n+    ApplicationDetail oldAppDetail = getAppDetail(appId);\n+    ETLBatchConfig oldBatchConfig = GSON.fromJson(oldAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> oldStageMap = oldBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Upgrade application.\n+    appManager.upgrade();\n+\n+    ApplicationDetail upgradedAppDetail = getAppDetail(appId);\n+    ETLBatchConfig newBatchConfig = GSON.fromJson(upgradedAppDetail.getConfiguration(), ETLBatchConfig.class);\n+    Map<String, ETLStage> newStageMap = newBatchConfig.getStages().stream().collect(\n+        Collectors.toMap(ETLStage::getName, e -> e));\n+\n+    // Compare stages that should be same after upgrade.\n+    Assert.assertEquals(oldStageMap.get(\"source\"), newStageMap.get(\"source\"));\n+    Assert.assertEquals(oldStageMap.get(\"sink\"), newStageMap.get(\"sink\"));\n+\n+    // Verify that after upgrade, application upgrades artifact version to latest version available.\n+    Assert.assertEquals(upgradedAppDetail.getArtifact().getVersion(), UPGRADE_APP_ARTIFACT_ID_2.getVersion());\n+    // Check if the filter stage, for which version range should be upgraded to include latest plugin version in SYSTEM\n+    // scope.\n+    ETLPlugin upgradedPlugin = newStageMap.get(\"filter\").getPlugin();\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getVersion(), \"[1.0.0,1.1.0]\");\n+    Assert.assertEquals(upgradedPlugin.getArtifactConfig().getApiArtifactScope(), ArtifactScope.SYSTEM);\n+  }\n+\n+  /* Unit test tests upgrade for a deployed application with a plugin using plugin range.\n+ 1. Deploy an application with older application artifact (1.0.0) and filter plugin version with range\n+    [1.0.0-2.0.0) to make sure latest version of plugin should be included in it.\n+ 2. Add multiple versions of same application artifact with latest being (1.2.0).\n+ 3. Bind newer version of filter plugin 1.1.0 with it.\n+ 3. Upgrade the older deployed application.\n+ 4. Verify that after upgrading, application artifact uses latest version in its config.\n+    But plugin range is not updated as latest version of plugin is still included in the range.\n+*/\n+  @Test\n+  public void testUpgradePipelinesWithNoChangeInPluginRange() throws Exception {\n+    // Since filter plugin is not going to upgrade due to its range, the scope of filter plugin still stays USER.\n+    // Add a filter plugin in DEFAULT namespace in the proposed range for upgraded artifact version.\n+    // Needed to make deployment successful.\n+    addPluginArtifact(NamespaceId.DEFAULT.artifact(\"test-plugins\", \"1.1.0\"), UPGRADE_APP_ARTIFACT_ID_2,\n+                      PluggableFilterTransform.class);\n+\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"[1.0.0,2.0.0)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDgwMA==", "bodyText": "indentation (same with rest of test classes)", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435604800", "createdAt": "2020-06-04T23:22:48Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/test/java/io/cdap/cdap/datapipeline/DataPipelineTest.java", "diffHunk": "@@ -3493,4 +3520,175 @@ private long getMetric(ApplicationId appId, String metric) {\n                                                Constants.Metrics.Tag.WORKFLOW, SmartWorkflow.NAME);\n     return getMetricsManager().getTotalMetric(tags, \"user.\" + metric);\n   }\n+\n+  /* Unit test tests upgrade for a deployed application.\n+     1. Deploy an application with older application artifact (1.0.0) and older filter plugin version (1.0.0).\n+     2. Add new version of application artifact (1.0.1) and filter plugin artifact (1.1.0).\n+     3. Upgrade the older deployed application.\n+     4. Verify that after upgrading, application artifact and filter plugin artifact is upgraded to use latest version\n+        in its config.\n+   */\n+  @Test\n+  public void testSimpleUpgradePipelines() throws Exception {\n+    ArtifactSelectorConfig currentArtifactSelector =\n+        new ArtifactSelectorConfig(ArtifactScope.USER.name(), \"test-plugins\", \"1.0.0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNTI2MQ==", "bodyText": "don't think this should exist here either. The caller should make sure they handle the null scope case.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435605261", "createdAt": "2020-06-04T23:24:28Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/ArtifactSelectorConfig.java", "diffHunk": "@@ -85,4 +87,9 @@ public String toString() {\n       \", version='\" + version + '\\'' +\n       '}';\n   }\n+\n+  public io.cdap.cdap.api.artifact.ArtifactScope getApiArtifactScope() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNTUwNg==", "bodyText": "indentation", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435605506", "createdAt": "2020-06-04T23:25:15Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLConfig.java", "diffHunk": "@@ -74,6 +77,18 @@ protected ETLConfig(Set<ETLStage> stages, Set<Connection> connections,\n     this.source = null;\n     this.sinks = new ArrayList<>();\n     this.transforms = new ArrayList<>();\n+    this.comments = new ArrayList<>();\n+  }\n+\n+  protected ETLConfig(Set<ETLStage> stages, Set<Connection> connections,\n+      Resources resources, Resources driverResources, Resources clientResources,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNjQ3NA==", "bodyText": "if it can return null, the method should be annotated with @Nullable", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435606474", "createdAt": "2020-06-04T23:28:41Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNjg0Mw==", "bodyText": "if they've explicitly given a range with an upper bound, is it really correct to increase that range?\nTo me, it makes more sense to choose the highest artifact within that range.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435606843", "createdAt": "2020-06-04T23:30:03Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNzQyMg==", "bodyText": "there are too many levels of nesting in this method. If the parsing is the only thing that can throw an exception, you remove one level of nesting by doing:\nArtifactVersionRange currentVersionRange;\ntry {\n  currentVersionRange = ...\n} catch (...) {\n  ...\n}\n\n// rest of logic", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435607422", "createdAt": "2020-06-04T23:32:00Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.\n+   *\n+   * @param newPlugin New candidate plugin for updating plugin artifact.\n+   * @return version string to be used for new plugin. Might be fixed version/version range string depending on\n+   *         current use.\n+   */\n+  private String getUpgradedVersionString(ArtifactId newPlugin) {\n+    try {\n+      ArtifactVersionRange currentVersionRange =\n+        io.cdap.cdap.api.artifact.ArtifactVersionRange.parse(plugin.getArtifactConfig().getVersion());\n+      if (!currentVersionRange.isExactVersion()) {\n+        // Current plugin version is version range.\n+        if (currentVersionRange.versionIsInRange(newPlugin.getVersion())) {\n+          // Do nothing and return as is. Note that plugin scope will not change.\n+          // TODO: Figure out how to change plugin scope if a newer plugin is found but in different scope.\n+          return null;\n+        } else if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) > 0) {\n+          // Current lower version is higher than newer latest version. This should not happen.\n+          LOG.warn(\"Invalid new plugin artifact {} for upgrade for upgrading plugin {} \", newPlugin, plugin);\n+          return null;\n+        } else {\n+          // Increase the upper bound to latest available version.\n+          ArtifactVersionRange newVersionRange =\n+            new ArtifactVersionRange(currentVersionRange.getLower(), currentVersionRange.isLowerInclusive(),\n+                                     newPlugin.getVersion(), /*isUpperInclusive=*/true);\n+          return newVersionRange.getVersionString();\n+        }\n+      } else if (currentVersionRange.isExactVersion()\n+          && currentVersionRange.getLower().compareTo(newPlugin.getVersion()) < 0) {\n+        // Current version is a fixed version and new version is higher than current.\n+        return newPlugin.getVersion().getVersion();\n+      } else {\n+        // Should not happen. Safety check.\n+        return null;\n+      }\n+    } catch (Exception e) {\n+      LOG.warn(\"Issue in parsing version string for plugin, ignoring stage for upgrade {}\", plugin, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxMjQ0Nw==", "bodyText": "when you have a bunch of these ifs, it's more readable to put the short checks at the top and remove a level of nesting. Something like:\nif (currentVersionRange.isExactVersion()) {\n  if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) < 0) {\n    return newPlugin.getVersion().getVersion();\n  }\n  return null;\n}\n.. other logic", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435612447", "createdAt": "2020-06-04T23:38:24Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.\n+   *\n+   * @param newPlugin New candidate plugin for updating plugin artifact.\n+   * @return version string to be used for new plugin. Might be fixed version/version range string depending on\n+   *         current use.\n+   */\n+  private String getUpgradedVersionString(ArtifactId newPlugin) {\n+    try {\n+      ArtifactVersionRange currentVersionRange =\n+        io.cdap.cdap.api.artifact.ArtifactVersionRange.parse(plugin.getArtifactConfig().getVersion());\n+      if (!currentVersionRange.isExactVersion()) {\n+        // Current plugin version is version range.\n+        if (currentVersionRange.versionIsInRange(newPlugin.getVersion())) {\n+          // Do nothing and return as is. Note that plugin scope will not change.\n+          // TODO: Figure out how to change plugin scope if a newer plugin is found but in different scope.\n+          return null;\n+        } else if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) > 0) {\n+          // Current lower version is higher than newer latest version. This should not happen.\n+          LOG.warn(\"Invalid new plugin artifact {} for upgrade for upgrading plugin {} \", newPlugin, plugin);\n+          return null;\n+        } else {\n+          // Increase the upper bound to latest available version.\n+          ArtifactVersionRange newVersionRange =\n+            new ArtifactVersionRange(currentVersionRange.getLower(), currentVersionRange.isLowerInclusive(),\n+                                     newPlugin.getVersion(), /*isUpperInclusive=*/true);\n+          return newVersionRange.getVersionString();\n+        }\n+      } else if (currentVersionRange.isExactVersion()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNDkwMQ==", "bodyText": "this message is confusing and not very useful. Imagine seeing this in a log file, you won't be able to do anything with it. It doesn't mention which pipeline or which stage within the pipeline.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435614901", "createdAt": "2020-06-04T23:41:19Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.\n+   *\n+   * @param newPlugin New candidate plugin for updating plugin artifact.\n+   * @return version string to be used for new plugin. Might be fixed version/version range string depending on\n+   *         current use.\n+   */\n+  private String getUpgradedVersionString(ArtifactId newPlugin) {\n+    try {\n+      ArtifactVersionRange currentVersionRange =\n+        io.cdap.cdap.api.artifact.ArtifactVersionRange.parse(plugin.getArtifactConfig().getVersion());\n+      if (!currentVersionRange.isExactVersion()) {\n+        // Current plugin version is version range.\n+        if (currentVersionRange.versionIsInRange(newPlugin.getVersion())) {\n+          // Do nothing and return as is. Note that plugin scope will not change.\n+          // TODO: Figure out how to change plugin scope if a newer plugin is found but in different scope.\n+          return null;\n+        } else if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) > 0) {\n+          // Current lower version is higher than newer latest version. This should not happen.\n+          LOG.warn(\"Invalid new plugin artifact {} for upgrade for upgrading plugin {} \", newPlugin, plugin);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNTIzMQ==", "bodyText": "it would be useful to give a couple inputs and outputs", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435615231", "createdAt": "2020-06-04T23:41:44Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +104,117 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(),\n+                                       ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNjg0Mw=="}, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNTUyNg==", "bodyText": "indentation", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435615526", "createdAt": "2020-06-04T23:42:04Z", "author": {"login": "albertshau"}, "path": "cdap-client/src/main/java/io/cdap/cdap/client/ApplicationClient.java", "diffHunk": "@@ -230,6 +230,25 @@ public ApplicationDetail get(ApplicationId appId)\n     return ObjectResponse.fromJsonBody(response, new TypeToken<List<PluginInstanceDetail>>() { }).getResponseObject();\n   }\n \n+  /**\n+   * Upgrades an application.\n+   *\n+   * @param app the application to delete\n+   * @throws ApplicationNotFoundException if the application with the given ID was not found\n+   * @throws IOException if a network error occurred\n+   * @throws UnauthenticatedException if the request is not authorized successfully in the gateway server\n+   */\n+  public void upgradeApplication(ApplicationId app)\n+      throws ApplicationNotFoundException, IOException, UnauthenticatedException, UnauthorizedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNjY5MQ==", "bodyText": "this should match what is given as the input except have additional fields for status code and message. The javadoc for the REST API seems to indicate the input is an 'appId' variable of type string.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435616691", "createdAt": "2020-06-04T23:43:44Z", "author": {"login": "albertshau"}, "path": "cdap-proto/src/main/java/io/cdap/cdap/proto/ApplicationUpdateDetail.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.proto;\n+\n+import io.cdap.cdap.api.common.HttpErrorStatusProvider;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Represents an application update result of an {@link ApplicationDetail}.\n+ */\n+public class ApplicationUpdateDetail {\n+\n+  private final int statusCode;\n+  private final String error;\n+  private final String updateDetails;\n+  private final ApplicationId applicationId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNzU5NQ==", "bodyText": "looking at some of the other batch endpoints, they return lists of objects like BatchProgramResult. There, appId is a flat field. It also only has an 'error' string and nothing like 'updateDetails'. If the operation is successful, there is no message.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435617595", "createdAt": "2020-06-04T23:47:13Z", "author": {"login": "albertshau"}, "path": "cdap-proto/src/main/java/io/cdap/cdap/proto/ApplicationUpdateDetail.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.proto;\n+\n+import io.cdap.cdap.api.common.HttpErrorStatusProvider;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Represents an application update result of an {@link ApplicationDetail}.\n+ */\n+public class ApplicationUpdateDetail {\n+\n+  private final int statusCode;\n+  private final String error;\n+  private final String updateDetails;\n+  private final ApplicationId applicationId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNjY5MQ=="}, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNzY4Ng==", "bodyText": "should be POST", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435617686", "createdAt": "2020-06-04T23:47:35Z", "author": {"login": "albertshau"}, "path": "cdap-client/src/main/java/io/cdap/cdap/client/ApplicationClient.java", "diffHunk": "@@ -230,6 +230,25 @@ public ApplicationDetail get(ApplicationId appId)\n     return ObjectResponse.fromJsonBody(response, new TypeToken<List<PluginInstanceDetail>>() { }).getResponseObject();\n   }\n \n+  /**\n+   * Upgrades an application.\n+   *\n+   * @param app the application to delete\n+   * @throws ApplicationNotFoundException if the application with the given ID was not found\n+   * @throws IOException if a network error occurred\n+   * @throws UnauthenticatedException if the request is not authorized successfully in the gateway server\n+   */\n+  public void upgradeApplication(ApplicationId app)\n+      throws ApplicationNotFoundException, IOException, UnauthenticatedException, UnauthorizedException {\n+    String path = String.format(\"apps/%s/upgrade\", app.getApplication());\n+    HttpResponse response = restClient.execute(HttpMethod.DELETE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f869607e99cdae1ea124f79938408db5d73617"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDE2NTcx", "url": "https://github.com/cdapio/cdap/pull/12233#pullrequestreview-425016571", "createdAt": "2020-06-05T06:02:51Z", "commit": {"oid": "63e082e95b8094724cfda1ca78c771dca283cbb7"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNjowMjo1MVrOGfha5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzozNDozN1rOGfjhoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNjU5OQ==", "bodyText": "This implementation definitely need to change before releasing. Looping in handler one by one is never a good idea (query and update storage one by one). Please open a JIRA and mark a TODO here.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435706599", "createdAt": "2020-06-05T06:02:51Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,56 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") String namespaceId,\n+                                 @PathParam(\"app-id\") String appName) throws Exception {\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+    ApplicationUpdateDetail detail = applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   * The response will be an array of {@link ApplicationUpdateDetail} object, which either indicates a success (200) or\n+   * failure for each of the requested application in the same order as the request. The failure also indicates reason\n+   * for the error.\n+   */\n+  @POST\n+  @Path(\"/upgrade\")\n+  public void upgradeApplications(FullHttpRequest request, HttpResponder responder,\n+                                  @PathParam(\"namespace-id\") String namespace) throws Exception {\n+    List<ApplicationId> appIds = decodeAndValidateBatchApplication(validateNamespace(namespace), request);\n+    List<ApplicationUpdateDetail> details = new ArrayList<>();\n+    for (ApplicationId appId : appIds) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e082e95b8094724cfda1ca78c771dca283cbb7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNzM0Mg==", "bodyText": "Make a copy instead of just wrapping the incoming list:\nCollections.unmodifiableList(new ArrayList<>(updateActions));", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435707342", "createdAt": "2020-06-05T06:05:32Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e082e95b8094724cfda1ca78c771dca283cbb7"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNzcwMw==", "bodyText": "As I mentioned in previous comment, this casting is not safe. You have to do:\n((Class<C>) TypeToken.of(configType).getRawType()).newInstance;", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435707703", "createdAt": "2020-06-05T06:06:57Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) configType).newInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e082e95b8094724cfda1ca78c771dca283cbb7"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwNzkzNw==", "bodyText": "No need to have else since the if block always terminate the flow (either returning or throwing)", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435707937", "createdAt": "2020-06-05T06:07:41Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e082e95b8094724cfda1ca78c771dca283cbb7"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMjc3NQ==", "bodyText": "Don't log and throw, as this can easily create repeated logs of exceptions.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435722775", "createdAt": "2020-06-05T06:51:51Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        return GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) throws Exception {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = input -> {\n+      // Check if it is from the scoped namespace and should check if plugin is in given range if provided.\n+      return (pluginArtifactNamespace.equals(input.getParent()) &&\n+             (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+    };\n+\n+    try {\n+      // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+        artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                      Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                      pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {\n+          pluginArtifacts.add(plugin);\n+        }\n+      }\n+    } catch (PluginNotExistsException e) {\n+      LOG.debug(\"No plugin found for plugin {} of type {} in scope {} for app {}\",\n+                pluginName, pluginType, pluginScope, applicationId);\n+      return Collections.emptyList();\n+    } catch (Exception e) {\n+      LOG.warn(\"Failed to get plugin details for artifact {} for plugin {} of type {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e082e95b8094724cfda1ca78c771dca283cbb7"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMjk5NQ==", "bodyText": "Is the plugin not exists expected to happen?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435722995", "createdAt": "2020-06-05T06:52:26Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        return GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) throws Exception {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = input -> {\n+      // Check if it is from the scoped namespace and should check if plugin is in given range if provided.\n+      return (pluginArtifactNamespace.equals(input.getParent()) &&\n+             (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+    };\n+\n+    try {\n+      // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+        artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                      Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                      pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {\n+          pluginArtifacts.add(plugin);\n+        }\n+      }\n+    } catch (PluginNotExistsException e) {\n+      LOG.debug(\"No plugin found for plugin {} of type {} in scope {} for app {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e082e95b8094724cfda1ca78c771dca283cbb7"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTUxMw==", "bodyText": "The alignment is off.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435735513", "createdAt": "2020-06-05T07:22:58Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,132 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading application artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"The current artifact has a version higher %s than any existing artifact.\", currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+      new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                     upgradeActions, ownerAdmin.getOwner(appId), false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId appId,\n+                                                            @Nullable String currentConfigStr,\n+                                                            ProgramTerminator programTerminator,\n+                                                            ArtifactDetail artifactDetail,\n+                                                            List<ApplicationConfigUpdateAction> updateActions,\n+                                                            @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                            boolean updateSchedules,\n+                                                            String userAction) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      // This should never happen.\n+      throw new IllegalStateException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                         artifactDetail.getDescriptor().getArtifactId(), appId.getParent()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e082e95b8094724cfda1ca78c771dca283cbb7"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MTA4OA==", "bodyText": "You have to close this to avoid resource leakage by using a try block. The returned type is CloseableClassLoader.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r435741088", "createdAt": "2020-06-05T07:34:37Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,132 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading application artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"The current artifact has a version higher %s than any existing artifact.\", currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+      new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                     upgradeActions, ownerAdmin.getOwner(appId), false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId appId,\n+                                                            @Nullable String currentConfigStr,\n+                                                            ProgramTerminator programTerminator,\n+                                                            ArtifactDetail artifactDetail,\n+                                                            List<ApplicationConfigUpdateAction> updateActions,\n+                                                            @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                            boolean updateSchedules,\n+                                                            String userAction) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      // This should never happen.\n+      throw new IllegalStateException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                         artifactDetail.getDescriptor().getArtifactId(), appId.getParent()));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+      Artifacts.toProtoArtifactId(appId.getParent(), artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+    ClassLoader artifactClassLoader =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63e082e95b8094724cfda1ca78c771dca283cbb7"}, "originalPosition": 176}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NzI5MDA5", "url": "https://github.com/cdapio/cdap/pull/12233#pullrequestreview-425729009", "createdAt": "2020-06-06T09:57:51Z", "commit": {"oid": "3cb06762cacc6c8536c6384380a6e60bf112cabc"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwOTo1Nzo1MlrOGgC8DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxMDowNzozMlrOGgC-Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NTc1Nw==", "bodyText": "Is internal error the only type of error we reported back? Typically we at least differentiate client error (e.g. 404) vs server side one.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436255757", "createdAt": "2020-06-06T09:57:52Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,58 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") String namespaceId,\n+                                 @PathParam(\"app-id\") String appName) throws Exception {\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+    ApplicationUpdateDetail detail = applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   * The response will be an array of {@link ApplicationUpdateDetail} object, which either indicates a success (200) or\n+   * failure for each of the requested application in the same order as the request. The failure also indicates reason\n+   * for the error.\n+   */\n+  @POST\n+  @Path(\"/upgrade\")\n+  public void upgradeApplications(FullHttpRequest request, HttpResponder responder,\n+                                  @PathParam(\"namespace-id\") String namespace) throws Exception {\n+    // TODO: (CDAP-16910) Improve batch API performance as each application upgrade is an event independent of each\n+    //  other.\n+    List<ApplicationId> appIds = decodeAndValidateBatchApplication(validateNamespace(namespace), request);\n+    List<ApplicationUpdateDetail> details = new ArrayList<>();\n+    for (ApplicationId appId : appIds) {\n+      try {\n+        details.add(applicationLifecycleService.upgradeApplication(appId, createProgramTerminator()));\n+      } catch (Exception e) {\n+        ApplicationUpdateDetail errorDetail =\n+          new ApplicationUpdateDetail(appId, new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                                                                   HttpResponseStatus.INTERNAL_SERVER_ERROR));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb06762cacc6c8536c6384380a6e60bf112cabc"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NTc4MQ==", "bodyText": "Typically don't log if the exception is caused by client side error", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436255781", "createdAt": "2020-06-06T09:58:09Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,58 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") String namespaceId,\n+                                 @PathParam(\"app-id\") String appName) throws Exception {\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+    ApplicationUpdateDetail detail = applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(detail));\n+  }\n+\n+  /**\n+   * Upgrades a lis of existing application to use latest version of application artifact and plugin artifacts.\n+   *\n+   * <pre>\n+   * {@code\n+   * [\n+   *   {\"appId\":\"XYZ\"},\n+   *   {\"appId\":\"ABC\"},\n+   *   {\"appId\":\"FOO\"},\n+   * ]\n+   * }\n+   * </pre>\n+   * The response will be an array of {@link ApplicationUpdateDetail} object, which either indicates a success (200) or\n+   * failure for each of the requested application in the same order as the request. The failure also indicates reason\n+   * for the error.\n+   */\n+  @POST\n+  @Path(\"/upgrade\")\n+  public void upgradeApplications(FullHttpRequest request, HttpResponder responder,\n+                                  @PathParam(\"namespace-id\") String namespace) throws Exception {\n+    // TODO: (CDAP-16910) Improve batch API performance as each application upgrade is an event independent of each\n+    //  other.\n+    List<ApplicationId> appIds = decodeAndValidateBatchApplication(validateNamespace(namespace), request);\n+    List<ApplicationUpdateDetail> details = new ArrayList<>();\n+    for (ApplicationId appId : appIds) {\n+      try {\n+        details.add(applicationLifecycleService.upgradeApplication(appId, createProgramTerminator()));\n+      } catch (Exception e) {\n+        ApplicationUpdateDetail errorDetail =\n+          new ApplicationUpdateDetail(appId, new ServiceException(\"Upgrade failed due to internal error.\", null,\n+                                                                   HttpResponseStatus.INTERNAL_SERVER_ERROR));\n+        details.add(errorDetail);\n+        LOG.debug(\"Upgrading application {} failed due to exception \", appId, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb06762cacc6c8536c6384380a6e60bf112cabc"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NTkwMA==", "bodyText": "nit: is not supported", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436255900", "createdAt": "2020-06-06T10:00:20Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(new ArrayList<>(updateActions));\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb06762cacc6c8536c6384380a6e60bf112cabc"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjA4MA==", "bodyText": "If it is commonly expected to happen, log with trace instead of debug.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436256080", "createdAt": "2020-06-06T10:03:44Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(updateActions);\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) configType).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    } else {\n+      try {\n+        return GSON.fromJson(configString, configType);\n+      } catch (JsonSyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                           + \" syntax.\", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) throws Exception {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = input -> {\n+      // Check if it is from the scoped namespace and should check if plugin is in given range if provided.\n+      return (pluginArtifactNamespace.equals(input.getParent()) &&\n+             (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+    };\n+\n+    try {\n+      // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+        artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                      Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                      pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {\n+          pluginArtifacts.add(plugin);\n+        }\n+      }\n+    } catch (PluginNotExistsException e) {\n+      LOG.debug(\"No plugin found for plugin {} of type {} in scope {} for app {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMjk5NQ=="}, "originalCommit": {"oid": "63e082e95b8094724cfda1ca78c771dca283cbb7"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjEwMQ==", "bodyText": "Don't log and throw. It can cause multiple exceptions being logged.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436256101", "createdAt": "2020-06-06T10:04:22Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/DefaultApplicationUpdateContext.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.reflect.TypeToken;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.Config;\n+import io.cdap.cdap.api.app.ApplicationConfigUpdateAction;\n+import io.cdap.cdap.api.app.ApplicationUpdateContext;\n+import io.cdap.cdap.api.artifact.ArtifactId;\n+import io.cdap.cdap.api.artifact.ArtifactScope;\n+import io.cdap.cdap.api.artifact.ArtifactVersion;\n+import io.cdap.cdap.api.artifact.ArtifactVersionRange;\n+import io.cdap.cdap.api.plugin.PluginClass;\n+import io.cdap.cdap.common.id.Id.Artifact;\n+import io.cdap.cdap.common.id.Id.Namespace;\n+import io.cdap.cdap.common.io.CaseInsensitiveEnumTypeAdapterFactory;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactDescriptor;\n+import io.cdap.cdap.internal.app.runtime.artifact.ArtifactRepository;\n+import io.cdap.cdap.internal.app.runtime.plugin.PluginNotExistsException;\n+import io.cdap.cdap.proto.artifact.ArtifactSortOrder;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Default implementation of {@link ApplicationUpdateContext}.\n+ *\n+ * Used during update of an Application config via provided helper methods used during an update action like\n+ * upgrade/downgrade.\n+ */\n+public class DefaultApplicationUpdateContext implements ApplicationUpdateContext {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DefaultApplicationUpdateContext.class);\n+  private static final Gson GSON = new GsonBuilder().\n+    registerTypeAdapterFactory(new CaseInsensitiveEnumTypeAdapterFactory()).create();\n+\n+  private final ArtifactId applicationArtifactId;\n+  private final String configString;\n+  private final List<ApplicationConfigUpdateAction> updateActions;\n+  private final ArtifactRepository artifactRepository;\n+  private final ApplicationId applicationId;\n+  private final NamespaceId namespaceId;\n+\n+  public DefaultApplicationUpdateContext(NamespaceId namespaceId, ApplicationId applicationId,\n+                                         ArtifactId applicationArtifactId, ArtifactRepository artifactRepository,\n+                                         String configString, List<ApplicationConfigUpdateAction> updateActions) {\n+    this.namespaceId = namespaceId;\n+    this.applicationId = applicationId;\n+    this.artifactRepository = artifactRepository;\n+    this.applicationArtifactId = applicationArtifactId;\n+    this.configString = configString;\n+    this.updateActions = Collections.unmodifiableList(new ArrayList<>(updateActions));\n+  }\n+\n+  @Override\n+  public List<ApplicationConfigUpdateAction> getUpdateActions() {\n+    return updateActions;\n+  }\n+\n+  @Override\n+  public <C extends Config> C getConfig(Type configType) {\n+    // Given configtype has to be derived from Config class.\n+    Preconditions.checkArgument(Config.class.isAssignableFrom(TypeToken.of(configType).getRawType()),\n+                                \"Application config type \" + configType + \" not supported. \" +\n+                                \"Type must extend Config and cannot be parameterized.\");\n+    if (configString.isEmpty()) {\n+      try {\n+        return ((Class<C>) TypeToken.of(configType).getRawType()).newInstance();\n+      } catch (Exception e) {\n+        throw new IllegalArgumentException(\"Issue in creating config class of type \" + configType.getTypeName(), e);\n+      }\n+    }\n+\n+    try {\n+      return GSON.fromJson(configString, configType);\n+    } catch (JsonSyntaxException e) {\n+      throw new IllegalArgumentException(\"Invalid JSON application configuration was provided. Please check the\"\n+                                         + \" syntax.\", e);\n+    }\n+  }\n+\n+  @Override\n+  public String getConfigAsString() {\n+    return configString;\n+  }\n+\n+  @Override\n+  public List<ArtifactId> getPluginArtifacts(String pluginType, String pluginName, ArtifactScope pluginScope,\n+                                             @Nullable ArtifactVersionRange pluginRange, int limit) throws Exception {\n+    List<ArtifactId> pluginArtifacts = new ArrayList<>();\n+    NamespaceId pluginArtifactNamespace = ArtifactScope.SYSTEM.equals(pluginScope) ? NamespaceId.SYSTEM : namespaceId;\n+\n+    Predicate<io.cdap.cdap.proto.id.ArtifactId> predicate = input -> {\n+      // Check if it is from the scoped namespace and should check if plugin is in given range if provided.\n+      return (pluginArtifactNamespace.equals(input.getParent()) &&\n+             (pluginRange == null || pluginRange.versionIsInRange(new ArtifactVersion(input.getVersion()))));\n+    };\n+\n+    try {\n+      // TODO: Pass ArtifactSortOrder as argument for better flexibility.\n+      Map<ArtifactDescriptor, PluginClass> plugins =\n+        artifactRepository.getPlugins(pluginArtifactNamespace,\n+                                      Artifact.from(Namespace.fromEntityId(namespaceId), applicationArtifactId),\n+                                      pluginType, pluginName, predicate, limit, ArtifactSortOrder.ASC);\n+      for (Map.Entry<ArtifactDescriptor, PluginClass> pluginsEntry : plugins.entrySet()) {\n+        ArtifactId plugin = pluginsEntry.getKey().getArtifactId();\n+        // Only consider non-SNAPSHOT plugins for upgrade.\n+        // TODO: Consider making this check optional. Helpful for integration tests.\n+        if (!plugin.getVersion().isSnapshot()) {\n+          pluginArtifacts.add(plugin);\n+        }\n+      }\n+    } catch (PluginNotExistsException e) {\n+      LOG.debug(\"No plugin found for plugin {} of type {} in scope {} for app {}\",\n+                pluginName, pluginType, pluginScope, applicationId);\n+      return Collections.emptyList();\n+    } catch (Exception e) {\n+      LOG.debug(\"Failed to get plugin details for artifact {} for plugin {} of type {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb06762cacc6c8536c6384380a6e60bf112cabc"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjI0Mw==", "bodyText": "You need to close this classloader after done using any instances created from it. The createArtifactClassLoader returns a CloseableClassLoader, which you can use try (resource) block to easily close it out.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436256243", "createdAt": "2020-06-06T10:06:16Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +362,138 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading application artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"The current artifact has a version higher %s than any existing artifact.\", currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+      new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                     upgradeActions, ownerAdmin.getOwner(appId), false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId appId,\n+                                                            @Nullable String currentConfigStr,\n+                                                            ProgramTerminator programTerminator,\n+                                                            ArtifactDetail artifactDetail,\n+                                                            List<ApplicationConfigUpdateAction> updateActions,\n+                                                            @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                            boolean updateSchedules,\n+                                                            String userAction) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      // This should never happen.\n+      throw new IllegalStateException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                      artifactDetail.getDescriptor().getArtifactId(), appId.getParent()));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+      Artifacts.toProtoArtifactId(appId.getParent(), artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+\n+    String updatedAppConfig = \"\";\n+    DefaultApplicationUpdateContext updateContext =\n+      new DefaultApplicationUpdateContext(appId.getParent(), appId, artifactDetail.getDescriptor().getArtifactId(),\n+                                          artifactRepository, currentConfigStr, updateActions);\n+\n+    Object appMain;\n+    try {\n+      ClassLoader artifactClassLoader =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb06762cacc6c8536c6384380a6e60bf112cabc"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NjMxMA==", "bodyText": "Why need to change?", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436256310", "createdAt": "2020-06-06T10:07:32Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLBatchConfig.java", "diffHunk": "@@ -43,7 +44,7 @@\n   private final List<ETLStage> postActions;\n   // for backwards compatibility\n   private final List<ETLStage> actions;\n-  private final boolean service;\n+  private final Boolean service;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb06762cacc6c8536c6384380a6e60bf112cabc"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NTExNzY5", "url": "https://github.com/cdapio/cdap/pull/12233#pullrequestreview-426511769", "createdAt": "2020-06-08T18:39:10Z", "commit": {"oid": "f00409bd92e6701851f07a04bf4d21f9b52c1064"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODozOToxMFrOGgrI-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOTowNToxOFrOGgsGpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNDQyNQ==", "bodyText": "So when an Exception will be thrown versus when the failure will be in the returned ApplicationUpdateDetail? Generally it is not a good idea to have two ways to communicate errors. It is probably better for this method to always throw exception (e.g. ApplicationNotFoundException, ArtifcatNotFoundException... etc), and the caller to this method to handle it in different way (e.g. if it is called from the http handler, exceptions get caught and wrapped into ApplicationUpdateDetail for response)", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436914425", "createdAt": "2020-06-08T18:39:10Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +363,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading application artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f00409bd92e6701851f07a04bf4d21f9b52c1064"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNTg4Mg==", "bodyText": "You can't close the ClassLoader here since the appMain is still being in use. You can only close a ClassLoader after all classes/instances created from it are no longer in use.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436915882", "createdAt": "2020-06-08T18:41:50Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/services/ApplicationLifecycleService.java", "diffHunk": "@@ -345,6 +363,139 @@ public ApplicationWithPrograms updateApp(ApplicationId appId, AppRequest appRequ\n                      programTerminator, ownerAdmin.getOwner(appId), appRequest.canUpdateSchedules());\n   }\n \n+  /**\n+   * Upgrades an existing application by upgrading application artifact versions and plugin artifact versions.\n+   *\n+   * @param appId the id of the application to upgrade.\n+   * @param programTerminator a program terminator that will stop programs that are removed when updating an app.\n+   *                          For example, if an update removes a flow, the terminator defines how to stop that flow.\n+   * @return Details of upgrade for the application like failure details with reason.\n+   * @throws IllegalStateException if something unexpected happened during upgrade.\n+   * @throws IOException if there was an IO error during initializing application class from artifact.\n+   * @throws JsonIOException if there was an error in serializing or deserializing app config.\n+   * @throws Exception if there was an exception during the upgrade of application. This exception will often wrap\n+   *                   the actual exception\n+   */\n+  public ApplicationUpdateDetail upgradeApplication(ApplicationId appId, ProgramTerminator programTerminator)\n+      throws Exception {\n+    // Check if the current user has admin privileges on it before updating.\n+    authorizationEnforcer.enforce(appId, authenticationContext.getPrincipal(), Action.ADMIN);\n+    // check that app exists\n+    ApplicationSpecification currentSpec = store.getApplication(appId);\n+    if (currentSpec == null) {\n+      LOG.info(\"Application {} not found for upgrade.\", appId);\n+      return new ApplicationUpdateDetail(appId, new NotFoundException(appId));\n+    }\n+    ArtifactId currentArtifact = currentSpec.getArtifactId();\n+    NamespaceId currentArtifactNamespace =\n+      ArtifactScope.SYSTEM.equals(currentArtifact.getScope()) ? NamespaceId.SYSTEM : appId.getParent();\n+\n+    // Get the artifact with latest version for upgrade.\n+    List<ArtifactSummary> availableArtifacts =\n+      artifactRepository.getArtifactSummaries(currentArtifactNamespace, currentArtifact.getName(), 1,\n+                                              ArtifactSortOrder.DESC);\n+    if (availableArtifacts.isEmpty()) {\n+      String error = String.format(\"No artifacts found for artifact id %s in namespace %s.\", currentArtifact.getName(),\n+                                   currentArtifactNamespace);\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+    // The latest version should be first (and only) value in the result.\n+    ArtifactSummary candidateArtifact = availableArtifacts.get(0);\n+    ArtifactVersion candidateArtifactVersion = new ArtifactVersion(candidateArtifact.getVersion());\n+\n+    // Current artifact should not have higher version than candidate artifact.\n+    if (currentArtifact.getVersion().compareTo(candidateArtifactVersion) > 0) {\n+      String error = String.format(\n+        \"The current artifact has a version higher %s than any existing artifact.\", currentArtifact.getVersion());\n+      return new ApplicationUpdateDetail(appId, \"Upgrade failed: \" + error);\n+    }\n+\n+    ArtifactId newArtifactId =\n+      new ArtifactId(currentArtifact.getName(), candidateArtifactVersion, currentArtifact.getScope());\n+\n+    Id.Artifact newArtifact = Id.Artifact.fromEntityId(Artifacts.toProtoArtifactId(appId.getParent(), newArtifactId));\n+    ArtifactDetail newArtifactDetail = artifactRepository.getArtifact(newArtifact);\n+    List<ApplicationConfigUpdateAction> upgradeActions = Arrays.asList(ApplicationConfigUpdateAction.UPGRADE_ARTIFACT);\n+\n+\n+    return updateApplicationInternal(appId, currentSpec.getConfiguration(), programTerminator, newArtifactDetail,\n+                                     upgradeActions, ownerAdmin.getOwner(appId), false, \"Upgrade\");\n+  }\n+\n+  /**\n+   * Updates an application config by applying given update actions. The app should know how to apply these actions\n+   * to its config.\n+   */\n+  private ApplicationUpdateDetail updateApplicationInternal(ApplicationId appId,\n+                                                            @Nullable String currentConfigStr,\n+                                                            ProgramTerminator programTerminator,\n+                                                            ArtifactDetail artifactDetail,\n+                                                            List<ApplicationConfigUpdateAction> updateActions,\n+                                                            @Nullable KerberosPrincipalId ownerPrincipal,\n+                                                            boolean updateSchedules,\n+                                                            String userAction) throws Exception {\n+    ApplicationClass appClass = Iterables.getFirst(artifactDetail.getMeta().getClasses().getApps(), null);\n+    if (appClass == null) {\n+      // This should never happen.\n+      throw new IllegalStateException(String.format(\"No application class found in artifact '%s' in namespace '%s'.\",\n+                                      artifactDetail.getDescriptor().getArtifactId(), appId.getParent()));\n+    }\n+    io.cdap.cdap.proto.id.ArtifactId artifactId =\n+      Artifacts.toProtoArtifactId(appId.getParent(), artifactDetail.getDescriptor().getArtifactId());\n+    EntityImpersonator classLoaderImpersonator = new EntityImpersonator(artifactId, this.impersonator);\n+\n+    String updatedAppConfig = \"\";\n+    DefaultApplicationUpdateContext updateContext =\n+      new DefaultApplicationUpdateContext(appId.getParent(), appId, artifactDetail.getDescriptor().getArtifactId(),\n+                                          artifactRepository, currentConfigStr, updateActions);\n+\n+    Object appMain;\n+    try {\n+      try (CloseableClassLoader artifactClassLoader =\n+        artifactRepository.createArtifactClassLoader(artifactDetail.getDescriptor().getLocation(),\n+                                                     classLoaderImpersonator)) {\n+        appMain = artifactClassLoader.loadClass(appClass.getClassName()).newInstance();\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f00409bd92e6701851f07a04bf4d21f9b52c1064"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzMDIxMg==", "bodyText": "No need to have else after an if block returns", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r436930212", "createdAt": "2020-06-08T19:05:18Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-proto/src/main/java/io/cdap/cdap/etl/proto/v2/ETLStage.java", "diffHunk": "@@ -77,6 +105,122 @@ public ETLStage upgradeStage(UpgradeContext upgradeContext) {\n     return new io.cdap.cdap.etl.proto.v2.ETLStage(name, etlPlugin);\n   }\n \n+  /**\n+   * Updates stage by performing update action logic provided in context.\n+   * Current relevant update actions for stages are:\n+   *  1. UPGRADE_ARTIFACT: Upgrades plugin artifact by finding the latest version of plugin to use.\n+   *\n+   * @param updateContext Context to use for updating stage.\n+   * @return new (updated) ETLStage.\n+   */\n+  public ETLStage updateStage(ApplicationUpdateContext updateContext) throws Exception {\n+    for (ApplicationConfigUpdateAction updateAction: updateContext.getUpdateActions()) {\n+      switch (updateAction) {\n+        case UPGRADE_ARTIFACT:\n+          return new io.cdap.cdap.etl.proto.v2.ETLStage(name, upgradePlugin(updateContext), inputSchema,\n+                                                        outputSchema);\n+        default:\n+          return this;\n+        }\n+      }\n+\n+    // No update action provided so return stage as is.\n+    return this;\n+  }\n+\n+  /**\n+   * Upgrade plugin used in the stage.\n+   * 1. If plugin is using fixed version and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    use the new plugin.\n+   * 2. If plugin is using a plugin range and a new plugin artifact is found with higher version in SYSTEM scope,\n+   *    move the upper bound of the range to include the new plugin artifact. Also change plugin scope.\n+   *    If new plugin is in range, do not change range. (Note: It would not change range even though new plugin is in\n+   *    different scope).\n+   *\n+   * @param updateContext To use helper functions like getPluginArtifacts.\n+   * @return Updated plugin object to be used for the udated stage. Returned null if no changes to current plugin.\n+   */\n+  private ETLPlugin upgradePlugin(ApplicationUpdateContext updateContext) throws Exception {\n+    // Currently tries to find latest plugin in SYSTEM scope and upgrades current plugin if version is higher,\n+    // ignoring current plugin scope.\n+    // In future, we can modify logic to fetch the latest plugin in any scope.\n+    List<ArtifactId> candidates =\n+      updateContext.getPluginArtifacts(plugin.getType(), plugin.getName(), ArtifactScope.SYSTEM, null);\n+    if (candidates.isEmpty()) {\n+      return plugin;\n+    }\n+\n+    // getPluginArtifacts returns plugins sorted in ascending order.\n+    // TODO: Consider passing sort order as parameter.\n+    ArtifactId newPlugin = candidates.get(candidates.size() - 1);\n+    String newVersion = getUpgradedVersionString(newPlugin);\n+    // If getUpgradedVersionString returns null, candidate plugin is not valid for upgrade.\n+    if (newVersion == null) {\n+      return plugin;\n+    }\n+\n+    ArtifactSelectorConfig newArtifactSelectorConfig =\n+      new ArtifactSelectorConfig(newPlugin.getScope().name(), newPlugin.getName(),\n+                                 newVersion);\n+    io.cdap.cdap.etl.proto.v2.ETLPlugin upgradedEtlPlugin =\n+      new io.cdap.cdap.etl.proto.v2.ETLPlugin(plugin.getName(), plugin.getType(),\n+                                              plugin.getProperties(),\n+                                              newArtifactSelectorConfig);\n+    return upgradedEtlPlugin;\n+  }\n+\n+  /**\n+   * Returns new valid version string for plugin upgrade if any changes are required. Returns null if no change to\n+   * current plugin version.\n+   * Artifact selector config only stores plugin version as string, it can be either fixed version or range.\n+   * Hence, if the plugin version is fixed, replace the fixed version with newer fixed version. If it is a range,\n+   * move the upper bound of the range to the newest version.\n+   *\n+   * @param newPlugin New candidate plugin for updating plugin artifact.\n+   * @return version string to be used for new plugin. Might be fixed version/version range string depending on\n+   *         current use.\n+   */\n+  @Nullable\n+  private String getUpgradedVersionString(ArtifactId newPlugin) {\n+    ArtifactVersionRange currentVersionRange = null;\n+    try {\n+      currentVersionRange =\n+        io.cdap.cdap.api.artifact.ArtifactVersionRange.parse(plugin.getArtifactConfig().getVersion());\n+    } catch (Exception e) {\n+      LOG.warn(\"Issue in parsing version string for plugin {}, ignoring stage {} for upgrade.\", plugin, name, e);\n+      return null;\n+    }\n+\n+    if (currentVersionRange.isExactVersion()) {\n+      if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) < 0) {\n+        // Current version is a fixed version and new version is higher than current.\n+        return newPlugin.getVersion().getVersion();\n+      }\n+      return null;\n+    }\n+\n+    if (!currentVersionRange.isExactVersion()) {\n+      // Current plugin version is version range.\n+      if (currentVersionRange.versionIsInRange(newPlugin.getVersion())) {\n+        // Do nothing and return as is. Note that plugin scope will not change.\n+        // TODO: Figure out how to change plugin scope if a newer plugin is found but in different scope.\n+        return null;\n+      } else if (currentVersionRange.getLower().compareTo(newPlugin.getVersion()) > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f00409bd92e6701851f07a04bf4d21f9b52c1064"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NjYzMDYx", "url": "https://github.com/cdapio/cdap/pull/12233#pullrequestreview-426663061", "createdAt": "2020-06-08T22:23:57Z", "commit": {"oid": "5820f801fcd894c460f13204a361f84c792b2aab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjoyMzo1N1rOGgydbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjoyMzo1N1rOGgydbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNDM0OA==", "bodyText": "Instead of catching it here, I think it is better to add the handling to the HttpExceptionHandler.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r437034348", "createdAt": "2020-06-08T22:23:57Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/AppLifecycleHttpHandler.java", "diffHunk": "@@ -378,6 +381,71 @@ public void updateApp(FullHttpRequest request, HttpResponder responder,\n     }\n   }\n \n+  /**\n+   * upgrades an existing application.\n+   */\n+  @POST\n+  @Path(\"/apps/{app-id}/upgrade\")\n+  @AuditPolicy(AuditDetail.REQUEST_BODY)\n+  public void upgradeApplication(HttpRequest request, HttpResponder responder,\n+                                 @PathParam(\"namespace-id\") String namespaceId,\n+                                 @PathParam(\"app-id\") String appName) throws Exception {\n+    ApplicationId appId = validateApplicationId(namespaceId, appName);\n+    try {\n+      applicationLifecycleService.upgradeApplication(appId, createProgramTerminator());\n+      ApplicationUpdateDetail updateDetail = new ApplicationUpdateDetail(appId, \"upgrade successful.\");\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(updateDetail));\n+    } catch (UnsupportedOperationException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5820f801fcd894c460f13204a361f84c792b2aab"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Njc0MTE3", "url": "https://github.com/cdapio/cdap/pull/12233#pullrequestreview-426674117", "createdAt": "2020-06-08T22:50:04Z", "commit": {"oid": "0a569b9e28525399c68892b1c7eae05e010e253f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjo1MDowNFrOGgzBNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjo1MDowNFrOGgzBNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MzUxMA==", "bodyText": "Better use instanceof instead of checking the class name in this case.", "url": "https://github.com/cdapio/cdap/pull/12233#discussion_r437043510", "createdAt": "2020-06-08T22:50:04Z", "author": {"login": "chtyim"}, "path": "cdap-common/src/main/java/io/cdap/cdap/common/HttpExceptionHandler.java", "diffHunk": "@@ -64,6 +64,12 @@ public void handle(Throwable t, HttpRequest request, HttpResponder responder) {\n         responder.sendString(HttpResponseStatus.CONFLICT, cause.getMessage());\n         return;\n       }\n+\n+      if (cause.getClass().getName().endsWith(\"UnsupportedOperationException\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a569b9e28525399c68892b1c7eae05e010e253f"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "61ef6eca98b4f7d1de4bb7d6ded3ac5f12607c33", "author": {"user": null}, "url": "https://github.com/cdapio/cdap/commit/61ef6eca98b4f7d1de4bb7d6ded3ac5f12607c33", "committedDate": "2020-06-08T23:20:48Z", "message": "Updating unsupported exception handler"}, "afterCommit": {"oid": "d2744762c84df3f36ae78cac6082e829134e16f4", "author": {"user": null}, "url": "https://github.com/cdapio/cdap/commit/d2744762c84df3f36ae78cac6082e829134e16f4", "committedDate": "2020-06-09T01:05:30Z", "message": "Fixing artifact test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffaa13ba408e9935cd7388ef740ae2947f2f886e", "author": {"user": null}, "url": "https://github.com/cdapio/cdap/commit/ffaa13ba408e9935cd7388ef740ae2947f2f886e", "committedDate": "2020-06-09T16:26:14Z", "message": "Add new API in application interface for upgrading application config.\nAdd logic for DataPipelineApp to upgrade ETLBatchConfig. Add REST API\nendpoints for upgrading applications."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce9fabc41a5cc4bae6dd7bdbfc9ff46777b494ca", "author": {"user": null}, "url": "https://github.com/cdapio/cdap/commit/ce9fabc41a5cc4bae6dd7bdbfc9ff46777b494ca", "committedDate": "2020-06-09T06:09:50Z", "message": "Fix audit test"}, "afterCommit": {"oid": "ffaa13ba408e9935cd7388ef740ae2947f2f886e", "author": {"user": null}, "url": "https://github.com/cdapio/cdap/commit/ffaa13ba408e9935cd7388ef740ae2947f2f886e", "committedDate": "2020-06-09T16:26:14Z", "message": "Add new API in application interface for upgrading application config.\nAdd logic for DataPipelineApp to upgrade ETLBatchConfig. Add REST API\nendpoints for upgrading applications."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2036, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}