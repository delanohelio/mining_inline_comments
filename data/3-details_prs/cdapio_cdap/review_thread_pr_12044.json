{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMzA5Nzcz", "number": 12044, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0NToxNlrODwgOlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxODo0NjowMVrODwhizg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg2MjYyOnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0NToxNlrOGDi8mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDo0NDoxMlrOGDouRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTQ4MA==", "bodyText": "I think we should refactor this method and separate this part out. isValid method is doing more than validation - such as mutating state in local store.", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406371480", "createdAt": "2020-04-09T17:45:16Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.BadRequestException;\n+import io.cdap.cdap.common.NotFoundException;\n+import io.cdap.cdap.common.ServiceUnavailableException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.logging.gateway.handlers.ProgramRunRecordFetcher;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.netty.handler.codec.http.HttpRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link RuntimeRequestValidator} implementation that reads from the runtime table directly.\n+ */\n+public final class DirectRuntimeRequestValidator implements RuntimeRequestValidator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DirectRuntimeRequestValidator.class);\n+  private static final Gson GSON = new Gson();\n+\n+  private final TransactionRunner txRunner;\n+  private final ProgramRunRecordFetcher runRecordFetcher;\n+  private final LoadingCache<ProgramRunId, Boolean> programRunsCache;\n+\n+  @Inject\n+  DirectRuntimeRequestValidator(CConfiguration cConf, TransactionRunner txRunner,\n+                                ProgramRunRecordFetcher runRecordFetcher) {\n+    this.txRunner = txRunner;\n+    this.runRecordFetcher = runRecordFetcher;\n+\n+    // Configure the cache with expiry the poll time.\n+    // This helps reducing the actual lookup for a burst of requests within one poll interval,\n+    // but not to keep it too long so that data becomes stale.\n+    long pollTimeMillis = cConf.getLong(Constants.RuntimeMonitor.POLL_TIME_MS);\n+    this.programRunsCache = CacheBuilder.newBuilder()\n+      .expireAfterWrite(pollTimeMillis, TimeUnit.MILLISECONDS)\n+      .build(new CacheLoader<ProgramRunId, Boolean>() {\n+        @Override\n+        public Boolean load(ProgramRunId programRunId) throws IOException {\n+          return isValid(programRunId);\n+        }\n+      });\n+  }\n+\n+  @Override\n+  public void validate(ProgramRunId programRunId, HttpRequest request) throws BadRequestException {\n+    boolean exists;\n+    try {\n+      exists = programRunsCache.get(programRunId);\n+    } catch (Exception e) {\n+      throw new ServiceUnavailableException(Constants.Service.RUNTIME, e);\n+    }\n+    if (!exists) {\n+      throw new BadRequestException(\"Program run \" + programRunId + \" is not valid\");\n+    }\n+  }\n+\n+  /**\n+   * Checks if the given {@link ProgramRunId} is valid.\n+   */\n+  private boolean isValid(ProgramRunId programRunId) throws IOException {\n+    RunRecordDetail runRecord = TransactionRunners.run(txRunner, context -> {\n+      return AppMetadataStore.create(context).getRun(programRunId);\n+    }, IOException.class);\n+\n+    if (runRecord != null) {\n+      return !runRecord.getStatus().isEndState();\n+    }\n+    // If it is not found in the local store, which should be very rare, try to fetch the run record remotely.\n+    try {\n+      LOG.info(\"Fetching program run details for {} remotely\", programRunId);\n+      runRecord = runRecordFetcher.getRunRecordMeta(programRunId);\n+      // Try to update the local store\n+      insertRunRecord(programRunId, runRecord);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abec131568f2ff15cd1c3c6e3a8b8991567e6a36"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NTczMg==", "bodyText": "Separate this part out means the caller to this method to do it?? But the information about that it is fetching remotely doesn't go out of this method.", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406455732", "createdAt": "2020-04-09T20:23:08Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.BadRequestException;\n+import io.cdap.cdap.common.NotFoundException;\n+import io.cdap.cdap.common.ServiceUnavailableException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.logging.gateway.handlers.ProgramRunRecordFetcher;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.netty.handler.codec.http.HttpRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link RuntimeRequestValidator} implementation that reads from the runtime table directly.\n+ */\n+public final class DirectRuntimeRequestValidator implements RuntimeRequestValidator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DirectRuntimeRequestValidator.class);\n+  private static final Gson GSON = new Gson();\n+\n+  private final TransactionRunner txRunner;\n+  private final ProgramRunRecordFetcher runRecordFetcher;\n+  private final LoadingCache<ProgramRunId, Boolean> programRunsCache;\n+\n+  @Inject\n+  DirectRuntimeRequestValidator(CConfiguration cConf, TransactionRunner txRunner,\n+                                ProgramRunRecordFetcher runRecordFetcher) {\n+    this.txRunner = txRunner;\n+    this.runRecordFetcher = runRecordFetcher;\n+\n+    // Configure the cache with expiry the poll time.\n+    // This helps reducing the actual lookup for a burst of requests within one poll interval,\n+    // but not to keep it too long so that data becomes stale.\n+    long pollTimeMillis = cConf.getLong(Constants.RuntimeMonitor.POLL_TIME_MS);\n+    this.programRunsCache = CacheBuilder.newBuilder()\n+      .expireAfterWrite(pollTimeMillis, TimeUnit.MILLISECONDS)\n+      .build(new CacheLoader<ProgramRunId, Boolean>() {\n+        @Override\n+        public Boolean load(ProgramRunId programRunId) throws IOException {\n+          return isValid(programRunId);\n+        }\n+      });\n+  }\n+\n+  @Override\n+  public void validate(ProgramRunId programRunId, HttpRequest request) throws BadRequestException {\n+    boolean exists;\n+    try {\n+      exists = programRunsCache.get(programRunId);\n+    } catch (Exception e) {\n+      throw new ServiceUnavailableException(Constants.Service.RUNTIME, e);\n+    }\n+    if (!exists) {\n+      throw new BadRequestException(\"Program run \" + programRunId + \" is not valid\");\n+    }\n+  }\n+\n+  /**\n+   * Checks if the given {@link ProgramRunId} is valid.\n+   */\n+  private boolean isValid(ProgramRunId programRunId) throws IOException {\n+    RunRecordDetail runRecord = TransactionRunners.run(txRunner, context -> {\n+      return AppMetadataStore.create(context).getRun(programRunId);\n+    }, IOException.class);\n+\n+    if (runRecord != null) {\n+      return !runRecord.getStatus().isEndState();\n+    }\n+    // If it is not found in the local store, which should be very rare, try to fetch the run record remotely.\n+    try {\n+      LOG.info(\"Fetching program run details for {} remotely\", programRunId);\n+      runRecord = runRecordFetcher.getRunRecordMeta(programRunId);\n+      // Try to update the local store\n+      insertRunRecord(programRunId, runRecord);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTQ4MA=="}, "originalCommit": {"oid": "abec131568f2ff15cd1c3c6e3a8b8991567e6a36"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2MzcwMQ==", "bodyText": "Would it be a good idea to throw NotFoundException in isValid when program is not present and do insertion logic in the caller.", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406463701", "createdAt": "2020-04-09T20:39:16Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.BadRequestException;\n+import io.cdap.cdap.common.NotFoundException;\n+import io.cdap.cdap.common.ServiceUnavailableException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.logging.gateway.handlers.ProgramRunRecordFetcher;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.netty.handler.codec.http.HttpRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link RuntimeRequestValidator} implementation that reads from the runtime table directly.\n+ */\n+public final class DirectRuntimeRequestValidator implements RuntimeRequestValidator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DirectRuntimeRequestValidator.class);\n+  private static final Gson GSON = new Gson();\n+\n+  private final TransactionRunner txRunner;\n+  private final ProgramRunRecordFetcher runRecordFetcher;\n+  private final LoadingCache<ProgramRunId, Boolean> programRunsCache;\n+\n+  @Inject\n+  DirectRuntimeRequestValidator(CConfiguration cConf, TransactionRunner txRunner,\n+                                ProgramRunRecordFetcher runRecordFetcher) {\n+    this.txRunner = txRunner;\n+    this.runRecordFetcher = runRecordFetcher;\n+\n+    // Configure the cache with expiry the poll time.\n+    // This helps reducing the actual lookup for a burst of requests within one poll interval,\n+    // but not to keep it too long so that data becomes stale.\n+    long pollTimeMillis = cConf.getLong(Constants.RuntimeMonitor.POLL_TIME_MS);\n+    this.programRunsCache = CacheBuilder.newBuilder()\n+      .expireAfterWrite(pollTimeMillis, TimeUnit.MILLISECONDS)\n+      .build(new CacheLoader<ProgramRunId, Boolean>() {\n+        @Override\n+        public Boolean load(ProgramRunId programRunId) throws IOException {\n+          return isValid(programRunId);\n+        }\n+      });\n+  }\n+\n+  @Override\n+  public void validate(ProgramRunId programRunId, HttpRequest request) throws BadRequestException {\n+    boolean exists;\n+    try {\n+      exists = programRunsCache.get(programRunId);\n+    } catch (Exception e) {\n+      throw new ServiceUnavailableException(Constants.Service.RUNTIME, e);\n+    }\n+    if (!exists) {\n+      throw new BadRequestException(\"Program run \" + programRunId + \" is not valid\");\n+    }\n+  }\n+\n+  /**\n+   * Checks if the given {@link ProgramRunId} is valid.\n+   */\n+  private boolean isValid(ProgramRunId programRunId) throws IOException {\n+    RunRecordDetail runRecord = TransactionRunners.run(txRunner, context -> {\n+      return AppMetadataStore.create(context).getRun(programRunId);\n+    }, IOException.class);\n+\n+    if (runRecord != null) {\n+      return !runRecord.getStatus().isEndState();\n+    }\n+    // If it is not found in the local store, which should be very rare, try to fetch the run record remotely.\n+    try {\n+      LOG.info(\"Fetching program run details for {} remotely\", programRunId);\n+      runRecord = runRecordFetcher.getRunRecordMeta(programRunId);\n+      // Try to update the local store\n+      insertRunRecord(programRunId, runRecord);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTQ4MA=="}, "originalCommit": {"oid": "abec131568f2ff15cd1c3c6e3a8b8991567e6a36"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NTE2NQ==", "bodyText": "No. It is intentional to populate the cache with a false so that we don't need to keep making remote call in case someone is calling this with a program run that is not runnning.", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406465165", "createdAt": "2020-04-09T20:42:17Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.BadRequestException;\n+import io.cdap.cdap.common.NotFoundException;\n+import io.cdap.cdap.common.ServiceUnavailableException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.logging.gateway.handlers.ProgramRunRecordFetcher;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.netty.handler.codec.http.HttpRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link RuntimeRequestValidator} implementation that reads from the runtime table directly.\n+ */\n+public final class DirectRuntimeRequestValidator implements RuntimeRequestValidator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DirectRuntimeRequestValidator.class);\n+  private static final Gson GSON = new Gson();\n+\n+  private final TransactionRunner txRunner;\n+  private final ProgramRunRecordFetcher runRecordFetcher;\n+  private final LoadingCache<ProgramRunId, Boolean> programRunsCache;\n+\n+  @Inject\n+  DirectRuntimeRequestValidator(CConfiguration cConf, TransactionRunner txRunner,\n+                                ProgramRunRecordFetcher runRecordFetcher) {\n+    this.txRunner = txRunner;\n+    this.runRecordFetcher = runRecordFetcher;\n+\n+    // Configure the cache with expiry the poll time.\n+    // This helps reducing the actual lookup for a burst of requests within one poll interval,\n+    // but not to keep it too long so that data becomes stale.\n+    long pollTimeMillis = cConf.getLong(Constants.RuntimeMonitor.POLL_TIME_MS);\n+    this.programRunsCache = CacheBuilder.newBuilder()\n+      .expireAfterWrite(pollTimeMillis, TimeUnit.MILLISECONDS)\n+      .build(new CacheLoader<ProgramRunId, Boolean>() {\n+        @Override\n+        public Boolean load(ProgramRunId programRunId) throws IOException {\n+          return isValid(programRunId);\n+        }\n+      });\n+  }\n+\n+  @Override\n+  public void validate(ProgramRunId programRunId, HttpRequest request) throws BadRequestException {\n+    boolean exists;\n+    try {\n+      exists = programRunsCache.get(programRunId);\n+    } catch (Exception e) {\n+      throw new ServiceUnavailableException(Constants.Service.RUNTIME, e);\n+    }\n+    if (!exists) {\n+      throw new BadRequestException(\"Program run \" + programRunId + \" is not valid\");\n+    }\n+  }\n+\n+  /**\n+   * Checks if the given {@link ProgramRunId} is valid.\n+   */\n+  private boolean isValid(ProgramRunId programRunId) throws IOException {\n+    RunRecordDetail runRecord = TransactionRunners.run(txRunner, context -> {\n+      return AppMetadataStore.create(context).getRun(programRunId);\n+    }, IOException.class);\n+\n+    if (runRecord != null) {\n+      return !runRecord.getStatus().isEndState();\n+    }\n+    // If it is not found in the local store, which should be very rare, try to fetch the run record remotely.\n+    try {\n+      LOG.info(\"Fetching program run details for {} remotely\", programRunId);\n+      runRecord = runRecordFetcher.getRunRecordMeta(programRunId);\n+      // Try to update the local store\n+      insertRunRecord(programRunId, runRecord);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTQ4MA=="}, "originalCommit": {"oid": "abec131568f2ff15cd1c3c6e3a8b8991567e6a36"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NjExOQ==", "bodyText": "I see.", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406466119", "createdAt": "2020-04-09T20:44:12Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.BadRequestException;\n+import io.cdap.cdap.common.NotFoundException;\n+import io.cdap.cdap.common.ServiceUnavailableException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.logging.gateway.handlers.ProgramRunRecordFetcher;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.netty.handler.codec.http.HttpRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link RuntimeRequestValidator} implementation that reads from the runtime table directly.\n+ */\n+public final class DirectRuntimeRequestValidator implements RuntimeRequestValidator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DirectRuntimeRequestValidator.class);\n+  private static final Gson GSON = new Gson();\n+\n+  private final TransactionRunner txRunner;\n+  private final ProgramRunRecordFetcher runRecordFetcher;\n+  private final LoadingCache<ProgramRunId, Boolean> programRunsCache;\n+\n+  @Inject\n+  DirectRuntimeRequestValidator(CConfiguration cConf, TransactionRunner txRunner,\n+                                ProgramRunRecordFetcher runRecordFetcher) {\n+    this.txRunner = txRunner;\n+    this.runRecordFetcher = runRecordFetcher;\n+\n+    // Configure the cache with expiry the poll time.\n+    // This helps reducing the actual lookup for a burst of requests within one poll interval,\n+    // but not to keep it too long so that data becomes stale.\n+    long pollTimeMillis = cConf.getLong(Constants.RuntimeMonitor.POLL_TIME_MS);\n+    this.programRunsCache = CacheBuilder.newBuilder()\n+      .expireAfterWrite(pollTimeMillis, TimeUnit.MILLISECONDS)\n+      .build(new CacheLoader<ProgramRunId, Boolean>() {\n+        @Override\n+        public Boolean load(ProgramRunId programRunId) throws IOException {\n+          return isValid(programRunId);\n+        }\n+      });\n+  }\n+\n+  @Override\n+  public void validate(ProgramRunId programRunId, HttpRequest request) throws BadRequestException {\n+    boolean exists;\n+    try {\n+      exists = programRunsCache.get(programRunId);\n+    } catch (Exception e) {\n+      throw new ServiceUnavailableException(Constants.Service.RUNTIME, e);\n+    }\n+    if (!exists) {\n+      throw new BadRequestException(\"Program run \" + programRunId + \" is not valid\");\n+    }\n+  }\n+\n+  /**\n+   * Checks if the given {@link ProgramRunId} is valid.\n+   */\n+  private boolean isValid(ProgramRunId programRunId) throws IOException {\n+    RunRecordDetail runRecord = TransactionRunners.run(txRunner, context -> {\n+      return AppMetadataStore.create(context).getRun(programRunId);\n+    }, IOException.class);\n+\n+    if (runRecord != null) {\n+      return !runRecord.getStatus().isEndState();\n+    }\n+    // If it is not found in the local store, which should be very rare, try to fetch the run record remotely.\n+    try {\n+      LOG.info(\"Fetching program run details for {} remotely\", programRunId);\n+      runRecord = runRecordFetcher.getRunRecordMeta(programRunId);\n+      // Try to update the local store\n+      insertRunRecord(programRunId, runRecord);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTQ4MA=="}, "originalCommit": {"oid": "abec131568f2ff15cd1c3c6e3a8b8991567e6a36"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTkxOTEyOnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxODowMToxOFrOGDjgiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDoyNDowMFrOGDoHSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4MDY4MA==", "bodyText": "Remotely fetching program run details for {}", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406380680", "createdAt": "2020-04-09T18:01:18Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.BadRequestException;\n+import io.cdap.cdap.common.NotFoundException;\n+import io.cdap.cdap.common.ServiceUnavailableException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.logging.gateway.handlers.ProgramRunRecordFetcher;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.netty.handler.codec.http.HttpRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link RuntimeRequestValidator} implementation that reads from the runtime table directly.\n+ */\n+public final class DirectRuntimeRequestValidator implements RuntimeRequestValidator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DirectRuntimeRequestValidator.class);\n+  private static final Gson GSON = new Gson();\n+\n+  private final TransactionRunner txRunner;\n+  private final ProgramRunRecordFetcher runRecordFetcher;\n+  private final LoadingCache<ProgramRunId, Boolean> programRunsCache;\n+\n+  @Inject\n+  DirectRuntimeRequestValidator(CConfiguration cConf, TransactionRunner txRunner,\n+                                ProgramRunRecordFetcher runRecordFetcher) {\n+    this.txRunner = txRunner;\n+    this.runRecordFetcher = runRecordFetcher;\n+\n+    // Configure the cache with expiry the poll time.\n+    // This helps reducing the actual lookup for a burst of requests within one poll interval,\n+    // but not to keep it too long so that data becomes stale.\n+    long pollTimeMillis = cConf.getLong(Constants.RuntimeMonitor.POLL_TIME_MS);\n+    this.programRunsCache = CacheBuilder.newBuilder()\n+      .expireAfterWrite(pollTimeMillis, TimeUnit.MILLISECONDS)\n+      .build(new CacheLoader<ProgramRunId, Boolean>() {\n+        @Override\n+        public Boolean load(ProgramRunId programRunId) throws IOException {\n+          return isValid(programRunId);\n+        }\n+      });\n+  }\n+\n+  @Override\n+  public void validate(ProgramRunId programRunId, HttpRequest request) throws BadRequestException {\n+    boolean exists;\n+    try {\n+      exists = programRunsCache.get(programRunId);\n+    } catch (Exception e) {\n+      throw new ServiceUnavailableException(Constants.Service.RUNTIME, e);\n+    }\n+    if (!exists) {\n+      throw new BadRequestException(\"Program run \" + programRunId + \" is not valid\");\n+    }\n+  }\n+\n+  /**\n+   * Checks if the given {@link ProgramRunId} is valid.\n+   */\n+  private boolean isValid(ProgramRunId programRunId) throws IOException {\n+    RunRecordDetail runRecord = TransactionRunners.run(txRunner, context -> {\n+      return AppMetadataStore.create(context).getRun(programRunId);\n+    }, IOException.class);\n+\n+    if (runRecord != null) {\n+      return !runRecord.getStatus().isEndState();\n+    }\n+    // If it is not found in the local store, which should be very rare, try to fetch the run record remotely.\n+    try {\n+      LOG.info(\"Fetching program run details for {} remotely\", programRunId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abec131568f2ff15cd1c3c6e3a8b8991567e6a36"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NjEzOQ==", "bodyText": "Fixed", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406456139", "createdAt": "2020-04-09T20:24:00Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/DirectRuntimeRequestValidator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.common.BadRequestException;\n+import io.cdap.cdap.common.NotFoundException;\n+import io.cdap.cdap.common.ServiceUnavailableException;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.internal.app.store.RunRecordDetail;\n+import io.cdap.cdap.logging.gateway.handlers.ProgramRunRecordFetcher;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import io.netty.handler.codec.http.HttpRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A {@link RuntimeRequestValidator} implementation that reads from the runtime table directly.\n+ */\n+public final class DirectRuntimeRequestValidator implements RuntimeRequestValidator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(DirectRuntimeRequestValidator.class);\n+  private static final Gson GSON = new Gson();\n+\n+  private final TransactionRunner txRunner;\n+  private final ProgramRunRecordFetcher runRecordFetcher;\n+  private final LoadingCache<ProgramRunId, Boolean> programRunsCache;\n+\n+  @Inject\n+  DirectRuntimeRequestValidator(CConfiguration cConf, TransactionRunner txRunner,\n+                                ProgramRunRecordFetcher runRecordFetcher) {\n+    this.txRunner = txRunner;\n+    this.runRecordFetcher = runRecordFetcher;\n+\n+    // Configure the cache with expiry the poll time.\n+    // This helps reducing the actual lookup for a burst of requests within one poll interval,\n+    // but not to keep it too long so that data becomes stale.\n+    long pollTimeMillis = cConf.getLong(Constants.RuntimeMonitor.POLL_TIME_MS);\n+    this.programRunsCache = CacheBuilder.newBuilder()\n+      .expireAfterWrite(pollTimeMillis, TimeUnit.MILLISECONDS)\n+      .build(new CacheLoader<ProgramRunId, Boolean>() {\n+        @Override\n+        public Boolean load(ProgramRunId programRunId) throws IOException {\n+          return isValid(programRunId);\n+        }\n+      });\n+  }\n+\n+  @Override\n+  public void validate(ProgramRunId programRunId, HttpRequest request) throws BadRequestException {\n+    boolean exists;\n+    try {\n+      exists = programRunsCache.get(programRunId);\n+    } catch (Exception e) {\n+      throw new ServiceUnavailableException(Constants.Service.RUNTIME, e);\n+    }\n+    if (!exists) {\n+      throw new BadRequestException(\"Program run \" + programRunId + \" is not valid\");\n+    }\n+  }\n+\n+  /**\n+   * Checks if the given {@link ProgramRunId} is valid.\n+   */\n+  private boolean isValid(ProgramRunId programRunId) throws IOException {\n+    RunRecordDetail runRecord = TransactionRunners.run(txRunner, context -> {\n+      return AppMetadataStore.create(context).getRun(programRunId);\n+    }, IOException.class);\n+\n+    if (runRecord != null) {\n+      return !runRecord.getStatus().isEndState();\n+    }\n+    // If it is not found in the local store, which should be very rare, try to fetch the run record remotely.\n+    try {\n+      LOG.info(\"Fetching program run details for {} remotely\", programRunId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4MDY4MA=="}, "originalCommit": {"oid": "abec131568f2ff15cd1c3c6e3a8b8991567e6a36"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjA2NTgyOnYy", "diffSide": "RIGHT", "path": "cdap-common/src/main/java/io/cdap/cdap/common/service/AbstractRetryableScheduledService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxODo0MjozMFrOGDk7fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDoyNjo1OFrOGDoNMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwMzk2NA==", "bodyText": "what exception will be caught by this outer catch?", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406403964", "createdAt": "2020-04-09T18:42:30Z", "author": {"login": "CuriousVini"}, "path": "cdap-common/src/main/java/io/cdap/cdap/common/service/AbstractRetryableScheduledService.java", "diffHunk": "@@ -149,28 +152,35 @@ protected long handleRetriesExhausted(Exception e) throws Exception {\n   @Override\n   protected final void runOneIteration() throws Exception {\n     try {\n-      if (nonFailureStartTime == 0L) {\n-        nonFailureStartTime = System.currentTimeMillis();\n-      }\n+      try {\n+        if (nonFailureStartTime == 0L) {\n+          nonFailureStartTime = System.currentTimeMillis();\n+        }\n \n-      delayMillis = runTask();\n-      nonFailureStartTime = 0L;\n-      failureCount = 0;\n-    } catch (Exception e) {\n-      if (!shouldRetry(e)) {\n-        throw e;\n-      }\n-\n-      long delayMillis = retryStrategy.nextRetry(++failureCount, nonFailureStartTime);\n-      if (delayMillis < 0) {\n-        e.addSuppressed(new RetriesExhaustedException(String.format(\"Retries exhausted after %d failures and %d ms.\",\n-                                                                    failureCount,\n-                                                                    System.currentTimeMillis() - nonFailureStartTime)));\n-        delayMillis = Math.max(0L, handleRetriesExhausted(e));\n+        delayMillis = runTask();\n         nonFailureStartTime = 0L;\n         failureCount = 0;\n+      } catch (Exception e) {\n+        OUTAGE_LOG.warn(\"Failed to execute task for scheduled service {}\", getServiceName(), e);\n+        if (!shouldRetry(e)) {\n+          throw e;\n+        }\n+\n+        long delayMillis = retryStrategy.nextRetry(++failureCount, nonFailureStartTime);\n+        if (delayMillis < 0) {\n+          e.addSuppressed(\n+            new RetriesExhaustedException(String.format(\"Retries exhausted after %d failures and %d ms.\",\n+                                                        failureCount,\n+                                                        System.currentTimeMillis() - nonFailureStartTime)));\n+          delayMillis = Math.max(0L, handleRetriesExhausted(e));\n+          nonFailureStartTime = 0L;\n+          failureCount = 0;\n+        }\n+        this.delayMillis = delayMillis;\n       }\n-      this.delayMillis = delayMillis;\n+    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c285cec5afdd78ba8b75c2fafa16438a774b82f"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NzY1MQ==", "bodyText": "The one thrown in line 166. It is just for logging that when a service is giving up retry due to shouldRetry(e) returning false.", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406457651", "createdAt": "2020-04-09T20:26:58Z", "author": {"login": "chtyim"}, "path": "cdap-common/src/main/java/io/cdap/cdap/common/service/AbstractRetryableScheduledService.java", "diffHunk": "@@ -149,28 +152,35 @@ protected long handleRetriesExhausted(Exception e) throws Exception {\n   @Override\n   protected final void runOneIteration() throws Exception {\n     try {\n-      if (nonFailureStartTime == 0L) {\n-        nonFailureStartTime = System.currentTimeMillis();\n-      }\n+      try {\n+        if (nonFailureStartTime == 0L) {\n+          nonFailureStartTime = System.currentTimeMillis();\n+        }\n \n-      delayMillis = runTask();\n-      nonFailureStartTime = 0L;\n-      failureCount = 0;\n-    } catch (Exception e) {\n-      if (!shouldRetry(e)) {\n-        throw e;\n-      }\n-\n-      long delayMillis = retryStrategy.nextRetry(++failureCount, nonFailureStartTime);\n-      if (delayMillis < 0) {\n-        e.addSuppressed(new RetriesExhaustedException(String.format(\"Retries exhausted after %d failures and %d ms.\",\n-                                                                    failureCount,\n-                                                                    System.currentTimeMillis() - nonFailureStartTime)));\n-        delayMillis = Math.max(0L, handleRetriesExhausted(e));\n+        delayMillis = runTask();\n         nonFailureStartTime = 0L;\n         failureCount = 0;\n+      } catch (Exception e) {\n+        OUTAGE_LOG.warn(\"Failed to execute task for scheduled service {}\", getServiceName(), e);\n+        if (!shouldRetry(e)) {\n+          throw e;\n+        }\n+\n+        long delayMillis = retryStrategy.nextRetry(++failureCount, nonFailureStartTime);\n+        if (delayMillis < 0) {\n+          e.addSuppressed(\n+            new RetriesExhaustedException(String.format(\"Retries exhausted after %d failures and %d ms.\",\n+                                                        failureCount,\n+                                                        System.currentTimeMillis() - nonFailureStartTime)));\n+          delayMillis = Math.max(0L, handleRetriesExhausted(e));\n+          nonFailureStartTime = 0L;\n+          failureCount = 0;\n+        }\n+        this.delayMillis = delayMillis;\n       }\n-      this.delayMillis = delayMillis;\n+    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwMzk2NA=="}, "originalCommit": {"oid": "5c285cec5afdd78ba8b75c2fafa16438a774b82f"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjA3Nzg0OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/RuntimeProgramStatusSubscriberService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxODo0NTo1NVrOGDlC6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDoyNDo0NlrOGDoI0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNTg2NA==", "bodyText": "unused?", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406405864", "createdAt": "2020-04-09T18:45:55Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/RuntimeProgramStatusSubscriberService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.program.ProgramDescriptor;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.runtime.ProgramOptionConstants;\n+import io.cdap.cdap.internal.app.services.AbstractNotificationSubscriberService;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.proto.Notification;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableAdmin;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A TMS subscriber service to replicate program status from the\n+ * {@link Constants.AppFabric#PROGRAM_STATUS_RECORD_EVENT_TOPIC} to a local storage.\n+ * It is for the {@link DirectRuntimeRequestValidator} to validate incoming requests that it is coming from\n+ * a running program.\n+ */\n+public class RuntimeProgramStatusSubscriberService extends AbstractNotificationSubscriberService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeProgramStatusSubscriberService.class);\n+  private static final Gson GSON = new Gson();\n+\n+  @Inject\n+  RuntimeProgramStatusSubscriberService(CConfiguration cConf, MessagingService messagingService,\n+                                        DiscoveryServiceClient discoveryServiceClient,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c285cec5afdd78ba8b75c2fafa16438a774b82f"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NjUyOQ==", "bodyText": "Removed", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406456529", "createdAt": "2020-04-09T20:24:46Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/RuntimeProgramStatusSubscriberService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.program.ProgramDescriptor;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.runtime.ProgramOptionConstants;\n+import io.cdap.cdap.internal.app.services.AbstractNotificationSubscriberService;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.proto.Notification;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableAdmin;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A TMS subscriber service to replicate program status from the\n+ * {@link Constants.AppFabric#PROGRAM_STATUS_RECORD_EVENT_TOPIC} to a local storage.\n+ * It is for the {@link DirectRuntimeRequestValidator} to validate incoming requests that it is coming from\n+ * a running program.\n+ */\n+public class RuntimeProgramStatusSubscriberService extends AbstractNotificationSubscriberService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeProgramStatusSubscriberService.class);\n+  private static final Gson GSON = new Gson();\n+\n+  @Inject\n+  RuntimeProgramStatusSubscriberService(CConfiguration cConf, MessagingService messagingService,\n+                                        DiscoveryServiceClient discoveryServiceClient,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNTg2NA=="}, "originalCommit": {"oid": "5c285cec5afdd78ba8b75c2fafa16438a774b82f"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjA3ODIyOnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/RuntimeProgramStatusSubscriberService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxODo0NjowMVrOGDlDHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDoyNDo1MVrOGDoJDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNTkxOQ==", "bodyText": "unused?", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406405919", "createdAt": "2020-04-09T18:46:01Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/RuntimeProgramStatusSubscriberService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.program.ProgramDescriptor;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.runtime.ProgramOptionConstants;\n+import io.cdap.cdap.internal.app.services.AbstractNotificationSubscriberService;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.proto.Notification;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableAdmin;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A TMS subscriber service to replicate program status from the\n+ * {@link Constants.AppFabric#PROGRAM_STATUS_RECORD_EVENT_TOPIC} to a local storage.\n+ * It is for the {@link DirectRuntimeRequestValidator} to validate incoming requests that it is coming from\n+ * a running program.\n+ */\n+public class RuntimeProgramStatusSubscriberService extends AbstractNotificationSubscriberService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeProgramStatusSubscriberService.class);\n+  private static final Gson GSON = new Gson();\n+\n+  @Inject\n+  RuntimeProgramStatusSubscriberService(CConfiguration cConf, MessagingService messagingService,\n+                                        DiscoveryServiceClient discoveryServiceClient,\n+                                        MetricsCollectionService metricsCollectionService,\n+                                        TransactionRunner transactionRunner,\n+                                        StructuredTableAdmin structuredTableAdmin) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c285cec5afdd78ba8b75c2fafa16438a774b82f"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NjU4OQ==", "bodyText": "Removed", "url": "https://github.com/cdapio/cdap/pull/12044#discussion_r406456589", "createdAt": "2020-04-09T20:24:51Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/monitor/RuntimeProgramStatusSubscriberService.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.monitor;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.program.ProgramDescriptor;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.runtime.ProgramOptionConstants;\n+import io.cdap.cdap.internal.app.services.AbstractNotificationSubscriberService;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.proto.Notification;\n+import io.cdap.cdap.proto.ProgramRunStatus;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableAdmin;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.twill.discovery.DiscoveryServiceClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A TMS subscriber service to replicate program status from the\n+ * {@link Constants.AppFabric#PROGRAM_STATUS_RECORD_EVENT_TOPIC} to a local storage.\n+ * It is for the {@link DirectRuntimeRequestValidator} to validate incoming requests that it is coming from\n+ * a running program.\n+ */\n+public class RuntimeProgramStatusSubscriberService extends AbstractNotificationSubscriberService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeProgramStatusSubscriberService.class);\n+  private static final Gson GSON = new Gson();\n+\n+  @Inject\n+  RuntimeProgramStatusSubscriberService(CConfiguration cConf, MessagingService messagingService,\n+                                        DiscoveryServiceClient discoveryServiceClient,\n+                                        MetricsCollectionService metricsCollectionService,\n+                                        TransactionRunner transactionRunner,\n+                                        StructuredTableAdmin structuredTableAdmin) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNTkxOQ=="}, "originalCommit": {"oid": "5c285cec5afdd78ba8b75c2fafa16438a774b82f"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2720, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}