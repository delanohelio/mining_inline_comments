{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMDE4NDQ3", "number": 12057, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODozODozOFrODxxgwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODozODozOFrODxxgwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTE4MDE2OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/runtime/DelayedProgramController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxODozODozOFrOGFb6WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOTo1OToyN1rOGFesiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MzM2OQ==", "bodyText": "nit: this can be moved to the line above", "url": "https://github.com/cdapio/cdap/pull/12057#discussion_r408353369", "createdAt": "2020-04-14T18:38:38Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/runtime/DelayedProgramController.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.app.runtime;\n+\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.lang.Delegator;\n+import io.cdap.cdap.internal.app.runtime.AbstractProgramController;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.apache.twill.api.RunId;\n+import org.apache.twill.common.Cancellable;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.function.Function;\n+\n+/**\n+ * A {@link ProgramController} that delegates all methods to another {@link ProgramController}, in which can be\n+ * set later. All method calls on this instance should be non-blocking.\n+ */\n+public final class DelayedProgramController implements ProgramController, Delegator<ProgramController> {\n+\n+  private final ProgramRunId programRunId;\n+  private final RunId runId;\n+  private final CompletableFuture<ProgramController> delegateFuture;\n+\n+  DelayedProgramController(ProgramRunId programRunId) {\n+    this.programRunId = programRunId;\n+    this.runId = RunIds.fromString(programRunId.getRun());\n+    this.delegateFuture = new CompletableFuture<>();\n+  }\n+\n+  /**\n+   * Sets the delegate {@link ProgramController} to the one provided.\n+   */\n+  void setProgramController(ProgramController controller) {\n+    delegateFuture.complete(controller);\n+  }\n+\n+  /**\n+   * Force this program controller into ERROR state if the delegating program controller hasn't been set.\n+   */\n+  void failed(Throwable t) {\n+    delegateFuture.complete(new FailedProgramController(programRunId, t));\n+  }\n+\n+  /**\n+   * Returns the {@link ProgramController} being delegated to. This method will block until the delegates is available.\n+   */\n+  @Override\n+  public ProgramController getDelegate() {\n+    try {\n+      return Uninterruptibles.getUninterruptibly(delegateFuture);\n+    } catch (ExecutionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @Override\n+  public ProgramRunId getProgramRunId() {\n+    return programRunId;\n+  }\n+\n+  @Override\n+  public RunId getRunId() {\n+    return runId;\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> suspend() {\n+    return callDelegate(ProgramController::suspend);\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> resume() {\n+    return callDelegate(ProgramController::resume);\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> stop() {\n+    return callDelegate(ProgramController::stop);\n+  }\n+\n+  @Override\n+  public State getState() {\n+    try {\n+      return Uninterruptibles.getUninterruptibly(delegateFuture).getState();\n+    } catch (ExecutionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @Override\n+  public Throwable getFailureCause() {\n+    try {\n+      return Uninterruptibles.getUninterruptibly(delegateFuture).getFailureCause();\n+    } catch (ExecutionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @Override\n+  public Cancellable addListener(Listener listener, Executor executor) {\n+    CompletableFuture<Cancellable> cancellableFuture = new CompletableFuture<>();\n+    delegateFuture.whenComplete((programController, throwable) -> {\n+      if (throwable == null) {\n+        cancellableFuture.complete(programController.addListener(listener, executor));\n+      } else {\n+        cancellableFuture.completeExceptionally(throwable);\n+      }\n+    });\n+    return () -> {\n+      try {\n+        Uninterruptibles.getUninterruptibly(cancellableFuture).cancel();\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> command(String name, Object value) {\n+    return callDelegate(controller -> controller.command(name, value));\n+  }\n+\n+  /**\n+   * Makes a method call on the delegating {@link ProgramController} when it is available.\n+   */\n+  private ListenableFuture<ProgramController> callDelegate(\n+    Function<ProgramController, ListenableFuture<ProgramController>> callFunc\n+  ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9794576be3a2887a56b169de0ff5c5f9e4dec741"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5ODk4Nw==", "bodyText": "I intentionally make a new line to have a clear separation between the argument and the method body.", "url": "https://github.com/cdapio/cdap/pull/12057#discussion_r408398987", "createdAt": "2020-04-14T19:59:27Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/runtime/DelayedProgramController.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.app.runtime;\n+\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.lang.Delegator;\n+import io.cdap.cdap.internal.app.runtime.AbstractProgramController;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import org.apache.twill.api.RunId;\n+import org.apache.twill.common.Cancellable;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.function.Function;\n+\n+/**\n+ * A {@link ProgramController} that delegates all methods to another {@link ProgramController}, in which can be\n+ * set later. All method calls on this instance should be non-blocking.\n+ */\n+public final class DelayedProgramController implements ProgramController, Delegator<ProgramController> {\n+\n+  private final ProgramRunId programRunId;\n+  private final RunId runId;\n+  private final CompletableFuture<ProgramController> delegateFuture;\n+\n+  DelayedProgramController(ProgramRunId programRunId) {\n+    this.programRunId = programRunId;\n+    this.runId = RunIds.fromString(programRunId.getRun());\n+    this.delegateFuture = new CompletableFuture<>();\n+  }\n+\n+  /**\n+   * Sets the delegate {@link ProgramController} to the one provided.\n+   */\n+  void setProgramController(ProgramController controller) {\n+    delegateFuture.complete(controller);\n+  }\n+\n+  /**\n+   * Force this program controller into ERROR state if the delegating program controller hasn't been set.\n+   */\n+  void failed(Throwable t) {\n+    delegateFuture.complete(new FailedProgramController(programRunId, t));\n+  }\n+\n+  /**\n+   * Returns the {@link ProgramController} being delegated to. This method will block until the delegates is available.\n+   */\n+  @Override\n+  public ProgramController getDelegate() {\n+    try {\n+      return Uninterruptibles.getUninterruptibly(delegateFuture);\n+    } catch (ExecutionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @Override\n+  public ProgramRunId getProgramRunId() {\n+    return programRunId;\n+  }\n+\n+  @Override\n+  public RunId getRunId() {\n+    return runId;\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> suspend() {\n+    return callDelegate(ProgramController::suspend);\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> resume() {\n+    return callDelegate(ProgramController::resume);\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> stop() {\n+    return callDelegate(ProgramController::stop);\n+  }\n+\n+  @Override\n+  public State getState() {\n+    try {\n+      return Uninterruptibles.getUninterruptibly(delegateFuture).getState();\n+    } catch (ExecutionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @Override\n+  public Throwable getFailureCause() {\n+    try {\n+      return Uninterruptibles.getUninterruptibly(delegateFuture).getFailureCause();\n+    } catch (ExecutionException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @Override\n+  public Cancellable addListener(Listener listener, Executor executor) {\n+    CompletableFuture<Cancellable> cancellableFuture = new CompletableFuture<>();\n+    delegateFuture.whenComplete((programController, throwable) -> {\n+      if (throwable == null) {\n+        cancellableFuture.complete(programController.addListener(listener, executor));\n+      } else {\n+        cancellableFuture.completeExceptionally(throwable);\n+      }\n+    });\n+    return () -> {\n+      try {\n+        Uninterruptibles.getUninterruptibly(cancellableFuture).cancel();\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ListenableFuture<ProgramController> command(String name, Object value) {\n+    return callDelegate(controller -> controller.command(name, value));\n+  }\n+\n+  /**\n+   * Makes a method call on the delegating {@link ProgramController} when it is available.\n+   */\n+  private ListenableFuture<ProgramController> callDelegate(\n+    Function<ProgramController, ListenableFuture<ProgramController>> callFunc\n+  ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MzM2OQ=="}, "originalCommit": {"oid": "9794576be3a2887a56b169de0ff5c5f9e4dec741"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2741, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}