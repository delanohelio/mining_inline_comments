{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NzM5NjE0", "number": 11886, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDo1MDoyNFrODi2Nqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDo1MzoyNlrODi2RIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODY2NDExOnYy", "diffSide": "RIGHT", "path": "cdap-common/src/main/java/io/cdap/cdap/common/guice/DFSLocationModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDo1MDoyNFrOFuUt8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDo1MDoyNFrOFuUt8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExODI1OA==", "bodyText": "would be a little simpler to return lf if locationCachePath is null before this line", "url": "https://github.com/cdapio/cdap/pull/11886#discussion_r384118258", "createdAt": "2020-02-25T20:50:24Z", "author": {"login": "albertshau"}, "path": "cdap-common/src/main/java/io/cdap/cdap/common/guice/DFSLocationModule.java", "diffHunk": "@@ -66,16 +73,28 @@ private LocationFactoryProvider(CConfiguration cConf, Configuration hConf,\n     @Override\n     public LocationFactory get() {\n       String namespace = cConf.get(Constants.CFG_HDFS_NAMESPACE);\n-      LOG.debug(\"HDFS namespace is {}\", namespace);\n+      LOG.debug(\"Location namespace is {}\", namespace);\n+\n+      LocationFactory lf;\n \n       // This FileContextLocationFactory supports multiple users from the same process.\n       // It is used when security is enabled, which in turn impersonation could occur.\n       if (UserGroupInformation.isSecurityEnabled()) {\n-        return new FileContextLocationFactory(hConf, namespace);\n+        lf = new FileContextLocationFactory(hConf, namespace);\n+      } else {\n+        // In non hadoop secure mode, use the static file context, which operates as single user.\n+        lf = new InsecureFileContextLocationFactory(hConf, namespace, staticFileContextProvider.get());\n       }\n \n-      // In non hadoop secure mode, use the static file context, which operates as single user.\n-      return new InsecureFileContextLocationFactory(hConf, namespace, staticFileContextProvider.get());\n+      String locationCachePath = cConf.get(Constants.LOCATION_CACHE_PATH);\n+      Path cachePath = Strings.isNullOrEmpty(locationCachePath) ? null : Paths.get(locationCachePath).toAbsolutePath();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae60adf64b93acc55d6ffeb31fdb63db571b7ee7"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODY3Mjk2OnYy", "diffSide": "RIGHT", "path": "cdap-common/src/main/java/io/cdap/cdap/common/io/CachingLocation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDo1MzoyNlrOFuUzjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTowNjowNlrOFuVK9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExOTY5Mg==", "bodyText": "do we need to delete the file at the tmpPath? Or is that somehow handled by Files.createTempFile?", "url": "https://github.com/cdapio/cdap/pull/11886#discussion_r384119692", "createdAt": "2020-02-25T20:53:26Z", "author": {"login": "albertshau"}, "path": "cdap-common/src/main/java/io/cdap/cdap/common/io/CachingLocation.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.common.io;\n+\n+import org.apache.twill.filesystem.Location;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link Location} implementation that caches data read locally to allow efficient re-reading.\n+ */\n+final class CachingLocation implements Location {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CachingLocation.class);\n+\n+  private final LocationFactory locationFactory;\n+  private final Location delegate;\n+  private final CachingPathProvider cachingPathProvider;\n+\n+  CachingLocation(LocationFactory locationFactory, Location delegate, CachingPathProvider cachingPathProvider) {\n+    this.locationFactory = locationFactory;\n+    this.delegate = delegate;\n+    this.cachingPathProvider = cachingPathProvider;\n+  }\n+\n+  @Override\n+  public boolean exists() throws IOException {\n+    return delegate.exists();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return delegate.getName();\n+  }\n+\n+  @Override\n+  public boolean createNew() throws IOException {\n+    return delegate.createNew();\n+  }\n+\n+  @Override\n+  public boolean createNew(String permission) throws IOException {\n+    return delegate.createNew(permission);\n+  }\n+\n+  @Override\n+  public String getPermissions() throws IOException {\n+    return delegate.getPermissions();\n+  }\n+\n+  @Override\n+  public String getOwner() throws IOException {\n+    return delegate.getOwner();\n+  }\n+\n+  @Override\n+  public String getGroup() throws IOException {\n+    return delegate.getGroup();\n+  }\n+\n+  @Override\n+  public void setGroup(String group) throws IOException {\n+    delegate.setGroup(group);\n+  }\n+\n+  @Override\n+  public void setPermissions(String permission) throws IOException {\n+    delegate.setPermissions(permission);\n+  }\n+\n+  @Override\n+  public InputStream getInputStream() throws IOException {\n+    Path cachePath = cachingPathProvider.apply(delegate).orElse(null);\n+    if (cachePath == null) {\n+      return delegate.getInputStream();\n+    }\n+\n+    try {\n+      return new FileInputStream(cachePath.toFile());\n+    } catch (IOException e) {\n+      // If fail to open stream from the cache, try to regenerate it.\n+      Files.deleteIfExists(cachePath);\n+    }\n+\n+    try (InputStream input = delegate.getInputStream()) {\n+      Files.createDirectories(cachePath.getParent());\n+      Path tmpPath = Files.createTempFile(cachePath.getParent(), cachePath.getFileName().toString(), \".tmp\",\n+                                          PosixFilePermissions.asFileAttribute(\n+                                            PosixFilePermissions.fromString(\"rw-------\")));\n+      Files.copy(input, tmpPath, StandardCopyOption.REPLACE_EXISTING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae60adf64b93acc55d6ffeb31fdb63db571b7ee7"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyNTY4Ng==", "bodyText": "It is handled by StandardCopyOption.REPLACE_EXISTING.", "url": "https://github.com/cdapio/cdap/pull/11886#discussion_r384125686", "createdAt": "2020-02-25T21:06:06Z", "author": {"login": "chtyim"}, "path": "cdap-common/src/main/java/io/cdap/cdap/common/io/CachingLocation.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.common.io;\n+\n+import org.apache.twill.filesystem.Location;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link Location} implementation that caches data read locally to allow efficient re-reading.\n+ */\n+final class CachingLocation implements Location {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CachingLocation.class);\n+\n+  private final LocationFactory locationFactory;\n+  private final Location delegate;\n+  private final CachingPathProvider cachingPathProvider;\n+\n+  CachingLocation(LocationFactory locationFactory, Location delegate, CachingPathProvider cachingPathProvider) {\n+    this.locationFactory = locationFactory;\n+    this.delegate = delegate;\n+    this.cachingPathProvider = cachingPathProvider;\n+  }\n+\n+  @Override\n+  public boolean exists() throws IOException {\n+    return delegate.exists();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return delegate.getName();\n+  }\n+\n+  @Override\n+  public boolean createNew() throws IOException {\n+    return delegate.createNew();\n+  }\n+\n+  @Override\n+  public boolean createNew(String permission) throws IOException {\n+    return delegate.createNew(permission);\n+  }\n+\n+  @Override\n+  public String getPermissions() throws IOException {\n+    return delegate.getPermissions();\n+  }\n+\n+  @Override\n+  public String getOwner() throws IOException {\n+    return delegate.getOwner();\n+  }\n+\n+  @Override\n+  public String getGroup() throws IOException {\n+    return delegate.getGroup();\n+  }\n+\n+  @Override\n+  public void setGroup(String group) throws IOException {\n+    delegate.setGroup(group);\n+  }\n+\n+  @Override\n+  public void setPermissions(String permission) throws IOException {\n+    delegate.setPermissions(permission);\n+  }\n+\n+  @Override\n+  public InputStream getInputStream() throws IOException {\n+    Path cachePath = cachingPathProvider.apply(delegate).orElse(null);\n+    if (cachePath == null) {\n+      return delegate.getInputStream();\n+    }\n+\n+    try {\n+      return new FileInputStream(cachePath.toFile());\n+    } catch (IOException e) {\n+      // If fail to open stream from the cache, try to regenerate it.\n+      Files.deleteIfExists(cachePath);\n+    }\n+\n+    try (InputStream input = delegate.getInputStream()) {\n+      Files.createDirectories(cachePath.getParent());\n+      Path tmpPath = Files.createTempFile(cachePath.getParent(), cachePath.getFileName().toString(), \".tmp\",\n+                                          PosixFilePermissions.asFileAttribute(\n+                                            PosixFilePermissions.fromString(\"rw-------\")));\n+      Files.copy(input, tmpPath, StandardCopyOption.REPLACE_EXISTING);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExOTY5Mg=="}, "originalCommit": {"oid": "ae60adf64b93acc55d6ffeb31fdb63db571b7ee7"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2954, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}