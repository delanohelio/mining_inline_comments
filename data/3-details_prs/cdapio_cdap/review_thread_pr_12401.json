{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5MDI0MjQ3", "number": 12401, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxMjoxMlrOESs7BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1NToxNFrOESt6Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ1ODI4OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/preview/PreviewConfigModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxMjoxMlrOG4Bj9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo0NzowOVrOG4Ve8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM5OTAyOA==", "bodyText": "globalTMS", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461399028", "createdAt": "2020-07-28T08:12:12Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/preview/PreviewConfigModule.java", "diffHunk": "@@ -42,6 +42,7 @@\n   public static final String PREVIEW_HCONF = \"previewHConf\";\n   public static final String PREVIEW_SCONF = \"previewSConf\";\n   public static final String PREVIEW_LEVEL_DB = \"previewLevelDB\";\n+  public static final String GLOBAL_TMS = \"globaltms\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyNTQyNg==", "bodyText": "done.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461725426", "createdAt": "2020-07-28T16:47:09Z", "author": {"login": "sagarkapare"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/app/preview/PreviewConfigModule.java", "diffHunk": "@@ -42,6 +42,7 @@\n   public static final String PREVIEW_HCONF = \"previewHConf\";\n   public static final String PREVIEW_SCONF = \"previewSConf\";\n   public static final String PREVIEW_LEVEL_DB = \"previewLevelDB\";\n+  public static final String GLOBAL_TMS = \"globaltms\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM5OTAyOA=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ2ODk4OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/DefaultPreviewManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxNToxMFrOG4Bqjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo0NzoyOFrOG4Vftg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMDcxOA==", "bodyText": "Make the subscriberService a field and only call the injector.getInstance once in the startUp method. This makes it clear it is the same instance instead of relying on the singleton binding, which is not clear in this context.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461400718", "createdAt": "2020-07-28T08:15:10Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/DefaultPreviewManager.java", "diffHunk": "@@ -143,15 +147,20 @@\n     this.previewRequestQueue = previewRequestQueue;\n     this.previewStore = new DefaultPreviewStore(previewLevelDBTableService);\n     this.previewRunnerServiceStopper = previewRunnerServiceStopper;\n+    this.messagingService = messagingService;\n   }\n \n   @Override\n-  protected synchronized void startUp() throws Exception {\n+  protected void startUp() throws Exception {\n     previewInjector = createPreviewInjector();\n+    PreviewDataSubscriberService subscriberService = previewInjector.getInstance(PreviewDataSubscriberService.class);\n+    subscriberService.startAndWait();\n   }\n \n   @Override\n   protected void shutDown() throws Exception {\n+    PreviewDataSubscriberService subscriberService = previewInjector.getInstance(PreviewDataSubscriberService.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyNTYyMg==", "bodyText": "Good point! fixed.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461725622", "createdAt": "2020-07-28T16:47:28Z", "author": {"login": "sagarkapare"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/DefaultPreviewManager.java", "diffHunk": "@@ -143,15 +147,20 @@\n     this.previewRequestQueue = previewRequestQueue;\n     this.previewStore = new DefaultPreviewStore(previewLevelDBTableService);\n     this.previewRunnerServiceStopper = previewRunnerServiceStopper;\n+    this.messagingService = messagingService;\n   }\n \n   @Override\n-  protected synchronized void startUp() throws Exception {\n+  protected void startUp() throws Exception {\n     previewInjector = createPreviewInjector();\n+    PreviewDataSubscriberService subscriberService = previewInjector.getInstance(PreviewDataSubscriberService.class);\n+    subscriberService.startAndWait();\n   }\n \n   @Override\n   protected void shutDown() throws Exception {\n+    PreviewDataSubscriberService subscriberService = previewInjector.getInstance(PreviewDataSubscriberService.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMDcxOA=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ3NDg4OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/DefaultPreviewRequestQueue.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxNjo0N1rOG4BuQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODowNzo0OFrOG4YeOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMTY2NA==", "bodyText": "I assume this is the persisted queue?? Where will this entry getting removed?", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461401664", "createdAt": "2020-07-28T08:16:47Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/DefaultPreviewRequestQueue.java", "diffHunk": "@@ -99,11 +99,12 @@ public DefaultPreviewRequestQueue(CConfiguration cConf, PreviewStore previewStor\n \n   @Override\n   public void add(PreviewRequest previewRequest) {\n+    previewStore.add(previewRequest.getProgram().getParent(), previewRequest.getAppRequest());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyNjkyMA==", "bodyText": "Entry is persisted before adding to the in-memory queue. If in-memory queue is full with capacity, this entry is removed on line 104.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461726920", "createdAt": "2020-07-28T16:49:29Z", "author": {"login": "sagarkapare"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/DefaultPreviewRequestQueue.java", "diffHunk": "@@ -99,11 +99,12 @@ public DefaultPreviewRequestQueue(CConfiguration cConf, PreviewStore previewStor\n \n   @Override\n   public void add(PreviewRequest previewRequest) {\n+    previewStore.add(previewRequest.getProgram().getParent(), previewRequest.getAppRequest());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMTY2NA=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczMTI2Ng==", "bodyText": "How about on dequeue? Does it get removed?", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461731266", "createdAt": "2020-07-28T16:56:30Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/DefaultPreviewRequestQueue.java", "diffHunk": "@@ -99,11 +99,12 @@ public DefaultPreviewRequestQueue(CConfiguration cConf, PreviewStore previewStor\n \n   @Override\n   public void add(PreviewRequest previewRequest) {\n+    previewStore.add(previewRequest.getProgram().getParent(), previewRequest.getAppRequest());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMTY2NA=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3NDM5NQ==", "bodyText": "yes on dequeue we call\npreviewStore.setPreviewRequestPollerInfo(previewRequest.getProgram().getParent(), pollerInfo);\n\nThis removes from WAITING state.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461774395", "createdAt": "2020-07-28T18:07:48Z", "author": {"login": "sagarkapare"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/DefaultPreviewRequestQueue.java", "diffHunk": "@@ -99,11 +99,12 @@ public DefaultPreviewRequestQueue(CConfiguration cConf, PreviewStore previewStor\n \n   @Override\n   public void add(PreviewRequest previewRequest) {\n+    previewStore.add(previewRequest.getProgram().getParent(), previewRequest.getAppRequest());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMTY2NA=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ3OTM4OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/MessagingPreviewDataPublisher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxODoxMlrOG4BxLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo1MToyNVrOG4Vpjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMjQxMg==", "bodyText": "There is already a system.preview. retries, why not use that?", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461402412", "createdAt": "2020-07-28T08:18:12Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/MessagingPreviewDataPublisher.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.preview;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Named;\n+import io.cdap.cdap.app.preview.PreviewConfigModule;\n+import io.cdap.cdap.app.preview.PreviewDataPublisher;\n+import io.cdap.cdap.app.preview.PreviewMessage;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.service.RetryStrategy;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.messaging.StoreRequest;\n+import io.cdap.cdap.messaging.client.StoreRequestBuilder;\n+import io.cdap.cdap.proto.id.EntityId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.TopicId;\n+\n+/**\n+ * Preview data publisher that publishes to the TMS.\n+ */\n+public class MessagingPreviewDataPublisher implements PreviewDataPublisher {\n+  private static final Gson GSON = new Gson();\n+\n+  private final TopicId topic;\n+  private final MessagingService messagingService;\n+  private final RetryStrategy retryStrategy;\n+\n+  @Inject\n+  MessagingPreviewDataPublisher(CConfiguration cConf,\n+                                @Named(PreviewConfigModule.GLOBAL_TMS) MessagingService messagingService) {\n+    this.topic = NamespaceId.SYSTEM.topic(cConf.get(Constants.Preview.MESSAGING_TOPIC));\n+    this.messagingService = messagingService;\n+    //TODO using system.metadata properties", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyODE0Mw==", "bodyText": "system.preview. was added after this PR was opened.. missed updating this.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461728143", "createdAt": "2020-07-28T16:51:25Z", "author": {"login": "sagarkapare"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/MessagingPreviewDataPublisher.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.preview;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Named;\n+import io.cdap.cdap.app.preview.PreviewConfigModule;\n+import io.cdap.cdap.app.preview.PreviewDataPublisher;\n+import io.cdap.cdap.app.preview.PreviewMessage;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.service.RetryStrategy;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.messaging.StoreRequest;\n+import io.cdap.cdap.messaging.client.StoreRequestBuilder;\n+import io.cdap.cdap.proto.id.EntityId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.TopicId;\n+\n+/**\n+ * Preview data publisher that publishes to the TMS.\n+ */\n+public class MessagingPreviewDataPublisher implements PreviewDataPublisher {\n+  private static final Gson GSON = new Gson();\n+\n+  private final TopicId topic;\n+  private final MessagingService messagingService;\n+  private final RetryStrategy retryStrategy;\n+\n+  @Inject\n+  MessagingPreviewDataPublisher(CConfiguration cConf,\n+                                @Named(PreviewConfigModule.GLOBAL_TMS) MessagingService messagingService) {\n+    this.topic = NamespaceId.SYSTEM.topic(cConf.get(Constants.Preview.MESSAGING_TOPIC));\n+    this.messagingService = messagingService;\n+    //TODO using system.metadata properties", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMjQxMg=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ4MzA3OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/MessagingPreviewDataPublisher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxOToxM1rOG4BzgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo1MTo1OFrOG4Vq-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMzAwOA==", "bodyText": "Why use ALWAYS_TRUE? We don't want to retry if the error is non-recoverable by retry", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461403008", "createdAt": "2020-07-28T08:19:13Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/MessagingPreviewDataPublisher.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.preview;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Named;\n+import io.cdap.cdap.app.preview.PreviewConfigModule;\n+import io.cdap.cdap.app.preview.PreviewDataPublisher;\n+import io.cdap.cdap.app.preview.PreviewMessage;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.service.RetryStrategy;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.messaging.StoreRequest;\n+import io.cdap.cdap.messaging.client.StoreRequestBuilder;\n+import io.cdap.cdap.proto.id.EntityId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.TopicId;\n+\n+/**\n+ * Preview data publisher that publishes to the TMS.\n+ */\n+public class MessagingPreviewDataPublisher implements PreviewDataPublisher {\n+  private static final Gson GSON = new Gson();\n+\n+  private final TopicId topic;\n+  private final MessagingService messagingService;\n+  private final RetryStrategy retryStrategy;\n+\n+  @Inject\n+  MessagingPreviewDataPublisher(CConfiguration cConf,\n+                                @Named(PreviewConfigModule.GLOBAL_TMS) MessagingService messagingService) {\n+    this.topic = NamespaceId.SYSTEM.topic(cConf.get(Constants.Preview.MESSAGING_TOPIC));\n+    this.messagingService = messagingService;\n+    //TODO using system.metadata properties\n+    this.retryStrategy = RetryStrategies.fromConfiguration(cConf, \"system.metadata.\");\n+  }\n+\n+  @Override\n+  public void publish(EntityId entityId, PreviewMessage previewMessage) {\n+    StoreRequest request = StoreRequestBuilder.of(topic).addPayload(GSON.toJson(previewMessage)).build();\n+    try {\n+      Retries.callWithRetries(() -> messagingService.publish(request), retryStrategy, Retries.ALWAYS_TRUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyODUwNQ==", "bodyText": "retrying now on IOException or RetryableException(i.e. ServiceUnavailableException).", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461728505", "createdAt": "2020-07-28T16:51:58Z", "author": {"login": "sagarkapare"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/MessagingPreviewDataPublisher.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.preview;\n+\n+import com.google.gson.Gson;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Named;\n+import io.cdap.cdap.app.preview.PreviewConfigModule;\n+import io.cdap.cdap.app.preview.PreviewDataPublisher;\n+import io.cdap.cdap.app.preview.PreviewMessage;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.Retries;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.service.RetryStrategy;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.messaging.StoreRequest;\n+import io.cdap.cdap.messaging.client.StoreRequestBuilder;\n+import io.cdap.cdap.proto.id.EntityId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.TopicId;\n+\n+/**\n+ * Preview data publisher that publishes to the TMS.\n+ */\n+public class MessagingPreviewDataPublisher implements PreviewDataPublisher {\n+  private static final Gson GSON = new Gson();\n+\n+  private final TopicId topic;\n+  private final MessagingService messagingService;\n+  private final RetryStrategy retryStrategy;\n+\n+  @Inject\n+  MessagingPreviewDataPublisher(CConfiguration cConf,\n+                                @Named(PreviewConfigModule.GLOBAL_TMS) MessagingService messagingService) {\n+    this.topic = NamespaceId.SYSTEM.topic(cConf.get(Constants.Preview.MESSAGING_TOPIC));\n+    this.messagingService = messagingService;\n+    //TODO using system.metadata properties\n+    this.retryStrategy = RetryStrategies.fromConfiguration(cConf, \"system.metadata.\");\n+  }\n+\n+  @Override\n+  public void publish(EntityId entityId, PreviewMessage previewMessage) {\n+    StoreRequest request = StoreRequestBuilder.of(topic).addPayload(GSON.toJson(previewMessage)).build();\n+    try {\n+      Retries.callWithRetries(() -> messagingService.publish(request), retryStrategy, Retries.ALWAYS_TRUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMzAwOA=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDYwNTg3OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/PreviewDataSubscriberService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1MTozNVrOG4DADw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo1MjowNlrOG4VrYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyMjYwNw==", "bodyText": "Remove this. You don't need to declare a no-op default constructor", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461422607", "createdAt": "2020-07-28T08:51:35Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/PreviewDataSubscriberService.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.preview;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Named;\n+import io.cdap.cdap.api.messaging.Message;\n+import io.cdap.cdap.api.messaging.MessagingContext;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.preview.DefaultPreviewRunnerModule;\n+import io.cdap.cdap.app.preview.PreviewConfigModule;\n+import io.cdap.cdap.app.preview.PreviewMessage;\n+import io.cdap.cdap.app.preview.PreviewStatus;\n+import io.cdap.cdap.app.store.preview.PreviewStore;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.messaging.context.MultiThreadMessagingContext;\n+import io.cdap.cdap.messaging.subscriber.AbstractMessagingSubscriberService;\n+import io.cdap.cdap.proto.codec.EntityIdTypeAdapter;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.EntityId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.tephra.TxConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Service responsible for consuming preview messages from TMS and persist it to preview store.\n+ */\n+public class PreviewDataSubscriberService extends AbstractMessagingSubscriberService<PreviewMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(PreviewDataSubscriberService.class);\n+  private static final Gson GSON = new GsonBuilder()\n+    .registerTypeAdapter(EntityId.class, new EntityIdTypeAdapter())\n+    .create();\n+\n+  private final PreviewStore previewStore;\n+  private final MultiThreadMessagingContext messagingContext;\n+  private final TransactionRunner transactionRunner;\n+  private final int maxRetriesOnError;\n+  private int errorCount = 0;\n+  private String erroredMessageId = null;\n+\n+  /**\n+   * Constructor.\n+   */\n+  @Inject\n+  PreviewDataSubscriberService(CConfiguration cConf,\n+                               @Named(PreviewConfigModule.GLOBAL_TMS) MessagingService messagingService,\n+                               MetricsCollectionService metricsCollectionService, PreviewStore previewStore,\n+                               TransactionRunner transactionRunner) {\n+    super(\n+      NamespaceId.SYSTEM.topic(cConf.get(Constants.Preview.MESSAGING_TOPIC)),\n+      cConf.getInt(Constants.Metadata.MESSAGING_FETCH_SIZE),\n+      cConf.getInt(TxConstants.Manager.CFG_TX_TIMEOUT),\n+      cConf.getLong(Constants.Metadata.MESSAGING_POLL_DELAY_MILLIS),\n+      // TODO: using same configs as metadata\n+      RetryStrategies.fromConfiguration(cConf, \"system.metadata.\"),\n+      metricsCollectionService.getContext(ImmutableMap.of(\n+        Constants.Metrics.Tag.COMPONENT, Constants.Service.MASTER_SERVICES,\n+        Constants.Metrics.Tag.INSTANCE_ID, \"0\",\n+        Constants.Metrics.Tag.NAMESPACE, NamespaceId.SYSTEM.getNamespace(),\n+        Constants.Metrics.Tag.TOPIC, cConf.get(Constants.Preview.MESSAGING_TOPIC),\n+        Constants.Metrics.Tag.CONSUMER, \"preview.writer\"\n+      )));\n+\n+    this.messagingContext = new MultiThreadMessagingContext(messagingService);\n+    this.previewStore = previewStore;\n+    this.transactionRunner = transactionRunner;\n+    this.maxRetriesOnError = cConf.getInt(Constants.Metadata.MESSAGING_RETRIES_ON_CONFLICT);\n+  }\n+\n+  @Override\n+  protected TransactionRunner getTransactionRunner() {\n+    return transactionRunner;\n+  }\n+\n+  @Nullable\n+  @Override\n+  protected String loadMessageId(StructuredTableContext context) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    return appMetadataStore.retrieveSubscriberState(getTopicId().getTopic(), \"preview.writer\");\n+  }\n+\n+  @Override\n+  protected void storeMessageId(StructuredTableContext context, String messageId) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    appMetadataStore.persistSubscriberState(getTopicId().getTopic(), \"preview.writer\", messageId);\n+  }\n+\n+  @Override\n+  protected void processMessages(StructuredTableContext structuredTableContext,\n+                                 Iterator<ImmutablePair<String, PreviewMessage>> messages) throws Exception {\n+    Map<PreviewMessage.Type, PreviewMessageProcessor> processors = new HashMap<>();\n+\n+    // Loop over all fetched messages and process them with corresponding PreviewMessageProcessor\n+    while (messages.hasNext()) {\n+      ImmutablePair<String, PreviewMessage> next = messages.next();\n+      String messageId = next.getFirst();\n+      PreviewMessage message = next.getSecond();\n+\n+      PreviewMessageProcessor processor = processors.computeIfAbsent(message.getType(), type -> {\n+        switch (type) {\n+          case DATA:\n+            return new PreviewDataProcessor();\n+          case STATUS:\n+            return new PreviewStatusWriter();\n+          case PROGRAM_RUN_ID:\n+            return new PreviewProgramRunIdWriter();\n+          default:\n+            return null;\n+        }\n+      });\n+\n+      // noinspection ConstantConditions\n+      if (processor == null) {\n+        LOG.warn(\"Unsupported preview message type {}. Message ignored.\", message.getType());\n+        continue;\n+      }\n+      try {\n+        processor.processMessage(message);\n+        errorCount = 0;\n+      } catch (Exception e) {\n+        if (messageId.equals(erroredMessageId)) {\n+          errorCount++;\n+          if (errorCount >= maxRetriesOnError) {\n+            LOG.warn(\"Skipping preview message {} after processing it has caused {} consecutive errors: {}\",\n+                     message, errorCount, e.getMessage());\n+            continue;\n+          }\n+        } else {\n+          erroredMessageId = messageId;\n+          errorCount = 1;\n+        }\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  protected MessagingContext getMessagingContext() {\n+    return messagingContext;\n+  }\n+\n+  @Override\n+  protected PreviewMessage decodeMessage(Message message) {\n+    return GSON.fromJson(message.getPayloadAsString(), PreviewMessage.class);\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for processing preview data.\n+   */\n+  private final class PreviewDataProcessor implements PreviewMessageProcessor {\n+    PreviewDataProcessor() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyODYwOA==", "bodyText": "done.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461728608", "createdAt": "2020-07-28T16:52:06Z", "author": {"login": "sagarkapare"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/PreviewDataSubscriberService.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.preview;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Named;\n+import io.cdap.cdap.api.messaging.Message;\n+import io.cdap.cdap.api.messaging.MessagingContext;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.preview.DefaultPreviewRunnerModule;\n+import io.cdap.cdap.app.preview.PreviewConfigModule;\n+import io.cdap.cdap.app.preview.PreviewMessage;\n+import io.cdap.cdap.app.preview.PreviewStatus;\n+import io.cdap.cdap.app.store.preview.PreviewStore;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.messaging.context.MultiThreadMessagingContext;\n+import io.cdap.cdap.messaging.subscriber.AbstractMessagingSubscriberService;\n+import io.cdap.cdap.proto.codec.EntityIdTypeAdapter;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.EntityId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.tephra.TxConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Service responsible for consuming preview messages from TMS and persist it to preview store.\n+ */\n+public class PreviewDataSubscriberService extends AbstractMessagingSubscriberService<PreviewMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(PreviewDataSubscriberService.class);\n+  private static final Gson GSON = new GsonBuilder()\n+    .registerTypeAdapter(EntityId.class, new EntityIdTypeAdapter())\n+    .create();\n+\n+  private final PreviewStore previewStore;\n+  private final MultiThreadMessagingContext messagingContext;\n+  private final TransactionRunner transactionRunner;\n+  private final int maxRetriesOnError;\n+  private int errorCount = 0;\n+  private String erroredMessageId = null;\n+\n+  /**\n+   * Constructor.\n+   */\n+  @Inject\n+  PreviewDataSubscriberService(CConfiguration cConf,\n+                               @Named(PreviewConfigModule.GLOBAL_TMS) MessagingService messagingService,\n+                               MetricsCollectionService metricsCollectionService, PreviewStore previewStore,\n+                               TransactionRunner transactionRunner) {\n+    super(\n+      NamespaceId.SYSTEM.topic(cConf.get(Constants.Preview.MESSAGING_TOPIC)),\n+      cConf.getInt(Constants.Metadata.MESSAGING_FETCH_SIZE),\n+      cConf.getInt(TxConstants.Manager.CFG_TX_TIMEOUT),\n+      cConf.getLong(Constants.Metadata.MESSAGING_POLL_DELAY_MILLIS),\n+      // TODO: using same configs as metadata\n+      RetryStrategies.fromConfiguration(cConf, \"system.metadata.\"),\n+      metricsCollectionService.getContext(ImmutableMap.of(\n+        Constants.Metrics.Tag.COMPONENT, Constants.Service.MASTER_SERVICES,\n+        Constants.Metrics.Tag.INSTANCE_ID, \"0\",\n+        Constants.Metrics.Tag.NAMESPACE, NamespaceId.SYSTEM.getNamespace(),\n+        Constants.Metrics.Tag.TOPIC, cConf.get(Constants.Preview.MESSAGING_TOPIC),\n+        Constants.Metrics.Tag.CONSUMER, \"preview.writer\"\n+      )));\n+\n+    this.messagingContext = new MultiThreadMessagingContext(messagingService);\n+    this.previewStore = previewStore;\n+    this.transactionRunner = transactionRunner;\n+    this.maxRetriesOnError = cConf.getInt(Constants.Metadata.MESSAGING_RETRIES_ON_CONFLICT);\n+  }\n+\n+  @Override\n+  protected TransactionRunner getTransactionRunner() {\n+    return transactionRunner;\n+  }\n+\n+  @Nullable\n+  @Override\n+  protected String loadMessageId(StructuredTableContext context) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    return appMetadataStore.retrieveSubscriberState(getTopicId().getTopic(), \"preview.writer\");\n+  }\n+\n+  @Override\n+  protected void storeMessageId(StructuredTableContext context, String messageId) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    appMetadataStore.persistSubscriberState(getTopicId().getTopic(), \"preview.writer\", messageId);\n+  }\n+\n+  @Override\n+  protected void processMessages(StructuredTableContext structuredTableContext,\n+                                 Iterator<ImmutablePair<String, PreviewMessage>> messages) throws Exception {\n+    Map<PreviewMessage.Type, PreviewMessageProcessor> processors = new HashMap<>();\n+\n+    // Loop over all fetched messages and process them with corresponding PreviewMessageProcessor\n+    while (messages.hasNext()) {\n+      ImmutablePair<String, PreviewMessage> next = messages.next();\n+      String messageId = next.getFirst();\n+      PreviewMessage message = next.getSecond();\n+\n+      PreviewMessageProcessor processor = processors.computeIfAbsent(message.getType(), type -> {\n+        switch (type) {\n+          case DATA:\n+            return new PreviewDataProcessor();\n+          case STATUS:\n+            return new PreviewStatusWriter();\n+          case PROGRAM_RUN_ID:\n+            return new PreviewProgramRunIdWriter();\n+          default:\n+            return null;\n+        }\n+      });\n+\n+      // noinspection ConstantConditions\n+      if (processor == null) {\n+        LOG.warn(\"Unsupported preview message type {}. Message ignored.\", message.getType());\n+        continue;\n+      }\n+      try {\n+        processor.processMessage(message);\n+        errorCount = 0;\n+      } catch (Exception e) {\n+        if (messageId.equals(erroredMessageId)) {\n+          errorCount++;\n+          if (errorCount >= maxRetriesOnError) {\n+            LOG.warn(\"Skipping preview message {} after processing it has caused {} consecutive errors: {}\",\n+                     message, errorCount, e.getMessage());\n+            continue;\n+          }\n+        } else {\n+          erroredMessageId = messageId;\n+          errorCount = 1;\n+        }\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  protected MessagingContext getMessagingContext() {\n+    return messagingContext;\n+  }\n+\n+  @Override\n+  protected PreviewMessage decodeMessage(Message message) {\n+    return GSON.fromJson(message.getPayloadAsString(), PreviewMessage.class);\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for processing preview data.\n+   */\n+  private final class PreviewDataProcessor implements PreviewMessageProcessor {\n+    PreviewDataProcessor() {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyMjYwNw=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDYwNzU0OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/PreviewDataSubscriberService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1MjowMVrOG4DBJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo1MjoxMVrOG4Vruw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyMjg4Ng==", "bodyText": "Remove", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461422886", "createdAt": "2020-07-28T08:52:01Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/PreviewDataSubscriberService.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.preview;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Named;\n+import io.cdap.cdap.api.messaging.Message;\n+import io.cdap.cdap.api.messaging.MessagingContext;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.preview.DefaultPreviewRunnerModule;\n+import io.cdap.cdap.app.preview.PreviewConfigModule;\n+import io.cdap.cdap.app.preview.PreviewMessage;\n+import io.cdap.cdap.app.preview.PreviewStatus;\n+import io.cdap.cdap.app.store.preview.PreviewStore;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.messaging.context.MultiThreadMessagingContext;\n+import io.cdap.cdap.messaging.subscriber.AbstractMessagingSubscriberService;\n+import io.cdap.cdap.proto.codec.EntityIdTypeAdapter;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.EntityId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.tephra.TxConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Service responsible for consuming preview messages from TMS and persist it to preview store.\n+ */\n+public class PreviewDataSubscriberService extends AbstractMessagingSubscriberService<PreviewMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(PreviewDataSubscriberService.class);\n+  private static final Gson GSON = new GsonBuilder()\n+    .registerTypeAdapter(EntityId.class, new EntityIdTypeAdapter())\n+    .create();\n+\n+  private final PreviewStore previewStore;\n+  private final MultiThreadMessagingContext messagingContext;\n+  private final TransactionRunner transactionRunner;\n+  private final int maxRetriesOnError;\n+  private int errorCount = 0;\n+  private String erroredMessageId = null;\n+\n+  /**\n+   * Constructor.\n+   */\n+  @Inject\n+  PreviewDataSubscriberService(CConfiguration cConf,\n+                               @Named(PreviewConfigModule.GLOBAL_TMS) MessagingService messagingService,\n+                               MetricsCollectionService metricsCollectionService, PreviewStore previewStore,\n+                               TransactionRunner transactionRunner) {\n+    super(\n+      NamespaceId.SYSTEM.topic(cConf.get(Constants.Preview.MESSAGING_TOPIC)),\n+      cConf.getInt(Constants.Metadata.MESSAGING_FETCH_SIZE),\n+      cConf.getInt(TxConstants.Manager.CFG_TX_TIMEOUT),\n+      cConf.getLong(Constants.Metadata.MESSAGING_POLL_DELAY_MILLIS),\n+      // TODO: using same configs as metadata\n+      RetryStrategies.fromConfiguration(cConf, \"system.metadata.\"),\n+      metricsCollectionService.getContext(ImmutableMap.of(\n+        Constants.Metrics.Tag.COMPONENT, Constants.Service.MASTER_SERVICES,\n+        Constants.Metrics.Tag.INSTANCE_ID, \"0\",\n+        Constants.Metrics.Tag.NAMESPACE, NamespaceId.SYSTEM.getNamespace(),\n+        Constants.Metrics.Tag.TOPIC, cConf.get(Constants.Preview.MESSAGING_TOPIC),\n+        Constants.Metrics.Tag.CONSUMER, \"preview.writer\"\n+      )));\n+\n+    this.messagingContext = new MultiThreadMessagingContext(messagingService);\n+    this.previewStore = previewStore;\n+    this.transactionRunner = transactionRunner;\n+    this.maxRetriesOnError = cConf.getInt(Constants.Metadata.MESSAGING_RETRIES_ON_CONFLICT);\n+  }\n+\n+  @Override\n+  protected TransactionRunner getTransactionRunner() {\n+    return transactionRunner;\n+  }\n+\n+  @Nullable\n+  @Override\n+  protected String loadMessageId(StructuredTableContext context) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    return appMetadataStore.retrieveSubscriberState(getTopicId().getTopic(), \"preview.writer\");\n+  }\n+\n+  @Override\n+  protected void storeMessageId(StructuredTableContext context, String messageId) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    appMetadataStore.persistSubscriberState(getTopicId().getTopic(), \"preview.writer\", messageId);\n+  }\n+\n+  @Override\n+  protected void processMessages(StructuredTableContext structuredTableContext,\n+                                 Iterator<ImmutablePair<String, PreviewMessage>> messages) throws Exception {\n+    Map<PreviewMessage.Type, PreviewMessageProcessor> processors = new HashMap<>();\n+\n+    // Loop over all fetched messages and process them with corresponding PreviewMessageProcessor\n+    while (messages.hasNext()) {\n+      ImmutablePair<String, PreviewMessage> next = messages.next();\n+      String messageId = next.getFirst();\n+      PreviewMessage message = next.getSecond();\n+\n+      PreviewMessageProcessor processor = processors.computeIfAbsent(message.getType(), type -> {\n+        switch (type) {\n+          case DATA:\n+            return new PreviewDataProcessor();\n+          case STATUS:\n+            return new PreviewStatusWriter();\n+          case PROGRAM_RUN_ID:\n+            return new PreviewProgramRunIdWriter();\n+          default:\n+            return null;\n+        }\n+      });\n+\n+      // noinspection ConstantConditions\n+      if (processor == null) {\n+        LOG.warn(\"Unsupported preview message type {}. Message ignored.\", message.getType());\n+        continue;\n+      }\n+      try {\n+        processor.processMessage(message);\n+        errorCount = 0;\n+      } catch (Exception e) {\n+        if (messageId.equals(erroredMessageId)) {\n+          errorCount++;\n+          if (errorCount >= maxRetriesOnError) {\n+            LOG.warn(\"Skipping preview message {} after processing it has caused {} consecutive errors: {}\",\n+                     message, errorCount, e.getMessage());\n+            continue;\n+          }\n+        } else {\n+          erroredMessageId = messageId;\n+          errorCount = 1;\n+        }\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  protected MessagingContext getMessagingContext() {\n+    return messagingContext;\n+  }\n+\n+  @Override\n+  protected PreviewMessage decodeMessage(Message message) {\n+    return GSON.fromJson(message.getPayloadAsString(), PreviewMessage.class);\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for processing preview data.\n+   */\n+  private final class PreviewDataProcessor implements PreviewMessageProcessor {\n+    PreviewDataProcessor() {}\n+\n+    @Override\n+    public void processMessage(PreviewMessage message) {\n+      if (!(message.getEntityId() instanceof ApplicationId)) {\n+        LOG.warn(\"Missing application id from the preview data information. Ignoring the message {}\", message);\n+        return;\n+      }\n+\n+      ApplicationId applicationId = (ApplicationId) message.getEntityId();\n+      PreviewDataPayload payload;\n+      try {\n+        payload = message.getPayload(GSON, PreviewDataPayload.class);\n+      } catch (Throwable t) {\n+        LOG.warn(\"Error while deserializing the preview data message received from TMS. Ignoring : {}\",\n+                 message, t);\n+        return;\n+      }\n+      previewStore.put(applicationId, payload.getTracerName(), payload.getPropertyName(), payload.getPropertyValue());\n+    }\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for writing preview status to store.\n+   */\n+  private final class PreviewStatusWriter implements PreviewMessageProcessor {\n+    PreviewStatusWriter() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyODY5OQ==", "bodyText": "done.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461728699", "createdAt": "2020-07-28T16:52:11Z", "author": {"login": "sagarkapare"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/PreviewDataSubscriberService.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.preview;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Named;\n+import io.cdap.cdap.api.messaging.Message;\n+import io.cdap.cdap.api.messaging.MessagingContext;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.preview.DefaultPreviewRunnerModule;\n+import io.cdap.cdap.app.preview.PreviewConfigModule;\n+import io.cdap.cdap.app.preview.PreviewMessage;\n+import io.cdap.cdap.app.preview.PreviewStatus;\n+import io.cdap.cdap.app.store.preview.PreviewStore;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.messaging.context.MultiThreadMessagingContext;\n+import io.cdap.cdap.messaging.subscriber.AbstractMessagingSubscriberService;\n+import io.cdap.cdap.proto.codec.EntityIdTypeAdapter;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.EntityId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.tephra.TxConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Service responsible for consuming preview messages from TMS and persist it to preview store.\n+ */\n+public class PreviewDataSubscriberService extends AbstractMessagingSubscriberService<PreviewMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(PreviewDataSubscriberService.class);\n+  private static final Gson GSON = new GsonBuilder()\n+    .registerTypeAdapter(EntityId.class, new EntityIdTypeAdapter())\n+    .create();\n+\n+  private final PreviewStore previewStore;\n+  private final MultiThreadMessagingContext messagingContext;\n+  private final TransactionRunner transactionRunner;\n+  private final int maxRetriesOnError;\n+  private int errorCount = 0;\n+  private String erroredMessageId = null;\n+\n+  /**\n+   * Constructor.\n+   */\n+  @Inject\n+  PreviewDataSubscriberService(CConfiguration cConf,\n+                               @Named(PreviewConfigModule.GLOBAL_TMS) MessagingService messagingService,\n+                               MetricsCollectionService metricsCollectionService, PreviewStore previewStore,\n+                               TransactionRunner transactionRunner) {\n+    super(\n+      NamespaceId.SYSTEM.topic(cConf.get(Constants.Preview.MESSAGING_TOPIC)),\n+      cConf.getInt(Constants.Metadata.MESSAGING_FETCH_SIZE),\n+      cConf.getInt(TxConstants.Manager.CFG_TX_TIMEOUT),\n+      cConf.getLong(Constants.Metadata.MESSAGING_POLL_DELAY_MILLIS),\n+      // TODO: using same configs as metadata\n+      RetryStrategies.fromConfiguration(cConf, \"system.metadata.\"),\n+      metricsCollectionService.getContext(ImmutableMap.of(\n+        Constants.Metrics.Tag.COMPONENT, Constants.Service.MASTER_SERVICES,\n+        Constants.Metrics.Tag.INSTANCE_ID, \"0\",\n+        Constants.Metrics.Tag.NAMESPACE, NamespaceId.SYSTEM.getNamespace(),\n+        Constants.Metrics.Tag.TOPIC, cConf.get(Constants.Preview.MESSAGING_TOPIC),\n+        Constants.Metrics.Tag.CONSUMER, \"preview.writer\"\n+      )));\n+\n+    this.messagingContext = new MultiThreadMessagingContext(messagingService);\n+    this.previewStore = previewStore;\n+    this.transactionRunner = transactionRunner;\n+    this.maxRetriesOnError = cConf.getInt(Constants.Metadata.MESSAGING_RETRIES_ON_CONFLICT);\n+  }\n+\n+  @Override\n+  protected TransactionRunner getTransactionRunner() {\n+    return transactionRunner;\n+  }\n+\n+  @Nullable\n+  @Override\n+  protected String loadMessageId(StructuredTableContext context) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    return appMetadataStore.retrieveSubscriberState(getTopicId().getTopic(), \"preview.writer\");\n+  }\n+\n+  @Override\n+  protected void storeMessageId(StructuredTableContext context, String messageId) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    appMetadataStore.persistSubscriberState(getTopicId().getTopic(), \"preview.writer\", messageId);\n+  }\n+\n+  @Override\n+  protected void processMessages(StructuredTableContext structuredTableContext,\n+                                 Iterator<ImmutablePair<String, PreviewMessage>> messages) throws Exception {\n+    Map<PreviewMessage.Type, PreviewMessageProcessor> processors = new HashMap<>();\n+\n+    // Loop over all fetched messages and process them with corresponding PreviewMessageProcessor\n+    while (messages.hasNext()) {\n+      ImmutablePair<String, PreviewMessage> next = messages.next();\n+      String messageId = next.getFirst();\n+      PreviewMessage message = next.getSecond();\n+\n+      PreviewMessageProcessor processor = processors.computeIfAbsent(message.getType(), type -> {\n+        switch (type) {\n+          case DATA:\n+            return new PreviewDataProcessor();\n+          case STATUS:\n+            return new PreviewStatusWriter();\n+          case PROGRAM_RUN_ID:\n+            return new PreviewProgramRunIdWriter();\n+          default:\n+            return null;\n+        }\n+      });\n+\n+      // noinspection ConstantConditions\n+      if (processor == null) {\n+        LOG.warn(\"Unsupported preview message type {}. Message ignored.\", message.getType());\n+        continue;\n+      }\n+      try {\n+        processor.processMessage(message);\n+        errorCount = 0;\n+      } catch (Exception e) {\n+        if (messageId.equals(erroredMessageId)) {\n+          errorCount++;\n+          if (errorCount >= maxRetriesOnError) {\n+            LOG.warn(\"Skipping preview message {} after processing it has caused {} consecutive errors: {}\",\n+                     message, errorCount, e.getMessage());\n+            continue;\n+          }\n+        } else {\n+          erroredMessageId = messageId;\n+          errorCount = 1;\n+        }\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  protected MessagingContext getMessagingContext() {\n+    return messagingContext;\n+  }\n+\n+  @Override\n+  protected PreviewMessage decodeMessage(Message message) {\n+    return GSON.fromJson(message.getPayloadAsString(), PreviewMessage.class);\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for processing preview data.\n+   */\n+  private final class PreviewDataProcessor implements PreviewMessageProcessor {\n+    PreviewDataProcessor() {}\n+\n+    @Override\n+    public void processMessage(PreviewMessage message) {\n+      if (!(message.getEntityId() instanceof ApplicationId)) {\n+        LOG.warn(\"Missing application id from the preview data information. Ignoring the message {}\", message);\n+        return;\n+      }\n+\n+      ApplicationId applicationId = (ApplicationId) message.getEntityId();\n+      PreviewDataPayload payload;\n+      try {\n+        payload = message.getPayload(GSON, PreviewDataPayload.class);\n+      } catch (Throwable t) {\n+        LOG.warn(\"Error while deserializing the preview data message received from TMS. Ignoring : {}\",\n+                 message, t);\n+        return;\n+      }\n+      previewStore.put(applicationId, payload.getTracerName(), payload.getPropertyName(), payload.getPropertyValue());\n+    }\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for writing preview status to store.\n+   */\n+  private final class PreviewStatusWriter implements PreviewMessageProcessor {\n+    PreviewStatusWriter() {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyMjg4Ng=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDYwODAwOnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/PreviewDataSubscriberService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1MjoxMFrOG4DBfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo1MjoxOFrOG4Vr_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyMjk3Mw==", "bodyText": "Remove", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461422973", "createdAt": "2020-07-28T08:52:10Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/PreviewDataSubscriberService.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.preview;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Named;\n+import io.cdap.cdap.api.messaging.Message;\n+import io.cdap.cdap.api.messaging.MessagingContext;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.preview.DefaultPreviewRunnerModule;\n+import io.cdap.cdap.app.preview.PreviewConfigModule;\n+import io.cdap.cdap.app.preview.PreviewMessage;\n+import io.cdap.cdap.app.preview.PreviewStatus;\n+import io.cdap.cdap.app.store.preview.PreviewStore;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.messaging.context.MultiThreadMessagingContext;\n+import io.cdap.cdap.messaging.subscriber.AbstractMessagingSubscriberService;\n+import io.cdap.cdap.proto.codec.EntityIdTypeAdapter;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.EntityId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.tephra.TxConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Service responsible for consuming preview messages from TMS and persist it to preview store.\n+ */\n+public class PreviewDataSubscriberService extends AbstractMessagingSubscriberService<PreviewMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(PreviewDataSubscriberService.class);\n+  private static final Gson GSON = new GsonBuilder()\n+    .registerTypeAdapter(EntityId.class, new EntityIdTypeAdapter())\n+    .create();\n+\n+  private final PreviewStore previewStore;\n+  private final MultiThreadMessagingContext messagingContext;\n+  private final TransactionRunner transactionRunner;\n+  private final int maxRetriesOnError;\n+  private int errorCount = 0;\n+  private String erroredMessageId = null;\n+\n+  /**\n+   * Constructor.\n+   */\n+  @Inject\n+  PreviewDataSubscriberService(CConfiguration cConf,\n+                               @Named(PreviewConfigModule.GLOBAL_TMS) MessagingService messagingService,\n+                               MetricsCollectionService metricsCollectionService, PreviewStore previewStore,\n+                               TransactionRunner transactionRunner) {\n+    super(\n+      NamespaceId.SYSTEM.topic(cConf.get(Constants.Preview.MESSAGING_TOPIC)),\n+      cConf.getInt(Constants.Metadata.MESSAGING_FETCH_SIZE),\n+      cConf.getInt(TxConstants.Manager.CFG_TX_TIMEOUT),\n+      cConf.getLong(Constants.Metadata.MESSAGING_POLL_DELAY_MILLIS),\n+      // TODO: using same configs as metadata\n+      RetryStrategies.fromConfiguration(cConf, \"system.metadata.\"),\n+      metricsCollectionService.getContext(ImmutableMap.of(\n+        Constants.Metrics.Tag.COMPONENT, Constants.Service.MASTER_SERVICES,\n+        Constants.Metrics.Tag.INSTANCE_ID, \"0\",\n+        Constants.Metrics.Tag.NAMESPACE, NamespaceId.SYSTEM.getNamespace(),\n+        Constants.Metrics.Tag.TOPIC, cConf.get(Constants.Preview.MESSAGING_TOPIC),\n+        Constants.Metrics.Tag.CONSUMER, \"preview.writer\"\n+      )));\n+\n+    this.messagingContext = new MultiThreadMessagingContext(messagingService);\n+    this.previewStore = previewStore;\n+    this.transactionRunner = transactionRunner;\n+    this.maxRetriesOnError = cConf.getInt(Constants.Metadata.MESSAGING_RETRIES_ON_CONFLICT);\n+  }\n+\n+  @Override\n+  protected TransactionRunner getTransactionRunner() {\n+    return transactionRunner;\n+  }\n+\n+  @Nullable\n+  @Override\n+  protected String loadMessageId(StructuredTableContext context) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    return appMetadataStore.retrieveSubscriberState(getTopicId().getTopic(), \"preview.writer\");\n+  }\n+\n+  @Override\n+  protected void storeMessageId(StructuredTableContext context, String messageId) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    appMetadataStore.persistSubscriberState(getTopicId().getTopic(), \"preview.writer\", messageId);\n+  }\n+\n+  @Override\n+  protected void processMessages(StructuredTableContext structuredTableContext,\n+                                 Iterator<ImmutablePair<String, PreviewMessage>> messages) throws Exception {\n+    Map<PreviewMessage.Type, PreviewMessageProcessor> processors = new HashMap<>();\n+\n+    // Loop over all fetched messages and process them with corresponding PreviewMessageProcessor\n+    while (messages.hasNext()) {\n+      ImmutablePair<String, PreviewMessage> next = messages.next();\n+      String messageId = next.getFirst();\n+      PreviewMessage message = next.getSecond();\n+\n+      PreviewMessageProcessor processor = processors.computeIfAbsent(message.getType(), type -> {\n+        switch (type) {\n+          case DATA:\n+            return new PreviewDataProcessor();\n+          case STATUS:\n+            return new PreviewStatusWriter();\n+          case PROGRAM_RUN_ID:\n+            return new PreviewProgramRunIdWriter();\n+          default:\n+            return null;\n+        }\n+      });\n+\n+      // noinspection ConstantConditions\n+      if (processor == null) {\n+        LOG.warn(\"Unsupported preview message type {}. Message ignored.\", message.getType());\n+        continue;\n+      }\n+      try {\n+        processor.processMessage(message);\n+        errorCount = 0;\n+      } catch (Exception e) {\n+        if (messageId.equals(erroredMessageId)) {\n+          errorCount++;\n+          if (errorCount >= maxRetriesOnError) {\n+            LOG.warn(\"Skipping preview message {} after processing it has caused {} consecutive errors: {}\",\n+                     message, errorCount, e.getMessage());\n+            continue;\n+          }\n+        } else {\n+          erroredMessageId = messageId;\n+          errorCount = 1;\n+        }\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  protected MessagingContext getMessagingContext() {\n+    return messagingContext;\n+  }\n+\n+  @Override\n+  protected PreviewMessage decodeMessage(Message message) {\n+    return GSON.fromJson(message.getPayloadAsString(), PreviewMessage.class);\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for processing preview data.\n+   */\n+  private final class PreviewDataProcessor implements PreviewMessageProcessor {\n+    PreviewDataProcessor() {}\n+\n+    @Override\n+    public void processMessage(PreviewMessage message) {\n+      if (!(message.getEntityId() instanceof ApplicationId)) {\n+        LOG.warn(\"Missing application id from the preview data information. Ignoring the message {}\", message);\n+        return;\n+      }\n+\n+      ApplicationId applicationId = (ApplicationId) message.getEntityId();\n+      PreviewDataPayload payload;\n+      try {\n+        payload = message.getPayload(GSON, PreviewDataPayload.class);\n+      } catch (Throwable t) {\n+        LOG.warn(\"Error while deserializing the preview data message received from TMS. Ignoring : {}\",\n+                 message, t);\n+        return;\n+      }\n+      previewStore.put(applicationId, payload.getTracerName(), payload.getPropertyName(), payload.getPropertyValue());\n+    }\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for writing preview status to store.\n+   */\n+  private final class PreviewStatusWriter implements PreviewMessageProcessor {\n+    PreviewStatusWriter() {}\n+\n+    @Override\n+    public void processMessage(PreviewMessage message) {\n+      if (!(message.getEntityId() instanceof ApplicationId)) {\n+        LOG.warn(\"Missing application id from the preview status information. Ignoring the message {}\", message);\n+        return;\n+      }\n+\n+      ApplicationId applicationId = (ApplicationId) message.getEntityId();\n+      PreviewStatus payload;\n+      try {\n+        payload = message.getPayload(GSON, PreviewStatus.class);\n+      } catch (Throwable t) {\n+        LOG.warn(\"Error while deserializing the preview status message received from TMS. Ignoring : {}\",\n+                 message, t);\n+        return;\n+      }\n+      PreviewStatus existing = previewStore.getPreviewStatus(applicationId);\n+      if (existing != null && existing.getStatus().isEndState()) {\n+        LOG.warn(\"Preview status for application {} is already in end state {}. Ignoring the update with state {}.\",\n+                 applicationId, existing.getStatus(), payload.getStatus());\n+        return;\n+      }\n+      previewStore.setPreviewStatus(applicationId, payload);\n+    }\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for writing preview run id to store.\n+   */\n+  private final class PreviewProgramRunIdWriter implements PreviewMessageProcessor {\n+    PreviewProgramRunIdWriter() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyODc2NQ==", "bodyText": "done.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461728765", "createdAt": "2020-07-28T16:52:18Z", "author": {"login": "sagarkapare"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/preview/PreviewDataSubscriberService.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.preview;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Named;\n+import io.cdap.cdap.api.messaging.Message;\n+import io.cdap.cdap.api.messaging.MessagingContext;\n+import io.cdap.cdap.api.metrics.MetricsCollectionService;\n+import io.cdap.cdap.app.preview.DefaultPreviewRunnerModule;\n+import io.cdap.cdap.app.preview.PreviewConfigModule;\n+import io.cdap.cdap.app.preview.PreviewMessage;\n+import io.cdap.cdap.app.preview.PreviewStatus;\n+import io.cdap.cdap.app.store.preview.PreviewStore;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.conf.Constants;\n+import io.cdap.cdap.common.service.RetryStrategies;\n+import io.cdap.cdap.common.utils.ImmutablePair;\n+import io.cdap.cdap.internal.app.store.AppMetadataStore;\n+import io.cdap.cdap.messaging.MessagingService;\n+import io.cdap.cdap.messaging.context.MultiThreadMessagingContext;\n+import io.cdap.cdap.messaging.subscriber.AbstractMessagingSubscriberService;\n+import io.cdap.cdap.proto.codec.EntityIdTypeAdapter;\n+import io.cdap.cdap.proto.id.ApplicationId;\n+import io.cdap.cdap.proto.id.EntityId;\n+import io.cdap.cdap.proto.id.NamespaceId;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.spi.data.StructuredTableContext;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.tephra.TxConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Service responsible for consuming preview messages from TMS and persist it to preview store.\n+ */\n+public class PreviewDataSubscriberService extends AbstractMessagingSubscriberService<PreviewMessage> {\n+  private static final Logger LOG = LoggerFactory.getLogger(PreviewDataSubscriberService.class);\n+  private static final Gson GSON = new GsonBuilder()\n+    .registerTypeAdapter(EntityId.class, new EntityIdTypeAdapter())\n+    .create();\n+\n+  private final PreviewStore previewStore;\n+  private final MultiThreadMessagingContext messagingContext;\n+  private final TransactionRunner transactionRunner;\n+  private final int maxRetriesOnError;\n+  private int errorCount = 0;\n+  private String erroredMessageId = null;\n+\n+  /**\n+   * Constructor.\n+   */\n+  @Inject\n+  PreviewDataSubscriberService(CConfiguration cConf,\n+                               @Named(PreviewConfigModule.GLOBAL_TMS) MessagingService messagingService,\n+                               MetricsCollectionService metricsCollectionService, PreviewStore previewStore,\n+                               TransactionRunner transactionRunner) {\n+    super(\n+      NamespaceId.SYSTEM.topic(cConf.get(Constants.Preview.MESSAGING_TOPIC)),\n+      cConf.getInt(Constants.Metadata.MESSAGING_FETCH_SIZE),\n+      cConf.getInt(TxConstants.Manager.CFG_TX_TIMEOUT),\n+      cConf.getLong(Constants.Metadata.MESSAGING_POLL_DELAY_MILLIS),\n+      // TODO: using same configs as metadata\n+      RetryStrategies.fromConfiguration(cConf, \"system.metadata.\"),\n+      metricsCollectionService.getContext(ImmutableMap.of(\n+        Constants.Metrics.Tag.COMPONENT, Constants.Service.MASTER_SERVICES,\n+        Constants.Metrics.Tag.INSTANCE_ID, \"0\",\n+        Constants.Metrics.Tag.NAMESPACE, NamespaceId.SYSTEM.getNamespace(),\n+        Constants.Metrics.Tag.TOPIC, cConf.get(Constants.Preview.MESSAGING_TOPIC),\n+        Constants.Metrics.Tag.CONSUMER, \"preview.writer\"\n+      )));\n+\n+    this.messagingContext = new MultiThreadMessagingContext(messagingService);\n+    this.previewStore = previewStore;\n+    this.transactionRunner = transactionRunner;\n+    this.maxRetriesOnError = cConf.getInt(Constants.Metadata.MESSAGING_RETRIES_ON_CONFLICT);\n+  }\n+\n+  @Override\n+  protected TransactionRunner getTransactionRunner() {\n+    return transactionRunner;\n+  }\n+\n+  @Nullable\n+  @Override\n+  protected String loadMessageId(StructuredTableContext context) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    return appMetadataStore.retrieveSubscriberState(getTopicId().getTopic(), \"preview.writer\");\n+  }\n+\n+  @Override\n+  protected void storeMessageId(StructuredTableContext context, String messageId) throws Exception {\n+    AppMetadataStore appMetadataStore = AppMetadataStore.create(context);\n+    appMetadataStore.persistSubscriberState(getTopicId().getTopic(), \"preview.writer\", messageId);\n+  }\n+\n+  @Override\n+  protected void processMessages(StructuredTableContext structuredTableContext,\n+                                 Iterator<ImmutablePair<String, PreviewMessage>> messages) throws Exception {\n+    Map<PreviewMessage.Type, PreviewMessageProcessor> processors = new HashMap<>();\n+\n+    // Loop over all fetched messages and process them with corresponding PreviewMessageProcessor\n+    while (messages.hasNext()) {\n+      ImmutablePair<String, PreviewMessage> next = messages.next();\n+      String messageId = next.getFirst();\n+      PreviewMessage message = next.getSecond();\n+\n+      PreviewMessageProcessor processor = processors.computeIfAbsent(message.getType(), type -> {\n+        switch (type) {\n+          case DATA:\n+            return new PreviewDataProcessor();\n+          case STATUS:\n+            return new PreviewStatusWriter();\n+          case PROGRAM_RUN_ID:\n+            return new PreviewProgramRunIdWriter();\n+          default:\n+            return null;\n+        }\n+      });\n+\n+      // noinspection ConstantConditions\n+      if (processor == null) {\n+        LOG.warn(\"Unsupported preview message type {}. Message ignored.\", message.getType());\n+        continue;\n+      }\n+      try {\n+        processor.processMessage(message);\n+        errorCount = 0;\n+      } catch (Exception e) {\n+        if (messageId.equals(erroredMessageId)) {\n+          errorCount++;\n+          if (errorCount >= maxRetriesOnError) {\n+            LOG.warn(\"Skipping preview message {} after processing it has caused {} consecutive errors: {}\",\n+                     message, errorCount, e.getMessage());\n+            continue;\n+          }\n+        } else {\n+          erroredMessageId = messageId;\n+          errorCount = 1;\n+        }\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  protected MessagingContext getMessagingContext() {\n+    return messagingContext;\n+  }\n+\n+  @Override\n+  protected PreviewMessage decodeMessage(Message message) {\n+    return GSON.fromJson(message.getPayloadAsString(), PreviewMessage.class);\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for processing preview data.\n+   */\n+  private final class PreviewDataProcessor implements PreviewMessageProcessor {\n+    PreviewDataProcessor() {}\n+\n+    @Override\n+    public void processMessage(PreviewMessage message) {\n+      if (!(message.getEntityId() instanceof ApplicationId)) {\n+        LOG.warn(\"Missing application id from the preview data information. Ignoring the message {}\", message);\n+        return;\n+      }\n+\n+      ApplicationId applicationId = (ApplicationId) message.getEntityId();\n+      PreviewDataPayload payload;\n+      try {\n+        payload = message.getPayload(GSON, PreviewDataPayload.class);\n+      } catch (Throwable t) {\n+        LOG.warn(\"Error while deserializing the preview data message received from TMS. Ignoring : {}\",\n+                 message, t);\n+        return;\n+      }\n+      previewStore.put(applicationId, payload.getTracerName(), payload.getPropertyName(), payload.getPropertyValue());\n+    }\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for writing preview status to store.\n+   */\n+  private final class PreviewStatusWriter implements PreviewMessageProcessor {\n+    PreviewStatusWriter() {}\n+\n+    @Override\n+    public void processMessage(PreviewMessage message) {\n+      if (!(message.getEntityId() instanceof ApplicationId)) {\n+        LOG.warn(\"Missing application id from the preview status information. Ignoring the message {}\", message);\n+        return;\n+      }\n+\n+      ApplicationId applicationId = (ApplicationId) message.getEntityId();\n+      PreviewStatus payload;\n+      try {\n+        payload = message.getPayload(GSON, PreviewStatus.class);\n+      } catch (Throwable t) {\n+        LOG.warn(\"Error while deserializing the preview status message received from TMS. Ignoring : {}\",\n+                 message, t);\n+        return;\n+      }\n+      PreviewStatus existing = previewStore.getPreviewStatus(applicationId);\n+      if (existing != null && existing.getStatus().isEndState()) {\n+        LOG.warn(\"Preview status for application {} is already in end state {}. Ignoring the update with state {}.\",\n+                 applicationId, existing.getStatus(), payload.getStatus());\n+        return;\n+      }\n+      previewStore.setPreviewStatus(applicationId, payload);\n+    }\n+  }\n+\n+  /**\n+   * The {@link PreviewMessageProcessor} for writing preview run id to store.\n+   */\n+  private final class PreviewProgramRunIdWriter implements PreviewMessageProcessor {\n+    PreviewProgramRunIdWriter() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyMjk3Mw=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDYyMDE5OnYy", "diffSide": "RIGHT", "path": "cdap-watchdog/src/main/java/io/cdap/cdap/logging/framework/CustomLogPipelineConfigProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1NToxNFrOG4DJGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo1MjoyN1rOG4VsWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNDkyMA==", "bodyText": "Why needed? You can unset the PIPELINE_CONFIG_DIR config and have the LogPipelineLoader to check if that config exist before using it.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461424920", "createdAt": "2020-07-28T08:55:14Z", "author": {"login": "chtyim"}, "path": "cdap-watchdog/src/main/java/io/cdap/cdap/logging/framework/CustomLogPipelineConfigProvider.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.logging.framework;\n+\n+import java.io.File;\n+import java.util.List;\n+\n+/**\n+ * Interface to provide custom log pipeline configurations.\n+ */\n+public interface CustomLogPipelineConfigProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyODg1Nw==", "bodyText": "fixed.", "url": "https://github.com/cdapio/cdap/pull/12401#discussion_r461728857", "createdAt": "2020-07-28T16:52:27Z", "author": {"login": "sagarkapare"}, "path": "cdap-watchdog/src/main/java/io/cdap/cdap/logging/framework/CustomLogPipelineConfigProvider.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.logging.framework;\n+\n+import java.io.File;\n+import java.util.List;\n+\n+/**\n+ * Interface to provide custom log pipeline configurations.\n+ */\n+public interface CustomLogPipelineConfigProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNDkyMA=="}, "originalCommit": {"oid": "c3cf5d3b7b2b49cef05e90ab8f0a38b0df4c208d"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3310, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}