{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0OTMyMTg1", "number": 12865, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDozNDoxOFrOE7s-4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDo0MzozNlrOE7tI9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDM4NDMzOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDozNDoxOFrOH3f37A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDo0OTozMFrOH3gRzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1NTk0OA==", "bodyText": "Typo here", "url": "https://github.com/cdapio/cdap/pull/12865#discussion_r527955948", "createdAt": "2020-11-20T20:34:18Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -812,7 +812,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si\n         //   completion.completed();\n         // } catch (Throwable t) {\n         //   completion.completedWithException(t);\n-        //   // Wrap it with RuntimeException to prevent SparkSubmit calling System.exit in local mode\n+        //   // Wrap it with RuntimeException to preven SparkSubmit calling System.exit in local mode", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea86c28865b6a6ccfb3579225b30b13903646c1f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2MjU3Mg==", "bodyText": "fixup", "url": "https://github.com/cdapio/cdap/pull/12865#discussion_r527962572", "createdAt": "2020-11-20T20:49:30Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -812,7 +812,7 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si\n         //   completion.completed();\n         // } catch (Throwable t) {\n         //   completion.completedWithException(t);\n-        //   // Wrap it with RuntimeException to prevent SparkSubmit calling System.exit in local mode\n+        //   // Wrap it with RuntimeException to preven SparkSubmit calling System.exit in local mode", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1NTk0OA=="}, "originalCommit": {"oid": "ea86c28865b6a6ccfb3579225b30b13903646c1f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDQwNTgxOnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/provision/ProvisioningService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDo0MjowNlrOH3gFCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMTowOToxN1rOH3gyRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTMwNg==", "bodyText": "Is it safe to have an unbounded queue? Any chance we can run into OOM with it?", "url": "https://github.com/cdapio/cdap/pull/12865#discussion_r527959306", "createdAt": "2020-11-20T20:42:06Z", "author": {"login": "tivv"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/provision/ProvisioningService.java", "diffHunk": "@@ -154,10 +158,19 @@\n   @Override\n   protected void startUp() throws Exception {\n     LOG.info(\"Starting {}\", getClass().getSimpleName());\n+\n+    this.taskExecutor = new KeyedExecutor<>(\n+      Executors.newScheduledThreadPool(cConf.getInt(Constants.Provisioner.EXECUTOR_THREADS),\n+                                       Threads.createDaemonThreadFactory(\"provisioning-task-%d\")));\n+\n+    int maxPoolSize = cConf.getInt(Constants.Provisioner.CONTEXT_EXECUTOR_THREADS);\n+    ThreadPoolExecutor contextExecutor = new ThreadPoolExecutor(\n+      maxPoolSize, maxPoolSize, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea86c28865b6a6ccfb3579225b30b13903646c1f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MDg4NQ==", "bodyText": "We typically use unbounded queue for executor with a thread pool (same as the default in Java Executors). If this queue even gets OOM, we are in bigger problem than the OOM itself.", "url": "https://github.com/cdapio/cdap/pull/12865#discussion_r527970885", "createdAt": "2020-11-20T21:09:17Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/provision/ProvisioningService.java", "diffHunk": "@@ -154,10 +158,19 @@\n   @Override\n   protected void startUp() throws Exception {\n     LOG.info(\"Starting {}\", getClass().getSimpleName());\n+\n+    this.taskExecutor = new KeyedExecutor<>(\n+      Executors.newScheduledThreadPool(cConf.getInt(Constants.Provisioner.EXECUTOR_THREADS),\n+                                       Threads.createDaemonThreadFactory(\"provisioning-task-%d\")));\n+\n+    int maxPoolSize = cConf.getInt(Constants.Provisioner.CONTEXT_EXECUTOR_THREADS);\n+    ThreadPoolExecutor contextExecutor = new ThreadPoolExecutor(\n+      maxPoolSize, maxPoolSize, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTMwNg=="}, "originalCommit": {"oid": "ea86c28865b6a6ccfb3579225b30b13903646c1f"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDQxMDE1OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/provision/DefaultProvisionerContext.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDo0MzozNlrOH3gHjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMTozNzo1OVrOH3hnmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTk0OQ==", "bodyText": "Do we want to catch Throwable? What is our strategy on handling something like StackOverflowError here?", "url": "https://github.com/cdapio/cdap/pull/12865#discussion_r527959949", "createdAt": "2020-11-20T20:43:36Z", "author": {"login": "tivv"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/provision/DefaultProvisionerContext.java", "diffHunk": "@@ -125,4 +132,18 @@ public ProvisionerMetrics getMetrics(Map<String, String> context) {\n     tags.put(Constants.Metrics.Tag.PROVISIONER, provisionerName);\n     return new DefaultProvisionerMetrics(metricsCollectionService.getContext(tags));\n   }\n+\n+  @Override\n+  public <T> CompletionStage<T> execute(Callable<T> callable) {\n+    CompletableFuture<T> result = new CompletableFuture<>();\n+\n+    executor.execute(() -> {\n+      try {\n+        result.complete(callable.call());\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea86c28865b6a6ccfb3579225b30b13903646c1f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2Mzg4Mg==", "bodyText": "We can also use standard wrapping approach with something like this:\nCompletableFuture.supplyAsync(executor,  () -> {\n try {\n  result.complete(callable.call());\n } catch (Exception e) {\n  throw new CompletionException(e);\n }\n});\n\nIt would produce same result, but we would rely on JDK to ensure any exit from function will complete the future without explicit Throwable catching.", "url": "https://github.com/cdapio/cdap/pull/12865#discussion_r527963882", "createdAt": "2020-11-20T20:52:30Z", "author": {"login": "tivv"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/provision/DefaultProvisionerContext.java", "diffHunk": "@@ -125,4 +132,18 @@ public ProvisionerMetrics getMetrics(Map<String, String> context) {\n     tags.put(Constants.Metrics.Tag.PROVISIONER, provisionerName);\n     return new DefaultProvisionerMetrics(metricsCollectionService.getContext(tags));\n   }\n+\n+  @Override\n+  public <T> CompletionStage<T> execute(Callable<T> callable) {\n+    CompletableFuture<T> result = new CompletableFuture<>();\n+\n+    executor.execute(() -> {\n+      try {\n+        result.complete(callable.call());\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTk0OQ=="}, "originalCommit": {"oid": "ea86c28865b6a6ccfb3579225b30b13903646c1f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MjQ0NA==", "bodyText": "Change to catch Throwable is simpler. The supplyAsync doesn't really buy us anything in this case.", "url": "https://github.com/cdapio/cdap/pull/12865#discussion_r527972444", "createdAt": "2020-11-20T21:13:04Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/provision/DefaultProvisionerContext.java", "diffHunk": "@@ -125,4 +132,18 @@ public ProvisionerMetrics getMetrics(Map<String, String> context) {\n     tags.put(Constants.Metrics.Tag.PROVISIONER, provisionerName);\n     return new DefaultProvisionerMetrics(metricsCollectionService.getContext(tags));\n   }\n+\n+  @Override\n+  public <T> CompletionStage<T> execute(Callable<T> callable) {\n+    CompletableFuture<T> result = new CompletableFuture<>();\n+\n+    executor.execute(() -> {\n+      try {\n+        result.complete(callable.call());\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTk0OQ=="}, "originalCommit": {"oid": "ea86c28865b6a6ccfb3579225b30b13903646c1f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MjcyNA==", "bodyText": "Generally speak, catching Throwable is not desirable. But in this case is necessary to complete the future returned.", "url": "https://github.com/cdapio/cdap/pull/12865#discussion_r527972724", "createdAt": "2020-11-20T21:13:51Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/provision/DefaultProvisionerContext.java", "diffHunk": "@@ -125,4 +132,18 @@ public ProvisionerMetrics getMetrics(Map<String, String> context) {\n     tags.put(Constants.Metrics.Tag.PROVISIONER, provisionerName);\n     return new DefaultProvisionerMetrics(metricsCollectionService.getContext(tags));\n   }\n+\n+  @Override\n+  public <T> CompletionStage<T> execute(Callable<T> callable) {\n+    CompletableFuture<T> result = new CompletableFuture<>();\n+\n+    executor.execute(() -> {\n+      try {\n+        result.complete(callable.call());\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTk0OQ=="}, "originalCommit": {"oid": "ea86c28865b6a6ccfb3579225b30b13903646c1f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk4NDUzOA==", "bodyText": "Yep, that's the main reason I proposed supplyAsync. I don't like to catch Throwable either.", "url": "https://github.com/cdapio/cdap/pull/12865#discussion_r527984538", "createdAt": "2020-11-20T21:37:59Z", "author": {"login": "tivv"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/provision/DefaultProvisionerContext.java", "diffHunk": "@@ -125,4 +132,18 @@ public ProvisionerMetrics getMetrics(Map<String, String> context) {\n     tags.put(Constants.Metrics.Tag.PROVISIONER, provisionerName);\n     return new DefaultProvisionerMetrics(metricsCollectionService.getContext(tags));\n   }\n+\n+  @Override\n+  public <T> CompletionStage<T> execute(Callable<T> callable) {\n+    CompletableFuture<T> result = new CompletableFuture<>();\n+\n+    executor.execute(() -> {\n+      try {\n+        result.complete(callable.call());\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1OTk0OQ=="}, "originalCommit": {"oid": "ea86c28865b6a6ccfb3579225b30b13903646c1f"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2605, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}