{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTk3Njgz", "number": 11925, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMzo0ODoxOFrODl-Wzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMToyNToxMFrODmd-Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTQ1NTUxOnYy", "diffSide": "RIGHT", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMzo0ODoxOFrOFzKrBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMzo0ODoxOFrOFzKrBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5NjU0OA==", "bodyText": "extra space after =", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389196548", "createdAt": "2020-03-06T23:48:18Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -86,15 +87,17 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n \n   private Map<String, Operation> computeProcessedOperations() {\n     Map<String, Operation> processedOperations = new HashMap<>();\n+    // this stores information about all the outputs on a merge stage, the key is the prefix of the merge\n+    Map<String, List<String>> mergedOutputs = new HashMap<>();\n     for (String stageName : topologicalOrder) {\n       Set<String> stageInputs = stageDag.getNodeInputs(stageName);\n       if (stageInputs.size() > 1 && !noMergeRequiredStages.contains(stageName)) {\n-        addMergeOperation(stageInputs, processedOperations);\n+        addMergeOperation(stageInputs, processedOperations, mergedOutputs);\n       }\n       List<FieldOperation> fieldOperations = stageOperations.get(stageName);\n       for (FieldOperation fieldOperation : fieldOperations) {\n         Operation newOperation = null;\n-        String newOperationName =  prefixedOperationName(stageName, fieldOperation.getName());\n+        String newOperationName =  prefixedName(stageName, fieldOperation.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58454c2a30286f45e5df85cb0a5746005a7f8219"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTQ2NTYyOnYy", "diffSide": "RIGHT", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMzo1NTo1MFrOFzKxQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOToyMjoxMlrOFzfqFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5ODE0NQ==", "bodyText": "I don't understand what this represents. What is a merge stage? What is a prefix of a merge?", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389198145", "createdAt": "2020-03-06T23:55:50Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -86,15 +87,17 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n \n   private Map<String, Operation> computeProcessedOperations() {\n     Map<String, Operation> processedOperations = new HashMap<>();\n+    // this stores information about all the outputs on a merge stage, the key is the prefix of the merge\n+    Map<String, List<String>> mergedOutputs = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58454c2a30286f45e5df85cb0a5746005a7f8219"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU0MDM3Mw==", "bodyText": "Removed this to reduce complication", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389540373", "createdAt": "2020-03-09T09:22:12Z", "author": {"login": "yaojiefeng"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -86,15 +87,17 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n \n   private Map<String, Operation> computeProcessedOperations() {\n     Map<String, Operation> processedOperations = new HashMap<>();\n+    // this stores information about all the outputs on a merge stage, the key is the prefix of the merge\n+    Map<String, List<String>> mergedOutputs = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5ODE0NQ=="}, "originalCommit": {"oid": "58454c2a30286f45e5df85cb0a5746005a7f8219"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjU2MzQwOnYy", "diffSide": "RIGHT", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMTowMDo1MVrOFz5NeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMToyOToyOFrOFz6CDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1OTAzMg==", "bodyText": "we should get rid of them. Multiple inputs going into a non-joiner is a no-op since nothing changes in the data. It should not generate a new operation.", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389959032", "createdAt": "2020-03-09T21:00:51Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -47,8 +48,16 @@\n  * converting it into the form the platform expects. This includes prefixing operation names\n  * to make sure they are unique across all the plugins, adding implicit merge operations when\n  * stage has more than one input etc.\n+ * The platform operation requires each operation to specify the previous operation name and the operation name has\n+ * to be unique. Therefore this class will prefix each operation name with the stage name, i.e,\n+ * {stage-name}.{original-name}. When a stage has multiple input stages except Joiner, implicit merge operations are\n+ * generated in order for future stages to look up the previous operations.\n+ *\n+ * TODO: CDAP-16395 revisit this class to see if we can get rid of the merge operations since user will be confused\n+ * about it. If we cannot, should just make this class more understandable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3MjQ5Mw==", "bodyText": "Yea, we should remove it, but in 6.2 it is too risky. It is better we do it early in next release.", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389972493", "createdAt": "2020-03-09T21:29:28Z", "author": {"login": "yaojiefeng"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -47,8 +48,16 @@\n  * converting it into the form the platform expects. This includes prefixing operation names\n  * to make sure they are unique across all the plugins, adding implicit merge operations when\n  * stage has more than one input etc.\n+ * The platform operation requires each operation to specify the previous operation name and the operation name has\n+ * to be unique. Therefore this class will prefix each operation name with the stage name, i.e,\n+ * {stage-name}.{original-name}. When a stage has multiple input stages except Joiner, implicit merge operations are\n+ * generated in order for future stages to look up the previous operations.\n+ *\n+ * TODO: CDAP-16395 revisit this class to see if we can get rid of the merge operations since user will be confused\n+ * about it. If we cannot, should just make this class more understandable.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1OTAzMg=="}, "originalCommit": {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjU2NDkxOnYy", "diffSide": "RIGHT", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMTowMToyMFrOFz5OeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMTowMToyMFrOFz5OeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1OTI4OQ==", "bodyText": "transform3 -> t3 (to match the diagram)", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389959289", "createdAt": "2020-03-09T21:01:20Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjU3NjkyOnYy", "diffSide": "RIGHT", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMTowNToyNlrOFz5V5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMTozNzoyMlrOFz6Pog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2MTE5MQ==", "bodyText": "with this example, stageInputs = <t1, t2> and processedOperations contains operations for src1, src2, t1, and t2?", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389961191", "createdAt": "2020-03-09T21:05:26Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3NTk3MA==", "bodyText": "Yes, updated the javadoc", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389975970", "createdAt": "2020-03-09T21:37:22Z", "author": {"login": "yaojiefeng"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2MTE5MQ=="}, "originalCommit": {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjYzMTY0OnYy", "diffSide": "RIGHT", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMToyMzo0MlrOFz531A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMTo0Mzo0MlrOFz6ahQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2OTg3Ng==", "bodyText": "can you add some comments describing what the key and values are. An example would help as well.", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389969876", "createdAt": "2020-03-09T21:23:42Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c\n+   *\n+   * @param stageInputs the stage inputs, the size of this set be greater than 1\n+   * @param processedOperations the processed operations that collect all the result\n+   */\n+  private void addMergeOperation(Set<String> stageInputs, Map<String, Operation> processedOperations) {\n     Set<String> sortedInputs = new TreeSet<>(stageInputs);\n-    String mergeOperationName = prefixedOperationName(Joiner.on(SEPARATOR).join(sortedInputs), \"merge\");\n+    String mergeOperationNamePrefix = getMergeOperationNamePrefix(sortedInputs);\n     String mergeDescription = \"Merged stages: \" + Joiner.on(\",\").join(sortedInputs);\n-    if (processedOperations.containsKey(mergeOperationName)) {\n-      // it is possible that same stages act as an input to multiple stages.\n-      // we should still only add single merge operation for them\n-      return;\n-    }\n-    List<InputField> inputFields = new ArrayList<>();\n+\n+    Map<String, List<InputField>> fieldNameMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3ODc1Nw==", "bodyText": "Added comments", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389978757", "createdAt": "2020-03-09T21:43:42Z", "author": {"login": "yaojiefeng"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c\n+   *\n+   * @param stageInputs the stage inputs, the size of this set be greater than 1\n+   * @param processedOperations the processed operations that collect all the result\n+   */\n+  private void addMergeOperation(Set<String> stageInputs, Map<String, Operation> processedOperations) {\n     Set<String> sortedInputs = new TreeSet<>(stageInputs);\n-    String mergeOperationName = prefixedOperationName(Joiner.on(SEPARATOR).join(sortedInputs), \"merge\");\n+    String mergeOperationNamePrefix = getMergeOperationNamePrefix(sortedInputs);\n     String mergeDescription = \"Merged stages: \" + Joiner.on(\",\").join(sortedInputs);\n-    if (processedOperations.containsKey(mergeOperationName)) {\n-      // it is possible that same stages act as an input to multiple stages.\n-      // we should still only add single merge operation for them\n-      return;\n-    }\n-    List<InputField> inputFields = new ArrayList<>();\n+\n+    Map<String, List<InputField>> fieldNameMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2OTg3Ng=="}, "originalCommit": {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjYzNDkwOnYy", "diffSide": "RIGHT", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMToyNDo0OFrOFz55yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMTozNjoyMlrOFz6N6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3MDM3Ng==", "bodyText": "this makes it look like it's still a many to many operation. Would be better to change the Map<String, List<InputField>> into a Map<String, Set>` so that it is clear there is only ever one output, which is the fieldName.", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389970376", "createdAt": "2020-03-09T21:24:48Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c\n+   *\n+   * @param stageInputs the stage inputs, the size of this set be greater than 1\n+   * @param processedOperations the processed operations that collect all the result\n+   */\n+  private void addMergeOperation(Set<String> stageInputs, Map<String, Operation> processedOperations) {\n     Set<String> sortedInputs = new TreeSet<>(stageInputs);\n-    String mergeOperationName = prefixedOperationName(Joiner.on(SEPARATOR).join(sortedInputs), \"merge\");\n+    String mergeOperationNamePrefix = getMergeOperationNamePrefix(sortedInputs);\n     String mergeDescription = \"Merged stages: \" + Joiner.on(\",\").join(sortedInputs);\n-    if (processedOperations.containsKey(mergeOperationName)) {\n-      // it is possible that same stages act as an input to multiple stages.\n-      // we should still only add single merge operation for them\n-      return;\n-    }\n-    List<InputField> inputFields = new ArrayList<>();\n+\n+    Map<String, List<InputField>> fieldNameMap = new LinkedHashMap<>();\n+    // create the map that contains the field name of the current stages and the parent stages to the origins\n     for (String inputStage : sortedInputs) {\n       List<String> parentStages = findParentStages(inputStage);\n+      // traverse in a reverse order of parent stages since the parent stages will contain the closest parent\n+      // at the end of the list\n+      Collections.reverse(parentStages);\n+      // this stores the visited field, if we already know the field from the previous parent, do not\n+      // add other origin of this field\n+      Set<String> visitedField = new HashSet<>();\n       for (String parentStage : parentStages) {\n+        // get the map of all the outputs to the origin map from a stage\n         Map<String, String> fieldOrigins = stageOutputsWithOrigins.get(parentStage);\n         for (Map.Entry<String, String> fieldOrigin : fieldOrigins.entrySet()) {\n-          inputFields.add(InputField.of(fieldOrigin.getValue(), fieldOrigin.getKey()));\n+          String fieldName = fieldOrigin.getKey();\n+          if (visitedField.contains(fieldName)) {\n+            continue;\n+          }\n+          List<InputField> inputFields = fieldNameMap.computeIfAbsent(fieldName, k -> new ArrayList<>());\n+          inputFields.add(InputField.of(fieldOrigin.getValue(), fieldName));\n+          visitedField.add(fieldName);\n         }\n       }\n     }\n \n-    Set<String> outputs = new LinkedHashSet<>();\n-    for (InputField inputField : inputFields) {\n-      outputs.add(inputField.getName());\n-    }\n-    TransformOperation merge = new TransformOperation(mergeOperationName, mergeDescription, inputFields,\n-                                                      new ArrayList<>(outputs));\n-    processedOperations.put(merge.getName(), merge);\n+    fieldNameMap.forEach((fieldName, inputFields) -> {\n+      String mergeName = prefixedName(mergeOperationNamePrefix, fieldName);\n+      if (processedOperations.containsKey(mergeName)) {\n+        // it is possible that same stages act as an input to multiple stages.\n+        // we should still only add single merge operation for them\n+        return;\n+      }\n+\n+      Set<String> outputs = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3NTUzMA==", "bodyText": "Changed this to a  Map<String, List<String>> , where the value is list of origins of the field, a list better matches the API since the transform operation expects a list instead of a set", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389975530", "createdAt": "2020-03-09T21:36:22Z", "author": {"login": "yaojiefeng"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c\n+   *\n+   * @param stageInputs the stage inputs, the size of this set be greater than 1\n+   * @param processedOperations the processed operations that collect all the result\n+   */\n+  private void addMergeOperation(Set<String> stageInputs, Map<String, Operation> processedOperations) {\n     Set<String> sortedInputs = new TreeSet<>(stageInputs);\n-    String mergeOperationName = prefixedOperationName(Joiner.on(SEPARATOR).join(sortedInputs), \"merge\");\n+    String mergeOperationNamePrefix = getMergeOperationNamePrefix(sortedInputs);\n     String mergeDescription = \"Merged stages: \" + Joiner.on(\",\").join(sortedInputs);\n-    if (processedOperations.containsKey(mergeOperationName)) {\n-      // it is possible that same stages act as an input to multiple stages.\n-      // we should still only add single merge operation for them\n-      return;\n-    }\n-    List<InputField> inputFields = new ArrayList<>();\n+\n+    Map<String, List<InputField>> fieldNameMap = new LinkedHashMap<>();\n+    // create the map that contains the field name of the current stages and the parent stages to the origins\n     for (String inputStage : sortedInputs) {\n       List<String> parentStages = findParentStages(inputStage);\n+      // traverse in a reverse order of parent stages since the parent stages will contain the closest parent\n+      // at the end of the list\n+      Collections.reverse(parentStages);\n+      // this stores the visited field, if we already know the field from the previous parent, do not\n+      // add other origin of this field\n+      Set<String> visitedField = new HashSet<>();\n       for (String parentStage : parentStages) {\n+        // get the map of all the outputs to the origin map from a stage\n         Map<String, String> fieldOrigins = stageOutputsWithOrigins.get(parentStage);\n         for (Map.Entry<String, String> fieldOrigin : fieldOrigins.entrySet()) {\n-          inputFields.add(InputField.of(fieldOrigin.getValue(), fieldOrigin.getKey()));\n+          String fieldName = fieldOrigin.getKey();\n+          if (visitedField.contains(fieldName)) {\n+            continue;\n+          }\n+          List<InputField> inputFields = fieldNameMap.computeIfAbsent(fieldName, k -> new ArrayList<>());\n+          inputFields.add(InputField.of(fieldOrigin.getValue(), fieldName));\n+          visitedField.add(fieldName);\n         }\n       }\n     }\n \n-    Set<String> outputs = new LinkedHashSet<>();\n-    for (InputField inputField : inputFields) {\n-      outputs.add(inputField.getName());\n-    }\n-    TransformOperation merge = new TransformOperation(mergeOperationName, mergeDescription, inputFields,\n-                                                      new ArrayList<>(outputs));\n-    processedOperations.put(merge.getName(), merge);\n+    fieldNameMap.forEach((fieldName, inputFields) -> {\n+      String mergeName = prefixedName(mergeOperationNamePrefix, fieldName);\n+      if (processedOperations.containsKey(mergeName)) {\n+        // it is possible that same stages act as an input to multiple stages.\n+        // we should still only add single merge operation for them\n+        return;\n+      }\n+\n+      Set<String> outputs = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3MDM3Ng=="}, "originalCommit": {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjYzNTkwOnYy", "diffSide": "RIGHT", "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMToyNToxMFrOFz56aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMToyNToxMFrOFz56aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3MDUzNg==", "bodyText": "I think it's more understandable for this to be Collections.singletonList(fieldName)", "url": "https://github.com/cdapio/cdap/pull/11925#discussion_r389970536", "createdAt": "2020-03-09T21:25:10Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-etl-core/src/main/java/io/cdap/cdap/etl/lineage/LineageOperationsProcessor.java", "diffHunk": "@@ -129,34 +150,70 @@ public LineageOperationsProcessor(Set<Connection> stageConnections,\n     return processedOperations;\n   }\n \n-  private void addMergeOperation(Set<String> stageInputs,\n-                                 Map<String, Operation> processedOperations) {\n+  /**\n+   * Create the implicit merge operations. Each merge operation will have a prefix with\n+   * {stage1-name},(stage2-name),{other-stage-name}.merge, appended with the field name.\n+   * Each merge operation can be seen as an identity transform for all the fields appeared in the outputs in the\n+   * parent stages.\n+   * For example, if a pipeline looks like this:\n+   * src1 -> t1(a,b,c) --|\n+   *                     |-> t3(not joiner) -> sink\n+   * src2 -> t2(a,b,c) --|\n+   * At stage transform3, 3 merge operations are generated for each field a,b,c:\n+   * 1. name: t1,t2.merge.a, input fields: t1.a, t2.a, output fields: a\n+   * 2. name: t1,t2.merge.b, input fields: t1.b, t2.b, output fields: b\n+   * 3. name: t1,t2.merge.c, input fields: t1.c, t2.c, output fields: c\n+   *\n+   * @param stageInputs the stage inputs, the size of this set be greater than 1\n+   * @param processedOperations the processed operations that collect all the result\n+   */\n+  private void addMergeOperation(Set<String> stageInputs, Map<String, Operation> processedOperations) {\n     Set<String> sortedInputs = new TreeSet<>(stageInputs);\n-    String mergeOperationName = prefixedOperationName(Joiner.on(SEPARATOR).join(sortedInputs), \"merge\");\n+    String mergeOperationNamePrefix = getMergeOperationNamePrefix(sortedInputs);\n     String mergeDescription = \"Merged stages: \" + Joiner.on(\",\").join(sortedInputs);\n-    if (processedOperations.containsKey(mergeOperationName)) {\n-      // it is possible that same stages act as an input to multiple stages.\n-      // we should still only add single merge operation for them\n-      return;\n-    }\n-    List<InputField> inputFields = new ArrayList<>();\n+\n+    Map<String, List<InputField>> fieldNameMap = new LinkedHashMap<>();\n+    // create the map that contains the field name of the current stages and the parent stages to the origins\n     for (String inputStage : sortedInputs) {\n       List<String> parentStages = findParentStages(inputStage);\n+      // traverse in a reverse order of parent stages since the parent stages will contain the closest parent\n+      // at the end of the list\n+      Collections.reverse(parentStages);\n+      // this stores the visited field, if we already know the field from the previous parent, do not\n+      // add other origin of this field\n+      Set<String> visitedField = new HashSet<>();\n       for (String parentStage : parentStages) {\n+        // get the map of all the outputs to the origin map from a stage\n         Map<String, String> fieldOrigins = stageOutputsWithOrigins.get(parentStage);\n         for (Map.Entry<String, String> fieldOrigin : fieldOrigins.entrySet()) {\n-          inputFields.add(InputField.of(fieldOrigin.getValue(), fieldOrigin.getKey()));\n+          String fieldName = fieldOrigin.getKey();\n+          if (visitedField.contains(fieldName)) {\n+            continue;\n+          }\n+          List<InputField> inputFields = fieldNameMap.computeIfAbsent(fieldName, k -> new ArrayList<>());\n+          inputFields.add(InputField.of(fieldOrigin.getValue(), fieldName));\n+          visitedField.add(fieldName);\n         }\n       }\n     }\n \n-    Set<String> outputs = new LinkedHashSet<>();\n-    for (InputField inputField : inputFields) {\n-      outputs.add(inputField.getName());\n-    }\n-    TransformOperation merge = new TransformOperation(mergeOperationName, mergeDescription, inputFields,\n-                                                      new ArrayList<>(outputs));\n-    processedOperations.put(merge.getName(), merge);\n+    fieldNameMap.forEach((fieldName, inputFields) -> {\n+      String mergeName = prefixedName(mergeOperationNamePrefix, fieldName);\n+      if (processedOperations.containsKey(mergeName)) {\n+        // it is possible that same stages act as an input to multiple stages.\n+        // we should still only add single merge operation for them\n+        return;\n+      }\n+\n+      Set<String> outputs = new LinkedHashSet<>();\n+      for (InputField inputField : inputFields) {\n+        outputs.add(inputField.getName());\n+      }\n+\n+      TransformOperation merge = new TransformOperation(mergeName, mergeDescription, inputFields,\n+                                                        new ArrayList<>(outputs));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8e29358a07aee38221b6ab3de01fcd72931d5ad"}, "originalPosition": 147}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2999, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}