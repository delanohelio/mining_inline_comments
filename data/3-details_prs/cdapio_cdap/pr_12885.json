{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzMDg5MDg4", "number": 12885, "title": "(CDAP-17355) New Drafts API", "bodyText": "This PR adds support for managing drafts within the data pipeline app.\nMain changes:\n\nCreated various classes to represent drafts and draft-related exceptions\nAdded new draft.count metric that tracks the number of drafts across all namespaces and users\nCreated a new StructuredTable to store drafts\nCreated service class to interact with the drafts store\nCreate a HTTPHandler to expose various endpoints for listing, getting, creating/updating and deleting drafts\nUnit tests to test 100% of all new draft related methods", "createdAt": "2020-12-05T20:39:39Z", "url": "https://github.com/cdapio/cdap/pull/12885", "merged": true, "mergeCommit": {"oid": "1d6cdc2b833659f9f9da72d3f531ef2160b4bcec"}, "closed": true, "closedAt": "2020-12-12T04:09:10Z", "author": {"login": "MEseifan"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdj7KQPgBqjQwODE0MzEyOTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdlN9KIABqjQxMDIyMzE4ODM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "908e206a8af3ae6c23de7e3acf7ccc5f4e9933ce", "author": {"user": {"login": "MEseifan", "name": null}}, "url": "https://github.com/cdapio/cdap/commit/908e206a8af3ae6c23de7e3acf7ccc5f4e9933ce", "committedDate": "2020-12-05T20:55:31Z", "message": "Checkstyle"}, "afterCommit": {"oid": "5b661dafa26c4c029dd61975cfca3784ab60ee45", "author": {"user": {"login": "MEseifan", "name": null}}, "url": "https://github.com/cdapio/cdap/commit/5b661dafa26c4c029dd61975cfca3784ab60ee45", "committedDate": "2020-12-07T19:59:38Z", "message": "Checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDg3NTM5", "url": "https://github.com/cdapio/cdap/pull/12885#pullrequestreview-546487539", "createdAt": "2020-12-07T19:56:43Z", "commit": {"oid": "908e206a8af3ae6c23de7e3acf7ccc5f4e9933ce"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1Nzo1MlrOIA4J3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDoyNjoxOFrOIA5Oiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MDk0Mw==", "bodyText": "Remove extra new line", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537790943", "createdAt": "2020-12-07T19:57:52Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftRequest.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Request to store a draft.\n+ *\n+ * @param <T> Type of config that this DraftRequest contains\n+ */\n+public class DraftRequest<T> {\n+  private final String previousHash; // currently unused but will be used later to detect collision\n+  private final String name;\n+  private final String description;\n+  private final int revision; // currently unused but will be used later to enable draft version tracking\n+  private final ArtifactSummary artifact;\n+  private T config;\n+\n+  public DraftRequest(T config, String previousHash, String name, String description, int revision,\n+                      ArtifactSummary artifact) {\n+    this.config = config;\n+    this.previousHash = previousHash;\n+    this.name = name;\n+    this.description = description;\n+    this.revision = revision;\n+    this.artifact = artifact;\n+  }\n+\n+  public String getDescription() {\n+    return description;\n+  }\n+\n+  public String getName() {\n+    return name == null ? \"\" : name;\n+  }\n+\n+  public int getRevision() {\n+    return revision;\n+  }\n+\n+  public ArtifactSummary getArtifact() {\n+    return artifact;\n+  }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "908e206a8af3ae6c23de7e3acf7ccc5f4e9933ce"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MTEyNg==", "bodyText": "What is this?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537791126", "createdAt": "2020-12-07T19:58:08Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftRequest.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Request to store a draft.\n+ *\n+ * @param <T> Type of config that this DraftRequest contains\n+ */\n+public class DraftRequest<T> {\n+  private final String previousHash; // currently unused but will be used later to detect collision\n+  private final String name;\n+  private final String description;\n+  private final int revision; // currently unused but will be used later to enable draft version tracking\n+  private final ArtifactSummary artifact;\n+  private T config;\n+\n+  public DraftRequest(T config, String previousHash, String name, String description, int revision,\n+                      ArtifactSummary artifact) {\n+    this.config = config;\n+    this.previousHash = previousHash;\n+    this.name = name;\n+    this.description = description;\n+    this.revision = revision;\n+    this.artifact = artifact;\n+  }\n+\n+  public String getDescription() {\n+    return description;\n+  }\n+\n+  public String getName() {\n+    return name == null ? \"\" : name;\n+  }\n+\n+  public int getRevision() {\n+    return revision;\n+  }\n+\n+  public ArtifactSummary getArtifact() {\n+    return artifact;\n+  }\n+\n+\n+  public T getConfig() {\n+    return config;\n+  }\n+\n+  public String getPreviousHash() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "908e206a8af3ae6c23de7e3acf7ccc5f4e9933ce"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MTQ3Nw==", "bodyText": "Remove extra line", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537791477", "createdAt": "2020-12-07T19:58:43Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftRequest.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Request to store a draft.\n+ *\n+ * @param <T> Type of config that this DraftRequest contains\n+ */\n+public class DraftRequest<T> {\n+  private final String previousHash; // currently unused but will be used later to detect collision\n+  private final String name;\n+  private final String description;\n+  private final int revision; // currently unused but will be used later to enable draft version tracking\n+  private final ArtifactSummary artifact;\n+  private T config;\n+\n+  public DraftRequest(T config, String previousHash, String name, String description, int revision,\n+                      ArtifactSummary artifact) {\n+    this.config = config;\n+    this.previousHash = previousHash;\n+    this.name = name;\n+    this.description = description;\n+    this.revision = revision;\n+    this.artifact = artifact;\n+  }\n+\n+  public String getDescription() {\n+    return description;\n+  }\n+\n+  public String getName() {\n+    return name == null ? \"\" : name;\n+  }\n+\n+  public int getRevision() {\n+    return revision;\n+  }\n+\n+  public ArtifactSummary getArtifact() {\n+    return artifact;\n+  }\n+\n+\n+  public T getConfig() {\n+    return config;\n+  }\n+\n+  public String getPreviousHash() {\n+    return previousHash;\n+  }\n+\n+  public void clearConfig() {\n+    this.config = null;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    DraftRequest<T> that = (DraftRequest<T>) o;\n+    return Objects.equals(config, that.config) &&\n+      Objects.equals(previousHash, that.previousHash) &&\n+      Objects.equals(name, that.name) &&\n+      Objects.equals(artifact, that.artifact) &&\n+      revision == that.revision;\n+  }\n+\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(config, previousHash, revision, artifact, name, description);\n+  }\n+\n+  /**\n+   * Builder for creating DraftRequest\n+   *\n+   * @param <T> Type of pipeline for the DraftRequest being created\n+   */\n+  public static class Builder<T> {\n+    private String previousHash; // currently unused but will be used later to detect collision\n+    private String name;\n+    private String description;\n+    private int revision; // currently unused but will be used later to enable draft version tracking\n+    private ArtifactSummary artifact;\n+    private T config;\n+\n+    public Builder() {\n+      this.name = \"\";\n+      this.artifact = null;\n+      this.config = null;\n+      this.previousHash = \"\";\n+      this.revision = 0;\n+      this.description = \"\";\n+    }\n+\n+    private Builder(String previousHash, String name, String description, int revision,\n+                    ArtifactSummary artifact, T config) {\n+      this.previousHash = previousHash;\n+      this.name = name;\n+      this.description = description;\n+      this.revision = revision;\n+      this.artifact = artifact;\n+      this.config = config;\n+    }\n+\n+    public static <T> Builder<T> fromRequest(DraftRequest request) {\n+      return new Builder<T>(request.getPreviousHash(), request.getName(), request.getDescription(),\n+                            request.getRevision(), request.getArtifact(), null);\n+    }\n+\n+    public static <T> Builder<T> newBuilder() {\n+      return new Builder<>();\n+    }\n+\n+    public Builder<T> setPreviousHash(String previousHash) {\n+      this.previousHash = previousHash;\n+      return this;\n+    }\n+\n+    public Builder<T> setRevision(int revision) {\n+      this.revision = revision;\n+      return this;\n+    }\n+\n+    public Builder<T> setDescription(String description) {\n+      this.description = description;\n+      return this;\n+    }\n+\n+    public Builder<T> setName(String name) {\n+      this.name = name;\n+      return this;\n+    }\n+\n+    public Builder<T> setArtifact(ArtifactSummary artifact) {\n+      this.artifact = artifact;\n+      return this;\n+    }\n+\n+    public Builder<T> setConfig(T config) {\n+      this.config = config;\n+      return this;\n+    }\n+\n+    public DraftRequest<T> build() {\n+      return new DraftRequest<>(config, previousHash, name, description, revision, artifact);\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "908e206a8af3ae6c23de7e3acf7ccc5f4e9933ce"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjM2OQ==", "bodyText": "Why need a builder? Is this class mainly for ser-de purpose?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537792369", "createdAt": "2020-12-07T20:00:10Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftRequest.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Request to store a draft.\n+ *\n+ * @param <T> Type of config that this DraftRequest contains\n+ */\n+public class DraftRequest<T> {\n+  private final String previousHash; // currently unused but will be used later to detect collision\n+  private final String name;\n+  private final String description;\n+  private final int revision; // currently unused but will be used later to enable draft version tracking\n+  private final ArtifactSummary artifact;\n+  private T config;\n+\n+  public DraftRequest(T config, String previousHash, String name, String description, int revision,\n+                      ArtifactSummary artifact) {\n+    this.config = config;\n+    this.previousHash = previousHash;\n+    this.name = name;\n+    this.description = description;\n+    this.revision = revision;\n+    this.artifact = artifact;\n+  }\n+\n+  public String getDescription() {\n+    return description;\n+  }\n+\n+  public String getName() {\n+    return name == null ? \"\" : name;\n+  }\n+\n+  public int getRevision() {\n+    return revision;\n+  }\n+\n+  public ArtifactSummary getArtifact() {\n+    return artifact;\n+  }\n+\n+\n+  public T getConfig() {\n+    return config;\n+  }\n+\n+  public String getPreviousHash() {\n+    return previousHash;\n+  }\n+\n+  public void clearConfig() {\n+    this.config = null;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    DraftRequest<T> that = (DraftRequest<T>) o;\n+    return Objects.equals(config, that.config) &&\n+      Objects.equals(previousHash, that.previousHash) &&\n+      Objects.equals(name, that.name) &&\n+      Objects.equals(artifact, that.artifact) &&\n+      revision == that.revision;\n+  }\n+\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(config, previousHash, revision, artifact, name, description);\n+  }\n+\n+  /**\n+   * Builder for creating DraftRequest\n+   *\n+   * @param <T> Type of pipeline for the DraftRequest being created\n+   */\n+  public static class Builder<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "908e206a8af3ae6c23de7e3acf7ccc5f4e9933ce"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MzczNg==", "bodyText": "Remove extra line", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537793736", "createdAt": "2020-12-07T20:02:18Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/Draft.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A pipeline draft.\n+ */\n+public class Draft extends DraftRequest<ETLConfig> {\n+  private final String id;\n+  private final long createdTimeMillis;\n+  private final long updatedTimeMillis;\n+  private final int configHash;\n+\n+  private Draft(ETLConfig config, String previousHash, String name, String description, int revision,\n+                ArtifactSummary artifact, String id, long createdTimeMillis, long updatedTimeMillis) {\n+    super(config, previousHash, name, description, revision, artifact);\n+    this.id = id;\n+    this.createdTimeMillis = createdTimeMillis;\n+    this.updatedTimeMillis = updatedTimeMillis;\n+    this.configHash = config == null ? 0 : config.hashCode();\n+  }\n+\n+  // This should be the default constructor until previousHash and revision are needed\n+  public Draft(ETLConfig config, String name, String description, ArtifactSummary artifact, String id,\n+               long createdTimeMillis, long updatedTimeMillis) {\n+    this(config, \"\", name, description, 0, artifact, id, createdTimeMillis, updatedTimeMillis);\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b661dafa26c4c029dd61975cfca3784ab60ee45"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5NDgxNQ==", "bodyText": "Don't use printStacktrace. Use a logger.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537794815", "createdAt": "2020-12-07T20:04:09Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      return;\n+    }\n+    try {\n+      this.metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());\n+    } catch (TransactionException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b661dafa26c4c029dd61975cfca3784ab60ee45"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5Njc0MQ==", "bodyText": "Can filter be null? If so, annotate the parameter with @Nullable", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537796741", "createdAt": "2020-12-07T20:07:23Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      return;\n+    }\n+    try {\n+      this.metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());\n+    } catch (TransactionException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws TransactionException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                String filter) throws TransactionException {\n+    List<Draft> drafts = store.listDrafts(namespaceSummary, owner, sortRequest);\n+    if (!includeConfig) {\n+      drafts.forEach(DraftRequest::clearConfig);\n+    }\n+\n+    if (!Strings.isNullOrEmpty(filter)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b661dafa26c4c029dd61975cfca3784ab60ee45"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5ODE0MQ==", "bodyText": "Use return store.getDraft(draftId).orElseThrow(() -> new DraftNotFoundException(draftId));", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537798141", "createdAt": "2020-12-07T20:09:33Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      return;\n+    }\n+    try {\n+      this.metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());\n+    } catch (TransactionException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws TransactionException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                String filter) throws TransactionException {\n+    List<Draft> drafts = store.listDrafts(namespaceSummary, owner, sortRequest);\n+    if (!includeConfig) {\n+      drafts.forEach(DraftRequest::clearConfig);\n+    }\n+\n+    if (!Strings.isNullOrEmpty(filter)) {\n+      //TODO Add filtering on other fields?\n+      drafts = drafts.stream()\n+        .filter(draft -> draft.getName().toLowerCase().startsWith(filter.toLowerCase()))\n+        .collect(Collectors.toList());\n+    }\n+    return drafts;\n+\n+  }\n+\n+  /**\n+   * Fetch the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @return the {@link Draft} object\n+   * @throws TransactionException when an error occurs while fetching from the table\n+   * @throws DraftNotFoundException if the draft does not exist\n+   */\n+  public Draft getDraft(DraftId draftId) throws TransactionException, DraftNotFoundException {\n+    Optional<Draft> draft = store.getDraft(draftId);\n+    if (!draft.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b661dafa26c4c029dd61975cfca3784ab60ee45"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5ODgwOA==", "bodyText": "remove this.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537798808", "createdAt": "2020-12-07T20:10:39Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      return;\n+    }\n+    try {\n+      this.metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());\n+    } catch (TransactionException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws TransactionException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                String filter) throws TransactionException {\n+    List<Draft> drafts = store.listDrafts(namespaceSummary, owner, sortRequest);\n+    if (!includeConfig) {\n+      drafts.forEach(DraftRequest::clearConfig);\n+    }\n+\n+    if (!Strings.isNullOrEmpty(filter)) {\n+      //TODO Add filtering on other fields?\n+      drafts = drafts.stream()\n+        .filter(draft -> draft.getName().toLowerCase().startsWith(filter.toLowerCase()))\n+        .collect(Collectors.toList());\n+    }\n+    return drafts;\n+\n+  }\n+\n+  /**\n+   * Fetch the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @return the {@link Draft} object\n+   * @throws TransactionException when an error occurs while fetching from the table\n+   * @throws DraftNotFoundException if the draft does not exist\n+   */\n+  public Draft getDraft(DraftId draftId) throws TransactionException, DraftNotFoundException {\n+    Optional<Draft> draft = store.getDraft(draftId);\n+    if (!draft.isPresent()) {\n+      throw new DraftNotFoundException(draftId);\n+    }\n+    return draft.get();\n+  }\n+\n+  /**\n+   * Write the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @param draftRequest {@link DraftRequest} that contains the rest of the draft data\n+   * @throws TransactionException when an error occurs while writing to the table\n+   */\n+  public <T extends ETLConfig> void writeDraft(DraftId draftId,\n+                                               DraftRequest<T> draftRequest) throws TransactionException {\n+    //TODO add collision detection using the hashes\n+    store.writeDraft(draftId, draftRequest);\n+    this.metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b661dafa26c4c029dd61975cfca3784ab60ee45"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5OTAyNg==", "bodyText": "Are all these constants need to be public?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537799026", "createdAt": "2020-12-07T20:11:03Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b661dafa26c4c029dd61975cfca3784ab60ee45"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgwNzI5MA==", "bodyText": "Instead of doing left right like this, you can based on the fieldType to use different comparator and delegate to it. Check out static method on the Comparator.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537807290", "createdAt": "2020-12-07T20:24:17Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  public static final String NAMESPACE_COL = \"namespace\";\n+  public static final String GENERATION_COL = \"generation\";\n+  public static final String OWNER_COL = \"owner\";\n+  public static final String ID_COL = \"id\";\n+  public static final String ARTIFACT_COL = \"artifact\";\n+  public static final String NAME_COL = \"name\";\n+  public static final String DESCRIPTION_COL = \"description\";\n+  public static final String CREATED_COL = \"createdTimeMillis\";\n+  public static final String UPDATED_COL = \"updatedTimeMillis\";\n+  public static final String PIPELINE_COL = \"pipeline\";\n+  public static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws TransactionException {\n+    AtomicReference<List<StructuredRow>> results = new AtomicReference<>();\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    transactionRunner.run(context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      Range range = Range.singleton(prefix);\n+      List<StructuredRow> temp = new ArrayList<>();\n+      try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+        while (rowIter.hasNext()) {\n+          temp.add(rowIter.next());\n+        }\n+      }\n+      results.set(temp);\n+    });\n+\n+    List<StructuredRow> sortedResults = doSort(results.get(), sortRequest);\n+    return sortedResults.stream().map(this::fromRow).collect(Collectors.toList());\n+\n+  }\n+\n+  /**\n+   * Helper method to apply the sorting onto a list of rows. Sorting needs to take place at the store-level so it can\n+   * leverage the StructuredRow to enable sorting on any field.\n+   *\n+   * @param rows list of {@link StructuredRow} to be sorted\n+   * @param sortRequest {@link SortRequest} describing the sort to be performed\n+   * @return a sorted list of {@link StructuredRow}\n+   */\n+  private List<StructuredRow> doSort(List<StructuredRow> rows, SortRequest sortRequest) {\n+    if (sortRequest == null) {\n+      return rows;\n+    }\n+    String sortField = sortRequest.getFieldName();\n+    Map<String, FieldType.Type> fieldTypes = TABLE_SPEC\n+      .getFieldTypes()\n+      .stream()\n+      .collect(Collectors.toMap(FieldType::getName, FieldType::getType));\n+    if (!fieldTypes.containsKey(sortField)) {\n+      throw new IllegalArgumentException(\n+        String\n+          .format(\"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\",\n+                  sortField));\n+    }\n+\n+    rows.sort((o1, o2) -> {\n+      int result = 0;\n+      FieldType.Type fieldType = fieldTypes.get(sortField);\n+\n+      Object left = null;\n+      Object right = null;\n+      switch (fieldType) {\n+        case STRING:\n+          left = o1.getString(sortField);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b661dafa26c4c029dd61975cfca3784ab60ee45"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgwODUyMw==", "bodyText": "throwing the TransactionException is not a very good contract. You should catch the TransactionException and extract the cause from it and throw that one out.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r537808523", "createdAt": "2020-12-07T20:26:18Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  public static final String NAMESPACE_COL = \"namespace\";\n+  public static final String GENERATION_COL = \"generation\";\n+  public static final String OWNER_COL = \"owner\";\n+  public static final String ID_COL = \"id\";\n+  public static final String ARTIFACT_COL = \"artifact\";\n+  public static final String NAME_COL = \"name\";\n+  public static final String DESCRIPTION_COL = \"description\";\n+  public static final String CREATED_COL = \"createdTimeMillis\";\n+  public static final String UPDATED_COL = \"updatedTimeMillis\";\n+  public static final String PIPELINE_COL = \"pipeline\";\n+  public static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws TransactionException {\n+    AtomicReference<List<StructuredRow>> results = new AtomicReference<>();\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    transactionRunner.run(context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      Range range = Range.singleton(prefix);\n+      List<StructuredRow> temp = new ArrayList<>();\n+      try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+        while (rowIter.hasNext()) {\n+          temp.add(rowIter.next());\n+        }\n+      }\n+      results.set(temp);\n+    });\n+\n+    List<StructuredRow> sortedResults = doSort(results.get(), sortRequest);\n+    return sortedResults.stream().map(this::fromRow).collect(Collectors.toList());\n+\n+  }\n+\n+  /**\n+   * Helper method to apply the sorting onto a list of rows. Sorting needs to take place at the store-level so it can\n+   * leverage the StructuredRow to enable sorting on any field.\n+   *\n+   * @param rows list of {@link StructuredRow} to be sorted\n+   * @param sortRequest {@link SortRequest} describing the sort to be performed\n+   * @return a sorted list of {@link StructuredRow}\n+   */\n+  private List<StructuredRow> doSort(List<StructuredRow> rows, SortRequest sortRequest) {\n+    if (sortRequest == null) {\n+      return rows;\n+    }\n+    String sortField = sortRequest.getFieldName();\n+    Map<String, FieldType.Type> fieldTypes = TABLE_SPEC\n+      .getFieldTypes()\n+      .stream()\n+      .collect(Collectors.toMap(FieldType::getName, FieldType::getType));\n+    if (!fieldTypes.containsKey(sortField)) {\n+      throw new IllegalArgumentException(\n+        String\n+          .format(\"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\",\n+                  sortField));\n+    }\n+\n+    rows.sort((o1, o2) -> {\n+      int result = 0;\n+      FieldType.Type fieldType = fieldTypes.get(sortField);\n+\n+      Object left = null;\n+      Object right = null;\n+      switch (fieldType) {\n+        case STRING:\n+          left = o1.getString(sortField);\n+          right = o2.getString(sortField);\n+          break;\n+        case INTEGER:\n+          left = o1.getInteger(sortField);\n+          right = o2.getInteger(sortField);\n+          break;\n+        case LONG:\n+          left = o1.getLong(sortField);\n+          right = o2.getLong(sortField);\n+          break;\n+        case FLOAT:\n+          left = o1.getFloat(sortField);\n+          right = o2.getFloat(sortField);\n+          break;\n+        case DOUBLE:\n+          left = o1.getDouble(sortField);\n+          right = o2.getDouble(sortField);\n+          break;\n+        case BYTES:\n+          throw new IllegalArgumentException(\"Cannot sort field '%s' because it is of type BYTES.\");\n+      }\n+      if (left == null && right == null) {\n+        return 0;\n+      }\n+      if (left == null || right == null) {\n+        result = left == null ? -1 : 1;\n+      } else {\n+        result = ((Comparable<Object>) left).compareTo(right);\n+      }\n+\n+      if (sortRequest.getOrder() == SortRequest.SortOrder.ASC) {\n+        return result;\n+      }\n+      return -1 * result;\n+    });\n+\n+    return rows;\n+  }\n+\n+  /**\n+   * Fetch a given draft if it exists\n+   *\n+   * @param id {@link DraftId} that is used to uniquely identify a draft\n+   * @return an {@link Optional<Draft>} representing the requested draft\n+   */\n+  public Optional<Draft> getDraft(DraftId id) throws TransactionException {\n+    AtomicReference<Optional<Draft>> result = new AtomicReference<>();\n+    transactionRunner.run(context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      Optional<StructuredRow> row = table.read(getKey(id));\n+      result.set(row.map(this::fromRow));\n+    });\n+    return result.get();\n+  }\n+\n+  /**\n+   * Delete the given draft. This is a no-op if the draft does not exist\n+   *\n+   * @param id {@link DraftId} that is used to uniquely identify a draft\n+   */\n+  public void deleteDraft(DraftId id) throws TransactionException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b661dafa26c4c029dd61975cfca3784ab60ee45"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTIzMzU2", "url": "https://github.com/cdapio/cdap/pull/12885#pullrequestreview-547523356", "createdAt": "2020-12-08T18:43:46Z", "commit": {"oid": "5e89b03edebc7e1a961d16ea136601dea42506d0"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxODo0Mzo0N1rOIBwakg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOToxNTo0NFrOIBx8yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMjcyMg==", "bodyText": "Util class should be final and has a private default constructor.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538712722", "createdAt": "2020-12-08T18:43:47Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/service/StudioUtil.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.service;\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+/**\n+ * Helper functions for handlers/services in {@link io.cdap.cdap.datapipeline.service.StudioService}\n+ */\n+public class StudioUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e89b03edebc7e1a961d16ea136601dea42506d0"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMzYyMw==", "bodyText": "Mark the parameter with @Nullable if it can be null.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538713623", "createdAt": "2020-12-08T18:44:59Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/service/StudioUtil.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.service;\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+/**\n+ * Helper functions for handlers/services in {@link io.cdap.cdap.datapipeline.service.StudioService}\n+ */\n+public class StudioUtil {\n+  public static final String ARTIFACT_BATCH_NAME = \"cdap-data-pipeline\";\n+  public static final String ARTIFACT_STREAMING_NAME = \"cdap-data-streams\";\n+\n+  public static boolean isBatchPipeline(ArtifactSummary artifactSummary) {\n+    if (artifactSummary == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e89b03edebc7e1a961d16ea136601dea42506d0"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNTEyNQ==", "bodyText": "Shouldn't have this. The DraftHandler created in the configure method should have a default constructor that doesn't does the metrics object. The Metrics field in the DraftHandler will get injected at run time.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538715125", "createdAt": "2020-12-08T18:47:04Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/service/StudioService.java", "diffHunk": "@@ -17,18 +17,27 @@\n \n package io.cdap.cdap.datapipeline.service;\n \n+import io.cdap.cdap.api.metrics.Metrics;\n import io.cdap.cdap.api.service.AbstractSystemService;\n+import io.cdap.cdap.datapipeline.draft.DraftStore;\n \n /**\n  * Service that handles pipeline studio operations, like validation and schema propagation.\n  */\n public class StudioService extends AbstractSystemService {\n   public static final String NAME = \"studio\";\n \n+  // Injected by CDAP\n+  @SuppressWarnings(\"unused\")\n+  private Metrics serviceMetrics;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e89b03edebc7e1a961d16ea136601dea42506d0"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMzkxMA==", "bodyText": "Why not move it to the respond method to handle as well?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538733910", "createdAt": "2020-12-08T19:09:40Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/service/DraftHandler.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.data.schema.Schema;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.api.service.http.AbstractSystemHttpServiceHandler;\n+import io.cdap.cdap.api.service.http.HttpServiceRequest;\n+import io.cdap.cdap.api.service.http.HttpServiceResponder;\n+import io.cdap.cdap.api.service.http.SystemHttpServiceContext;\n+import io.cdap.cdap.datapipeline.draft.CodedException;\n+import io.cdap.cdap.datapipeline.draft.DraftId;\n+import io.cdap.cdap.datapipeline.draft.DraftRequest;\n+import io.cdap.cdap.datapipeline.draft.DraftRequestDeserializer;\n+import io.cdap.cdap.datapipeline.draft.DraftService;\n+import io.cdap.cdap.datapipeline.draft.SortRequest;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.internal.io.SchemaTypeAdapter;\n+import io.cdap.cdap.spi.data.TableNotFoundException;\n+\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.nio.charset.StandardCharsets;\n+import javax.annotation.Nullable;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.QueryParam;\n+\n+/**\n+ * Handler of drafts\n+ */\n+public class DraftHandler extends AbstractSystemHttpServiceHandler {\n+  private static final Gson GSON = new GsonBuilder()\n+    .setPrettyPrinting()\n+    .registerTypeAdapter(DraftRequest.class, new DraftRequestDeserializer())\n+    .registerTypeAdapter(Schema.class, new SchemaTypeAdapter())\n+    .create();\n+\n+  private final Metrics metrics;\n+\n+  private DraftService draftService;\n+\n+  public DraftHandler(Metrics metrics) {\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void initialize(SystemHttpServiceContext context) throws Exception {\n+    super.initialize(context);\n+    this.draftService = new DraftService(context, this.metrics);\n+  }\n+\n+  /**\n+   * Returns a list of drafts associated with a namespace and the current user\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts\")\n+  public void listDrafts(HttpServiceRequest request, HttpServiceResponder responder,\n+                         @PathParam(\"context\") String namespaceName,\n+                         @QueryParam(\"includeConfig\") @DefaultValue(\"false\") boolean includeConfig,\n+                         @QueryParam(\"sortBy\") @DefaultValue(\"name\") String sortBy,\n+                         @QueryParam(\"sortOrder\") @DefaultValue(\"ASC\") String sortOrder,\n+                         @QueryParam(\"filter\") @Nullable String filter) {\n+\n+    respond(namespaceName, responder, (namespace) -> {\n+      SortRequest sortRequest = new SortRequest(sortBy, sortOrder);\n+      responder.sendJson(draftService.listDrafts(namespace, request.getUserId(), includeConfig, sortRequest, filter));\n+    });\n+  }\n+\n+  /**\n+   * Gets the details of a draft\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void getDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                       @PathParam(\"context\") String namespaceName,\n+                       @PathParam(\"draft\") String draftId) {\n+    respond(namespaceName, responder, (namespace) -> {\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+      responder.sendJson(draftService.getDraft(id));\n+    });\n+  }\n+\n+  /**\n+   * Creates or updates a draft\n+   */\n+  @PUT\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void putDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                       @PathParam(\"context\") String namespaceName,\n+                       @PathParam(\"draft\") String draftId) {\n+\n+    respond(namespaceName, responder, (namespace) -> {\n+      DraftRequest<ETLConfig> draftRequest;\n+      try {\n+        draftRequest = GSON\n+          .fromJson(StandardCharsets.UTF_8.decode(request.getContent()).toString(), DraftRequest.class);\n+      } catch (JsonSyntaxException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e89b03edebc7e1a961d16ea136601dea42506d0"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDY4Ng==", "bodyText": "Remove extra new lines", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538734686", "createdAt": "2020-12-08T19:10:55Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/SortRequest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Class to hold information for a sorting request in a list API\n+ */\n+public class SortRequest {\n+  private final String fieldName;\n+  private final SortOrder order;\n+\n+  public SortRequest(String fieldName, String sortOrder) {\n+    this.fieldName = fieldName;\n+    try {\n+      this.order = SortOrder.valueOf(sortOrder.toUpperCase());\n+    } catch (Exception e) {\n+      throw new IllegalArgumentException(String.format(\"Sort order '%s' is not valid. Valid options are %s\", sortOrder,\n+                                                       Arrays.toString(SortOrder.values())));\n+    }\n+  }\n+\n+  public String getFieldName() {\n+    return fieldName;\n+  }\n+\n+  public SortOrder getOrder() {\n+    return order;\n+  }\n+\n+  enum SortOrder {\n+    ASC,\n+    DESC\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e89b03edebc7e1a961d16ea136601dea42506d0"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNTg0Ng==", "bodyText": "Is this correct?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538735846", "createdAt": "2020-12-08T19:12:36Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws TransactionException {\n+    AtomicReference<List<StructuredRow>> results = new AtomicReference<>();\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    transactionRunner.run(context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      Range range = Range.singleton(prefix);\n+      List<StructuredRow> temp = new ArrayList<>();\n+      try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+        while (rowIter.hasNext()) {\n+          temp.add(rowIter.next());\n+        }\n+      }\n+      results.set(temp);\n+    });\n+\n+    List<StructuredRow> sortedResults = doSort(results.get(), sortRequest);\n+    return sortedResults.stream().map(this::fromRow).collect(Collectors.toList());\n+\n+  }\n+\n+  /**\n+   * Helper method to apply the sorting onto a list of rows. Sorting needs to take place at the store-level so it can\n+   * leverage the StructuredRow to enable sorting on any field.\n+   *\n+   * @param rows list of {@link StructuredRow} to be sorted\n+   * @param sortRequest {@link SortRequest} describing the sort to be performed\n+   * @return a sorted list of {@link StructuredRow}\n+   */\n+  private List<StructuredRow> doSort(List<StructuredRow> rows, SortRequest sortRequest) {\n+    if (sortRequest == null) {\n+      return rows;\n+    }\n+    String sortField = sortRequest.getFieldName();\n+    Map<String, FieldType.Type> fieldTypes = TABLE_SPEC\n+      .getFieldTypes()\n+      .stream()\n+      .collect(Collectors.toMap(FieldType::getName, FieldType::getType));\n+    if (!fieldTypes.containsKey(sortField)) {\n+      throw new IllegalArgumentException(\n+        String\n+          .format(\"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\",\n+                  sortField));\n+    }\n+\n+    rows.sort((o1, o2) -> {\n+      int result = 0;\n+      FieldType.Type fieldType = fieldTypes.get(sortField);\n+\n+      Object left = null;\n+      Object right = null;\n+      switch (fieldType) {\n+        case STRING:\n+          left = o1.getString(sortField);\n+          right = o2.getString(sortField);\n+          break;\n+        case INTEGER:\n+          left = o1.getInteger(sortField);\n+          right = o2.getInteger(sortField);\n+          break;\n+        case LONG:\n+          left = o1.getLong(sortField);\n+          right = o2.getLong(sortField);\n+          break;\n+        case FLOAT:\n+          left = o1.getFloat(sortField);\n+          right = o2.getFloat(sortField);\n+          break;\n+        case DOUBLE:\n+          left = o1.getDouble(sortField);\n+          right = o2.getDouble(sortField);\n+          break;\n+        case BYTES:\n+          throw new IllegalArgumentException(\"Cannot sort field '%s' because it is of type BYTES.\");\n+      }\n+      if (left == null && right == null) {\n+        return 0;\n+      }\n+      if (left == null || right == null) {\n+        result = left == null ? -1 : 1;\n+      } else {\n+        result = ((Comparable<Object>) left).compareTo(right);\n+      }\n+\n+      if (sortRequest.getOrder() == SortRequest.SortOrder.ASC) {\n+        return result;\n+      }\n+      return -1 * result;\n+    });\n+\n+    return rows;\n+  }\n+\n+  /**\n+   * Fetch a given draft if it exists\n+   *\n+   * @param id {@link DraftId} that is used to uniquely identify a draft\n+   * @return an {@link Optional<Draft>} representing the requested draft\n+   */\n+  public Optional<Draft> getDraft(DraftId id) throws TransactionException {\n+    AtomicReference<Optional<Draft>> result = new AtomicReference<>();\n+    transactionRunner.run(context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      Optional<StructuredRow> row = table.read(getKey(id));\n+      result.set(row.map(this::fromRow));\n+    });\n+    return result.get();\n+  }\n+\n+  /**\n+   * Delete the given draft. This is a no-op if the draft does not exist\n+   *\n+   * @param id {@link DraftId} that is used to uniquely identify a draft\n+   */\n+  public void deleteDraft(DraftId id) throws TransactionException {\n+    transactionRunner.run(context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      table.delete(getKey(id));\n+    });\n+  }\n+\n+  /**\n+   * Create/update the given draft\n+   *\n+   * @param id {@link DraftId} that is used to uniquely identify a draft\n+   * @param request {@link DraftRequest} that contains the rest of the draft data\n+   * @throws TransactionException\n+   */\n+  public <T extends ETLConfig> void writeDraft(DraftId id, DraftRequest<T> request) throws TransactionException {\n+    Optional<Draft> existing = getDraft(id);\n+    long now = System.currentTimeMillis();\n+    long createTime = existing.map(Draft::getCreatedTimeMillis).orElse(now);\n+\n+    Draft draft = new Draft(request.getConfig(), request.getName(), request.getDescription(), request.getArtifact(),\n+                            id.getId(), createTime, now);\n+    transactionRunner.run(context -> {\n+//      StructuredTable table = context.getTable(TABLE_ID);\n+            StructuredTable table = context.getTable(new StructuredTableId(\"TESTST\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e89b03edebc7e1a961d16ea136601dea42506d0"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNzg2NA==", "bodyText": "So, just log without failing? Is this the expected behavior?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538737864", "createdAt": "2020-12-08T19:15:44Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private static final Logger LOG = LoggerFactory.getLogger(DraftService.class);\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      LOG.error(\"Metrics collector was not injected into StudioService\");\n+    }\n+    try {\n+      this.metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());\n+    } catch (TransactionException e) {\n+      LOG.warn(\"Failed to write {} metric on DraftService startup due to: {}\", Constants.Metrics.DRAFT_COUNT,\n+               e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws TransactionException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                @Nullable String filter) throws TransactionException {\n+    List<Draft> drafts = store.listDrafts(namespaceSummary, owner, sortRequest);\n+    if (!includeConfig) {\n+      drafts.forEach(DraftRequest::clearConfig);\n+    }\n+\n+    if (!Strings.isNullOrEmpty(filter)) {\n+      //TODO Add filtering on other fields?\n+      drafts = drafts.stream()\n+        .filter(draft -> draft.getName().toLowerCase().startsWith(filter.toLowerCase()))\n+        .collect(Collectors.toList());\n+    }\n+    return drafts;\n+\n+  }\n+\n+  /**\n+   * Fetch the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @return the {@link Draft} object\n+   * @throws TransactionException when an error occurs while fetching from the table\n+   * @throws DraftNotFoundException if the draft does not exist\n+   */\n+  public Draft getDraft(DraftId draftId) throws TransactionException, DraftNotFoundException {\n+    return store.getDraft(draftId).orElseThrow(() -> new DraftNotFoundException(draftId));\n+  }\n+\n+  /**\n+   * Write the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @param draftRequest {@link DraftRequest} that contains the rest of the draft data\n+   * @throws TransactionException when an error occurs while writing to the table\n+   */\n+  public <T extends ETLConfig> void writeDraft(DraftId draftId,\n+                                               DraftRequest<T> draftRequest) throws TransactionException {\n+    //TODO add collision detection using the hashes\n+    try {\n+      store.writeDraft(draftId, draftRequest);\n+    } catch (TransactionException e) {\n+      LOG.warn(\"Failed to write {} metric on writeDraft request due to: {}\", Constants.Metrics.DRAFT_COUNT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e89b03edebc7e1a961d16ea136601dea42506d0"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NjYyMDQy", "url": "https://github.com/cdapio/cdap/pull/12885#pullrequestreview-547662042", "createdAt": "2020-12-08T21:51:01Z", "commit": {"oid": "1ea2c75ed34e90469177b923588080987fdc0fac"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMTo1MTowMlrOIB3ztA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMTo1Njo1MlrOIB4BGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzMzg0NA==", "bodyText": "final", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538833844", "createdAt": "2020-12-08T21:51:02Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftRequest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Request to store a draft.\n+ *\n+ * @param <T> Type of config that this DraftRequest contains\n+ */\n+public class DraftRequest<T> {\n+  private final String previousHash;\n+  private final String name;\n+  private final String description;\n+  private final int revision;\n+  private final ArtifactSummary artifact;\n+  private T config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ea2c75ed34e90469177b923588080987fdc0fac"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzNDgxOA==", "bodyText": "If you provide a Builder, the constructor should be private.\nAlso, from the builder implementation, both the config and the artifact can be null. Is it intended? If so, please annotate them as @Nullable. If not, please check and throw exception in the Builder.build method.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538834818", "createdAt": "2020-12-08T21:52:39Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftRequest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Request to store a draft.\n+ *\n+ * @param <T> Type of config that this DraftRequest contains\n+ */\n+public class DraftRequest<T> {\n+  private final String previousHash;\n+  private final String name;\n+  private final String description;\n+  private final int revision;\n+  private final ArtifactSummary artifact;\n+  private T config;\n+\n+  public DraftRequest(T config, String previousHash, String name, String description, int revision,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ea2c75ed34e90469177b923588080987fdc0fac"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzNTMxMw==", "bodyText": "Shouldn't new a Gson inside a deserializer. Use context.deserialize instead.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538835313", "createdAt": "2020-12-08T21:53:35Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftRequestDeserializer.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * GSON deserializer to correctly deserialize the config field in {@link DraftRequest}\n+ */\n+public class DraftRequestDeserializer implements JsonDeserializer<DraftRequest<ETLConfig>> {\n+\n+  @Override\n+  public DraftRequest<ETLConfig> deserialize(JsonElement jsonElement, Type type,\n+                                             JsonDeserializationContext context) throws JsonParseException {\n+\n+    // Deserialize this normally to get all the other field values\n+    Gson gson = new GsonBuilder().create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ea2c75ed34e90469177b923588080987fdc0fac"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzNTY5Mg==", "bodyText": "Log as warn. If you log as error, it should halt the flow.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538835692", "createdAt": "2020-12-08T21:54:10Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private static final Logger LOG = LoggerFactory.getLogger(DraftService.class);\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      LOG.error(\"Metrics collector was not injected into StudioService\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ea2c75ed34e90469177b923588080987fdc0fac"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzNjI2Mw==", "bodyText": "Don't do data logic in constructor (store.getDraftCount is a data logic)", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538836263", "createdAt": "2020-12-08T21:55:07Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private static final Logger LOG = LoggerFactory.getLogger(DraftService.class);\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      LOG.error(\"Metrics collector was not injected into StudioService\");\n+    }\n+    try {\n+      this.metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ea2c75ed34e90469177b923588080987fdc0fac"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzNjYxNQ==", "bodyText": "no need to throws RuntimeException. Also, throwing RuntimeException is not a good contract. Should throw something more specific to indicate what the error is.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538836615", "createdAt": "2020-12-08T21:55:44Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private static final Logger LOG = LoggerFactory.getLogger(DraftService.class);\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      LOG.error(\"Metrics collector was not injected into StudioService\");\n+    }\n+    try {\n+      this.metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());\n+    } catch (Exception e) {\n+      LOG.warn(\"Failed to write {} metric on DraftService startup due to: {}\", Constants.Metrics.DRAFT_COUNT,\n+               e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                @Nullable String filter) throws RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ea2c75ed34e90469177b923588080987fdc0fac"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzNjgzNw==", "bodyText": "Don't do this.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538836837", "createdAt": "2020-12-08T21:56:09Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Throwables;\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.commons.lang.NotImplementedException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws RuntimeException {\n+    AtomicReference<List<StructuredRow>> results = new AtomicReference<>();\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    try {\n+      transactionRunner.run(context -> {\n+        StructuredTable table = context.getTable(TABLE_ID);\n+        Range range = Range.singleton(prefix);\n+        List<StructuredRow> temp = new ArrayList<>();\n+        try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+          while (rowIter.hasNext()) {\n+            temp.add(rowIter.next());\n+          }\n+        }\n+        results.set(temp);\n+      });\n+    } catch (TransactionException e) {\n+      Throwables.propagate(e.getCause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ea2c75ed34e90469177b923588080987fdc0fac"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzNzI3Mg==", "bodyText": "You can use the Bytes.BYTES_COMPARATOR", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538837272", "createdAt": "2020-12-08T21:56:52Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Throwables;\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.commons.lang.NotImplementedException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws RuntimeException {\n+    AtomicReference<List<StructuredRow>> results = new AtomicReference<>();\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    try {\n+      transactionRunner.run(context -> {\n+        StructuredTable table = context.getTable(TABLE_ID);\n+        Range range = Range.singleton(prefix);\n+        List<StructuredRow> temp = new ArrayList<>();\n+        try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+          while (rowIter.hasNext()) {\n+            temp.add(rowIter.next());\n+          }\n+        }\n+        results.set(temp);\n+      });\n+    } catch (TransactionException e) {\n+      Throwables.propagate(e.getCause());\n+    }\n+\n+    List<StructuredRow> sortedResults = doSort(results.get(), sortRequest);\n+    return sortedResults.stream().map(this::fromRow).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Helper method to apply the sorting onto a list of rows. Sorting needs to take place at the store-level so it can\n+   * leverage the StructuredRow to enable sorting on any field.\n+   *\n+   * @param rows list of {@link StructuredRow} to be sorted\n+   * @param sortRequest {@link SortRequest} describing the sort to be performed\n+   * @return a sorted list of {@link StructuredRow}\n+   */\n+  private List<StructuredRow> doSort(List<StructuredRow> rows, SortRequest sortRequest) {\n+    if (sortRequest == null) {\n+      return rows;\n+    }\n+    String sortField = sortRequest.getFieldName();\n+    Map<String, FieldType.Type> fieldTypes = TABLE_SPEC\n+      .getFieldTypes()\n+      .stream()\n+      .collect(Collectors.toMap(FieldType::getName, FieldType::getType));\n+    if (!fieldTypes.containsKey(sortField)) {\n+      throw new IllegalArgumentException(\n+        String\n+          .format(\"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\",\n+                  sortField));\n+    }\n+\n+    rows.sort((o1, o2) -> {\n+      FieldType.Type fieldType = fieldTypes.get(sortField);\n+      Comparator<StructuredRow> comparator = null;\n+      switch (fieldType) {\n+        case STRING:\n+          comparator = Comparator.<StructuredRow, String>comparing(o -> o.getString(sortField));\n+          break;\n+        case INTEGER:\n+          comparator = Comparator.<StructuredRow, Integer>comparing(o -> o.getInteger(sortField));\n+          break;\n+        case LONG:\n+          comparator = Comparator.<StructuredRow, Long>comparing(o -> o.getLong(sortField));\n+          break;\n+        case FLOAT:\n+          comparator = Comparator.<StructuredRow, Float>comparing(o -> o.getFloat(sortField));\n+          break;\n+        case DOUBLE:\n+          comparator = Comparator.<StructuredRow, Double>comparing(o -> o.getDouble(sortField));\n+          break;\n+        case BYTES:\n+          throw new IllegalArgumentException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ea2c75ed34e90469177b923588080987fdc0fac"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzUyODIy", "url": "https://github.com/cdapio/cdap/pull/12885#pullrequestreview-547752822", "createdAt": "2020-12-09T00:50:40Z", "commit": {"oid": "5a0db0adfa0dd769932aff143ee585f9c332900c"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDo1MDo0MFrOIB9EcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMTowNjoxMlrOIB9c7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMDA0OQ==", "bodyText": "nit: id is a bit misleading since this doesn't actually uniquely identify anything. This is more like a name.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538920049", "createdAt": "2020-12-09T00:50:40Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftId.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import io.cdap.cdap.api.NamespaceSummary;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Uniquely identifies a draft.\n+ */\n+public class DraftId {\n+  private final NamespaceSummary namespace;\n+  private final String id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0db0adfa0dd769932aff143ee585f9c332900c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMDcxNw==", "bodyText": "nit: DraftWriteRequest or DraftStoreRequest is a little more descriptive", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538920717", "createdAt": "2020-12-09T00:52:19Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftRequest.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Request to store a draft.\n+ *\n+ * @param <T> Type of config that this DraftRequest contains\n+ */\n+public class DraftRequest<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0db0adfa0dd769932aff143ee585f9c332900c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMTY4Mw==", "bodyText": "is this an outdated comment? Don't see this getting used anywhere.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538921683", "createdAt": "2020-12-09T00:54:20Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftRequestDeserializer.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * GSON deserializer to correctly deserialize the config field in {@link DraftRequest}\n+ */\n+public class DraftRequestDeserializer implements JsonDeserializer<DraftRequest<ETLConfig>> {\n+\n+  @Override\n+  public DraftRequest<ETLConfig> deserialize(JsonElement jsonElement, Type type,\n+                                             JsonDeserializationContext context) throws JsonParseException {\n+\n+    // Deserialize this normally to get all the other field values\n+    Gson gson = new GsonBuilder().create();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzNTMxMw=="}, "originalCommit": {"oid": "1ea2c75ed34e90469177b923588080987fdc0fac"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMjUxOQ==", "bodyText": "we generally don't declare that a method throws any type of RuntimeException and just put it in the javadoc.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538922519", "createdAt": "2020-12-09T00:56:24Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private static final Logger LOG = LoggerFactory.getLogger(DraftService.class);\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      LOG.warn(\"Metrics collector was not injected into DraftHandler\");\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                @Nullable String filter) {\n+    List<Draft> drafts = store.listDrafts(namespaceSummary, owner, sortRequest);\n+    if (!includeConfig) {\n+      drafts = drafts.stream().map(Draft::copyWithoutConfig).collect(Collectors.toList());\n+    }\n+\n+    if (!Strings.isNullOrEmpty(filter)) {\n+      //TODO Add filtering on other fields?\n+      drafts = drafts.stream()\n+        .filter(draft -> draft.getName().toLowerCase().startsWith(filter.toLowerCase()))\n+        .collect(Collectors.toList());\n+    }\n+    return drafts;\n+  }\n+\n+  /**\n+   * Fetch the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @return the {@link Draft} object\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   * @throws DraftNotFoundException if the draft does not exist\n+   */\n+  public Draft getDraft(DraftId draftId) throws RuntimeException, DraftNotFoundException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0db0adfa0dd769932aff143ee585f9c332900c"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMjk4OA==", "bodyText": "Is this happening in a follow up or sometime later?\nTODO comments should mention the jira number, otherwise these things always get lost.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538922988", "createdAt": "2020-12-09T00:57:29Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private static final Logger LOG = LoggerFactory.getLogger(DraftService.class);\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      LOG.warn(\"Metrics collector was not injected into DraftHandler\");\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                @Nullable String filter) {\n+    List<Draft> drafts = store.listDrafts(namespaceSummary, owner, sortRequest);\n+    if (!includeConfig) {\n+      drafts = drafts.stream().map(Draft::copyWithoutConfig).collect(Collectors.toList());\n+    }\n+\n+    if (!Strings.isNullOrEmpty(filter)) {\n+      //TODO Add filtering on other fields?\n+      drafts = drafts.stream()\n+        .filter(draft -> draft.getName().toLowerCase().startsWith(filter.toLowerCase()))\n+        .collect(Collectors.toList());\n+    }\n+    return drafts;\n+  }\n+\n+  /**\n+   * Fetch the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @return the {@link Draft} object\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   * @throws DraftNotFoundException if the draft does not exist\n+   */\n+  public Draft getDraft(DraftId draftId) throws RuntimeException, DraftNotFoundException {\n+    return store.getDraft(draftId).orElseThrow(() -> new DraftNotFoundException(draftId));\n+  }\n+\n+  /**\n+   * Write the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @param draftRequest {@link DraftRequest} that contains the rest of the draft data\n+   * @throws RuntimeException when an error occurs while writing to the table\n+   */\n+  public <T extends ETLConfig> void writeDraft(DraftId draftId,\n+                                               DraftRequest<T> draftRequest) {\n+    //TODO add collision detection using the hashes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0db0adfa0dd769932aff143ee585f9c332900c"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNTMxMA==", "bodyText": "this type of error should eventually result in a 400 response code. I think it's better to validate this earlier in the handler rather than here. Each handler method should be validating user input before passing it lower in the stack.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538925310", "createdAt": "2020-12-09T01:03:29Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.InvalidFieldException;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.StructuredTableInstantiationException;\n+import io.cdap.cdap.spi.data.TableNotFoundException;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.commons.lang.NotImplementedException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws RuntimeException {\n+    AtomicReference<List<StructuredRow>> results = new AtomicReference<>();\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    try {\n+      transactionRunner.run(context -> {\n+        StructuredTable table = context.getTable(TABLE_ID);\n+        Range range = Range.singleton(prefix);\n+        List<StructuredRow> temp = new ArrayList<>();\n+        try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+          while (rowIter.hasNext()) {\n+            temp.add(rowIter.next());\n+          }\n+        }\n+        results.set(temp);\n+      });\n+    } catch (TransactionException e) {\n+      handleError(e.getCause());\n+    }\n+\n+    List<StructuredRow> sortedResults = doSort(results.get(), sortRequest);\n+    return sortedResults.stream().map(this::fromRow).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Helper method to apply the sorting onto a list of rows. Sorting needs to take place at the store-level so it can\n+   * leverage the StructuredRow to enable sorting on any field.\n+   *\n+   * @param rows list of {@link StructuredRow} to be sorted\n+   * @param sortRequest {@link SortRequest} describing the sort to be performed\n+   * @return a sorted list of {@link StructuredRow}\n+   */\n+  private List<StructuredRow> doSort(List<StructuredRow> rows, SortRequest sortRequest) {\n+    if (sortRequest == null) {\n+      return rows;\n+    }\n+    String sortField = sortRequest.getFieldName();\n+    Map<String, FieldType.Type> fieldTypes = TABLE_SPEC\n+      .getFieldTypes()\n+      .stream()\n+      .collect(Collectors.toMap(FieldType::getName, FieldType::getType));\n+    if (!fieldTypes.containsKey(sortField)) {\n+      throw new IllegalArgumentException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0db0adfa0dd769932aff143ee585f9c332900c"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNTczNA==", "bodyText": "should get the Comparator outside of the sort, so that this logic happens only once instead of for each comparison.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538925734", "createdAt": "2020-12-09T01:04:37Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.InvalidFieldException;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.StructuredTableInstantiationException;\n+import io.cdap.cdap.spi.data.TableNotFoundException;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.commons.lang.NotImplementedException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws RuntimeException {\n+    AtomicReference<List<StructuredRow>> results = new AtomicReference<>();\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    try {\n+      transactionRunner.run(context -> {\n+        StructuredTable table = context.getTable(TABLE_ID);\n+        Range range = Range.singleton(prefix);\n+        List<StructuredRow> temp = new ArrayList<>();\n+        try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+          while (rowIter.hasNext()) {\n+            temp.add(rowIter.next());\n+          }\n+        }\n+        results.set(temp);\n+      });\n+    } catch (TransactionException e) {\n+      handleError(e.getCause());\n+    }\n+\n+    List<StructuredRow> sortedResults = doSort(results.get(), sortRequest);\n+    return sortedResults.stream().map(this::fromRow).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Helper method to apply the sorting onto a list of rows. Sorting needs to take place at the store-level so it can\n+   * leverage the StructuredRow to enable sorting on any field.\n+   *\n+   * @param rows list of {@link StructuredRow} to be sorted\n+   * @param sortRequest {@link SortRequest} describing the sort to be performed\n+   * @return a sorted list of {@link StructuredRow}\n+   */\n+  private List<StructuredRow> doSort(List<StructuredRow> rows, SortRequest sortRequest) {\n+    if (sortRequest == null) {\n+      return rows;\n+    }\n+    String sortField = sortRequest.getFieldName();\n+    Map<String, FieldType.Type> fieldTypes = TABLE_SPEC\n+      .getFieldTypes()\n+      .stream()\n+      .collect(Collectors.toMap(FieldType::getName, FieldType::getType));\n+    if (!fieldTypes.containsKey(sortField)) {\n+      throw new IllegalArgumentException(\n+        String\n+          .format(\"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\",\n+                  sortField));\n+    }\n+\n+    rows.sort((o1, o2) -> {\n+      FieldType.Type fieldType = fieldTypes.get(sortField);\n+      Comparator<StructuredRow> comparator = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0db0adfa0dd769932aff143ee585f9c332900c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyNjMxNw==", "bodyText": "There is a TransactionRunners utility class that you can use instead of doing this.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r538926317", "createdAt": "2020-12-09T01:06:12Z", "author": {"login": "albertshau"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.InvalidFieldException;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.StructuredTableInstantiationException;\n+import io.cdap.cdap.spi.data.TableNotFoundException;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionException;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.apache.commons.lang.NotImplementedException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws RuntimeException {\n+    AtomicReference<List<StructuredRow>> results = new AtomicReference<>();\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    try {\n+      transactionRunner.run(context -> {\n+        StructuredTable table = context.getTable(TABLE_ID);\n+        Range range = Range.singleton(prefix);\n+        List<StructuredRow> temp = new ArrayList<>();\n+        try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+          while (rowIter.hasNext()) {\n+            temp.add(rowIter.next());\n+          }\n+        }\n+        results.set(temp);\n+      });\n+    } catch (TransactionException e) {\n+      handleError(e.getCause());\n+    }\n+\n+    List<StructuredRow> sortedResults = doSort(results.get(), sortRequest);\n+    return sortedResults.stream().map(this::fromRow).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Helper method to apply the sorting onto a list of rows. Sorting needs to take place at the store-level so it can\n+   * leverage the StructuredRow to enable sorting on any field.\n+   *\n+   * @param rows list of {@link StructuredRow} to be sorted\n+   * @param sortRequest {@link SortRequest} describing the sort to be performed\n+   * @return a sorted list of {@link StructuredRow}\n+   */\n+  private List<StructuredRow> doSort(List<StructuredRow> rows, SortRequest sortRequest) {\n+    if (sortRequest == null) {\n+      return rows;\n+    }\n+    String sortField = sortRequest.getFieldName();\n+    Map<String, FieldType.Type> fieldTypes = TABLE_SPEC\n+      .getFieldTypes()\n+      .stream()\n+      .collect(Collectors.toMap(FieldType::getName, FieldType::getType));\n+    if (!fieldTypes.containsKey(sortField)) {\n+      throw new IllegalArgumentException(\n+        String\n+          .format(\"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\",\n+                  sortField));\n+    }\n+\n+    rows.sort((o1, o2) -> {\n+      FieldType.Type fieldType = fieldTypes.get(sortField);\n+      Comparator<StructuredRow> comparator = null;\n+      switch (fieldType) {\n+        case STRING:\n+          comparator = Comparator.<StructuredRow, String>comparing(o -> o.getString(sortField));\n+          break;\n+        case INTEGER:\n+          comparator = Comparator.<StructuredRow, Integer>comparing(o -> o.getInteger(sortField));\n+          break;\n+        case LONG:\n+          comparator = Comparator.<StructuredRow, Long>comparing(o -> o.getLong(sortField));\n+          break;\n+        case FLOAT:\n+          comparator = Comparator.<StructuredRow, Float>comparing(o -> o.getFloat(sortField));\n+          break;\n+        case DOUBLE:\n+          comparator = Comparator.<StructuredRow, Double>comparing(o -> o.getDouble(sortField));\n+          break;\n+        case BYTES:\n+          comparator = Comparator.comparing(o -> o.getBytes(sortField), Bytes.BYTES_COMPARATOR);\n+          break;\n+        default:\n+          throw new NotImplementedException(String.format(\"Cannot sort field '%s' because type '%s' is not supported.\",\n+                                                          sortField, fieldType.toString()));\n+      }\n+\n+      if (sortRequest.getOrder() != SortRequest.SortOrder.ASC) {\n+        comparator = comparator.reversed();\n+      }\n+      return comparator.compare(o1, o2);\n+    });\n+\n+    return rows;\n+  }\n+\n+  /**\n+   * Fetch a given draft if it exists\n+   *\n+   * @param id {@link DraftId} that is used to uniquely identify a draft\n+   * @return an {@link Optional<Draft>} representing the requested draft\n+   */\n+  public Optional<Draft> getDraft(DraftId id) throws RuntimeException {\n+    AtomicReference<Optional<Draft>> result = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0db0adfa0dd769932aff143ee585f9c332900c"}, "originalPosition": 190}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMzk5NzIy", "url": "https://github.com/cdapio/cdap/pull/12885#pullrequestreview-550399722", "createdAt": "2020-12-11T18:09:21Z", "commit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODowOToyMVrOIEEIcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODoyODowN1rOIEEzBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEzMjkxNA==", "bodyText": "Why not have this passed to the store.listDrafts method and have the returned drafts already without the config?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541132914", "createdAt": "2020-12-11T18:09:21Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private static final Logger LOG = LoggerFactory.getLogger(DraftService.class);\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      LOG.warn(\"Metrics collector was not injected into DraftHandler\");\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                @Nullable String filter) {\n+    List<Draft> drafts = store.listDrafts(namespaceSummary, owner, sortRequest);\n+    if (!includeConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEzMzU4Mg==", "bodyText": "Writing to metrics should never fail.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541133582", "createdAt": "2020-12-11T18:10:29Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private static final Logger LOG = LoggerFactory.getLogger(DraftService.class);\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      LOG.warn(\"Metrics collector was not injected into DraftHandler\");\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                @Nullable String filter) {\n+    List<Draft> drafts = store.listDrafts(namespaceSummary, owner, sortRequest);\n+    if (!includeConfig) {\n+      drafts = drafts.stream().map(Draft::copyWithoutConfig).collect(Collectors.toList());\n+    }\n+\n+    if (!Strings.isNullOrEmpty(filter)) {\n+      //TODO Add filtering on other fields?\n+      drafts = drafts.stream()\n+        .filter(draft -> draft.getName().toLowerCase().startsWith(filter.toLowerCase()))\n+        .collect(Collectors.toList());\n+    }\n+    return drafts;\n+  }\n+\n+  /**\n+   * Fetch the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @return the {@link Draft} object\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   * @throws DraftNotFoundException if the draft does not exist\n+   */\n+  public Draft getDraft(DraftId draftId) throws RuntimeException, DraftNotFoundException {\n+    return store.getDraft(draftId).orElseThrow(() -> new DraftNotFoundException(draftId));\n+  }\n+\n+  /**\n+   * Write the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @param draftStoreRequest {@link DraftStoreRequest} that contains the rest of the draft data\n+   * @throws RuntimeException when an error occurs while writing to the table\n+   */\n+  public <T extends ETLConfig> void writeDraft(DraftId draftId,\n+                                               DraftStoreRequest<T> draftStoreRequest) {\n+    // TODO(CDAP-17456): Add collision detection using the hashes\n+    store.writeDraft(draftId, draftStoreRequest);\n+\n+    // Wrap metrics in try-catch to prevent entire request from failing if metrics writing fails", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEzMzc2MA==", "bodyText": "Remove extra empty lines.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541133760", "createdAt": "2020-12-11T18:10:46Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private static final Logger LOG = LoggerFactory.getLogger(DraftService.class);\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      LOG.warn(\"Metrics collector was not injected into DraftHandler\");\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                @Nullable String filter) {\n+    List<Draft> drafts = store.listDrafts(namespaceSummary, owner, sortRequest);\n+    if (!includeConfig) {\n+      drafts = drafts.stream().map(Draft::copyWithoutConfig).collect(Collectors.toList());\n+    }\n+\n+    if (!Strings.isNullOrEmpty(filter)) {\n+      //TODO Add filtering on other fields?\n+      drafts = drafts.stream()\n+        .filter(draft -> draft.getName().toLowerCase().startsWith(filter.toLowerCase()))\n+        .collect(Collectors.toList());\n+    }\n+    return drafts;\n+  }\n+\n+  /**\n+   * Fetch the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @return the {@link Draft} object\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   * @throws DraftNotFoundException if the draft does not exist\n+   */\n+  public Draft getDraft(DraftId draftId) throws RuntimeException, DraftNotFoundException {\n+    return store.getDraft(draftId).orElseThrow(() -> new DraftNotFoundException(draftId));\n+  }\n+\n+  /**\n+   * Write the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @param draftStoreRequest {@link DraftStoreRequest} that contains the rest of the draft data\n+   * @throws RuntimeException when an error occurs while writing to the table\n+   */\n+  public <T extends ETLConfig> void writeDraft(DraftId draftId,\n+                                               DraftStoreRequest<T> draftStoreRequest) {\n+    // TODO(CDAP-17456): Add collision detection using the hashes\n+    store.writeDraft(draftId, draftStoreRequest);\n+\n+    // Wrap metrics in try-catch to prevent entire request from failing if metrics writing fails\n+    try {\n+      metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());\n+    } catch (Exception e) {\n+      LOG.warn(\"Failed to write {} metric on writeDraft request due to: {}\", Constants.Metrics.DRAFT_COUNT,\n+               e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Delete the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   * @throws DraftNotFoundException if the draft does not exist\n+   */\n+  public void deleteDraft(DraftId draftId) {\n+    // Make sure the draft exists before attempting to delete it\n+    getDraft(draftId);\n+    store.deleteDraft(draftId);\n+\n+    // Wrap metrics in try-catch to prevent entire request from failing if metrics writing fails\n+    try {\n+      metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());\n+    } catch (Exception e) {\n+      LOG.warn(\"Failed to write {} metric on deleteDraft request due to: {}\", Constants.Metrics.DRAFT_COUNT,\n+               e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Checks if the given field exists in the {@link DraftStore} table spec. This should be used for validation.\n+   *\n+   * @param fieldName name of the field to check\n+   * @return True if the field exists in the {@link DraftStore} table spec\n+   */\n+  public boolean fieldExists(String fieldName) {\n+    Map<String, FieldType.Type> fieldTypes = DraftStore.TABLE_SPEC\n+      .getFieldTypes()\n+      .stream()\n+      .collect(Collectors.toMap(FieldType::getName, FieldType::getType));\n+\n+    return fieldTypes.containsKey(fieldName);\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEzNDA5OA==", "bodyText": "Seems like this could be package private instead of public?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541134098", "createdAt": "2020-12-11T18:11:21Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.InvalidFieldException;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.TableNotFoundException;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import org.apache.commons.lang.NotImplementedException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEzNDczNg==", "bodyText": "You can simplify it to rowIter.forEachRemaining(temp::add)", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541134736", "createdAt": "2020-12-11T18:12:19Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.InvalidFieldException;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.TableNotFoundException;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import org.apache.commons.lang.NotImplementedException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   * @throws TableNotFoundException if the draft store table is not found\n+   * @throws InvalidFieldException if the fields Namespace and owner fields do not match the fields in the\n+   *   StructuredTable\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws TableNotFoundException, InvalidFieldException {\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    List<StructuredRow> rows;\n+    rows = TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      Range range = Range.singleton(prefix);\n+      List<StructuredRow> temp = new ArrayList<>();\n+      try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+        while (rowIter.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEzODQ4Ng==", "bodyText": "Annotate parameter with @Nullable if it can be null.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541138486", "createdAt": "2020-12-11T18:19:00Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.InvalidFieldException;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.TableNotFoundException;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import org.apache.commons.lang.NotImplementedException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   * @throws TableNotFoundException if the draft store table is not found\n+   * @throws InvalidFieldException if the fields Namespace and owner fields do not match the fields in the\n+   *   StructuredTable\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws TableNotFoundException, InvalidFieldException {\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    List<StructuredRow> rows;\n+    rows = TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      Range range = Range.singleton(prefix);\n+      List<StructuredRow> temp = new ArrayList<>();\n+      try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+        while (rowIter.hasNext()) {\n+          temp.add(rowIter.next());\n+        }\n+      }\n+      return temp;\n+    }, TableNotFoundException.class, InvalidFieldException.class);\n+\n+    List<StructuredRow> sortedResults = doSort(rows, sortRequest);\n+    return sortedResults.stream().map(this::fromRow).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Helper method to apply the sorting onto a list of rows. Sorting needs to take place at the store-level so it can\n+   * leverage the StructuredRow to enable sorting on any field.\n+   *\n+   * @param rows list of {@link StructuredRow} to be sorted\n+   * @param sortRequest {@link SortRequest} describing the sort to be performed\n+   * @return a sorted list of {@link StructuredRow}\n+   */\n+  private List<StructuredRow> doSort(List<StructuredRow> rows, SortRequest sortRequest) {\n+    if (sortRequest == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0MDIxOA==", "bodyText": "Seems overkill to create a map to just get one field. It's better to do:\nFieldType fieldType = TABLE_SPEC.getFieldTypes().stream().filter(f -> f.getName().equals(sortField)).findFirst().orElse(null);\nif (fieldType == null) {\n  throw ...\n}", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541140218", "createdAt": "2020-12-11T18:22:01Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.InvalidFieldException;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.TableNotFoundException;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import org.apache.commons.lang.NotImplementedException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   * @throws TableNotFoundException if the draft store table is not found\n+   * @throws InvalidFieldException if the fields Namespace and owner fields do not match the fields in the\n+   *   StructuredTable\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest) throws TableNotFoundException, InvalidFieldException {\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    List<StructuredRow> rows;\n+    rows = TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      Range range = Range.singleton(prefix);\n+      List<StructuredRow> temp = new ArrayList<>();\n+      try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+        while (rowIter.hasNext()) {\n+          temp.add(rowIter.next());\n+        }\n+      }\n+      return temp;\n+    }, TableNotFoundException.class, InvalidFieldException.class);\n+\n+    List<StructuredRow> sortedResults = doSort(rows, sortRequest);\n+    return sortedResults.stream().map(this::fromRow).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Helper method to apply the sorting onto a list of rows. Sorting needs to take place at the store-level so it can\n+   * leverage the StructuredRow to enable sorting on any field.\n+   *\n+   * @param rows list of {@link StructuredRow} to be sorted\n+   * @param sortRequest {@link SortRequest} describing the sort to be performed\n+   * @return a sorted list of {@link StructuredRow}\n+   */\n+  private List<StructuredRow> doSort(List<StructuredRow> rows, SortRequest sortRequest) {\n+    if (sortRequest == null) {\n+      return rows;\n+    }\n+    String sortField = sortRequest.getFieldName();\n+    Map<String, FieldType.Type> fieldTypes = TABLE_SPEC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0MjAwNQ==", "bodyText": "No need to have else after the if block return. It is cleaner to read it as:\nif (...) {\n  return;\n}\nif (...) {\n  return;\n}\nthrow new IllegalArgumentException(...);", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541142005", "createdAt": "2020-12-11T18:25:09Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/service/DraftHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.reflect.TypeToken;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.data.schema.Schema;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.api.service.http.AbstractSystemHttpServiceHandler;\n+import io.cdap.cdap.api.service.http.HttpServiceRequest;\n+import io.cdap.cdap.api.service.http.HttpServiceResponder;\n+import io.cdap.cdap.api.service.http.SystemHttpServiceContext;\n+import io.cdap.cdap.datapipeline.draft.CodedException;\n+import io.cdap.cdap.datapipeline.draft.DraftId;\n+import io.cdap.cdap.datapipeline.draft.DraftService;\n+import io.cdap.cdap.datapipeline.draft.DraftStoreRequest;\n+import io.cdap.cdap.datapipeline.draft.SortRequest;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.internal.io.SchemaTypeAdapter;\n+\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.nio.charset.StandardCharsets;\n+import javax.annotation.Nullable;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.QueryParam;\n+\n+/**\n+ * Handler of drafts\n+ */\n+public class DraftHandler extends AbstractSystemHttpServiceHandler {\n+  private static final Gson GSON = new GsonBuilder()\n+    .setPrettyPrinting()\n+    .registerTypeAdapter(Schema.class, new SchemaTypeAdapter())\n+    .create();\n+\n+  // Injected by CDAP\n+  @SuppressWarnings(\"unused\")\n+  private Metrics metrics;\n+\n+  private DraftService draftService;\n+\n+  @Override\n+  public void initialize(SystemHttpServiceContext context) throws Exception {\n+    super.initialize(context);\n+    this.draftService = new DraftService(context, this.metrics);\n+  }\n+\n+  /**\n+   * Returns a list of drafts associated with a namespace and the current user\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts\")\n+  public void listDrafts(HttpServiceRequest request, HttpServiceResponder responder,\n+                         @PathParam(\"context\") String namespaceName,\n+                         @QueryParam(\"includeConfig\") @DefaultValue(\"false\") boolean includeConfig,\n+                         @QueryParam(\"sortBy\") @DefaultValue(\"name\") String sortBy,\n+                         @QueryParam(\"sortOrder\") @DefaultValue(\"ASC\") String sortOrder,\n+                         @QueryParam(\"filter\") @Nullable String filter) {\n+\n+    respond(namespaceName, responder, (namespace) -> {\n+      if (!draftService.fieldExists(sortBy)) {\n+        throw new IllegalArgumentException(String.format(\n+          \"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\", sortBy));\n+      }\n+\n+      SortRequest sortRequest = new SortRequest(sortBy, sortOrder);\n+      responder.sendJson(draftService.listDrafts(namespace, request.getUserId(), includeConfig, sortRequest, filter));\n+    });\n+  }\n+\n+  /**\n+   * Gets the details of a draft\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void getDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                       @PathParam(\"context\") String namespaceName,\n+                       @PathParam(\"draft\") String draftId) {\n+    respond(namespaceName, responder, (namespace) -> {\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+      responder.sendJson(draftService.getDraft(id));\n+    });\n+  }\n+\n+  /**\n+   * Creates or updates a draft\n+   */\n+  @PUT\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void putDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                       @PathParam(\"context\") String namespaceName,\n+                       @PathParam(\"draft\") String draftId) {\n+\n+    respond(namespaceName, responder, (namespace) -> {\n+\n+      String requestStr = StandardCharsets.UTF_8.decode(request.getContent()).toString();\n+      DraftStoreRequest<ETLConfig> draftStoreRequest = deserializeDraftStoreRequest(requestStr);\n+\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+      draftService.writeDraft(id, draftStoreRequest);\n+\n+      responder.sendStatus(HttpURLConnection.HTTP_OK);\n+    });\n+  }\n+\n+  /**\n+   * Deletes a draft\n+   */\n+  @DELETE\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void deleteDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                          @PathParam(\"context\") String namespaceName,\n+                          @PathParam(\"draft\") String draftId) {\n+    respond(namespaceName, responder, (namespace) -> {\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+\n+      draftService.deleteDraft(id);\n+      responder.sendStatus(HttpURLConnection.HTTP_OK);\n+    });\n+  }\n+\n+  /**\n+   * Utility method to correct deserialize the config field in the {@link DraftStoreRequest} object\n+   * @param jsonStr the json string representing the DraftStoreRequest\n+   * @return {@link DraftStoreRequest} object\n+   */\n+  private DraftStoreRequest<ETLConfig> deserializeDraftStoreRequest(String jsonStr) {\n+    try {\n+      DraftStoreRequest<ETLConfig> request = GSON\n+        .fromJson(jsonStr, new TypeToken<DraftStoreRequest<ETLConfig>>() { }.getType());\n+\n+      if (request.getArtifact() == null) {\n+        throw new IllegalArgumentException(\"artifact is null\");\n+      }\n+\n+      if (StudioUtil.isBatchPipeline(request.getArtifact())) {\n+        return GSON.fromJson(jsonStr, new TypeToken<DraftStoreRequest<ETLBatchConfig>>() { }.getType());\n+      } else if (StudioUtil.isStreamingPipeline(request.getArtifact())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0MjYyMg==", "bodyText": "So this is catching the one thrown in line 164? Seems confusing. Also, generally, when wrapping an exception, always carry the origin exception as the cause, otherwise it will make the stacktrace not debuggable.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541142622", "createdAt": "2020-12-11T18:26:07Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/service/DraftHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.reflect.TypeToken;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.data.schema.Schema;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.api.service.http.AbstractSystemHttpServiceHandler;\n+import io.cdap.cdap.api.service.http.HttpServiceRequest;\n+import io.cdap.cdap.api.service.http.HttpServiceResponder;\n+import io.cdap.cdap.api.service.http.SystemHttpServiceContext;\n+import io.cdap.cdap.datapipeline.draft.CodedException;\n+import io.cdap.cdap.datapipeline.draft.DraftId;\n+import io.cdap.cdap.datapipeline.draft.DraftService;\n+import io.cdap.cdap.datapipeline.draft.DraftStoreRequest;\n+import io.cdap.cdap.datapipeline.draft.SortRequest;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.internal.io.SchemaTypeAdapter;\n+\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.nio.charset.StandardCharsets;\n+import javax.annotation.Nullable;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.QueryParam;\n+\n+/**\n+ * Handler of drafts\n+ */\n+public class DraftHandler extends AbstractSystemHttpServiceHandler {\n+  private static final Gson GSON = new GsonBuilder()\n+    .setPrettyPrinting()\n+    .registerTypeAdapter(Schema.class, new SchemaTypeAdapter())\n+    .create();\n+\n+  // Injected by CDAP\n+  @SuppressWarnings(\"unused\")\n+  private Metrics metrics;\n+\n+  private DraftService draftService;\n+\n+  @Override\n+  public void initialize(SystemHttpServiceContext context) throws Exception {\n+    super.initialize(context);\n+    this.draftService = new DraftService(context, this.metrics);\n+  }\n+\n+  /**\n+   * Returns a list of drafts associated with a namespace and the current user\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts\")\n+  public void listDrafts(HttpServiceRequest request, HttpServiceResponder responder,\n+                         @PathParam(\"context\") String namespaceName,\n+                         @QueryParam(\"includeConfig\") @DefaultValue(\"false\") boolean includeConfig,\n+                         @QueryParam(\"sortBy\") @DefaultValue(\"name\") String sortBy,\n+                         @QueryParam(\"sortOrder\") @DefaultValue(\"ASC\") String sortOrder,\n+                         @QueryParam(\"filter\") @Nullable String filter) {\n+\n+    respond(namespaceName, responder, (namespace) -> {\n+      if (!draftService.fieldExists(sortBy)) {\n+        throw new IllegalArgumentException(String.format(\n+          \"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\", sortBy));\n+      }\n+\n+      SortRequest sortRequest = new SortRequest(sortBy, sortOrder);\n+      responder.sendJson(draftService.listDrafts(namespace, request.getUserId(), includeConfig, sortRequest, filter));\n+    });\n+  }\n+\n+  /**\n+   * Gets the details of a draft\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void getDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                       @PathParam(\"context\") String namespaceName,\n+                       @PathParam(\"draft\") String draftId) {\n+    respond(namespaceName, responder, (namespace) -> {\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+      responder.sendJson(draftService.getDraft(id));\n+    });\n+  }\n+\n+  /**\n+   * Creates or updates a draft\n+   */\n+  @PUT\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void putDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                       @PathParam(\"context\") String namespaceName,\n+                       @PathParam(\"draft\") String draftId) {\n+\n+    respond(namespaceName, responder, (namespace) -> {\n+\n+      String requestStr = StandardCharsets.UTF_8.decode(request.getContent()).toString();\n+      DraftStoreRequest<ETLConfig> draftStoreRequest = deserializeDraftStoreRequest(requestStr);\n+\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+      draftService.writeDraft(id, draftStoreRequest);\n+\n+      responder.sendStatus(HttpURLConnection.HTTP_OK);\n+    });\n+  }\n+\n+  /**\n+   * Deletes a draft\n+   */\n+  @DELETE\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void deleteDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                          @PathParam(\"context\") String namespaceName,\n+                          @PathParam(\"draft\") String draftId) {\n+    respond(namespaceName, responder, (namespace) -> {\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+\n+      draftService.deleteDraft(id);\n+      responder.sendStatus(HttpURLConnection.HTTP_OK);\n+    });\n+  }\n+\n+  /**\n+   * Utility method to correct deserialize the config field in the {@link DraftStoreRequest} object\n+   * @param jsonStr the json string representing the DraftStoreRequest\n+   * @return {@link DraftStoreRequest} object\n+   */\n+  private DraftStoreRequest<ETLConfig> deserializeDraftStoreRequest(String jsonStr) {\n+    try {\n+      DraftStoreRequest<ETLConfig> request = GSON\n+        .fromJson(jsonStr, new TypeToken<DraftStoreRequest<ETLConfig>>() { }.getType());\n+\n+      if (request.getArtifact() == null) {\n+        throw new IllegalArgumentException(\"artifact is null\");\n+      }\n+\n+      if (StudioUtil.isBatchPipeline(request.getArtifact())) {\n+        return GSON.fromJson(jsonStr, new TypeToken<DraftStoreRequest<ETLBatchConfig>>() { }.getType());\n+      } else if (StudioUtil.isStreamingPipeline(request.getArtifact())) {\n+        return GSON.fromJson(jsonStr, new TypeToken<DraftStoreRequest<DataStreamsConfig>>() { }.getType());\n+      } else {\n+        throw new IllegalArgumentException(String\n+                                             .format(\"artifact '%s' is not supported, valid options are: '%s' or '%s'\",\n+                                                     request.getArtifact().getName(), StudioUtil.ARTIFACT_BATCH_NAME,\n+                                                     StudioUtil.ARTIFACT_STREAMING_NAME));\n+      }\n+    } catch (JsonSyntaxException e) {\n+      throw new IllegalArgumentException(\"Unable to decode request body: \" + e.getMessage());\n+    } catch (IllegalArgumentException e) {\n+      throw new IllegalArgumentException(\"Invalid config: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0Mjg2NQ==", "bodyText": "Seems not needed?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541142865", "createdAt": "2020-12-11T18:26:31Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/service/DraftHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.reflect.TypeToken;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.data.schema.Schema;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.api.service.http.AbstractSystemHttpServiceHandler;\n+import io.cdap.cdap.api.service.http.HttpServiceRequest;\n+import io.cdap.cdap.api.service.http.HttpServiceResponder;\n+import io.cdap.cdap.api.service.http.SystemHttpServiceContext;\n+import io.cdap.cdap.datapipeline.draft.CodedException;\n+import io.cdap.cdap.datapipeline.draft.DraftId;\n+import io.cdap.cdap.datapipeline.draft.DraftService;\n+import io.cdap.cdap.datapipeline.draft.DraftStoreRequest;\n+import io.cdap.cdap.datapipeline.draft.SortRequest;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.internal.io.SchemaTypeAdapter;\n+\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.nio.charset.StandardCharsets;\n+import javax.annotation.Nullable;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.QueryParam;\n+\n+/**\n+ * Handler of drafts\n+ */\n+public class DraftHandler extends AbstractSystemHttpServiceHandler {\n+  private static final Gson GSON = new GsonBuilder()\n+    .setPrettyPrinting()\n+    .registerTypeAdapter(Schema.class, new SchemaTypeAdapter())\n+    .create();\n+\n+  // Injected by CDAP\n+  @SuppressWarnings(\"unused\")\n+  private Metrics metrics;\n+\n+  private DraftService draftService;\n+\n+  @Override\n+  public void initialize(SystemHttpServiceContext context) throws Exception {\n+    super.initialize(context);\n+    this.draftService = new DraftService(context, this.metrics);\n+  }\n+\n+  /**\n+   * Returns a list of drafts associated with a namespace and the current user\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts\")\n+  public void listDrafts(HttpServiceRequest request, HttpServiceResponder responder,\n+                         @PathParam(\"context\") String namespaceName,\n+                         @QueryParam(\"includeConfig\") @DefaultValue(\"false\") boolean includeConfig,\n+                         @QueryParam(\"sortBy\") @DefaultValue(\"name\") String sortBy,\n+                         @QueryParam(\"sortOrder\") @DefaultValue(\"ASC\") String sortOrder,\n+                         @QueryParam(\"filter\") @Nullable String filter) {\n+\n+    respond(namespaceName, responder, (namespace) -> {\n+      if (!draftService.fieldExists(sortBy)) {\n+        throw new IllegalArgumentException(String.format(\n+          \"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\", sortBy));\n+      }\n+\n+      SortRequest sortRequest = new SortRequest(sortBy, sortOrder);\n+      responder.sendJson(draftService.listDrafts(namespace, request.getUserId(), includeConfig, sortRequest, filter));\n+    });\n+  }\n+\n+  /**\n+   * Gets the details of a draft\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void getDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                       @PathParam(\"context\") String namespaceName,\n+                       @PathParam(\"draft\") String draftId) {\n+    respond(namespaceName, responder, (namespace) -> {\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+      responder.sendJson(draftService.getDraft(id));\n+    });\n+  }\n+\n+  /**\n+   * Creates or updates a draft\n+   */\n+  @PUT\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void putDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                       @PathParam(\"context\") String namespaceName,\n+                       @PathParam(\"draft\") String draftId) {\n+\n+    respond(namespaceName, responder, (namespace) -> {\n+\n+      String requestStr = StandardCharsets.UTF_8.decode(request.getContent()).toString();\n+      DraftStoreRequest<ETLConfig> draftStoreRequest = deserializeDraftStoreRequest(requestStr);\n+\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+      draftService.writeDraft(id, draftStoreRequest);\n+\n+      responder.sendStatus(HttpURLConnection.HTTP_OK);\n+    });\n+  }\n+\n+  /**\n+   * Deletes a draft\n+   */\n+  @DELETE\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void deleteDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                          @PathParam(\"context\") String namespaceName,\n+                          @PathParam(\"draft\") String draftId) {\n+    respond(namespaceName, responder, (namespace) -> {\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+\n+      draftService.deleteDraft(id);\n+      responder.sendStatus(HttpURLConnection.HTTP_OK);\n+    });\n+  }\n+\n+  /**\n+   * Utility method to correct deserialize the config field in the {@link DraftStoreRequest} object\n+   * @param jsonStr the json string representing the DraftStoreRequest\n+   * @return {@link DraftStoreRequest} object\n+   */\n+  private DraftStoreRequest<ETLConfig> deserializeDraftStoreRequest(String jsonStr) {\n+    try {\n+      DraftStoreRequest<ETLConfig> request = GSON\n+        .fromJson(jsonStr, new TypeToken<DraftStoreRequest<ETLConfig>>() { }.getType());\n+\n+      if (request.getArtifact() == null) {\n+        throw new IllegalArgumentException(\"artifact is null\");\n+      }\n+\n+      if (StudioUtil.isBatchPipeline(request.getArtifact())) {\n+        return GSON.fromJson(jsonStr, new TypeToken<DraftStoreRequest<ETLBatchConfig>>() { }.getType());\n+      } else if (StudioUtil.isStreamingPipeline(request.getArtifact())) {\n+        return GSON.fromJson(jsonStr, new TypeToken<DraftStoreRequest<DataStreamsConfig>>() { }.getType());\n+      } else {\n+        throw new IllegalArgumentException(String\n+                                             .format(\"artifact '%s' is not supported, valid options are: '%s' or '%s'\",\n+                                                     request.getArtifact().getName(), StudioUtil.ARTIFACT_BATCH_NAME,\n+                                                     StudioUtil.ARTIFACT_STREAMING_NAME));\n+      }\n+    } catch (JsonSyntaxException e) {\n+      throw new IllegalArgumentException(\"Unable to decode request body: \" + e.getMessage());\n+    } catch (IllegalArgumentException e) {\n+      throw new IllegalArgumentException(\"Invalid config: \" + e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Utility method that checks that the namespace exists and fetches current user before responding.\n+   */\n+  private void respond(String namespaceName, HttpServiceResponder responder, NamespacedEndpoint endpoint) {\n+    SystemHttpServiceContext context = getContext();\n+    NamespaceSummary namespaceSummary;\n+    try {\n+      namespaceSummary = context.getAdmin().getNamespaceSummary(namespaceName);\n+      if (namespaceSummary == null) {\n+        responder.sendError(HttpURLConnection.HTTP_NOT_FOUND, String.format(\"Namespace '%s' not found\", namespaceName));\n+        return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0MjkwOQ==", "bodyText": "Seems not needed?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541142909", "createdAt": "2020-12-11T18:26:35Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/service/DraftHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.reflect.TypeToken;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.data.schema.Schema;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.api.service.http.AbstractSystemHttpServiceHandler;\n+import io.cdap.cdap.api.service.http.HttpServiceRequest;\n+import io.cdap.cdap.api.service.http.HttpServiceResponder;\n+import io.cdap.cdap.api.service.http.SystemHttpServiceContext;\n+import io.cdap.cdap.datapipeline.draft.CodedException;\n+import io.cdap.cdap.datapipeline.draft.DraftId;\n+import io.cdap.cdap.datapipeline.draft.DraftService;\n+import io.cdap.cdap.datapipeline.draft.DraftStoreRequest;\n+import io.cdap.cdap.datapipeline.draft.SortRequest;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.internal.io.SchemaTypeAdapter;\n+\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.nio.charset.StandardCharsets;\n+import javax.annotation.Nullable;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.QueryParam;\n+\n+/**\n+ * Handler of drafts\n+ */\n+public class DraftHandler extends AbstractSystemHttpServiceHandler {\n+  private static final Gson GSON = new GsonBuilder()\n+    .setPrettyPrinting()\n+    .registerTypeAdapter(Schema.class, new SchemaTypeAdapter())\n+    .create();\n+\n+  // Injected by CDAP\n+  @SuppressWarnings(\"unused\")\n+  private Metrics metrics;\n+\n+  private DraftService draftService;\n+\n+  @Override\n+  public void initialize(SystemHttpServiceContext context) throws Exception {\n+    super.initialize(context);\n+    this.draftService = new DraftService(context, this.metrics);\n+  }\n+\n+  /**\n+   * Returns a list of drafts associated with a namespace and the current user\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts\")\n+  public void listDrafts(HttpServiceRequest request, HttpServiceResponder responder,\n+                         @PathParam(\"context\") String namespaceName,\n+                         @QueryParam(\"includeConfig\") @DefaultValue(\"false\") boolean includeConfig,\n+                         @QueryParam(\"sortBy\") @DefaultValue(\"name\") String sortBy,\n+                         @QueryParam(\"sortOrder\") @DefaultValue(\"ASC\") String sortOrder,\n+                         @QueryParam(\"filter\") @Nullable String filter) {\n+\n+    respond(namespaceName, responder, (namespace) -> {\n+      if (!draftService.fieldExists(sortBy)) {\n+        throw new IllegalArgumentException(String.format(\n+          \"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\", sortBy));\n+      }\n+\n+      SortRequest sortRequest = new SortRequest(sortBy, sortOrder);\n+      responder.sendJson(draftService.listDrafts(namespace, request.getUserId(), includeConfig, sortRequest, filter));\n+    });\n+  }\n+\n+  /**\n+   * Gets the details of a draft\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void getDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                       @PathParam(\"context\") String namespaceName,\n+                       @PathParam(\"draft\") String draftId) {\n+    respond(namespaceName, responder, (namespace) -> {\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+      responder.sendJson(draftService.getDraft(id));\n+    });\n+  }\n+\n+  /**\n+   * Creates or updates a draft\n+   */\n+  @PUT\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void putDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                       @PathParam(\"context\") String namespaceName,\n+                       @PathParam(\"draft\") String draftId) {\n+\n+    respond(namespaceName, responder, (namespace) -> {\n+\n+      String requestStr = StandardCharsets.UTF_8.decode(request.getContent()).toString();\n+      DraftStoreRequest<ETLConfig> draftStoreRequest = deserializeDraftStoreRequest(requestStr);\n+\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+      draftService.writeDraft(id, draftStoreRequest);\n+\n+      responder.sendStatus(HttpURLConnection.HTTP_OK);\n+    });\n+  }\n+\n+  /**\n+   * Deletes a draft\n+   */\n+  @DELETE\n+  @Path(\"v1/contexts/{context}/drafts/{draft}\")\n+  public void deleteDraft(HttpServiceRequest request, HttpServiceResponder responder,\n+                          @PathParam(\"context\") String namespaceName,\n+                          @PathParam(\"draft\") String draftId) {\n+    respond(namespaceName, responder, (namespace) -> {\n+      DraftId id = new DraftId(namespace, draftId, request.getUserId());\n+\n+      draftService.deleteDraft(id);\n+      responder.sendStatus(HttpURLConnection.HTTP_OK);\n+    });\n+  }\n+\n+  /**\n+   * Utility method to correct deserialize the config field in the {@link DraftStoreRequest} object\n+   * @param jsonStr the json string representing the DraftStoreRequest\n+   * @return {@link DraftStoreRequest} object\n+   */\n+  private DraftStoreRequest<ETLConfig> deserializeDraftStoreRequest(String jsonStr) {\n+    try {\n+      DraftStoreRequest<ETLConfig> request = GSON\n+        .fromJson(jsonStr, new TypeToken<DraftStoreRequest<ETLConfig>>() { }.getType());\n+\n+      if (request.getArtifact() == null) {\n+        throw new IllegalArgumentException(\"artifact is null\");\n+      }\n+\n+      if (StudioUtil.isBatchPipeline(request.getArtifact())) {\n+        return GSON.fromJson(jsonStr, new TypeToken<DraftStoreRequest<ETLBatchConfig>>() { }.getType());\n+      } else if (StudioUtil.isStreamingPipeline(request.getArtifact())) {\n+        return GSON.fromJson(jsonStr, new TypeToken<DraftStoreRequest<DataStreamsConfig>>() { }.getType());\n+      } else {\n+        throw new IllegalArgumentException(String\n+                                             .format(\"artifact '%s' is not supported, valid options are: '%s' or '%s'\",\n+                                                     request.getArtifact().getName(), StudioUtil.ARTIFACT_BATCH_NAME,\n+                                                     StudioUtil.ARTIFACT_STREAMING_NAME));\n+      }\n+    } catch (JsonSyntaxException e) {\n+      throw new IllegalArgumentException(\"Unable to decode request body: \" + e.getMessage());\n+    } catch (IllegalArgumentException e) {\n+      throw new IllegalArgumentException(\"Invalid config: \" + e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Utility method that checks that the namespace exists and fetches current user before responding.\n+   */\n+  private void respond(String namespaceName, HttpServiceResponder responder, NamespacedEndpoint endpoint) {\n+    SystemHttpServiceContext context = getContext();\n+    NamespaceSummary namespaceSummary;\n+    try {\n+      namespaceSummary = context.getAdmin().getNamespaceSummary(namespaceName);\n+      if (namespaceSummary == null) {\n+        responder.sendError(HttpURLConnection.HTTP_NOT_FOUND, String.format(\"Namespace '%s' not found\", namespaceName));\n+        return;\n+      }\n+    } catch (IOException e) {\n+      responder.sendError(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                          String.format(\"Unable to check if namespace '%s' exists.\", namespaceName));\n+      return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0MzM1MQ==", "bodyText": "Does this pass checkstyle? I think it is has to be a space after the ). Generally do:\nprivate StudioUtil() {\n  // prevent instantiation of util class.\n}", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541143351", "createdAt": "2020-12-11T18:27:24Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/service/StudioUtil.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.service;\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Helper functions for handlers/services in {@link io.cdap.cdap.datapipeline.service.StudioService}\n+ */\n+public final class StudioUtil {\n+  public static final String ARTIFACT_BATCH_NAME = \"cdap-data-pipeline\";\n+  public static final String ARTIFACT_STREAMING_NAME = \"cdap-data-streams\";\n+\n+  private StudioUtil(){ }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0MzgxNA==", "bodyText": "Use io.cdap.cdap.common.utils.Tasks.waitFor", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541143814", "createdAt": "2020-12-11T18:28:07Z", "author": {"login": "chtyim"}, "path": "cdap-test/src/main/java/io/cdap/cdap/test/MetricsManager.java", "diffHunk": "@@ -150,6 +150,33 @@ public void waitForTotalMetricCount(Map<String, String> tags, String metricName,\n     }\n   }\n \n+  /**\n+   * waitFor a metric value count for the metric identified by metricName and context.\n+   * @param tags - context identified by tags map\n+   * @param metricName\n+   * @param count - expected metric total count value\n+   * @param timeout\n+   * @param timeoutUnit\n+   * @throws TimeoutException\n+   * @throws InterruptedException\n+   */\n+  public void waitForExactMetricCount(Map<String, String> tags, String metricName, long count, long timeout,\n+                                      TimeUnit timeoutUnit) throws TimeoutException, InterruptedException {\n+    long value = getTotalMetric(tags, metricName);\n+\n+    // Min sleep time is 10ms, max sleep time is 1 seconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMzg5Mjk0", "url": "https://github.com/cdapio/cdap/pull/12885#pullrequestreview-550389294", "createdAt": "2020-12-11T18:02:52Z", "commit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODowMjo1M1rOIED5yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODo0MTo0MVrOIEFQmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEyOTE2Mw==", "bodyText": "Could you please clarify in javadoc that it's an HTTP code?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541129163", "createdAt": "2020-12-11T18:02:53Z", "author": {"login": "tivv"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/CodedException.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+/**\n+ * An exception that contains an error code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NTIxMw==", "bodyText": "Does it make sense to have \"v1/contexts/{context}\" as a top-level @Path directive, e.g. like in DatasetInstanceHandler.\nAlso I see that usually path looks like Constants.Gateway.API_VERSION_3 + \"/namespaces/{namespace-id}. Is context a different thing? I see that its referred  as a namespace below. On the other side ValidationHandler is using \"/v1/contexts\". It would be good to have the common part extracted as a constant similar to Gateway as it would be easier to bump version when we need to.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541145213", "createdAt": "2020-12-11T18:30:28Z", "author": {"login": "tivv"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/service/DraftHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.reflect.TypeToken;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.data.schema.Schema;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.api.service.http.AbstractSystemHttpServiceHandler;\n+import io.cdap.cdap.api.service.http.HttpServiceRequest;\n+import io.cdap.cdap.api.service.http.HttpServiceResponder;\n+import io.cdap.cdap.api.service.http.SystemHttpServiceContext;\n+import io.cdap.cdap.datapipeline.draft.CodedException;\n+import io.cdap.cdap.datapipeline.draft.DraftId;\n+import io.cdap.cdap.datapipeline.draft.DraftService;\n+import io.cdap.cdap.datapipeline.draft.DraftStoreRequest;\n+import io.cdap.cdap.datapipeline.draft.SortRequest;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.internal.io.SchemaTypeAdapter;\n+\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.nio.charset.StandardCharsets;\n+import javax.annotation.Nullable;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.QueryParam;\n+\n+/**\n+ * Handler of drafts\n+ */\n+public class DraftHandler extends AbstractSystemHttpServiceHandler {\n+  private static final Gson GSON = new GsonBuilder()\n+    .setPrettyPrinting()\n+    .registerTypeAdapter(Schema.class, new SchemaTypeAdapter())\n+    .create();\n+\n+  // Injected by CDAP\n+  @SuppressWarnings(\"unused\")\n+  private Metrics metrics;\n+\n+  private DraftService draftService;\n+\n+  @Override\n+  public void initialize(SystemHttpServiceContext context) throws Exception {\n+    super.initialize(context);\n+    this.draftService = new DraftService(context, this.metrics);\n+  }\n+\n+  /**\n+   * Returns a list of drafts associated with a namespace and the current user\n+   */\n+  @GET\n+  @Path(\"v1/contexts/{context}/drafts\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE1MTM4NA==", "bodyText": "Does it make sense to put it into some common place and not inside draft? Looks like a useful abstraction.\nAnother option would be to reuse javax.ws.rs.ServerErrorException/ClientErrorException with it's Response.Status. May be we even can have a common exception handler, so that there is not need for own own code to convert it into sendError", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541151384", "createdAt": "2020-12-11T18:41:41Z", "author": {"login": "tivv"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/CodedException.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b37a09950acdfb3fce8e6d35adfc7e086b16e14"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTM3MjUz", "url": "https://github.com/cdapio/cdap/pull/12885#pullrequestreview-550537253", "createdAt": "2020-12-11T19:59:54Z", "commit": {"oid": "358e795765e4988d21706464ba009c843b94619d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTo1OTo1NVrOIEJyUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTo1OTo1NVrOIEJyUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNTU1NA==", "bodyText": "It seems the includeConfig is unused? Shouldn't you based on that to determine to have the config pass to Draft or not?", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541225554", "createdAt": "2020-12-11T19:59:55Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStore.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.gson.Gson;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+import io.cdap.cdap.api.common.Bytes;\n+import io.cdap.cdap.api.dataset.lib.CloseableIterator;\n+import io.cdap.cdap.datapipeline.service.StudioUtil;\n+import io.cdap.cdap.etl.proto.v2.DataStreamsConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLBatchConfig;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.InvalidFieldException;\n+import io.cdap.cdap.spi.data.StructuredRow;\n+import io.cdap.cdap.spi.data.StructuredTable;\n+import io.cdap.cdap.spi.data.TableNotFoundException;\n+import io.cdap.cdap.spi.data.table.StructuredTableId;\n+import io.cdap.cdap.spi.data.table.StructuredTableSpecification;\n+import io.cdap.cdap.spi.data.table.field.Field;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.table.field.Fields;\n+import io.cdap.cdap.spi.data.table.field.Range;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunners;\n+import org.apache.commons.lang.NotImplementedException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Schema for draft store.\n+ */\n+public class DraftStore {\n+  public static final StructuredTableId TABLE_ID = new StructuredTableId(\"drafts\");\n+  private static final String NAMESPACE_COL = \"namespace\";\n+  private static final String GENERATION_COL = \"generation\";\n+  private static final String OWNER_COL = \"owner\";\n+  private static final String ID_COL = \"id\";\n+  private static final String ARTIFACT_COL = \"artifact\";\n+  private static final String NAME_COL = \"name\";\n+  private static final String DESCRIPTION_COL = \"description\";\n+  private static final String CREATED_COL = \"createdTimeMillis\";\n+  private static final String UPDATED_COL = \"updatedTimeMillis\";\n+  private static final String PIPELINE_COL = \"pipeline\";\n+  private static final String REVISION_COL = \"revision\";\n+  public static final StructuredTableSpecification TABLE_SPEC = new StructuredTableSpecification.Builder()\n+    .withId(TABLE_ID)\n+    .withFields(Fields.stringType(NAMESPACE_COL),\n+                Fields.longType(GENERATION_COL),\n+                Fields.stringType(OWNER_COL),\n+                Fields.stringType(ID_COL),\n+                Fields.stringType(ARTIFACT_COL),\n+                Fields.stringType(NAME_COL),\n+                Fields.stringType(DESCRIPTION_COL),\n+                Fields.longType(CREATED_COL),\n+                Fields.longType(UPDATED_COL),\n+                Fields.stringType(PIPELINE_COL),\n+                Fields.intType(REVISION_COL))\n+    .withPrimaryKeys(NAMESPACE_COL, GENERATION_COL, OWNER_COL, ID_COL)\n+    .build();\n+  private static final Gson GSON = new Gson();\n+  private final TransactionRunner transactionRunner;\n+\n+  public DraftStore(TransactionRunner transactionRunner) {\n+    this.transactionRunner = transactionRunner;\n+  }\n+\n+  /**\n+   * @param namespace the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required.\n+   * @return a list of drafts\n+   * @throws TableNotFoundException if the draft store table is not found\n+   * @throws InvalidFieldException if the fields Namespace and owner fields do not match the fields in the\n+   *   StructuredTable\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespace, String owner,\n+                                SortRequest sortRequest,\n+                                boolean includeConfig) throws TableNotFoundException, InvalidFieldException {\n+    List<Field<?>> prefix = new ArrayList<>(3);\n+    prefix.add(Fields.stringField(NAMESPACE_COL, namespace.getName()));\n+    prefix.add(Fields.longField(GENERATION_COL, namespace.getGeneration()));\n+    prefix.add(Fields.stringField(OWNER_COL, owner));\n+\n+    List<StructuredRow> rows;\n+    rows = TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      Range range = Range.singleton(prefix);\n+      List<StructuredRow> temp = new ArrayList<>();\n+      try (CloseableIterator<StructuredRow> rowIter = table.scan(range, Integer.MAX_VALUE)) {\n+        rowIter.forEachRemaining(temp::add);\n+      }\n+      return temp;\n+    }, TableNotFoundException.class, InvalidFieldException.class);\n+\n+    List<StructuredRow> sortedResults = doSort(rows, sortRequest);\n+    return sortedResults.stream().map(row -> fromRow(row, includeConfig)).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Helper method to apply the sorting onto a list of rows. Sorting needs to take place at the store-level so it can\n+   * leverage the StructuredRow to enable sorting on any field.\n+   *\n+   * @param rows list of {@link StructuredRow} to be sorted\n+   * @param sortRequest {@link SortRequest} describing the sort to be performed\n+   * @return a sorted list of {@link StructuredRow}\n+   */\n+  private List<StructuredRow> doSort(List<StructuredRow> rows, @Nullable SortRequest sortRequest) {\n+    if (sortRequest == null) {\n+      return rows;\n+    }\n+    String sortField = sortRequest.getFieldName();\n+    FieldType field = TABLE_SPEC.getFieldTypes().stream()\n+      .filter(f -> f.getName().equals(sortField))\n+      .findFirst()\n+      .orElse(null);\n+    if (field == null) {\n+      throw new IllegalArgumentException(\n+        String\n+          .format(\"Invalid value '%s' for sortBy. This field does not exist in the Drafts table.\",\n+                  sortField));\n+    }\n+\n+    FieldType.Type fieldType = field.getType();\n+    Comparator<StructuredRow> comparator;\n+    switch (fieldType) {\n+      case STRING:\n+        comparator = Comparator.<StructuredRow, String>comparing(o -> o.getString(sortField));\n+        break;\n+      case INTEGER:\n+        comparator = Comparator.<StructuredRow, Integer>comparing(o -> o.getInteger(sortField));\n+        break;\n+      case LONG:\n+        comparator = Comparator.<StructuredRow, Long>comparing(o -> o.getLong(sortField));\n+        break;\n+      case FLOAT:\n+        comparator = Comparator.<StructuredRow, Float>comparing(o -> o.getFloat(sortField));\n+        break;\n+      case DOUBLE:\n+        comparator = Comparator.<StructuredRow, Double>comparing(o -> o.getDouble(sortField));\n+        break;\n+      case BYTES:\n+        comparator = Comparator.comparing(o -> o.getBytes(sortField), Bytes.BYTES_COMPARATOR);\n+        break;\n+      default:\n+        throw new NotImplementedException(String.format(\"Cannot sort field '%s' because type '%s' is not supported.\",\n+                                                        sortField, fieldType.toString()));\n+    }\n+\n+    if (sortRequest.getOrder() != SortRequest.SortOrder.ASC) {\n+      comparator = comparator.reversed();\n+    }\n+\n+    rows.sort(comparator);\n+\n+    return rows;\n+  }\n+\n+  /**\n+   * Fetch a given draft if it exists\n+   *\n+   * @param id {@link DraftId} that is used to uniquely identify a draft\n+   * @return an {@link Optional<Draft>} representing the requested draft\n+   * @throws TableNotFoundException if the draft store table is not found\n+   * @throws InvalidFieldException if the fields in the {@link DraftId} object do not match the fields in the\n+   *   StructuredTable\n+   */\n+  public Optional<Draft> getDraft(DraftId id) throws TableNotFoundException, InvalidFieldException {\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      Optional<StructuredRow> row = table.read(getKey(id));\n+      return row.map(this::fromRow);\n+    }, TableNotFoundException.class, InvalidFieldException.class);\n+  }\n+\n+  /**\n+   * Delete the given draft. This is a no-op if the draft does not exist\n+   *\n+   * @param id {@link DraftId} that is used to uniquely identify a draft\n+   * @throws TableNotFoundException if the draft store table is not found\n+   * @throws InvalidFieldException if the fields in the {@link Draft} object do not match the fields in the\n+   *   StructuredTable\n+   */\n+  public void deleteDraft(DraftId id) throws TableNotFoundException, InvalidFieldException {\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      table.delete(getKey(id));\n+    }, TableNotFoundException.class, InvalidFieldException.class);\n+  }\n+\n+  /**\n+   * Create/update the given draft\n+   *\n+   * @param id {@link DraftId} that is used to uniquely identify a draft\n+   * @param request {@link DraftStoreRequest} that contains the rest of the draft data\n+   * @throws TableNotFoundException if the draft store table is not found\n+   * @throws InvalidFieldException if the fields in the {@link Draft} or {@link DraftStoreRequest} objects do not\n+   *   match the fields in the StructuredTable\n+   */\n+  public <T extends ETLConfig> void writeDraft(DraftId id, DraftStoreRequest<T> request)\n+    throws TableNotFoundException, InvalidFieldException {\n+\n+    Optional<Draft> existing = getDraft(id);\n+    long now = System.currentTimeMillis();\n+    long createTime = existing.map(Draft::getCreatedTimeMillis).orElse(now);\n+\n+    Draft draft = new Draft(request.getConfig(), request.getName(), request.getDescription(), request.getArtifact(),\n+                            id.getId(), createTime, now);\n+\n+    TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      table.upsert(getRow(id, draft));\n+    }, TableNotFoundException.class, InvalidFieldException.class);\n+  }\n+\n+  /**\n+   * Returns the count of drafts in the table\n+   *\n+   * @return long value presenting the number of drafts in the table\n+   * @throws TableNotFoundException if the draft store table is not found\n+   */\n+  public long getDraftCount() throws TableNotFoundException {\n+    return TransactionRunners.run(transactionRunner, context -> {\n+      StructuredTable table = context.getTable(TABLE_ID);\n+      return table.count(Collections.singleton(Range.all()));\n+    }, TableNotFoundException.class);\n+  }\n+\n+  private void addKeyFields(DraftId id, List<Field<?>> fields) {\n+    fields.add(Fields.stringField(NAMESPACE_COL, id.getNamespace().getName()));\n+    fields.add(Fields.longField(GENERATION_COL, id.getNamespace().getGeneration()));\n+    fields.add(Fields.stringField(OWNER_COL, id.getOwner()));\n+    fields.add(Fields.stringField(ID_COL, id.getId()));\n+  }\n+\n+  private List<Field<?>> getKey(DraftId id) {\n+    List<Field<?>> keyFields = new ArrayList<>(4);\n+    addKeyFields(id, keyFields);\n+    return keyFields;\n+  }\n+\n+  private List<Field<?>> getRow(DraftId id, Draft draft) {\n+    List<Field<?>> fields = new ArrayList<>(11);\n+    addKeyFields(id, fields);\n+    fields.add(Fields.stringField(ARTIFACT_COL, GSON.toJson(draft.getArtifact())));\n+    fields.add(Fields.stringField(NAME_COL, draft.getName()));\n+    fields.add(Fields.stringField(DESCRIPTION_COL, draft.getDescription()));\n+    fields.add(Fields.longField(CREATED_COL, draft.getCreatedTimeMillis()));\n+    fields.add(Fields.longField(UPDATED_COL, draft.getUpdatedTimeMillis()));\n+    fields.add(Fields.stringField(PIPELINE_COL, GSON.toJson(draft.getConfig())));\n+    fields.add(Fields.intField(REVISION_COL, draft.getRevision()));\n+\n+    return fields;\n+  }\n+\n+  private Draft fromRow(StructuredRow row) {\n+    return fromRow(row, true);\n+  }\n+\n+  @SuppressWarnings(\"ConstantConditions\")\n+  private Draft fromRow(StructuredRow row, boolean includeConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "358e795765e4988d21706464ba009c843b94619d"}, "originalPosition": 279}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTM3NTkw", "url": "https://github.com/cdapio/cdap/pull/12885#pullrequestreview-550537590", "createdAt": "2020-12-11T20:00:25Z", "commit": {"oid": "358e795765e4988d21706464ba009c843b94619d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQyMDowMDoyNlrOIEJ0dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQyMDowMDoyNlrOIEJ0dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNjEwMA==", "bodyText": "Annotate methods with @Nullable if null can be returned (config and artifact, I believe).", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541226100", "createdAt": "2020-12-11T20:00:26Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftStoreRequest.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import io.cdap.cdap.api.artifact.ArtifactSummary;\n+\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Request to store a draft.\n+ *\n+ * @param <T> Type of config that this DraftRequest contains\n+ */\n+public class DraftStoreRequest<T> {\n+  private final String previousHash;\n+  private final String name;\n+  private final String description;\n+  private final int revision;\n+  private final ArtifactSummary artifact;\n+  private final T config;\n+\n+  public DraftStoreRequest(@Nullable T config, String previousHash, String name, String description, int revision,\n+                           @Nullable ArtifactSummary artifact) {\n+    this.config = config;\n+    this.previousHash = previousHash;\n+    this.name = name;\n+    this.description = description;\n+    this.revision = revision;\n+    this.artifact = artifact;\n+  }\n+\n+  public String getDescription() {\n+    return description;\n+  }\n+\n+  public String getName() {\n+    return name == null ? \"\" : name;\n+  }\n+\n+  public ArtifactSummary getArtifact() {\n+    return artifact;\n+  }\n+\n+  public T getConfig() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "358e795765e4988d21706464ba009c843b94619d"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTQ4NDE0", "url": "https://github.com/cdapio/cdap/pull/12885#pullrequestreview-550548414", "createdAt": "2020-12-11T20:18:23Z", "commit": {"oid": "a9a63d6e8c1752ffaa74c04119fb07f53e1df9eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQyMDoxODoyM1rOIEK4dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQyMDoxODoyM1rOIEK4dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI0MzUxMA==", "bodyText": "Use filter and find first to check instead of creating a map.", "url": "https://github.com/cdapio/cdap/pull/12885#discussion_r541243510", "createdAt": "2020-12-11T20:18:23Z", "author": {"login": "chtyim"}, "path": "cdap-app-templates/cdap-etl/cdap-data-pipeline/src/main/java/io/cdap/cdap/datapipeline/draft/DraftService.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+package io.cdap.cdap.datapipeline.draft;\n+\n+import com.google.common.base.Strings;\n+import io.cdap.cdap.api.NamespaceSummary;\n+import io.cdap.cdap.api.metrics.Metrics;\n+import io.cdap.cdap.etl.common.Constants;\n+import io.cdap.cdap.etl.proto.v2.ETLConfig;\n+import io.cdap.cdap.spi.data.table.field.FieldType;\n+import io.cdap.cdap.spi.data.transaction.TransactionRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Class to interact with the DraftStore\n+ */\n+public class DraftService {\n+  private static final Logger LOG = LoggerFactory.getLogger(DraftService.class);\n+  private final Metrics metrics;\n+  private final DraftStore store;\n+\n+  public DraftService(TransactionRunner context, @Nullable Metrics metrics) {\n+    this.store = new DraftStore(context);\n+    this.metrics = metrics;\n+    if (metrics == null) {\n+      LOG.warn(\"Metrics collector was not injected into DraftHandler\");\n+    }\n+  }\n+\n+  /**\n+   * Returns a sorted and filtered list of drafts for the given namespace and owner\n+   *\n+   * @param namespaceSummary the namespace to fetch the drafts from\n+   * @param owner the id of the owner of the drafts\n+   * @param includeConfig the returned Draft objects will not include the pipeline config if this is false\n+   * @param sortRequest The sorting that should be applied to the results, pass null if no sorting is required. Note\n+   *   that the sortField matches against the column names in the table spec found in {@link DraftStore}\n+   * @param filter string used to do case-insensitive prefix matching on the draft name\n+   * @return List of {@link Draft}\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   */\n+  public List<Draft> listDrafts(NamespaceSummary namespaceSummary, String owner,\n+                                boolean includeConfig, SortRequest sortRequest,\n+                                @Nullable String filter) {\n+    List<Draft> drafts = store.listDrafts(namespaceSummary, owner, sortRequest, includeConfig);\n+    if (!Strings.isNullOrEmpty(filter)) {\n+      drafts = drafts.stream()\n+        .filter(draft -> draft.getName().toLowerCase().startsWith(filter.toLowerCase()))\n+        .collect(Collectors.toList());\n+    }\n+    return drafts;\n+  }\n+\n+  /**\n+   * Fetch the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @return the {@link Draft} object\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   * @throws DraftNotFoundException if the draft does not exist\n+   */\n+  public Draft getDraft(DraftId draftId) throws RuntimeException, DraftNotFoundException {\n+    return store.getDraft(draftId).orElseThrow(() -> new DraftNotFoundException(draftId));\n+  }\n+\n+  /**\n+   * Write the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @param draftStoreRequest {@link DraftStoreRequest} that contains the rest of the draft data\n+   * @throws RuntimeException when an error occurs while writing to the table\n+   */\n+  public <T extends ETLConfig> void writeDraft(DraftId draftId,\n+                                               DraftStoreRequest<T> draftStoreRequest) {\n+    // TODO(CDAP-17456): Add collision detection using the hashes\n+    store.writeDraft(draftId, draftStoreRequest);\n+\n+    metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());\n+  }\n+\n+  /**\n+   * Delete the given draft\n+   *\n+   * @param draftId {@link DraftId} that is used to uniquely identify a draft\n+   * @throws RuntimeException when an error occurs while fetching from the table\n+   * @throws DraftNotFoundException if the draft does not exist\n+   */\n+  public void deleteDraft(DraftId draftId) {\n+    // Make sure the draft exists before attempting to delete it\n+    getDraft(draftId);\n+    store.deleteDraft(draftId);\n+\n+    metrics.gauge(Constants.Metrics.DRAFT_COUNT, store.getDraftCount());\n+  }\n+\n+  /**\n+   * Checks if the given field exists in the {@link DraftStore} table spec. This should be used for validation.\n+   *\n+   * @param fieldName name of the field to check\n+   * @return True if the field exists in the {@link DraftStore} table spec\n+   */\n+  public boolean fieldExists(String fieldName) {\n+    Map<String, FieldType.Type> fieldTypes = DraftStore.TABLE_SPEC\n+      .getFieldTypes()\n+      .stream()\n+      .collect(Collectors.toMap(FieldType::getName, FieldType::getType));\n+    return fieldTypes.containsKey(fieldName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9a63d6e8c1752ffaa74c04119fb07f53e1df9eb"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTUxMjAz", "url": "https://github.com/cdapio/cdap/pull/12885#pullrequestreview-550551203", "createdAt": "2020-12-11T20:21:06Z", "commit": {"oid": "a9a63d6e8c1752ffaa74c04119fb07f53e1df9eb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad38b9fb5a7b065646f4eb3dbddc3722bfdb50c8", "author": {"user": {"login": "MEseifan", "name": null}}, "url": "https://github.com/cdapio/cdap/commit/ad38b9fb5a7b065646f4eb3dbddc3722bfdb50c8", "committedDate": "2020-12-11T20:26:57Z", "message": "[CDAP-17355] Create new Drafts API to manage pipeline drafts in the backend"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a9a63d6e8c1752ffaa74c04119fb07f53e1df9eb", "author": {"user": {"login": "MEseifan", "name": null}}, "url": "https://github.com/cdapio/cdap/commit/a9a63d6e8c1752ffaa74c04119fb07f53e1df9eb", "committedDate": "2020-12-11T20:06:17Z", "message": "Addressed comments"}, "afterCommit": {"oid": "ad38b9fb5a7b065646f4eb3dbddc3722bfdb50c8", "author": {"user": {"login": "MEseifan", "name": null}}, "url": "https://github.com/cdapio/cdap/commit/ad38b9fb5a7b065646f4eb3dbddc3722bfdb50c8", "committedDate": "2020-12-11T20:26:57Z", "message": "[CDAP-17355] Create new Drafts API to manage pipeline drafts in the backend"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1390, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}