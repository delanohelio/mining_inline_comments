{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMDMxMDky", "number": 11899, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDoxNDoxOFrODjmMrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDoyMzoyNVrODjmW_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjUyNTkxOnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDoxNDoxOFrOFvfu3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDo1OTo1N1rOFvhAjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0NzI5NA==", "bodyText": "typo: Runt -> Run", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385347294", "createdAt": "2020-02-27T20:14:18Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM2ODIwNw==", "bodyText": "fixed", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385368207", "createdAt": "2020-02-27T20:59:57Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0NzI5NA=="}, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjUzMjUxOnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/scheduler/ProgramScheduleService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDoxNjozOVrOFvfzAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMTowMToxOVrOFvhDIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0ODM1NQ==", "bodyText": "when does it throw other Exceptions?", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385348355", "createdAt": "2020-02-27T20:16:39Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/scheduler/ProgramScheduleService.java", "diffHunk": "@@ -60,13 +62,48 @@\n   private final AuthorizationEnforcer authorizationEnforcer;\n   private final AuthenticationContext authenticationContext;\n   private final Scheduler scheduler;\n+  private final TimeSchedulerService timeSchedulerService;\n \n   @Inject\n   ProgramScheduleService(AuthorizationEnforcer authorizationEnforcer,\n-                         AuthenticationContext authenticationContext, Scheduler scheduler) {\n+                         AuthenticationContext authenticationContext, Scheduler scheduler,\n+                         TimeSchedulerService timeSchedulerService) {\n     this.authorizationEnforcer = authorizationEnforcer;\n     this.authenticationContext = authenticationContext;\n     this.scheduler = scheduler;\n+    this.timeSchedulerService = timeSchedulerService;\n+  }\n+\n+  /**\n+   * Get the previous run time for the program. A program may contain one or more schedules\n+   * the method returns the previous runtimes for all the schedules. This method only takes\n+   + into account schedules based on time. For schedules based on data, an empty list will\n+   + be returned.\n+   *\n+   * @param progrmaId program to fetch the previous runtime.\n+   * @return list of Scheduled runtimes for the program. Empty list if there are no schedules\n+   *         or if the program is not found\n+   * @throws SchedulerException on unforeseen error.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM2ODg2Nw==", "bodyText": "When authorization failed. It was copied from other method, and apparently the javadoc of this class is not very good.", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385368867", "createdAt": "2020-02-27T21:01:19Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/scheduler/ProgramScheduleService.java", "diffHunk": "@@ -60,13 +62,48 @@\n   private final AuthorizationEnforcer authorizationEnforcer;\n   private final AuthenticationContext authenticationContext;\n   private final Scheduler scheduler;\n+  private final TimeSchedulerService timeSchedulerService;\n \n   @Inject\n   ProgramScheduleService(AuthorizationEnforcer authorizationEnforcer,\n-                         AuthenticationContext authenticationContext, Scheduler scheduler) {\n+                         AuthenticationContext authenticationContext, Scheduler scheduler,\n+                         TimeSchedulerService timeSchedulerService) {\n     this.authorizationEnforcer = authorizationEnforcer;\n     this.authenticationContext = authenticationContext;\n     this.scheduler = scheduler;\n+    this.timeSchedulerService = timeSchedulerService;\n+  }\n+\n+  /**\n+   * Get the previous run time for the program. A program may contain one or more schedules\n+   * the method returns the previous runtimes for all the schedules. This method only takes\n+   + into account schedules based on time. For schedules based on data, an empty list will\n+   + be returned.\n+   *\n+   * @param progrmaId program to fetch the previous runtime.\n+   * @return list of Scheduled runtimes for the program. Empty list if there are no schedules\n+   *         or if the program is not found\n+   * @throws SchedulerException on unforeseen error.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0ODM1NQ=="}, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjUzNDEzOnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/scheduler/ProgramScheduleService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDoxNzoxMFrOFvfz8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMTowMTo0MVrOFvhD6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0ODU5Mg==", "bodyText": "when does it throw other Exceptions?", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385348592", "createdAt": "2020-02-27T20:17:10Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/scheduler/ProgramScheduleService.java", "diffHunk": "@@ -60,13 +62,48 @@\n   private final AuthorizationEnforcer authorizationEnforcer;\n   private final AuthenticationContext authenticationContext;\n   private final Scheduler scheduler;\n+  private final TimeSchedulerService timeSchedulerService;\n \n   @Inject\n   ProgramScheduleService(AuthorizationEnforcer authorizationEnforcer,\n-                         AuthenticationContext authenticationContext, Scheduler scheduler) {\n+                         AuthenticationContext authenticationContext, Scheduler scheduler,\n+                         TimeSchedulerService timeSchedulerService) {\n     this.authorizationEnforcer = authorizationEnforcer;\n     this.authenticationContext = authenticationContext;\n     this.scheduler = scheduler;\n+    this.timeSchedulerService = timeSchedulerService;\n+  }\n+\n+  /**\n+   * Get the previous run time for the program. A program may contain one or more schedules\n+   * the method returns the previous runtimes for all the schedules. This method only takes\n+   + into account schedules based on time. For schedules based on data, an empty list will\n+   + be returned.\n+   *\n+   * @param progrmaId program to fetch the previous runtime.\n+   * @return list of Scheduled runtimes for the program. Empty list if there are no schedules\n+   *         or if the program is not found\n+   * @throws SchedulerException on unforeseen error.\n+   */\n+  public List<ScheduledRuntime> getPreviousScheduledRuntimes(ProgramId progrmaId) throws Exception {\n+    AuthorizationUtil.ensureAccess(progrmaId, authorizationEnforcer, authenticationContext.getPrincipal());\n+    return timeSchedulerService.previousScheduledRuntime(progrmaId);\n+  }\n+\n+  /**\n+   * Get the next scheduled run time of the program. A program may contain multiple schedules.\n+   * This method returns the next scheduled runtimes for all the schedules. This method only takes\n+   + into account schedules based on time. For schedules based on data, an empty list will\n+   + be returned.\n+   *\n+   * @param programId program to fetch the next runtime.\n+   * @return list of scheduled runtimes for the program. Empty list if there are no schedules\n+   *         or if the program is not found\n+   * @throws SchedulerException on unforeseen error.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM2OTA2NQ==", "bodyText": "fixed", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385369065", "createdAt": "2020-02-27T21:01:41Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/scheduler/ProgramScheduleService.java", "diffHunk": "@@ -60,13 +62,48 @@\n   private final AuthorizationEnforcer authorizationEnforcer;\n   private final AuthenticationContext authenticationContext;\n   private final Scheduler scheduler;\n+  private final TimeSchedulerService timeSchedulerService;\n \n   @Inject\n   ProgramScheduleService(AuthorizationEnforcer authorizationEnforcer,\n-                         AuthenticationContext authenticationContext, Scheduler scheduler) {\n+                         AuthenticationContext authenticationContext, Scheduler scheduler,\n+                         TimeSchedulerService timeSchedulerService) {\n     this.authorizationEnforcer = authorizationEnforcer;\n     this.authenticationContext = authenticationContext;\n     this.scheduler = scheduler;\n+    this.timeSchedulerService = timeSchedulerService;\n+  }\n+\n+  /**\n+   * Get the previous run time for the program. A program may contain one or more schedules\n+   * the method returns the previous runtimes for all the schedules. This method only takes\n+   + into account schedules based on time. For schedules based on data, an empty list will\n+   + be returned.\n+   *\n+   * @param progrmaId program to fetch the previous runtime.\n+   * @return list of Scheduled runtimes for the program. Empty list if there are no schedules\n+   *         or if the program is not found\n+   * @throws SchedulerException on unforeseen error.\n+   */\n+  public List<ScheduledRuntime> getPreviousScheduledRuntimes(ProgramId progrmaId) throws Exception {\n+    AuthorizationUtil.ensureAccess(progrmaId, authorizationEnforcer, authenticationContext.getPrincipal());\n+    return timeSchedulerService.previousScheduledRuntime(progrmaId);\n+  }\n+\n+  /**\n+   * Get the next scheduled run time of the program. A program may contain multiple schedules.\n+   * This method returns the next scheduled runtimes for all the schedules. This method only takes\n+   + into account schedules based on time. For schedules based on data, an empty list will\n+   + be returned.\n+   *\n+   * @param programId program to fetch the next runtime.\n+   * @return list of scheduled runtimes for the program. Empty list if there are no schedules\n+   *         or if the program is not found\n+   * @throws SchedulerException on unforeseen error.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0ODU5Mg=="}, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjU1MDI1OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDoyMjozOFrOFvf91g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMTowMjoyMVrOFvhFEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MTEyNg==", "bodyText": "not from this PR, but it's kind of misleading to have this method in Store, as it reads like this would be performing some I/O.", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385351126", "createdAt": "2020-02-27T20:22:38Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,\n+                                      boolean previousRuntimeRequested) throws Exception {\n+    try {\n+      lifecycleService.ensureProgramExists(programId);\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(getScheduledRunTimes(programId, previousRuntimeRequested)));\n+    } catch (SecurityException e) {\n+      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n+    }\n+  }\n+\n+  /**\n+   * Returns the previous scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/previousruntime\")\n+  public void batchPreviousRunTimes(FullHttpRequest request,\n+                                    HttpResponder responder,\n+                                    @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, true)));\n+  }\n+\n+  /**\n+   * Returns the next scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/nextruntime\")\n+  public void batchNextRunTimes(FullHttpRequest request,\n+                                HttpResponder responder,\n+                                @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, false)));\n+  }\n+\n+  /**\n+   * Fetches scheduled run times for a set of programs.\n+   *\n+   * @param namespace namespace of the programs\n+   * @param programs the list of programs to fetch scheduled run times\n+   * @param previous {@code true} to get the previous scheduled times; {@code false} to get the next scheduled times\n+   * @return a list of {@link BatchProgramSchedule} containing the result\n+   * @throws SchedulerException if failed to fetch schedules\n+   */\n+  private List<BatchProgramSchedule> batchRunTimes(String namespace, Collection<? extends BatchProgram> programs,\n+                                                   boolean previous) throws Exception {\n+    List<ProgramId> programIds = programs.stream()\n+      .map(p -> new ProgramId(namespace, p.getAppId(), p.getProgramType(), p.getProgramId()))\n+      .collect(Collectors.toList());\n+\n+    Set<ApplicationId> appIds = programIds.stream().map(ProgramId::getParent).collect(Collectors.toSet());\n+    Map<ApplicationId, ApplicationSpecification> appSpecs = store.getApplications(appIds);\n+\n+    List<BatchProgramSchedule> result = new ArrayList<>();\n+    for (ProgramId programId : programIds) {\n+      ApplicationSpecification spec = appSpecs.get(programId.getParent());\n+      if (spec == null) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(),\n+                                            new NotFoundException(programId.getParent()).getMessage(), null));\n+        continue;\n+      }\n+      try {\n+        Store.ensureProgramExists(programId, spec);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM2OTM2Mw==", "bodyText": "Agree. it is a static method on the Store interface.", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385369363", "createdAt": "2020-02-27T21:02:21Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,\n+                                      boolean previousRuntimeRequested) throws Exception {\n+    try {\n+      lifecycleService.ensureProgramExists(programId);\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(getScheduledRunTimes(programId, previousRuntimeRequested)));\n+    } catch (SecurityException e) {\n+      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n+    }\n+  }\n+\n+  /**\n+   * Returns the previous scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/previousruntime\")\n+  public void batchPreviousRunTimes(FullHttpRequest request,\n+                                    HttpResponder responder,\n+                                    @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, true)));\n+  }\n+\n+  /**\n+   * Returns the next scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/nextruntime\")\n+  public void batchNextRunTimes(FullHttpRequest request,\n+                                HttpResponder responder,\n+                                @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, false)));\n+  }\n+\n+  /**\n+   * Fetches scheduled run times for a set of programs.\n+   *\n+   * @param namespace namespace of the programs\n+   * @param programs the list of programs to fetch scheduled run times\n+   * @param previous {@code true} to get the previous scheduled times; {@code false} to get the next scheduled times\n+   * @return a list of {@link BatchProgramSchedule} containing the result\n+   * @throws SchedulerException if failed to fetch schedules\n+   */\n+  private List<BatchProgramSchedule> batchRunTimes(String namespace, Collection<? extends BatchProgram> programs,\n+                                                   boolean previous) throws Exception {\n+    List<ProgramId> programIds = programs.stream()\n+      .map(p -> new ProgramId(namespace, p.getAppId(), p.getProgramType(), p.getProgramId()))\n+      .collect(Collectors.toList());\n+\n+    Set<ApplicationId> appIds = programIds.stream().map(ProgramId::getParent).collect(Collectors.toSet());\n+    Map<ApplicationId, ApplicationSpecification> appSpecs = store.getApplications(appIds);\n+\n+    List<BatchProgramSchedule> result = new ArrayList<>();\n+    for (ProgramId programId : programIds) {\n+      ApplicationSpecification spec = appSpecs.get(programId.getParent());\n+      if (spec == null) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(),\n+                                            new NotFoundException(programId.getParent()).getMessage(), null));\n+        continue;\n+      }\n+      try {\n+        Store.ensureProgramExists(programId, spec);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MTEyNg=="}, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjU1MjI4OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDoyMzoyNVrOFvf_Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMTowNDowN1rOFvhIUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MTQ3OA==", "bodyText": "doesn't look like Store.ensureProgramExists throws this, should it be throwing NotFound instead of IllegalArgument?", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385351478", "createdAt": "2020-02-27T20:23:25Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,\n+                                      boolean previousRuntimeRequested) throws Exception {\n+    try {\n+      lifecycleService.ensureProgramExists(programId);\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(getScheduledRunTimes(programId, previousRuntimeRequested)));\n+    } catch (SecurityException e) {\n+      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n+    }\n+  }\n+\n+  /**\n+   * Returns the previous scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/previousruntime\")\n+  public void batchPreviousRunTimes(FullHttpRequest request,\n+                                    HttpResponder responder,\n+                                    @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, true)));\n+  }\n+\n+  /**\n+   * Returns the next scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/nextruntime\")\n+  public void batchNextRunTimes(FullHttpRequest request,\n+                                HttpResponder responder,\n+                                @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, false)));\n+  }\n+\n+  /**\n+   * Fetches scheduled run times for a set of programs.\n+   *\n+   * @param namespace namespace of the programs\n+   * @param programs the list of programs to fetch scheduled run times\n+   * @param previous {@code true} to get the previous scheduled times; {@code false} to get the next scheduled times\n+   * @return a list of {@link BatchProgramSchedule} containing the result\n+   * @throws SchedulerException if failed to fetch schedules\n+   */\n+  private List<BatchProgramSchedule> batchRunTimes(String namespace, Collection<? extends BatchProgram> programs,\n+                                                   boolean previous) throws Exception {\n+    List<ProgramId> programIds = programs.stream()\n+      .map(p -> new ProgramId(namespace, p.getAppId(), p.getProgramType(), p.getProgramId()))\n+      .collect(Collectors.toList());\n+\n+    Set<ApplicationId> appIds = programIds.stream().map(ProgramId::getParent).collect(Collectors.toSet());\n+    Map<ApplicationId, ApplicationSpecification> appSpecs = store.getApplications(appIds);\n+\n+    List<BatchProgramSchedule> result = new ArrayList<>();\n+    for (ProgramId programId : programIds) {\n+      ApplicationSpecification spec = appSpecs.get(programId.getParent());\n+      if (spec == null) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(),\n+                                            new NotFoundException(programId.getParent()).getMessage(), null));\n+        continue;\n+      }\n+      try {\n+        Store.ensureProgramExists(programId, spec);\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.OK.code(), null,\n+                                            getScheduledRunTimes(programId, previous)));\n+      } catch (NotFoundException e) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(), e.getMessage(), null));\n+      } catch (BadRequestException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MjIwMw==", "bodyText": "oh this gets thrown from getScheduledRunTimes. But it seems like IllegalArgument should still be fixed in ensureProgramExists()", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385352203", "createdAt": "2020-02-27T20:25:03Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,\n+                                      boolean previousRuntimeRequested) throws Exception {\n+    try {\n+      lifecycleService.ensureProgramExists(programId);\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(getScheduledRunTimes(programId, previousRuntimeRequested)));\n+    } catch (SecurityException e) {\n+      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n+    }\n+  }\n+\n+  /**\n+   * Returns the previous scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/previousruntime\")\n+  public void batchPreviousRunTimes(FullHttpRequest request,\n+                                    HttpResponder responder,\n+                                    @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, true)));\n+  }\n+\n+  /**\n+   * Returns the next scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/nextruntime\")\n+  public void batchNextRunTimes(FullHttpRequest request,\n+                                HttpResponder responder,\n+                                @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, false)));\n+  }\n+\n+  /**\n+   * Fetches scheduled run times for a set of programs.\n+   *\n+   * @param namespace namespace of the programs\n+   * @param programs the list of programs to fetch scheduled run times\n+   * @param previous {@code true} to get the previous scheduled times; {@code false} to get the next scheduled times\n+   * @return a list of {@link BatchProgramSchedule} containing the result\n+   * @throws SchedulerException if failed to fetch schedules\n+   */\n+  private List<BatchProgramSchedule> batchRunTimes(String namespace, Collection<? extends BatchProgram> programs,\n+                                                   boolean previous) throws Exception {\n+    List<ProgramId> programIds = programs.stream()\n+      .map(p -> new ProgramId(namespace, p.getAppId(), p.getProgramType(), p.getProgramId()))\n+      .collect(Collectors.toList());\n+\n+    Set<ApplicationId> appIds = programIds.stream().map(ProgramId::getParent).collect(Collectors.toSet());\n+    Map<ApplicationId, ApplicationSpecification> appSpecs = store.getApplications(appIds);\n+\n+    List<BatchProgramSchedule> result = new ArrayList<>();\n+    for (ProgramId programId : programIds) {\n+      ApplicationSpecification spec = appSpecs.get(programId.getParent());\n+      if (spec == null) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(),\n+                                            new NotFoundException(programId.getParent()).getMessage(), null));\n+        continue;\n+      }\n+      try {\n+        Store.ensureProgramExists(programId, spec);\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.OK.code(), null,\n+                                            getScheduledRunTimes(programId, previous)));\n+      } catch (NotFoundException e) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(), e.getMessage(), null));\n+      } catch (BadRequestException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MTQ3OA=="}, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM3MDE5Mw==", "bodyText": "The IllegalArgumentException should never happen though, since the appSpec was coming from fetching the app of the program id. The implementation of the ensureProgramExists is more to guard against misuse (bug) in the call, which can't be raised in normal case.", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385370193", "createdAt": "2020-02-27T21:04:07Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,\n+                                      boolean previousRuntimeRequested) throws Exception {\n+    try {\n+      lifecycleService.ensureProgramExists(programId);\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(getScheduledRunTimes(programId, previousRuntimeRequested)));\n+    } catch (SecurityException e) {\n+      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n+    }\n+  }\n+\n+  /**\n+   * Returns the previous scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/previousruntime\")\n+  public void batchPreviousRunTimes(FullHttpRequest request,\n+                                    HttpResponder responder,\n+                                    @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, true)));\n+  }\n+\n+  /**\n+   * Returns the next scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/nextruntime\")\n+  public void batchNextRunTimes(FullHttpRequest request,\n+                                HttpResponder responder,\n+                                @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, false)));\n+  }\n+\n+  /**\n+   * Fetches scheduled run times for a set of programs.\n+   *\n+   * @param namespace namespace of the programs\n+   * @param programs the list of programs to fetch scheduled run times\n+   * @param previous {@code true} to get the previous scheduled times; {@code false} to get the next scheduled times\n+   * @return a list of {@link BatchProgramSchedule} containing the result\n+   * @throws SchedulerException if failed to fetch schedules\n+   */\n+  private List<BatchProgramSchedule> batchRunTimes(String namespace, Collection<? extends BatchProgram> programs,\n+                                                   boolean previous) throws Exception {\n+    List<ProgramId> programIds = programs.stream()\n+      .map(p -> new ProgramId(namespace, p.getAppId(), p.getProgramType(), p.getProgramId()))\n+      .collect(Collectors.toList());\n+\n+    Set<ApplicationId> appIds = programIds.stream().map(ProgramId::getParent).collect(Collectors.toSet());\n+    Map<ApplicationId, ApplicationSpecification> appSpecs = store.getApplications(appIds);\n+\n+    List<BatchProgramSchedule> result = new ArrayList<>();\n+    for (ProgramId programId : programIds) {\n+      ApplicationSpecification spec = appSpecs.get(programId.getParent());\n+      if (spec == null) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(),\n+                                            new NotFoundException(programId.getParent()).getMessage(), null));\n+        continue;\n+      }\n+      try {\n+        Store.ensureProgramExists(programId, spec);\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.OK.code(), null,\n+                                            getScheduledRunTimes(programId, previous)));\n+      } catch (NotFoundException e) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(), e.getMessage(), null));\n+      } catch (BadRequestException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MTQ3OA=="}, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 242}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2973, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}