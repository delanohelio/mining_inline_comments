{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMDMxMDky", "number": 11899, "title": "(CDAP-16339) Added batch next run time endpoint", "bodyText": "Also fixed bunch of authorization and handler issues\n-- Http handler shouldn't be inherited", "createdAt": "2020-02-27T19:30:39Z", "url": "https://github.com/cdapio/cdap/pull/11899", "merged": true, "mergeCommit": {"oid": "f10b55a9cce7c740f773b09a1d551afc6bed6dfc"}, "closed": true, "closedAt": "2020-02-28T01:18:48Z", "author": {"login": "chtyim"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIhVbegFqTM2NTk2NjgxOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIlVItgBqjMwODAwNzU5Nzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1OTY2ODE4", "url": "https://github.com/cdapio/cdap/pull/11899#pullrequestreview-365966818", "createdAt": "2020-02-27T20:14:18Z", "commit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDoxNDoxOFrOFvfu3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDoyNTowM1rOFvgCCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0NzI5NA==", "bodyText": "typo: Runt -> Run", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385347294", "createdAt": "2020-02-27T20:14:18Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0ODM1NQ==", "bodyText": "when does it throw other Exceptions?", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385348355", "createdAt": "2020-02-27T20:16:39Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/scheduler/ProgramScheduleService.java", "diffHunk": "@@ -60,13 +62,48 @@\n   private final AuthorizationEnforcer authorizationEnforcer;\n   private final AuthenticationContext authenticationContext;\n   private final Scheduler scheduler;\n+  private final TimeSchedulerService timeSchedulerService;\n \n   @Inject\n   ProgramScheduleService(AuthorizationEnforcer authorizationEnforcer,\n-                         AuthenticationContext authenticationContext, Scheduler scheduler) {\n+                         AuthenticationContext authenticationContext, Scheduler scheduler,\n+                         TimeSchedulerService timeSchedulerService) {\n     this.authorizationEnforcer = authorizationEnforcer;\n     this.authenticationContext = authenticationContext;\n     this.scheduler = scheduler;\n+    this.timeSchedulerService = timeSchedulerService;\n+  }\n+\n+  /**\n+   * Get the previous run time for the program. A program may contain one or more schedules\n+   * the method returns the previous runtimes for all the schedules. This method only takes\n+   + into account schedules based on time. For schedules based on data, an empty list will\n+   + be returned.\n+   *\n+   * @param progrmaId program to fetch the previous runtime.\n+   * @return list of Scheduled runtimes for the program. Empty list if there are no schedules\n+   *         or if the program is not found\n+   * @throws SchedulerException on unforeseen error.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0ODU5Mg==", "bodyText": "when does it throw other Exceptions?", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385348592", "createdAt": "2020-02-27T20:17:10Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/scheduler/ProgramScheduleService.java", "diffHunk": "@@ -60,13 +62,48 @@\n   private final AuthorizationEnforcer authorizationEnforcer;\n   private final AuthenticationContext authenticationContext;\n   private final Scheduler scheduler;\n+  private final TimeSchedulerService timeSchedulerService;\n \n   @Inject\n   ProgramScheduleService(AuthorizationEnforcer authorizationEnforcer,\n-                         AuthenticationContext authenticationContext, Scheduler scheduler) {\n+                         AuthenticationContext authenticationContext, Scheduler scheduler,\n+                         TimeSchedulerService timeSchedulerService) {\n     this.authorizationEnforcer = authorizationEnforcer;\n     this.authenticationContext = authenticationContext;\n     this.scheduler = scheduler;\n+    this.timeSchedulerService = timeSchedulerService;\n+  }\n+\n+  /**\n+   * Get the previous run time for the program. A program may contain one or more schedules\n+   * the method returns the previous runtimes for all the schedules. This method only takes\n+   + into account schedules based on time. For schedules based on data, an empty list will\n+   + be returned.\n+   *\n+   * @param progrmaId program to fetch the previous runtime.\n+   * @return list of Scheduled runtimes for the program. Empty list if there are no schedules\n+   *         or if the program is not found\n+   * @throws SchedulerException on unforeseen error.\n+   */\n+  public List<ScheduledRuntime> getPreviousScheduledRuntimes(ProgramId progrmaId) throws Exception {\n+    AuthorizationUtil.ensureAccess(progrmaId, authorizationEnforcer, authenticationContext.getPrincipal());\n+    return timeSchedulerService.previousScheduledRuntime(progrmaId);\n+  }\n+\n+  /**\n+   * Get the next scheduled run time of the program. A program may contain multiple schedules.\n+   * This method returns the next scheduled runtimes for all the schedules. This method only takes\n+   + into account schedules based on time. For schedules based on data, an empty list will\n+   + be returned.\n+   *\n+   * @param programId program to fetch the next runtime.\n+   * @return list of scheduled runtimes for the program. Empty list if there are no schedules\n+   *         or if the program is not found\n+   * @throws SchedulerException on unforeseen error.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MTEyNg==", "bodyText": "not from this PR, but it's kind of misleading to have this method in Store, as it reads like this would be performing some I/O.", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385351126", "createdAt": "2020-02-27T20:22:38Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,\n+                                      boolean previousRuntimeRequested) throws Exception {\n+    try {\n+      lifecycleService.ensureProgramExists(programId);\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(getScheduledRunTimes(programId, previousRuntimeRequested)));\n+    } catch (SecurityException e) {\n+      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n+    }\n+  }\n+\n+  /**\n+   * Returns the previous scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/previousruntime\")\n+  public void batchPreviousRunTimes(FullHttpRequest request,\n+                                    HttpResponder responder,\n+                                    @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, true)));\n+  }\n+\n+  /**\n+   * Returns the next scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/nextruntime\")\n+  public void batchNextRunTimes(FullHttpRequest request,\n+                                HttpResponder responder,\n+                                @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, false)));\n+  }\n+\n+  /**\n+   * Fetches scheduled run times for a set of programs.\n+   *\n+   * @param namespace namespace of the programs\n+   * @param programs the list of programs to fetch scheduled run times\n+   * @param previous {@code true} to get the previous scheduled times; {@code false} to get the next scheduled times\n+   * @return a list of {@link BatchProgramSchedule} containing the result\n+   * @throws SchedulerException if failed to fetch schedules\n+   */\n+  private List<BatchProgramSchedule> batchRunTimes(String namespace, Collection<? extends BatchProgram> programs,\n+                                                   boolean previous) throws Exception {\n+    List<ProgramId> programIds = programs.stream()\n+      .map(p -> new ProgramId(namespace, p.getAppId(), p.getProgramType(), p.getProgramId()))\n+      .collect(Collectors.toList());\n+\n+    Set<ApplicationId> appIds = programIds.stream().map(ProgramId::getParent).collect(Collectors.toSet());\n+    Map<ApplicationId, ApplicationSpecification> appSpecs = store.getApplications(appIds);\n+\n+    List<BatchProgramSchedule> result = new ArrayList<>();\n+    for (ProgramId programId : programIds) {\n+      ApplicationSpecification spec = appSpecs.get(programId.getParent());\n+      if (spec == null) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(),\n+                                            new NotFoundException(programId.getParent()).getMessage(), null));\n+        continue;\n+      }\n+      try {\n+        Store.ensureProgramExists(programId, spec);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MTQ3OA==", "bodyText": "doesn't look like Store.ensureProgramExists throws this, should it be throwing NotFound instead of IllegalArgument?", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385351478", "createdAt": "2020-02-27T20:23:25Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,\n+                                      boolean previousRuntimeRequested) throws Exception {\n+    try {\n+      lifecycleService.ensureProgramExists(programId);\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(getScheduledRunTimes(programId, previousRuntimeRequested)));\n+    } catch (SecurityException e) {\n+      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n+    }\n+  }\n+\n+  /**\n+   * Returns the previous scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/previousruntime\")\n+  public void batchPreviousRunTimes(FullHttpRequest request,\n+                                    HttpResponder responder,\n+                                    @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, true)));\n+  }\n+\n+  /**\n+   * Returns the next scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/nextruntime\")\n+  public void batchNextRunTimes(FullHttpRequest request,\n+                                HttpResponder responder,\n+                                @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, false)));\n+  }\n+\n+  /**\n+   * Fetches scheduled run times for a set of programs.\n+   *\n+   * @param namespace namespace of the programs\n+   * @param programs the list of programs to fetch scheduled run times\n+   * @param previous {@code true} to get the previous scheduled times; {@code false} to get the next scheduled times\n+   * @return a list of {@link BatchProgramSchedule} containing the result\n+   * @throws SchedulerException if failed to fetch schedules\n+   */\n+  private List<BatchProgramSchedule> batchRunTimes(String namespace, Collection<? extends BatchProgram> programs,\n+                                                   boolean previous) throws Exception {\n+    List<ProgramId> programIds = programs.stream()\n+      .map(p -> new ProgramId(namespace, p.getAppId(), p.getProgramType(), p.getProgramId()))\n+      .collect(Collectors.toList());\n+\n+    Set<ApplicationId> appIds = programIds.stream().map(ProgramId::getParent).collect(Collectors.toSet());\n+    Map<ApplicationId, ApplicationSpecification> appSpecs = store.getApplications(appIds);\n+\n+    List<BatchProgramSchedule> result = new ArrayList<>();\n+    for (ProgramId programId : programIds) {\n+      ApplicationSpecification spec = appSpecs.get(programId.getParent());\n+      if (spec == null) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(),\n+                                            new NotFoundException(programId.getParent()).getMessage(), null));\n+        continue;\n+      }\n+      try {\n+        Store.ensureProgramExists(programId, spec);\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.OK.code(), null,\n+                                            getScheduledRunTimes(programId, previous)));\n+      } catch (NotFoundException e) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(), e.getMessage(), null));\n+      } catch (BadRequestException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MjIwMw==", "bodyText": "oh this gets thrown from getScheduledRunTimes. But it seems like IllegalArgument should still be fixed in ensureProgramExists()", "url": "https://github.com/cdapio/cdap/pull/11899#discussion_r385352203", "createdAt": "2020-02-27T20:25:03Z", "author": {"login": "albertshau"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/gateway/handlers/ProgramLifecycleHttpHandler.java", "diffHunk": "@@ -776,6 +817,161 @@ protected void doGetSchedules(HttpResponder responder, ApplicationId application\n     responder.sendJson(HttpResponseStatus.OK, GSON.toJson(details, Schedulers.SCHEDULE_DETAILS_TYPE));\n   }\n \n+  /**\n+   * Returns the previous runtime when the scheduled program ran.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/previousruntime\")\n+  public void getPreviousScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                          @PathParam(\"namespace-id\") String namespaceId,\n+                                          @PathParam(\"app-name\") String appId,\n+                                          @PathParam(\"program-type\") String type,\n+                                          @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), true);\n+  }\n+\n+  /**\n+   * Returns next scheduled runtime of a workflow.\n+   */\n+  @GET\n+  @Path(\"/apps/{app-name}/{program-type}/{program-name}/nextruntime\")\n+  public void getNextScheduledRunTime(HttpRequest request, HttpResponder responder,\n+                                      @PathParam(\"namespace-id\") String namespaceId,\n+                                      @PathParam(\"app-name\") String appId,\n+                                      @PathParam(\"program-type\") String type,\n+                                      @PathParam(\"program-name\") String program) throws Exception {\n+    ProgramType programType = getProgramType(type);\n+    handleScheduleRuntTime(responder, new NamespaceId(namespaceId).app(appId).program(programType, program), false);\n+  }\n+\n+  private void handleScheduleRuntTime(HttpResponder responder, ProgramId programId,\n+                                      boolean previousRuntimeRequested) throws Exception {\n+    try {\n+      lifecycleService.ensureProgramExists(programId);\n+      responder.sendJson(HttpResponseStatus.OK, GSON.toJson(getScheduledRunTimes(programId, previousRuntimeRequested)));\n+    } catch (SecurityException e) {\n+      responder.sendStatus(HttpResponseStatus.UNAUTHORIZED);\n+    }\n+  }\n+\n+  /**\n+   * Returns the previous scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/previousruntime\")\n+  public void batchPreviousRunTimes(FullHttpRequest request,\n+                                    HttpResponder responder,\n+                                    @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, true)));\n+  }\n+\n+  /**\n+   * Returns the next scheduled run time for all programs that are passed into the data.\n+   * The data is an array of JSON objects\n+   * where each object must contain the following three elements: appId, programType, and programId\n+   * (flow name, service name, etc.).\n+   * <p>\n+   * Example input:\n+   * <pre><code>\n+   * [{\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF1\"},\n+   * {\"appId\": \"App1\", \"programType\": \"Workflow\", \"programId\": \"WF2\"}]\n+   * </code></pre>\n+   * </p><p>\n+   * The response will be an array of JsonObjects each of which will contain the three input parameters\n+   * as well as a \"schedules\" field, which is a list of {@link ScheduledRuntime} object.\n+   * </p><p>\n+   * If an error occurs in the input (for the example above, App1 does not exist), then all JsonObjects for which the\n+   * parameters have a valid status will have the status field but all JsonObjects for which the parameters do not have\n+   * a valid status will have an error message and statusCode.\n+   */\n+  @POST\n+  @Path(\"/nextruntime\")\n+  public void batchNextRunTimes(FullHttpRequest request,\n+                                HttpResponder responder,\n+                                @PathParam(\"namespace-id\") String namespaceId) throws Exception {\n+    List<BatchProgram> batchPrograms = validateAndGetBatchInput(request, BATCH_PROGRAMS_TYPE);\n+    responder.sendJson(HttpResponseStatus.OK, GSON.toJson(batchRunTimes(namespaceId, batchPrograms, false)));\n+  }\n+\n+  /**\n+   * Fetches scheduled run times for a set of programs.\n+   *\n+   * @param namespace namespace of the programs\n+   * @param programs the list of programs to fetch scheduled run times\n+   * @param previous {@code true} to get the previous scheduled times; {@code false} to get the next scheduled times\n+   * @return a list of {@link BatchProgramSchedule} containing the result\n+   * @throws SchedulerException if failed to fetch schedules\n+   */\n+  private List<BatchProgramSchedule> batchRunTimes(String namespace, Collection<? extends BatchProgram> programs,\n+                                                   boolean previous) throws Exception {\n+    List<ProgramId> programIds = programs.stream()\n+      .map(p -> new ProgramId(namespace, p.getAppId(), p.getProgramType(), p.getProgramId()))\n+      .collect(Collectors.toList());\n+\n+    Set<ApplicationId> appIds = programIds.stream().map(ProgramId::getParent).collect(Collectors.toSet());\n+    Map<ApplicationId, ApplicationSpecification> appSpecs = store.getApplications(appIds);\n+\n+    List<BatchProgramSchedule> result = new ArrayList<>();\n+    for (ProgramId programId : programIds) {\n+      ApplicationSpecification spec = appSpecs.get(programId.getParent());\n+      if (spec == null) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(),\n+                                            new NotFoundException(programId.getParent()).getMessage(), null));\n+        continue;\n+      }\n+      try {\n+        Store.ensureProgramExists(programId, spec);\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.OK.code(), null,\n+                                            getScheduledRunTimes(programId, previous)));\n+      } catch (NotFoundException e) {\n+        result.add(new BatchProgramSchedule(programId, HttpResponseStatus.NOT_FOUND.code(), e.getMessage(), null));\n+      } catch (BadRequestException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MTQ3OA=="}, "originalCommit": {"oid": "ea35e3f8a1fc4eaae132ac678105fbd288b0e354"}, "originalPosition": 242}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDk4MjY0", "url": "https://github.com/cdapio/cdap/pull/11899#pullrequestreview-366098264", "createdAt": "2020-02-28T00:46:47Z", "commit": {"oid": "37c808e39b57238b684d838f09cb3f9801f2dc09"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3305f05209bd4b5883de322aecd0fc4b1da56b2b", "author": {"user": {"login": "chtyim", "name": "Terence Yim"}}, "url": "https://github.com/cdapio/cdap/commit/3305f05209bd4b5883de322aecd0fc4b1da56b2b", "committedDate": "2020-02-28T01:04:52Z", "message": "(CDAP-16339) Added batch endpoint for previous and next run time\n\n- Also with some refactoring / fixes\n-- Move schedule handler from WorkflowHttpHandler to ProgramLifecycleHttpHandler\n-- Move getNext/Prev schedule runtimes call to program http handler and enforce authorization correctly"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "37c808e39b57238b684d838f09cb3f9801f2dc09", "author": {"user": {"login": "chtyim", "name": "Terence Yim"}}, "url": "https://github.com/cdapio/cdap/commit/37c808e39b57238b684d838f09cb3f9801f2dc09", "committedDate": "2020-02-27T21:04:29Z", "message": "Address comments"}, "afterCommit": {"oid": "3305f05209bd4b5883de322aecd0fc4b1da56b2b", "author": {"user": {"login": "chtyim", "name": "Terence Yim"}}, "url": "https://github.com/cdapio/cdap/commit/3305f05209bd4b5883de322aecd0fc4b1da56b2b", "committedDate": "2020-02-28T01:04:52Z", "message": "(CDAP-16339) Added batch endpoint for previous and next run time\n\n- Also with some refactoring / fixes\n-- Move schedule handler from WorkflowHttpHandler to ProgramLifecycleHttpHandler\n-- Move getNext/Prev schedule runtimes call to program http handler and enforce authorization correctly"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1306, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}