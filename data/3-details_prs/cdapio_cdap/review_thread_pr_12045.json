{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNTczMTk3", "number": 12045, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzozMzoyNlrODwz5-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzozMzo1N1rODwz6oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTA4NjY3OnYy", "diffSide": "RIGHT", "path": "cdap-ui/app/directives/modified-tooltip/tooltip.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzozMzoyNlrOGEA3lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzozMzoyNlrOGEA3lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2MTcxNg==", "bodyText": "nit: newline at EOF", "url": "https://github.com/cdapio/cdap/pull/12045#discussion_r406861716", "createdAt": "2020-04-10T17:33:26Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/directives/modified-tooltip/tooltip.js", "diffHunk": "@@ -0,0 +1,828 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/**\n+ * The MIT License\n+\n+Copyright (c) 2012-2014 Olivier Louvignes http://olouv.com\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ */\n+\n+angular.module(PKG.name + '.commons')\n+\n+  .provider('$modifiedTooltip', function () {\n+\n+    var defaults = this.defaults = {\n+      animation: 'am-fade',\n+      customClass: '',\n+      prefixClass: 'tooltip',\n+      prefixEvent: 'tooltip',\n+      container: false,\n+      target: false,\n+      placement: 'top',\n+      templateUrl: 'modified-tooltip/tooltip.html',\n+      template: '',\n+      titleTemplate: false,\n+      trigger: 'hover focus',\n+      keyboard: false,\n+      html: false,\n+      show: false,\n+      title: '',\n+      type: '',\n+      delay: 0,\n+      autoClose: false,\n+      bsEnabled: true,\n+      mouseDownPreventDefault: true,\n+      mouseDownStopPropagation: true,\n+      viewport: {\n+        selector: 'body',\n+        padding: 0\n+      }\n+    };\n+\n+    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n+\n+      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n+      var isTouch = ('createTouch' in $window.document) && isNative;\n+      var $body = angular.element($window.document);\n+\n+      function TooltipFactory (element, config) {\n+\n+        var $tooltip = {};\n+\n+        // Common vars\n+        var options = $tooltip.$options = angular.extend({}, defaults, config);\n+        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n+        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n+\n+        var nodeName = element[0].nodeName.toLowerCase();\n+        if (options.delay && angular.isString(options.delay)) {\n+          var split = options.delay.split(',').map(parseFloat);\n+          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n+        }\n+\n+        // Store $id to identify the triggering element in events\n+        // give priority to options.id, otherwise, try to use\n+        // element id if defined\n+        $tooltip.$id = options.id || element.attr('id') || '';\n+\n+        // Support scope as string options\n+        if (options.title) {\n+          scope.title = $sce.trustAsHtml(options.title);\n+        }\n+\n+        // Provide scope helpers\n+        scope.$setEnabled = function (isEnabled) {\n+          scope.$$postDigest(function () {\n+            $tooltip.setEnabled(isEnabled);\n+          });\n+        };\n+        scope.$hide = function () {\n+          scope.$$postDigest(function () {\n+            $tooltip.hide();\n+          });\n+        };\n+        scope.$show = function () {\n+          scope.$$postDigest(function () {\n+            $tooltip.show();\n+          });\n+        };\n+        scope.$toggle = function () {\n+          scope.$$postDigest(function () {\n+            $tooltip.toggle();\n+          });\n+        };\n+        // Publish isShown as a protected var on scope\n+        $tooltip.$isShown = scope.$isShown = false;\n+\n+        // Private vars\n+        var timeout;\n+        var hoverState;\n+\n+        // Fetch, compile then initialize tooltip\n+        var compileData;\n+        var tipElement;\n+        var tipContainer;\n+        var tipScope;\n+        promise.then(function (data) {\n+          compileData = data;\n+          $tooltip.init();\n+        });\n+\n+        $tooltip.init = function () {\n+\n+          // Options: delay\n+          if (options.delay && angular.isNumber(options.delay)) {\n+            options.delay = {\n+              show: options.delay,\n+              hide: options.delay\n+            };\n+          }\n+\n+          // Replace trigger on touch devices ?\n+          // if(isTouch && options.trigger === defaults.trigger) {\n+          //   options.trigger.replace(/hover/g, 'click');\n+          // }\n+\n+          // Options : container\n+          if (options.container === 'self') {\n+            tipContainer = element;\n+          } else if (angular.isElement(options.container)) {\n+            tipContainer = options.container;\n+          } else if (options.container) {\n+            tipContainer = findElement(options.container);\n+          }\n+\n+          // Options: trigger\n+          bindTriggerEvents();\n+\n+          // Options: target\n+          if (options.target) {\n+            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n+          }\n+\n+          // Options: show\n+          if (options.show) {\n+            scope.$$postDigest(function () {\n+              if (options.trigger === 'focus') {\n+                element[0].focus();\n+              } else {\n+                $tooltip.show();\n+              }\n+            });\n+          }\n+\n+        };\n+\n+        $tooltip.destroy = function () {\n+\n+          // Unbind events\n+          unbindTriggerEvents();\n+\n+          // Remove element\n+          destroyTipElement();\n+\n+          // Destroy scope\n+          scope.$destroy();\n+\n+        };\n+\n+        $tooltip.enter = function () {\n+\n+          clearTimeout(timeout);\n+          hoverState = 'in';\n+          if (!options.delay || !options.delay.show) {\n+            return $tooltip.show();\n+          }\n+\n+          timeout = setTimeout(function () {\n+            if (hoverState === 'in') $tooltip.show();\n+          }, options.delay.show);\n+\n+        };\n+\n+        $tooltip.show = function () {\n+          if (!options.bsEnabled || $tooltip.$isShown) return;\n+\n+          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n+          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n+            options.onBeforeShow($tooltip);\n+          }\n+          var parent;\n+          var after;\n+          if (options.container) {\n+            parent = tipContainer;\n+            if (tipContainer[0].lastChild) {\n+              after = angular.element(tipContainer[0].lastChild);\n+            } else {\n+              after = null;\n+            }\n+          } else {\n+            parent = null;\n+            after = element;\n+          }\n+\n+\n+          // Hide any existing tipElement\n+          if (tipElement) destroyTipElement();\n+          // Fetch a cloned element linked from template\n+          tipScope = $tooltip.$scope.$new();\n+          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n+\n+          // Set the initial positioning.  Make the tooltip invisible\n+          // so IE doesn't try to focus on it off screen.\n+          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n+\n+          // Options: animation\n+          if (options.animation) tipElement.addClass(options.animation);\n+          // Options: type\n+          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n+          // Options: custom classes\n+          if (options.customClass) tipElement.addClass(options.customClass);\n+\n+          // Append the element, without any animations.  If we append\n+          // using $animate.enter, some of the animations cause the placement\n+          // to be off due to the transforms.\n+          if (after) {\n+            after.after(tipElement);\n+          } else {\n+            parent.prepend(tipElement);\n+          }\n+\n+          $tooltip.$isShown = scope.$isShown = true;\n+          safeDigest(scope);\n+\n+          // Now, apply placement\n+          $tooltip.$applyPlacement();\n+\n+          // Once placed, animate it.\n+          // Support v1.2+ $animate\n+          // https://github.com/angular/angular.js/issues/11713\n+          if (angular.version.minor <= 2) {\n+            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n+          } else {\n+            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n+          }\n+          safeDigest(scope);\n+\n+          $$rAF(function () {\n+            // Once the tooltip is placed and the animation starts, make the tooltip visible\n+            if (tipElement) tipElement.css({visibility: 'visible'});\n+\n+            // Bind events\n+            if (options.keyboard) {\n+              if (options.trigger !== 'focus') {\n+                $tooltip.focus();\n+              }\n+              bindKeyboardEvents();\n+            }\n+          });\n+\n+          if (options.autoClose) {\n+            bindAutoCloseEvents();\n+          }\n+\n+        };\n+\n+        function enterAnimateCallback () {\n+          scope.$emit(options.prefixEvent + '.show', $tooltip);\n+          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n+            options.onShow($tooltip);\n+          }\n+        }\n+\n+        $tooltip.leave = function () {\n+\n+          clearTimeout(timeout);\n+          hoverState = 'out';\n+          if (!options.delay || !options.delay.hide) {\n+            return $tooltip.hide();\n+          }\n+          timeout = setTimeout(function () {\n+            if (hoverState === 'out') {\n+              $tooltip.hide();\n+            }\n+          }, options.delay.hide);\n+\n+        };\n+\n+        var _blur;\n+        var _tipToHide;\n+        $tooltip.hide = function (blur) {\n+\n+          if (!$tooltip.$isShown) return;\n+          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n+          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n+            options.onBeforeHide($tooltip);\n+          }\n+\n+          // store blur value for leaveAnimateCallback to use\n+          _blur = blur;\n+\n+          // store current tipElement reference to use\n+          // in leaveAnimateCallback\n+          _tipToHide = tipElement;\n+\n+          if (tipElement !== null) {\n+            // Support v1.2+ $animate\n+            // https://github.com/angular/angular.js/issues/11713\n+            if (angular.version.minor <= 2) {\n+              $animate.leave(tipElement, leaveAnimateCallback);\n+            } else {\n+              $animate.leave(tipElement).then(leaveAnimateCallback);\n+            }\n+          }\n+\n+          $tooltip.$isShown = scope.$isShown = false;\n+          safeDigest(scope);\n+\n+          // Unbind events\n+          if (options.keyboard && tipElement !== null) {\n+            unbindKeyboardEvents();\n+          }\n+\n+          if (options.autoClose && tipElement !== null) {\n+            unbindAutoCloseEvents();\n+          }\n+        };\n+\n+        function leaveAnimateCallback () {\n+          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n+          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n+            options.onHide($tooltip);\n+          }\n+\n+          // check if current tipElement still references\n+          // the same element when hide was called\n+          if (tipElement === _tipToHide) {\n+            // Allow to blur the input when hidden, like when pressing enter key\n+            if (_blur && options.trigger === 'focus') {\n+              return element[0].blur();\n+            }\n+\n+            // clean up child scopes\n+            destroyTipElement();\n+          }\n+        }\n+\n+        $tooltip.toggle = function (evt) {\n+          if (evt) { evt.preventDefault(); }\n+          if ($tooltip.$isShown) {\n+            $tooltip.leave();\n+          } else {\n+            $tooltip.enter();\n+          }\n+        };\n+\n+        $tooltip.focus = function () {\n+          if (tipElement) {\n+            tipElement[0].focus();\n+          }\n+        };\n+\n+        $tooltip.setEnabled = function (isEnabled) {\n+          options.bsEnabled = isEnabled;\n+        };\n+\n+        $tooltip.setViewport = function (viewport) {\n+          options.viewport = viewport;\n+        };\n+\n+        // Protected methods\n+\n+        $tooltip.$applyPlacement = function () {\n+          if (!tipElement) return;\n+\n+          // Determine if we're doing an auto or normal placement\n+          var placement = options.placement;\n+          var autoToken = /\\s?auto?\\s?/i;\n+          var autoPlace = autoToken.test(placement);\n+\n+          if (autoPlace) {\n+            placement = placement.replace(autoToken, '') || defaults.placement;\n+          }\n+\n+          // Need to add the position class before we get\n+          // the offsets\n+          tipElement.addClass(options.placement);\n+\n+          // Get the position of the target element\n+          // and the height and width of the tooltip so we can center it.\n+          var elementPosition = getPosition();\n+          var tipWidth = tipElement.prop('offsetWidth');\n+          var tipHeight = tipElement.prop('offsetHeight');\n+\n+          // Refresh viewport position\n+          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n+\n+          // If we're auto placing, we need to check the positioning\n+          if (autoPlace) {\n+            var originalPlacement = placement;\n+            var viewportPosition = getPosition($tooltip.$viewport);\n+\n+            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n+              placement = originalPlacement.replace('bottom', 'top');\n+            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n+              placement = originalPlacement.replace('top', 'bottom');\n+            }\n+\n+            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n+              placement = placement.replace('left', 'right');\n+            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n+              placement = placement.replace('right', 'left');\n+            }\n+\n+            tipElement.removeClass(originalPlacement).addClass(placement);\n+          }\n+\n+          // Get the tooltip's top and left coordinates to center it with this directive.\n+          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n+          applyPlacement(tipPosition, placement);\n+        };\n+\n+        $tooltip.$onKeyUp = function (evt) {\n+          if (evt.which === 27 && $tooltip.$isShown) {\n+            $tooltip.hide();\n+            evt.stopPropagation();\n+          }\n+        };\n+\n+        $tooltip.$onFocusKeyUp = function (evt) {\n+          if (evt.which === 27) {\n+            element[0].blur();\n+            evt.stopPropagation();\n+          }\n+        };\n+\n+        $tooltip.$onFocusElementMouseDown = function (evt) {\n+          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\n+          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\n+          // Some browsers do not auto-focus buttons (eg. Safari)\n+          if ($tooltip.$isShown) {\n+            element[0].blur();\n+          } else {\n+            element[0].focus();\n+          }\n+        };\n+\n+        // bind/unbind events\n+        function bindTriggerEvents () {\n+          var triggers = options.trigger.split(' ');\n+          angular.forEach(triggers, function (trigger) {\n+            if (trigger === 'click' || trigger === 'contextmenu') {\n+              element.on(trigger, $tooltip.toggle);\n+            } else if (trigger !== 'manual') {\n+              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n+              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n+              if (nodeName === 'button' && trigger !== 'hover') {\n+                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n+              }\n+            }\n+          });\n+        }\n+\n+        function unbindTriggerEvents () {\n+          var triggers = options.trigger.split(' ');\n+          for (var i = triggers.length; i--;) {\n+            var trigger = triggers[i];\n+            if (trigger === 'click' || trigger === 'contextmenu') {\n+              element.off(trigger, $tooltip.toggle);\n+            } else if (trigger !== 'manual') {\n+              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n+              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n+              if (nodeName === 'button' && trigger !== 'hover') {\n+                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n+              }\n+            }\n+          }\n+        }\n+\n+        function bindKeyboardEvents () {\n+          if (options.trigger !== 'focus' && tipElement) {\n+            tipElement.on('keyup', $tooltip.$onKeyUp);\n+          } else {\n+            element.on('keyup', $tooltip.$onFocusKeyUp);\n+          }\n+        }\n+\n+        function unbindKeyboardEvents () {\n+          if (options.trigger !== 'focus') {\n+            tipElement.off('keyup', $tooltip.$onKeyUp);\n+          } else {\n+            element.off('keyup', $tooltip.$onFocusKeyUp);\n+          }\n+        }\n+\n+        var _autoCloseEventsBinded = false;\n+        function bindAutoCloseEvents () {\n+          // use timeout to hookup the events to prevent\n+          // event bubbling from being processed imediately.\n+          $timeout(function () {\n+            // Stop propagation when clicking inside tooltip\n+            if (tipElement !== null) {\n+              tipElement.on('click', stopEventPropagation);\n+            }\n+\n+            // Hide when clicking outside tooltip\n+            $body.on('click', $tooltip.hide);\n+\n+            _autoCloseEventsBinded = true;\n+          }, 0, false);\n+        }\n+\n+        function unbindAutoCloseEvents () {\n+          if (_autoCloseEventsBinded) {\n+            tipElement.off('click', stopEventPropagation);\n+            $body.off('click', $tooltip.hide);\n+            _autoCloseEventsBinded = false;\n+          }\n+        }\n+\n+        function stopEventPropagation (event) {\n+          event.stopPropagation();\n+        }\n+\n+        // Private methods\n+\n+        function getPosition ($element) {\n+          $element = $element || (options.target || element);\n+\n+          var el = $element[0];\n+          var isBody = el.tagName === 'BODY';\n+\n+          var elRect = el.getBoundingClientRect();\n+          var rect = {};\n+\n+          // IE8 has issues with angular.extend and using elRect directly.\n+          // By coping the values of elRect into a new object, we can continue to use extend\n+          /* eslint-disable guard-for-in */\n+          for (var p in elRect) { // eslint-disable-line\n+            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n+            rect[p] = elRect[p];\n+          }\n+          /* eslint-enable guard-for-in */\n+\n+          if (rect.width === null) {\n+            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n+            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n+          }\n+          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n+          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n+          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n+\n+          return angular.extend({}, rect, scroll, outerDims, elOffset);\n+        }\n+\n+        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\n+          var offset;\n+          var split = placement.split('-');\n+\n+          switch (split[0]) {\n+            case 'right':\n+              offset = {\n+                top: position.top + position.height / 2 - actualHeight / 2,\n+                left: position.left + position.width\n+              };\n+              break;\n+            case 'bottom':\n+              offset = {\n+                top: position.top + position.height,\n+                left: position.left + position.width / 2 - actualWidth / 2\n+              };\n+              break;\n+            case 'left':\n+              offset = {\n+                top: position.top + position.height / 2 - actualHeight / 2,\n+                left: position.left - actualWidth\n+              };\n+              break;\n+            default:\n+              offset = {\n+                top: position.top - actualHeight,\n+                left: position.left + position.width / 2 - actualWidth / 2\n+              };\n+              break;\n+          }\n+\n+          if (!split[1]) {\n+            return offset;\n+          }\n+\n+          // Add support for corners @todo css\n+          if (split[0] === 'top' || split[0] === 'bottom') {\n+            switch (split[1]) {\n+              case 'left':\n+                offset.left = position.left;\n+                break;\n+              case 'right':\n+                offset.left = position.left + position.width - actualWidth;\n+                break;\n+              default:\n+                break;\n+            }\n+          } else if (split[0] === 'left' || split[0] === 'right') {\n+            switch (split[1]) {\n+              case 'top':\n+                offset.top = position.top - actualHeight + position.height;\n+                break;\n+              case 'bottom':\n+                offset.top = position.top;\n+                break;\n+              default:\n+                break;\n+            }\n+          }\n+\n+          return offset;\n+        }\n+\n+        function applyPlacement (offset, placement) {\n+          if (!tipElement) {\n+            return;\n+          }\n+\n+          var tip = tipElement[0];\n+          var width = tip.offsetWidth;\n+          var height = tip.offsetHeight;\n+\n+          // manually read margins because getBoundingClientRect includes difference\n+          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n+          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n+\n+          // we must check for NaN for ie 8/9\n+          if (isNaN(marginTop)) marginTop = 0;\n+          if (isNaN(marginLeft)) marginLeft = 0;\n+\n+          offset.top = offset.top + marginTop;\n+          offset.left = offset.left + marginLeft;\n+\n+          // dimensions setOffset doesn't round pixel values\n+          // so we use setOffset directly with our own function\n+          dimensions.setOffset(tip, angular.extend({\n+            using: function (props) {\n+              tipElement.css({\n+                top: Math.round(props.top) + 'px',\n+                left: Math.round(props.left) + 'px',\n+                right: ''\n+              });\n+            }\n+          }, offset), 0);\n+\n+          // check to see if placing tip in new offset caused the tip to resize itself\n+          var actualWidth = tip.offsetWidth;\n+          var actualHeight = tip.offsetHeight;\n+\n+          if (placement === 'top' && actualHeight !== height) {\n+            offset.top = offset.top + height - actualHeight;\n+          }\n+\n+          // If it's an exotic placement, exit now instead of\n+          // applying a delta and changing the arrow\n+          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n+\n+          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n+\n+          if (delta.left) {\n+            offset.left += delta.left;\n+          } else {\n+            offset.top += delta.top;\n+          }\n+\n+          dimensions.setOffset(tip, offset);\n+\n+          if (/top|right|bottom|left/.test(placement)) {\n+            var isVertical = /top|bottom/.test(placement);\n+            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n+            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n+\n+            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n+          }\n+        }\n+\n+        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n+        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\n+          var delta = {top: 0, left: 0};\n+          if (!$tooltip.$viewport) return delta;\n+\n+          var viewportPadding = options.viewport && options.viewport.padding || 0;\n+          var viewportDimensions = getPosition($tooltip.$viewport);\n+\n+          if (/right|left/.test(placement)) {\n+            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n+            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n+            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n+              delta.top = viewportDimensions.top - topEdgeOffset;\n+            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n+              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n+            }\n+          } else {\n+            var leftEdgeOffset = position.left - viewportPadding;\n+            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n+            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n+              delta.left = viewportDimensions.left - leftEdgeOffset;\n+            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n+              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n+            }\n+          }\n+\n+          return delta;\n+        }\n+\n+        function replaceArrow (delta, dimension, isHorizontal) {\n+          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n+\n+          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n+                .css(isHorizontal ? 'top' : 'left', '');\n+        }\n+\n+        function destroyTipElement () {\n+          // Cancel pending callbacks\n+          clearTimeout(timeout);\n+\n+          if ($tooltip.$isShown && tipElement !== null) {\n+            if (options.autoClose) {\n+              unbindAutoCloseEvents();\n+            }\n+\n+            if (options.keyboard) {\n+              unbindKeyboardEvents();\n+            }\n+          }\n+\n+          if (tipScope) {\n+            tipScope.$destroy();\n+            tipScope = null;\n+          }\n+\n+          if (tipElement) {\n+            tipElement.remove();\n+            tipElement = $tooltip.$element = null;\n+          }\n+        }\n+\n+        return $tooltip;\n+\n+      }\n+\n+      // Helper functions\n+\n+      function safeDigest (scope) {\n+        /* eslint-disable no-unused-expressions */\n+        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n+        /* eslint-enable no-unused-expressions */\n+      }\n+\n+      function findElement (query, element) {\n+        return angular.element((element || document).querySelectorAll(query));\n+      }\n+\n+      return TooltipFactory;\n+\n+    };\n+\n+  })\n+\n+  \n+  .provider('$modifiedPopover', function () {\n+\n+    var defaults = this.defaults = {\n+      animation: 'am-fade',\n+      customClass: '',\n+      // uncommenting the next two lines will break backwards compatability\n+      // prefixClass: 'popover',\n+      // prefixEvent: 'popover',\n+      container: false,\n+      target: false,\n+      placement: 'right',\n+      templateUrl: 'modified-tooltip/popover.html',\n+      contentTemplate: false,\n+      trigger: 'click',\n+      keyboard: true,\n+      html: false,\n+      title: '',\n+      content: '',\n+      delay: 0,\n+      autoClose: false\n+    };\n+\n+    this.$get = function ($modifiedTooltip) {\n+\n+      function PopoverFactory (element, config) {\n+\n+        // Common vars\n+        var options = angular.extend({}, defaults, config);\n+\n+        var $popover = $modifiedTooltip(element, options);\n+\n+        // Support scope as string options [/*title, */content]\n+        if (options.content) {\n+          $popover.$scope.content = options.content;\n+        }\n+\n+        return $popover;\n+\n+      }\n+\n+      return PopoverFactory;\n+\n+    };\n+  })\n+  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c72f1d5adef3c108e26fe7e56d28e682b9e5fe8a"}, "originalPosition": 828}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTA4ODMyOnYy", "diffSide": "RIGHT", "path": "cdap-ui/app/directives/modified-tooltip/tooltip.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzozMzo1N1rOGEA4gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzozMzo1N1rOGEA4gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2MTk1NA==", "bodyText": "nit: add curly braces", "url": "https://github.com/cdapio/cdap/pull/12045#discussion_r406861954", "createdAt": "2020-04-10T17:33:57Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/directives/modified-tooltip/tooltip.js", "diffHunk": "@@ -0,0 +1,828 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/**\n+ * The MIT License\n+\n+Copyright (c) 2012-2014 Olivier Louvignes http://olouv.com\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ */\n+\n+angular.module(PKG.name + '.commons')\n+\n+  .provider('$modifiedTooltip', function () {\n+\n+    var defaults = this.defaults = {\n+      animation: 'am-fade',\n+      customClass: '',\n+      prefixClass: 'tooltip',\n+      prefixEvent: 'tooltip',\n+      container: false,\n+      target: false,\n+      placement: 'top',\n+      templateUrl: 'modified-tooltip/tooltip.html',\n+      template: '',\n+      titleTemplate: false,\n+      trigger: 'hover focus',\n+      keyboard: false,\n+      html: false,\n+      show: false,\n+      title: '',\n+      type: '',\n+      delay: 0,\n+      autoClose: false,\n+      bsEnabled: true,\n+      mouseDownPreventDefault: true,\n+      mouseDownStopPropagation: true,\n+      viewport: {\n+        selector: 'body',\n+        padding: 0\n+      }\n+    };\n+\n+    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n+\n+      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n+      var isTouch = ('createTouch' in $window.document) && isNative;\n+      var $body = angular.element($window.document);\n+\n+      function TooltipFactory (element, config) {\n+\n+        var $tooltip = {};\n+\n+        // Common vars\n+        var options = $tooltip.$options = angular.extend({}, defaults, config);\n+        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n+        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n+\n+        var nodeName = element[0].nodeName.toLowerCase();\n+        if (options.delay && angular.isString(options.delay)) {\n+          var split = options.delay.split(',').map(parseFloat);\n+          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n+        }\n+\n+        // Store $id to identify the triggering element in events\n+        // give priority to options.id, otherwise, try to use\n+        // element id if defined\n+        $tooltip.$id = options.id || element.attr('id') || '';\n+\n+        // Support scope as string options\n+        if (options.title) {\n+          scope.title = $sce.trustAsHtml(options.title);\n+        }\n+\n+        // Provide scope helpers\n+        scope.$setEnabled = function (isEnabled) {\n+          scope.$$postDigest(function () {\n+            $tooltip.setEnabled(isEnabled);\n+          });\n+        };\n+        scope.$hide = function () {\n+          scope.$$postDigest(function () {\n+            $tooltip.hide();\n+          });\n+        };\n+        scope.$show = function () {\n+          scope.$$postDigest(function () {\n+            $tooltip.show();\n+          });\n+        };\n+        scope.$toggle = function () {\n+          scope.$$postDigest(function () {\n+            $tooltip.toggle();\n+          });\n+        };\n+        // Publish isShown as a protected var on scope\n+        $tooltip.$isShown = scope.$isShown = false;\n+\n+        // Private vars\n+        var timeout;\n+        var hoverState;\n+\n+        // Fetch, compile then initialize tooltip\n+        var compileData;\n+        var tipElement;\n+        var tipContainer;\n+        var tipScope;\n+        promise.then(function (data) {\n+          compileData = data;\n+          $tooltip.init();\n+        });\n+\n+        $tooltip.init = function () {\n+\n+          // Options: delay\n+          if (options.delay && angular.isNumber(options.delay)) {\n+            options.delay = {\n+              show: options.delay,\n+              hide: options.delay\n+            };\n+          }\n+\n+          // Replace trigger on touch devices ?\n+          // if(isTouch && options.trigger === defaults.trigger) {\n+          //   options.trigger.replace(/hover/g, 'click');\n+          // }\n+\n+          // Options : container\n+          if (options.container === 'self') {\n+            tipContainer = element;\n+          } else if (angular.isElement(options.container)) {\n+            tipContainer = options.container;\n+          } else if (options.container) {\n+            tipContainer = findElement(options.container);\n+          }\n+\n+          // Options: trigger\n+          bindTriggerEvents();\n+\n+          // Options: target\n+          if (options.target) {\n+            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n+          }\n+\n+          // Options: show\n+          if (options.show) {\n+            scope.$$postDigest(function () {\n+              if (options.trigger === 'focus') {\n+                element[0].focus();\n+              } else {\n+                $tooltip.show();\n+              }\n+            });\n+          }\n+\n+        };\n+\n+        $tooltip.destroy = function () {\n+\n+          // Unbind events\n+          unbindTriggerEvents();\n+\n+          // Remove element\n+          destroyTipElement();\n+\n+          // Destroy scope\n+          scope.$destroy();\n+\n+        };\n+\n+        $tooltip.enter = function () {\n+\n+          clearTimeout(timeout);\n+          hoverState = 'in';\n+          if (!options.delay || !options.delay.show) {\n+            return $tooltip.show();\n+          }\n+\n+          timeout = setTimeout(function () {\n+            if (hoverState === 'in') $tooltip.show();\n+          }, options.delay.show);\n+\n+        };\n+\n+        $tooltip.show = function () {\n+          if (!options.bsEnabled || $tooltip.$isShown) return;\n+\n+          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n+          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n+            options.onBeforeShow($tooltip);\n+          }\n+          var parent;\n+          var after;\n+          if (options.container) {\n+            parent = tipContainer;\n+            if (tipContainer[0].lastChild) {\n+              after = angular.element(tipContainer[0].lastChild);\n+            } else {\n+              after = null;\n+            }\n+          } else {\n+            parent = null;\n+            after = element;\n+          }\n+\n+\n+          // Hide any existing tipElement\n+          if (tipElement) destroyTipElement();\n+          // Fetch a cloned element linked from template\n+          tipScope = $tooltip.$scope.$new();\n+          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n+\n+          // Set the initial positioning.  Make the tooltip invisible\n+          // so IE doesn't try to focus on it off screen.\n+          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n+\n+          // Options: animation\n+          if (options.animation) tipElement.addClass(options.animation);\n+          // Options: type\n+          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n+          // Options: custom classes\n+          if (options.customClass) tipElement.addClass(options.customClass);\n+\n+          // Append the element, without any animations.  If we append\n+          // using $animate.enter, some of the animations cause the placement\n+          // to be off due to the transforms.\n+          if (after) {\n+            after.after(tipElement);\n+          } else {\n+            parent.prepend(tipElement);\n+          }\n+\n+          $tooltip.$isShown = scope.$isShown = true;\n+          safeDigest(scope);\n+\n+          // Now, apply placement\n+          $tooltip.$applyPlacement();\n+\n+          // Once placed, animate it.\n+          // Support v1.2+ $animate\n+          // https://github.com/angular/angular.js/issues/11713\n+          if (angular.version.minor <= 2) {\n+            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n+          } else {\n+            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n+          }\n+          safeDigest(scope);\n+\n+          $$rAF(function () {\n+            // Once the tooltip is placed and the animation starts, make the tooltip visible\n+            if (tipElement) tipElement.css({visibility: 'visible'});\n+\n+            // Bind events\n+            if (options.keyboard) {\n+              if (options.trigger !== 'focus') {\n+                $tooltip.focus();\n+              }\n+              bindKeyboardEvents();\n+            }\n+          });\n+\n+          if (options.autoClose) {\n+            bindAutoCloseEvents();\n+          }\n+\n+        };\n+\n+        function enterAnimateCallback () {\n+          scope.$emit(options.prefixEvent + '.show', $tooltip);\n+          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n+            options.onShow($tooltip);\n+          }\n+        }\n+\n+        $tooltip.leave = function () {\n+\n+          clearTimeout(timeout);\n+          hoverState = 'out';\n+          if (!options.delay || !options.delay.hide) {\n+            return $tooltip.hide();\n+          }\n+          timeout = setTimeout(function () {\n+            if (hoverState === 'out') {\n+              $tooltip.hide();\n+            }\n+          }, options.delay.hide);\n+\n+        };\n+\n+        var _blur;\n+        var _tipToHide;\n+        $tooltip.hide = function (blur) {\n+\n+          if (!$tooltip.$isShown) return;\n+          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n+          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n+            options.onBeforeHide($tooltip);\n+          }\n+\n+          // store blur value for leaveAnimateCallback to use\n+          _blur = blur;\n+\n+          // store current tipElement reference to use\n+          // in leaveAnimateCallback\n+          _tipToHide = tipElement;\n+\n+          if (tipElement !== null) {\n+            // Support v1.2+ $animate\n+            // https://github.com/angular/angular.js/issues/11713\n+            if (angular.version.minor <= 2) {\n+              $animate.leave(tipElement, leaveAnimateCallback);\n+            } else {\n+              $animate.leave(tipElement).then(leaveAnimateCallback);\n+            }\n+          }\n+\n+          $tooltip.$isShown = scope.$isShown = false;\n+          safeDigest(scope);\n+\n+          // Unbind events\n+          if (options.keyboard && tipElement !== null) {\n+            unbindKeyboardEvents();\n+          }\n+\n+          if (options.autoClose && tipElement !== null) {\n+            unbindAutoCloseEvents();\n+          }\n+        };\n+\n+        function leaveAnimateCallback () {\n+          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n+          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n+            options.onHide($tooltip);\n+          }\n+\n+          // check if current tipElement still references\n+          // the same element when hide was called\n+          if (tipElement === _tipToHide) {\n+            // Allow to blur the input when hidden, like when pressing enter key\n+            if (_blur && options.trigger === 'focus') {\n+              return element[0].blur();\n+            }\n+\n+            // clean up child scopes\n+            destroyTipElement();\n+          }\n+        }\n+\n+        $tooltip.toggle = function (evt) {\n+          if (evt) { evt.preventDefault(); }\n+          if ($tooltip.$isShown) {\n+            $tooltip.leave();\n+          } else {\n+            $tooltip.enter();\n+          }\n+        };\n+\n+        $tooltip.focus = function () {\n+          if (tipElement) {\n+            tipElement[0].focus();\n+          }\n+        };\n+\n+        $tooltip.setEnabled = function (isEnabled) {\n+          options.bsEnabled = isEnabled;\n+        };\n+\n+        $tooltip.setViewport = function (viewport) {\n+          options.viewport = viewport;\n+        };\n+\n+        // Protected methods\n+\n+        $tooltip.$applyPlacement = function () {\n+          if (!tipElement) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c72f1d5adef3c108e26fe7e56d28e682b9e5fe8a"}, "originalPosition": 392}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2722, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}