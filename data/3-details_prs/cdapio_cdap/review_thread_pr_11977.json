{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNjc2NzQ1", "number": 11977, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNDo0OToyOFrODpwAJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0Njo1NVrODtsylg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTA0Njc5OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/DistributedProgramRunner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNDo0OToyOFrOF5HoQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjo0NDoxOVrOF65bTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzODE0Ng==", "bodyText": "It seems strange to use the localDir to determine using artifact.jar file or not. The logic could be easier to understand by\nFile pluginDir = new File(systemArgs.getOption(ProgramOptionConstants.PLUGIN_DIR));\nFile pluginArchiveFile = new File(\"artifacts_archive.jar\");\nif (!pluginArchiveFile.exists()) {\n  if (!pluginDir.isDirectory()) {\n    // this shouldn't happen, throw exception\n    throw new IllegalStateException(...);\n  }\n  // Archive the plugin directory content locally\n  pluginArchiveFile = new File(tempDir, \"artifacts_archive.jar\");\n  BundleJarUtil.createJar(localDir, pluginArchiveFile);\n}\n\n// Localize all plugins to the program containers.\n// We localize to two target paths, one get expanded to a \"artifacts\" directory, \n// and one keep it as jar \"artifacts_archive.jar\" for further localization to other containers in YARN\nlocalizeResources.put(\"artifacts\", new LocalizeResource(pluginArchiveFile, true));\nlocalizeResources.put(\"artifacts_archive.jar\", new LocalizeResource(pluginArchiveFile, false));\n\nnewSystemArgs.put(ProgramOptionConstants.PLUGIN_DIR, \"artifacts\");\nnewSystemArgs.put(ProgramOptionConstants.PLUGIN_ARCHIVE, \"artifacts_archive.jar\");", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395438146", "createdAt": "2020-03-20T04:49:28Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/DistributedProgramRunner.java", "diffHunk": "@@ -508,11 +508,20 @@ private ProgramOptions updateProgramOptions(ProgramOptions options,\n     if (systemArgs.hasOption(ProgramOptionConstants.PLUGIN_DIR)) {\n       File localDir = new File(systemArgs.getOption(ProgramOptionConstants.PLUGIN_DIR));\n       File archiveFile = new File(tempDir, \"artifacts.jar\");\n-      BundleJarUtil.createJar(localDir, archiveFile);\n \n-      // Localize plugins to two files, one expanded into a directory, one not.\n-      localizeResources.put(\"artifacts\", new LocalizeResource(archiveFile, true));\n-      localizeResources.put(\"artifacts_archive.jar\", new LocalizeResource(archiveFile, false));\n+      if (!localDir.exists()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwMjYwNw==", "bodyText": "stale comment? This check is not applicable anymore.\nAs we discussed offline, I have modified it as below, we rely on the fact that program options are updated with PLUGIN_ARCHIVE option:\nif (systemArgs.hasOption(ProgramOptionConstants.PLUGIN_ARCHIVE)) {\n      archiveFile = new File(artifactArchiveJarName);\n      // Localize plugins to two files, one expanded into a directory, one not.\n      localizeResources.put(artifactDirName, new LocalizeResource(archiveFile, true));\n      localizeResources.put(artifactArchiveJarName, new LocalizeResource(archiveFile, false));\n    } else {\n      File localDir = new File(systemArgs.getOption(ProgramOptionConstants.PLUGIN_DIR));\n      archiveFile = new File(tempDir, artifactDirName + \".jar\");\n      BundleJarUtil.createJar(localDir, archiveFile);\n      // Localize plugins to two files, one expanded into a directory, one not.\n      localizeResources.put(artifactDirName, new LocalizeResource(archiveFile, true));\n      localizeResources.put(artifactArchiveJarName, new LocalizeResource(archiveFile, false));\n    }", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r397302607", "createdAt": "2020-03-24T16:44:19Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/DistributedProgramRunner.java", "diffHunk": "@@ -508,11 +508,20 @@ private ProgramOptions updateProgramOptions(ProgramOptions options,\n     if (systemArgs.hasOption(ProgramOptionConstants.PLUGIN_DIR)) {\n       File localDir = new File(systemArgs.getOption(ProgramOptionConstants.PLUGIN_DIR));\n       File archiveFile = new File(tempDir, \"artifacts.jar\");\n-      BundleJarUtil.createJar(localDir, archiveFile);\n \n-      // Localize plugins to two files, one expanded into a directory, one not.\n-      localizeResources.put(\"artifacts\", new LocalizeResource(archiveFile, true));\n-      localizeResources.put(\"artifacts_archive.jar\", new LocalizeResource(archiveFile, false));\n+      if (!localDir.exists()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzODE0Ng=="}, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTA0OTcxOnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/DefaultRuntimeInfo.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNDo1MjowNVrOF5HqAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNDo1MjowNVrOF5HqAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzODU5NQ==", "bodyText": "Wrong link?", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395438595", "createdAt": "2020-03-20T04:52:05Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/DefaultRuntimeInfo.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeLocalFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+/**\n+ * Default implementation of {@link RuntimeLocalFile}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTA1MjM1OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/DefaultRuntimeInfo.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNDo1NDoxNVrOF5HrfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNDo1NDoxNVrOF5HrfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzODk3Mg==", "bodyText": "Suggest to take (ProgramRunId programRunId, Collection<? extends RuntimeLocalFile> localizeFiles). This would make the caller code cleaner.", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395438972", "createdAt": "2020-03-20T04:54:15Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/DefaultRuntimeInfo.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeLocalFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+/**\n+ * Default implementation of {@link RuntimeLocalFile}.\n+ */\n+public class DefaultRuntimeInfo implements RuntimeJobInfo {\n+  private final Collection<? extends RuntimeLocalFile> files;\n+  private final ProgramRunInfo info;\n+\n+  DefaultRuntimeInfo(Collection<? extends RuntimeLocalFile> files, ProgramRunInfo info) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTA1NTk4OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNDo1ODowNVrOF5Htsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjo1NToxOFrOF658eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzOTUzOQ==", "bodyText": "The comment is at the wrong place. The next if is for the startup successful case", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395439539", "createdAt": "2020-03-20T04:58:05Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import org.apache.twill.api.Command;\n+import org.apache.twill.api.ResourceReport;\n+import org.apache.twill.api.RunId;\n+import org.apache.twill.api.ServiceController;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.discovery.ServiceDiscovered;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of {@link TwillController} that uses {@link RuntimeJobManager} to monitor and\n+ * control a running program.\n+ */\n+class RuntimeJobTwillController implements TwillController {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillController.class);\n+\n+  private final RunId runId;\n+  private final ProgramRunId programRunId;\n+  private final RuntimeJobManager jobManager;\n+  private final CompletableFuture<RuntimeJobTwillController> started;\n+  private final CompletableFuture<RuntimeJobTwillController> completion;\n+  private final AtomicBoolean terminateCalled;\n+\n+  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId) {\n+    this.programRunId = programRunId;\n+    this.runId = RunIds.fromString(programRunId.getRun());\n+    this.jobManager = jobManager;\n+    this.started = new CompletableFuture<>();\n+    this.completion = new CompletableFuture<>();\n+    this.terminateCalled = new AtomicBoolean();\n+  }\n+\n+  RuntimeJobManager getJobManager() {\n+    return jobManager;\n+  }\n+\n+  void start(CompletableFuture<Void> startupTaskCompletion) {\n+    startupTaskCompletion.whenComplete((res, throwable) -> {\n+      // terminate this controller with fail state", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxMTA5OA==", "bodyText": "I added it for the whole if..else block, but moved it closer to the else", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r397311098", "createdAt": "2020-03-24T16:55:18Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import org.apache.twill.api.Command;\n+import org.apache.twill.api.ResourceReport;\n+import org.apache.twill.api.RunId;\n+import org.apache.twill.api.ServiceController;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.discovery.ServiceDiscovered;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of {@link TwillController} that uses {@link RuntimeJobManager} to monitor and\n+ * control a running program.\n+ */\n+class RuntimeJobTwillController implements TwillController {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillController.class);\n+\n+  private final RunId runId;\n+  private final ProgramRunId programRunId;\n+  private final RuntimeJobManager jobManager;\n+  private final CompletableFuture<RuntimeJobTwillController> started;\n+  private final CompletableFuture<RuntimeJobTwillController> completion;\n+  private final AtomicBoolean terminateCalled;\n+\n+  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId) {\n+    this.programRunId = programRunId;\n+    this.runId = RunIds.fromString(programRunId.getRun());\n+    this.jobManager = jobManager;\n+    this.started = new CompletableFuture<>();\n+    this.completion = new CompletableFuture<>();\n+    this.terminateCalled = new AtomicBoolean();\n+  }\n+\n+  RuntimeJobManager getJobManager() {\n+    return jobManager;\n+  }\n+\n+  void start(CompletableFuture<Void> startupTaskCompletion) {\n+    startupTaskCompletion.whenComplete((res, throwable) -> {\n+      // terminate this controller with fail state", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQzOTUzOQ=="}, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTA2MTM0OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNTowMzoxNFrOF5Hw0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNTowMzoxNFrOF5Hw0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MDMzNw==", "bodyText": "Why not call the jobManager.kill?", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395440337", "createdAt": "2020-03-20T05:03:14Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import org.apache.twill.api.Command;\n+import org.apache.twill.api.ResourceReport;\n+import org.apache.twill.api.RunId;\n+import org.apache.twill.api.ServiceController;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.discovery.ServiceDiscovered;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of {@link TwillController} that uses {@link RuntimeJobManager} to monitor and\n+ * control a running program.\n+ */\n+class RuntimeJobTwillController implements TwillController {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillController.class);\n+\n+  private final RunId runId;\n+  private final ProgramRunId programRunId;\n+  private final RuntimeJobManager jobManager;\n+  private final CompletableFuture<RuntimeJobTwillController> started;\n+  private final CompletableFuture<RuntimeJobTwillController> completion;\n+  private final AtomicBoolean terminateCalled;\n+\n+  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId) {\n+    this.programRunId = programRunId;\n+    this.runId = RunIds.fromString(programRunId.getRun());\n+    this.jobManager = jobManager;\n+    this.started = new CompletableFuture<>();\n+    this.completion = new CompletableFuture<>();\n+    this.terminateCalled = new AtomicBoolean();\n+  }\n+\n+  RuntimeJobManager getJobManager() {\n+    return jobManager;\n+  }\n+\n+  void start(CompletableFuture<Void> startupTaskCompletion) {\n+    startupTaskCompletion.whenComplete((res, throwable) -> {\n+      // terminate this controller with fail state\n+      if (throwable == null) {\n+        started.complete(this);\n+      } else {\n+        completion.completeExceptionally(throwable);\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public void addLogHandler(LogHandler handler) {\n+    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n+  }\n+\n+  @Override\n+  public ServiceDiscovered discoverService(String serviceName) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Future<Integer> changeInstances(String runnable, int newCount) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Nullable\n+  @Override\n+  public ResourceReport getResourceReport() {\n+    return null;\n+  }\n+\n+  @Override\n+  public Future<String> restartAllInstances(String runnable) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Future<Set<String>> restartInstances(Map<String, ? extends Set<Integer>> runnableToInstanceIds) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Future<String> restartInstances(String runnable, int instanceId, int... moreInstanceIds) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Future<String> restartInstances(String runnable, Set<Integer> instanceIds) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public Future<Map<String, LogEntry.Level>> updateLogLevels(Map<String, LogEntry.Level> logLevels) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"updateLogLevels is not supported\"));\n+  }\n+\n+  @Override\n+  public Future<Map<String, LogEntry.Level>> updateLogLevels(String runnableName,\n+                                                             Map<String, LogEntry.Level> logLevelsForRunnable) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"updateLogLevels is not supported\"));\n+  }\n+\n+  @Override\n+  public Future<String[]> resetLogLevels(String... loggerNames) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"resetLogLevels is not supported\"));\n+  }\n+\n+  @Override\n+  public Future<String[]> resetRunnableLogLevels(String runnableName, String... loggerNames) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"resetRunnableLogLevels is not supported\"));\n+  }\n+\n+  @Override\n+  public RunId getRunId() {\n+    return runId;\n+  }\n+\n+  @Override\n+  public Future<Command> sendCommand(Command command) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"sendCommand is not supported\"));\n+  }\n+\n+  @Override\n+  public Future<Command> sendCommand(String runnableName, Command command) {\n+    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"sendCommand is not supported\"));\n+  }\n+\n+  @Override\n+  public void onRunning(Runnable runnable, Executor executor) {\n+    started.thenRunAsync(runnable, executor);\n+  }\n+\n+  @Override\n+  public void onTerminated(Runnable runnable, Executor executor) {\n+    completion.whenCompleteAsync((remoteExecutionTwillController, throwable) -> runnable.run(), executor);\n+  }\n+\n+  @Override\n+  public void awaitTerminated() throws ExecutionException {\n+    Uninterruptibles.getUninterruptibly(completion);\n+  }\n+\n+  @Override\n+  public void awaitTerminated(long timeout, TimeUnit timeoutUnit) throws TimeoutException, ExecutionException {\n+    Uninterruptibles.getUninterruptibly(completion, timeout, timeoutUnit);\n+  }\n+\n+  @Override\n+  public Future<? extends ServiceController> terminate() {\n+    if (terminateCalled.compareAndSet(false, true)) {\n+      try {\n+        // stop the job\n+        jobManager.stop(new ProgramRunInfo.Builder()\n+                          .setNamespace(programRunId.getNamespace())\n+                          .setApplication(programRunId.getApplication())\n+                          .setProgram(programRunId.getProgram())\n+                          .setProgramType(programRunId.getType().getPrettyName())\n+                          .setRun(programRunId.getRun()).build());\n+        // mark completion as completed\n+        completion.complete(this);\n+      } catch (Exception e) {\n+        completion.completeExceptionally(e);\n+      }\n+    }\n+    return completion;\n+  }\n+\n+  @Override\n+  public void kill() {\n+    try {\n+      terminate().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTA4Mjc1OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillPreparer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNToyMjozOVrOF5H9fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjo1MjoxM1rOF65zWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzU4Mg==", "bodyText": "If this callable throw exception, who is calling jobManager.destroy()? Probably better to have a try-catch block to call destroy and rethrow the exception", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395443582", "createdAt": "2020-03-20T05:22:39Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillPreparer.java", "diffHunk": "@@ -0,0 +1,678 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.ListMultimap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.hash.Hasher;\n+import com.google.common.hash.Hashing;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.io.Locations;\n+import io.cdap.cdap.common.logging.LoggingContext;\n+import io.cdap.cdap.common.logging.LoggingContextAccessor;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.runtime.distributed.runtime.TwillControllerFactory;\n+import io.cdap.cdap.logging.context.LoggingContextHelper;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeLocalFile;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.twill.api.ClassAcceptor;\n+import org.apache.twill.api.EventHandlerSpecification;\n+import org.apache.twill.api.LocalFile;\n+import org.apache.twill.api.RuntimeSpecification;\n+import org.apache.twill.api.SecureStore;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.TwillPreparer;\n+import org.apache.twill.api.TwillRunnable;\n+import org.apache.twill.api.TwillSpecification;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.common.Cancellable;\n+import org.apache.twill.filesystem.Location;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.ApplicationBundler;\n+import org.apache.twill.internal.Arguments;\n+import org.apache.twill.internal.Constants;\n+import org.apache.twill.internal.DefaultLocalFile;\n+import org.apache.twill.internal.DefaultRuntimeSpecification;\n+import org.apache.twill.internal.DefaultTwillSpecification;\n+import org.apache.twill.internal.LogOnlyEventHandler;\n+import org.apache.twill.internal.TwillRuntimeSpecification;\n+import org.apache.twill.internal.io.LocationCache;\n+import org.apache.twill.internal.json.ArgumentsCodec;\n+import org.apache.twill.internal.json.TwillRuntimeSpecificationAdapter;\n+import org.apache.twill.internal.utils.Paths;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+\n+/**\n+ *  A {@link TwillPreparer} implementation that uses runtime job manager to launch a single {@link TwillRunnable}.\n+ */\n+public class RuntimeJobTwillPreparer implements TwillPreparer {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillPreparer.class);\n+\n+  private final CConfiguration cConf;\n+  private final Configuration hConf;\n+  private final TwillSpecification twillSpec;\n+  private final ProgramRunId programRunId;\n+  private final ProgramOptions programOptions;\n+\n+  private final List<String> arguments = new ArrayList<>();\n+  private final Set<Class<?>> dependencies = Sets.newIdentityHashSet();\n+  private final List<URI> resources = new ArrayList<>();\n+  private final List<String> classPaths = new ArrayList<>();\n+  private final ListMultimap<String, String> runnableArgs = ArrayListMultimap.create();\n+  private final Map<String, Map<String, String>> environments = new HashMap<>();\n+  private final List<String> applicationClassPaths = new ArrayList<>();\n+  private final Map<String, Map<String, String>> logLevels = new HashMap<>();\n+  private final LocationCache locationCache;\n+  private final Map<String, Integer> maxRetries = new HashMap<>();\n+  private final Map<String, Map<String, String>> runnableConfigs = new HashMap<>();\n+  private final LocationFactory locationFactory;\n+  private final TwillControllerFactory controllerFactory;\n+  private final RuntimeJobManager jobManager;\n+\n+  private ClassAcceptor classAcceptor;\n+\n+  RuntimeJobTwillPreparer(CConfiguration cConf, Configuration hConf,\n+                          TwillSpecification twillSpec, ProgramRunId programRunId,\n+                          ProgramOptions programOptions, LocationCache locationCache,\n+                          LocationFactory locationFactory, TwillControllerFactory controllerFactory,\n+                          RuntimeJobManager jobManager) {\n+    // Check to prevent future mistake\n+    if (twillSpec.getRunnables().size() != 1) {\n+      throw new IllegalArgumentException(\"Only one TwillRunnable is supported\");\n+    }\n+\n+    this.cConf = cConf;\n+    this.hConf = hConf;\n+    this.twillSpec = twillSpec;\n+    this.programRunId = programRunId;\n+    this.programOptions = programOptions;\n+    this.classAcceptor = new ClassAcceptor();\n+    this.locationCache = locationCache;\n+    this.locationFactory = locationFactory;\n+    this.controllerFactory = controllerFactory;\n+    this.jobManager = jobManager;\n+  }\n+\n+  private void confirmRunnableName(String runnableName) {\n+    Preconditions.checkNotNull(runnableName);\n+    Preconditions.checkArgument(twillSpec.getRunnables().containsKey(runnableName),\n+                                \"Runnable %s is not defined in the application.\", runnableName);\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(Map<String, String> config) {\n+    config.forEach(hConf::set);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(String runnableName, Map<String, String> config) {\n+    confirmRunnableName(runnableName);\n+    runnableConfigs.put(runnableName, Maps.newHashMap(config));\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addLogHandler(LogHandler handler) {\n+    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setUser(String user) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setSchedulerQueue(String name) {\n+    LOG.trace(\"Scheduler queue is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String runnableName, String options) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(String... runnables) {\n+    return enableDebugging(false, runnables);\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(boolean doSuspend, String... runnables) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(String... args) {\n+    return withApplicationArguments(Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(Iterable<String> args) {\n+    Iterables.addAll(arguments, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, String... args) {\n+    return withArguments(runnableName, Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, Iterable<String> args) {\n+    confirmRunnableName(runnableName);\n+    runnableArgs.putAll(runnableName, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Class<?>... classes) {\n+    return withDependencies(Arrays.asList(classes));\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Iterable<Class<?>> classes) {\n+    Iterables.addAll(dependencies, classes);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(URI... resources) {\n+    return withResources(Arrays.asList(resources));\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(Iterable<URI> resources) {\n+    Iterables.addAll(this.resources, resources);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(String... classPaths) {\n+    return withClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.classPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(Map<String, String> env) {\n+    // Add the given environments to all runnables\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      setEnv(runnableName, env, false);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(String runnableName, Map<String, String> env) {\n+    confirmRunnableName(runnableName);\n+    setEnv(runnableName, env, true);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(String... classPaths) {\n+    return withApplicationClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.applicationClassPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withBundlerClassAcceptor(ClassAcceptor classAcceptor) {\n+    this.classAcceptor = classAcceptor;\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withMaxRetries(String runnableName, int maxRetries) {\n+    confirmRunnableName(runnableName);\n+    this.maxRetries.put(runnableName, maxRetries);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addSecureStore(SecureStore secureStore) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevel(LogEntry.Level logLevel) {\n+    return setLogLevels(Collections.singletonMap(Logger.ROOT_LOGGER_NAME, logLevel));\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(Map<String, LogEntry.Level> logLevels) {\n+    Preconditions.checkNotNull(logLevels);\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      saveLogLevels(runnableName, logLevels);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(String runnableName, Map<String, LogEntry.Level> runnableLogLevels) {\n+    confirmRunnableName(runnableName);\n+    Preconditions.checkNotNull(runnableLogLevels);\n+    Preconditions.checkArgument(!(logLevels.containsKey(Logger.ROOT_LOGGER_NAME)\n+      && logLevels.get(Logger.ROOT_LOGGER_NAME) == null));\n+    saveLogLevels(runnableName, runnableLogLevels);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setClassLoader(String classLoaderClassName) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillController start() {\n+    return start(Constants.APPLICATION_MAX_START_SECONDS, TimeUnit.SECONDS);\n+  }\n+\n+  @Override\n+  public TwillController start(long timeout, TimeUnit timeoutUnit) {\n+    long startTime = System.currentTimeMillis();\n+\n+    Callable<Void> startupTask = () -> {\n+      jobManager.initialize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwODc2Mg==", "bodyText": "That logic is handled here: https://github.com/cdapio/cdap/pull/11977/files#diff-b118a2e8f9a139c00287cbcbbf734ea7R300", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r397308762", "createdAt": "2020-03-24T16:52:13Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillPreparer.java", "diffHunk": "@@ -0,0 +1,678 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.ListMultimap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.hash.Hasher;\n+import com.google.common.hash.Hashing;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.io.Locations;\n+import io.cdap.cdap.common.logging.LoggingContext;\n+import io.cdap.cdap.common.logging.LoggingContextAccessor;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.runtime.distributed.runtime.TwillControllerFactory;\n+import io.cdap.cdap.logging.context.LoggingContextHelper;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeLocalFile;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.twill.api.ClassAcceptor;\n+import org.apache.twill.api.EventHandlerSpecification;\n+import org.apache.twill.api.LocalFile;\n+import org.apache.twill.api.RuntimeSpecification;\n+import org.apache.twill.api.SecureStore;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.TwillPreparer;\n+import org.apache.twill.api.TwillRunnable;\n+import org.apache.twill.api.TwillSpecification;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.common.Cancellable;\n+import org.apache.twill.filesystem.Location;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.ApplicationBundler;\n+import org.apache.twill.internal.Arguments;\n+import org.apache.twill.internal.Constants;\n+import org.apache.twill.internal.DefaultLocalFile;\n+import org.apache.twill.internal.DefaultRuntimeSpecification;\n+import org.apache.twill.internal.DefaultTwillSpecification;\n+import org.apache.twill.internal.LogOnlyEventHandler;\n+import org.apache.twill.internal.TwillRuntimeSpecification;\n+import org.apache.twill.internal.io.LocationCache;\n+import org.apache.twill.internal.json.ArgumentsCodec;\n+import org.apache.twill.internal.json.TwillRuntimeSpecificationAdapter;\n+import org.apache.twill.internal.utils.Paths;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+\n+/**\n+ *  A {@link TwillPreparer} implementation that uses runtime job manager to launch a single {@link TwillRunnable}.\n+ */\n+public class RuntimeJobTwillPreparer implements TwillPreparer {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillPreparer.class);\n+\n+  private final CConfiguration cConf;\n+  private final Configuration hConf;\n+  private final TwillSpecification twillSpec;\n+  private final ProgramRunId programRunId;\n+  private final ProgramOptions programOptions;\n+\n+  private final List<String> arguments = new ArrayList<>();\n+  private final Set<Class<?>> dependencies = Sets.newIdentityHashSet();\n+  private final List<URI> resources = new ArrayList<>();\n+  private final List<String> classPaths = new ArrayList<>();\n+  private final ListMultimap<String, String> runnableArgs = ArrayListMultimap.create();\n+  private final Map<String, Map<String, String>> environments = new HashMap<>();\n+  private final List<String> applicationClassPaths = new ArrayList<>();\n+  private final Map<String, Map<String, String>> logLevels = new HashMap<>();\n+  private final LocationCache locationCache;\n+  private final Map<String, Integer> maxRetries = new HashMap<>();\n+  private final Map<String, Map<String, String>> runnableConfigs = new HashMap<>();\n+  private final LocationFactory locationFactory;\n+  private final TwillControllerFactory controllerFactory;\n+  private final RuntimeJobManager jobManager;\n+\n+  private ClassAcceptor classAcceptor;\n+\n+  RuntimeJobTwillPreparer(CConfiguration cConf, Configuration hConf,\n+                          TwillSpecification twillSpec, ProgramRunId programRunId,\n+                          ProgramOptions programOptions, LocationCache locationCache,\n+                          LocationFactory locationFactory, TwillControllerFactory controllerFactory,\n+                          RuntimeJobManager jobManager) {\n+    // Check to prevent future mistake\n+    if (twillSpec.getRunnables().size() != 1) {\n+      throw new IllegalArgumentException(\"Only one TwillRunnable is supported\");\n+    }\n+\n+    this.cConf = cConf;\n+    this.hConf = hConf;\n+    this.twillSpec = twillSpec;\n+    this.programRunId = programRunId;\n+    this.programOptions = programOptions;\n+    this.classAcceptor = new ClassAcceptor();\n+    this.locationCache = locationCache;\n+    this.locationFactory = locationFactory;\n+    this.controllerFactory = controllerFactory;\n+    this.jobManager = jobManager;\n+  }\n+\n+  private void confirmRunnableName(String runnableName) {\n+    Preconditions.checkNotNull(runnableName);\n+    Preconditions.checkArgument(twillSpec.getRunnables().containsKey(runnableName),\n+                                \"Runnable %s is not defined in the application.\", runnableName);\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(Map<String, String> config) {\n+    config.forEach(hConf::set);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(String runnableName, Map<String, String> config) {\n+    confirmRunnableName(runnableName);\n+    runnableConfigs.put(runnableName, Maps.newHashMap(config));\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addLogHandler(LogHandler handler) {\n+    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setUser(String user) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setSchedulerQueue(String name) {\n+    LOG.trace(\"Scheduler queue is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String runnableName, String options) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(String... runnables) {\n+    return enableDebugging(false, runnables);\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(boolean doSuspend, String... runnables) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(String... args) {\n+    return withApplicationArguments(Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(Iterable<String> args) {\n+    Iterables.addAll(arguments, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, String... args) {\n+    return withArguments(runnableName, Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, Iterable<String> args) {\n+    confirmRunnableName(runnableName);\n+    runnableArgs.putAll(runnableName, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Class<?>... classes) {\n+    return withDependencies(Arrays.asList(classes));\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Iterable<Class<?>> classes) {\n+    Iterables.addAll(dependencies, classes);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(URI... resources) {\n+    return withResources(Arrays.asList(resources));\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(Iterable<URI> resources) {\n+    Iterables.addAll(this.resources, resources);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(String... classPaths) {\n+    return withClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.classPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(Map<String, String> env) {\n+    // Add the given environments to all runnables\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      setEnv(runnableName, env, false);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(String runnableName, Map<String, String> env) {\n+    confirmRunnableName(runnableName);\n+    setEnv(runnableName, env, true);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(String... classPaths) {\n+    return withApplicationClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.applicationClassPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withBundlerClassAcceptor(ClassAcceptor classAcceptor) {\n+    this.classAcceptor = classAcceptor;\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withMaxRetries(String runnableName, int maxRetries) {\n+    confirmRunnableName(runnableName);\n+    this.maxRetries.put(runnableName, maxRetries);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addSecureStore(SecureStore secureStore) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevel(LogEntry.Level logLevel) {\n+    return setLogLevels(Collections.singletonMap(Logger.ROOT_LOGGER_NAME, logLevel));\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(Map<String, LogEntry.Level> logLevels) {\n+    Preconditions.checkNotNull(logLevels);\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      saveLogLevels(runnableName, logLevels);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(String runnableName, Map<String, LogEntry.Level> runnableLogLevels) {\n+    confirmRunnableName(runnableName);\n+    Preconditions.checkNotNull(runnableLogLevels);\n+    Preconditions.checkArgument(!(logLevels.containsKey(Logger.ROOT_LOGGER_NAME)\n+      && logLevels.get(Logger.ROOT_LOGGER_NAME) == null));\n+    saveLogLevels(runnableName, runnableLogLevels);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setClassLoader(String classLoaderClassName) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillController start() {\n+    return start(Constants.APPLICATION_MAX_START_SECONDS, TimeUnit.SECONDS);\n+  }\n+\n+  @Override\n+  public TwillController start(long timeout, TimeUnit timeoutUnit) {\n+    long startTime = System.currentTimeMillis();\n+\n+    Callable<Void> startupTask = () -> {\n+      jobManager.initialize();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzU4Mg=="}, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 354}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTA5OTE2OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillPreparer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNTozNjowN1rOF5IHLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjo1MjoyOVrOF650Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0NjA2MQ==", "bodyText": "We shouldn't handle it differently.", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r395446061", "createdAt": "2020-03-20T05:36:07Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillPreparer.java", "diffHunk": "@@ -0,0 +1,678 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.ListMultimap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.hash.Hasher;\n+import com.google.common.hash.Hashing;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.io.Locations;\n+import io.cdap.cdap.common.logging.LoggingContext;\n+import io.cdap.cdap.common.logging.LoggingContextAccessor;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.runtime.distributed.runtime.TwillControllerFactory;\n+import io.cdap.cdap.logging.context.LoggingContextHelper;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeLocalFile;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.twill.api.ClassAcceptor;\n+import org.apache.twill.api.EventHandlerSpecification;\n+import org.apache.twill.api.LocalFile;\n+import org.apache.twill.api.RuntimeSpecification;\n+import org.apache.twill.api.SecureStore;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.TwillPreparer;\n+import org.apache.twill.api.TwillRunnable;\n+import org.apache.twill.api.TwillSpecification;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.common.Cancellable;\n+import org.apache.twill.filesystem.Location;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.ApplicationBundler;\n+import org.apache.twill.internal.Arguments;\n+import org.apache.twill.internal.Constants;\n+import org.apache.twill.internal.DefaultLocalFile;\n+import org.apache.twill.internal.DefaultRuntimeSpecification;\n+import org.apache.twill.internal.DefaultTwillSpecification;\n+import org.apache.twill.internal.LogOnlyEventHandler;\n+import org.apache.twill.internal.TwillRuntimeSpecification;\n+import org.apache.twill.internal.io.LocationCache;\n+import org.apache.twill.internal.json.ArgumentsCodec;\n+import org.apache.twill.internal.json.TwillRuntimeSpecificationAdapter;\n+import org.apache.twill.internal.utils.Paths;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+\n+/**\n+ *  A {@link TwillPreparer} implementation that uses runtime job manager to launch a single {@link TwillRunnable}.\n+ */\n+public class RuntimeJobTwillPreparer implements TwillPreparer {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillPreparer.class);\n+\n+  private final CConfiguration cConf;\n+  private final Configuration hConf;\n+  private final TwillSpecification twillSpec;\n+  private final ProgramRunId programRunId;\n+  private final ProgramOptions programOptions;\n+\n+  private final List<String> arguments = new ArrayList<>();\n+  private final Set<Class<?>> dependencies = Sets.newIdentityHashSet();\n+  private final List<URI> resources = new ArrayList<>();\n+  private final List<String> classPaths = new ArrayList<>();\n+  private final ListMultimap<String, String> runnableArgs = ArrayListMultimap.create();\n+  private final Map<String, Map<String, String>> environments = new HashMap<>();\n+  private final List<String> applicationClassPaths = new ArrayList<>();\n+  private final Map<String, Map<String, String>> logLevels = new HashMap<>();\n+  private final LocationCache locationCache;\n+  private final Map<String, Integer> maxRetries = new HashMap<>();\n+  private final Map<String, Map<String, String>> runnableConfigs = new HashMap<>();\n+  private final LocationFactory locationFactory;\n+  private final TwillControllerFactory controllerFactory;\n+  private final RuntimeJobManager jobManager;\n+\n+  private ClassAcceptor classAcceptor;\n+\n+  RuntimeJobTwillPreparer(CConfiguration cConf, Configuration hConf,\n+                          TwillSpecification twillSpec, ProgramRunId programRunId,\n+                          ProgramOptions programOptions, LocationCache locationCache,\n+                          LocationFactory locationFactory, TwillControllerFactory controllerFactory,\n+                          RuntimeJobManager jobManager) {\n+    // Check to prevent future mistake\n+    if (twillSpec.getRunnables().size() != 1) {\n+      throw new IllegalArgumentException(\"Only one TwillRunnable is supported\");\n+    }\n+\n+    this.cConf = cConf;\n+    this.hConf = hConf;\n+    this.twillSpec = twillSpec;\n+    this.programRunId = programRunId;\n+    this.programOptions = programOptions;\n+    this.classAcceptor = new ClassAcceptor();\n+    this.locationCache = locationCache;\n+    this.locationFactory = locationFactory;\n+    this.controllerFactory = controllerFactory;\n+    this.jobManager = jobManager;\n+  }\n+\n+  private void confirmRunnableName(String runnableName) {\n+    Preconditions.checkNotNull(runnableName);\n+    Preconditions.checkArgument(twillSpec.getRunnables().containsKey(runnableName),\n+                                \"Runnable %s is not defined in the application.\", runnableName);\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(Map<String, String> config) {\n+    config.forEach(hConf::set);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(String runnableName, Map<String, String> config) {\n+    confirmRunnableName(runnableName);\n+    runnableConfigs.put(runnableName, Maps.newHashMap(config));\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addLogHandler(LogHandler handler) {\n+    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setUser(String user) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setSchedulerQueue(String name) {\n+    LOG.trace(\"Scheduler queue is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String runnableName, String options) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(String... runnables) {\n+    return enableDebugging(false, runnables);\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(boolean doSuspend, String... runnables) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(String... args) {\n+    return withApplicationArguments(Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(Iterable<String> args) {\n+    Iterables.addAll(arguments, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, String... args) {\n+    return withArguments(runnableName, Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, Iterable<String> args) {\n+    confirmRunnableName(runnableName);\n+    runnableArgs.putAll(runnableName, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Class<?>... classes) {\n+    return withDependencies(Arrays.asList(classes));\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Iterable<Class<?>> classes) {\n+    Iterables.addAll(dependencies, classes);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(URI... resources) {\n+    return withResources(Arrays.asList(resources));\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(Iterable<URI> resources) {\n+    Iterables.addAll(this.resources, resources);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(String... classPaths) {\n+    return withClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.classPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(Map<String, String> env) {\n+    // Add the given environments to all runnables\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      setEnv(runnableName, env, false);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(String runnableName, Map<String, String> env) {\n+    confirmRunnableName(runnableName);\n+    setEnv(runnableName, env, true);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(String... classPaths) {\n+    return withApplicationClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.applicationClassPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withBundlerClassAcceptor(ClassAcceptor classAcceptor) {\n+    this.classAcceptor = classAcceptor;\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withMaxRetries(String runnableName, int maxRetries) {\n+    confirmRunnableName(runnableName);\n+    this.maxRetries.put(runnableName, maxRetries);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addSecureStore(SecureStore secureStore) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevel(LogEntry.Level logLevel) {\n+    return setLogLevels(Collections.singletonMap(Logger.ROOT_LOGGER_NAME, logLevel));\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(Map<String, LogEntry.Level> logLevels) {\n+    Preconditions.checkNotNull(logLevels);\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      saveLogLevels(runnableName, logLevels);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(String runnableName, Map<String, LogEntry.Level> runnableLogLevels) {\n+    confirmRunnableName(runnableName);\n+    Preconditions.checkNotNull(runnableLogLevels);\n+    Preconditions.checkArgument(!(logLevels.containsKey(Logger.ROOT_LOGGER_NAME)\n+      && logLevels.get(Logger.ROOT_LOGGER_NAME) == null));\n+    saveLogLevels(runnableName, runnableLogLevels);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setClassLoader(String classLoaderClassName) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillController start() {\n+    return start(Constants.APPLICATION_MAX_START_SECONDS, TimeUnit.SECONDS);\n+  }\n+\n+  @Override\n+  public TwillController start(long timeout, TimeUnit timeoutUnit) {\n+    long startTime = System.currentTimeMillis();\n+\n+    Callable<Void> startupTask = () -> {\n+      jobManager.initialize();\n+\n+      Path tempDir = java.nio.file.Paths.get(\n+        cConf.get(io.cdap.cdap.common.conf.Constants.CFG_LOCAL_DATA_DIR),\n+        cConf.get(io.cdap.cdap.common.conf.Constants.AppFabric.TEMP_DIR)).toAbsolutePath();\n+      Path stagingDir = Files.createTempDirectory(tempDir, programRunId.getRun());\n+\n+      LoggingContext loggingContext = LoggingContextHelper.getLoggingContextWithRunId(\n+        programRunId, programOptions.getArguments().asMap());\n+      Cancellable cancelLoggingContext = LoggingContextAccessor.setLoggingContext(loggingContext);\n+\n+      try {\n+        Map<String, LocalFile> localFiles = new HashMap<>();\n+        createApplicationJar(createBundler(classAcceptor, stagingDir), localFiles);\n+        createResourcesJar(createBundler(classAcceptor, stagingDir), localFiles, stagingDir);\n+\n+        throwIfTimeout(startTime, timeout, timeoutUnit);\n+\n+        TwillRuntimeSpecification twillRuntimeSpec;\n+        Path runtimeConfigDir = Files.createTempDirectory(stagingDir, Constants.Files.RUNTIME_CONFIG_JAR);\n+        twillRuntimeSpec = saveSpecification(twillSpec,\n+                                             runtimeConfigDir.resolve(Constants.Files.TWILL_SPEC), stagingDir);\n+        RuntimeSpecification runtimeSpec = twillRuntimeSpec.getTwillSpecification().getRunnables().values()\n+          .stream().findFirst().orElseThrow(IllegalStateException::new);\n+        saveLogback(runtimeConfigDir.resolve(Constants.Files.LOGBACK_TEMPLATE));\n+        saveClassPaths(runtimeConfigDir);\n+        saveArguments(new Arguments(arguments, runnableArgs), runtimeConfigDir.resolve(Constants.Files.ARGUMENTS));\n+        createRuntimeConfigJar(runtimeConfigDir, localFiles, stagingDir);\n+        Paths.deleteRecursively(runtimeConfigDir);\n+\n+        throwIfTimeout(startTime, timeout, timeoutUnit);\n+        List<LocalFile> launcherFiles = new ArrayList<>();\n+\n+        for (Map.Entry<String, LocalFile> entry : localFiles.entrySet()) {\n+          launcherFiles.add(entry.getValue());\n+        }\n+\n+        for (LocalFile file : runtimeSpec.getLocalFiles()) {\n+          if (file.getName().equals(\"artifacts\")) {\n+            launcherFiles.add(new DefaultLocalFile(\"artifacts.jar\", file.getURI(), file.getLastModified(),\n+                                                   file.getSize(), file.isArchive(), file.getPattern()));\n+            continue;\n+          }\n+          if (file.getName().equals(\"artifacts_archive.jar\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 397}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwODk1MQ==", "bodyText": "stale comment? this is not applicable any more.", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r397308951", "createdAt": "2020-03-24T16:52:29Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillPreparer.java", "diffHunk": "@@ -0,0 +1,678 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.ListMultimap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.hash.Hasher;\n+import com.google.common.hash.Hashing;\n+import io.cdap.cdap.app.runtime.ProgramOptions;\n+import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.common.conf.CConfiguration;\n+import io.cdap.cdap.common.io.Locations;\n+import io.cdap.cdap.common.logging.LoggingContext;\n+import io.cdap.cdap.common.logging.LoggingContextAccessor;\n+import io.cdap.cdap.common.utils.DirUtils;\n+import io.cdap.cdap.internal.app.runtime.distributed.runtime.TwillControllerFactory;\n+import io.cdap.cdap.logging.context.LoggingContextHelper;\n+import io.cdap.cdap.proto.id.ProgramRunId;\n+import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n+import io.cdap.cdap.runtime.spi.runtimejob.RuntimeLocalFile;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.twill.api.ClassAcceptor;\n+import org.apache.twill.api.EventHandlerSpecification;\n+import org.apache.twill.api.LocalFile;\n+import org.apache.twill.api.RuntimeSpecification;\n+import org.apache.twill.api.SecureStore;\n+import org.apache.twill.api.TwillController;\n+import org.apache.twill.api.TwillPreparer;\n+import org.apache.twill.api.TwillRunnable;\n+import org.apache.twill.api.TwillSpecification;\n+import org.apache.twill.api.logging.LogEntry;\n+import org.apache.twill.api.logging.LogHandler;\n+import org.apache.twill.common.Cancellable;\n+import org.apache.twill.filesystem.Location;\n+import org.apache.twill.filesystem.LocationFactory;\n+import org.apache.twill.internal.ApplicationBundler;\n+import org.apache.twill.internal.Arguments;\n+import org.apache.twill.internal.Constants;\n+import org.apache.twill.internal.DefaultLocalFile;\n+import org.apache.twill.internal.DefaultRuntimeSpecification;\n+import org.apache.twill.internal.DefaultTwillSpecification;\n+import org.apache.twill.internal.LogOnlyEventHandler;\n+import org.apache.twill.internal.TwillRuntimeSpecification;\n+import org.apache.twill.internal.io.LocationCache;\n+import org.apache.twill.internal.json.ArgumentsCodec;\n+import org.apache.twill.internal.json.TwillRuntimeSpecificationAdapter;\n+import org.apache.twill.internal.utils.Paths;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+\n+/**\n+ *  A {@link TwillPreparer} implementation that uses runtime job manager to launch a single {@link TwillRunnable}.\n+ */\n+public class RuntimeJobTwillPreparer implements TwillPreparer {\n+  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillPreparer.class);\n+\n+  private final CConfiguration cConf;\n+  private final Configuration hConf;\n+  private final TwillSpecification twillSpec;\n+  private final ProgramRunId programRunId;\n+  private final ProgramOptions programOptions;\n+\n+  private final List<String> arguments = new ArrayList<>();\n+  private final Set<Class<?>> dependencies = Sets.newIdentityHashSet();\n+  private final List<URI> resources = new ArrayList<>();\n+  private final List<String> classPaths = new ArrayList<>();\n+  private final ListMultimap<String, String> runnableArgs = ArrayListMultimap.create();\n+  private final Map<String, Map<String, String>> environments = new HashMap<>();\n+  private final List<String> applicationClassPaths = new ArrayList<>();\n+  private final Map<String, Map<String, String>> logLevels = new HashMap<>();\n+  private final LocationCache locationCache;\n+  private final Map<String, Integer> maxRetries = new HashMap<>();\n+  private final Map<String, Map<String, String>> runnableConfigs = new HashMap<>();\n+  private final LocationFactory locationFactory;\n+  private final TwillControllerFactory controllerFactory;\n+  private final RuntimeJobManager jobManager;\n+\n+  private ClassAcceptor classAcceptor;\n+\n+  RuntimeJobTwillPreparer(CConfiguration cConf, Configuration hConf,\n+                          TwillSpecification twillSpec, ProgramRunId programRunId,\n+                          ProgramOptions programOptions, LocationCache locationCache,\n+                          LocationFactory locationFactory, TwillControllerFactory controllerFactory,\n+                          RuntimeJobManager jobManager) {\n+    // Check to prevent future mistake\n+    if (twillSpec.getRunnables().size() != 1) {\n+      throw new IllegalArgumentException(\"Only one TwillRunnable is supported\");\n+    }\n+\n+    this.cConf = cConf;\n+    this.hConf = hConf;\n+    this.twillSpec = twillSpec;\n+    this.programRunId = programRunId;\n+    this.programOptions = programOptions;\n+    this.classAcceptor = new ClassAcceptor();\n+    this.locationCache = locationCache;\n+    this.locationFactory = locationFactory;\n+    this.controllerFactory = controllerFactory;\n+    this.jobManager = jobManager;\n+  }\n+\n+  private void confirmRunnableName(String runnableName) {\n+    Preconditions.checkNotNull(runnableName);\n+    Preconditions.checkArgument(twillSpec.getRunnables().containsKey(runnableName),\n+                                \"Runnable %s is not defined in the application.\", runnableName);\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(Map<String, String> config) {\n+    config.forEach(hConf::set);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withConfiguration(String runnableName, Map<String, String> config) {\n+    confirmRunnableName(runnableName);\n+    runnableConfigs.put(runnableName, Maps.newHashMap(config));\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addLogHandler(LogHandler handler) {\n+    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setUser(String user) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setSchedulerQueue(String name) {\n+    LOG.trace(\"Scheduler queue is not supported for {}\", getClass().getSimpleName());\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setJVMOptions(String runnableName, String options) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addJVMOptions(String options) {\n+    Preconditions.checkArgument(options != null, \"JVM options cannot be null.\");\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(String... runnables) {\n+    return enableDebugging(false, runnables);\n+  }\n+\n+  @Override\n+  public TwillPreparer enableDebugging(boolean doSuspend, String... runnables) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(String... args) {\n+    return withApplicationArguments(Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationArguments(Iterable<String> args) {\n+    Iterables.addAll(arguments, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, String... args) {\n+    return withArguments(runnableName, Arrays.asList(args));\n+  }\n+\n+  @Override\n+  public TwillPreparer withArguments(String runnableName, Iterable<String> args) {\n+    confirmRunnableName(runnableName);\n+    runnableArgs.putAll(runnableName, args);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Class<?>... classes) {\n+    return withDependencies(Arrays.asList(classes));\n+  }\n+\n+  @Override\n+  public TwillPreparer withDependencies(Iterable<Class<?>> classes) {\n+    Iterables.addAll(dependencies, classes);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(URI... resources) {\n+    return withResources(Arrays.asList(resources));\n+  }\n+\n+  @Override\n+  public TwillPreparer withResources(Iterable<URI> resources) {\n+    Iterables.addAll(this.resources, resources);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(String... classPaths) {\n+    return withClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.classPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(Map<String, String> env) {\n+    // Add the given environments to all runnables\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      setEnv(runnableName, env, false);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withEnv(String runnableName, Map<String, String> env) {\n+    confirmRunnableName(runnableName);\n+    setEnv(runnableName, env, true);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(String... classPaths) {\n+    return withApplicationClassPaths(Arrays.asList(classPaths));\n+  }\n+\n+  @Override\n+  public TwillPreparer withApplicationClassPaths(Iterable<String> classPaths) {\n+    Iterables.addAll(this.applicationClassPaths, classPaths);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withBundlerClassAcceptor(ClassAcceptor classAcceptor) {\n+    this.classAcceptor = classAcceptor;\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer withMaxRetries(String runnableName, int maxRetries) {\n+    confirmRunnableName(runnableName);\n+    this.maxRetries.put(runnableName, maxRetries);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer addSecureStore(SecureStore secureStore) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevel(LogEntry.Level logLevel) {\n+    return setLogLevels(Collections.singletonMap(Logger.ROOT_LOGGER_NAME, logLevel));\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(Map<String, LogEntry.Level> logLevels) {\n+    Preconditions.checkNotNull(logLevels);\n+    for (String runnableName : twillSpec.getRunnables().keySet()) {\n+      saveLogLevels(runnableName, logLevels);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setLogLevels(String runnableName, Map<String, LogEntry.Level> runnableLogLevels) {\n+    confirmRunnableName(runnableName);\n+    Preconditions.checkNotNull(runnableLogLevels);\n+    Preconditions.checkArgument(!(logLevels.containsKey(Logger.ROOT_LOGGER_NAME)\n+      && logLevels.get(Logger.ROOT_LOGGER_NAME) == null));\n+    saveLogLevels(runnableName, runnableLogLevels);\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillPreparer setClassLoader(String classLoaderClassName) {\n+    return this;\n+  }\n+\n+  @Override\n+  public TwillController start() {\n+    return start(Constants.APPLICATION_MAX_START_SECONDS, TimeUnit.SECONDS);\n+  }\n+\n+  @Override\n+  public TwillController start(long timeout, TimeUnit timeoutUnit) {\n+    long startTime = System.currentTimeMillis();\n+\n+    Callable<Void> startupTask = () -> {\n+      jobManager.initialize();\n+\n+      Path tempDir = java.nio.file.Paths.get(\n+        cConf.get(io.cdap.cdap.common.conf.Constants.CFG_LOCAL_DATA_DIR),\n+        cConf.get(io.cdap.cdap.common.conf.Constants.AppFabric.TEMP_DIR)).toAbsolutePath();\n+      Path stagingDir = Files.createTempDirectory(tempDir, programRunId.getRun());\n+\n+      LoggingContext loggingContext = LoggingContextHelper.getLoggingContextWithRunId(\n+        programRunId, programOptions.getArguments().asMap());\n+      Cancellable cancelLoggingContext = LoggingContextAccessor.setLoggingContext(loggingContext);\n+\n+      try {\n+        Map<String, LocalFile> localFiles = new HashMap<>();\n+        createApplicationJar(createBundler(classAcceptor, stagingDir), localFiles);\n+        createResourcesJar(createBundler(classAcceptor, stagingDir), localFiles, stagingDir);\n+\n+        throwIfTimeout(startTime, timeout, timeoutUnit);\n+\n+        TwillRuntimeSpecification twillRuntimeSpec;\n+        Path runtimeConfigDir = Files.createTempDirectory(stagingDir, Constants.Files.RUNTIME_CONFIG_JAR);\n+        twillRuntimeSpec = saveSpecification(twillSpec,\n+                                             runtimeConfigDir.resolve(Constants.Files.TWILL_SPEC), stagingDir);\n+        RuntimeSpecification runtimeSpec = twillRuntimeSpec.getTwillSpecification().getRunnables().values()\n+          .stream().findFirst().orElseThrow(IllegalStateException::new);\n+        saveLogback(runtimeConfigDir.resolve(Constants.Files.LOGBACK_TEMPLATE));\n+        saveClassPaths(runtimeConfigDir);\n+        saveArguments(new Arguments(arguments, runnableArgs), runtimeConfigDir.resolve(Constants.Files.ARGUMENTS));\n+        createRuntimeConfigJar(runtimeConfigDir, localFiles, stagingDir);\n+        Paths.deleteRecursively(runtimeConfigDir);\n+\n+        throwIfTimeout(startTime, timeout, timeoutUnit);\n+        List<LocalFile> launcherFiles = new ArrayList<>();\n+\n+        for (Map.Entry<String, LocalFile> entry : localFiles.entrySet()) {\n+          launcherFiles.add(entry.getValue());\n+        }\n+\n+        for (LocalFile file : runtimeSpec.getLocalFiles()) {\n+          if (file.getName().equals(\"artifacts\")) {\n+            launcherFiles.add(new DefaultLocalFile(\"artifacts.jar\", file.getURI(), file.getLastModified(),\n+                                                   file.getSize(), file.isArchive(), file.getPattern()));\n+            continue;\n+          }\n+          if (file.getName().equals(\"artifacts_archive.jar\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0NjA2MQ=="}, "originalCommit": {"oid": "3b474b303d7a005f1b21fb3a3d17a77c68b9618d"}, "originalPosition": 397}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjQ2MzU4OnYy", "diffSide": "RIGHT", "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0Njo1NVrOF_R-pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDo0OTozMVrOF_SD7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5OTE3Mg==", "bodyText": "who is responsible for calling jobManager.kill?", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r401899172", "createdAt": "2020-04-01T20:46:55Z", "author": {"login": "CuriousVini"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "diffHunk": "@@ -16,222 +16,66 @@\n \n package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n \n-import com.google.common.base.Throwables;\n-import com.google.common.util.concurrent.Futures;\n-import com.google.common.util.concurrent.Uninterruptibles;\n-import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.internal.app.runtime.distributed.AbstractRuntimeTwillController;\n import io.cdap.cdap.proto.id.ProgramRunId;\n import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n-import org.apache.twill.api.Command;\n-import org.apache.twill.api.ResourceReport;\n-import org.apache.twill.api.RunId;\n import org.apache.twill.api.ServiceController;\n import org.apache.twill.api.TwillController;\n-import org.apache.twill.api.logging.LogEntry;\n-import org.apache.twill.api.logging.LogHandler;\n-import org.apache.twill.discovery.ServiceDiscovered;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Executor;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import javax.annotation.Nullable;\n \n /**\n  * Implementation of {@link TwillController} that uses {@link RuntimeJobManager} to monitor and\n  * control a running program.\n  */\n-class RuntimeJobTwillController implements TwillController {\n-  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillController.class);\n+class RuntimeJobTwillController extends AbstractRuntimeTwillController {\n \n-  private final RunId runId;\n-  private final ProgramRunId programRunId;\n   private final RuntimeJobManager jobManager;\n-  private final CompletableFuture<RuntimeJobTwillController> started;\n-  private final CompletableFuture<RuntimeJobTwillController> completion;\n-  private final AtomicBoolean terminateCalled;\n+  private final ExecutorService executor;\n+  private final ProgramRunInfo programRunInfo;\n \n-  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId) {\n-    this.programRunId = programRunId;\n-    this.runId = RunIds.fromString(programRunId.getRun());\n+  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId,\n+                            CompletionStage<?> startupCompletionStage, ExecutorService executor) {\n+    super(programRunId, startupCompletionStage);\n     this.jobManager = jobManager;\n-    this.started = new CompletableFuture<>();\n-    this.completion = new CompletableFuture<>();\n-    this.terminateCalled = new AtomicBoolean();\n+    this.executor = executor;\n+    this.programRunInfo = new ProgramRunInfo.Builder()\n+      .setNamespace(programRunId.getNamespace())\n+      .setApplication(programRunId.getApplication())\n+      .setProgram(programRunId.getProgram())\n+      .setProgramType(programRunId.getType().getPrettyName())\n+      .setRun(programRunId.getRun()).build();\n   }\n \n   RuntimeJobManager getJobManager() {\n     return jobManager;\n   }\n \n-  void start(CompletableFuture<Void> startupTaskCompletion) {\n-    startupTaskCompletion.whenComplete((res, throwable) -> {\n-      if (throwable == null) {\n-        started.complete(this);\n-      } else {\n-        // terminate this controller with fail state\n-        completion.completeExceptionally(throwable);\n-      }\n-    });\n-  }\n-\n-  @Override\n-  public void addLogHandler(LogHandler handler) {\n-    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n-  }\n-\n-  @Override\n-  public ServiceDiscovered discoverService(String serviceName) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<Integer> changeInstances(String runnable, int newCount) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Nullable\n-  @Override\n-  public ResourceReport getResourceReport() {\n-    return null;\n-  }\n-\n-  @Override\n-  public Future<String> restartAllInstances(String runnable) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<Set<String>> restartInstances(Map<String, ? extends Set<Integer>> runnableToInstanceIds) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<String> restartInstances(String runnable, int instanceId, int... moreInstanceIds) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<String> restartInstances(String runnable, Set<Integer> instanceIds) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<Map<String, LogEntry.Level>> updateLogLevels(Map<String, LogEntry.Level> logLevels) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"updateLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<Map<String, LogEntry.Level>> updateLogLevels(String runnableName,\n-                                                             Map<String, LogEntry.Level> logLevelsForRunnable) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"updateLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<String[]> resetLogLevels(String... loggerNames) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"resetLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<String[]> resetRunnableLogLevels(String runnableName, String... loggerNames) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"resetRunnableLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public RunId getRunId() {\n-    return runId;\n-  }\n-\n-  @Override\n-  public Future<Command> sendCommand(Command command) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"sendCommand is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<Command> sendCommand(String runnableName, Command command) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"sendCommand is not supported\"));\n-  }\n-\n-  @Override\n-  public void onRunning(Runnable runnable, Executor executor) {\n-    started.thenRunAsync(runnable, executor);\n-  }\n-\n-  @Override\n-  public void onTerminated(Runnable runnable, Executor executor) {\n-    completion.whenCompleteAsync((remoteExecutionTwillController, throwable) -> runnable.run(), executor);\n-  }\n-\n-  @Override\n-  public void awaitTerminated() throws ExecutionException {\n-    Uninterruptibles.getUninterruptibly(completion);\n-  }\n-\n-  @Override\n-  public void awaitTerminated(long timeout, TimeUnit timeoutUnit) throws TimeoutException, ExecutionException {\n-    Uninterruptibles.getUninterruptibly(completion, timeout, timeoutUnit);\n-  }\n-\n   @Override\n   public Future<? extends ServiceController> terminate() {\n-    if (terminateCalled.compareAndSet(false, true)) {\n-      try {\n-        // stop the job\n-        jobManager.stop(new ProgramRunInfo.Builder()\n-                          .setNamespace(programRunId.getNamespace())\n-                          .setApplication(programRunId.getApplication())\n-                          .setProgram(programRunId.getProgram())\n-                          .setProgramType(programRunId.getType().getPrettyName())\n-                          .setRun(programRunId.getRun()).build());\n-        // mark completion as completed\n-        completion.complete(this);\n-      } catch (Exception e) {\n-        completion.completeExceptionally(e);\n-      }\n+    if (getTerminationFuture().isDone()) {\n+      return CompletableFuture.completedFuture(this);\n     }\n-    return completion;\n-  }\n \n-  @Override\n-  public void kill() {\n-    if (terminateCalled.compareAndSet(false, true)) {\n+    CompletableFuture<TwillController> result = getTerminationFuture().thenApply(r -> r);\n+    executor.execute(() -> {\n       try {\n-        // stop the job\n-        jobManager.kill(new ProgramRunInfo.Builder()\n-                          .setNamespace(programRunId.getNamespace())\n-                          .setApplication(programRunId.getApplication())\n-                          .setProgram(programRunId.getProgram())\n-                          .setProgramType(programRunId.getType().getPrettyName())\n-                          .setRun(programRunId.getRun()).build());\n-        // mark completion as completed\n-        completion.complete(this);\n+        if (jobManager.getDetail(programRunInfo).isPresent()) {\n+          // stop the job\n+          jobManager.stop(programRunInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00db1497e9dc80ba381271df92cb0b9f54da92ca"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMDUyNw==", "bodyText": "oh right. Missed that during refactoring", "url": "https://github.com/cdapio/cdap/pull/11977#discussion_r401900527", "createdAt": "2020-04-01T20:49:31Z", "author": {"login": "chtyim"}, "path": "cdap-app-fabric/src/main/java/io/cdap/cdap/internal/app/runtime/distributed/runtimejob/RuntimeJobTwillController.java", "diffHunk": "@@ -16,222 +16,66 @@\n \n package io.cdap.cdap.internal.app.runtime.distributed.runtimejob;\n \n-import com.google.common.base.Throwables;\n-import com.google.common.util.concurrent.Futures;\n-import com.google.common.util.concurrent.Uninterruptibles;\n-import io.cdap.cdap.common.app.RunIds;\n+import io.cdap.cdap.internal.app.runtime.distributed.AbstractRuntimeTwillController;\n import io.cdap.cdap.proto.id.ProgramRunId;\n import io.cdap.cdap.runtime.spi.runtimejob.ProgramRunInfo;\n import io.cdap.cdap.runtime.spi.runtimejob.RuntimeJobManager;\n-import org.apache.twill.api.Command;\n-import org.apache.twill.api.ResourceReport;\n-import org.apache.twill.api.RunId;\n import org.apache.twill.api.ServiceController;\n import org.apache.twill.api.TwillController;\n-import org.apache.twill.api.logging.LogEntry;\n-import org.apache.twill.api.logging.LogHandler;\n-import org.apache.twill.discovery.ServiceDiscovered;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import java.util.Map;\n-import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Executor;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import javax.annotation.Nullable;\n \n /**\n  * Implementation of {@link TwillController} that uses {@link RuntimeJobManager} to monitor and\n  * control a running program.\n  */\n-class RuntimeJobTwillController implements TwillController {\n-  private static final Logger LOG = LoggerFactory.getLogger(RuntimeJobTwillController.class);\n+class RuntimeJobTwillController extends AbstractRuntimeTwillController {\n \n-  private final RunId runId;\n-  private final ProgramRunId programRunId;\n   private final RuntimeJobManager jobManager;\n-  private final CompletableFuture<RuntimeJobTwillController> started;\n-  private final CompletableFuture<RuntimeJobTwillController> completion;\n-  private final AtomicBoolean terminateCalled;\n+  private final ExecutorService executor;\n+  private final ProgramRunInfo programRunInfo;\n \n-  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId) {\n-    this.programRunId = programRunId;\n-    this.runId = RunIds.fromString(programRunId.getRun());\n+  RuntimeJobTwillController(RuntimeJobManager jobManager, ProgramRunId programRunId,\n+                            CompletionStage<?> startupCompletionStage, ExecutorService executor) {\n+    super(programRunId, startupCompletionStage);\n     this.jobManager = jobManager;\n-    this.started = new CompletableFuture<>();\n-    this.completion = new CompletableFuture<>();\n-    this.terminateCalled = new AtomicBoolean();\n+    this.executor = executor;\n+    this.programRunInfo = new ProgramRunInfo.Builder()\n+      .setNamespace(programRunId.getNamespace())\n+      .setApplication(programRunId.getApplication())\n+      .setProgram(programRunId.getProgram())\n+      .setProgramType(programRunId.getType().getPrettyName())\n+      .setRun(programRunId.getRun()).build();\n   }\n \n   RuntimeJobManager getJobManager() {\n     return jobManager;\n   }\n \n-  void start(CompletableFuture<Void> startupTaskCompletion) {\n-    startupTaskCompletion.whenComplete((res, throwable) -> {\n-      if (throwable == null) {\n-        started.complete(this);\n-      } else {\n-        // terminate this controller with fail state\n-        completion.completeExceptionally(throwable);\n-      }\n-    });\n-  }\n-\n-  @Override\n-  public void addLogHandler(LogHandler handler) {\n-    LOG.trace(\"LogHandler is not supported for {}\", getClass().getSimpleName());\n-  }\n-\n-  @Override\n-  public ServiceDiscovered discoverService(String serviceName) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<Integer> changeInstances(String runnable, int newCount) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Nullable\n-  @Override\n-  public ResourceReport getResourceReport() {\n-    return null;\n-  }\n-\n-  @Override\n-  public Future<String> restartAllInstances(String runnable) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<Set<String>> restartInstances(Map<String, ? extends Set<Integer>> runnableToInstanceIds) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<String> restartInstances(String runnable, int instanceId, int... moreInstanceIds) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<String> restartInstances(String runnable, Set<Integer> instanceIds) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Future<Map<String, LogEntry.Level>> updateLogLevels(Map<String, LogEntry.Level> logLevels) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"updateLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<Map<String, LogEntry.Level>> updateLogLevels(String runnableName,\n-                                                             Map<String, LogEntry.Level> logLevelsForRunnable) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"updateLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<String[]> resetLogLevels(String... loggerNames) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"resetLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<String[]> resetRunnableLogLevels(String runnableName, String... loggerNames) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"resetRunnableLogLevels is not supported\"));\n-  }\n-\n-  @Override\n-  public RunId getRunId() {\n-    return runId;\n-  }\n-\n-  @Override\n-  public Future<Command> sendCommand(Command command) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"sendCommand is not supported\"));\n-  }\n-\n-  @Override\n-  public Future<Command> sendCommand(String runnableName, Command command) {\n-    return Futures.immediateFailedFuture(new UnsupportedOperationException(\"sendCommand is not supported\"));\n-  }\n-\n-  @Override\n-  public void onRunning(Runnable runnable, Executor executor) {\n-    started.thenRunAsync(runnable, executor);\n-  }\n-\n-  @Override\n-  public void onTerminated(Runnable runnable, Executor executor) {\n-    completion.whenCompleteAsync((remoteExecutionTwillController, throwable) -> runnable.run(), executor);\n-  }\n-\n-  @Override\n-  public void awaitTerminated() throws ExecutionException {\n-    Uninterruptibles.getUninterruptibly(completion);\n-  }\n-\n-  @Override\n-  public void awaitTerminated(long timeout, TimeUnit timeoutUnit) throws TimeoutException, ExecutionException {\n-    Uninterruptibles.getUninterruptibly(completion, timeout, timeoutUnit);\n-  }\n-\n   @Override\n   public Future<? extends ServiceController> terminate() {\n-    if (terminateCalled.compareAndSet(false, true)) {\n-      try {\n-        // stop the job\n-        jobManager.stop(new ProgramRunInfo.Builder()\n-                          .setNamespace(programRunId.getNamespace())\n-                          .setApplication(programRunId.getApplication())\n-                          .setProgram(programRunId.getProgram())\n-                          .setProgramType(programRunId.getType().getPrettyName())\n-                          .setRun(programRunId.getRun()).build());\n-        // mark completion as completed\n-        completion.complete(this);\n-      } catch (Exception e) {\n-        completion.completeExceptionally(e);\n-      }\n+    if (getTerminationFuture().isDone()) {\n+      return CompletableFuture.completedFuture(this);\n     }\n-    return completion;\n-  }\n \n-  @Override\n-  public void kill() {\n-    if (terminateCalled.compareAndSet(false, true)) {\n+    CompletableFuture<TwillController> result = getTerminationFuture().thenApply(r -> r);\n+    executor.execute(() -> {\n       try {\n-        // stop the job\n-        jobManager.kill(new ProgramRunInfo.Builder()\n-                          .setNamespace(programRunId.getNamespace())\n-                          .setApplication(programRunId.getApplication())\n-                          .setProgram(programRunId.getProgram())\n-                          .setProgramType(programRunId.getType().getPrettyName())\n-                          .setRun(programRunId.getRun()).build());\n-        // mark completion as completed\n-        completion.complete(this);\n+        if (jobManager.getDetail(programRunInfo).isPresent()) {\n+          // stop the job\n+          jobManager.stop(programRunInfo);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5OTE3Mg=="}, "originalCommit": {"oid": "00db1497e9dc80ba381271df92cb0b9f54da92ca"}, "originalPosition": 223}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2847, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}