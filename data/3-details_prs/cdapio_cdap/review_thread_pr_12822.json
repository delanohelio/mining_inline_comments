{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5Mjk1MTQ0", "number": 12822, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTozNTo0NVrOExbRNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzozOTozOFrOEy7aCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjYyNDU1OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTozNTo0NVrOHnjnGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzozMDo0N1rOHpIQ_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIzOTk2MA==", "bodyText": "This should be an optional rewrite controlled by cdap-site.xml", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511239960", "createdAt": "2020-10-24T01:35:45Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +231,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg4NjQzOA==", "bodyText": "@chtyim Should this feature be enabled or disabled by default?", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512886438", "createdAt": "2020-10-27T17:27:39Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +231,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIzOTk2MA=="}, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg4OTA4NA==", "bodyText": "disable", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512889084", "createdAt": "2020-10-27T17:30:47Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +231,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIzOTk2MA=="}, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjYyNTIwOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTozNjowMFrOHnjnjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTozNjowMFrOHnjnjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MDA3Nw==", "bodyText": "No need to have final", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511240077", "createdAt": "2020-10-24T01:36:00Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjYyNzg3OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTozNjo0OVrOHnjpeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTozNjo0OVrOHnjpeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MDU2OQ==", "bodyText": "Why need the full class name? It can be just String.class.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511240569", "createdAt": "2020-10-24T01:36:49Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjYyOTIyOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTozNzoxNFrOHnjqWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTozNzoxNFrOHnjqWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MDc5Mg==", "bodyText": "Same here. Can be just StringBuilder.class", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511240792", "createdAt": "2020-10-24T01:37:14Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);\n+    final Type stringBuilderType = Type.getType(java.lang.StringBuilder.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjYzODE3OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTo0MDo1M1rOHnjwjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzozODo0MVrOHpIqJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MjM4Mw==", "bodyText": "Should compare with the method signature.\nMethod method = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, StringType });\n...\nif (method.equals(new Method(name, desc))) {\n   // Matched\n}", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511242383", "createdAt": "2020-10-24T01:40:53Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);\n+    final Type stringBuilderType = Type.getType(java.lang.StringBuilder.class);\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&\n+              name.equals(\"<init>\") &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0Mjg5MA==", "bodyText": "Also, I would suggest check if the previous instruction was a LDC \"temp\". We don't want to rewrite if the second parameter is not the constant string \"temp\"", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511242890", "createdAt": "2020-10-24T01:42:05Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);\n+    final Type stringBuilderType = Type.getType(java.lang.StringBuilder.class);\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&\n+              name.equals(\"<init>\") &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MjM4Mw=="}, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5NTUyNg==", "bodyText": "@chtyim I have added logic to check wether the previous instruction to the Path constructor call is the LDC \"temp\" instruction.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512895526", "createdAt": "2020-10-27T17:38:41Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);\n+    final Type stringBuilderType = Type.getType(java.lang.StringBuilder.class);\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&\n+              name.equals(\"<init>\") &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MjM4Mw=="}, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjY0NjExOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTo0Mzo0N1rOHnj1zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTo0Mzo0N1rOHnj1zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0MzcyNg==", "bodyText": "Use the checkpointTime field instead of System.currentTimeMillis.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511243726", "createdAt": "2020-10-24T01:43:47Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);\n+    final Type stringBuilderType = Type.getType(java.lang.StringBuilder.class);\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&\n+              name.equals(\"<init>\") &&\n+              Type.getObjectType(owner).equals(hadoopPathType) &&\n+              Type.getArgumentTypes(desc).length == 2 &&\n+              stringType.equals(Type.getArgumentTypes(desc)[0]) &&\n+              stringType.equals(Type.getArgumentTypes(desc)[1])) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              super.visitInsn(Opcodes.POP);\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjY0OTIxOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTo0NDo0N1rOHnj3xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMTo0NDo0N1rOHnj3xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI0NDIzMQ==", "bodyText": "For generating code, it's easier to use GeneratorAdapter instead of MethodVisitor directly.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r511244231", "createdAt": "2020-10-24T01:44:47Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,78 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    final Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    final Type stringType = Type.getType(java.lang.String.class);\n+    final Type stringBuilderType = Type.getType(java.lang.StringBuilder.class);\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc8ed4b218f543dbb169d7e43de4bd17d016628a"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMzU4NDQyOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzozNDo1NFrOHpIeWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzozNDo1NFrOHpIeWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5MjUwNg==", "bodyText": "no need to have final", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512892506", "createdAt": "2020-10-27T17:34:54Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMzU4NzExOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzozNToyM1rOHpIgFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozMTo0M1rOHpRy0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5Mjk0OA==", "bodyText": "Move this as a simple boolean field in the returned inner class.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512892948", "createdAt": "2020-10-27T17:35:23Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0NTIwMQ==", "bodyText": "Done.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513045201", "createdAt": "2020-10-27T21:31:43Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5Mjk0OA=="}, "originalCommit": {"oid": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMzU5MjE3OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzozNjoyNlrOHpIjdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozMTozNVrOHpRynQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5MzgxMw==", "bodyText": "It is dangerous to pass the mv to two different MethodVisitor (one to the adapter above, one here). It is better to just return a new GeneratorAdapter here.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512893813", "createdAt": "2020-10-27T17:36:26Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0NTE0OQ==", "bodyText": "Made some changes to return a new GeneratorAdapter.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513045149", "createdAt": "2020-10-27T21:31:35Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5MzgxMw=="}, "originalCommit": {"oid": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMzYxOTY2OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzo0MjowMFrOHpI0qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzo0MjowMFrOHpI0qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5ODIxOA==", "bodyText": "The && should be on the next line. See https://www.oracle.com/java/technologies/javase/codeconventions-indentation.html#248", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512898218", "createdAt": "2020-10-27T17:42:00Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            if (\"temp\".equals(value)) {\n+              tempStringAddedToStack.set(true);\n+            }\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMzY5MzA1OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzo1Njo1NVrOHpJiqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozMToxNVrOHpRx5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwOTk5Mw==", "bodyText": "Should document how the source code looks like. The bytecode is already as part of the code down below, no need to repeat that.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512909993", "createdAt": "2020-10-27T17:56:55Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            if (\"temp\".equals(value)) {\n+              tempStringAddedToStack.set(true);\n+            }\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&\n+              Type.getObjectType(owner).equals(hadoopPathType) &&\n+              constructor.equals(new Method(name, desc)) &&\n+              tempStringAddedToStack.get()) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              //super.visitInsn(Opcodes.POP);\n+              adapter.pop();\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.\n+              //Bytecode is:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0NDk2Nw==", "bodyText": "Done.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513044967", "createdAt": "2020-10-27T21:31:15Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            if (\"temp\".equals(value)) {\n+              tempStringAddedToStack.set(true);\n+            }\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL &&\n+              Type.getObjectType(owner).equals(hadoopPathType) &&\n+              constructor.equals(new Method(name, desc)) &&\n+              tempStringAddedToStack.get()) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              //super.visitInsn(Opcodes.POP);\n+              adapter.pop();\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.\n+              //Bytecode is:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwOTk5Mw=="}, "originalCommit": {"oid": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMzcwMTc1OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNzo1ODo0NVrOHpJoYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTozMTowMlrOHpRxbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkxMTQ1OQ==", "bodyText": "You should reset it to false when the value is not \"temp\".", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r512911459", "createdAt": "2020-10-27T17:58:45Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            if (\"temp\".equals(value)) {\n+              tempStringAddedToStack.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0NDg0Nw==", "bodyText": "Done.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513044847", "createdAt": "2020-10-27T21:31:02Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +669,108 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+        final GeneratorAdapter adapter = new GeneratorAdapter(mv, access, name, desc);\n+        final AtomicBoolean tempStringAddedToStack = new AtomicBoolean(false);\n+\n+        final Method constructor = new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+        return new MethodVisitor(Opcodes.ASM5, mv) {\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            if (\"temp\".equals(value)) {\n+              tempStringAddedToStack.set(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkxMTQ1OQ=="}, "originalCommit": {"oid": "ab46351a8ecb271d80f9169e2ee8dc1c9f06499b"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDk4NTQ0OnYy", "diffSide": "RIGHT", "path": "cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDozNTo1MFrOHpV2-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoyNTozMFrOHp1dlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMTgwMA==", "bodyText": "Since these constants are only used in the Spark runtime, I would suggest moving them to the SparkRuntimeUtils class.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513111800", "createdAt": "2020-10-28T00:35:50Z", "author": {"login": "chtyim"}, "path": "cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java", "diffHunk": "@@ -1492,4 +1492,13 @@\n      */\n     public static final String UPDATE_ALLOWED = PREFIX + \"update.allowed\";\n   }\n+\n+  /**\n+   * Constants for streaming", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyOTU5MQ==", "bodyText": "Done!", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513629591", "createdAt": "2020-10-28T17:25:30Z", "author": {"login": "fernst"}, "path": "cdap-common/src/main/java/io/cdap/cdap/common/conf/Constants.java", "diffHunk": "@@ -1492,4 +1492,13 @@\n      */\n     public static final String UPDATE_ALLOWED = PREFIX + \"update.allowed\";\n   }\n+\n+  /**\n+   * Constants for streaming", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMTgwMA=="}, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDk4Nzg1OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkProgramRuntimeProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDozNzoxNFrOHpV4aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoyNTozNVrOHp1dyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjE3MQ==", "bodyText": "Better get the CConfiguration instance once as a local variable and use it throughout this method.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513112171", "createdAt": "2020-10-28T00:37:14Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkProgramRuntimeProvider.java", "diffHunk": "@@ -90,6 +90,10 @@ public ProgramRunner createProgramRunner(ProgramType type, Mode mode, Injector i\n     Preconditions.checkArgument(type == ProgramType.SPARK, \"Unsupported program type %s. Only %s is supported\",\n                                 type, ProgramType.SPARK);\n \n+    boolean rewriteCheckpointTempFileName = injector.getInstance(CConfiguration.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyOTY0Mw==", "bodyText": "Done!", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513629643", "createdAt": "2020-10-28T17:25:35Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkProgramRuntimeProvider.java", "diffHunk": "@@ -90,6 +90,10 @@ public ProgramRunner createProgramRunner(ProgramType type, Mode mode, Injector i\n     Preconditions.checkArgument(type == ProgramType.SPARK, \"Unsupported program type %s. Only %s is supported\",\n                                 type, ProgramType.SPARK);\n \n+    boolean rewriteCheckpointTempFileName = injector.getInstance(CConfiguration.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjE3MQ=="}, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDk5MzM3OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0MDowMFrOHpV7mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoyNTo0NVrOHp1eNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjk4NQ==", "bodyText": "I would check the boolean first for a faster short circuit", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513112985", "createdAt": "2020-10-28T00:40:00Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +234,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName()) && rewriteCheckpointTempFileName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEyNjczNw==", "bodyText": "Good point. I wanted to keep it consistent with https://github.com/cdapio/cdap/blob/develop/cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java#L188", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513126737", "createdAt": "2020-10-28T01:30:30Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +234,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName()) && rewriteCheckpointTempFileName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjk4NQ=="}, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEyNzAxMw==", "bodyText": "Maybe worth changing both places", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513127013", "createdAt": "2020-10-28T01:31:35Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +234,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName()) && rewriteCheckpointTempFileName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjk4NQ=="}, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyOTc0OA==", "bodyText": "Done!", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513629748", "createdAt": "2020-10-28T17:25:45Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +234,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName()) && rewriteCheckpointTempFileName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjk4NQ=="}, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDk5NDIwOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0MDoyOFrOHpV8HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoyNTo1MlrOHp1eog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzExNw==", "bodyText": "typo: checkpoints", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513113117", "createdAt": "2020-10-28T00:40:28Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +234,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName()) && rewriteCheckpointTempFileName) {\n+      // Rewrite the Spark CheckpointWriteHandler to add a timestamp to the temporary file used for theckpoints.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyOTg1OA==", "bodyText": "Fixed,", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513629858", "createdAt": "2020-10-28T17:25:52Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -229,6 +234,10 @@ public SparkClassRewriter(Function<String, InputStream> resourceLookup, boolean\n       // Rewrite the Spark OutputMetrics to skip overwriting bytes written metrics with 0.\n       return rewriteOutputMetrics(SPARK_OUTPUT_METRICS, input);\n     }\n+    if (className.startsWith(CHECKPOINT_WRITE_HANDLER_TYPE.getClassName()) && rewriteCheckpointTempFileName) {\n+      // Rewrite the Spark CheckpointWriteHandler to add a timestamp to the temporary file used for theckpoints.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzExNw=="}, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDk5NTgxOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0MTozMFrOHpV9Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoyNjowN1rOHp1fcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzM2Mw==", "bodyText": "You are using the checkpoint time instead of the current timestamp, right?", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513113363", "createdAt": "2020-10-28T00:41:30Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMDA2Nw==", "bodyText": "Correct. I've updated the comment.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513630067", "createdAt": "2020-10-28T17:26:07Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzM2Mw=="}, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDk5ODM2OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0Mjo1OVrOHpV-mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoyNjoxM1rOHp1fxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzc1Mg==", "bodyText": "You need to override the visitField  of the ClassWriter to make sure this class actually has this field. Otherwise you can result in cryptic classloading failure", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513113752", "createdAt": "2020-10-28T00:42:59Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            tempStringAddedToStack = \"temp\".equals(value);\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL\n+              && Type.getObjectType(owner).equals(hadoopPathType)\n+              && hadoopPathConstructorMethod.equals(new Method(name, desc))\n+              && tempStringAddedToStack) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              //super.visitInsn(Opcodes.POP);\n+              pop();\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.\n+              //This function generates the following code:\n+              //  new StringBuilder().append(\"temp-\").append(checkpointTime.milliseconds()).toString();\n+              newInstance(stringBuilderType);\n+              dup();\n+              invokeConstructor(stringBuilderType, Methods.getMethod(void.class, \"<init>\"));\n+              push(\"temp-\");\n+              invokeVirtual(stringBuilderType,\n+                            new Method(\"append\", stringBuilderType, new Type[]{stringType}));\n+              loadThis();\n+              getField(CHECKPOINT_WRITE_HANDLER_TYPE, checkpointTimeFieldName, timeType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMDE0OQ==", "bodyText": "Done!", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513630149", "createdAt": "2020-10-28T17:26:13Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            tempStringAddedToStack = \"temp\".equals(value);\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL\n+              && Type.getObjectType(owner).equals(hadoopPathType)\n+              && hadoopPathConstructorMethod.equals(new Method(name, desc))\n+              && tempStringAddedToStack) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              //super.visitInsn(Opcodes.POP);\n+              pop();\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.\n+              //This function generates the following code:\n+              //  new StringBuilder().append(\"temp-\").append(checkpointTime.milliseconds()).toString();\n+              newInstance(stringBuilderType);\n+              dup();\n+              invokeConstructor(stringBuilderType, Methods.getMethod(void.class, \"<init>\"));\n+              push(\"temp-\");\n+              invokeVirtual(stringBuilderType,\n+                            new Method(\"append\", stringBuilderType, new Type[]{stringType}));\n+              loadThis();\n+              getField(CHECKPOINT_WRITE_HANDLER_TYPE, checkpointTimeFieldName, timeType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMzc1Mg=="}, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTAwMDE4OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0NDowM1rOHpV_vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoyNjoyNVrOHp1gUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNDA0NQ==", "bodyText": "This class shouldn't reference Spark or Hadoop classes via .class. See https://github.com/cdapio/cdap/blob/develop/cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java#L80\nOnly classes from the bootstrap classloader (i.e JRE classes) can be referenced with .class.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513114045", "createdAt": "2020-10-28T00:44:03Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMDI5MA==", "bodyText": "Done!", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513630290", "createdAt": "2020-10-28T17:26:25Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNDA0NQ=="}, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTAwMjU4OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0NToxM1rOHpWBDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0NToxM1rOHpWBDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNDM4Mg==", "bodyText": "Remove extra empty line", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513114382", "createdAt": "2020-10-28T00:45:13Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            tempStringAddedToStack = \"temp\".equals(value);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTAwNDQwOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0NjoxN1rOHpWCJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0NjoxN1rOHpWCJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNDY2MA==", "bodyText": "Please update the comment. I think you are using checkpointTime.milliseconds(), right?", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513114660", "createdAt": "2020-10-28T00:46:17Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            tempStringAddedToStack = \"temp\".equals(value);\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL\n+              && Type.getObjectType(owner).equals(hadoopPathType)\n+              && hadoopPathConstructorMethod.equals(new Method(name, desc))\n+              && tempStringAddedToStack) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              //super.visitInsn(Opcodes.POP);\n+              pop();\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTAwNjI3OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0NzoyNVrOHpWDOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDo0NzoyNVrOHpWDOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNDkzOA==", "bodyText": "Remove empty line", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513114938", "createdAt": "2020-10-28T00:47:25Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +672,95 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(current_timestamp_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type timeType = Type.getType(org.apache.spark.streaming.Time.class);\n+    Type hadoopPathType = Type.getType(org.apache.hadoop.fs.Path.class);\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitLdcInsn(Object value) {\n+            // If we find this instruction, we update our atomic boolean to True:\n+            // LDC \"temp\"\n+            // If this value is true, and the next instruction is the Path constructor, we need to\n+            // concat the checkpoont time to this string\n+            tempStringAddedToStack = \"temp\".equals(value);\n+\n+            super.visitLdcInsn(value);\n+          }\n+\n+          @Override\n+          public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {\n+\n+            // If we see a call to the Path constructor with 2 String parameters, rewrite the second argument\n+            // to add a timestamp.\n+            if (opcode == Opcodes.INVOKESPECIAL\n+              && Type.getObjectType(owner).equals(hadoopPathType)\n+              && hadoopPathConstructorMethod.equals(new Method(name, desc))\n+              && tempStringAddedToStack) {\n+\n+              //Pop the LOC \"temp\" argument from the stack.\n+              //super.visitInsn(Opcodes.POP);\n+              pop();\n+\n+              //Build the string that replaces \"temp\" as \"temp-\" + System.currentTimestampMillis.\n+              //This function generates the following code:\n+              //  new StringBuilder().append(\"temp-\").append(checkpointTime.milliseconds()).toString();\n+              newInstance(stringBuilderType);\n+              dup();\n+              invokeConstructor(stringBuilderType, Methods.getMethod(void.class, \"<init>\"));\n+              push(\"temp-\");\n+              invokeVirtual(stringBuilderType,\n+                            new Method(\"append\", stringBuilderType, new Type[]{stringType}));\n+              loadThis();\n+              getField(CHECKPOINT_WRITE_HANDLER_TYPE, checkpointTimeFieldName, timeType);\n+              invokeVirtual(timeType, new Method(\"milliseconds\", Type.LONG_TYPE, EMPTY_ARGS));\n+              invokeVirtual(stringBuilderType,\n+                            new Method(\"append\", stringBuilderType, new Type[]{Type.LONG_TYPE}));\n+              invokeVirtual(stringBuilderType,\n+                            new Method(\"toString\", stringType, EMPTY_ARGS));\n+\n+              LOG.debug(\"Checkpoint temp file name rewriting is ENABLED\");\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c513d3b7218d532aa3f821b33a4c08ddfb24487"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODM0NzM0OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkProgramRuntimeProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzozMjo0OVrOHp1x2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzozNDowMFrOHp10rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNDc3OQ==", "bodyText": "Generally I prefer alignment like this:\nprivate synchronized SparkRunnerClassLoader createClassLoader(boolean filterScalaClasses,\n                                                              boolean rewriteYarnClient, \n                                                              boolean rewriteCheckpointFileName) throws IOException {\n  // Code\n}\n\nAs it gives a clearer separation between method signature and the method body.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513634779", "createdAt": "2020-10-28T17:32:49Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkProgramRuntimeProvider.java", "diffHunk": "@@ -289,8 +294,10 @@ private ProgramRunner createSparkProgramRunner(Injector injector,\n   /**\n    * Returns an array of {@link URL} being used by the {@link ClassLoader} of this {@link Class}.\n    */\n-  private synchronized SparkRunnerClassLoader createClassLoader(boolean filterScalaClasses,\n-                                                                boolean rewriteYarnClient) throws IOException {\n+  private synchronized SparkRunnerClassLoader createClassLoader(\n+    boolean filterScalaClasses,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNTUwMw==", "bodyText": "If the last variable is too long, it's ok to use a shorter name since it is only local to the method.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513635503", "createdAt": "2020-10-28T17:34:00Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkProgramRuntimeProvider.java", "diffHunk": "@@ -289,8 +294,10 @@ private ProgramRunner createSparkProgramRunner(Injector injector,\n   /**\n    * Returns an array of {@link URL} being used by the {@link ClassLoader} of this {@link Class}.\n    */\n-  private synchronized SparkRunnerClassLoader createClassLoader(boolean filterScalaClasses,\n-                                                                boolean rewriteYarnClient) throws IOException {\n+  private synchronized SparkRunnerClassLoader createClassLoader(\n+    boolean filterScalaClasses,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNDc3OQ=="}, "originalCommit": {"oid": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODM1OTMwOnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkRuntimeUtils.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzozNTo0OFrOHp15dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODozNDoxNFrOHp4PRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjcyNQ==", "bodyText": "Why need two separate constants? Can we just have one? Also, since the constant is defined inside spark, it doesn't need to be so long. E.g. It can be just CHECKPOINT_REWRITE_ENABLED.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513636725", "createdAt": "2020-10-28T17:35:48Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkRuntimeUtils.java", "diffHunk": "@@ -84,6 +84,10 @@\n   public static final String PYSPARK_PORT_FILE_NAME = \"cdap.py4j.gateway.port.txt\";\n   public static final String PYSPARK_SECRET_FILE_NAME = \"cdap.py4j.gateway.secret.txt\";\n \n+  public static final String STREAMING_CHECKPOINT_REWRITE_ENABLED = \"streaming.checkpoint.rewrite.enabled\";\n+  public static final String SPARK_STREAMING_CHECKPOINT_REWRITE_ENABLED =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NzY1OA==", "bodyText": "I made them separate as I use the STREAMING_CHECKPOINT_REWRITE_ENABLED variable for the Java options in https://github.com/cdapio/cdap/pull/12822/files#diff-25b96ab36cd957bb35aace06ff7a5befcc138b4900b04c2e1435951a252a51b6R532\nThe SPARK_STREAMING_CHECKPOINT_REWRITE_ENABLED just adds the spark. prefix and is used in the cdap-site.xml configuration file.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513647658", "createdAt": "2020-10-28T17:51:28Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkRuntimeUtils.java", "diffHunk": "@@ -84,6 +84,10 @@\n   public static final String PYSPARK_PORT_FILE_NAME = \"cdap.py4j.gateway.port.txt\";\n   public static final String PYSPARK_SECRET_FILE_NAME = \"cdap.py4j.gateway.secret.txt\";\n \n+  public static final String STREAMING_CHECKPOINT_REWRITE_ENABLED = \"streaming.checkpoint.rewrite.enabled\";\n+  public static final String SPARK_STREAMING_CHECKPOINT_REWRITE_ENABLED =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjcyNQ=="}, "originalCommit": {"oid": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0OTM5Mw==", "bodyText": "Seems like you can just use the same one?", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513649393", "createdAt": "2020-10-28T17:54:06Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkRuntimeUtils.java", "diffHunk": "@@ -84,6 +84,10 @@\n   public static final String PYSPARK_PORT_FILE_NAME = \"cdap.py4j.gateway.port.txt\";\n   public static final String PYSPARK_SECRET_FILE_NAME = \"cdap.py4j.gateway.secret.txt\";\n \n+  public static final String STREAMING_CHECKPOINT_REWRITE_ENABLED = \"streaming.checkpoint.rewrite.enabled\";\n+  public static final String SPARK_STREAMING_CHECKPOINT_REWRITE_ENABLED =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjcyNQ=="}, "originalCommit": {"oid": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NTcxOQ==", "bodyText": "I tried that and when I did, Spark complained that Spark configuration properties cannot be set using Java opts.\nI don't recall the exact text of the error message, I can reproduce it and paste it here if you'd like.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513655719", "createdAt": "2020-10-28T18:03:09Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkRuntimeUtils.java", "diffHunk": "@@ -84,6 +84,10 @@\n   public static final String PYSPARK_PORT_FILE_NAME = \"cdap.py4j.gateway.port.txt\";\n   public static final String PYSPARK_SECRET_FILE_NAME = \"cdap.py4j.gateway.secret.txt\";\n \n+  public static final String STREAMING_CHECKPOINT_REWRITE_ENABLED = \"streaming.checkpoint.rewrite.enabled\";\n+  public static final String SPARK_STREAMING_CHECKPOINT_REWRITE_ENABLED =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjcyNQ=="}, "originalCommit": {"oid": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY3NTA3Ng==", "bodyText": "I see. it's ok to keep this. Maybe good to add a code comment as to why it is needed.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513675076", "createdAt": "2020-10-28T18:34:14Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/SparkRuntimeUtils.java", "diffHunk": "@@ -84,6 +84,10 @@\n   public static final String PYSPARK_PORT_FILE_NAME = \"cdap.py4j.gateway.port.txt\";\n   public static final String PYSPARK_SECRET_FILE_NAME = \"cdap.py4j.gateway.secret.txt\";\n \n+  public static final String STREAMING_CHECKPOINT_REWRITE_ENABLED = \"streaming.checkpoint.rewrite.enabled\";\n+  public static final String SPARK_STREAMING_CHECKPOINT_REWRITE_ENABLED =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzNjcyNQ=="}, "originalCommit": {"oid": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODM3NTc3OnYy", "diffSide": "RIGHT", "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzozOTozOFrOHp2Dmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzo1Mjo1MVrOHp2nxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzOTMyMg==", "bodyText": "You shouldn't be override this. This get called when a field is used inside a method. What I suggested earlier is to override the ClassVisitor.visitField method to make the field is defined in the class.", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513639322", "createdAt": "2020-10-28T17:39:38Z", "author": {"login": "chtyim"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +675,104 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(checkpoint_time_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          boolean hasCheckpointTimeField = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0ODU4MQ==", "bodyText": "Oh, I see what you mean now. I'll move this logic into the ClassVisitor instead", "url": "https://github.com/cdapio/cdap/pull/12822#discussion_r513648581", "createdAt": "2020-10-28T17:52:51Z", "author": {"login": "fernst"}, "path": "cdap-spark-core-base/src/main/java/io/cdap/cdap/app/runtime/spark/classloader/SparkClassRewriter.java", "diffHunk": "@@ -663,6 +675,104 @@ public void visitMethodInsn(int opcode, String owner, String name, String desc,\n     return cw.toByteArray();\n   }\n \n+  /**\n+   * Rewrites the temporary file name used for checkpoints from checkpointDir/temp to\n+   * checkpointDir/temp-(checkpoint_time_milliseconds).\n+   *\n+   * @param byteCodeStream {@link InputStream} for reading in the original bytecode.\n+   * @return the rewritten bytecode\n+   */\n+  private byte[] rewriteTempFileNameForCheckpoint(InputStream byteCodeStream) throws IOException {\n+    String checkpointTimeFieldName =\n+      \"org$apache$spark$streaming$CheckpointWriter$CheckpointWriteHandler$$checkpointTime\";\n+    Type stringType = Type.getType(String.class);\n+    Type stringBuilderType = Type.getType(StringBuilder.class);\n+\n+    ClassReader cr = new ClassReader(byteCodeStream);\n+    ClassWriter cw = new ClassWriter(0);\n+\n+    cr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n+      @Override\n+      public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n+\n+        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n+\n+        return new GeneratorAdapter(Opcodes.ASM5, mv, access, name, desc) {\n+\n+          boolean tempStringAddedToStack = false;\n+          boolean hasCheckpointTimeField = false;\n+          final Method hadoopPathConstructorMethod =\n+            new Method(\"<init>\", Type.VOID_TYPE, new Type[]{ stringType, stringType });\n+\n+          @Override\n+          public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzOTMyMg=="}, "originalCommit": {"oid": "d66a0cb5fe770530ff7692ef50fd8d1c42b98525"}, "originalPosition": 94}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3092, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}