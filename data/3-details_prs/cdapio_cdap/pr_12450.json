{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4MzI3OTYx", "number": 12450, "title": "[CDAP-16850] Revamp schema editor", "bodyText": "Context\n\nThis is a complete rewrite of schema editor.\nThe goal of the schema to be more scalable and accommodate for editing attributes of certain avro schema types.\n\nDesign\n\nThe schema editor design can be split into three parts,\n\nPresentation - Editor\nState management - Schema Manager\nValidator - Schema Validator to validate schema\n\n\nEditor represents the visual part of the schema editor. At the core, it renders a list + manages changes to the schema (crud operation)\nSchema Manager is the underlying state management for any operation happening in the Editor. Internally it maintains a tree and a flat list each representing the same avro schema. Tree - for faster manipulation and Flat list - for easier rendering\nValidator is the module used to validate the schema after each operation. We use customized version of avsc library to suit our needs\n\nImplementation\nSchema Manager\n\nFor any avro schema generates a tree and a flat array\nFor each operation (add/remove/update) the Schema Manager mutates the tree. This results in either adding a new subtree, removing a new subtree or modifying the existing subtree.\nThis subtree is then flattened and inserted at appropriate position to the existing flat array.\nTree is a direct tree representation of the avro schema\nList is a DFS traversed list generated from the above tree.\n\nEditor\n\nList contains each node in the avro schema\nEach node in the list is identified by a unique id\nEach node contains a reference to #of ancestors\nEach row is either a two column (unions or maps) or three column like record field with name(or label), type and action buttons\n\nOther component changes\n\nModified VirtualScroll to include a childrenUnderFoldScroll. This is to increase the rendered child count on scroll to avoid showing empty white space. This is a common occurrence when using a virtual scroll as browser cannot catch up with scroll and rendering the underlying component quick enough.\nModified Select dropdown to have a dense option to reduce padding.\nModified TextboxOnValium to accept a ref prop to be able to pass on the underlying input element to the parent.\nModified If to accept an additional invisible property to set visibility: hidden to children. This is to render empty space in place where the component needs to be showed.\n\nThings coming soon\n\nUnit and Integration test for utilities, state management and editor components. - #12455\nReplacing schema editor in the plugins modal #12478\nCode cleanup #12482", "createdAt": "2020-07-13T15:26:21Z", "url": "https://github.com/cdapio/cdap/pull/12450", "merged": true, "mergeCommit": {"oid": "7e68d0cbf1e081150b9e610606d3de80b9174b9c"}, "closed": true, "closedAt": "2020-07-23T22:53:34Z", "author": {"login": "ajainarayanan"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1Us0-AFqTQ0OTQzNzg0Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc33RwAgBqjM1ODE5NjI3NDY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDM3ODQz", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-449437843", "createdAt": "2020-07-16T00:57:40Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMDo1Nzo0MVrOGyWWlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMToxMDo1NVrOGyWj-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODIxNQ==", "bodyText": "I've noticed some types are in string form, should we define them in enum instead?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455448215", "createdAt": "2020-07-16T00:57:41Z", "author": {"login": "jennac3"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaGenerator.ts", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  IOrderedChildren,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  ISchemaType,\n+  IEnumFieldBase,\n+  IFieldType,\n+  IRecordField,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import uuidV4 from 'uuid/v4';\n+import {\n+  getDefaultEmptyAvroSchema,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { isDisplayTypeComplex } from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+\n+function generateArrayType(children: IOrderedChildren, nullable: boolean) {\n+  const finalType = {\n+    type: 'array',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODYwMQ==", "bodyText": "nit: I believe if (typeProperties.symbol && typeProperties.symbol.length > 0) may be less confusing, but this may be my biased opinion.", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455448601", "createdAt": "2020-07-16T00:59:09Z", "author": {"login": "jennac3"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaGenerator.ts", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  IOrderedChildren,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  ISchemaType,\n+  IEnumFieldBase,\n+  IFieldType,\n+  IRecordField,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import uuidV4 from 'uuid/v4';\n+import {\n+  getDefaultEmptyAvroSchema,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { isDisplayTypeComplex } from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+\n+function generateArrayType(children: IOrderedChildren, nullable: boolean) {\n+  const finalType = {\n+    type: 'array',\n+    items: null,\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type: childType, nullable: isArrayTypeNullable } = currentChild;\n+    const isArrayTypeComplex = isDisplayTypeComplex({ type: childType });\n+    if (!isArrayTypeComplex) {\n+      finalType.items = isArrayTypeNullable ? [childType, 'null'] : childType;\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(\n+      childType,\n+      currentChild,\n+      currentChild.nullable\n+    );\n+    if (complexType) {\n+      finalType.items = complexType;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateMapType(children: IOrderedChildren, nullable) {\n+  const finalType = {\n+    type: 'map',\n+    keys: 'string',\n+    values: 'string',\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type, nullable: isCurrentChildNullable, internalType } = currentChild;\n+    const isMapChildComplexType = isDisplayTypeComplex({ type });\n+    if (!isMapChildComplexType) {\n+      if (internalType === InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE) {\n+        finalType.keys = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      if (internalType === InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE) {\n+        finalType.values = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(type, currentChild, isCurrentChildNullable);\n+    if (internalType === InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT) {\n+      finalType.keys = complexType as any;\n+    }\n+    if (internalType === InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT) {\n+      finalType.values = complexType as any;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateEnumType(children: IOrderedChildren, currentNode: INode, nullable) {\n+  const finalType: IEnumFieldBase = {\n+    type: 'enum',\n+    symbols: [],\n+  };\n+  const { typeProperties: currentTypeProperties = {} } = currentNode;\n+  if (currentTypeProperties.doc) {\n+    finalType.doc = currentTypeProperties.doc;\n+  }\n+  if (currentTypeProperties.aliases) {\n+    finalType.aliases = currentTypeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { typeProperties } = currentChild;\n+      if (typeProperties.symbol && typeProperties.symbol !== '') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0OTEzOA==", "bodyText": "I believe if (!name) will suffice since this will check for empty string as well.", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455449138", "createdAt": "2020-07-16T01:00:56Z", "author": {"login": "jennac3"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaGenerator.ts", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  IOrderedChildren,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  ISchemaType,\n+  IEnumFieldBase,\n+  IFieldType,\n+  IRecordField,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import uuidV4 from 'uuid/v4';\n+import {\n+  getDefaultEmptyAvroSchema,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { isDisplayTypeComplex } from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+\n+function generateArrayType(children: IOrderedChildren, nullable: boolean) {\n+  const finalType = {\n+    type: 'array',\n+    items: null,\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type: childType, nullable: isArrayTypeNullable } = currentChild;\n+    const isArrayTypeComplex = isDisplayTypeComplex({ type: childType });\n+    if (!isArrayTypeComplex) {\n+      finalType.items = isArrayTypeNullable ? [childType, 'null'] : childType;\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(\n+      childType,\n+      currentChild,\n+      currentChild.nullable\n+    );\n+    if (complexType) {\n+      finalType.items = complexType;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateMapType(children: IOrderedChildren, nullable) {\n+  const finalType = {\n+    type: 'map',\n+    keys: 'string',\n+    values: 'string',\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type, nullable: isCurrentChildNullable, internalType } = currentChild;\n+    const isMapChildComplexType = isDisplayTypeComplex({ type });\n+    if (!isMapChildComplexType) {\n+      if (internalType === InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE) {\n+        finalType.keys = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      if (internalType === InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE) {\n+        finalType.values = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(type, currentChild, isCurrentChildNullable);\n+    if (internalType === InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT) {\n+      finalType.keys = complexType as any;\n+    }\n+    if (internalType === InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT) {\n+      finalType.values = complexType as any;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateEnumType(children: IOrderedChildren, currentNode: INode, nullable) {\n+  const finalType: IEnumFieldBase = {\n+    type: 'enum',\n+    symbols: [],\n+  };\n+  const { typeProperties: currentTypeProperties = {} } = currentNode;\n+  if (currentTypeProperties.doc) {\n+    finalType.doc = currentTypeProperties.doc;\n+  }\n+  if (currentTypeProperties.aliases) {\n+    finalType.aliases = currentTypeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { typeProperties } = currentChild;\n+      if (typeProperties.symbol && typeProperties.symbol !== '') {\n+        finalType.symbols.push(typeProperties.symbol);\n+      }\n+      if (typeProperties.doc) {\n+        finalType.doc = typeProperties.doc;\n+      }\n+      if (typeProperties.aliases) {\n+        finalType.aliases = typeProperties.aliases;\n+      }\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateRecordType(children: IOrderedChildren, currentNode: INode, nullable: boolean) {\n+  const finalType: IRecordField = {\n+    type: 'record',\n+    name: currentNode.name || `name-${uuidV4()}`,\n+    fields: [],\n+  };\n+  const { typeProperties = {} } = currentNode;\n+  if (typeProperties.doc) {\n+    finalType.doc = typeProperties.doc;\n+  }\n+  if (typeProperties.aliases) {\n+    finalType.aliases = typeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { name, type, nullable: isFiledNullable } = currentChild;\n+      if (!name || name === '') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0OTc1NQ==", "bodyText": "I believe if (!name) will suffice since this will check for empty string as well.", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455449755", "createdAt": "2020-07-16T01:03:26Z", "author": {"login": "jennac3"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaGenerator.ts", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  IOrderedChildren,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  ISchemaType,\n+  IEnumFieldBase,\n+  IFieldType,\n+  IRecordField,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import uuidV4 from 'uuid/v4';\n+import {\n+  getDefaultEmptyAvroSchema,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { isDisplayTypeComplex } from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+\n+function generateArrayType(children: IOrderedChildren, nullable: boolean) {\n+  const finalType = {\n+    type: 'array',\n+    items: null,\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type: childType, nullable: isArrayTypeNullable } = currentChild;\n+    const isArrayTypeComplex = isDisplayTypeComplex({ type: childType });\n+    if (!isArrayTypeComplex) {\n+      finalType.items = isArrayTypeNullable ? [childType, 'null'] : childType;\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(\n+      childType,\n+      currentChild,\n+      currentChild.nullable\n+    );\n+    if (complexType) {\n+      finalType.items = complexType;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateMapType(children: IOrderedChildren, nullable) {\n+  const finalType = {\n+    type: 'map',\n+    keys: 'string',\n+    values: 'string',\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type, nullable: isCurrentChildNullable, internalType } = currentChild;\n+    const isMapChildComplexType = isDisplayTypeComplex({ type });\n+    if (!isMapChildComplexType) {\n+      if (internalType === InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE) {\n+        finalType.keys = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      if (internalType === InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE) {\n+        finalType.values = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(type, currentChild, isCurrentChildNullable);\n+    if (internalType === InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT) {\n+      finalType.keys = complexType as any;\n+    }\n+    if (internalType === InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT) {\n+      finalType.values = complexType as any;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateEnumType(children: IOrderedChildren, currentNode: INode, nullable) {\n+  const finalType: IEnumFieldBase = {\n+    type: 'enum',\n+    symbols: [],\n+  };\n+  const { typeProperties: currentTypeProperties = {} } = currentNode;\n+  if (currentTypeProperties.doc) {\n+    finalType.doc = currentTypeProperties.doc;\n+  }\n+  if (currentTypeProperties.aliases) {\n+    finalType.aliases = currentTypeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { typeProperties } = currentChild;\n+      if (typeProperties.symbol && typeProperties.symbol !== '') {\n+        finalType.symbols.push(typeProperties.symbol);\n+      }\n+      if (typeProperties.doc) {\n+        finalType.doc = typeProperties.doc;\n+      }\n+      if (typeProperties.aliases) {\n+        finalType.aliases = typeProperties.aliases;\n+      }\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateRecordType(children: IOrderedChildren, currentNode: INode, nullable: boolean) {\n+  const finalType: IRecordField = {\n+    type: 'record',\n+    name: currentNode.name || `name-${uuidV4()}`,\n+    fields: [],\n+  };\n+  const { typeProperties = {} } = currentNode;\n+  if (typeProperties.doc) {\n+    finalType.doc = typeProperties.doc;\n+  }\n+  if (typeProperties.aliases) {\n+    finalType.aliases = typeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { name, type, nullable: isFiledNullable } = currentChild;\n+      if (!name || name === '') {\n+        continue;\n+      }\n+      const isFieldTypeComplex = isDisplayTypeComplex({ type });\n+      if (!isFieldTypeComplex) {\n+        finalType.fields.push({\n+          name,\n+          type: isFiledNullable ? [type, 'null'] : type,\n+        });\n+      } else {\n+        finalType.fields.push({\n+          name,\n+          type: generateSchemaFromComplexType(\n+            currentChild.type,\n+            currentChild,\n+            currentChild.nullable\n+          ),\n+        });\n+      }\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateUnionType(children: IOrderedChildren) {\n+  const finalType = [];\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { type } = currentChild;\n+      const isUnionTypeComplex = isDisplayTypeComplex({ type });\n+      if (!isUnionTypeComplex) {\n+        finalType.push(type);\n+        continue;\n+      }\n+      finalType.push(generateSchemaFromComplexType(type, currentChild, false));\n+    }\n+  }\n+  return finalType;\n+}\n+\n+function generateLogicalType(child) {\n+  const { typeProperties, nullable } = child;\n+  return nullable ? [typeProperties, 'null'] : typeProperties;\n+}\n+\n+function generateSchemaFromComplexType(type: string, currentChild, nullable: boolean) {\n+  const complexTypeChildren: IOrderedChildren = currentChild.children;\n+  switch (type) {\n+    case 'array':\n+      return generateArrayType(complexTypeChildren, nullable);\n+    case 'map':\n+      return generateMapType(complexTypeChildren, nullable);\n+    case 'enum':\n+      return generateEnumType(complexTypeChildren, currentChild, nullable);\n+    case 'union':\n+      return generateUnionType(complexTypeChildren);\n+    case 'record':\n+      return generateRecordType(complexTypeChildren, currentChild, nullable);\n+    case 'time':\n+    case 'timestamp':\n+    case 'decimal':\n+    case 'date':\n+      return generateLogicalType(currentChild);\n+    default:\n+      return type;\n+  }\n+}\n+\n+/**\n+ * Utility to convert the entire schema tree to a valid avro schema JSON.\n+ * @param schemaTree Schema tree to convert to avro schema JSON.\n+ */\n+function SchemaGenerator(schemaTree: INode) {\n+  const avroSchema: ISchemaType = getDefaultEmptyAvroSchema();\n+  if (!schemaTree) {\n+    return avroSchema;\n+  }\n+  // Top level record fields.\n+  const { order } = schemaTree.children;\n+  if (Array.isArray(order)) {\n+    for (const id of order) {\n+      const currentField = schemaTree.children[id];\n+      const { name, type, nullable } = currentField;\n+      // Skip the newly added rows.\n+      if (!name || name === '') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ1MDU4Mg==", "bodyText": "this can be just '96px'", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455450582", "createdAt": "2020-07-16T01:06:42Z", "author": {"login": "jennac3"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/FieldWrapper/index.tsx", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import Box from '@material-ui/core/Box';\n+import Paper from '@material-ui/core/Paper';\n+import isObject from 'lodash/isObject';\n+import withStyles from '@material-ui/core/styles/withStyles';\n+import If from 'components/If';\n+import { SiblingCommunicationConsumer } from 'components/AbstractWidget/SchemaEditor/FieldWrapper/SiblingCommunicationContext';\n+import { SchemaValidatorConsumer } from '../SchemaValidator';\n+import isNil from 'lodash/isNil';\n+import { SiblingLine } from 'components/AbstractWidget/SchemaEditor/FieldWrapper/SiblingLine';\n+import {\n+  INDENTATION_SPACING,\n+  rowHeight,\n+  rowMarginTop,\n+} from 'components/AbstractWidget/SchemaEditor/FieldWrapper/FieldWrapperConstants';\n+\n+interface IFieldWrapperProps {\n+  ancestors: string[];\n+  children?: React.ReactNode;\n+  style?: any;\n+  className?: any;\n+}\n+\n+const CustomizedPaper = withStyles(() => {\n+  return {\n+    root: {\n+      padding: '2px 10px 2px 0px',\n+      display: 'grid',\n+      marginTop: `${rowMarginTop}px`,\n+      gridTemplateRows: `${rowHeight}px`,\n+      position: 'relative',\n+    },\n+  };\n+})(Paper);\n+\n+const SiblingsWrapper = withStyles(() => {\n+  return {\n+    root: {\n+      position: 'absolute',\n+      left: 0,\n+      top: 0,\n+    },\n+  };\n+})(Box);\n+\n+const FieldWrapperBase = ({\n+  ancestors = [],\n+  children,\n+  style = {},\n+  className,\n+}: IFieldWrapperProps) => {\n+  /**\n+   * Based on the number of ancestors we indent the row accordingly. Each ancestor will\n+   * have a line indicating hierarchy and a horizontal line with immediate parent\n+   *\n+   * The design is to have a grid base row\n+   * - There is a single column wrapper (for unions and arrays) which is implemented by SingleColumnWrapper\n+   * - There is a two column layout for field name/type (or label and type for maps) and the\n+   * other for the row buttons. This helps us maintain the vertical alignment for row buttons\n+   * no matter what the indentation is.\n+   *\n+   * The width of the wrapper is reduced based on the indentation.\n+   */\n+  const spacing = ancestors.length * INDENTATION_SPACING;\n+  const firstColumn = '20px';\n+  const thirdColumn = `96px`;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ1MDg3NA==", "bodyText": "nit: are these console.log necessary?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455450874", "createdAt": "2020-07-16T01:08:00Z", "author": {"login": "jennac3"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/SampleTypeFieldChecker.ts", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/**\n+ * This is purely a playground to play around and get an understanding on the\n+ * schema types. Not used anywhere.\n+ */\n+import {\n+  IArrayField,\n+  IArrayFieldNullable,\n+  IUnionField,\n+  IEnumField,\n+  IRecordField,\n+  IMapFieldBase,\n+  IMapField,\n+  IComplexType,\n+  ISimpleType,\n+  IComplexTypeFieldNullable,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+\n+const mapfield: IMapField = {\n+  name: 'map1',\n+  type: {\n+    type: 'map',\n+    keys: 'string',\n+    values: 'string',\n+  },\n+};\n+// tslint:disable-next-line: no-console\n+console.log(mapfield.type.keys);\n+\n+const arrayField: IArrayField = {\n+  name: 'arr',\n+  type: {\n+    type: 'array',\n+    items: 'string',\n+  },\n+};\n+// tslint:disable-next-line: no-console\n+console.log(!Array.isArray(arrayField.type) ? arrayField.type.items : arrayField.type[0]);\n+\n+const unionField: IUnionField = {\n+  name: 'something',\n+  type: ['long', 'string'],\n+};\n+// tslint:disable-next-line: no-console\n+console.log(unionField.type[1]);\n+\n+const enumField: IEnumField = {\n+  name: 'enum1',\n+  type: {\n+    type: 'enum',\n+    symbols: ['something', 'somethingelse', 'nothing', 'maybesomething'],\n+  },\n+};\n+// tslint:disable-next-line: no-console\n+// tslint:disable-next-line: no-console\n+console.log(enumField.type.symbols);\n+\n+const recordField: IRecordField = {\n+  type: 'record',\n+  name: 'record1',\n+  fields: [\n+    {\n+      name: 'name',\n+      type: 'string',\n+    },\n+    {\n+      name: 'email',\n+      type: 'string',\n+    },\n+  ],\n+};\n+// tslint:disable-next-line: no-console\n+// tslint:disable-next-line: no-console\n+console.log(recordField.fields);\n+\n+const complexArrField2: IArrayFieldNullable = {\n+  name: 'arr1',\n+  type: [\n+    {\n+      type: 'array',\n+      items: 'string',\n+    },\n+    'null',\n+  ],\n+};\n+// tslint:disable-next-line: no-console\n+console.log(\n+  Array.isArray(complexArrField2.type)\n+    ? complexArrField2.type.find((t) => t !== 'null' && typeof t.items !== 'undefined')\n+    : complexArrField2.type\n+);\n+\n+const isNullable = (type) => Array.isArray(type) && type.find((t) => t === 'null');\n+const complexArrayField: IArrayFieldNullable = {\n+  name: 'complexArray',\n+  type: [\n+    {\n+      type: 'array',\n+      items: [\n+        {\n+          type: 'record',\n+          name: 'ad5bddf76ef2743218d79d3905f0f8e4f',\n+          fields: [\n+            {\n+              name: 'name',\n+              type: 'string',\n+            },\n+            {\n+              name: 'email',\n+              type: 'string',\n+            },\n+          ],\n+        },\n+        'null',\n+      ],\n+    },\n+    'null',\n+  ],\n+};\n+\n+if (Array.isArray(complexArrayField.type)) {\n+  const a1 = complexArrayField.type.find((t) => t !== 'null' && t.type === 'array');\n+  // tslint:disable-next-line: no-console\n+  console.log(a1 !== 'null' && a1.items);\n+  if (isNullable(complexArrayField.type)) {\n+    // tslint:disable-next-line: no-console\n+    console.log('nullable is true');\n+  }\n+}\n+\n+const complexUnionField: IUnionField = {\n+  name: 'something',\n+  type: [\n+    'long',\n+    {\n+      type: 'map',\n+      keys: {\n+        type: 'record',\n+        name: 'a64d56b7343854e81801874b77b536802',\n+        fields: [\n+          {\n+            name: 'sdfsd',\n+            type: 'string',\n+          },\n+          {\n+            name: 'sdfsdsdfsdf',\n+            type: 'string',\n+          },\n+        ],\n+      },\n+      values: 'string',\n+    },\n+    {\n+      type: 'record',\n+      name: 'record1',\n+      fields: [\n+        {\n+          name: 'name',\n+          type: 'string',\n+        },\n+        {\n+          name: 'email',\n+          type: 'string',\n+        },\n+      ],\n+    },\n+  ],\n+};\n+const isSimpleType = (type: ISimpleType | IComplexTypeFieldNullable) =>\n+  typeof type === 'string' &&\n+  [\n+    'boolean',\n+    'bytes',\n+    'date',\n+    'decimal',\n+    'double',\n+    'float',\n+    'int',\n+    'long',\n+    'number',\n+    'string',\n+    'time',\n+  ].indexOf(type) !== -1;\n+if (Array.isArray(complexUnionField.type)) {\n+  const map1 = complexUnionField.type\n+    .filter((t) => typeof t !== 'string')\n+    .find((t: IComplexType) => !Array.isArray(t.type) && t.type === 'map') as IMapFieldBase;\n+  let fieldsInRecords;\n+  if (!Array.isArray(map1.keys) && typeof map1.keys === 'object' && map1.keys.type === 'record') {\n+    fieldsInRecords = (map1.keys as IRecordField).fields;\n+  }\n+  // tslint:disable-next-line: no-console\n+  console.log(map1, fieldsInRecords);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ1MTM5MQ==", "bodyText": "this if (!invisible) can be moved outside so that it can be less nested.", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455451391", "createdAt": "2020-07-16T01:09:58Z", "author": {"login": "jennac3"}, "path": "cdap-ui/app/cdap/components/If/index.tsx", "diffHunk": "@@ -14,15 +14,34 @@\n  * the License.\n  */\n import * as React from 'react';\n+import Box from '@material-ui/core/Box';\n+import withStyles from '@material-ui/core/styles/withStyles';\n \n interface IIfComponentProps {\n   condition: boolean;\n   children: React.ReactNode;\n+  invisible?: boolean;\n+  HiddenContainer?: React.ReactNode;\n }\n \n-const If: React.FC<IIfComponentProps> = ({ condition, children }) => {\n+const If: React.FC<IIfComponentProps> = ({\n+  condition,\n+  children,\n+  invisible = false,\n+  HiddenContainer,\n+}) => {\n   if (!condition) {\n-    return null;\n+    if (!invisible) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ1MTY0MA==", "bodyText": "can we just return result in try block?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455451640", "createdAt": "2020-07-16T01:10:55Z", "author": {"login": "jennac3"}, "path": "cdap-ui/app/cdap/services/helpers.js", "diffHunk": "@@ -490,6 +490,16 @@ function connectWithStore(store, WrappedComponent, ...args) {\n   };\n }\n \n+function dumbestClone(jsonObj) {\n+  let result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDAxNTI4", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-449401528", "createdAt": "2020-07-15T23:05:13Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMzowNToxM1rOGyUSuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMjozOTo1OFrOGyYAyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxNDQ1Nw==", "bodyText": "instead of importing the color, does it work if the function being passed to withStyles have the theme object?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455414457", "createdAt": "2020-07-15T23:05:13Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/FormInputs/Select/index.tsx", "diffHunk": "@@ -21,35 +21,59 @@ import { IWidgetProps } from 'components/AbstractWidget';\n import { objectQuery } from 'services/helpers';\n import { WIDGET_PROPTYPES } from 'components/AbstractWidget/constants';\n import withStyles from '@material-ui/core/styles/withStyles';\n-\n+import { blue } from 'components/ThemeWrapper/colors';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxNzUwNA==", "bodyText": "combine the two if statements?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455417504", "createdAt": "2020-07-15T23:14:20Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/ArrayType/index.tsx", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import { schemaTypes } from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { SingleColumnWrapper } from 'components/AbstractWidget/SchemaEditor/SingleColumnWrapper';\n+import Select from 'components/AbstractWidget/FormInputs/Select';\n+import { IFieldTypeBaseProps } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import { RowButtons } from 'components/AbstractWidget/SchemaEditor/RowButtons';\n+\n+const ArrayTypeBase = ({\n+  type,\n+  nullable,\n+  onChange,\n+  autoFocus,\n+  typeProperties,\n+}: IFieldTypeBaseProps) => {\n+  const [fieldType, setFieldType] = React.useState(type);\n+  const [fieldNullable, setFieldNullable] = React.useState(nullable);\n+  const [fieldTypeProperties, setFieldTypeProperties] = React.useState(typeProperties || {});\n+\n+  const onTypePropertiesChangeHandler = (property, value) => {\n+    if (property === 'typeProperties') {\n+      setFieldTypeProperties(value);\n+    }\n+    onChange(property, value);\n+  };\n+  const inputEle = React.useRef(null);\n+  React.useEffect(() => {\n+    if (autoFocus) {\n+      if (inputEle.current) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxODU1OA==", "bodyText": "should we extract the types of properties that can be updated into an Enum?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455418558", "createdAt": "2020-07-15T23:17:27Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/ArrayType/index.tsx", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import { schemaTypes } from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { SingleColumnWrapper } from 'components/AbstractWidget/SchemaEditor/SingleColumnWrapper';\n+import Select from 'components/AbstractWidget/FormInputs/Select';\n+import { IFieldTypeBaseProps } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import { RowButtons } from 'components/AbstractWidget/SchemaEditor/RowButtons';\n+\n+const ArrayTypeBase = ({\n+  type,\n+  nullable,\n+  onChange,\n+  autoFocus,\n+  typeProperties,\n+}: IFieldTypeBaseProps) => {\n+  const [fieldType, setFieldType] = React.useState(type);\n+  const [fieldNullable, setFieldNullable] = React.useState(nullable);\n+  const [fieldTypeProperties, setFieldTypeProperties] = React.useState(typeProperties || {});\n+\n+  const onTypePropertiesChangeHandler = (property, value) => {\n+    if (property === 'typeProperties') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ2ODQ5Mg==", "bodyText": "nit: unnecessary {}", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455468492", "createdAt": "2020-07-16T02:13:18Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaManagerUtilities.ts", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  parseUnionType,\n+  parseArrayType,\n+  parseEnumType,\n+  parseMapType,\n+  IOrderedChildren,\n+  parseComplexType,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  logicalTypes,\n+  defaultTimeStampTypeProperties,\n+  defaultDecimalTypeProperties,\n+  defaultTimeTypeProperties,\n+  defaultDateTypeProperties,\n+  defaultArrayType,\n+  defaultEnumType,\n+  defaultMapType,\n+  defaultRecordType,\n+  defaultUnionType,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import isEmpty from 'lodash/isEmpty';\n+\n+function getInternalType(tree: INode) {\n+  const hasChildren = tree.children ? Object.keys(tree.children).length : 0;\n+  if (tree.internalType === InternalTypesEnum.RECORD_SIMPLE_TYPE && hasChildren) {\n+    return InternalTypesEnum.RECORD_COMPLEX_TYPE_ROOT;\n+  }\n+  if (tree.internalType === InternalTypesEnum.RECORD_COMPLEX_TYPE_ROOT && !hasChildren) {\n+    return InternalTypesEnum.RECORD_SIMPLE_TYPE;\n+  }\n+  if (tree.internalType === InternalTypesEnum.UNION_SIMPLE_TYPE && hasChildren) {\n+    return InternalTypesEnum.UNION_COMPLEX_TYPE_ROOT;\n+  }\n+  if (tree.internalType === InternalTypesEnum.UNION_COMPLEX_TYPE_ROOT && !hasChildren) {\n+    return InternalTypesEnum.UNION_SIMPLE_TYPE;\n+  }\n+  if (tree.internalType === InternalTypesEnum.ARRAY_SIMPLE_TYPE && hasChildren) {\n+    return InternalTypesEnum.ARRAY_COMPLEX_TYPE_ROOT;\n+  }\n+  if (tree.internalType === InternalTypesEnum.ARRAY_COMPLEX_TYPE_ROOT && !hasChildren) {\n+    return InternalTypesEnum.ARRAY_SIMPLE_TYPE;\n+  }\n+  if (tree.internalType === InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE && hasChildren) {\n+    return InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT;\n+  }\n+  if (tree.internalType === InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT && hasChildren) {\n+    return InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE;\n+  }\n+  if (tree.internalType === InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE && hasChildren) {\n+    return InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT;\n+  }\n+  if (tree.internalType === InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT && hasChildren) {\n+    return InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE;\n+  }\n+  return tree.internalType;\n+}\n+\n+const branchCount = (tree: INode): number => {\n+  let count = 0;\n+  if (tree && !isEmpty(tree.children) && Object.keys(tree.children).length) {\n+    // skip 'order' array which is under children.\n+    const children = Object.values(tree.children).filter((child) => !Array.isArray(child));\n+    count += children.length;\n+    children.forEach((child: INode) => {\n+      count += branchCount(child);\n+    });\n+  }\n+  return count;\n+};\n+\n+const initChildren = (type): IOrderedChildren => {\n+  switch (type) {\n+    case 'array':\n+      return parseArrayType(defaultArrayType);\n+    case 'enum':\n+      return parseEnumType(defaultEnumType);\n+    case 'map':\n+      return parseMapType(defaultMapType);\n+    case 'record': {\n+      return parseComplexType(defaultRecordType);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ2OTA5MA==", "bodyText": "nit: remove {}", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455469090", "createdAt": "2020-07-16T02:15:40Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaParser.ts", "diffHunk": "@@ -0,0 +1,431 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+import { IInternalFieldType } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import {\n+  ISchemaType,\n+  IDisplayType,\n+  IFieldType,\n+  IFieldTypeNullable,\n+  ILogicalTypeBase,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import {\n+  getComplexTypeName,\n+  isNullable,\n+  isComplexType,\n+  getNonNullableType,\n+  getSimpleType,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+import uuidV4 from 'uuid/v4';\n+import { InternalTypesEnum } from '../SchemaConstants';\n+\n+type ITypeProperties = Record<string, any>;\n+\n+/**\n+ * A generic node of the tree.\n+ * name, id, nullable and type - directly translate to the avro schema\n+ * children - is a map of child-id and the child node. In cases like records and enums\n+ * where the order of children needs to be maintained, the map will have a static\n+ * 'order' array.\n+ * internalType - purely used for presentation.\n+ * typeProperties - Defines the properties of the type. Right now this takes in\n+ * symbols in the enum and precision, scale in decimal types.\n+ */\n+interface INode {\n+  name?: string;\n+  children?: IOrderedChildren;\n+  id: string;\n+  internalType: IInternalFieldType;\n+  nullable?: boolean;\n+  type?: IDisplayType;\n+  typeProperties?: ITypeProperties;\n+}\n+\n+type IOrderedChildren = Record<string, INode> | Record<'order', string[]>;\n+\n+/**\n+ * {\n+ *  [child-id1]: {\n+ *    id: child-id1,\n+ *    internalType: 'union-simple-type',\n+ *    type: 'string'\n+ *  }\n+ * }\n+ * @param type avro union type\n+ * ['string']\n+ */\n+function parseUnionType(type): IOrderedChildren {\n+  const result: IOrderedChildren = {\n+    order: [],\n+  };\n+  for (const subType of type) {\n+    const id = uuidV4();\n+    result.order.push(id);\n+    if (isComplexType(subType)) {\n+      const typeName = getComplexTypeName(subType);\n+      result[id] = {\n+        id,\n+        type: typeName,\n+        internalType: InternalTypesEnum.UNION_COMPLEX_TYPE_ROOT,\n+        children: parseComplexType(subType),\n+      };\n+    } else {\n+      result[id] = {\n+        id,\n+        type: subType,\n+        nullable: false,\n+        internalType: InternalTypesEnum.UNION_SIMPLE_TYPE,\n+      };\n+    }\n+  }\n+  return result;\n+}\n+/**\n+ * @returns\n+ * {\n+ *  [child-id1]: {\n+ *    internalType: 'array-simple-type',\n+ *    type: 'string'\n+ *  }\n+ * }\n+ * @param type avro array type\n+ * {\n+ *  type: 'array',\n+ *  items: 'string'\n+ * }\n+ */\n+function parseArrayType(type): IOrderedChildren {\n+  const nullable = isNullable(type);\n+  const t = getNonNullableType(type);\n+  const id = uuidV4();\n+  if (t.items && !isComplexType(t.items)) {\n+    return {\n+      [id]: {\n+        internalType: InternalTypesEnum.ARRAY_SIMPLE_TYPE,\n+        id,\n+        nullable: isNullable(t.items),\n+        type: getNonNullableType(t.items),\n+      },\n+    };\n+  }\n+  return {\n+    [id]: {\n+      internalType: InternalTypesEnum.ARRAY_COMPLEX_TYPE_ROOT,\n+      id,\n+      nullable,\n+      type: getComplexTypeName(t.items),\n+      children: parseComplexType(t.items),\n+    },\n+  };\n+}\n+\n+/**\n+ * @returns\n+ * {\n+ *  order: [child-id1, child-id2,...]\n+ *  [child-id1]: {\n+ *    id: child-id1,\n+ *    internalType: 'enum-symbol',\n+ *    typeProperties: {\n+ *      symbol: 'symbol1'\n+ *    }\n+ *  },\n+ *  [child-id2]: {\n+ *    id: child-id2,\n+ *    internalType: 'enum-symbol',\n+ *    typeProperties: {\n+ *      symbol: 'symbol2'\n+ *    }\n+ *  }\n+ * }\n+ * @param type avro enum type\n+ * {\n+ *  type: 'enum',\n+ *  symbols: ['symbol1', 'symbol2', ....]\n+ * }\n+ */\n+function parseEnumType(type): IOrderedChildren {\n+  const nullable = isNullable(type);\n+  const t = getNonNullableType(type);\n+  const result = {\n+    order: [],\n+  };\n+  for (const symbol of t.symbols) {\n+    const id = uuidV4();\n+    result.order.push(id);\n+    result[id] = {\n+      id,\n+      internalType: InternalTypesEnum.ENUM_SYMBOL,\n+      nullable,\n+      typeProperties: {\n+        symbol,\n+      },\n+    };\n+  }\n+  return result;\n+}\n+\n+function getMapSubType(type, internalTypeName): INode {\n+  const id = uuidV4();\n+  if (!isComplexType(type)) {\n+    return {\n+      id,\n+      internalType: internalTypeName.simpleType,\n+      nullable: isNullable(type),\n+      type: getNonNullableType(type),\n+    };\n+  } else {\n+    const complexType = getComplexTypeName(type);\n+    const nullable = isNullable(type);\n+    return {\n+      children: parseComplexType(type),\n+      id,\n+      internalType: internalTypeName.complexType,\n+      type: complexType,\n+      nullable,\n+    };\n+  }\n+}\n+/**\n+ * @returns\n+ * {\n+ *   [child-id1]: {\n+ *    \"id\": child-id1,\n+ *    \"internalType\": \"map-keys-simple-type\",\n+ *    \"type\": \"string\"\n+ *  },\n+ *   [child-id2] {\n+ *    \"id\": child-id2,\n+ *    \"internalType\": \"map-values-simple-type\",\n+ *    \"nullable\": false,\n+ *    \"type\": \"string\"\n+ *   }\n+ * }\n+ * @param type avro map type\n+ * {\n+ *  type: {\n+ *    keys: 'string',\n+ *    values: 'string',\n+ *  }\n+ * }\n+ */\n+function parseMapType(type): IOrderedChildren {\n+  const t = getNonNullableType(type);\n+  const keysType = t.keys;\n+  const valuesType = t.values;\n+  const result: Record<string, INode> = {};\n+  const mapKeysSubType = getMapSubType(keysType, {\n+    simpleType: InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE,\n+    complexType: InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT,\n+  });\n+  const mapValuesSubType = getMapSubType(valuesType, {\n+    simpleType: InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE,\n+    complexType: InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT,\n+  });\n+  result[mapKeysSubType.id] = mapKeysSubType;\n+  result[mapValuesSubType.id] = mapValuesSubType;\n+  return result;\n+}\n+/**\n+ * @returns -\n+ * {\n+ *  [child-id1]:{\n+ *    id: child-id1,\n+ *    internalType: 'record-field-simple-type',\n+ *    type: 'string',\n+ *  },\n+ *  order: [child-id1]\n+ * }\n+ * @param type - avro record type\n+ * {\n+ *  name: 'record-name',\n+ *  type: 'record',\n+ *  fields: [ field1, field2 ...]\n+ * }\n+ */\n+function parseRecordType(type): IOrderedChildren {\n+  const t = getNonNullableType(type);\n+  const result = {\n+    order: [],\n+  };\n+  for (const field of t.fields) {\n+    const child = parseSubTree(field);\n+    result.order.push(child.id);\n+    result[child.id] = child;\n+  }\n+  return result;\n+}\n+\n+function parseComplexType(type): IOrderedChildren {\n+  const complexTypeName = getComplexTypeName(type);\n+  let record: IOrderedChildren = {};\n+  switch (complexTypeName) {\n+    case 'enum':\n+      record = parseEnumType(type);\n+      break;\n+    case 'array':\n+      record = parseArrayType(type);\n+      break;\n+    case 'record': {\n+      record = parseRecordType(type);\n+      break;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ2OTY2MA==", "bodyText": "do these need to be exposed here? can these value just be inside the getMapSubType?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455469660", "createdAt": "2020-07-16T02:17:52Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaParser.ts", "diffHunk": "@@ -0,0 +1,431 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+import { IInternalFieldType } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import {\n+  ISchemaType,\n+  IDisplayType,\n+  IFieldType,\n+  IFieldTypeNullable,\n+  ILogicalTypeBase,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import {\n+  getComplexTypeName,\n+  isNullable,\n+  isComplexType,\n+  getNonNullableType,\n+  getSimpleType,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+import uuidV4 from 'uuid/v4';\n+import { InternalTypesEnum } from '../SchemaConstants';\n+\n+type ITypeProperties = Record<string, any>;\n+\n+/**\n+ * A generic node of the tree.\n+ * name, id, nullable and type - directly translate to the avro schema\n+ * children - is a map of child-id and the child node. In cases like records and enums\n+ * where the order of children needs to be maintained, the map will have a static\n+ * 'order' array.\n+ * internalType - purely used for presentation.\n+ * typeProperties - Defines the properties of the type. Right now this takes in\n+ * symbols in the enum and precision, scale in decimal types.\n+ */\n+interface INode {\n+  name?: string;\n+  children?: IOrderedChildren;\n+  id: string;\n+  internalType: IInternalFieldType;\n+  nullable?: boolean;\n+  type?: IDisplayType;\n+  typeProperties?: ITypeProperties;\n+}\n+\n+type IOrderedChildren = Record<string, INode> | Record<'order', string[]>;\n+\n+/**\n+ * {\n+ *  [child-id1]: {\n+ *    id: child-id1,\n+ *    internalType: 'union-simple-type',\n+ *    type: 'string'\n+ *  }\n+ * }\n+ * @param type avro union type\n+ * ['string']\n+ */\n+function parseUnionType(type): IOrderedChildren {\n+  const result: IOrderedChildren = {\n+    order: [],\n+  };\n+  for (const subType of type) {\n+    const id = uuidV4();\n+    result.order.push(id);\n+    if (isComplexType(subType)) {\n+      const typeName = getComplexTypeName(subType);\n+      result[id] = {\n+        id,\n+        type: typeName,\n+        internalType: InternalTypesEnum.UNION_COMPLEX_TYPE_ROOT,\n+        children: parseComplexType(subType),\n+      };\n+    } else {\n+      result[id] = {\n+        id,\n+        type: subType,\n+        nullable: false,\n+        internalType: InternalTypesEnum.UNION_SIMPLE_TYPE,\n+      };\n+    }\n+  }\n+  return result;\n+}\n+/**\n+ * @returns\n+ * {\n+ *  [child-id1]: {\n+ *    internalType: 'array-simple-type',\n+ *    type: 'string'\n+ *  }\n+ * }\n+ * @param type avro array type\n+ * {\n+ *  type: 'array',\n+ *  items: 'string'\n+ * }\n+ */\n+function parseArrayType(type): IOrderedChildren {\n+  const nullable = isNullable(type);\n+  const t = getNonNullableType(type);\n+  const id = uuidV4();\n+  if (t.items && !isComplexType(t.items)) {\n+    return {\n+      [id]: {\n+        internalType: InternalTypesEnum.ARRAY_SIMPLE_TYPE,\n+        id,\n+        nullable: isNullable(t.items),\n+        type: getNonNullableType(t.items),\n+      },\n+    };\n+  }\n+  return {\n+    [id]: {\n+      internalType: InternalTypesEnum.ARRAY_COMPLEX_TYPE_ROOT,\n+      id,\n+      nullable,\n+      type: getComplexTypeName(t.items),\n+      children: parseComplexType(t.items),\n+    },\n+  };\n+}\n+\n+/**\n+ * @returns\n+ * {\n+ *  order: [child-id1, child-id2,...]\n+ *  [child-id1]: {\n+ *    id: child-id1,\n+ *    internalType: 'enum-symbol',\n+ *    typeProperties: {\n+ *      symbol: 'symbol1'\n+ *    }\n+ *  },\n+ *  [child-id2]: {\n+ *    id: child-id2,\n+ *    internalType: 'enum-symbol',\n+ *    typeProperties: {\n+ *      symbol: 'symbol2'\n+ *    }\n+ *  }\n+ * }\n+ * @param type avro enum type\n+ * {\n+ *  type: 'enum',\n+ *  symbols: ['symbol1', 'symbol2', ....]\n+ * }\n+ */\n+function parseEnumType(type): IOrderedChildren {\n+  const nullable = isNullable(type);\n+  const t = getNonNullableType(type);\n+  const result = {\n+    order: [],\n+  };\n+  for (const symbol of t.symbols) {\n+    const id = uuidV4();\n+    result.order.push(id);\n+    result[id] = {\n+      id,\n+      internalType: InternalTypesEnum.ENUM_SYMBOL,\n+      nullable,\n+      typeProperties: {\n+        symbol,\n+      },\n+    };\n+  }\n+  return result;\n+}\n+\n+function getMapSubType(type, internalTypeName): INode {\n+  const id = uuidV4();\n+  if (!isComplexType(type)) {\n+    return {\n+      id,\n+      internalType: internalTypeName.simpleType,\n+      nullable: isNullable(type),\n+      type: getNonNullableType(type),\n+    };\n+  } else {\n+    const complexType = getComplexTypeName(type);\n+    const nullable = isNullable(type);\n+    return {\n+      children: parseComplexType(type),\n+      id,\n+      internalType: internalTypeName.complexType,\n+      type: complexType,\n+      nullable,\n+    };\n+  }\n+}\n+/**\n+ * @returns\n+ * {\n+ *   [child-id1]: {\n+ *    \"id\": child-id1,\n+ *    \"internalType\": \"map-keys-simple-type\",\n+ *    \"type\": \"string\"\n+ *  },\n+ *   [child-id2] {\n+ *    \"id\": child-id2,\n+ *    \"internalType\": \"map-values-simple-type\",\n+ *    \"nullable\": false,\n+ *    \"type\": \"string\"\n+ *   }\n+ * }\n+ * @param type avro map type\n+ * {\n+ *  type: {\n+ *    keys: 'string',\n+ *    values: 'string',\n+ *  }\n+ * }\n+ */\n+function parseMapType(type): IOrderedChildren {\n+  const t = getNonNullableType(type);\n+  const keysType = t.keys;\n+  const valuesType = t.values;\n+  const result: Record<string, INode> = {};\n+  const mapKeysSubType = getMapSubType(keysType, {\n+    simpleType: InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE,\n+    complexType: InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT,\n+  });\n+  const mapValuesSubType = getMapSubType(valuesType, {\n+    simpleType: InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE,\n+    complexType: InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ3MDk2Ng==", "bodyText": "this style seemed to be the same across a few places. Does it make sense to extract?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455470966", "createdAt": "2020-07-16T02:22:58Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/RowButtons/FieldAttributes/RecordEnumAttributes.tsx", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import WidgetWrapper from 'components/ConfigurationGroup/WidgetWrapper';\n+import Button from '@material-ui/core/Button';\n+import makeStyles from '@material-ui/core/styles/makeStyles';\n+import { IAttributesComponentProps } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+\n+const useStyles = makeStyles({\n+  root: {\n+    marginTop: '15px',\n+    maxHeight: '250px',\n+    overflowY: 'auto',\n+    '& >div': {\n+      margin: '10px 0',\n+    },\n+  },\n+});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ3MjkzMw==", "bodyText": "minor optimization, should we just cloneDeep here instead of at the beginning of the function? It seems like only this part requires the cloned type object", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455472933", "createdAt": "2020-07-16T02:30:21Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/SchemaHelpers.ts", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  IComplexTypeNames,\n+  ISimpleType,\n+  ILogicalTypeNames,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import { logicalTypeToSimpleTypeMap } from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import cloneDeep from 'lodash/cloneDeep';\n+\n+const displayTypes: Array<ISimpleType | IComplexTypeNames | ILogicalTypeNames> = [\n+  'array',\n+  'enum',\n+  'map',\n+  'record',\n+  'union',\n+  'boolean',\n+  'bytes',\n+  'date',\n+  'decimal',\n+  'double',\n+  'float',\n+  'int',\n+  'long',\n+  'number',\n+  'string',\n+  'time',\n+  'timestamp-micros',\n+  'date',\n+  'time-micros',\n+  'decimal',\n+];\n+\n+/**\n+ * Checks if the current avro type is nullable.\n+ * @param type any avro type (simple/complex types).\n+ */\n+const isNullable = (type) => {\n+  if (Array.isArray(type)) {\n+    return type.find((t) => t === 'null') === 'null';\n+  }\n+  return false;\n+};\n+\n+const isUnion = (type) => {\n+  return Array.isArray(type) && !isNullable(type);\n+};\n+/**\n+ * If the type is nullable get the non-null type for further processing.\n+ * @param type any valid avro type\n+ */\n+const getNonNullableType = (type) => {\n+  if (Array.isArray(type) && !isUnion(type)) {\n+    const nonNullTypes = type.filter((t) => t !== 'null');\n+    if (nonNullTypes.length === 1 && type.length - 1 === nonNullTypes.length) {\n+      return nonNullTypes[0];\n+    }\n+  }\n+  return type;\n+};\n+/**\n+ * Helps in getting the simple type or underlying type in a logical type.\n+ * @param type valid simple/logical avro type\n+ */\n+const getSimpleType = (type) => {\n+  if (typeof type === 'string') {\n+    return type;\n+  }\n+  if (type && type.logicalType) {\n+    return logicalTypeToSimpleTypeMap[type.logicalType];\n+  }\n+  return type;\n+};\n+/**\n+ * Utility to check if the current type is a complex type to tranverse further\n+ * into the schema tree.\n+ * @param complexType any valid complex avro type. (map, array, record, union and enum)\n+ */\n+const isComplexType = (complexType) => {\n+  const nullable = isNullable(complexType);\n+  let type = complexType;\n+  if (nullable) {\n+    type = complexType.filter((t) => t !== 'null').pop();\n+  }\n+  if (typeof type === 'string') {\n+    return false;\n+  }\n+  switch (type.type) {\n+    case 'record':\n+    case 'enum':\n+    case 'array':\n+    case 'map':\n+      return true;\n+    default:\n+      return isUnion(complexType) ? true : false;\n+  }\n+};\n+\n+const isDisplayTypeLogical = ({ type }) => {\n+  switch (type) {\n+    case 'decimal':\n+    case 'date':\n+    case 'time':\n+    case 'timestamp':\n+      return true;\n+    default:\n+      return false;\n+  }\n+};\n+\n+const isDisplayTypeComplex = ({ type }) => {\n+  switch (type) {\n+    case 'record':\n+    case 'enum':\n+    case 'union':\n+    case 'map':\n+    case 'array':\n+      return true;\n+    default:\n+      return isDisplayTypeLogical({ type }) || false;\n+  }\n+};\n+\n+/**\n+ * Utility function to get the complex type names.\n+ * @param complexType any valid complex avro type.\n+ */\n+const getComplexTypeName = (complexType): IComplexTypeNames => {\n+  const c = cloneDeep(complexType);\n+  let type;\n+  if (isNullable(complexType)) {\n+    type = complexType.filter((t) => t !== 'null').pop();\n+    type = type.type;\n+  } else {\n+    type = c.type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ3NDMyOQ==", "bodyText": "I think for this particular case, we can use the getDerivedStateFromProps lifecycle and memoizing it since you need to update the state based on props change. Might future-proof this since componentWillReceiveProps is being deprecated", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455474329", "createdAt": "2020-07-16T02:35:41Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/index.tsx", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import withStyles, { WithStyles, StyleRules } from '@material-ui/styles/withStyles';\n+import ThemeWrapper from 'components/ThemeWrapper';\n+import {\n+  SchemaManager,\n+  INode,\n+  ISchemaManager,\n+  IOnChangeReturnType,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaManager';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import {\n+  IFlattenRowType,\n+  IFieldIdentifier,\n+  IOnChangePayload,\n+} from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import { FieldsList } from 'components/AbstractWidget/SchemaEditor/FieldsList';\n+import {\n+  SchemaValidatorConsumer,\n+  SchemaValidatorProvider,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaValidator';\n+import { dumbestClone as cloneDeep } from 'services/helpers';\n+\n+const styles = (): StyleRules => {\n+  return {\n+    schemaContainer: {\n+      width: '100%',\n+      height: '100%',\n+    },\n+  };\n+};\n+\n+interface ISchemaEditorProps extends WithStyles<typeof styles> {\n+  schema: ISchemaType;\n+  onChange: (props: {\n+    tree: INode;\n+    flat: IFlattenRowType[];\n+    avroSchema: ISchemaType;\n+  }) => IOnChangeReturnType;\n+}\n+\n+interface ISchemaEditorState {\n+  tree: INode;\n+  flat: IFlattenRowType[];\n+}\n+\n+class SchemaEditorBase extends React.Component<ISchemaEditorProps, ISchemaEditorState> {\n+  private schema: ISchemaManager = null;\n+  constructor(props) {\n+    super(props);\n+    const { options } = props;\n+    this.schema = SchemaManager(this.props.schema, options).getInstance();\n+    this.state = {\n+      flat: cloneDeep(this.schema.getFlatSchema()),\n+      tree: cloneDeep(this.schema.getSchemaTree()),\n+    };\n+  }\n+\n+  public componentWillReceiveProps(nextProps) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ3NTQwMg==", "bodyText": "can we use this just as dumbestClone and not alias it with cloneDeep? Might be easier to detect if we need to refactor later simply through search", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r455475402", "createdAt": "2020-07-16T02:39:58Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/index.tsx", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import withStyles, { WithStyles, StyleRules } from '@material-ui/styles/withStyles';\n+import ThemeWrapper from 'components/ThemeWrapper';\n+import {\n+  SchemaManager,\n+  INode,\n+  ISchemaManager,\n+  IOnChangeReturnType,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaManager';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import {\n+  IFlattenRowType,\n+  IFieldIdentifier,\n+  IOnChangePayload,\n+} from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import { FieldsList } from 'components/AbstractWidget/SchemaEditor/FieldsList';\n+import {\n+  SchemaValidatorConsumer,\n+  SchemaValidatorProvider,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaValidator';\n+import { dumbestClone as cloneDeep } from 'services/helpers';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzg4NTg0", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-450788584", "createdAt": "2020-07-17T16:16:21Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjoxNjoyMlrOGzZENg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjoxNjoyMlrOGzZENg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU0MTIzOA==", "bodyText": "I don't see \"isFiledNullable\" defined anywhere - should this just be \"nullable\"? (same for line 145)", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456541238", "createdAt": "2020-07-17T16:16:22Z", "author": {"login": "yukiej"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaGenerator.ts", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  IOrderedChildren,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  ISchemaType,\n+  IEnumFieldBase,\n+  IFieldType,\n+  IRecordField,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import uuidV4 from 'uuid/v4';\n+import {\n+  getDefaultEmptyAvroSchema,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import { isDisplayTypeComplex } from 'components/AbstractWidget/SchemaEditor/SchemaHelpers';\n+\n+function generateArrayType(children: IOrderedChildren, nullable: boolean) {\n+  const finalType = {\n+    type: 'array',\n+    items: null,\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type: childType, nullable: isArrayTypeNullable } = currentChild;\n+    const isArrayTypeComplex = isDisplayTypeComplex({ type: childType });\n+    if (!isArrayTypeComplex) {\n+      finalType.items = isArrayTypeNullable ? [childType, 'null'] : childType;\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(\n+      childType,\n+      currentChild,\n+      currentChild.nullable\n+    );\n+    if (complexType) {\n+      finalType.items = complexType;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateMapType(children: IOrderedChildren, nullable) {\n+  const finalType = {\n+    type: 'map',\n+    keys: 'string',\n+    values: 'string',\n+  };\n+  for (const childId of Object.keys(children)) {\n+    const currentChild = children[childId];\n+    const { type, nullable: isCurrentChildNullable, internalType } = currentChild;\n+    const isMapChildComplexType = isDisplayTypeComplex({ type });\n+    if (!isMapChildComplexType) {\n+      if (internalType === InternalTypesEnum.MAP_KEYS_SIMPLE_TYPE) {\n+        finalType.keys = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      if (internalType === InternalTypesEnum.MAP_VALUES_SIMPLE_TYPE) {\n+        finalType.values = isCurrentChildNullable ? [type, 'null'] : type;\n+      }\n+      continue;\n+    }\n+    // nested complex types.\n+    const complexType = generateSchemaFromComplexType(type, currentChild, isCurrentChildNullable);\n+    if (internalType === InternalTypesEnum.MAP_KEYS_COMPLEX_TYPE_ROOT) {\n+      finalType.keys = complexType as any;\n+    }\n+    if (internalType === InternalTypesEnum.MAP_VALUES_COMPLEX_TYPE_ROOT) {\n+      finalType.values = complexType as any;\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateEnumType(children: IOrderedChildren, currentNode: INode, nullable) {\n+  const finalType: IEnumFieldBase = {\n+    type: 'enum',\n+    symbols: [],\n+  };\n+  const { typeProperties: currentTypeProperties = {} } = currentNode;\n+  if (currentTypeProperties.doc) {\n+    finalType.doc = currentTypeProperties.doc;\n+  }\n+  if (currentTypeProperties.aliases) {\n+    finalType.aliases = currentTypeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { typeProperties } = currentChild;\n+      if (typeProperties.symbol && typeProperties.symbol !== '') {\n+        finalType.symbols.push(typeProperties.symbol);\n+      }\n+      if (typeProperties.doc) {\n+        finalType.doc = typeProperties.doc;\n+      }\n+      if (typeProperties.aliases) {\n+        finalType.aliases = typeProperties.aliases;\n+      }\n+    }\n+  }\n+  return nullable ? [finalType, 'null'] : finalType;\n+}\n+\n+function generateRecordType(children: IOrderedChildren, currentNode: INode, nullable: boolean) {\n+  const finalType: IRecordField = {\n+    type: 'record',\n+    name: currentNode.name || `name-${uuidV4()}`,\n+    fields: [],\n+  };\n+  const { typeProperties = {} } = currentNode;\n+  if (typeProperties.doc) {\n+    finalType.doc = typeProperties.doc;\n+  }\n+  if (typeProperties.aliases) {\n+    finalType.aliases = typeProperties.aliases;\n+  }\n+  if (Array.isArray(children.order)) {\n+    for (const childId of children.order) {\n+      const currentChild = children[childId];\n+      const { name, type, nullable: isFiledNullable } = currentChild;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 137}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzkyNjQx", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-450792641", "createdAt": "2020-07-17T16:22:52Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjoyMjo1MlrOGzZQNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjoyMjo1MlrOGzZQNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU0NDMxMQ==", "bodyText": "nit: The naming of this (currently numeric) variable sounds like it is a boolean, and it looks like it is being used as a boolean value. Maybe it can be modified slightly to have a boolean value.", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456544311", "createdAt": "2020-07-17T16:22:52Z", "author": {"login": "yukiej"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaManagerUtilities.ts", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  INode,\n+  parseUnionType,\n+  parseArrayType,\n+  parseEnumType,\n+  parseMapType,\n+  IOrderedChildren,\n+  parseComplexType,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import {\n+  logicalTypes,\n+  defaultTimeStampTypeProperties,\n+  defaultDecimalTypeProperties,\n+  defaultTimeTypeProperties,\n+  defaultDateTypeProperties,\n+  defaultArrayType,\n+  defaultEnumType,\n+  defaultMapType,\n+  defaultRecordType,\n+  defaultUnionType,\n+  InternalTypesEnum,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+import isEmpty from 'lodash/isEmpty';\n+\n+function getInternalType(tree: INode) {\n+  const hasChildren = tree.children ? Object.keys(tree.children).length : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwODM0OTg3", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-450834987", "createdAt": "2020-07-17T17:28:18Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoyODoxOVrOGzbPvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoyODoxOVrOGzbPvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3Njk1OQ==", "bodyText": "Nit: Should this be capitalized for consistency?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456576959", "createdAt": "2020-07-17T17:28:19Z", "author": {"login": "yukiej"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/RowButtons/FieldAttributes/RecordEnumAttributes.tsx", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import WidgetWrapper from 'components/ConfigurationGroup/WidgetWrapper';\n+import Button from '@material-ui/core/Button';\n+import makeStyles from '@material-ui/core/styles/makeStyles';\n+import { IAttributesComponentProps } from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+\n+const useStyles = makeStyles({\n+  root: {\n+    marginTop: '15px',\n+    maxHeight: '250px',\n+    overflowY: 'auto',\n+    '& >div': {\n+      margin: '10px 0',\n+    },\n+  },\n+});\n+\n+function RecordEnumTypeAttributes({\n+  typeProperties,\n+  onChange,\n+  handleClose,\n+}: IAttributesComponentProps) {\n+  const [doc, setDoc] = React.useState(typeProperties.doc || '');\n+  const [aliases, setAlias] = React.useState(typeProperties.aliases || []);\n+  const classes = useStyles();\n+\n+  const onChangeHandler = () => {\n+    onChange('typeProperties', {\n+      doc,\n+      aliases,\n+    });\n+    handleClose();\n+  };\n+  return (\n+    <React.Fragment>\n+      <div className={classes.root}>\n+        <WidgetWrapper\n+          pluginProperty={{\n+            name: 'doc',\n+            macroSupported: false,\n+            description: 'doc for the record',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwODQyODgx", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-450842881", "createdAt": "2020-07-17T17:40:59Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo0MDo1OVrOGzbn_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo0MDo1OVrOGzbn_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4MzE2NQ==", "bodyText": "Should this be null (without the single quotes)?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456583165", "createdAt": "2020-07-17T17:40:59Z", "author": {"login": "yukiej"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/SchemaTypes.ts", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/**\n+ * Contains types used in parsing an avro schema.\n+ * TODO: This is a work in progress. We don't use these types yet fully\n+ * in the schema parser yet.\n+ */\n+type IComplexTypeNames = 'array' | 'enum' | 'map' | 'record' | 'union';\n+type ISimpleType =\n+  | 'boolean'\n+  | 'bytes'\n+  | 'date'\n+  | 'decimal'\n+  | 'double'\n+  | 'float'\n+  | 'int'\n+  | 'long'\n+  | 'number'\n+  | 'string'\n+  | 'time'\n+  | 'timestamp';\n+type ILogicalTypeNames = 'timestamp-micros' | 'date' | 'time-micros' | 'decimal';\n+\n+type IDisplayType = ISimpleType | IComplexTypeNames;\n+\n+type ISimpleTypeNullable = Array<ISimpleType | 'null'>;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwODQzNzkz", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-450843793", "createdAt": "2020-07-17T17:42:23Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo0MjoyM1rOGzbqsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo0MjoyM1rOGzbqsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4Mzg1Nw==", "bodyText": "Do we know for sure that the error is always in e.message?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456583857", "createdAt": "2020-07-17T17:42:23Z", "author": {"login": "yukiej"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/SchemaValidator/index.tsx", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import cdapavsc from 'services/cdapavscwrapper';\n+import {\n+  SchemaGenerator,\n+  generateSchemaFromComplexType,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaGenerator';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import { IFlattenRowType } from '../EditorTypes';\n+import { isNilOrEmpty } from 'services/helpers';\n+\n+/**\n+ * Schema validator is independent of the schema editor. It takes in a schema tree\n+ * and converts to an avro schema and parses the schema through the avsc library\n+ *\n+ * The context provides a way to broadcast the error to appropriate row\n+ *\n+ * We cannot pin point the error to a specific row as avsc library doesn't\n+ * provide details on the place of failure. We right now surface the error\n+ * to the parent to show the error under a tree.\n+ *\n+ * This is separate in an effort to push this processing to a web worker in the future.\n+ * If we are not able write our own avro schema parser we won't be able to pinpoint\n+ * the error to a specific row. In which we have to recurrsively parse each node\n+ * in the schema tree to identify specific row of issue. This kind of processing\n+ * will bring the UI down which is when we will move this to the web worker.\n+ */\n+interface ISchemaValidatorProviderBaseState {\n+  id: string;\n+  time: number;\n+  error: string;\n+}\n+interface ISchemaValidatorContext {\n+  validate: (id: string, avroSchema: ISchemaType) => ISchemaValidatorProviderBaseState;\n+  errorMap: Record<string, ISchemaValidatorProviderBaseState>;\n+}\n+const SchemaValidatorContext = React.createContext<ISchemaValidatorContext>({\n+  validate: null,\n+  errorMap: {},\n+});\n+const SchemaValidatorConsumer = SchemaValidatorContext.Consumer;\n+\n+class SchemaValidatorProvider extends React.Component {\n+  public defaultState = {\n+    errorMap: {},\n+  };\n+\n+  /**\n+   * The subtree validation takes in a flat field, its ancestors\n+   * and navigates to the appropriate child in the schema tree and parses\n+   * the subtree. If it is valid nothing happens. If it is invalid we add the\n+   * error to the validator context with the id of the immediate parent of the field\n+   *\n+   * The error validation consumer is used per row and whichever row is added\n+   * to the error map gets highlighted with error.\n+   *\n+   * The sibliling line connection gets highlighted when parent is higlighted with an\n+   * error.\n+   * @param field Current flat row updated by user\n+   * @param schemaTree schema tree to validate against.\n+   */\n+  private isSubTreeValidAvroSchema = (field: IFlattenRowType, schemaTree) => {\n+    const { ancestors } = field;\n+    if (!ancestors || (Array.isArray(ancestors) && !ancestors.length)) {\n+      return;\n+    }\n+    if (ancestors.length === 1) {\n+      try {\n+        const entireSchema = SchemaGenerator(schemaTree);\n+        cdapavsc.parse(entireSchema.schema, { wrapUnions: true });\n+      } catch (e) {\n+        return { error: e.message, fieldIdToShowError: ancestors[0] };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwODQ0NDQ0", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-450844444", "createdAt": "2020-07-17T17:43:23Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo0MzoyM1rOGzbsmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo0MzoyM1rOGzbsmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4NDM0Ng==", "bodyText": "Nit: these numbers don't add up to 132", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456584346", "createdAt": "2020-07-17T17:43:23Z", "author": {"login": "yukiej"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/SingleColumnWrapper/index.tsx", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import withStyles from '@material-ui/core/styles/withStyles';\n+import Box from '@material-ui/core/Box';\n+/**\n+ * Row wrapper used for unions and array type rows.\n+ */\n+const SingleColumnWrapper = withStyles(() => {\n+  return {\n+    root: {\n+      width: '132px', // 50 + 100 + 10 from the mapwrapper", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDA1MDMx", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-451005031", "createdAt": "2020-07-17T23:41:20Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMzo0MToyMFrOGzjv0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMzo0MToyMFrOGzjv0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxNjI0MQ==", "bodyText": "This has a leading |. I don't know if it matters though.", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456716241", "createdAt": "2020-07-17T23:41:20Z", "author": {"login": "njbriggs"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/EditorTypes.ts", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+/**\n+ * Contains types used only by the editor for presentation.\n+ */\n+import { ISimpleType, IComplexTypeNames } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import { ITypeProperties } from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import { OperationTypesEnum } from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+\n+type IInternalFieldType =\n+  | 'schema'\n+  | 'record-field-simple-type'\n+  | 'record-field-complex-type-root'\n+  | 'array-simple-type'\n+  | 'array-complex-type'\n+  | 'array-complex-type-root'\n+  | 'enum-symbol'\n+  | 'map-keys-complex-type-root'\n+  | 'map-keys-simple-type'\n+  | 'map-values-complex-type-root'\n+  | 'map-values-simple-type'\n+  | 'union-simple-type'\n+  | 'union-complex-type-root';\n+\n+/**\n+ * Type of flattened row for rendering.\n+ * Contains context for that specific row. We have 'ancestors' here to show the\n+ * indentation for complex types.\n+ *\n+ * Every row will have a hidden flag. Potentially every row can be hidden\n+ * when the user collapses.\n+ *\n+ * Rows that has children will have a boolean collapsed.\n+ */\n+interface IFlattenRowType {\n+  id: string;\n+  name?: string;\n+  type?: ISimpleType | IComplexTypeNames;\n+  internalType: IInternalFieldType;\n+  nullable?: boolean;\n+  ancestors: string[];\n+  typeProperties?: ITypeProperties;\n+  collapsed?: boolean;\n+  hidden?: boolean;\n+}\n+\n+interface IFieldIdentifier {\n+  id: string;\n+  ancestors: string[];\n+}\n+type IOnchangeHandler = (property: string, value?: string | boolean | ITypeProperties) => void;\n+type IRowOnChangeHandler = (id: IFieldIdentifier, payload: IOnChangePayload) => void;\n+interface IFieldTypeBaseProps {\n+  name?: string;\n+  type?: ISimpleType | IComplexTypeNames;\n+  nullable?: boolean;\n+  internalType?: IInternalFieldType;\n+  typeProperties?: ITypeProperties;\n+  onChange: IOnchangeHandler;\n+  onAdd: () => void;\n+  onRemove: () => void;\n+  autoFocus?: boolean;\n+}\n+\n+interface IOnChangePayload {\n+  property?: string;\n+  value?: string | ITypeProperties;\n+  type:\n+    | OperationTypesEnum.UPDATE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDE0NjMx", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-451014631", "createdAt": "2020-07-18T00:37:08Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDozNzowOFrOGzkV1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDozNzowOFrOGzkV1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNTk3NA==", "bodyText": "Seems odd to import IconWrapper from RemoveRowButton?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456725974", "createdAt": "2020-07-18T00:37:08Z", "author": {"login": "njbriggs"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/RowButtons/AddRowButton.tsx", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import * as React from 'react';\n+import AddIcon from '@material-ui/icons/Add';\n+import { IconWrapper } from 'components/AbstractWidget/SchemaEditor/RowButtons/RemoveRowButton';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDE2MzQy", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-451016342", "createdAt": "2020-07-18T00:50:18Z", "commit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDo1MDoxOFrOGzkdoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwMDo1MDoxOFrOGzkdoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNzk2OQ==", "bodyText": "Do we want to add this to If or create a new Hidden component? If seems like it should stay a one-purpose component.", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r456727969", "createdAt": "2020-07-18T00:50:18Z", "author": {"login": "njbriggs"}, "path": "cdap-ui/app/cdap/components/If/index.tsx", "diffHunk": "@@ -14,15 +14,34 @@\n  * the License.\n  */\n import * as React from 'react';\n+import Box from '@material-ui/core/Box';\n+import withStyles from '@material-ui/core/styles/withStyles';\n \n interface IIfComponentProps {\n   condition: boolean;\n   children: React.ReactNode;\n+  invisible?: boolean;\n+  HiddenContainer?: React.ReactNode;\n }\n \n-const If: React.FC<IIfComponentProps> = ({ condition, children }) => {\n+const If: React.FC<IIfComponentProps> = ({\n+  condition,\n+  children,\n+  invisible = false,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44b101ef4258df00e88aab3e9723150a26184af1"}, "originalPosition": 18}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "84df6167ee27f509123bb57aa8f95a7c23327727", "author": {"user": {"login": "ajainarayanan", "name": "Ajai"}}, "url": "https://github.com/cdapio/cdap/commit/84df6167ee27f509123bb57aa8f95a7c23327727", "committedDate": "2020-07-18T05:45:21Z", "message": "Addresses review comments"}, "afterCommit": {"oid": "795ab020a36d3a8af39c7ef0486cd963dc859b2a", "author": {"user": {"login": "ajainarayanan", "name": "Ajai"}}, "url": "https://github.com/cdapio/cdap/commit/795ab020a36d3a8af39c7ef0486cd963dc859b2a", "committedDate": "2020-07-18T05:47:00Z", "message": "Addresses review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMDg5MTMw", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-452089130", "createdAt": "2020-07-21T02:48:47Z", "commit": {"oid": "afc9a67c8553341708b3902970ac2f1751dda93f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjo0ODo0N1rOG0mJ7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjo0ODo0N1rOG0mJ7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNDI3MQ==", "bodyText": "Is exporting INode here a typo? Since we imported it from SchemaParser", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r457804271", "createdAt": "2020-07-21T02:48:47Z", "author": {"login": "yukiej"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/SchemaEditor/Context/SchemaManager.ts", "diffHunk": "@@ -0,0 +1,596 @@\n+/*\n+ * Copyright \u00a9 2020 Cask Data, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+import {\n+  IFlattenRowType,\n+  IFieldIdentifier,\n+  IOnChangePayload,\n+} from 'components/AbstractWidget/SchemaEditor/EditorTypes';\n+import uuidV4 from 'uuid/v4';\n+import isEmpty from 'lodash/isEmpty';\n+import { INode, parseSchema } from 'components/AbstractWidget/SchemaEditor/Context/SchemaParser';\n+import { FlatSchema } from 'components/AbstractWidget/SchemaEditor/Context/FlatSchema';\n+import { ISchemaType } from 'components/AbstractWidget/SchemaEditor/SchemaTypes';\n+import { SchemaGenerator } from 'components/AbstractWidget/SchemaEditor/Context/SchemaGenerator';\n+import isObject from 'lodash/isObject';\n+import {\n+  branchCount,\n+  initChildren,\n+  getInternalType,\n+  initTypeProperties,\n+} from 'components/AbstractWidget/SchemaEditor/Context/SchemaManagerUtilities';\n+import { isNilOrEmpty } from 'services/helpers';\n+import {\n+  InternalTypesEnum,\n+  OperationTypesEnum,\n+  getDefaultEmptyAvroSchema,\n+} from 'components/AbstractWidget/SchemaEditor/SchemaConstants';\n+\n+interface ISchemaManagerOptions {\n+  collapseAll: boolean;\n+}\n+\n+/**\n+ * Interface that defines the schema data structure.\n+ */\n+interface ISchemaManager {\n+  getSchemaTree: () => INode;\n+  getFlatSchema: () => IFlattenRowType[];\n+  getAvroSchema: () => ISchemaType;\n+  onChange: (fieldId: IFieldIdentifier, onChangePayload: IOnChangePayload) => IOnChangeReturnType;\n+}\n+\n+interface IOnChangeReturnType {\n+  fieldIdToFocus?: string;\n+  fieldIndex?: number;\n+  nodeDepth?: number;\n+}\n+\n+/**\n+ * The Schema Manager is the central place to manage the entire schema\n+ *\n+ * Internally it has two data-structures,\n+ * 1. A tree to convert the JSON avro schema to a representation that we can\n+ * process a little bit faster.\n+ * 2. A flat array for presentation purpose.\n+ *\n+ * The tree is used for adding/removing/deleting fields in an avro schema.\n+ * It is a basic tree with id, name, type and children.\n+ *\n+ * The children is usually a map of id to the child node. In specific cases (records and enums)\n+ * we need to maintain the order. So in those cases the children map will have a static 'order'\n+ * array which maintains the order of the children.\n+ *\n+ * The flatten array is derived from the tree. It is nothing but a DFS traversal of the tree\n+ *\n+ * We need two representations because we need one for processing and the other for display purposes.\n+ * Flattening the tree as aray helps us with using virtual scroll which improves performance.\n+ */\n+class SchemaManagerBase implements ISchemaManager {\n+  private schemaTree: INode;\n+  private flatTree: IFlattenRowType[];\n+  private options: ISchemaManagerOptions;\n+  constructor(avroSchema, options: ISchemaManagerOptions) {\n+    this.schemaTree = parseSchema(avroSchema);\n+    this.flatTree = FlatSchema(this.schemaTree, options);\n+    this.options = options;\n+  }\n+\n+  public getSchemaTree = () => this.schemaTree;\n+  public getFlatSchema = () => this.flatTree;\n+  public getAvroSchema = () => SchemaGenerator(this.schemaTree);\n+\n+  // Generic function to insert the newly created child id into the order array\n+  // to maintain order of fields.\n+  private insertNewIdToOrder = (order = [], referenceId) => {\n+    const id = uuidV4();\n+    // +1 to add next to the current element.\n+    const currentIndexOfChild = order.findIndex((c) => c === referenceId) + 1;\n+    order = [...order.slice(0, currentIndexOfChild), id, ...order.slice(currentIndexOfChild)];\n+    return { id, order };\n+  };\n+\n+  private addNewEnumSymbol = (tree: INode, fieldId: IFieldIdentifier) => {\n+    if (!tree.children || (tree.children && !Array.isArray(tree.children.order))) {\n+      return { tree, newTree: undefined, currentField: undefined };\n+    }\n+    const { id = uuidV4(), order = [] } = this.insertNewIdToOrder(\n+      tree.children.order as string[],\n+      fieldId.id\n+    );\n+    tree.children.order = order;\n+    const newlyAddedField = {\n+      id,\n+      internalType: InternalTypesEnum.ENUM_SYMBOL,\n+      typeProperties: {\n+        symbol: '',\n+      },\n+    };\n+    tree.children[id] = newlyAddedField;\n+    return {\n+      tree,\n+      newTree: tree.children[id],\n+      currentField: tree.children[fieldId.id],\n+      newlyAddedField,\n+    };\n+  };\n+\n+  private addNewFieldType = (tree: INode, fieldId: IFieldIdentifier) => {\n+    if (!tree.children || (tree.children && !Array.isArray(tree.children.order))) {\n+      return { tree, newTree: undefined, currentField: undefined };\n+    }\n+    const { id = uuidV4(), order = [] } = this.insertNewIdToOrder(\n+      tree.children.order as string[],\n+      fieldId.id\n+    );\n+    tree.children.order = order;\n+    const newlyAddedField = {\n+      id,\n+      internalType: InternalTypesEnum.RECORD_SIMPLE_TYPE,\n+      nullable: false,\n+      type: 'string',\n+      name: '',\n+    };\n+    tree.children[id] = newlyAddedField;\n+    return {\n+      tree,\n+      newTree: tree.children[id],\n+      currentField: tree.children[fieldId.id],\n+      newlyAddedField,\n+    };\n+  };\n+\n+  private addNewUnionType = (tree: INode, fieldId: IFieldIdentifier) => {\n+    if (!tree.children || (tree.children && !Array.isArray(tree.children.order))) {\n+      return { tree, newTree: undefined, currentField: undefined };\n+    }\n+    const { id = uuidV4(), order = [] } = this.insertNewIdToOrder(\n+      tree.children.order as string[],\n+      fieldId.id\n+    );\n+    tree.children.order = order;\n+    const newlyAddedField = {\n+      id,\n+      internalType: InternalTypesEnum.UNION_SIMPLE_TYPE,\n+      nullable: false,\n+      type: 'string',\n+    };\n+    tree.children[id] = newlyAddedField;\n+    return {\n+      tree,\n+      newTree: tree.children[id],\n+      currentField: tree.children[fieldId.id],\n+      newlyAddedField,\n+    };\n+  };\n+\n+  private addSpecificTypesToTree = (tree: INode, fieldId: IFieldIdentifier) => {\n+    switch (tree.type) {\n+      case 'enum':\n+        return this.addNewEnumSymbol(tree, fieldId);\n+      case 'record':\n+        return this.addNewFieldType(tree, fieldId);\n+      case 'union':\n+        return this.addNewUnionType(tree, fieldId);\n+      default:\n+        return { tree: undefined, newTree: undefined, currentField: undefined };\n+    }\n+  };\n+\n+  private addToTree = (\n+    tree: INode,\n+    fieldId: IFieldIdentifier\n+  ): {\n+    tree: INode;\n+    newTree: INode;\n+    currentField: INode;\n+  } => {\n+    if (!tree) {\n+      return { tree: undefined, newTree: undefined, currentField: undefined };\n+    }\n+    // Only the top level record fields will have one ancestors. So just add the specific type.\n+    if (fieldId.ancestors.length === 1) {\n+      return this.addSpecificTypesToTree(tree, fieldId);\n+    }\n+    // Traverse to the specific child tree in the main schema tree.\n+    const { tree: child, newTree, currentField } = this.addToTree(\n+      tree.children[fieldId.ancestors[1]],\n+      { id: fieldId.id, ancestors: fieldId.ancestors.slice(1) }\n+    );\n+    // Mutates the main schema tree. This a performance optimization that we need to\n+    // to avoid generating huge JSONs on every mutation of the schema.\n+    return {\n+      tree: {\n+        ...tree,\n+        children: {\n+          ...tree.children,\n+          [child.id]: child,\n+        },\n+      },\n+      newTree,\n+      currentField,\n+    };\n+  };\n+\n+  /**\n+   * Add a new field to the current index. This could mean,\n+   *  - Add a new field in record schema\n+   *  - Add a new Symbol to enum\n+   *  - Add a new union type\n+   * The results of addition are,\n+   *  - Modifying the schema tree to add the new field (tree)\n+   *  - Newly added tree\n+   *  - Current field to focus on\n+   * We don't re-flatten the entire schema tree all the time. We calculate only the newly\n+   * added field, it could be a single field or a tree in case of union or map or enum,\n+   * and then flatten that sub tree and insert into our flattened array.\n+   *\n+   * @param fieldId ID of the current row being updated.\n+   */\n+  private add = (fieldId: IFieldIdentifier): IOnChangeReturnType => {\n+    const currentIndex = this.flatTree.findIndex((f) => f.id === fieldId.id);\n+    const matchingEntry = this.flatTree[currentIndex];\n+    let result: { tree: INode; newTree: INode; currentField: INode };\n+    let newFlatSubTree: IFlattenRowType[];\n+    const idObj = { id: matchingEntry.id, ancestors: matchingEntry.ancestors };\n+    // The result is the newly modified tree, the newly added tree and the current field\n+    // The modified tree is the entire schema tree that we maintain\n+    // The new tree is for flattening and inserting it into the flattened array\n+    // The current field is then passed on to the schema editor for presentation (focus on that specific row)\n+    result = this.addToTree(this.schemaTree, idObj);\n+    const customOptions = {\n+      ...this.options,\n+      collapseAll: false,\n+    };\n+    newFlatSubTree = FlatSchema(result.newTree, customOptions, matchingEntry.ancestors);\n+    this.schemaTree = result.tree;\n+    const currentFieldBranchCount = branchCount(result.currentField);\n+    this.flatTree = [\n+      ...this.flatTree.slice(0, currentIndex + currentFieldBranchCount + 1),\n+      ...newFlatSubTree,\n+      ...this.flatTree.slice(currentIndex + currentFieldBranchCount + 1),\n+    ];\n+    return {\n+      fieldIdToFocus: this.flatTree[currentIndex + currentFieldBranchCount + 1].id,\n+      fieldIndex: currentIndex + currentFieldBranchCount + 1,\n+    };\n+  };\n+\n+  private removeFromTree = (tree: INode, fieldId) => {\n+    if (!tree) {\n+      return { tree: undefined };\n+    }\n+    if (fieldId.ancestors.length === 1) {\n+      const field = { ...tree.children[fieldId.id] };\n+      let newField;\n+      if (Array.isArray(tree.children.order) && Object.keys(tree.children).length === 2) {\n+        const {\n+          tree: treeWithDefaultChild,\n+          newlyAddedField: defaultNewField,\n+        } = this.addSpecificTypesToTree(tree, fieldId);\n+        newField = defaultNewField;\n+        tree = treeWithDefaultChild;\n+      }\n+      if (Array.isArray(tree.children.order)) {\n+        tree.children.order = tree.children.order.filter((id) => id !== fieldId.id);\n+      }\n+      delete tree.children[fieldId.id];\n+      return { tree, removedField: field, newlyAddedField: newField };\n+    }\n+    const { tree: newTree, removedField, newlyAddedField } = this.removeFromTree(\n+      tree.children[fieldId.ancestors[1]],\n+      {\n+        id: fieldId.id,\n+        ancestors: fieldId.ancestors.slice(1),\n+      }\n+    );\n+    return {\n+      tree: {\n+        ...tree,\n+        children: {\n+          ...tree.children,\n+          ...newTree,\n+        },\n+      },\n+      removedField,\n+      newlyAddedField,\n+    };\n+  };\n+\n+  /**\n+   * Remove a field from the schema. This could be a simple type of row\n+   * or a complex type.\n+   * There is also a need for us to add a new row as part of removal.\n+   *\n+   * For instance: This comes up when users delete all the fields in\n+   * a record type. We can't have all the fields deleted. Upon the\n+   * deleting the final field we still need to add a new field for\n+   * the user to be able to keep the record type.\n+   * @param fieldId ID of the current row being updated.\n+   */\n+  private remove = (fieldId: IFieldIdentifier): IOnChangeReturnType => {\n+    const currentIndex = this.flatTree.findIndex((f) => f.id === fieldId.id);\n+    const matchingEntry = this.flatTree[currentIndex];\n+    const idObj = { id: matchingEntry.id, ancestors: matchingEntry.ancestors };\n+    const { tree, removedField, newlyAddedField } = this.removeFromTree(this.schemaTree, idObj);\n+    this.schemaTree = tree;\n+    // branch count to determine the slice in the flattened array.\n+    // If the user removed a complex type we need to remove the row\n+    // and all of its children.\n+    const childrenInBranch = branchCount(removedField);\n+    let newFlatSubTree = [];\n+    // Newly added row in case we need to maintain the structure of say, a record or an enum.\n+    if (newlyAddedField) {\n+      const customOptions = {\n+        ...this.options,\n+        collapseAll: false,\n+      };\n+      newFlatSubTree = FlatSchema(newlyAddedField, customOptions, matchingEntry.ancestors);\n+    }\n+    this.flatTree = [\n+      ...this.flatTree.slice(0, currentIndex),\n+      ...newFlatSubTree,\n+      ...this.flatTree.slice(currentIndex + 1 + childrenInBranch), // remove current row along with its children.\n+    ];\n+    return {\n+      fieldIdToFocus: this.flatTree[currentIndex - 1].id,\n+      fieldIndex: currentIndex - 1,\n+    };\n+  };\n+\n+  private updateTree = (\n+    tree: INode,\n+    fieldId: IFieldIdentifier,\n+    { property, value }: Partial<IOnChangePayload>\n+  ): {\n+    tree: INode;\n+    childrenCount: number;\n+    newTree: INode;\n+  } => {\n+    if (!tree) {\n+      return { childrenCount: undefined, tree: undefined, newTree: undefined };\n+    }\n+    if (fieldId.ancestors.length === 1 && !isEmpty(tree.children[fieldId.id])) {\n+      if (property === 'typeProperties' && typeof value === 'object') {\n+        tree.children[fieldId.id][property] = {\n+          ...tree.children[fieldId.id][property],\n+          ...value,\n+        };\n+      } else {\n+        tree.children[fieldId.id][property] = value;\n+      }\n+      let childrenInBranch = 0;\n+      let newChildTree: INode;\n+      if (property === 'type') {\n+        childrenInBranch = branchCount(tree.children[fieldId.id]);\n+        tree.children[fieldId.id].children = initChildren(value);\n+        newChildTree = tree.children[fieldId.id];\n+        tree.children[fieldId.id].internalType = getInternalType(tree.children[fieldId.id]);\n+        tree.children[fieldId.id].typeProperties = initTypeProperties(tree.children[fieldId.id]);\n+      }\n+      return {\n+        tree,\n+        childrenCount: childrenInBranch,\n+        newTree: newChildTree,\n+      };\n+    }\n+\n+    const { tree: child, childrenCount, newTree } = this.updateTree(\n+      tree.children[fieldId.ancestors[1]],\n+      { id: fieldId.id, ancestors: fieldId.ancestors.slice(1) },\n+      { property, value }\n+    );\n+    return {\n+      tree: {\n+        ...tree,\n+        children: {\n+          ...tree.children,\n+          [child.id]: child,\n+        },\n+      },\n+      childrenCount,\n+      newTree,\n+    };\n+  };\n+\n+  /**\n+   * Updating a field could be changing the 'name' or the 'type'.\n+   *\n+   * Updating 'name' is pretty straight forward and involves no complicated steps.\n+   * Updating 'type' involves changing from a simple type to a complex type or vice-versa.\n+   *\n+   * This again involves addition or removal of nodes in the schema.\n+   * @param fieldId ID of the current row being updated.\n+   * @param onChangePayload - { property, value } - payload for updating.\n+   */\n+  private update = (\n+    fieldId: IFieldIdentifier,\n+    { property, value }: Partial<IOnChangePayload>\n+  ): IOnChangeReturnType => {\n+    const index = this.flatTree.findIndex((f) => f.id === fieldId.id);\n+    if (property === 'typeProperties' && typeof value === 'object') {\n+      this.flatTree[index][property] = {\n+        ...this.flatTree[index][property],\n+        ...value,\n+      };\n+    } else {\n+      this.flatTree[index][property] = value;\n+    }\n+    const matchingEntry = this.flatTree[index];\n+    let result: { tree: INode; childrenCount: number; newTree: INode };\n+    let newFlatSubTree: IFlattenRowType[];\n+    const idObj = { id: matchingEntry.id, ancestors: matchingEntry.ancestors };\n+    result = this.updateTree(this.schemaTree, idObj, { property, value });\n+    this.schemaTree = result.tree;\n+    // If user changed a complex type to a simple type or to another complex type we need\n+    // to remove the complex type children first\n+    this.flatTree = [\n+      ...this.flatTree.slice(0, index),\n+      ...this.flatTree.slice(index + result.childrenCount + (!result.newTree ? 0 : 1)),\n+    ];\n+    const customOptions = {\n+      ...this.options,\n+      collapseAll: false,\n+    };\n+    // And then add the newly updated complex type children to the flattened array.\n+    if (result.newTree) {\n+      newFlatSubTree = FlatSchema(result.newTree, customOptions, matchingEntry.ancestors);\n+      this.flatTree = [\n+        ...this.flatTree.slice(0, index),\n+        ...newFlatSubTree,\n+        ...this.flatTree.slice(index),\n+      ];\n+    }\n+    // newFlatSubTree will be of length 1 for simple type changes.\n+    if (Array.isArray(newFlatSubTree) && newFlatSubTree.length > 1) {\n+      return {\n+        fieldIdToFocus: this.flatTree[index + 1].id,\n+        fieldIndex: index + 1,\n+      };\n+    }\n+    return {};\n+  };\n+\n+  /**\n+   * This is to identify the root tree from the flattened object.\n+   * @param fieldObj - id of the flattened row\n+   * @param schemaTree - Tree to find the root node.\n+   */\n+  private getFieldObjFromTree = (fieldObj, schemaTree: INode): INode => {\n+    if (fieldObj.id === schemaTree.id) {\n+      return schemaTree;\n+    }\n+    if (fieldObj.ancestors.length === 1) {\n+      return schemaTree.children[fieldObj.id];\n+    }\n+    return this.getFieldObjFromTree(\n+      { id: fieldObj.id, ancestors: fieldObj.ancestors.slice(1) },\n+      schemaTree.children[fieldObj.ancestors[1]]\n+    );\n+  };\n+\n+  /**\n+   * Function to collapse/expand a tree.\n+   * @param fieldId - id of the field for which the children needs to be\n+   * collapsed or expanded.\n+   */\n+  private collapse = (fieldId: IFieldIdentifier): IOnChangeReturnType => {\n+    const matchingIndex = this.flatTree.findIndex((row) => row.id === fieldId.id);\n+    const matchingEntry = this.flatTree[matchingIndex];\n+    if (!matchingEntry) {\n+      return {};\n+    }\n+    const idObj = { id: matchingEntry.id, ancestors: matchingEntry.ancestors };\n+    const fieldObj = this.getFieldObjFromTree(idObj, this.getSchemaTree());\n+    this.flatTree[matchingIndex].collapsed = !this.flatTree[matchingIndex].collapsed;\n+    const nodeDepth = this.calculateNodeDepthMap(fieldObj);\n+    for (let i = 1; i <= nodeDepth; i++) {\n+      const currentRow = this.flatTree[matchingIndex + i];\n+      const { collapsed } = currentRow;\n+      if (typeof collapsed === 'boolean') {\n+        if (collapsed === true) {\n+          const childTreeDepth = this.calculateNodeDepthMap(\n+            this.getFieldObjFromTree(currentRow, this.getSchemaTree())\n+          );\n+          this.flatTree[matchingIndex + i].hidden = this.flatTree[matchingIndex].collapsed;\n+          i += childTreeDepth;\n+          continue;\n+        } else {\n+          this.flatTree[matchingIndex + i].collapsed = this.flatTree[matchingIndex].collapsed;\n+        }\n+      }\n+      this.flatTree[matchingIndex + i].hidden = this.flatTree[matchingIndex].collapsed;\n+    }\n+    return {};\n+  };\n+\n+  /**\n+   * Identify the depth of a parent node. Depth here defines all the immediate children and all\n+   * the children of childrens and so on and so forth. We need to calculate this depth because\n+   * we do a DFS of our tree to flatten. Now if we need to collapse a subtree we need all the children\n+   * (both direct and indirect) because in a flattened array the children comes first before the sibling.\n+   * @param tree - Root node to find the depth.\n+   */\n+  private calculateNodeDepthMap = (tree: INode): number => {\n+    let totalDepth = 0;\n+    if (isObject(tree.children) && Object.keys(tree.children).length) {\n+      totalDepth += Object.keys(tree.children).filter((c) => c !== 'order').length;\n+      for (const childId of Object.keys(tree.children)) {\n+        if (childId === 'order') {\n+          continue;\n+        }\n+        const childCount = this.calculateNodeDepthMap(tree.children[childId]);\n+        totalDepth += childCount;\n+      }\n+    }\n+    return totalDepth;\n+  };\n+\n+  /**\n+   * The generic onChange is supposed to handle all types of mutation to the schema.\n+   * This onChange is the handler for any changes that happen in the schema (not to be confused with\n+   * the onChange in the schemaEditor).\n+   * @param fieldId - unique id to identify every field in the schema tree.\n+   * @param onChangePayload {type, property, value} - Every onchange call will have the type of\n+   * change, the property and the value. The type could be 'add', 'update', 'remove' and property could be\n+   * 'name' or 'typeProperties'\n+   */\n+  public onChange = (\n+    fieldId: IFieldIdentifier,\n+    { type, property, value }: IOnChangePayload\n+  ): IOnChangeReturnType => {\n+    if (isNilOrEmpty(fieldId)) {\n+      return;\n+    }\n+    switch (type) {\n+      case OperationTypesEnum.UPDATE:\n+        return this.update(fieldId, { property, value });\n+      case OperationTypesEnum.ADD:\n+        return this.add(fieldId);\n+      case OperationTypesEnum.REMOVE:\n+        return this.remove(fieldId);\n+      case OperationTypesEnum.COLLAPSE:\n+        return this.collapse(fieldId);\n+    }\n+  };\n+}\n+\n+/**\n+ * Default options for the schema manager. This as of now only has collapseAll.\n+ * Will expand to restricting schema types.\n+ */\n+const defaultOptions: ISchemaManagerOptions = {\n+  collapseAll: true,\n+};\n+\n+function SchemaManager(\n+  avroSchema = getDefaultEmptyAvroSchema(),\n+  options: ISchemaManagerOptions = defaultOptions\n+) {\n+  if (!options) {\n+    options = defaultOptions;\n+  } else {\n+    options = {\n+      ...defaultOptions,\n+      ...options,\n+    };\n+  }\n+  const schemaTreeInstance = new SchemaManagerBase(avroSchema, options);\n+  return {\n+    getInstance: () => schemaTreeInstance,\n+  };\n+}\n+export { SchemaManager, INode, ISchemaManager, IOnChangeReturnType, ISchemaManagerOptions };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afc9a67c8553341708b3902970ac2f1751dda93f"}, "originalPosition": 596}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMDg5MzA5", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-452089309", "createdAt": "2020-07-21T02:49:24Z", "commit": {"oid": "afc9a67c8553341708b3902970ac2f1751dda93f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNDcwMTQ4", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-452470148", "createdAt": "2020-07-21T13:43:25Z", "commit": {"oid": "afc9a67c8553341708b3902970ac2f1751dda93f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzo0MzoyNVrOG04msQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzo0MzoyNVrOG04msQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwNjU0NQ==", "bodyText": "we can use theme in withStyles I believe.\nwithStyles((theme))", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r458106545", "createdAt": "2020-07-21T13:43:25Z", "author": {"login": "jennac3"}, "path": "cdap-ui/app/cdap/components/AbstractWidget/FormInputs/Select/index.tsx", "diffHunk": "@@ -21,35 +21,59 @@ import { IWidgetProps } from 'components/AbstractWidget';\n import { objectQuery } from 'services/helpers';\n import { WIDGET_PROPTYPES } from 'components/AbstractWidget/constants';\n import withStyles from '@material-ui/core/styles/withStyles';\n-\n+import { blue } from 'components/ThemeWrapper/colors';\n const CustomizedInput = withStyles(() => {\n   return {\n     input: {\n       padding: '7px 18px 7px 12px',\n       '&:focus': {\n         backgroundColor: 'transparent',\n+        outline: `1px solid ${blue[100]}`,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afc9a67c8553341708b3902970ac2f1751dda93f"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "887b507714a645701be4d58db5b91c87d55db220", "author": {"user": {"login": "ajainarayanan", "name": "Ajai"}}, "url": "https://github.com/cdapio/cdap/commit/887b507714a645701be4d58db5b91c87d55db220", "committedDate": "2020-07-22T16:16:03Z", "message": "[CDAP-16850] Adds new Schema Editor. It is a complete rewrite from scratch.\n\n**Context**\n- This is a complete rewrite of schema editor.\n- The goal of the schema to be more scalable and accommodate for editing attributes of certain avro schema types.\n\n**Design**\n- The schema editor design can be split into three parts,\n  - Presentation - Editor\n  - State management - Schema Manager\n  - Validator - Schema Validator to validate schema\n- Editor represents the visual part of the schema editor. At the core, it renders a list + manages changes to the schema (crud operation)\n- Schema Manager is the underlying state management for any operation happening in the Editor. Internally it maintains a tree and a flat list each representing the same avro schema. Tree - for faster manipulation and Flat list - for easier rendering\n- Validator is the module used to validate the schema after each operation. We use customized version of [avsc library](https://github.com/cdapio/ui-schema-parser) to suit our needs\n\n**Implementation**\n\n_Schema Manager_\n- For any avro schema generates a tree and a flat array\n- For each operation (add/remove/update) the Schema Manager mutates the tree. This results in either adding a new subtree, removing a new subtree or modifying the existing subtree.\n- This subtree is then flattened and inserted at appropriate position to the existing flat array.\n- Tree is a direct tree representation of the avro schema\n- List is a DFS traversed list generated from the above tree.\n\n_Editor_\n- List contains each node in the avro schema\n- Each node in the list is identified by a unique id\n- Each node contains a reference to #of ancestors\n- Each row is either a two column (unions or maps) or three column like record field with name(or label), type and action buttons\n\n**Other component changes**\n- Modified `VirtualScroll` to include a `childrenUnderFoldScroll`. This is to increase the rendered child count on scroll to avoid showing empty white space. This is a common occurrence when using a virtual scroll as browser cannot catch up with scroll and rendering the underlying component quick enough.\n- Modified `Select` dropdown to have a dense option to reduce padding.\n- Modified `TextboxOnValium` to accept a ref prop to be able to pass on the underlying input element to the parent.\n- Modified `If` to accept an additional `invisible` property to set `visibility: hidden` to children. This is to render empty space in place where the component needs to be showed."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1c7127d806a012faadb9caaed8d6f4edffb99b6e", "author": {"user": {"login": "ajainarayanan", "name": "Ajai"}}, "url": "https://github.com/cdapio/cdap/commit/1c7127d806a012faadb9caaed8d6f4edffb99b6e", "committedDate": "2020-07-21T19:08:17Z", "message": "Fixes unnecessary export from SchemaManager"}, "afterCommit": {"oid": "887b507714a645701be4d58db5b91c87d55db220", "author": {"user": {"login": "ajainarayanan", "name": "Ajai"}}, "url": "https://github.com/cdapio/cdap/commit/887b507714a645701be4d58db5b91c87d55db220", "committedDate": "2020-07-22T16:16:03Z", "message": "[CDAP-16850] Adds new Schema Editor. It is a complete rewrite from scratch.\n\n**Context**\n- This is a complete rewrite of schema editor.\n- The goal of the schema to be more scalable and accommodate for editing attributes of certain avro schema types.\n\n**Design**\n- The schema editor design can be split into three parts,\n  - Presentation - Editor\n  - State management - Schema Manager\n  - Validator - Schema Validator to validate schema\n- Editor represents the visual part of the schema editor. At the core, it renders a list + manages changes to the schema (crud operation)\n- Schema Manager is the underlying state management for any operation happening in the Editor. Internally it maintains a tree and a flat list each representing the same avro schema. Tree - for faster manipulation and Flat list - for easier rendering\n- Validator is the module used to validate the schema after each operation. We use customized version of [avsc library](https://github.com/cdapio/ui-schema-parser) to suit our needs\n\n**Implementation**\n\n_Schema Manager_\n- For any avro schema generates a tree and a flat array\n- For each operation (add/remove/update) the Schema Manager mutates the tree. This results in either adding a new subtree, removing a new subtree or modifying the existing subtree.\n- This subtree is then flattened and inserted at appropriate position to the existing flat array.\n- Tree is a direct tree representation of the avro schema\n- List is a DFS traversed list generated from the above tree.\n\n_Editor_\n- List contains each node in the avro schema\n- Each node in the list is identified by a unique id\n- Each node contains a reference to #of ancestors\n- Each row is either a two column (unions or maps) or three column like record field with name(or label), type and action buttons\n\n**Other component changes**\n- Modified `VirtualScroll` to include a `childrenUnderFoldScroll`. This is to increase the rendered child count on scroll to avoid showing empty white space. This is a common occurrence when using a virtual scroll as browser cannot catch up with scroll and rendering the underlying component quick enough.\n- Modified `Select` dropdown to have a dense option to reduce padding.\n- Modified `TextboxOnValium` to accept a ref prop to be able to pass on the underlying input element to the parent.\n- Modified `If` to accept an additional `invisible` property to set `visibility: hidden` to children. This is to render empty space in place where the component needs to be showed."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNTgyMjI1", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-453582225", "createdAt": "2020-07-22T18:34:58Z", "commit": {"oid": "887b507714a645701be4d58db5b91c87d55db220"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a02c36f1b58ff8831547154710f9ae70b133f56", "author": {"user": {"login": "ajainarayanan", "name": "Ajai"}}, "url": "https://github.com/cdapio/cdap/commit/7a02c36f1b58ff8831547154710f9ae70b133f56", "committedDate": "2020-07-23T19:49:29Z", "message": "Integrates new Schema Editor to pipeline plugins\n\n**Approach**\n- Compose `SchemaEditor` into a new component named `PluginSchemaEditor` along with other `Actions` available on the schema.\n- Have retained the logic to enable/disable the schema actions in angular for the most part.\n- Some of the logic, like export, are still in react. We use the same event based system for import/export/clear\n- PluginSchemaEditor will also determine the height of the container to determine the number of rows that needs to be rendered (required by the virtual scroll)\n- Changes avro schema types from string to enum\n- Fixes `SchemaManager` to handle logical types for all complex types\n- Adds validation on import of schema\n- Adds the ability to set `disabled` for the schema editor to become non-editable.\n\n**Note**\n- This change achieves feature parity with existing schema editor.\n- However at any point if the user thinks they are experiencing any regressions they can switch off the experiment which will enable them to use the older schema editor\n- The experiment will be on by default.\n- All the changes to angular side are additive and does not remove any existing functionality."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NTA1OTg1", "url": "https://github.com/cdapio/cdap/pull/12450#pullrequestreview-454505985", "createdAt": "2020-07-23T21:24:36Z", "commit": {"oid": "502263be6da76f8f2c7f98b8fb5c40cbdd484ea3"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyNDozN1rOG2cGOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyNDozN1rOG2cGOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNjYzMw==", "bodyText": "nit: perhaps remove the Demo for part from this description since this lab is not for the demo page anymore?", "url": "https://github.com/cdapio/cdap/pull/12450#discussion_r459736633", "createdAt": "2020-07-23T21:24:37Z", "author": {"login": "elfenheart"}, "path": "cdap-ui/app/cdap/components/Lab/experiment-list.tsx", "diffHunk": "@@ -35,6 +35,6 @@ export default [\n       'Demo for new SchemaEditor. Includes complete rewrite in React + perf improvements',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "502263be6da76f8f2c7f98b8fb5c40cbdd484ea3"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad2c6561ca957c119cacd5f9d3b45c2e795d7fa0", "author": {"user": {"login": "ajainarayanan", "name": "Ajai"}}, "url": "https://github.com/cdapio/cdap/commit/ad2c6561ca957c119cacd5f9d3b45c2e795d7fa0", "committedDate": "2020-07-23T22:35:12Z", "message": "Load default experiments to localStorage on initial load + sets new schema editor experiment to true by default"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "502263be6da76f8f2c7f98b8fb5c40cbdd484ea3", "author": {"user": {"login": "ajainarayanan", "name": "Ajai"}}, "url": "https://github.com/cdapio/cdap/commit/502263be6da76f8f2c7f98b8fb5c40cbdd484ea3", "committedDate": "2020-07-23T21:13:18Z", "message": "Load default experiments to localStorage on initial load + sets new schema editor experiment to true by default"}, "afterCommit": {"oid": "ad2c6561ca957c119cacd5f9d3b45c2e795d7fa0", "author": {"user": {"login": "ajainarayanan", "name": "Ajai"}}, "url": "https://github.com/cdapio/cdap/commit/ad2c6561ca957c119cacd5f9d3b45c2e795d7fa0", "committedDate": "2020-07-23T22:35:12Z", "message": "Load default experiments to localStorage on initial load + sets new schema editor experiment to true by default"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1809, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}