{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4MjY1MTU3", "number": 627, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTozOTo1M1rOEOOHqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0NzoyMlrOEOORNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzQ2ODU4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTozOTo1M1rOGxP7JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTozOTo1M1rOGxP7JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDMwOQ==", "bodyText": "You can put this two lines higher and remove line 49 as well", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454294309", "createdAt": "2020-07-14T11:39:53Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzQ3MzE0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0MTowOVrOGxP9tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjo0MTo1MlrOGxR62Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng==", "bodyText": "There are lot of @Pure in the file that declares IntegerRange", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454294966", "createdAt": "2020-07-14T11:41:09Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxODUzMA==", "bodyText": "I guess you'll handle this in another MR? Don't see any changes now", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454318530", "createdAt": "2020-07-14T12:27:20Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng=="}, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyMjY1NQ==", "bodyText": "? replaced it with a for loop ?!?", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454322655", "createdAt": "2020-07-14T12:34:03Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng=="}, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyNTY5NQ==", "bodyText": "That also works \ud83d\udc4d\nWhat I meant by my comment is that the file that declares IntegerRange has already undergone the xtend->java process, but we forgot to remove the @Pure annotations so we should also get rid of those", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454325695", "createdAt": "2020-07-14T12:39:34Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng=="}, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyNjM0NQ==", "bodyText": "no integerrange always was java. and its in xbase lib. thus keep the pure for xtend (only) users", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454326345", "createdAt": "2020-07-14T12:40:44Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng=="}, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyNzAwMQ==", "bodyText": "I see, makes sense", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454327001", "createdAt": "2020-07-14T12:41:52Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng=="}, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzQ3NTMyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0MTo0OVrOGxP--w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0MTo0OVrOGxP--w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTI5MQ==", "bodyText": "No need for the intValue() AFAIK", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454295291", "createdAt": "2020-07-14T11:41:49Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzQ3NzI0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0MjoyM1rOGxQAHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoyMToyNVrOGxRMSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTU4Mg==", "bodyText": "newLines++ or +=1?", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454295582", "createdAt": "2020-07-14T11:42:23Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxNTA4MQ==", "bodyText": "didnt wanna change this", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454315081", "createdAt": "2020-07-14T12:21:25Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTU4Mg=="}, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzQ3OTQ3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0MzowOFrOGxQBaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0MzowOFrOGxQBaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTkxMw==", "bodyText": "You can just make this one else if", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454295913", "createdAt": "2020-07-14T11:43:08Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzQ4NjQ1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0NToyMVrOGxQFuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoxNjo0OVrOGxRCxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzAxNw==", "bodyText": "Why is this a field? It's only used in one method", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454297017", "createdAt": "2020-07-14T11:45:21Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxMjY0Nw==", "bodyText": "refactoring error", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454312647", "createdAt": "2020-07-14T12:16:49Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzAxNw=="}, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzQ5MDIyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0NjoyOFrOGxQH8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0NjoyOFrOGxQH8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzU4NA==", "bodyText": "No need for booleanValue()", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454297584", "createdAt": "2020-07-14T11:46:28Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {\n+\t\t\t\t\t\t\tcomment = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (comment) {\n+\t\t\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, node.getOffset()));\n+\t\t\t\t}\n+\t\t\t\tresult.getLeafs().add(new CommentInfo(result, node, newLines, trailing));\n+\t\t\t} else {\n+\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, node, newLines, node.getOffset()));\n+\t\t\t}\n+\t\t\tif (newLines > 0) {\n+\t\t\t\ttrailing = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\tint whitespaceOffset = 0;\n+\t\t\tif (result.getLeafs().isEmpty()) {\n+\t\t\t\twhitespaceOffset = offset;\n+\t\t\t} else {\n+\t\t\t\twhitespaceOffset = IterableExtensions.last(result.getLeafs()).getNode().getEndOffset();\n+\t\t\t}\n+\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, whitespaceOffset));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic HiddenLeafs getHiddenLeafsAfter(INode node) {\n+\t\tILeafNode start = findPreviousLeaf(node, l -> !l.isHidden());\n+\t\tif (start != null) {\n+\t\t\treturn newHiddenLeafs(start.getEndOffset(), findNextHiddenLeafs(start));\n+\t\t} else {\n+\t\t\toffset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected List<ILeafNode> findNextHiddenLeafs(INode node) {\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tNodeIterator ni = new NodeIterator(node);\n+\t\twhile (ni.hasNext()) {\n+\t\t\tINode next = ni.next();\n+\t\t\tif (next instanceof ILeafNode) {\n+\t\t\t\tif (((ILeafNode) next).isHidden()) {\n+\t\t\t\t\tresult.add((ILeafNode) next);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected ILeafNode findPreviousLeaf(INode node, Function1<? super ILeafNode, ? extends Boolean> matches) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tif (current instanceof ILeafNode && matches.apply((ILeafNode) current).booleanValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzQ5MDQ4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0NjozMlrOGxQIFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0NjozMlrOGxQIFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzYyMg==", "bodyText": "No need for booleanValue()", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454297622", "createdAt": "2020-07-14T11:46:32Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {\n+\t\t\t\t\t\t\tcomment = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (comment) {\n+\t\t\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, node.getOffset()));\n+\t\t\t\t}\n+\t\t\t\tresult.getLeafs().add(new CommentInfo(result, node, newLines, trailing));\n+\t\t\t} else {\n+\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, node, newLines, node.getOffset()));\n+\t\t\t}\n+\t\t\tif (newLines > 0) {\n+\t\t\t\ttrailing = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\tint whitespaceOffset = 0;\n+\t\t\tif (result.getLeafs().isEmpty()) {\n+\t\t\t\twhitespaceOffset = offset;\n+\t\t\t} else {\n+\t\t\t\twhitespaceOffset = IterableExtensions.last(result.getLeafs()).getNode().getEndOffset();\n+\t\t\t}\n+\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, whitespaceOffset));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic HiddenLeafs getHiddenLeafsAfter(INode node) {\n+\t\tILeafNode start = findPreviousLeaf(node, l -> !l.isHidden());\n+\t\tif (start != null) {\n+\t\t\treturn newHiddenLeafs(start.getEndOffset(), findNextHiddenLeafs(start));\n+\t\t} else {\n+\t\t\toffset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected List<ILeafNode> findNextHiddenLeafs(INode node) {\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tNodeIterator ni = new NodeIterator(node);\n+\t\twhile (ni.hasNext()) {\n+\t\t\tINode next = ni.next();\n+\t\t\tif (next instanceof ILeafNode) {\n+\t\t\t\tif (((ILeafNode) next).isHidden()) {\n+\t\t\t\t\tresult.add((ILeafNode) next);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected ILeafNode findPreviousLeaf(INode node, Function1<? super ILeafNode, ? extends Boolean> matches) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tif (current instanceof ILeafNode && matches.apply((ILeafNode) current).booleanValue()) {\n+\t\t\treturn (ILeafNode) current;\n+\t\t}\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (previous instanceof ILeafNode && matches.apply((ILeafNode) previous).booleanValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzQ5MzAxOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0NzoyMlrOGxQJog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoxNzozM1rOGxREWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5ODAxOA==", "bodyText": "Seems like a pretty useless comment to me", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454298018", "createdAt": "2020-07-14T11:47:22Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {\n+\t\t\t\t\t\t\tcomment = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (comment) {\n+\t\t\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, node.getOffset()));\n+\t\t\t\t}\n+\t\t\t\tresult.getLeafs().add(new CommentInfo(result, node, newLines, trailing));\n+\t\t\t} else {\n+\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, node, newLines, node.getOffset()));\n+\t\t\t}\n+\t\t\tif (newLines > 0) {\n+\t\t\t\ttrailing = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\tint whitespaceOffset = 0;\n+\t\t\tif (result.getLeafs().isEmpty()) {\n+\t\t\t\twhitespaceOffset = offset;\n+\t\t\t} else {\n+\t\t\t\twhitespaceOffset = IterableExtensions.last(result.getLeafs()).getNode().getEndOffset();\n+\t\t\t}\n+\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, whitespaceOffset));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic HiddenLeafs getHiddenLeafsAfter(INode node) {\n+\t\tILeafNode start = findPreviousLeaf(node, l -> !l.isHidden());\n+\t\tif (start != null) {\n+\t\t\treturn newHiddenLeafs(start.getEndOffset(), findNextHiddenLeafs(start));\n+\t\t} else {\n+\t\t\toffset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected List<ILeafNode> findNextHiddenLeafs(INode node) {\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tNodeIterator ni = new NodeIterator(node);\n+\t\twhile (ni.hasNext()) {\n+\t\t\tINode next = ni.next();\n+\t\t\tif (next instanceof ILeafNode) {\n+\t\t\t\tif (((ILeafNode) next).isHidden()) {\n+\t\t\t\t\tresult.add((ILeafNode) next);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected ILeafNode findPreviousLeaf(INode node, Function1<? super ILeafNode, ? extends Boolean> matches) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tif (current instanceof ILeafNode && matches.apply((ILeafNode) current).booleanValue()) {\n+\t\t\treturn (ILeafNode) current;\n+\t\t}\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (previous instanceof ILeafNode && matches.apply((ILeafNode) previous).booleanValue()) {\n+\t\t\t\t\treturn (ILeafNode) previous;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected List<ILeafNode> findPreviousHiddenLeafs(INode node) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (!Objects.equal(previous, current) && previous instanceof ILeafNode) {\n+\t\t\t\t\tif (((ILeafNode) previous).isHidden()) {\n+\t\t\t\t\t\tresult.add((ILeafNode) previous);\n+\t\t\t\t\t} else { // if(!result.empty)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxMzA0OQ==", "bodyText": "did not want to loose it", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454313049", "createdAt": "2020-07-14T12:17:33Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {\n+\t\t\t\t\t\t\tcomment = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (comment) {\n+\t\t\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, node.getOffset()));\n+\t\t\t\t}\n+\t\t\t\tresult.getLeafs().add(new CommentInfo(result, node, newLines, trailing));\n+\t\t\t} else {\n+\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, node, newLines, node.getOffset()));\n+\t\t\t}\n+\t\t\tif (newLines > 0) {\n+\t\t\t\ttrailing = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\tint whitespaceOffset = 0;\n+\t\t\tif (result.getLeafs().isEmpty()) {\n+\t\t\t\twhitespaceOffset = offset;\n+\t\t\t} else {\n+\t\t\t\twhitespaceOffset = IterableExtensions.last(result.getLeafs()).getNode().getEndOffset();\n+\t\t\t}\n+\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, whitespaceOffset));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic HiddenLeafs getHiddenLeafsAfter(INode node) {\n+\t\tILeafNode start = findPreviousLeaf(node, l -> !l.isHidden());\n+\t\tif (start != null) {\n+\t\t\treturn newHiddenLeafs(start.getEndOffset(), findNextHiddenLeafs(start));\n+\t\t} else {\n+\t\t\toffset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected List<ILeafNode> findNextHiddenLeafs(INode node) {\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tNodeIterator ni = new NodeIterator(node);\n+\t\twhile (ni.hasNext()) {\n+\t\t\tINode next = ni.next();\n+\t\t\tif (next instanceof ILeafNode) {\n+\t\t\t\tif (((ILeafNode) next).isHidden()) {\n+\t\t\t\t\tresult.add((ILeafNode) next);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected ILeafNode findPreviousLeaf(INode node, Function1<? super ILeafNode, ? extends Boolean> matches) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tif (current instanceof ILeafNode && matches.apply((ILeafNode) current).booleanValue()) {\n+\t\t\treturn (ILeafNode) current;\n+\t\t}\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (previous instanceof ILeafNode && matches.apply((ILeafNode) previous).booleanValue()) {\n+\t\t\t\t\treturn (ILeafNode) previous;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected List<ILeafNode> findPreviousHiddenLeafs(INode node) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (!Objects.equal(previous, current) && previous instanceof ILeafNode) {\n+\t\t\t\t\tif (((ILeafNode) previous).isHidden()) {\n+\t\t\t\t\t\tresult.add((ILeafNode) previous);\n+\t\t\t\t\t} else { // if(!result.empty)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5ODAxOA=="}, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 161}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 735, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}