{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMzQ5OTAy", "number": 636, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjoyODo0N1rOEVZCoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMzoxMjowMlrOEVaDKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODY1ODI1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjoyODo0N1rOG8Hcvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjo0ODo1MVrOG8IKDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4OTc5MA==", "bodyText": "api change?", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465689790", "createdAt": "2020-08-05T12:28:47Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5OTIxMQ==", "bodyText": "You mean the declared ClassNotFoundException?", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465699211", "createdAt": "2020-08-05T12:45:18Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4OTc5MA=="}, "originalCommit": {"oid": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMDA2Mg==", "bodyText": "yes", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465700062", "createdAt": "2020-08-05T12:46:44Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4OTc5MA=="}, "originalCommit": {"oid": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMTM4OA==", "bodyText": "Moved the catch clause into this method.", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465701388", "createdAt": "2020-08-05T12:48:51Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4OTc5MA=="}, "originalCommit": {"oid": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODY2NDkzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjozMDo0NlrOG8Hg4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjo1NDoxNlrOG8IW9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDg0OQ==", "bodyText": "buffering?", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465690849", "createdAt": "2020-08-05T12:30:46Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {\n+\t\tJvmModelAssociator.Adapter adapter = FluentIterable.from(resource.eAdapters())\n+\t\t\t\t.filter(JvmModelAssociator.Adapter.class)\n+\t\t\t\t.first()\n+\t\t\t\t.or(()->{\n+\t\t\t\t\tJvmModelAssociator.Adapter newAdapter = new JvmModelAssociator.Adapter();\n+\t\t\t\t\tresource.eAdapters().add(newAdapter);\n+\t\t\t\t\treturn newAdapter;\n+\t\t\t\t});\n+\t\t\n+\t\tstream.getNextEntry();\n+\t\t\n+\t\ttry (ObjectInputStream objIn = new ObjectInputStream(new NonClosingFilterInputStream(new BufferedInputStream(stream)))) {\n+\t\t\tMap<String, String> logicalMap = (Map<String, String>) objIn.readObject();\n+\t\t\tlogicalMap.forEach((key, value)->{\n+\t\t\t\tadapter.logicalContainerMap.put(resource.getEObject(key), (JvmIdentifiableElement)resource.getEObject(value));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> sourceToTargetMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\tsourceToTargetMap.forEach((source, targets)->{\n+\t\t\t\tadapter.sourceToTargetMap.put(resource.getEObject(source), fragmentsToObjects(resource, targets));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> targetToSourceMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\ttargetToSourceMap.forEach((target, sources)->{\n+\t\t\t\tadapter.targetToSourceMap.put(resource.getEObject(target), fragmentsToObjects(resource, sources)); \n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate Set<EObject> fragmentsToObjects(BatchLinkableResource resource, Set<String> fragments) {\n+\t\treturn FluentIterable.from(fragments)\n+\t\t.transform(resource::getEObject)\n+\t\t.copyInto(new LinkedHashSet<>());\n+\t}\n+\t\n+\tprivate static class NonClosingFilterInputStream extends FilterInputStream {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5OTQ5Ng==", "bodyText": "Extend buffering instead of decorate buffering? Is that what you mean?", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465699496", "createdAt": "2020-08-05T12:45:45Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {\n+\t\tJvmModelAssociator.Adapter adapter = FluentIterable.from(resource.eAdapters())\n+\t\t\t\t.filter(JvmModelAssociator.Adapter.class)\n+\t\t\t\t.first()\n+\t\t\t\t.or(()->{\n+\t\t\t\t\tJvmModelAssociator.Adapter newAdapter = new JvmModelAssociator.Adapter();\n+\t\t\t\t\tresource.eAdapters().add(newAdapter);\n+\t\t\t\t\treturn newAdapter;\n+\t\t\t\t});\n+\t\t\n+\t\tstream.getNextEntry();\n+\t\t\n+\t\ttry (ObjectInputStream objIn = new ObjectInputStream(new NonClosingFilterInputStream(new BufferedInputStream(stream)))) {\n+\t\t\tMap<String, String> logicalMap = (Map<String, String>) objIn.readObject();\n+\t\t\tlogicalMap.forEach((key, value)->{\n+\t\t\t\tadapter.logicalContainerMap.put(resource.getEObject(key), (JvmIdentifiableElement)resource.getEObject(value));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> sourceToTargetMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\tsourceToTargetMap.forEach((source, targets)->{\n+\t\t\t\tadapter.sourceToTargetMap.put(resource.getEObject(source), fragmentsToObjects(resource, targets));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> targetToSourceMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\ttargetToSourceMap.forEach((target, sources)->{\n+\t\t\t\tadapter.targetToSourceMap.put(resource.getEObject(target), fragmentsToObjects(resource, sources)); \n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate Set<EObject> fragmentsToObjects(BatchLinkableResource resource, Set<String> fragments) {\n+\t\treturn FluentIterable.from(fragments)\n+\t\t.transform(resource::getEObject)\n+\t\t.copyInto(new LinkedHashSet<>());\n+\t}\n+\t\n+\tprivate static class NonClosingFilterInputStream extends FilterInputStream {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDg0OQ=="}, "originalCommit": {"oid": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMDI0Mw==", "bodyText": "the old used a bufferedInputstream", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465700243", "createdAt": "2020-08-05T12:47:02Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {\n+\t\tJvmModelAssociator.Adapter adapter = FluentIterable.from(resource.eAdapters())\n+\t\t\t\t.filter(JvmModelAssociator.Adapter.class)\n+\t\t\t\t.first()\n+\t\t\t\t.or(()->{\n+\t\t\t\t\tJvmModelAssociator.Adapter newAdapter = new JvmModelAssociator.Adapter();\n+\t\t\t\t\tresource.eAdapters().add(newAdapter);\n+\t\t\t\t\treturn newAdapter;\n+\t\t\t\t});\n+\t\t\n+\t\tstream.getNextEntry();\n+\t\t\n+\t\ttry (ObjectInputStream objIn = new ObjectInputStream(new NonClosingFilterInputStream(new BufferedInputStream(stream)))) {\n+\t\t\tMap<String, String> logicalMap = (Map<String, String>) objIn.readObject();\n+\t\t\tlogicalMap.forEach((key, value)->{\n+\t\t\t\tadapter.logicalContainerMap.put(resource.getEObject(key), (JvmIdentifiableElement)resource.getEObject(value));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> sourceToTargetMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\tsourceToTargetMap.forEach((source, targets)->{\n+\t\t\t\tadapter.sourceToTargetMap.put(resource.getEObject(source), fragmentsToObjects(resource, targets));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> targetToSourceMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\ttargetToSourceMap.forEach((target, sources)->{\n+\t\t\t\tadapter.targetToSourceMap.put(resource.getEObject(target), fragmentsToObjects(resource, sources)); \n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate Set<EObject> fragmentsToObjects(BatchLinkableResource resource, Set<String> fragments) {\n+\t\treturn FluentIterable.from(fragments)\n+\t\t.transform(resource::getEObject)\n+\t\t.copyInto(new LinkedHashSet<>());\n+\t}\n+\t\n+\tprivate static class NonClosingFilterInputStream extends FilterInputStream {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDg0OQ=="}, "originalCommit": {"oid": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMTE0Ng==", "bodyText": "new ObjectInputStream(new NonClosingFilterInputStream(new BufferedInputStream(stream))) \nIt still does", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465701146", "createdAt": "2020-08-05T12:48:29Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {\n+\t\tJvmModelAssociator.Adapter adapter = FluentIterable.from(resource.eAdapters())\n+\t\t\t\t.filter(JvmModelAssociator.Adapter.class)\n+\t\t\t\t.first()\n+\t\t\t\t.or(()->{\n+\t\t\t\t\tJvmModelAssociator.Adapter newAdapter = new JvmModelAssociator.Adapter();\n+\t\t\t\t\tresource.eAdapters().add(newAdapter);\n+\t\t\t\t\treturn newAdapter;\n+\t\t\t\t});\n+\t\t\n+\t\tstream.getNextEntry();\n+\t\t\n+\t\ttry (ObjectInputStream objIn = new ObjectInputStream(new NonClosingFilterInputStream(new BufferedInputStream(stream)))) {\n+\t\t\tMap<String, String> logicalMap = (Map<String, String>) objIn.readObject();\n+\t\t\tlogicalMap.forEach((key, value)->{\n+\t\t\t\tadapter.logicalContainerMap.put(resource.getEObject(key), (JvmIdentifiableElement)resource.getEObject(value));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> sourceToTargetMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\tsourceToTargetMap.forEach((source, targets)->{\n+\t\t\t\tadapter.sourceToTargetMap.put(resource.getEObject(source), fragmentsToObjects(resource, targets));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> targetToSourceMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\ttargetToSourceMap.forEach((target, sources)->{\n+\t\t\t\tadapter.targetToSourceMap.put(resource.getEObject(target), fragmentsToObjects(resource, sources)); \n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate Set<EObject> fragmentsToObjects(BatchLinkableResource resource, Set<String> fragments) {\n+\t\treturn FluentIterable.from(fragments)\n+\t\t.transform(resource::getEObject)\n+\t\t.copyInto(new LinkedHashSet<>());\n+\t}\n+\t\n+\tprivate static class NonClosingFilterInputStream extends FilterInputStream {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDg0OQ=="}, "originalCommit": {"oid": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwNDY5Mg==", "bodyText": "looks like i missglanced this one", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465704692", "createdAt": "2020-08-05T12:54:16Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {\n+\t\tJvmModelAssociator.Adapter adapter = FluentIterable.from(resource.eAdapters())\n+\t\t\t\t.filter(JvmModelAssociator.Adapter.class)\n+\t\t\t\t.first()\n+\t\t\t\t.or(()->{\n+\t\t\t\t\tJvmModelAssociator.Adapter newAdapter = new JvmModelAssociator.Adapter();\n+\t\t\t\t\tresource.eAdapters().add(newAdapter);\n+\t\t\t\t\treturn newAdapter;\n+\t\t\t\t});\n+\t\t\n+\t\tstream.getNextEntry();\n+\t\t\n+\t\ttry (ObjectInputStream objIn = new ObjectInputStream(new NonClosingFilterInputStream(new BufferedInputStream(stream)))) {\n+\t\t\tMap<String, String> logicalMap = (Map<String, String>) objIn.readObject();\n+\t\t\tlogicalMap.forEach((key, value)->{\n+\t\t\t\tadapter.logicalContainerMap.put(resource.getEObject(key), (JvmIdentifiableElement)resource.getEObject(value));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> sourceToTargetMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\tsourceToTargetMap.forEach((source, targets)->{\n+\t\t\t\tadapter.sourceToTargetMap.put(resource.getEObject(source), fragmentsToObjects(resource, targets));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> targetToSourceMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\ttargetToSourceMap.forEach((target, sources)->{\n+\t\t\t\tadapter.targetToSourceMap.put(resource.getEObject(target), fragmentsToObjects(resource, sources)); \n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate Set<EObject> fragmentsToObjects(BatchLinkableResource resource, Set<String> fragments) {\n+\t\treturn FluentIterable.from(fragments)\n+\t\t.transform(resource::getEObject)\n+\t\t.copyInto(new LinkedHashSet<>());\n+\t}\n+\t\n+\tprivate static class NonClosingFilterInputStream extends FilterInputStream {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDg0OQ=="}, "originalCommit": {"oid": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODY3NjE3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageWritable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjozNDowN1rOG8Hnvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjozNDowN1rOG8Hnvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MjYwNg==", "bodyText": "Qualification not needed", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465692606", "createdAt": "2020-08-05T12:34:07Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageWritable.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmType;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageWritable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+import org.eclipse.xtext.xtype.XComputedTypeReference;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * @author Sven Efftinge\n+ */\n+public class BatchLinkableResourceStorageWritable extends ResourceStorageWritable {\n+\tprivate static final Logger LOG = Logger.getLogger(BatchLinkableResourceStorageWritable.class);\n+\n+\tpublic BatchLinkableResourceStorageWritable(OutputStream out, boolean storeNodeModel) {\n+\t\tsuper(out, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void writeEntries(StorageAwareResource resource, ZipOutputStream zipOut) throws IOException {\n+\t\tsuper.writeEntries(resource, zipOut);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\tzipOut.putNextEntry(new ZipEntry(\"associations\"));\n+\t\t\tBufferedOutputStream buffOut = new BufferedOutputStream(zipOut);\n+\t\t\ttry {\n+\t\t\t\twriteAssociationsAdapter((BatchLinkableResource) resource, buffOut);\n+\t\t\t} finally {\n+\t\t\t\tbuffOut.flush();\n+\t\t\t\tzipOut.closeEntry();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void beforeSaveEObject(InternalEObject object, BinaryResourceImpl.EObjectOutputStream writable)\n+\t\t\tthrows IOException {\n+\t\tsuper.beforeSaveEObject(object, writable);\n+\t\t// make sure lazy type references are computed\n+\t\tif (object instanceof XComputedTypeReference) {\n+\t\t\t((XComputedTypeReference) object).getType();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleSaveEObject(InternalEObject object, BinaryResourceImpl.EObjectOutputStream out)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleSaveEObject(object, out);\n+\t\t\n+\t\tDocumentationAdapter documentationAdapter = null;\n+\t\tJvmIdentifiableMetaData metaDataAdapter = null;\n+\t\tfor (Adapter adapter : object.eAdapters()) {\n+\t\t\tif (adapter instanceof DocumentationAdapter) {\n+\t\t\t\tdocumentationAdapter = (DocumentationAdapter) adapter;\n+\t\t\t}\n+\t\t\tif (adapter instanceof JvmIdentifiableMetaData) {\n+\t\t\t\tmetaDataAdapter = (JvmIdentifiableMetaData) adapter;\n+\t\t\t}\n+\t\t}\n+\t\t// store Documentation adapters\n+\t\tif (documentationAdapter != null) {\n+\t\t\tout.writeBoolean(true);\n+\t\t\tout.writeString(documentationAdapter.getDocumentation());\n+\t\t} else {\n+\t\t\tout.writeBoolean(false);\n+\t\t}\n+\t\t// store additional meta data\n+\t\tif (metaDataAdapter != null) {\n+\t\t\tout.writeBoolean(true);\n+\t\t\tout.writeBoolean(metaDataAdapter.isSynthetic());\n+\t\t} else {\n+\t\t\tout.writeBoolean(false);\n+\t\t}\n+\t}\n+\n+\tprotected void writeAssociationsAdapter(BatchLinkableResource resource, OutputStream zipOut) throws IOException {\n+\t\tJvmModelAssociator.Adapter adapter = (org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.Adapter) EcoreUtil.getExistingAdapter(resource, JvmModelAssociator.Adapter.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODgxODQ4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/DocumentationAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMzoxMDozOFrOG8I-Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwODo1MDoyMFrOG8peJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxNDc1MA==", "bodyText": "do we need a since?", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465714750", "createdAt": "2020-08-05T13:10:38Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/DocumentationAdapter.java", "diffHunk": "@@ -16,6 +16,13 @@\n public class DocumentationAdapter extends AdapterImpl {\n \n \tprivate String documentation;\n+\t\n+\tpublic DocumentationAdapter(String documentation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44de69ca0c89bad86047d838950b3f5d01a2e223"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI0NzIwNA==", "bodyText": "Added", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r466247204", "createdAt": "2020-08-06T08:50:20Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/DocumentationAdapter.java", "diffHunk": "@@ -16,6 +16,13 @@\n public class DocumentationAdapter extends AdapterImpl {\n \n \tprivate String documentation;\n+\t\n+\tpublic DocumentationAdapter(String documentation) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxNDc1MA=="}, "originalCommit": {"oid": "44de69ca0c89bad86047d838950b3f5d01a2e223"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODgyMzQ3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageWritable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMzoxMjowMlrOG8JBlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNDowODo0MlrOG8LXJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxNTYwNA==", "bodyText": "wrong map?", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465715604", "createdAt": "2020-08-05T13:12:02Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageWritable.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmType;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageWritable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+import org.eclipse.xtext.xtype.XComputedTypeReference;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * @author Sven Efftinge\n+ */\n+public class BatchLinkableResourceStorageWritable extends ResourceStorageWritable {\n+\tprivate static final Logger LOG = Logger.getLogger(BatchLinkableResourceStorageWritable.class);\n+\n+\tpublic BatchLinkableResourceStorageWritable(OutputStream out, boolean storeNodeModel) {\n+\t\tsuper(out, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void writeEntries(StorageAwareResource resource, ZipOutputStream zipOut) throws IOException {\n+\t\tsuper.writeEntries(resource, zipOut);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\tzipOut.putNextEntry(new ZipEntry(\"associations\"));\n+\t\t\tBufferedOutputStream buffOut = new BufferedOutputStream(zipOut);\n+\t\t\ttry {\n+\t\t\t\twriteAssociationsAdapter((BatchLinkableResource) resource, buffOut);\n+\t\t\t} finally {\n+\t\t\t\tbuffOut.flush();\n+\t\t\t\tzipOut.closeEntry();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void beforeSaveEObject(InternalEObject object, BinaryResourceImpl.EObjectOutputStream writable)\n+\t\t\tthrows IOException {\n+\t\tsuper.beforeSaveEObject(object, writable);\n+\t\t// make sure lazy type references are computed\n+\t\tif (object instanceof XComputedTypeReference) {\n+\t\t\t((XComputedTypeReference) object).getType();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleSaveEObject(InternalEObject object, BinaryResourceImpl.EObjectOutputStream out)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleSaveEObject(object, out);\n+\t\t\n+\t\tDocumentationAdapter documentationAdapter = null;\n+\t\tJvmIdentifiableMetaData metaDataAdapter = null;\n+\t\tfor (Adapter adapter : object.eAdapters()) {\n+\t\t\tif (adapter instanceof DocumentationAdapter) {\n+\t\t\t\tdocumentationAdapter = (DocumentationAdapter) adapter;\n+\t\t\t}\n+\t\t\tif (adapter instanceof JvmIdentifiableMetaData) {\n+\t\t\t\tmetaDataAdapter = (JvmIdentifiableMetaData) adapter;\n+\t\t\t}\n+\t\t}\n+\t\t// store Documentation adapters\n+\t\tif (documentationAdapter != null) {\n+\t\t\tout.writeBoolean(true);\n+\t\t\tout.writeString(documentationAdapter.getDocumentation());\n+\t\t} else {\n+\t\t\tout.writeBoolean(false);\n+\t\t}\n+\t\t// store additional meta data\n+\t\tif (metaDataAdapter != null) {\n+\t\t\tout.writeBoolean(true);\n+\t\t\tout.writeBoolean(metaDataAdapter.isSynthetic());\n+\t\t} else {\n+\t\t\tout.writeBoolean(false);\n+\t\t}\n+\t}\n+\n+\tprotected void writeAssociationsAdapter(BatchLinkableResource resource, OutputStream zipOut) throws IOException {\n+\t\tJvmModelAssociator.Adapter adapter = (JvmModelAssociator.Adapter) EcoreUtil.getExistingAdapter(resource, JvmModelAssociator.Adapter.class);\n+\t\tif (adapter == null) {\n+\t\t\tfor(int i = 1, max = resource.getContents().size(); i < max; i++) {\n+\t\t\t\tif (resource.getContents().get(i) instanceof JvmType) {\n+\t\t\t\t\tthrow new IOException(\"Missing JvmModelAssociator.Adapter but resource contains inferred types: \" + resource.getURI());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tadapter = new JvmModelAssociator.Adapter();\n+\t\t}\n+\t\ttry (ObjectOutputStream objOut = new ObjectOutputStream(zipOut) {\n+\t\t\t@Override\n+\t\t\tpublic void close() throws IOException {\n+\t\t\t\tflush();\n+\t\t\t}\n+\t\t}) {\n+\t\t\t// logicalMap\n+\t\t\tMap<String, String> logicalMap = new LinkedHashMap<>();\n+\t\t\tadapter.logicalContainerMap.forEach((key, value)->{\n+\t\t\t\tlogIfResourceMismatch(resource, key);\n+\t\t\t\tlogicalMap.put(getFragment(key), getFragment(value));\n+\t\t\t});\n+\t\t\tobjOut.writeObject(logicalMap);\n+\t\t\t\n+\t\t\t// sourceToTarget\n+\t\t\tMap<String, Set<String>> sourceToTarget = new LinkedHashMap<>();\n+\t\t\tadapter.sourceToTargetMap.forEach((source, targets)->{\n+\t\t\t\tlogIfResourceMismatch(resource, source);\n+\t\t\t\tsourceToTarget.put(getFragment(source), objectsToFragments(targets));\n+\t\t\t});\n+\t\t\tobjOut.writeObject(sourceToTarget);\n+\t\t\t\n+\t\t\t// targetToSource\n+\t\t\tMap<String, Set<String>> targetToSource = new LinkedHashMap<>();\n+\t\t\tadapter.sourceToTargetMap.forEach((target, sources)->{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44de69ca0c89bad86047d838950b3f5d01a2e223"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1Mzg5Mw==", "bodyText": "Excellent :)", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465753893", "createdAt": "2020-08-05T14:08:42Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageWritable.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmType;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageWritable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+import org.eclipse.xtext.xtype.XComputedTypeReference;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * @author Sven Efftinge\n+ */\n+public class BatchLinkableResourceStorageWritable extends ResourceStorageWritable {\n+\tprivate static final Logger LOG = Logger.getLogger(BatchLinkableResourceStorageWritable.class);\n+\n+\tpublic BatchLinkableResourceStorageWritable(OutputStream out, boolean storeNodeModel) {\n+\t\tsuper(out, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void writeEntries(StorageAwareResource resource, ZipOutputStream zipOut) throws IOException {\n+\t\tsuper.writeEntries(resource, zipOut);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\tzipOut.putNextEntry(new ZipEntry(\"associations\"));\n+\t\t\tBufferedOutputStream buffOut = new BufferedOutputStream(zipOut);\n+\t\t\ttry {\n+\t\t\t\twriteAssociationsAdapter((BatchLinkableResource) resource, buffOut);\n+\t\t\t} finally {\n+\t\t\t\tbuffOut.flush();\n+\t\t\t\tzipOut.closeEntry();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void beforeSaveEObject(InternalEObject object, BinaryResourceImpl.EObjectOutputStream writable)\n+\t\t\tthrows IOException {\n+\t\tsuper.beforeSaveEObject(object, writable);\n+\t\t// make sure lazy type references are computed\n+\t\tif (object instanceof XComputedTypeReference) {\n+\t\t\t((XComputedTypeReference) object).getType();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleSaveEObject(InternalEObject object, BinaryResourceImpl.EObjectOutputStream out)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleSaveEObject(object, out);\n+\t\t\n+\t\tDocumentationAdapter documentationAdapter = null;\n+\t\tJvmIdentifiableMetaData metaDataAdapter = null;\n+\t\tfor (Adapter adapter : object.eAdapters()) {\n+\t\t\tif (adapter instanceof DocumentationAdapter) {\n+\t\t\t\tdocumentationAdapter = (DocumentationAdapter) adapter;\n+\t\t\t}\n+\t\t\tif (adapter instanceof JvmIdentifiableMetaData) {\n+\t\t\t\tmetaDataAdapter = (JvmIdentifiableMetaData) adapter;\n+\t\t\t}\n+\t\t}\n+\t\t// store Documentation adapters\n+\t\tif (documentationAdapter != null) {\n+\t\t\tout.writeBoolean(true);\n+\t\t\tout.writeString(documentationAdapter.getDocumentation());\n+\t\t} else {\n+\t\t\tout.writeBoolean(false);\n+\t\t}\n+\t\t// store additional meta data\n+\t\tif (metaDataAdapter != null) {\n+\t\t\tout.writeBoolean(true);\n+\t\t\tout.writeBoolean(metaDataAdapter.isSynthetic());\n+\t\t} else {\n+\t\t\tout.writeBoolean(false);\n+\t\t}\n+\t}\n+\n+\tprotected void writeAssociationsAdapter(BatchLinkableResource resource, OutputStream zipOut) throws IOException {\n+\t\tJvmModelAssociator.Adapter adapter = (JvmModelAssociator.Adapter) EcoreUtil.getExistingAdapter(resource, JvmModelAssociator.Adapter.class);\n+\t\tif (adapter == null) {\n+\t\t\tfor(int i = 1, max = resource.getContents().size(); i < max; i++) {\n+\t\t\t\tif (resource.getContents().get(i) instanceof JvmType) {\n+\t\t\t\t\tthrow new IOException(\"Missing JvmModelAssociator.Adapter but resource contains inferred types: \" + resource.getURI());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tadapter = new JvmModelAssociator.Adapter();\n+\t\t}\n+\t\ttry (ObjectOutputStream objOut = new ObjectOutputStream(zipOut) {\n+\t\t\t@Override\n+\t\t\tpublic void close() throws IOException {\n+\t\t\t\tflush();\n+\t\t\t}\n+\t\t}) {\n+\t\t\t// logicalMap\n+\t\t\tMap<String, String> logicalMap = new LinkedHashMap<>();\n+\t\t\tadapter.logicalContainerMap.forEach((key, value)->{\n+\t\t\t\tlogIfResourceMismatch(resource, key);\n+\t\t\t\tlogicalMap.put(getFragment(key), getFragment(value));\n+\t\t\t});\n+\t\t\tobjOut.writeObject(logicalMap);\n+\t\t\t\n+\t\t\t// sourceToTarget\n+\t\t\tMap<String, Set<String>> sourceToTarget = new LinkedHashMap<>();\n+\t\t\tadapter.sourceToTargetMap.forEach((source, targets)->{\n+\t\t\t\tlogIfResourceMismatch(resource, source);\n+\t\t\t\tsourceToTarget.put(getFragment(source), objectsToFragments(targets));\n+\t\t\t});\n+\t\t\tobjOut.writeObject(sourceToTarget);\n+\t\t\t\n+\t\t\t// targetToSource\n+\t\t\tMap<String, Set<String>> targetToSource = new LinkedHashMap<>();\n+\t\t\tadapter.sourceToTargetMap.forEach((target, sources)->{", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxNTYwNA=="}, "originalCommit": {"oid": "44de69ca0c89bad86047d838950b3f5d01a2e223"}, "originalPosition": 139}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 645, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}