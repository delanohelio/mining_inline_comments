{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxNTMwODQ4", "number": 623, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzo1MDowOFrOEJxCQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzo1NjozMVrOEJxLbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4Njc2MDMzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ErrorSafeExtensions.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzo1MDowOFrOGqbthQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzo1MDowOFrOGqbthQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE0NzM5Nw==", "bodyText": "I know it's not really the scope of this PR, but return getErrors().iterator().hasNext() avoid a little bit of duplication here. Or even !Iterables.isEmpty(getErrors())", "url": "https://github.com/eclipse/xtext-extras/pull/623#discussion_r447147397", "createdAt": "2020-06-29T17:50:08Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ErrorSafeExtensions.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmSpecializedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.common.types.JvmUnknownTypeReference;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.compiler.BrokenTypeRefDetector;\n+import org.eclipse.xtext.xbase.compiler.IElementIssueProvider;\n+import org.eclipse.xtext.xbase.compiler.LoopParams;\n+import org.eclipse.xtext.xbase.compiler.TypeReferenceSerializer;\n+import org.eclipse.xtext.xbase.compiler.output.ErrorTreeAppendable;\n+import org.eclipse.xtext.xbase.compiler.output.ITreeAppendable;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ObjectExtensions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+/**\n+ * @author Jan Koehnlein\n+ */\n+public class ErrorSafeExtensions {\n+\t@Inject\n+\tprivate TypeReferenceSerializer typeReferenceSerializer;\n+\n+\t@Inject\n+\tprivate IElementIssueProvider.Factory issueProviderFactory;\n+\n+\tpublic Iterable<Issue> getErrors(EObject element) {\n+\t\tIElementIssueProvider issueProvider = issueProviderFactory.get(element.eResource());\n+\t\treturn Iterables.filter(issueProvider.getIssues(element), it -> Severity.ERROR.equals(it.getSeverity()));\n+\t}\n+\n+\tpublic boolean hasErrors(EObject element) {\n+\t\tIElementIssueProvider issueProvider = issueProviderFactory.get(element.eResource());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e6f0b822a195e7665a672ecbf5735b945b79cba"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4Njc2NzUyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ErrorSafeExtensions.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzo1MjowOFrOGqbyMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzo1MjowOFrOGqbyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE0ODU5NA==", "bodyText": "Unnecessary explicit unboxing.", "url": "https://github.com/eclipse/xtext-extras/pull/623#discussion_r447148594", "createdAt": "2020-06-29T17:52:08Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ErrorSafeExtensions.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmSpecializedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.common.types.JvmUnknownTypeReference;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.compiler.BrokenTypeRefDetector;\n+import org.eclipse.xtext.xbase.compiler.IElementIssueProvider;\n+import org.eclipse.xtext.xbase.compiler.LoopParams;\n+import org.eclipse.xtext.xbase.compiler.TypeReferenceSerializer;\n+import org.eclipse.xtext.xbase.compiler.output.ErrorTreeAppendable;\n+import org.eclipse.xtext.xbase.compiler.output.ITreeAppendable;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ObjectExtensions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+/**\n+ * @author Jan Koehnlein\n+ */\n+public class ErrorSafeExtensions {\n+\t@Inject\n+\tprivate TypeReferenceSerializer typeReferenceSerializer;\n+\n+\t@Inject\n+\tprivate IElementIssueProvider.Factory issueProviderFactory;\n+\n+\tpublic Iterable<Issue> getErrors(EObject element) {\n+\t\tIElementIssueProvider issueProvider = issueProviderFactory.get(element.eResource());\n+\t\treturn Iterables.filter(issueProvider.getIssues(element), it -> Severity.ERROR.equals(it.getSeverity()));\n+\t}\n+\n+\tpublic boolean hasErrors(EObject element) {\n+\t\tIElementIssueProvider issueProvider = issueProviderFactory.get(element.eResource());\n+\t\treturn IterableExtensions.exists(issueProvider.getIssues(element),\n+\t\t\t\tit -> Severity.ERROR.equals(it.getSeverity()));\n+\t}\n+\n+\tpublic <T extends EObject> void forEachSafely(ITreeAppendable appendable, Iterable<T> elements,\n+\t\t\tProcedure1<? super LoopParams> loopInitializer, Procedure2<? super T, ? super ITreeAppendable> body) {\n+\t\tif (Iterables.isEmpty(elements)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tLoopParams loopParams = ObjectExtensions.operator_doubleArrow(new LoopParams(), loopInitializer);\n+\t\tboolean allElementsBroken = Iterables\n+\t\t\t\t.size(Iterables.<T>filter(elements, (T it) -> hasErrors(it))) == Iterables.size(elements);\n+\t\tITreeAppendable currentAppendable = null;\n+\t\tif (allElementsBroken) {\n+\t\t\tcurrentAppendable = openErrorAppendable(appendable, null);\n+\t\t} else {\n+\t\t\tcurrentAppendable = appendable;\n+\t\t}\n+\t\tloopParams.appendPrefix(currentAppendable);\n+\t\tboolean isFirst = true;\n+\t\tboolean isFirstBroken = true;\n+\t\tfor (T element : elements) {\n+\t\t\tif (!hasErrors(element)) {\n+\t\t\t\tcurrentAppendable = closeErrorAppendable(appendable, currentAppendable);\n+\t\t\t\tif (!isFirst) {\n+\t\t\t\t\tloopParams.appendSeparator(appendable);\n+\t\t\t\t}\n+\t\t\t\tisFirst = false;\n+\t\t\t\tbody.apply(element, appendable);\n+\t\t\t} else {\n+\t\t\t\tif (!allElementsBroken) {\n+\t\t\t\t\tcurrentAppendable = openErrorAppendable(appendable, currentAppendable);\n+\t\t\t\t}\n+\t\t\t\tif (!isFirst || !isFirstBroken) {\n+\t\t\t\t\tloopParams.appendSeparator(currentAppendable);\n+\t\t\t\t}\n+\t\t\t\tisFirstBroken = false;\n+\t\t\t\ttry {\n+\t\t\t\t\tbody.apply(element, currentAppendable);\n+\t\t\t\t} catch (Exception ignoreMe) {\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (!allElementsBroken) {\n+\t\t\tcurrentAppendable = closeErrorAppendable(appendable, currentAppendable);\n+\t\t}\n+\t\tloopParams.appendSuffix(currentAppendable);\n+\t\tcloseErrorAppendable(appendable, currentAppendable);\n+\t}\n+\n+\tprotected ITreeAppendable openErrorAppendable(ITreeAppendable parent, ITreeAppendable child) {\n+\t\tif (child instanceof ErrorTreeAppendable) {\n+\t\t\treturn child;\n+\t\t} else {\n+\t\t\treturn parent.errorChild().append(\"/* \");\n+\t\t}\n+\t}\n+\n+\tprotected ITreeAppendable closeErrorAppendable(ITreeAppendable parent, ITreeAppendable child) {\n+\t\tif (child instanceof ErrorTreeAppendable && !Objects.equal(child, parent)) {\n+\t\t\tchild.append(\" */\");\n+\t\t}\n+\t\treturn parent;\n+\t}\n+\n+\tpublic void serializeSafely(JvmTypeReference typeRef, ITreeAppendable appendable) {\n+\t\tserializeSafely(typeRef, null, appendable);\n+\t}\n+\n+\tpublic void serializeSafely(JvmTypeReference typeRef, String surrogateType, ITreeAppendable appendable) {\n+\t\tif (typeRef == null || typeRef.getType() == null) {\n+\t\t\tif (typeRef instanceof JvmSpecializedTypeReference) {\n+\t\t\t\tserializeSafely(((JvmSpecializedTypeReference) typeRef).getEquivalent(), surrogateType, appendable);\n+\t\t\t} else if (typeRef instanceof JvmUnknownTypeReference) {\n+\t\t\t\tappendable.append(((JvmUnknownTypeReference) typeRef).getQualifiedName());\n+\t\t\t} else {\n+\t\t\t\tappendable.append(\"Object\");\n+\t\t\t\tITreeAppendable errorChild = openErrorAppendable(appendable, appendable);\n+\t\t\t\terrorChild.append(\"type is 'null'\");\n+\t\t\t\tcloseErrorAppendable(appendable, errorChild);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (typeRef.accept(new BrokenTypeRefDetector()).booleanValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e6f0b822a195e7665a672ecbf5735b945b79cba"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4Njc3NzU0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/util/PropertyUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzo1NDo1NFrOGqb4dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzo1NDo1NFrOGqb4dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE1MDE5OQ==", "bodyText": "Unnecessary qualification.", "url": "https://github.com/eclipse/xtext-extras/pull/623#discussion_r447150199", "createdAt": "2020-06-29T17:54:54Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/util/PropertyUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.util;\n+\n+import java.beans.Introspector;\n+import java.util.Locale;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.Strings;\n+\n+/**\n+ * @author kosyakov - Initial contribution and API\n+ */\n+public class PropertyUtil {\n+\tpublic static String getPropertyName(JvmFeature feature) {\n+\t\tif (feature.isStatic()) {\n+\t\t\treturn PropertyUtil.getPropertyName(feature, feature.getSimpleName(), 1, 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e6f0b822a195e7665a672ecbf5735b945b79cba"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4Njc4MzgyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/util/PropertyUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzo1NjozMVrOGqb8Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNzo1NjozMVrOGqb8Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE1MTE0Mw==", "bodyText": "Thank you for keeping the comments", "url": "https://github.com/eclipse/xtext-extras/pull/623#discussion_r447151143", "createdAt": "2020-06-29T17:56:31Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/util/PropertyUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.util;\n+\n+import java.beans.Introspector;\n+import java.util.Locale;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.Strings;\n+\n+/**\n+ * @author kosyakov - Initial contribution and API\n+ */\n+public class PropertyUtil {\n+\tpublic static String getPropertyName(JvmFeature feature) {\n+\t\tif (feature.isStatic()) {\n+\t\t\treturn PropertyUtil.getPropertyName(feature, feature.getSimpleName(), 1, 2);\n+\t\t} else {\n+\t\t\treturn PropertyUtil.getPropertyName(feature, feature.getSimpleName(), 0, 1);\n+\t\t}\n+\t}\n+\n+\tpublic static String getPropertyName(JvmFeature feature, String methodName, int getterParams, int setterParams) {\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tJvmOperation operation = (JvmOperation) feature;\n+\t\t\tString propertyName = PropertyUtil.getPropertyName(operation, methodName, \"get\", getterParams);\n+\t\t\tif (propertyName != null) {\n+\t\t\t\treturn propertyName;\n+\t\t\t}\n+\t\t\tpropertyName = PropertyUtil.getPropertyName(operation, methodName, \"set\", setterParams);\n+\t\t\tif (propertyName != null) {\n+\t\t\t\treturn propertyName;\n+\t\t\t}\n+\t\t\treturn PropertyUtil.getPropertyName(operation, methodName, \"is\", getterParams);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected static String getPropertyName(JvmOperation operation, String methodName, String prefix, int params) {\n+\t\tint prefixLength = prefix.length();\n+\t\tif (PropertyUtil.startsWithPrefix(methodName, prefix, prefixLength)\n+\t\t\t\t&& operation.getParameters().size() == params) {\n+\t\t\treturn Introspector.decapitalize(methodName.substring(prefixLength));\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected static boolean startsWithPrefix(String methodName, String prefix, int prefixLength) {\n+\t\treturn methodName.length() > prefixLength && methodName.startsWith(prefix)\n+\t\t\t\t&& Character.isUpperCase(methodName.charAt(prefixLength));\n+\t}\n+\n+\t/**\n+\t * @Nullable\n+\t */\n+\tpublic static String tryGetShorthandName(String fullName) {\n+\t\tString name = null;\n+\t\tif (fullName.startsWith(\"get\") || fullName.startsWith(\"set\")) {\n+\t\t\tname = fullName.substring(3);\n+\t\t} else {\n+\t\t\tif (fullName.startsWith(\"is\")) {\n+\t\t\t\tname = fullName.substring(2);\n+\t\t\t} else {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t\tif (name.length() == 1) { // e.g. Point.getX()\n+\t\t\treturn name.toLowerCase(Locale.ENGLISH);\n+\t\t} else {\n+\t\t\tif (name.length() > 1) {\n+\t\t\t\tif (Character.isUpperCase(name.charAt(1))) {\n+\t\t\t\t\t// if second char is uppercase, the name itself is the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e6f0b822a195e7665a672ecbf5735b945b79cba"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 728, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}