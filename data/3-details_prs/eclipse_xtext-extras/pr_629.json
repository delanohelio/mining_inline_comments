{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwOTM4MjA3", "number": 629, "title": "[eclipse/xtext#1777] ported xtend code 2 java", "bodyText": "[eclipse/xtext#1777] ported xtend code 2 java\nSigned-off-by: Christian Dietrich christian.dietrich@itemis.de", "createdAt": "2020-07-17T09:02:31Z", "url": "https://github.com/eclipse/xtext-extras/pull/629", "merged": true, "mergeCommit": {"oid": "53c6cc4c6c3a112bc6f28becf8519bb8f11879d2"}, "closed": true, "closedAt": "2020-07-27T12:51:41Z", "author": {"login": "cdietrich"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1xAeSAFqTQ1MDUzODE0MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5BTHagFqTQ1NTc0ODc5Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTM4MTQx", "url": "https://github.com/eclipse/xtext-extras/pull/629#pullrequestreview-450538141", "createdAt": "2020-07-17T10:09:56Z", "commit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowOTo1NlrOGzNcDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDowOTo1NlrOGzNcDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MDczMw==", "bodyText": "use try-with-resources for url.openStream()?", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456350733", "createdAt": "2020-07-17T10:09:56Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTM4NjI4", "url": "https://github.com/eclipse/xtext-extras/pull/629#pullrequestreview-450538628", "createdAt": "2020-07-17T10:10:41Z", "commit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxMDo0MVrOGzNdYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxMDo0MVrOGzNdYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MTA3Mg==", "bodyText": "use try-with-resources for url.openStream()?", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456351072", "createdAt": "2020-07-17T10:10:41Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTM5MDI3", "url": "https://github.com/eclipse/xtext-extras/pull/629#pullrequestreview-450539027", "createdAt": "2020-07-17T10:11:21Z", "commit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxMToyMVrOGzNehA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxMToyMVrOGzNehA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MTM2NA==", "bodyText": "move constructor to top", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456351364", "createdAt": "2020-07-17T10:11:21Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTQwMTYx", "url": "https://github.com/eclipse/xtext-extras/pull/629#pullrequestreview-450540161", "createdAt": "2020-07-17T10:13:10Z", "commit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxMzoxMFrOGzNh9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxMzoxMFrOGzNh9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MjI0Ng==", "bodyText": "move constructor up", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456352246", "createdAt": "2020-07-17T10:13:10Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tbyte[] bytes = classMap.get(path.substring(0, path.length() - 6).replace(\"/\", \".\"));\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (MalformedURLException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "originalPosition": 169}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTQxNzA2", "url": "https://github.com/eclipse/xtext-extras/pull/629#pullrequestreview-450541706", "createdAt": "2020-07-17T10:15:48Z", "commit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxNTo0OFrOGzNmxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxNTo0OFrOGzNmxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MzQ3Ng==", "bodyText": "remove result var, use compilerOptions.targetJDK directly", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456353476", "createdAt": "2020-07-17T10:15:48Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tbyte[] bytes = classMap.get(path.substring(0, path.length() - 6).replace(\"/\", \".\"));\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (MalformedURLException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setJavaVersion(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic long setJavaVersion(JavaVersion javaVersion) {\n+\t\tlong result = 0;\n+\t\tlong classFmt = toClassFmt(javaVersion);\n+\t\tsetSourceLevel(classFmt);\n+\t\tsetComplianceLevel(classFmt);\n+\t\tresult = compilerOptions.targetJDK = classFmt;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTQyNDgx", "url": "https://github.com/eclipse/xtext-extras/pull/629#pullrequestreview-450542481", "createdAt": "2020-07-17T10:17:09Z", "commit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxNzoxMFrOGzNpSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxNzoxMFrOGzNpSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NDEyMA==", "bodyText": "introduces => introduced", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456354120", "createdAt": "2020-07-17T10:17:10Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tbyte[] bytes = classMap.get(path.substring(0, path.length() - 6).replace(\"/\", \".\"));\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (MalformedURLException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setJavaVersion(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic long setJavaVersion(JavaVersion javaVersion) {\n+\t\tlong result = 0;\n+\t\tlong classFmt = toClassFmt(javaVersion);\n+\t\tsetSourceLevel(classFmt);\n+\t\tsetComplianceLevel(classFmt);\n+\t\tresult = compilerOptions.targetJDK = classFmt;\n+\t\treturn result;\n+\t}\n+\n+\tprivate long toClassFmt(JavaVersion version) {\n+\t\treturn version.toJdtClassFileConstant();\n+\t}\n+\n+\t/**\n+\t * sets the source level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setSourceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.sourceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\t// these fields have been introduces in JDT 3.7", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTQyODE2", "url": "https://github.com/eclipse/xtext-extras/pull/629#pullrequestreview-450542816", "createdAt": "2020-07-17T10:17:48Z", "commit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxNzo0OFrOGzNqUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoxNzo0OFrOGzNqUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NDM4Nw==", "bodyText": "introduces => introduced", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456354387", "createdAt": "2020-07-17T10:17:48Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tbyte[] bytes = classMap.get(path.substring(0, path.length() - 6).replace(\"/\", \".\"));\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (MalformedURLException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setJavaVersion(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic long setJavaVersion(JavaVersion javaVersion) {\n+\t\tlong result = 0;\n+\t\tlong classFmt = toClassFmt(javaVersion);\n+\t\tsetSourceLevel(classFmt);\n+\t\tsetComplianceLevel(classFmt);\n+\t\tresult = compilerOptions.targetJDK = classFmt;\n+\t\treturn result;\n+\t}\n+\n+\tprivate long toClassFmt(JavaVersion version) {\n+\t\treturn version.toJdtClassFileConstant();\n+\t}\n+\n+\t/**\n+\t * sets the source level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setSourceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.sourceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\t// these fields have been introduces in JDT 3.7\n+\t\t\t\tCompilerOptions.class.getField(\"originalSourceLevel\").setLong(compilerOptions, jdkVersion);\n+\t\t\t} catch (NoSuchFieldException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * sets the compliance level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setComplianceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.complianceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\t// these fields have been introduces in JDT 3.7", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "originalPosition": 239}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/04e1a6c56e9c0f082169efd00d08984bbff637f2", "committedDate": "2020-07-17T09:01:52Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}, "afterCommit": {"oid": "8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "committedDate": "2020-07-17T10:17:49Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "committedDate": "2020-07-17T10:17:49Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}, "afterCommit": {"oid": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/e8f0a421f19b9b2d9ee9169f210b0e544653ebad", "committedDate": "2020-07-17T10:18:32Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNTQ1Mzkx", "url": "https://github.com/eclipse/xtext-extras/pull/629#pullrequestreview-450545391", "createdAt": "2020-07-17T10:22:20Z", "commit": {"oid": "04e1a6c56e9c0f082169efd00d08984bbff637f2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoyMjozNFrOGzNy9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDozMDo0MVrOGzOBjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NjU5Nw==", "bodyText": "refactor to:\nICompilationUnit[] units = Stream.of(sources).map(it -> new CompilationUnit(it.getCode().toCharArray(), it.getFileName(), null)).toArray(ICompilationUnit[]::new);", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456356597", "createdAt": "2020-07-17T10:22:34Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tbyte[] bytes = classMap.get(path.substring(0, path.length() - 6).replace(\"/\", \".\"));\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (MalformedURLException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setJavaVersion(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic long setJavaVersion(JavaVersion javaVersion) {\n+\t\tlong result = 0;\n+\t\tlong classFmt = toClassFmt(javaVersion);\n+\t\tsetSourceLevel(classFmt);\n+\t\tsetComplianceLevel(classFmt);\n+\t\tresult = compilerOptions.targetJDK = classFmt;\n+\t\treturn result;\n+\t}\n+\n+\tprivate long toClassFmt(JavaVersion version) {\n+\t\treturn version.toJdtClassFileConstant();\n+\t}\n+\n+\t/**\n+\t * sets the source level\n+\t * (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setSourceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.sourceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\t// these fields have been introduced in JDT 3.7\n+\t\t\t\tCompilerOptions.class.getField(\"originalSourceLevel\").setLong(compilerOptions, jdkVersion);\n+\t\t\t} catch (NoSuchFieldException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * sets the compliance level\n+\t * (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setComplianceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.complianceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\t// these fields have been introduced in JDT 3.7\n+\t\t\t\tCompilerOptions.class.getField(\"originalComplianceLevel\").setLong(compilerOptions, jdkVersion);\n+\t\t\t} catch (NoSuchFieldException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tpublic Result compile(JavaSource... sources) {\n+\t\tResult result = new Result(parentClassLoader);\n+\t\tICompilerRequestor requestor = (CompilationResult it) -> {\n+\t\t\tfor (ClassFile cf : it.getClassFiles()) {\n+\t\t\t\tresult.classMap.put(CharOperation.toString(cf.getCompoundName()), cf.getBytes());\n+\t\t\t}\n+\t\t};\n+\t\torg.eclipse.jdt.internal.compiler.Compiler compiler = new org.eclipse.jdt.internal.compiler.Compiler(nameEnv,\n+\t\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(), compilerOptions, requestor,\n+\t\t\t\tnew DefaultProblemFactory() {\n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic CategorizedProblem createProblem(char[] originatingFileName, int problemId,\n+\t\t\t\t\t\t\tString[] problemArguments, int elaborationId, String[] messageArguments, int severity,\n+\t\t\t\t\t\t\tint startPosition, int endPosition, int lineNumber, int columnNumber) {\n+\t\t\t\t\t\tCategorizedProblem problem = super.createProblem(originatingFileName, problemId,\n+\t\t\t\t\t\t\t\tproblemArguments, elaborationId, messageArguments, severity, startPosition, endPosition,\n+\t\t\t\t\t\t\t\tlineNumber, columnNumber);\n+\t\t\t\t\t\tresult.compilationProblems.add(problem);\n+\t\t\t\t\t\treturn problem;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic CategorizedProblem createProblem(char[] originatingFileName, int problemId,\n+\t\t\t\t\t\t\tString[] problemArguments, String[] messageArguments, int severity, int startPosition,\n+\t\t\t\t\t\t\tint endPosition, int lineNumber, int columnNumber) {\n+\t\t\t\t\t\tCategorizedProblem problem = super.createProblem(originatingFileName, problemId,\n+\t\t\t\t\t\t\t\tproblemArguments, messageArguments, severity, startPosition, endPosition, lineNumber,\n+\t\t\t\t\t\t\t\tcolumnNumber);\n+\t\t\t\t\t\tresult.compilationProblems.add(problem);\n+\t\t\t\t\t\treturn problem;\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\tICompilationUnit[] units = ((ICompilationUnit[]) Conversions.unwrapArray(\n+\t\t\t\tListExtensions.map(Arrays.asList(sources),\n+\t\t\t\t\t\t(JavaSource it) -> new CompilationUnit(it.getCode().toCharArray(), it.getFileName(), null)),\n+\t\t\t\tICompilationUnit.class));\n+\t\tcompiler.compile(units);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1OTAwNQ==", "bodyText": "extract to method, sequence is used twice", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456359005", "createdAt": "2020-07-17T10:27:50Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ */\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\tprivate JavaVersion javaVersion;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t\tthis.javaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic void setJavaVersion(JavaVersion version) {\n+\t\tinMemoryCompiler.setJavaVersion(version);\n+\t\tjavaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic JavaVersion getJavaVersion() {\n+\t\treturn javaVersion;\n+\t}\n+\n+\tpublic Class<?> compileToClass(String classname, String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (Iterables.any(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Java code compiled with errors:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\").join(\n+\t\t\t\t\t\tIterables.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"Code was:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(code);\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(message.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Couldn\\'t load \\'\");\n+\t\t\t\tmessage.append(classname);\n+\t\t\t\tmessage.append(\"\\' \");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.append(\"source :\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(code, \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"PROBLEMS : \");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\").join(result.getCompilationProblems()), \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1OTI5NQ==", "bodyText": "extract to method, sequence is used twice", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456359295", "createdAt": "2020-07-17T10:28:23Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ */\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\tprivate JavaVersion javaVersion;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t\tthis.javaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic void setJavaVersion(JavaVersion version) {\n+\t\tinMemoryCompiler.setJavaVersion(version);\n+\t\tjavaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic JavaVersion getJavaVersion() {\n+\t\treturn javaVersion;\n+\t}\n+\n+\tpublic Class<?> compileToClass(String classname, String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (Iterables.any(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Java code compiled with errors:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\").join(\n+\t\t\t\t\t\tIterables.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\tmessage.newLineIfNotEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MDMzNA==", "bodyText": "This may read better with\nsourceCode.append(String.format(\"public class __Generated implements org.eclipse.xtext.xbase.lib.Functions.Function0<%s> {\", returnType.getName())\n\nIf you agree there are other line candidates.", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456360334", "createdAt": "2020-07-17T10:30:41Z", "author": {"login": "kthoms"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ */\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\tprivate JavaVersion javaVersion;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t\tthis.javaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic void setJavaVersion(JavaVersion version) {\n+\t\tinMemoryCompiler.setJavaVersion(version);\n+\t\tjavaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic JavaVersion getJavaVersion() {\n+\t\treturn javaVersion;\n+\t}\n+\n+\tpublic Class<?> compileToClass(String classname, String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (Iterables.any(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Java code compiled with errors:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\").join(\n+\t\t\t\t\t\tIterables.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"Code was:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(code);\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(message.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Couldn\\'t load \\'\");\n+\t\t\t\tmessage.append(classname);\n+\t\t\t\tmessage.append(\"\\' \");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.append(\"source :\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(code, \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"PROBLEMS : \");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\").join(result.getCompilationProblems()), \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(message.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate String toJavaFile(String string) {\n+\t\treturn string.replace('.', '/') + \".java\";\n+\t}\n+\n+\tpublic Map<String, Class<?>> compileToClasses(Map<String, String> sources) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(((JavaSource[]) Conversions.unwrapArray(\n+\t\t\t\tIterables.transform(sources.entrySet(), e -> new JavaSource(toJavaFile(e.getKey()), e.getValue())),\n+\t\t\t\tJavaSource.class)));\n+\t\ttry {\n+\t\t\tif (Iterables.any(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Java code compiled with errors:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\")\n+\t\t\t\t\t\t.join(Iterables.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"Code was:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"=========\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(Joiner.on(\"\\n=========\\n\").join(sources.values()));\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.append(\"=========\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tthrow new IllegalArgumentException(message.toString());\n+\t\t\t}\n+\t\t\tClassLoader classLoader = result.getClassLoader();\n+\t\t\treturn IterableExtensions.toMap(\n+\t\t\t\t\tIterables.transform(sources.keySet(), (String it) -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\treturn classLoader.loadClass(it);\n+\t\t\t\t\t\t} catch (ClassNotFoundException e) {\n+\t\t\t\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}), Class::getName);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(e.getMessage());\n+\t\t\t\tmessage.append(\" \");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.append(\"source :\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(sources, \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"PROBLEMS : \");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(IterableExtensions.join(result.getCompilationProblems(), \"\\n\"), \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(message.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic <RT extends Object> Function0<RT> createFunction(String expression, Class<RT> returnType) {\n+\t\ttry {\n+\t\t\tStringConcatenation sourceCode = new StringConcatenation();\n+\t\t\tsourceCode.append(\"public class __Generated implements org.eclipse.xtext.xbase.lib.Functions.Function0<\");\n+\t\t\tsourceCode.append(returnType.getName());\n+\t\t\tsourceCode.append(\"> {\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad"}, "originalPosition": 178}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/e8f0a421f19b9b2d9ee9169f210b0e544653ebad", "committedDate": "2020-07-17T10:18:32Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}, "afterCommit": {"oid": "e6ac1b9fdc2f8d946e711c23f6373daa8ae4c815", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/e6ac1b9fdc2f8d946e711c23f6373daa8ae4c815", "committedDate": "2020-07-17T10:32:55Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6ac1b9fdc2f8d946e711c23f6373daa8ae4c815", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/e6ac1b9fdc2f8d946e711c23f6373daa8ae4c815", "committedDate": "2020-07-17T10:32:55Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}, "afterCommit": {"oid": "8b15a76cd705cd6ef5f716404ca6843de3c4407b", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/8b15a76cd705cd6ef5f716404ca6843de3c4407b", "committedDate": "2020-07-17T10:39:12Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8b15a76cd705cd6ef5f716404ca6843de3c4407b", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/8b15a76cd705cd6ef5f716404ca6843de3c4407b", "committedDate": "2020-07-17T10:39:12Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}, "afterCommit": {"oid": "a515e574aa7bc8c354df2d963356d2c0f562c886", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/a515e574aa7bc8c354df2d963356d2c0f562c886", "committedDate": "2020-07-17T10:44:22Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c641a5ce800d21a9f84be146240029008ae4a643", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/c641a5ce800d21a9f84be146240029008ae4a643", "committedDate": "2020-07-24T11:55:01Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a515e574aa7bc8c354df2d963356d2c0f562c886", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/a515e574aa7bc8c354df2d963356d2c0f562c886", "committedDate": "2020-07-17T10:44:22Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}, "afterCommit": {"oid": "c641a5ce800d21a9f84be146240029008ae4a643", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/c641a5ce800d21a9f84be146240029008ae4a643", "committedDate": "2020-07-24T11:55:01Z", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NzQ4Nzk3", "url": "https://github.com/eclipse/xtext-extras/pull/629#pullrequestreview-455748797", "createdAt": "2020-07-27T12:50:33Z", "commit": {"oid": "c641a5ce800d21a9f84be146240029008ae4a643"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4433, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}