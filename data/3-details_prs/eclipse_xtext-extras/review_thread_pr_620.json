{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNDIzNjYw", "number": 620, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzoyMTowOVrOEJNUcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzoyMzozMFrOEJNXTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDkwODY2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.builder.standalone/src/org/eclipse/xtext/builder/standalone/StandaloneBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzoyMTowOVrOGpoxXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzoyMTowOVrOGpoxXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMjc5Ng==", "bodyText": "Unnecessary qualified access to static field", "url": "https://github.com/eclipse/xtext-extras/pull/620#discussion_r446312796", "createdAt": "2020-06-26T17:21:09Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.builder.standalone/src/org/eclipse/xtext/builder/standalone/StandaloneBuilder.java", "diffHunk": "@@ -0,0 +1,584 @@\n+package org.eclipse.xtext.builder.standalone;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.regex.Pattern;\n+import java.util.zip.ZipException;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.plugin.EcorePlugin;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.builder.standalone.compiler.IJavaCompiler;\n+import org.eclipse.xtext.common.types.access.impl.ClasspathTypeProvider;\n+import org.eclipse.xtext.common.types.access.impl.IndexedJvmTypeAccess;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess;\n+import org.eclipse.xtext.generator.GeneratorContext;\n+import org.eclipse.xtext.generator.IFileSystemAccess;\n+import org.eclipse.xtext.generator.JavaIoFileSystemAccess;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.mwe.NameBasedFilter;\n+import org.eclipse.xtext.mwe.PathTraverser;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.clustering.DisabledClusteringPolicy;\n+import org.eclipse.xtext.resource.clustering.DynamicResourceClusteringPolicy;\n+import org.eclipse.xtext.resource.clustering.IResourceClusteringPolicy;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.resource.persistence.IResourceStorageFacade;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.util.UriUtil;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Multimap;\n+import com.google.common.io.Files;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+public class StandaloneBuilder {\n+\tprivate static final Logger LOG = Logger.getLogger(StandaloneBuilder.class);\n+\n+\t/**\n+\t * Map key is a file extension provided by Language FileExtensionProvider\n+\t */\n+\tprivate Map<String, LanguageAccess> languages;\n+\n+\tprivate String baseDir;\n+\n+\tprivate Iterable<String> sourceDirs;\n+\n+\tprivate Iterable<String> javaSourceDirs = new ArrayList<>();\n+\n+\tprivate Iterable<String> classPathEntries;\n+\n+\tprivate File tempDir = Files.createTempDir();\n+\n+\tprivate String encoding;\n+\n+\tprivate String classPathLookUpFilter;\n+\n+\t/**\n+\t * If failOnValidationError is set to <code>false</code>, StandaloneBuilder\n+\t * will try to execute<br>\n+\t * language generator in spite of validation errors.<br>\n+\t * Note that {@link #launch()} will still return the current validation\n+\t * state. <br>\n+\t * Default is <code>true</code>\n+\t */\n+\tprivate boolean failOnValidationError = true;\n+\n+\tprivate boolean debugLog;\n+\n+\tprivate boolean writeStorageResources;\n+\n+\tprivate ClusteringConfig clusteringConfig = null;\n+\n+\t@Inject\n+\tprivate IndexedJvmTypeAccess jvmTypeAccess;\n+\n+\t@Inject\n+\tprivate Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\tprivate AbstractFileSystemAccess commonFileAccess;\n+\n+\t@Inject\n+\tprotected IIssueHandler issueHandler;\n+\n+\t@Inject\n+\tprivate IEncodingProvider.Runtime encodingProvider;\n+\n+\t@Inject\n+\tprivate IJavaCompiler compiler;\n+\n+\tpublic void setTempDir(String pathAsString) {\n+\t\tif (pathAsString != null) {\n+\t\t\ttempDir = new File(pathAsString);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @return <code>false</code> if some of processed resources contains severe\n+\t * validation issues. <code>true</code> otherwise\n+\t */\n+\tpublic boolean launch() {\n+\t\tboolean needsJava = IterableExtensions.exists(languages.values(), l -> l.isLinksAgainstJava());\n+\t\tif (baseDir == null) {\n+\t\t\tbaseDir = System.getProperty(\"user.dir\");\n+\t\t\tStandaloneBuilder.LOG.warn(\"Property baseDir not set. Using '\" + baseDir + \"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d8138bc1d20ccb29589552d31b9c4d257d2a12b"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDkxNTk2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.builder.standalone/src/org/eclipse/xtext/builder/standalone/StandaloneBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzoyMzozMFrOGpo16g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzoyMzozMFrOGpo16g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMxMzk2Mg==", "bodyText": "FluentIterable.from(classPathEntries).transform(..).toArray()", "url": "https://github.com/eclipse/xtext-extras/pull/620#discussion_r446313962", "createdAt": "2020-06-26T17:23:30Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.builder.standalone/src/org/eclipse/xtext/builder/standalone/StandaloneBuilder.java", "diffHunk": "@@ -0,0 +1,584 @@\n+package org.eclipse.xtext.builder.standalone;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.regex.Pattern;\n+import java.util.zip.ZipException;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.plugin.EcorePlugin;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.builder.standalone.compiler.IJavaCompiler;\n+import org.eclipse.xtext.common.types.access.impl.ClasspathTypeProvider;\n+import org.eclipse.xtext.common.types.access.impl.IndexedJvmTypeAccess;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess;\n+import org.eclipse.xtext.generator.GeneratorContext;\n+import org.eclipse.xtext.generator.IFileSystemAccess;\n+import org.eclipse.xtext.generator.JavaIoFileSystemAccess;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.mwe.NameBasedFilter;\n+import org.eclipse.xtext.mwe.PathTraverser;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.clustering.DisabledClusteringPolicy;\n+import org.eclipse.xtext.resource.clustering.DynamicResourceClusteringPolicy;\n+import org.eclipse.xtext.resource.clustering.IResourceClusteringPolicy;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.resource.persistence.IResourceStorageFacade;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.util.UriUtil;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Multimap;\n+import com.google.common.io.Files;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+public class StandaloneBuilder {\n+\tprivate static final Logger LOG = Logger.getLogger(StandaloneBuilder.class);\n+\n+\t/**\n+\t * Map key is a file extension provided by Language FileExtensionProvider\n+\t */\n+\tprivate Map<String, LanguageAccess> languages;\n+\n+\tprivate String baseDir;\n+\n+\tprivate Iterable<String> sourceDirs;\n+\n+\tprivate Iterable<String> javaSourceDirs = new ArrayList<>();\n+\n+\tprivate Iterable<String> classPathEntries;\n+\n+\tprivate File tempDir = Files.createTempDir();\n+\n+\tprivate String encoding;\n+\n+\tprivate String classPathLookUpFilter;\n+\n+\t/**\n+\t * If failOnValidationError is set to <code>false</code>, StandaloneBuilder\n+\t * will try to execute<br>\n+\t * language generator in spite of validation errors.<br>\n+\t * Note that {@link #launch()} will still return the current validation\n+\t * state. <br>\n+\t * Default is <code>true</code>\n+\t */\n+\tprivate boolean failOnValidationError = true;\n+\n+\tprivate boolean debugLog;\n+\n+\tprivate boolean writeStorageResources;\n+\n+\tprivate ClusteringConfig clusteringConfig = null;\n+\n+\t@Inject\n+\tprivate IndexedJvmTypeAccess jvmTypeAccess;\n+\n+\t@Inject\n+\tprivate Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\tprivate AbstractFileSystemAccess commonFileAccess;\n+\n+\t@Inject\n+\tprotected IIssueHandler issueHandler;\n+\n+\t@Inject\n+\tprivate IEncodingProvider.Runtime encodingProvider;\n+\n+\t@Inject\n+\tprivate IJavaCompiler compiler;\n+\n+\tpublic void setTempDir(String pathAsString) {\n+\t\tif (pathAsString != null) {\n+\t\t\ttempDir = new File(pathAsString);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @return <code>false</code> if some of processed resources contains severe\n+\t * validation issues. <code>true</code> otherwise\n+\t */\n+\tpublic boolean launch() {\n+\t\tboolean needsJava = IterableExtensions.exists(languages.values(), l -> l.isLinksAgainstJava());\n+\t\tif (baseDir == null) {\n+\t\t\tbaseDir = System.getProperty(\"user.dir\");\n+\t\t\tStandaloneBuilder.LOG.warn(\"Property baseDir not set. Using '\" + baseDir + \"'\");\n+\t\t}\n+\t\tif (needsJava) {\n+\t\t\tStandaloneBuilder.LOG.info(\"Using common types.\");\n+\t\t}\n+\t\tXtextResourceSet resourceSet = resourceSetProvider.get();\n+\t\tif (encoding != null) {\n+\t\t\tforceDebugLog(\"Setting encoding.\");\n+\t\t\tfileEncodingSetup(languages.values(), encoding);\n+\t\t}\n+\t\tStandaloneBuilder.LOG.info(\"Collecting source models.\");\n+\t\tlong startedAt = System.currentTimeMillis();\n+\t\tIterable<String> rootsToTravers = classPathEntries;\n+\t\tif (classPathLookUpFilter != null) {\n+\t\t\tStandaloneBuilder.LOG.info(\"Class path look up filter is active.\");\n+\t\t\tPattern cpLookUpFilter = Pattern.compile(classPathLookUpFilter);\n+\t\t\trootsToTravers = Iterables.filter(classPathEntries, root -> cpLookUpFilter.matcher(root).matches());\n+\t\t\tStandaloneBuilder.LOG.info(\"Investigating \" + Iterables.size(rootsToTravers) + \" of \"\n+\t\t\t\t\t+ Iterables.size(classPathEntries) + \" class path entries.\");\n+\t\t}\n+\t\tList<URI> sourceResourceURIs = collectResources(sourceDirs, resourceSet);\n+\t\tIterable<URI> allResourcesURIs = Iterables.concat(sourceResourceURIs,\n+\t\t\t\tcollectResources(rootsToTravers, resourceSet));\n+\t\tforceDebugLog(\"Finished collecting source models. Took: \" + (System.currentTimeMillis() - startedAt) + \" ms.\");\n+\t\tIterable<String> allClassPathEntries = Iterables.concat(sourceDirs, classPathEntries);\n+\t\tif (needsJava) {\n+\t\t\tStandaloneBuilder.LOG.info(\"Installing type provider.\");\n+\t\t\tinstallTypeProvider(allClassPathEntries, resourceSet, null);\n+\t\t}\n+\t\tIResourceClusteringPolicy strategy = null;\n+\t\tif (clusteringConfig != null) {\n+\t\t\tStandaloneBuilder.LOG.info(\"Clustering configured.\");\n+\t\t\tDynamicResourceClusteringPolicy dynamicResourceClusteringPolicy = new DynamicResourceClusteringPolicy();\n+\t\t\t// Convert MB to byte to make it easier for the user\n+\t\t\tdynamicResourceClusteringPolicy.setMinimumFreeMemory(clusteringConfig.getMinimumFreeMemory() * 1024 * 1024);\n+\t\t\tdynamicResourceClusteringPolicy.setMinimumClusterSize(clusteringConfig.getMinimumClusterSize());\n+\t\t\tdynamicResourceClusteringPolicy.setMinimumPercentFreeMemory(clusteringConfig.getMinimumPercentFreeMemory());\n+\t\t\tstrategy = dynamicResourceClusteringPolicy;\n+\t\t} else {\n+\t\t\tstrategy = new DisabledClusteringPolicy();\n+\t\t}\n+\t\t// Fill index\n+\t\tResourceDescriptionsData index = new ResourceDescriptionsData(new ArrayList<>());\n+\t\tIterator<URI> allResourceIterator = allResourcesURIs.iterator();\n+\t\twhile (allResourceIterator.hasNext()) {\n+\t\t\tList<Resource> resources = new ArrayList<>();\n+\t\t\tint clusterIndex = 0;\n+\t\t\tboolean canContinue = true;\n+\t\t\twhile (allResourceIterator.hasNext() && canContinue) {\n+\t\t\t\tURI uri = allResourceIterator.next();\n+\t\t\t\tResource resource = resourceSet.getResource(uri, true);\n+\t\t\t\tresources.add(resource);\n+\t\t\t\tfillIndex(uri, resource, index);\n+\t\t\t\tclusterIndex++;\n+\t\t\t\tif (!strategy.continueProcessing(resourceSet, null, clusterIndex)) {\n+\t\t\t\t\tcanContinue = false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (!canContinue) {\n+\t\t\t\tclearResourceSet(resourceSet);\n+\t\t\t}\n+\t\t}\n+\t\tinstallIndex(resourceSet, index);\n+\t\t// Generate Stubs\n+\t\tif (needsJava) {\n+\t\t\tString stubsClasses = compileStubs(generateStubs(index, sourceResourceURIs));\n+\t\t\tStandaloneBuilder.LOG.info(\"Installing type provider for stubs.\");\n+\t\t\tinstallTypeProvider(Iterables.concat(allClassPathEntries, Lists.newArrayList(stubsClasses)), resourceSet,\n+\t\t\t\t\tjvmTypeAccess);\n+\t\t}\n+\t\t// Validate and generate\n+\t\tStandaloneBuilder.LOG.info(\"Validate and generate.\");\n+\t\tIterator<URI> sourceResourceIterator = sourceResourceURIs.iterator();\n+\t\tboolean hasValidationErrors = false;\n+\t\twhile (sourceResourceIterator.hasNext()) {\n+\t\t\tList<Resource> resources = new ArrayList<>();\n+\t\t\tint clusterIndex = 0;\n+\t\t\tboolean canContinue = true;\n+\t\t\twhile (sourceResourceIterator.hasNext() && canContinue) {\n+\t\t\t\tURI uri = sourceResourceIterator.next();\n+\t\t\t\tResource resource = resourceSet.getResource(uri, true);\n+\t\t\t\tresources.add(resource);\n+\t\t\t\tresource.getContents(); // full initialize\n+\t\t\t\tEcoreUtil2.resolveLazyCrossReferences(resource, CancelIndicator.NullImpl);\n+\t\t\t\thasValidationErrors = !validate(resource) || hasValidationErrors;\n+\t\t\t\tclusterIndex++;\n+\t\t\t\tif (!strategy.continueProcessing(resourceSet, null, clusterIndex)) {\n+\t\t\t\t\tcanContinue = false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (failOnValidationError && hasValidationErrors) {\n+\t\t\t\treturn !hasValidationErrors;\n+\t\t\t}\n+\t\t\tgenerate(resources);\n+\t\t\tif (!canContinue) {\n+\t\t\t\tclearResourceSet(resourceSet);\n+\t\t\t}\n+\t\t}\n+\t\treturn !hasValidationErrors;\n+\t}\n+\n+\tpublic void fillIndex(URI uri, Resource resource, ResourceDescriptionsData index) {\n+\t\tIResourceDescription description = languageAccess(uri).getResourceDescriptionManager()\n+\t\t\t\t.getResourceDescription(resource);\n+\t\tindex.addDescription(uri, description);\n+\t}\n+\n+\tpublic void fileEncodingSetup(Collection<LanguageAccess> langs, String encoding) {\n+\t\tfor (LanguageAccess lang : langs) {\n+\t\t\tIEncodingProvider provider = lang.getEncodingProvider();\n+\t\t\tif (provider instanceof IEncodingProvider.Runtime) {\n+\t\t\t\t((IEncodingProvider.Runtime) provider).setDefaultEncoding(encoding);\n+\t\t\t} else {\n+\t\t\t\tforceDebugLog(\"Couldn't set encoding '\" + encoding + \"' for provider '\" + provider\n+\t\t\t\t\t\t+ \"'. Only subclasses of IEncodingProvider.Runtime are supported.\");\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void installIndex(XtextResourceSet resourceSet, ResourceDescriptionsData index) {\n+\t\tResourceDescriptionsData.ResourceSetAdapter.installResourceDescriptionsData(resourceSet, index);\n+\t}\n+\n+\tprotected String compileStubs(File stubsDir) {\n+\t\tFile stubsClasses = createTempDir(\"classes\");\n+\t\tcompiler.setClassPath(classPathEntries);\n+\t\tStandaloneBuilder.LOG.info(\"Compiling stubs located in \" + stubsDir.getAbsolutePath());\n+\t\tSet<String> sourcesToCompile = uniqueEntries(\n+\t\t\t\tIterables.concat(javaSourceDirs, sourceDirs, Lists.newArrayList(stubsDir.getAbsolutePath())));\n+\t\tforceDebugLog(\"Compiler source roots: \" + Joiner.on(\",\").join(sourcesToCompile));\n+\t\tIJavaCompiler.CompilationResult result = compiler.compile(sourcesToCompile, stubsClasses);\n+\t\tif (result != null) {\n+\t\t\tswitch (result) {\n+\t\t\tcase SKIPPED:\n+\t\t\t\tStandaloneBuilder.LOG.info(\"Nothing to compile. Stubs compilation was skipped.\");\n+\t\t\t\tbreak;\n+\t\t\tcase FAILED:\n+\t\t\t\tforceDebugLog(\"Stubs compilation finished with errors.\");\n+\t\t\t\tbreak;\n+\t\t\tcase SUCCEEDED:\n+\t\t\t\tforceDebugLog(\"Stubs compilation successfully finished.\");\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\treturn stubsClasses.getAbsolutePath();\n+\t}\n+\n+\tprotected Set<String> uniqueEntries(Iterable<String> pathes) {\n+\t\treturn IterableExtensions.toSet(Iterables.transform(pathes, (String it) -> new File(it).getAbsolutePath()));\n+\t}\n+\n+\tprotected File generateStubs(ResourceDescriptionsData data, List<URI> sourceResourceURIs) {\n+\t\tFile stubsDir = createTempDir(\"stubs\");\n+\t\tStandaloneBuilder.LOG.info(\"Generating stubs into \" + stubsDir.getAbsolutePath());\n+\t\tif (encoding != null) {\n+\t\t\tencodingProvider.setDefaultEncoding(encoding);\n+\t\t}\n+\t\tcommonFileAccess.setOutputPath(IFileSystemAccess.DEFAULT_OUTPUT, stubsDir.getAbsolutePath());\n+\t\tIterable<URI> generateStubs = Iterables.filter(sourceResourceURIs,\n+\t\t\t\t(URI it) -> languageAccess(it).isLinksAgainstJava());\n+\t\tfor (URI it : generateStubs) {\n+\t\t\tlanguageAccess(it).getStubGenerator().doGenerateStubs(commonFileAccess, data.getResourceDescription(it));\n+\t\t}\n+\t\treturn stubsDir;\n+\t}\n+\n+\tprotected boolean validate(Resource resource) {\n+\t\tStandaloneBuilder.LOG.info(\"Starting validation for input: '\" + resource.getURI().lastSegment() + \"'\");\n+\t\tIResourceValidator resourceValidator = languageAccess(resource.getURI()).getResourceValidator();\n+\t\tList<Issue> validationResult = resourceValidator.validate(resource, CheckMode.ALL, null);\n+\t\treturn issueHandler.handleIssue(validationResult);\n+\t}\n+\n+\tprotected void generate(List<Resource> sourceResources) {\n+\t\tGeneratorContext context = new GeneratorContext();\n+\t\tcontext.setCancelIndicator(CancelIndicator.NullImpl);\n+\t\tfor (Resource it : sourceResources) {\n+\t\t\tStandaloneBuilder.LOG.info(\"Starting generator for input: '\" + it.getURI().lastSegment() + \"'\");\n+\t\t\tregisterCurrentSource(it.getURI());\n+\t\t\tLanguageAccess access = languageAccess(it.getURI());\n+\t\t\tJavaIoFileSystemAccess fileSystemAccess = getFileSystemAccess(access);\n+\t\t\tif (isWriteStorageResources()) {\n+\t\t\t\tif (it instanceof StorageAwareResource) {\n+\t\t\t\t\tIResourceStorageFacade resourceStorageFacade = ((StorageAwareResource) it)\n+\t\t\t\t\t\t\t.getResourceStorageFacade();\n+\t\t\t\t\tif (resourceStorageFacade != null) {\n+\t\t\t\t\t\tresourceStorageFacade.saveResource((StorageAwareResource) it, fileSystemAccess);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\taccess.getGenerator().generate(it, fileSystemAccess, context);\n+\t\t}\n+\t}\n+\n+\tprotected void registerCurrentSource(URI uri) {\n+\t\tJavaIoFileSystemAccess fsa = getFileSystemAccess(languageAccess(uri));\n+\t\tIterable<URI> folders = Iterables.transform(sourceDirs, (String it) -> UriUtil.createFolderURI(new File(it)));\n+\t\tURI absoluteSource = IterableExtensions.findFirst(folders, (URI it) -> UriUtil.isPrefixOf(it, uri));\n+\t\tif (absoluteSource == null) {\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\"Resource \" + uri + \" is not contained in any of the known source folders \" + sourceDirs + \".\");\n+\t\t}\n+\t\tURI projectBaseURI = UriUtil.createFolderURI(new File(baseDir));\n+\t\tfor (OutputConfiguration output : fsa.getOutputConfigurations().values()) {\n+\t\t\tfor (String sourceFolder : output.getSourceFolders()) {\n+\t\t\t\tURI sourceFolderURI = URI.createURI((sourceFolder + \"/\"));\n+\t\t\t\tif (sourceFolderURI.isRelative()) {\n+\t\t\t\t\tsourceFolderURI = sourceFolderURI.resolve(projectBaseURI);\n+\t\t\t\t}\n+\t\t\t\tif (Objects.equal(absoluteSource, sourceFolderURI)) {\n+\t\t\t\t\tfsa.setCurrentSource(sourceFolder);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Map<LanguageAccess, JavaIoFileSystemAccess> configuredFsas = new HashMap<>();\n+\n+\tprivate JavaIoFileSystemAccess getFileSystemAccess(LanguageAccess language) {\n+\t\tJavaIoFileSystemAccess fsa = configuredFsas.get(language);\n+\t\tif (fsa == null) {\n+\t\t\tfsa = language.createFileSystemAccess(new File(baseDir));\n+\t\t\tfsa = this.configureFileSystemAccess(fsa, language);\n+\t\t\tconfiguredFsas.put(language, fsa);\n+\t\t}\n+\t\treturn fsa;\n+\t}\n+\n+\tprotected JavaIoFileSystemAccess configureFileSystemAccess(JavaIoFileSystemAccess fsa, LanguageAccess language) {\n+\t\treturn fsa;\n+\t}\n+\n+\tprivate LanguageAccess languageAccess(URI uri) {\n+\t\treturn languages.get(uri.fileExtension());\n+\t}\n+\n+\tprotected File createTempDir(String subDir) {\n+\t\ttry {\n+\t\t\tFile file = new File(this.tempDir, subDir);\n+\t\t\tif (!file.mkdirs() && !file.exists()) {\n+\t\t\t\tthrow new IOException(\"Failed to create directory '\" + file.getAbsolutePath() + \"'\");\n+\t\t\t}\n+\t\t\treturn file;\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void installTypeProvider(Iterable<String> classPathRoots, XtextResourceSet resSet,\n+\t\t\tIndexedJvmTypeAccess typeAccess) {\n+\t\tURLClassLoader classLoader = createURLClassLoader(classPathRoots);\n+\t\tnew ClasspathTypeProvider(classLoader, resSet, typeAccess, null);\n+\t\tresSet.setClasspathURIContext(classLoader);\n+\t}\n+\n+\tprivate URLClassLoader createURLClassLoader(Iterable<String> classPathEntries) {\n+\t\tIterable<URL> classPathUrls = Iterables.transform(classPathEntries, (String str) -> {\n+\t\t\ttry {\n+\t\t\t\treturn new File(str).toURI().toURL();\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t});\n+\t\treturn new URLClassLoader(((URL[]) Conversions.unwrapArray(classPathUrls, URL.class)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d8138bc1d20ccb29589552d31b9c4d257d2a12b"}, "originalPosition": 397}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 726, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}