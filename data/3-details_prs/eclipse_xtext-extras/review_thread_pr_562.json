{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NDAzMTgw", "number": 562, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyMzozMFrODa037w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMjoxODoxNFrODa23vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NDU1ODU1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/ClassFileCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyMzozMFrOFh9xqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyMzozMFrOFh9xqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1OTQ2Ng==", "bodyText": "A few unnecessary type arguments. The diamond op could help to simplify the code.", "url": "https://github.com/eclipse/xtext-extras/pull/562#discussion_r371159466", "createdAt": "2020-01-27T10:23:30Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/ClassFileCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2018 itemis AG (http://www.itemis.eu) and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ */\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.jdt.internal.compiler.env.IBinaryType;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+/**\n+ * A cache for parsed class or java source file content. It is bound to the lifecycle of a resource set.\n+ * \n+ * @author Christian Dietrich - Initial contribution and API\n+ * @since 2.15\n+ */\n+public class ClassFileCache {\n+\tpublic static class ClassFileCacheAdapter extends AdapterImpl {\n+\t\tprivate ClassFileCache element;\n+\n+\t\tpublic ClassFileCacheAdapter(ClassFileCache element) {\n+\t\t\tthis.element = element;\n+\t\t}\n+\n+\t\tpublic ClassFileCache get() {\n+\t\t\treturn this.element;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAdapterForType(Object object) {\n+\t\t\treturn object == ClassFileCache.class;\n+\t\t}\n+\t}\n+\n+\tprivate static final Object NULL = new Object();\n+\n+\tprivate final Map<QualifiedName, Object> cache = new ConcurrentHashMap<QualifiedName, Object>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9811c08b7821e6d9501ddf6fad0c5d686cc4cf"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NDU2NjI5OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/ClassFileCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyNTo0NlrOFh92Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyNTo0NlrOFh92Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE2MDYzMA==", "bodyText": "Should use EcoreUtil.getExistingAdapter to benefit from the new EScannableAdapterList", "url": "https://github.com/eclipse/xtext-extras/pull/562#discussion_r371160630", "createdAt": "2020-01-27T10:25:46Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/ClassFileCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2018 itemis AG (http://www.itemis.eu) and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ */\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.jdt.internal.compiler.env.IBinaryType;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+/**\n+ * A cache for parsed class or java source file content. It is bound to the lifecycle of a resource set.\n+ * \n+ * @author Christian Dietrich - Initial contribution and API\n+ * @since 2.15\n+ */\n+public class ClassFileCache {\n+\tpublic static class ClassFileCacheAdapter extends AdapterImpl {\n+\t\tprivate ClassFileCache element;\n+\n+\t\tpublic ClassFileCacheAdapter(ClassFileCache element) {\n+\t\t\tthis.element = element;\n+\t\t}\n+\n+\t\tpublic ClassFileCache get() {\n+\t\t\treturn this.element;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAdapterForType(Object object) {\n+\t\t\treturn object == ClassFileCache.class;\n+\t\t}\n+\t}\n+\n+\tprivate static final Object NULL = new Object();\n+\n+\tprivate final Map<QualifiedName, Object> cache = new ConcurrentHashMap<QualifiedName, Object>();\n+\n+\tprivate final Set<Resource> resourcesToCompile = Collections\n+\t\t\t.<Resource>newSetFromMap(new ConcurrentHashMap<Resource, Boolean>());\n+\n+\tprivate final Map<char[], List<String>> allTopLevelTypes = new ConcurrentHashMap<char[], List<String>>();\n+\n+\tprivate final Map<char[], Map<String, byte[]>> allClassMaps = new ConcurrentHashMap<char[], Map<String, byte[]>>();\n+\n+\tpublic boolean containsKey(QualifiedName qualifiedName) {\n+\t\treturn cache.containsKey(qualifiedName);\n+\t}\n+\n+\tpublic IBinaryType get(QualifiedName qualifiedName) {\n+\t\tObject result = cache.get(qualifiedName);\n+\t\tif (result == ClassFileCache.NULL) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (IBinaryType) result;\n+\t}\n+\n+\tpublic void put(QualifiedName qualifiedName, IBinaryType answer) {\n+\t\tif (answer == null) {\n+\t\t\tcache.put(qualifiedName, ClassFileCache.NULL);\n+\t\t} else {\n+\t\t\tcache.put(qualifiedName, answer);\n+\t\t}\n+\t}\n+\n+\tpublic IBinaryType computeIfAbsent(QualifiedName qualifiedName,\n+\t\t\tFunction<? super QualifiedName, ? extends IBinaryType> fun) {\n+\t\tObject result = this.cache.computeIfAbsent(qualifiedName, (QualifiedName fqn) -> {\n+\t\t\tIBinaryType binaryType = fun.apply(fqn);\n+\t\t\tif (binaryType != null) {\n+\t\t\t\treturn binaryType;\n+\t\t\t} else {\n+\t\t\t\treturn ClassFileCache.NULL;\n+\t\t\t}\n+\t\t});\n+\t\tif (result instanceof IBinaryType) {\n+\t\t\treturn (IBinaryType) result;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic void clear() {\n+\t\tcache.clear();\n+\t\tresourcesToCompile.clear();\n+\t\tallTopLevelTypes.clear();\n+\t\tallClassMaps.clear();\n+\t}\n+\n+\tpublic void addResourceToCompile(Resource resource) {\n+\t\tresourcesToCompile.add(resource);\n+\t}\n+\n+\tpublic Set<Resource> drainResourcesToCompile() {\n+\t\tHashSet<Resource> result = new HashSet<Resource>(resourcesToCompile);\n+\t\tresourcesToCompile.clear();\n+\t\treturn result;\n+\t}\n+\n+\tpublic boolean popCompileResult(char[] fileName,\n+\t\t\tProcedure2<? super List<String>, ? super Map<String, byte[]>> consumer) {\n+\t\tif (allTopLevelTypes.containsKey(fileName)) {\n+\t\t\tconsumer.apply(allTopLevelTypes.remove(fileName), allClassMaps.remove(fileName));\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic void addCompileResult(char[] fileName, List<String> topLevelTypes, Map<String, byte[]> classMap) {\n+\t\tallTopLevelTypes.put(fileName, topLevelTypes);\n+\t\tallClassMaps.put(fileName, classMap);\n+\t}\n+\n+\tpublic static ClassFileCache findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9811c08b7821e6d9501ddf6fad0c5d686cc4cf"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NDU2ODI2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/ClassFileCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyNjoxNVrOFh93Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMTowODoxMlrOFh-_xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE2MDkxNA==", "bodyText": "Dead code?", "url": "https://github.com/eclipse/xtext-extras/pull/562#discussion_r371160914", "createdAt": "2020-01-27T10:26:15Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/ClassFileCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2018 itemis AG (http://www.itemis.eu) and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ */\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.jdt.internal.compiler.env.IBinaryType;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+/**\n+ * A cache for parsed class or java source file content. It is bound to the lifecycle of a resource set.\n+ * \n+ * @author Christian Dietrich - Initial contribution and API\n+ * @since 2.15\n+ */\n+public class ClassFileCache {\n+\tpublic static class ClassFileCacheAdapter extends AdapterImpl {\n+\t\tprivate ClassFileCache element;\n+\n+\t\tpublic ClassFileCacheAdapter(ClassFileCache element) {\n+\t\t\tthis.element = element;\n+\t\t}\n+\n+\t\tpublic ClassFileCache get() {\n+\t\t\treturn this.element;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAdapterForType(Object object) {\n+\t\t\treturn object == ClassFileCache.class;\n+\t\t}\n+\t}\n+\n+\tprivate static final Object NULL = new Object();\n+\n+\tprivate final Map<QualifiedName, Object> cache = new ConcurrentHashMap<QualifiedName, Object>();\n+\n+\tprivate final Set<Resource> resourcesToCompile = Collections\n+\t\t\t.<Resource>newSetFromMap(new ConcurrentHashMap<Resource, Boolean>());\n+\n+\tprivate final Map<char[], List<String>> allTopLevelTypes = new ConcurrentHashMap<char[], List<String>>();\n+\n+\tprivate final Map<char[], Map<String, byte[]>> allClassMaps = new ConcurrentHashMap<char[], Map<String, byte[]>>();\n+\n+\tpublic boolean containsKey(QualifiedName qualifiedName) {\n+\t\treturn cache.containsKey(qualifiedName);\n+\t}\n+\n+\tpublic IBinaryType get(QualifiedName qualifiedName) {\n+\t\tObject result = cache.get(qualifiedName);\n+\t\tif (result == ClassFileCache.NULL) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (IBinaryType) result;\n+\t}\n+\n+\tpublic void put(QualifiedName qualifiedName, IBinaryType answer) {\n+\t\tif (answer == null) {\n+\t\t\tcache.put(qualifiedName, ClassFileCache.NULL);\n+\t\t} else {\n+\t\t\tcache.put(qualifiedName, answer);\n+\t\t}\n+\t}\n+\n+\tpublic IBinaryType computeIfAbsent(QualifiedName qualifiedName,\n+\t\t\tFunction<? super QualifiedName, ? extends IBinaryType> fun) {\n+\t\tObject result = this.cache.computeIfAbsent(qualifiedName, (QualifiedName fqn) -> {\n+\t\t\tIBinaryType binaryType = fun.apply(fqn);\n+\t\t\tif (binaryType != null) {\n+\t\t\t\treturn binaryType;\n+\t\t\t} else {\n+\t\t\t\treturn ClassFileCache.NULL;\n+\t\t\t}\n+\t\t});\n+\t\tif (result instanceof IBinaryType) {\n+\t\t\treturn (IBinaryType) result;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic void clear() {\n+\t\tcache.clear();\n+\t\tresourcesToCompile.clear();\n+\t\tallTopLevelTypes.clear();\n+\t\tallClassMaps.clear();\n+\t}\n+\n+\tpublic void addResourceToCompile(Resource resource) {\n+\t\tresourcesToCompile.add(resource);\n+\t}\n+\n+\tpublic Set<Resource> drainResourcesToCompile() {\n+\t\tHashSet<Resource> result = new HashSet<Resource>(resourcesToCompile);\n+\t\tresourcesToCompile.clear();\n+\t\treturn result;\n+\t}\n+\n+\tpublic boolean popCompileResult(char[] fileName,\n+\t\t\tProcedure2<? super List<String>, ? super Map<String, byte[]>> consumer) {\n+\t\tif (allTopLevelTypes.containsKey(fileName)) {\n+\t\t\tconsumer.apply(allTopLevelTypes.remove(fileName), allClassMaps.remove(fileName));\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic void addCompileResult(char[] fileName, List<String> topLevelTypes, Map<String, byte[]> classMap) {\n+\t\tallTopLevelTypes.put(fileName, topLevelTypes);\n+\t\tallClassMaps.put(fileName, classMap);\n+\t}\n+\n+\tpublic static ClassFileCache findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters()) {\n+\t\t\tif (adapter instanceof ClassFileCache.ClassFileCacheAdapter) {\n+\t\t\t\treturn ((ClassFileCache.ClassFileCacheAdapter) adapter).get();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic static ClassFileCache removeFromEmfObject(Notifier emfObject) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9811c08b7821e6d9501ddf6fad0c5d686cc4cf"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE2MzgyMg==", "bodyText": "am not sure if we should keep if somebody uses it", "url": "https://github.com/eclipse/xtext-extras/pull/562#discussion_r371163822", "createdAt": "2020-01-27T10:32:01Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/ClassFileCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2018 itemis AG (http://www.itemis.eu) and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ */\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.jdt.internal.compiler.env.IBinaryType;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+/**\n+ * A cache for parsed class or java source file content. It is bound to the lifecycle of a resource set.\n+ * \n+ * @author Christian Dietrich - Initial contribution and API\n+ * @since 2.15\n+ */\n+public class ClassFileCache {\n+\tpublic static class ClassFileCacheAdapter extends AdapterImpl {\n+\t\tprivate ClassFileCache element;\n+\n+\t\tpublic ClassFileCacheAdapter(ClassFileCache element) {\n+\t\t\tthis.element = element;\n+\t\t}\n+\n+\t\tpublic ClassFileCache get() {\n+\t\t\treturn this.element;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAdapterForType(Object object) {\n+\t\t\treturn object == ClassFileCache.class;\n+\t\t}\n+\t}\n+\n+\tprivate static final Object NULL = new Object();\n+\n+\tprivate final Map<QualifiedName, Object> cache = new ConcurrentHashMap<QualifiedName, Object>();\n+\n+\tprivate final Set<Resource> resourcesToCompile = Collections\n+\t\t\t.<Resource>newSetFromMap(new ConcurrentHashMap<Resource, Boolean>());\n+\n+\tprivate final Map<char[], List<String>> allTopLevelTypes = new ConcurrentHashMap<char[], List<String>>();\n+\n+\tprivate final Map<char[], Map<String, byte[]>> allClassMaps = new ConcurrentHashMap<char[], Map<String, byte[]>>();\n+\n+\tpublic boolean containsKey(QualifiedName qualifiedName) {\n+\t\treturn cache.containsKey(qualifiedName);\n+\t}\n+\n+\tpublic IBinaryType get(QualifiedName qualifiedName) {\n+\t\tObject result = cache.get(qualifiedName);\n+\t\tif (result == ClassFileCache.NULL) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (IBinaryType) result;\n+\t}\n+\n+\tpublic void put(QualifiedName qualifiedName, IBinaryType answer) {\n+\t\tif (answer == null) {\n+\t\t\tcache.put(qualifiedName, ClassFileCache.NULL);\n+\t\t} else {\n+\t\t\tcache.put(qualifiedName, answer);\n+\t\t}\n+\t}\n+\n+\tpublic IBinaryType computeIfAbsent(QualifiedName qualifiedName,\n+\t\t\tFunction<? super QualifiedName, ? extends IBinaryType> fun) {\n+\t\tObject result = this.cache.computeIfAbsent(qualifiedName, (QualifiedName fqn) -> {\n+\t\t\tIBinaryType binaryType = fun.apply(fqn);\n+\t\t\tif (binaryType != null) {\n+\t\t\t\treturn binaryType;\n+\t\t\t} else {\n+\t\t\t\treturn ClassFileCache.NULL;\n+\t\t\t}\n+\t\t});\n+\t\tif (result instanceof IBinaryType) {\n+\t\t\treturn (IBinaryType) result;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic void clear() {\n+\t\tcache.clear();\n+\t\tresourcesToCompile.clear();\n+\t\tallTopLevelTypes.clear();\n+\t\tallClassMaps.clear();\n+\t}\n+\n+\tpublic void addResourceToCompile(Resource resource) {\n+\t\tresourcesToCompile.add(resource);\n+\t}\n+\n+\tpublic Set<Resource> drainResourcesToCompile() {\n+\t\tHashSet<Resource> result = new HashSet<Resource>(resourcesToCompile);\n+\t\tresourcesToCompile.clear();\n+\t\treturn result;\n+\t}\n+\n+\tpublic boolean popCompileResult(char[] fileName,\n+\t\t\tProcedure2<? super List<String>, ? super Map<String, byte[]>> consumer) {\n+\t\tif (allTopLevelTypes.containsKey(fileName)) {\n+\t\t\tconsumer.apply(allTopLevelTypes.remove(fileName), allClassMaps.remove(fileName));\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic void addCompileResult(char[] fileName, List<String> topLevelTypes, Map<String, byte[]> classMap) {\n+\t\tallTopLevelTypes.put(fileName, topLevelTypes);\n+\t\tallClassMaps.put(fileName, classMap);\n+\t}\n+\n+\tpublic static ClassFileCache findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters()) {\n+\t\t\tif (adapter instanceof ClassFileCache.ClassFileCacheAdapter) {\n+\t\t\t\treturn ((ClassFileCache.ClassFileCacheAdapter) adapter).get();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic static ClassFileCache removeFromEmfObject(Notifier emfObject) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE2MDkxNA=="}, "originalCommit": {"oid": "4d9811c08b7821e6d9501ddf6fad0c5d686cc4cf"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE3OTQ2MA==", "bodyText": "Agreed", "url": "https://github.com/eclipse/xtext-extras/pull/562#discussion_r371179460", "createdAt": "2020-01-27T11:08:12Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/ClassFileCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2018 itemis AG (http://www.itemis.eu) and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ */\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.jdt.internal.compiler.env.IBinaryType;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+/**\n+ * A cache for parsed class or java source file content. It is bound to the lifecycle of a resource set.\n+ * \n+ * @author Christian Dietrich - Initial contribution and API\n+ * @since 2.15\n+ */\n+public class ClassFileCache {\n+\tpublic static class ClassFileCacheAdapter extends AdapterImpl {\n+\t\tprivate ClassFileCache element;\n+\n+\t\tpublic ClassFileCacheAdapter(ClassFileCache element) {\n+\t\t\tthis.element = element;\n+\t\t}\n+\n+\t\tpublic ClassFileCache get() {\n+\t\t\treturn this.element;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAdapterForType(Object object) {\n+\t\t\treturn object == ClassFileCache.class;\n+\t\t}\n+\t}\n+\n+\tprivate static final Object NULL = new Object();\n+\n+\tprivate final Map<QualifiedName, Object> cache = new ConcurrentHashMap<QualifiedName, Object>();\n+\n+\tprivate final Set<Resource> resourcesToCompile = Collections\n+\t\t\t.<Resource>newSetFromMap(new ConcurrentHashMap<Resource, Boolean>());\n+\n+\tprivate final Map<char[], List<String>> allTopLevelTypes = new ConcurrentHashMap<char[], List<String>>();\n+\n+\tprivate final Map<char[], Map<String, byte[]>> allClassMaps = new ConcurrentHashMap<char[], Map<String, byte[]>>();\n+\n+\tpublic boolean containsKey(QualifiedName qualifiedName) {\n+\t\treturn cache.containsKey(qualifiedName);\n+\t}\n+\n+\tpublic IBinaryType get(QualifiedName qualifiedName) {\n+\t\tObject result = cache.get(qualifiedName);\n+\t\tif (result == ClassFileCache.NULL) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (IBinaryType) result;\n+\t}\n+\n+\tpublic void put(QualifiedName qualifiedName, IBinaryType answer) {\n+\t\tif (answer == null) {\n+\t\t\tcache.put(qualifiedName, ClassFileCache.NULL);\n+\t\t} else {\n+\t\t\tcache.put(qualifiedName, answer);\n+\t\t}\n+\t}\n+\n+\tpublic IBinaryType computeIfAbsent(QualifiedName qualifiedName,\n+\t\t\tFunction<? super QualifiedName, ? extends IBinaryType> fun) {\n+\t\tObject result = this.cache.computeIfAbsent(qualifiedName, (QualifiedName fqn) -> {\n+\t\t\tIBinaryType binaryType = fun.apply(fqn);\n+\t\t\tif (binaryType != null) {\n+\t\t\t\treturn binaryType;\n+\t\t\t} else {\n+\t\t\t\treturn ClassFileCache.NULL;\n+\t\t\t}\n+\t\t});\n+\t\tif (result instanceof IBinaryType) {\n+\t\t\treturn (IBinaryType) result;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic void clear() {\n+\t\tcache.clear();\n+\t\tresourcesToCompile.clear();\n+\t\tallTopLevelTypes.clear();\n+\t\tallClassMaps.clear();\n+\t}\n+\n+\tpublic void addResourceToCompile(Resource resource) {\n+\t\tresourcesToCompile.add(resource);\n+\t}\n+\n+\tpublic Set<Resource> drainResourcesToCompile() {\n+\t\tHashSet<Resource> result = new HashSet<Resource>(resourcesToCompile);\n+\t\tresourcesToCompile.clear();\n+\t\treturn result;\n+\t}\n+\n+\tpublic boolean popCompileResult(char[] fileName,\n+\t\t\tProcedure2<? super List<String>, ? super Map<String, byte[]>> consumer) {\n+\t\tif (allTopLevelTypes.containsKey(fileName)) {\n+\t\t\tconsumer.apply(allTopLevelTypes.remove(fileName), allClassMaps.remove(fileName));\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tpublic void addCompileResult(char[] fileName, List<String> topLevelTypes, Map<String, byte[]> classMap) {\n+\t\tallTopLevelTypes.put(fileName, topLevelTypes);\n+\t\tallClassMaps.put(fileName, classMap);\n+\t}\n+\n+\tpublic static ClassFileCache findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters()) {\n+\t\t\tif (adapter instanceof ClassFileCache.ClassFileCacheAdapter) {\n+\t\t\t\treturn ((ClassFileCache.ClassFileCacheAdapter) adapter).get();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic static ClassFileCache removeFromEmfObject(Notifier emfObject) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE2MDkxNA=="}, "originalCommit": {"oid": "4d9811c08b7821e6d9501ddf6fad0c5d686cc4cf"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NDU2OTcxOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyNjozNFrOFh94Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyNjozNFrOFh94Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE2MTA5OQ==", "bodyText": "Dead code?", "url": "https://github.com/eclipse/xtext-extras/pull/562#discussion_r371161099", "createdAt": "2020-01-27T10:26:34Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaConfig.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *******************************************************************************/\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+public class JavaConfig {\n+\tpublic static class JavaConfigAdapter extends AdapterImpl {\n+\t\tprivate JavaConfig element;\n+\n+\t\tpublic JavaConfigAdapter(JavaConfig element) {\n+\t\t\tthis.element = element;\n+\t\t}\n+\n+\t\tpublic JavaConfig get() {\n+\t\t\treturn this.element;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAdapterForType(final Object object) {\n+\t\t\treturn object == JavaConfig.class;\n+\t\t}\n+\t}\n+\n+\tprivate JavaVersion javaSourceLevel;\n+\n+\tprivate JavaVersion javaTargetLevel;\n+\n+\tpublic static JavaConfig findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters()) {\n+\t\t\tif (adapter instanceof JavaConfig.JavaConfigAdapter) {\n+\t\t\t\treturn ((JavaConfig.JavaConfigAdapter) adapter).get();\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic static JavaConfig removeFromEmfObject(Notifier emfObject) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9811c08b7821e6d9501ddf6fad0c5d686cc4cf"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NDU3MDEwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyNjo0MVrOFh94RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyNjo0MVrOFh94RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE2MTE1Ng==", "bodyText": "EcoreUtil.getExistingAdapter", "url": "https://github.com/eclipse/xtext-extras/pull/562#discussion_r371161156", "createdAt": "2020-01-27T10:26:41Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaConfig.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *******************************************************************************/\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+public class JavaConfig {\n+\tpublic static class JavaConfigAdapter extends AdapterImpl {\n+\t\tprivate JavaConfig element;\n+\n+\t\tpublic JavaConfigAdapter(JavaConfig element) {\n+\t\t\tthis.element = element;\n+\t\t}\n+\n+\t\tpublic JavaConfig get() {\n+\t\t\treturn this.element;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAdapterForType(final Object object) {\n+\t\t\treturn object == JavaConfig.class;\n+\t\t}\n+\t}\n+\n+\tprivate JavaVersion javaSourceLevel;\n+\n+\tprivate JavaVersion javaTargetLevel;\n+\n+\tpublic static JavaConfig findInEmfObject(Notifier emfObject) {\n+\t\tfor (Adapter adapter : emfObject.eAdapters()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9811c08b7821e6d9501ddf6fad0c5d686cc4cf"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NDU3MTQzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaResourceServiceProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyNzowMlrOFh95BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMDoyNzowMlrOFh95BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE2MTM0OA==", "bodyText": "unnecessary parentheses", "url": "https://github.com/eclipse/xtext-extras/pull/562#discussion_r371161348", "createdAt": "2020-01-27T10:27:02Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaResourceServiceProvider.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ */\n+package org.eclipse.xtext.java.resource;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+\n+import com.google.inject.ConfigurationException;\n+import com.google.inject.Inject;\n+import com.google.inject.Injector;\n+\n+public class JavaResourceServiceProvider implements IResourceServiceProvider {\n+\t@Inject\n+\tprivate Injector injector;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider extensionProvider;\n+\n+\t@Override\n+\tpublic boolean canHandle(final URI uri) {\n+\t\treturn (extensionProvider.getFileExtensions().contains(uri.fileExtension()) && !uri.isArchive());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d9811c08b7821e6d9501ddf6fad0c5d686cc4cf"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NDg4NTcyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMjoxODoxNFrOFiAxwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMjoxODoxNFrOFiAxwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwODY0MA==", "bodyText": "Must be ((JavaConfigAdapter)getExistingAdapter(emfObject, JavaConfig.class)).get()", "url": "https://github.com/eclipse/xtext-extras/pull/562#discussion_r371208640", "createdAt": "2020-01-27T12:18:14Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaConfig.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *******************************************************************************/\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.Notifier;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+public class JavaConfig {\n+\tpublic static class JavaConfigAdapter extends AdapterImpl {\n+\t\tprivate JavaConfig element;\n+\n+\t\tpublic JavaConfigAdapter(JavaConfig element) {\n+\t\t\tthis.element = element;\n+\t\t}\n+\n+\t\tpublic JavaConfig get() {\n+\t\t\treturn this.element;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAdapterForType(final Object object) {\n+\t\t\treturn object == JavaConfig.class;\n+\t\t}\n+\t}\n+\n+\tprivate JavaVersion javaSourceLevel;\n+\n+\tprivate JavaVersion javaTargetLevel;\n+\n+\tpublic static JavaConfig findInEmfObject(Notifier emfObject) {\n+\t\treturn (JavaConfig) EcoreUtil.getExistingAdapter(emfObject, JavaConfig.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff39396ec6e17cc53df82870a5ee9602b1bd4588"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 684, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}