{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyODA0OTgx", "number": 612, "reviewThreads": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzozODozMFrOD_cRPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoyNDoyNlrOD_cuTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUwMDQ1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/adapter/Generator2AdapterSetup.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzozODozMFrOGaG68A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzozODozMFrOGaG68A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyOTU1Mg==", "bodyText": "No need for this", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430029552", "createdAt": "2020-05-25T17:38:30Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/adapter/Generator2AdapterSetup.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.adapter;\n+\n+import org.eclipse.xpand2.XpandExecutionContext;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.generator.Generator;\n+import org.eclipse.xtext.generator.LanguageConfig;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.generator.CodeConfig;\n+import org.eclipse.xtext.xtext.generator.DefaultGeneratorModule;\n+import org.eclipse.xtext.xtext.generator.IXtextGeneratorLanguage;\n+import org.eclipse.xtext.xtext.generator.XtextGeneratorLanguage;\n+import org.eclipse.xtext.xtext.generator.XtextGeneratorNaming;\n+import org.eclipse.xtext.xtext.generator.model.project.StandardProjectConfig;\n+import org.eclipse.xtext.xtext.generator.model.project.XtextProjectConfig;\n+\n+import com.google.common.base.Joiner;\n+import com.google.inject.Binder;\n+import com.google.inject.Guice;\n+import com.google.inject.Injector;\n+\n+/**\n+ * @since 2.9\n+ */\n+@Deprecated\n+public class Generator2AdapterSetup {\n+\tprivate LanguageConfig languageConfig;\n+\n+\tprivate XpandExecutionContext xpandContext;\n+\n+\tprivate Naming naming;\n+\n+\tprivate Injector injector;\n+\n+\tprivate com.google.inject.Module additionalGeneratorBindings = (Binder it) -> {\n+\t};\n+\n+\tprivate com.google.inject.Module additionalLanguageBindings = (Binder it) -> {\n+\t};\n+\n+\tpublic Generator2AdapterSetup(LanguageConfig languageConfig, XpandExecutionContext xpandContext, Naming naming) {\n+\t\tthis.languageConfig = languageConfig;\n+\t\tthis.xpandContext = xpandContext;\n+\t\tthis.naming = naming;\n+\t}\n+\n+\tpublic Injector getInjector() {\n+\t\tif (this.injector == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUxNjI5OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo0ODoyNlrOGaHENA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo0ODoyNlrOGaHENA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMTkyNA==", "bodyText": "s/identifier/identifiers/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430031924", "createdAt": "2020-05-25T17:48:26Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUxNjcxOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo0ODo0NVrOGaHEdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo0ODo0NVrOGaHEdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMTk5MQ==", "bodyText": "s/segments/segment/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430031991", "createdAt": "2020-05-25T17:48:45Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUxNzcwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo0OToyOVrOGaHFEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo0OToyOVrOGaHFEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMjE0NQ==", "bodyText": "Uppercasing every segment's first char would be PascalCase though", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430032145", "createdAt": "2020-05-25T17:49:29Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUxOTE5OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1MDoxMVrOGaHF4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1MDoxMVrOGaHF4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMjM1Mg==", "bodyText": "s/idetifier/identifier/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430032352", "createdAt": "2020-05-25T17:50:11Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUyMDk2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1MToyNVrOGaHHGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1MToyNVrOGaHHGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMjY2NQ==", "bodyText": "s/full qulified/fully qualified/\n{@link GrammarAccess}", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430032665", "createdAt": "2020-05-25T17:51:25Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUyMjIwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1MjoxN1rOGaHHzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1MjoxN1rOGaHHzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMjg0NA==", "bodyText": "s/full/fully/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430032844", "createdAt": "2020-05-25T17:52:17Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUyMjY0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1MjozMlrOGaHICg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1MjozMlrOGaHICg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMjkwNg==", "bodyText": "{@link}", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430032906", "createdAt": "2020-05-25T17:52:32Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUyMzMyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1Mjo1MVrOGaHIcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo0Nzo1OVrOGaIswA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMzAwOA==", "bodyText": "Here as well", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430033008", "createdAt": "2020-05-25T17:52:51Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMzQxOA==", "bodyText": "There's a lot of places in this class which should get a javadoc link", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430033418", "createdAt": "2020-05-25T17:54:32Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMzAwOA=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1ODY4OA==", "bodyText": "wont spent to much optimization for a deprecated class", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430058688", "createdAt": "2020-05-25T19:47:59Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMzAwOA=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUyNzUzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1NToyNlrOGaHLAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1NToyNlrOGaHLAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMzY2Nw==", "bodyText": "s/accesor/accessor/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430033667", "createdAt": "2020-05-25T17:55:26Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUzMDgzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1NzozN1rOGaHM7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo0OTowM1rOGaItkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDE1Ng==", "bodyText": "Is this API? if not, s/Methode/Method/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034156", "createdAt": "2020-05-25T17:57:37Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaElementAccessMethodeName(AbstractElement element) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1ODg5OA==", "bodyText": "assume it is", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430058898", "createdAt": "2020-05-25T19:49:03Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaElementAccessMethodeName(AbstractElement element) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDE1Ng=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUzMTg3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1ODowM1rOGaHNeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo0NTo1NFrOGaIqrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDI5Nw==", "bodyText": "Is this API? if not, s/Identifyer/Identifier/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034297", "createdAt": "2020-05-25T17:58:03Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1ODE1OA==", "bodyText": "i assume it is", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430058158", "createdAt": "2020-05-25T19:45:54Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDI5Nw=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUzMTkzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1ODowN1rOGaHNhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo0NTo0NFrOGaIqlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDMwOQ==", "bodyText": "Is this API? if not, s/Identifyer/Identifier/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034309", "createdAt": "2020-05-25T17:58:07Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1ODEzMg==", "bodyText": "i assume it is", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430058132", "createdAt": "2020-05-25T19:45:44Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDMwOQ=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUzMjgyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1ODozN1rOGaHODw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo0OToxN1rOGaItwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDQ0Nw==", "bodyText": "Is this API? if not, s/Accesor/Accessor/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034447", "createdAt": "2020-05-25T17:58:37Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaElementAccessMethodeName(AbstractElement element) {\n+\t\treturn \"get\" + gaElementIdentifyer(element);\n+\t}\n+\n+\t/**\n+\t * Returns the simple class name of a rule's facade. A GrammarAccess\n+\t * implementation has a facade for each parser rule, which contains the\n+\t * methods for accessing the rule's elements.\n+\t * \n+\t * @param rule ruleName\n+\t * @return the simple class name\n+\t */\n+\tpublic String gaRuleAccesorClassName(AbstractRule rule) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1ODk0Ng==", "bodyText": "i assume it is", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430058946", "createdAt": "2020-05-25T19:49:17Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaElementAccessMethodeName(AbstractElement element) {\n+\t\treturn \"get\" + gaElementIdentifyer(element);\n+\t}\n+\n+\t/**\n+\t * Returns the simple class name of a rule's facade. A GrammarAccess\n+\t * implementation has a facade for each parser rule, which contains the\n+\t * methods for accessing the rule's elements.\n+\t * \n+\t * @param rule ruleName\n+\t * @return the simple class name\n+\t */\n+\tpublic String gaRuleAccesorClassName(AbstractRule rule) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDQ0Nw=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUzMzIyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1ODo1M1rOGaHOVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1ODo1M1rOGaHOVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDUxNg==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034516", "createdAt": "2020-05-25T17:58:53Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaElementAccessMethodeName(AbstractElement element) {\n+\t\treturn \"get\" + gaElementIdentifyer(element);\n+\t}\n+\n+\t/**\n+\t * Returns the simple class name of a rule's facade. A GrammarAccess\n+\t * implementation has a facade for each parser rule, which contains the\n+\t * methods for accessing the rule's elements.\n+\t * \n+\t * @param rule ruleName\n+\t * @return the simple class name\n+\t */\n+\tpublic String gaRuleAccesorClassName(AbstractRule rule) {\n+\t\treturn gaRuleIdentifyer(rule) + \"Elements\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the rule accessor method as Java statement.\n+\t * \n+\t * @param rule the rule\n+\t * @return The java statement\n+\t */\n+\tpublic String gaRuleAccessor(AbstractRule rule) {\n+\t\treturn gaRuleAccessMethodName(rule) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the rule's content accessor method as Java\n+\t * statement.\n+\t * \n+\t * @param rule the rule\n+\t * @return The java statement\n+\t */\n+\tpublic String gaElementsAccessor(AbstractRule rule) {\n+\t\treturn gaRuleElementsMethodName(rule) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as Java statement.\n+\t * The called method is implemented by the rule's facade. Example:\n+\t * ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaElementAccessor(AbstractElement ele) {\n+\t\treturn gaElementAccessMethodeName(ele) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method for a GrammarAccess\n+\t * as Java statement. Example: prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaRuleElementAccessor(AbstractElement ele) {\n+\t\treturn gaElementsAccessor(GrammarUtil.containingRule(ele)) + \".\" + gaElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of an element or rule accessor, including the\n+\t * .getType() call. Example1: getFooRule().getType() Example2:\n+\t * getBarRule().getFooAction().getType()\n+\t */\n+\tpublic String gaTypeAccessor(TypeRef ele) {\n+\t\tEObject cnt = ele.eContainer();\n+\t\tif (cnt instanceof AbstractElement) {\n+\t\t\treturn gaRuleElementAccessor((AbstractElement) cnt) + \".getType()\";\n+\t\t} else if (cnt instanceof AbstractRule) {\n+\t\t\treturn gaRuleAccessor((AbstractRule) cnt) + \".getType()\";\n+\t\t} else {\n+\t\t\treturn (\"<error: unknown type \" + ele.eContainer().eClass().getName()) + \">\";\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of an element or rule accessor. Example1:\n+\t * getFooRule() Example2: getBarRule().getFooAction()\n+\t */\n+\tpublic String gaAccessor(EObject ele) {\n+\t\tif (ele instanceof AbstractElement) {\n+\t\t\treturn gaRuleElementAccessor(((AbstractElement) ele));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUzMzMxOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1ODo1OFrOGaHOYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1ODo1OFrOGaHOYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDUyOA==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034528", "createdAt": "2020-05-25T17:58:58Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaElementAccessMethodeName(AbstractElement element) {\n+\t\treturn \"get\" + gaElementIdentifyer(element);\n+\t}\n+\n+\t/**\n+\t * Returns the simple class name of a rule's facade. A GrammarAccess\n+\t * implementation has a facade for each parser rule, which contains the\n+\t * methods for accessing the rule's elements.\n+\t * \n+\t * @param rule ruleName\n+\t * @return the simple class name\n+\t */\n+\tpublic String gaRuleAccesorClassName(AbstractRule rule) {\n+\t\treturn gaRuleIdentifyer(rule) + \"Elements\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the rule accessor method as Java statement.\n+\t * \n+\t * @param rule the rule\n+\t * @return The java statement\n+\t */\n+\tpublic String gaRuleAccessor(AbstractRule rule) {\n+\t\treturn gaRuleAccessMethodName(rule) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the rule's content accessor method as Java\n+\t * statement.\n+\t * \n+\t * @param rule the rule\n+\t * @return The java statement\n+\t */\n+\tpublic String gaElementsAccessor(AbstractRule rule) {\n+\t\treturn gaRuleElementsMethodName(rule) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as Java statement.\n+\t * The called method is implemented by the rule's facade. Example:\n+\t * ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaElementAccessor(AbstractElement ele) {\n+\t\treturn gaElementAccessMethodeName(ele) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method for a GrammarAccess\n+\t * as Java statement. Example: prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaRuleElementAccessor(AbstractElement ele) {\n+\t\treturn gaElementsAccessor(GrammarUtil.containingRule(ele)) + \".\" + gaElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of an element or rule accessor, including the\n+\t * .getType() call. Example1: getFooRule().getType() Example2:\n+\t * getBarRule().getFooAction().getType()\n+\t */\n+\tpublic String gaTypeAccessor(TypeRef ele) {\n+\t\tEObject cnt = ele.eContainer();\n+\t\tif (cnt instanceof AbstractElement) {\n+\t\t\treturn gaRuleElementAccessor((AbstractElement) cnt) + \".getType()\";\n+\t\t} else if (cnt instanceof AbstractRule) {\n+\t\t\treturn gaRuleAccessor((AbstractRule) cnt) + \".getType()\";\n+\t\t} else {\n+\t\t\treturn (\"<error: unknown type \" + ele.eContainer().eClass().getName()) + \">\";\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of an element or rule accessor. Example1:\n+\t * getFooRule() Example2: getBarRule().getFooAction()\n+\t */\n+\tpublic String gaAccessor(EObject ele) {\n+\t\tif (ele instanceof AbstractElement) {\n+\t\t\treturn gaRuleElementAccessor(((AbstractElement) ele));\n+\t\t} else if (ele instanceof AbstractRule) {\n+\t\t\treturn gaRuleAccessor(((AbstractRule) ele));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUzNDQ3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/parser/antlr/AbstractAntlrXtendGeneratorFragment.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1OTo0MFrOGaHPBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNzo1OTo0MFrOGaHPBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDY5Mw==", "bodyText": "No need for this\nThere's a lot of this in this class", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034693", "createdAt": "2020-05-25T17:59:40Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/parser/antlr/AbstractAntlrXtendGeneratorFragment.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.parser.antlr;\n+\n+import java.util.List;\n+\n+import org.eclipse.xpand2.XpandExecutionContext;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.IGrammarAccess;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.generator.Xtend2ExecutionContext;\n+import org.eclipse.xtext.generator.Xtend2GeneratorFragment;\n+\n+import com.google.inject.Binder;\n+import com.google.inject.Guice;\n+\n+/**\n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.8\n+ */\n+@Deprecated\n+public abstract class AbstractAntlrXtendGeneratorFragment extends AbstractAntlrGeneratorFragment {\n+\tprotected com.google.inject.Module createModule(Grammar grammar) {\n+\t\treturn new com.google.inject.Module() {\n+\t\t\t@Override\n+\t\t\tpublic void configure(Binder binder) {\n+\t\t\t\tbinder.bind(Grammar.class).toInstance(grammar);\n+\t\t\t\tbinder.bind(Naming.class).toInstance(getNaming());\n+\t\t\t\tbinder.bind(IGrammarAccess.class).toInstance(new Xtend2GeneratorFragment.GenericGrammarAccess(grammar));\n+\t\t\t\taddLocalBindings(binder);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addLocalBindings(Binder binder) {\n+\t}\n+\n+\t@Override\n+\tpublic void generate(Grammar grammar, XpandExecutionContext ctx) {\n+\t\tthis.checkGrammar(grammar);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUzNjEzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/serializer/SerializerFragment.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODowMDo0NFrOGaHP_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo1MDo0NFrOGaIvJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDk0Mg==", "bodyText": "Off topic, why is there an @since 2.8 on a private field? For documentation?", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034942", "createdAt": "2020-05-25T18:00:44Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/serializer/SerializerFragment.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.serializer;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xpand2.XpandExecutionContext;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.generator.BindFactory;\n+import org.eclipse.xtext.generator.Binding;\n+import org.eclipse.xtext.generator.IStubGenerating;\n+import org.eclipse.xtext.generator.LanguageConfig;\n+import org.eclipse.xtext.generator.Xtend2ExecutionContext;\n+import org.eclipse.xtext.generator.Xtend2GeneratorFragment;\n+import org.eclipse.xtext.generator.adapter.Generator2AdapterSetup;\n+import org.eclipse.xtext.generator.parser.antlr.ex.wsAware.SyntheticTerminalAwareFragmentHelper;\n+import org.eclipse.xtext.generator.terminals.SyntheticTerminalDetector;\n+import org.eclipse.xtext.parser.antlr.AbstractSplittingTokenSource;\n+import org.eclipse.xtext.serializer.ISerializer;\n+import org.eclipse.xtext.serializer.impl.Serializer;\n+import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;\n+import org.eclipse.xtext.serializer.sequencer.ISyntacticSequencer;\n+import org.eclipse.xtext.xtext.generator.CodeConfig;\n+import org.eclipse.xtext.xtext.generator.serializer.SerializerFragment2;\n+\n+import com.google.common.collect.Lists;\n+import com.google.inject.Binder;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Names;\n+\n+/**\n+ * @author Moritz Eyshold - Initial contribution and API\n+ */\n+@Deprecated\n+public class SerializerFragment extends Xtend2GeneratorFragment\n+\t\timplements IStubGenerating, IStubGenerating.XtendOption {\n+\t@Inject\n+\tprivate SerializerGenFileNames names;\n+\n+\tprivate boolean generateDebugData = false;\n+\n+\tprivate boolean srcGenOnly = false;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tprivate boolean detectSyntheticTerminals = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTI1Ng==", "bodyText": "no idea", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430059256", "createdAt": "2020-05-25T19:50:34Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/serializer/SerializerFragment.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.serializer;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xpand2.XpandExecutionContext;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.generator.BindFactory;\n+import org.eclipse.xtext.generator.Binding;\n+import org.eclipse.xtext.generator.IStubGenerating;\n+import org.eclipse.xtext.generator.LanguageConfig;\n+import org.eclipse.xtext.generator.Xtend2ExecutionContext;\n+import org.eclipse.xtext.generator.Xtend2GeneratorFragment;\n+import org.eclipse.xtext.generator.adapter.Generator2AdapterSetup;\n+import org.eclipse.xtext.generator.parser.antlr.ex.wsAware.SyntheticTerminalAwareFragmentHelper;\n+import org.eclipse.xtext.generator.terminals.SyntheticTerminalDetector;\n+import org.eclipse.xtext.parser.antlr.AbstractSplittingTokenSource;\n+import org.eclipse.xtext.serializer.ISerializer;\n+import org.eclipse.xtext.serializer.impl.Serializer;\n+import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;\n+import org.eclipse.xtext.serializer.sequencer.ISyntacticSequencer;\n+import org.eclipse.xtext.xtext.generator.CodeConfig;\n+import org.eclipse.xtext.xtext.generator.serializer.SerializerFragment2;\n+\n+import com.google.common.collect.Lists;\n+import com.google.inject.Binder;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Names;\n+\n+/**\n+ * @author Moritz Eyshold - Initial contribution and API\n+ */\n+@Deprecated\n+public class SerializerFragment extends Xtend2GeneratorFragment\n+\t\timplements IStubGenerating, IStubGenerating.XtendOption {\n+\t@Inject\n+\tprivate SerializerGenFileNames names;\n+\n+\tprivate boolean generateDebugData = false;\n+\n+\tprivate boolean srcGenOnly = false;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tprivate boolean detectSyntheticTerminals = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDk0Mg=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTMwMQ==", "bodyText": "assume so", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430059301", "createdAt": "2020-05-25T19:50:44Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/serializer/SerializerFragment.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.serializer;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xpand2.XpandExecutionContext;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.generator.BindFactory;\n+import org.eclipse.xtext.generator.Binding;\n+import org.eclipse.xtext.generator.IStubGenerating;\n+import org.eclipse.xtext.generator.LanguageConfig;\n+import org.eclipse.xtext.generator.Xtend2ExecutionContext;\n+import org.eclipse.xtext.generator.Xtend2GeneratorFragment;\n+import org.eclipse.xtext.generator.adapter.Generator2AdapterSetup;\n+import org.eclipse.xtext.generator.parser.antlr.ex.wsAware.SyntheticTerminalAwareFragmentHelper;\n+import org.eclipse.xtext.generator.terminals.SyntheticTerminalDetector;\n+import org.eclipse.xtext.parser.antlr.AbstractSplittingTokenSource;\n+import org.eclipse.xtext.serializer.ISerializer;\n+import org.eclipse.xtext.serializer.impl.Serializer;\n+import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;\n+import org.eclipse.xtext.serializer.sequencer.ISyntacticSequencer;\n+import org.eclipse.xtext.xtext.generator.CodeConfig;\n+import org.eclipse.xtext.xtext.generator.serializer.SerializerFragment2;\n+\n+import com.google.common.collect.Lists;\n+import com.google.inject.Binder;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Names;\n+\n+/**\n+ * @author Moritz Eyshold - Initial contribution and API\n+ */\n+@Deprecated\n+public class SerializerFragment extends Xtend2GeneratorFragment\n+\t\timplements IStubGenerating, IStubGenerating.XtendOption {\n+\t@Inject\n+\tprivate SerializerGenFileNames names;\n+\n+\tprivate boolean generateDebugData = false;\n+\n+\tprivate boolean srcGenOnly = false;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tprivate boolean detectSyntheticTerminals = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDk0Mg=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODUzOTc3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/contentAssist/ContentAssistFragmentExtensions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODowMzoxMVrOGaHSJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODowMzoxMVrOGaHSJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNTQ5Mg==", "bodyText": "{@plainlink}", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430035492", "createdAt": "2020-05-25T18:03:11Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/contentAssist/ContentAssistFragmentExtensions.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ui.generator.contentAssist;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.StringExtensions;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * Created for https://bugs.eclipse.org/bugs/show_bug.cgi?id=471434", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU0NTYzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/contentAssist/ContentAssistFragmentExtensions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODowNTozMVrOGaHVoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo1Mzo1NFrOGaIxnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNjM4NQ==", "bodyText": "Using xbase utils here", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430036385", "createdAt": "2020-05-25T18:05:31Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/contentAssist/ContentAssistFragmentExtensions.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ui.generator.contentAssist;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.StringExtensions;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * Created for https://bugs.eclipse.org/bugs/show_bug.cgi?id=471434\n+ * \n+ * @author Lorenzo Bettini - Initial contribution and API\n+ * @since 2.8\n+ * @noreference This class is not intended to be referenced by clients.\n+ */\n+public class ContentAssistFragmentExtensions {\n+\tpublic static String getFqFeatureName(Assignment it) {\n+\t\treturn StringExtensions.toFirstUpper(GrammarUtil.containingParserRule(it).getName()) + \"_\"\n+\t\t\t\t+ StringExtensions.toFirstUpper(it.getFeature());\n+\t}\n+\n+\tpublic static String getFqFeatureName(AbstractRule it) {\n+\t\treturn \"_\" + it.getName();\n+\t}\n+\n+\tpublic static Grammar getSuperGrammar(Grammar grammar) {\n+\t\treturn Iterables.getFirst(grammar.getUsedGrammars(), null);\n+\t}\n+\n+\tpublic static Set<String> getFqFeatureNamesToExclude(Grammar grammar) {\n+\t\tSet<String> toExclude = new HashSet<>();\n+\t\tGrammar superGrammar = ContentAssistFragmentExtensions.getSuperGrammar(grammar);\n+\t\tif (superGrammar != null) {\n+\t\t\tSet<String> superGrammarsFqFeatureNames = ContentAssistFragmentExtensions\n+\t\t\t\t\t.computeFqFeatureNamesFromSuperGrammars(grammar);\n+\t\t\tSet<String> thisGrammarFqFeatureNames = IterableExtensions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTkzNQ==", "bodyText": "yes. dont know better alternative", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430059935", "createdAt": "2020-05-25T19:53:54Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/contentAssist/ContentAssistFragmentExtensions.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ui.generator.contentAssist;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.StringExtensions;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * Created for https://bugs.eclipse.org/bugs/show_bug.cgi?id=471434\n+ * \n+ * @author Lorenzo Bettini - Initial contribution and API\n+ * @since 2.8\n+ * @noreference This class is not intended to be referenced by clients.\n+ */\n+public class ContentAssistFragmentExtensions {\n+\tpublic static String getFqFeatureName(Assignment it) {\n+\t\treturn StringExtensions.toFirstUpper(GrammarUtil.containingParserRule(it).getName()) + \"_\"\n+\t\t\t\t+ StringExtensions.toFirstUpper(it.getFeature());\n+\t}\n+\n+\tpublic static String getFqFeatureName(AbstractRule it) {\n+\t\treturn \"_\" + it.getName();\n+\t}\n+\n+\tpublic static Grammar getSuperGrammar(Grammar grammar) {\n+\t\treturn Iterables.getFirst(grammar.getUsedGrammars(), null);\n+\t}\n+\n+\tpublic static Set<String> getFqFeatureNamesToExclude(Grammar grammar) {\n+\t\tSet<String> toExclude = new HashSet<>();\n+\t\tGrammar superGrammar = ContentAssistFragmentExtensions.getSuperGrammar(grammar);\n+\t\tif (superGrammar != null) {\n+\t\t\tSet<String> superGrammarsFqFeatureNames = ContentAssistFragmentExtensions\n+\t\t\t\t\t.computeFqFeatureNamesFromSuperGrammars(grammar);\n+\t\t\tSet<String> thisGrammarFqFeatureNames = IterableExtensions", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNjM4NQ=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU1MDQ3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/ClasspathBasedIdeTypesProposalProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODowODo1MlrOGaHYZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODowODo1MlrOGaHYZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNzA5NQ==", "bodyText": "No need for parentheses", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430037095", "createdAt": "2020-05-25T18:08:52Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/ClasspathBasedIdeTypesProposalProvider.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.Collections;\n+\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.common.types.descriptions.ClasspathScanner;\n+import org.eclipse.xtext.common.types.descriptions.ITypeDescriptor;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IIdeContentProposalAcceptor;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeContentProposalCreator;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeContentProposalPriorities;\n+import org.eclipse.xtext.naming.IQualifiedNameConverter;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.ReplaceRegion;\n+import org.eclipse.xtext.xbase.imports.IImportsConfiguration;\n+import org.eclipse.xtext.xbase.imports.ImportSectionRegionUtil;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xtype.XImportDeclaration;\n+import org.eclipse.xtext.xtype.XImportSection;\n+import org.eclipse.xtext.xtype.XtypePackage;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class ClasspathBasedIdeTypesProposalProvider implements IIdeTypesProposalProvider {\n+\t@Inject\n+\tprivate ClassLoader classLoader;\n+\n+\t@Inject\n+\tprivate ClasspathScanner classpathScanner;\n+\n+\t@Inject\n+\tprivate IdeContentProposalCreator proposalCreator;\n+\n+\t@Inject\n+\tprivate IdeContentProposalPriorities proposalPriorities;\n+\n+\t@Inject\n+\tprivate IQualifiedNameConverter qualifiedNameConverter;\n+\n+\t@Inject\n+\tprivate IImportsConfiguration importsConfiguration;\n+\n+\t@Inject\n+\tprivate ImportSectionRegionUtil importSectionRegionUtil;\n+\n+\t@Override\n+\tpublic void createTypeProposals(EReference reference, ContentAssistContext context,\n+\t\t\tPredicate<? super ITypeDescriptor> filter, IIdeContentProposalAcceptor acceptor) {\n+\t\tITextRegion importSectionRegion = null;\n+\t\tXImportSection importSection = null;\n+\t\tif (!isImportDeclaration(reference, context)) {\n+\t\t\timportSection = importsConfiguration.getImportSection(context.getResource());\n+\t\t\timportSectionRegion = importSectionRegionUtil.computeRegion(context.getResource());\n+\t\t}\n+\t\tfor (ITypeDescriptor typeDesc : getTypeDescriptors(context)) {\n+\t\t\tif (!acceptor.canAcceptMoreProposals()) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (canPropose(typeDesc, context, filter)) {\n+\t\t\t\tContentAssistEntry entry = createProposal(reference, typeDesc, context, importSection,\n+\t\t\t\t\t\timportSectionRegion);\n+\t\t\t\tint priority = ((XbaseIdeContentProposalPriorities) proposalPriorities).getTypeRefPriority(typeDesc,\n+\t\t\t\t\t\tentry);\n+\t\t\t\tacceptor.accept(entry, priority);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected Iterable<ITypeDescriptor> getTypeDescriptors(ContentAssistContext context) {\n+\t\tIterable<ITypeDescriptor> bootClasspath = classpathScanner\n+\t\t\t\t.getBootClasspathDescriptors(Lists.newArrayList(\"java\"));\n+\t\tIterable<ITypeDescriptor> appClasspath = classpathScanner.getDescriptors(getClassLoader(context),\n+\t\t\t\tCollections.emptyList());\n+\t\treturn Iterables.concat(bootClasspath, appClasspath);\n+\t}\n+\n+\tprotected ClassLoader getClassLoader(ContentAssistContext context) {\n+\t\tResourceSet resourceSet = context.getResource().getResourceSet();\n+\t\tif (resourceSet instanceof XtextResourceSet) {\n+\t\t\tObject ctx = ((XtextResourceSet) resourceSet).getClasspathURIContext();\n+\t\t\tif (ctx != null) {\n+\t\t\t\tif (ctx instanceof Class<?>) {\n+\t\t\t\t\treturn ((Class<?>) ctx).getClassLoader();\n+\t\t\t\t}\n+\t\t\t\tif (ctx instanceof ClassLoader) {\n+\t\t\t\t\treturn ((ClassLoader) ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU1MzM5OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/ClasspathBasedIdeTypesProposalProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxMDo0NlrOGaHaPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxMDo0NlrOGaHaPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNzU2NA==", "bodyText": "s/9/\"java.lang\".length/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430037564", "createdAt": "2020-05-25T18:10:46Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/ClasspathBasedIdeTypesProposalProvider.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.Collections;\n+\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.common.types.descriptions.ClasspathScanner;\n+import org.eclipse.xtext.common.types.descriptions.ITypeDescriptor;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IIdeContentProposalAcceptor;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeContentProposalCreator;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeContentProposalPriorities;\n+import org.eclipse.xtext.naming.IQualifiedNameConverter;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.ReplaceRegion;\n+import org.eclipse.xtext.xbase.imports.IImportsConfiguration;\n+import org.eclipse.xtext.xbase.imports.ImportSectionRegionUtil;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xtype.XImportDeclaration;\n+import org.eclipse.xtext.xtype.XImportSection;\n+import org.eclipse.xtext.xtype.XtypePackage;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class ClasspathBasedIdeTypesProposalProvider implements IIdeTypesProposalProvider {\n+\t@Inject\n+\tprivate ClassLoader classLoader;\n+\n+\t@Inject\n+\tprivate ClasspathScanner classpathScanner;\n+\n+\t@Inject\n+\tprivate IdeContentProposalCreator proposalCreator;\n+\n+\t@Inject\n+\tprivate IdeContentProposalPriorities proposalPriorities;\n+\n+\t@Inject\n+\tprivate IQualifiedNameConverter qualifiedNameConverter;\n+\n+\t@Inject\n+\tprivate IImportsConfiguration importsConfiguration;\n+\n+\t@Inject\n+\tprivate ImportSectionRegionUtil importSectionRegionUtil;\n+\n+\t@Override\n+\tpublic void createTypeProposals(EReference reference, ContentAssistContext context,\n+\t\t\tPredicate<? super ITypeDescriptor> filter, IIdeContentProposalAcceptor acceptor) {\n+\t\tITextRegion importSectionRegion = null;\n+\t\tXImportSection importSection = null;\n+\t\tif (!isImportDeclaration(reference, context)) {\n+\t\t\timportSection = importsConfiguration.getImportSection(context.getResource());\n+\t\t\timportSectionRegion = importSectionRegionUtil.computeRegion(context.getResource());\n+\t\t}\n+\t\tfor (ITypeDescriptor typeDesc : getTypeDescriptors(context)) {\n+\t\t\tif (!acceptor.canAcceptMoreProposals()) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (canPropose(typeDesc, context, filter)) {\n+\t\t\t\tContentAssistEntry entry = createProposal(reference, typeDesc, context, importSection,\n+\t\t\t\t\t\timportSectionRegion);\n+\t\t\t\tint priority = ((XbaseIdeContentProposalPriorities) proposalPriorities).getTypeRefPriority(typeDesc,\n+\t\t\t\t\t\tentry);\n+\t\t\t\tacceptor.accept(entry, priority);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected Iterable<ITypeDescriptor> getTypeDescriptors(ContentAssistContext context) {\n+\t\tIterable<ITypeDescriptor> bootClasspath = classpathScanner\n+\t\t\t\t.getBootClasspathDescriptors(Lists.newArrayList(\"java\"));\n+\t\tIterable<ITypeDescriptor> appClasspath = classpathScanner.getDescriptors(getClassLoader(context),\n+\t\t\t\tCollections.emptyList());\n+\t\treturn Iterables.concat(bootClasspath, appClasspath);\n+\t}\n+\n+\tprotected ClassLoader getClassLoader(ContentAssistContext context) {\n+\t\tResourceSet resourceSet = context.getResource().getResourceSet();\n+\t\tif (resourceSet instanceof XtextResourceSet) {\n+\t\t\tObject ctx = ((XtextResourceSet) resourceSet).getClasspathURIContext();\n+\t\t\tif (ctx != null) {\n+\t\t\t\tif (ctx instanceof Class<?>) {\n+\t\t\t\t\treturn ((Class<?>) ctx).getClassLoader();\n+\t\t\t\t}\n+\t\t\t\tif (ctx instanceof ClassLoader) {\n+\t\t\t\t\treturn ((ClassLoader) ctx);\n+\t\t\t\t}\n+\t\t\t\treturn ctx.getClass().getClassLoader();\n+\t\t\t}\n+\t\t}\n+\t\treturn classLoader;\n+\t}\n+\n+\tprotected boolean canPropose(ITypeDescriptor typeDesc, ContentAssistContext context,\n+\t\t\tPredicate<? super ITypeDescriptor> filter) {\n+\t\treturn isVisible(typeDesc, context) && filter.apply(typeDesc);\n+\t}\n+\n+\tprotected boolean isVisible(ITypeDescriptor typeDesc, ContentAssistContext context) {\n+\t\treturn Modifier.isPublic(typeDesc.getModifiers());\n+\t}\n+\n+\tprotected ContentAssistEntry createProposal(EReference reference, ITypeDescriptor typeDesc,\n+\t\t\tContentAssistContext context, XImportSection importSection, ITextRegion importSectionRegion) {\n+\t\tboolean importDecl = isImportDeclaration(reference, context);\n+\t\tString qualifiedName = qualifiedNameConverter.toString(typeDesc.getQualifiedName());\n+\t\tString proposal;\n+\t\tif (importDecl) {\n+\t\t\tproposal = qualifiedName;\n+\t\t} else {\n+\t\t\tproposal = typeDesc.getSimpleName();\n+\t\t}\n+\t\treturn proposalCreator.createProposal(proposal, context, (ContentAssistEntry it) -> {\n+\t\t\tit.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\tif (importDecl) {\n+\t\t\t\tit.setLabel(typeDesc.getSimpleName());\n+\t\t\t\tit.setDescription(proposal);\n+\t\t\t} else {\n+\t\t\t\tit.setDescription(qualifiedName);\n+\t\t\t\tif (importSectionRegion != null\n+\t\t\t\t\t\t&& isImportDeclarationRequired(typeDesc, qualifiedName, context, importSection)) {\n+\t\t\t\t\taddImportDeclaration(it, importSectionRegion, typeDesc, qualifiedName, context);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprotected boolean isImportDeclaration(EReference reference, ContentAssistContext context) {\n+\t\treturn XtypePackage.Literals.XIMPORT_DECLARATION__IMPORTED_TYPE.equals(reference);\n+\t}\n+\n+\tprotected boolean isImportDeclarationRequired(ITypeDescriptor typeDesc, String qualifiedName,\n+\t\t\tContentAssistContext context, XImportSection importSection) {\n+\t\treturn !(typeDesc.getName().startsWith(\"java.lang\") && typeDesc.getName().lastIndexOf('.') == 9)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU1NTU1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxMjowMlrOGaHbdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo1NjoyMFrOGaIzvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNzg3Nw==", "bodyText": ".equals?", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430037877", "createdAt": "2020-05-25T18:12:02Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.util.ContextualVisibilityHelper;\n+import org.eclipse.xtext.xbase.typesystem.util.IVisibilityHelper;\n+\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+\n+public class OverrideProposalUtil {\n+\t@Inject\n+\tprivate IGeneratorConfigProvider generatorConfigProvider;\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IVisibilityHelper visibilityHelper;\n+\n+\tpublic List<IResolvedExecutable> getImplementationCandidates(JvmDeclaredType type, boolean isAnonymous) {\n+\t\tif (type == null || !(type instanceof JvmGenericType)) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tJavaVersion sourceVersion = generatorConfigProvider.get(type).getJavaSourceVersion();\n+\t\tResolvedFeatures resolvedFeatures = overrideHelper.getResolvedFeatures(type, sourceVersion);\n+\t\tList<IResolvedExecutable> result = new ArrayList<>();\n+\t\tContextualVisibilityHelper contextualVisibilityHelper = new ContextualVisibilityHelper(visibilityHelper,\n+\t\t\t\tresolvedFeatures.getType());\n+\t\taddOperationCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\tif (!isAnonymous && !((JvmGenericType) type).isInterface()) {\n+\t\t\taddConstructorCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected void addOperationCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tList<IResolvedOperation> allOperations = resolvedFeatures.getAllOperations();\n+\t\tLightweightTypeReference inferredType = resolvedFeatures.getType();\n+\t\tfor (IResolvedOperation operation : allOperations) {\n+\t\t\tif (isCandidate(inferredType, operation, visibilityHelper)) {\n+\t\t\t\tresult.add(operation);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void addConstructorCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tLightweightTypeReference typeReference = resolvedFeatures.getType();\n+\t\tList<LightweightTypeReference> superTypes = typeReference.getSuperTypes();\n+\t\tfor (LightweightTypeReference superType : superTypes) {\n+\t\t\tif (!superType.isInterfaceType()) {\n+\t\t\t\tList<IResolvedConstructor> declaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t\t\tSet<String> erasedSignatures = Sets.<String>newHashSet();\n+\t\t\t\tfor (IResolvedConstructor constructor : declaredConstructors) {\n+\t\t\t\t\terasedSignatures.add(constructor.getResolvedErasureSignature());\n+\t\t\t\t}\n+\t\t\t\tResolvedFeatures superClass = overrideHelper.getResolvedFeatures(superType);\n+\t\t\t\tfor (IResolvedConstructor superclassConstructor : superClass.getDeclaredConstructors()) {\n+\t\t\t\t\tIResolvedConstructor overriddenConstructor = new ResolvedConstructor(\n+\t\t\t\t\t\t\tsuperclassConstructor.getDeclaration(), typeReference);\n+\t\t\t\t\tif (isCandidate(typeReference, overriddenConstructor, visibilityHelper)) {\n+\t\t\t\t\t\tif (erasedSignatures.add(superclassConstructor.getResolvedErasureSignature())) {\n+\t\t\t\t\t\t\tresult.add(overriddenConstructor);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean isCandidate(LightweightTypeReference type, IResolvedExecutable executable,\n+\t\t\tIVisibilityHelper visibilityHelper) {\n+\t\tJvmDeclaredType declaringType = executable.getDeclaration().getDeclaringType();\n+\t\tif (type.getType() != declaringType && isVisible(executable, visibilityHelper)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2MDQ3Nw==", "bodyText": "was like this before", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430060477", "createdAt": "2020-05-25T19:56:20Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.util.ContextualVisibilityHelper;\n+import org.eclipse.xtext.xbase.typesystem.util.IVisibilityHelper;\n+\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+\n+public class OverrideProposalUtil {\n+\t@Inject\n+\tprivate IGeneratorConfigProvider generatorConfigProvider;\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IVisibilityHelper visibilityHelper;\n+\n+\tpublic List<IResolvedExecutable> getImplementationCandidates(JvmDeclaredType type, boolean isAnonymous) {\n+\t\tif (type == null || !(type instanceof JvmGenericType)) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tJavaVersion sourceVersion = generatorConfigProvider.get(type).getJavaSourceVersion();\n+\t\tResolvedFeatures resolvedFeatures = overrideHelper.getResolvedFeatures(type, sourceVersion);\n+\t\tList<IResolvedExecutable> result = new ArrayList<>();\n+\t\tContextualVisibilityHelper contextualVisibilityHelper = new ContextualVisibilityHelper(visibilityHelper,\n+\t\t\t\tresolvedFeatures.getType());\n+\t\taddOperationCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\tif (!isAnonymous && !((JvmGenericType) type).isInterface()) {\n+\t\t\taddConstructorCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected void addOperationCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tList<IResolvedOperation> allOperations = resolvedFeatures.getAllOperations();\n+\t\tLightweightTypeReference inferredType = resolvedFeatures.getType();\n+\t\tfor (IResolvedOperation operation : allOperations) {\n+\t\t\tif (isCandidate(inferredType, operation, visibilityHelper)) {\n+\t\t\t\tresult.add(operation);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void addConstructorCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tLightweightTypeReference typeReference = resolvedFeatures.getType();\n+\t\tList<LightweightTypeReference> superTypes = typeReference.getSuperTypes();\n+\t\tfor (LightweightTypeReference superType : superTypes) {\n+\t\t\tif (!superType.isInterfaceType()) {\n+\t\t\t\tList<IResolvedConstructor> declaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t\t\tSet<String> erasedSignatures = Sets.<String>newHashSet();\n+\t\t\t\tfor (IResolvedConstructor constructor : declaredConstructors) {\n+\t\t\t\t\terasedSignatures.add(constructor.getResolvedErasureSignature());\n+\t\t\t\t}\n+\t\t\t\tResolvedFeatures superClass = overrideHelper.getResolvedFeatures(superType);\n+\t\t\t\tfor (IResolvedConstructor superclassConstructor : superClass.getDeclaredConstructors()) {\n+\t\t\t\t\tIResolvedConstructor overriddenConstructor = new ResolvedConstructor(\n+\t\t\t\t\t\t\tsuperclassConstructor.getDeclaration(), typeReference);\n+\t\t\t\t\tif (isCandidate(typeReference, overriddenConstructor, visibilityHelper)) {\n+\t\t\t\t\t\tif (erasedSignatures.add(superclassConstructor.getResolvedErasureSignature())) {\n+\t\t\t\t\t\t\tresult.add(overriddenConstructor);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean isCandidate(LightweightTypeReference type, IResolvedExecutable executable,\n+\t\t\tIVisibilityHelper visibilityHelper) {\n+\t\tJvmDeclaredType declaringType = executable.getDeclaration().getDeclaringType();\n+\t\tif (type.getType() != declaringType && isVisible(executable, visibilityHelper)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNzg3Nw=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU1Njk0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxMjo0OVrOGaHcSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxMjo0OVrOGaHcSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzODA5MA==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430038090", "createdAt": "2020-05-25T18:12:49Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.util.ContextualVisibilityHelper;\n+import org.eclipse.xtext.xbase.typesystem.util.IVisibilityHelper;\n+\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+\n+public class OverrideProposalUtil {\n+\t@Inject\n+\tprivate IGeneratorConfigProvider generatorConfigProvider;\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IVisibilityHelper visibilityHelper;\n+\n+\tpublic List<IResolvedExecutable> getImplementationCandidates(JvmDeclaredType type, boolean isAnonymous) {\n+\t\tif (type == null || !(type instanceof JvmGenericType)) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tJavaVersion sourceVersion = generatorConfigProvider.get(type).getJavaSourceVersion();\n+\t\tResolvedFeatures resolvedFeatures = overrideHelper.getResolvedFeatures(type, sourceVersion);\n+\t\tList<IResolvedExecutable> result = new ArrayList<>();\n+\t\tContextualVisibilityHelper contextualVisibilityHelper = new ContextualVisibilityHelper(visibilityHelper,\n+\t\t\t\tresolvedFeatures.getType());\n+\t\taddOperationCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\tif (!isAnonymous && !((JvmGenericType) type).isInterface()) {\n+\t\t\taddConstructorCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected void addOperationCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tList<IResolvedOperation> allOperations = resolvedFeatures.getAllOperations();\n+\t\tLightweightTypeReference inferredType = resolvedFeatures.getType();\n+\t\tfor (IResolvedOperation operation : allOperations) {\n+\t\t\tif (isCandidate(inferredType, operation, visibilityHelper)) {\n+\t\t\t\tresult.add(operation);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void addConstructorCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tLightweightTypeReference typeReference = resolvedFeatures.getType();\n+\t\tList<LightweightTypeReference> superTypes = typeReference.getSuperTypes();\n+\t\tfor (LightweightTypeReference superType : superTypes) {\n+\t\t\tif (!superType.isInterfaceType()) {\n+\t\t\t\tList<IResolvedConstructor> declaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t\t\tSet<String> erasedSignatures = Sets.<String>newHashSet();\n+\t\t\t\tfor (IResolvedConstructor constructor : declaredConstructors) {\n+\t\t\t\t\terasedSignatures.add(constructor.getResolvedErasureSignature());\n+\t\t\t\t}\n+\t\t\t\tResolvedFeatures superClass = overrideHelper.getResolvedFeatures(superType);\n+\t\t\t\tfor (IResolvedConstructor superclassConstructor : superClass.getDeclaredConstructors()) {\n+\t\t\t\t\tIResolvedConstructor overriddenConstructor = new ResolvedConstructor(\n+\t\t\t\t\t\t\tsuperclassConstructor.getDeclaration(), typeReference);\n+\t\t\t\t\tif (isCandidate(typeReference, overriddenConstructor, visibilityHelper)) {\n+\t\t\t\t\t\tif (erasedSignatures.add(superclassConstructor.getResolvedErasureSignature())) {\n+\t\t\t\t\t\t\tresult.add(overriddenConstructor);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean isCandidate(LightweightTypeReference type, IResolvedExecutable executable,\n+\t\t\tIVisibilityHelper visibilityHelper) {\n+\t\tJvmDeclaredType declaringType = executable.getDeclaration().getDeclaringType();\n+\t\tif (type.getType() != declaringType && isVisible(executable, visibilityHelper)) {\n+\t\t\tJvmExecutable rawExecutable = executable.getDeclaration();\n+\t\t\tif (rawExecutable instanceof JvmOperation) {\n+\t\t\t\tJvmOperation operation = ((JvmOperation) rawExecutable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU1NzQ0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxMzowOFrOGaHclA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo1NzoxNVrOGaI0bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzODE2NA==", "bodyText": "More parentheses", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430038164", "createdAt": "2020-05-25T18:13:08Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.util.ContextualVisibilityHelper;\n+import org.eclipse.xtext.xbase.typesystem.util.IVisibilityHelper;\n+\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+\n+public class OverrideProposalUtil {\n+\t@Inject\n+\tprivate IGeneratorConfigProvider generatorConfigProvider;\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IVisibilityHelper visibilityHelper;\n+\n+\tpublic List<IResolvedExecutable> getImplementationCandidates(JvmDeclaredType type, boolean isAnonymous) {\n+\t\tif (type == null || !(type instanceof JvmGenericType)) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tJavaVersion sourceVersion = generatorConfigProvider.get(type).getJavaSourceVersion();\n+\t\tResolvedFeatures resolvedFeatures = overrideHelper.getResolvedFeatures(type, sourceVersion);\n+\t\tList<IResolvedExecutable> result = new ArrayList<>();\n+\t\tContextualVisibilityHelper contextualVisibilityHelper = new ContextualVisibilityHelper(visibilityHelper,\n+\t\t\t\tresolvedFeatures.getType());\n+\t\taddOperationCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\tif (!isAnonymous && !((JvmGenericType) type).isInterface()) {\n+\t\t\taddConstructorCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected void addOperationCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tList<IResolvedOperation> allOperations = resolvedFeatures.getAllOperations();\n+\t\tLightweightTypeReference inferredType = resolvedFeatures.getType();\n+\t\tfor (IResolvedOperation operation : allOperations) {\n+\t\t\tif (isCandidate(inferredType, operation, visibilityHelper)) {\n+\t\t\t\tresult.add(operation);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void addConstructorCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tLightweightTypeReference typeReference = resolvedFeatures.getType();\n+\t\tList<LightweightTypeReference> superTypes = typeReference.getSuperTypes();\n+\t\tfor (LightweightTypeReference superType : superTypes) {\n+\t\t\tif (!superType.isInterfaceType()) {\n+\t\t\t\tList<IResolvedConstructor> declaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t\t\tSet<String> erasedSignatures = Sets.<String>newHashSet();\n+\t\t\t\tfor (IResolvedConstructor constructor : declaredConstructors) {\n+\t\t\t\t\terasedSignatures.add(constructor.getResolvedErasureSignature());\n+\t\t\t\t}\n+\t\t\t\tResolvedFeatures superClass = overrideHelper.getResolvedFeatures(superType);\n+\t\t\t\tfor (IResolvedConstructor superclassConstructor : superClass.getDeclaredConstructors()) {\n+\t\t\t\t\tIResolvedConstructor overriddenConstructor = new ResolvedConstructor(\n+\t\t\t\t\t\t\tsuperclassConstructor.getDeclaration(), typeReference);\n+\t\t\t\t\tif (isCandidate(typeReference, overriddenConstructor, visibilityHelper)) {\n+\t\t\t\t\t\tif (erasedSignatures.add(superclassConstructor.getResolvedErasureSignature())) {\n+\t\t\t\t\t\t\tresult.add(overriddenConstructor);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean isCandidate(LightweightTypeReference type, IResolvedExecutable executable,\n+\t\t\tIVisibilityHelper visibilityHelper) {\n+\t\tJvmDeclaredType declaringType = executable.getDeclaration().getDeclaringType();\n+\t\tif (type.getType() != declaringType && isVisible(executable, visibilityHelper)) {\n+\t\t\tJvmExecutable rawExecutable = executable.getDeclaration();\n+\t\t\tif (rawExecutable instanceof JvmOperation) {\n+\t\t\t\tJvmOperation operation = ((JvmOperation) rawExecutable);\n+\t\t\t\tif (operation.isFinal() || operation.isStatic()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (type.getType() instanceof JvmGenericType && ((JvmGenericType) type.getType()).isInterface()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2MDY1NA==", "bodyText": "?", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430060654", "createdAt": "2020-05-25T19:57:15Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.util.ContextualVisibilityHelper;\n+import org.eclipse.xtext.xbase.typesystem.util.IVisibilityHelper;\n+\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+\n+public class OverrideProposalUtil {\n+\t@Inject\n+\tprivate IGeneratorConfigProvider generatorConfigProvider;\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IVisibilityHelper visibilityHelper;\n+\n+\tpublic List<IResolvedExecutable> getImplementationCandidates(JvmDeclaredType type, boolean isAnonymous) {\n+\t\tif (type == null || !(type instanceof JvmGenericType)) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tJavaVersion sourceVersion = generatorConfigProvider.get(type).getJavaSourceVersion();\n+\t\tResolvedFeatures resolvedFeatures = overrideHelper.getResolvedFeatures(type, sourceVersion);\n+\t\tList<IResolvedExecutable> result = new ArrayList<>();\n+\t\tContextualVisibilityHelper contextualVisibilityHelper = new ContextualVisibilityHelper(visibilityHelper,\n+\t\t\t\tresolvedFeatures.getType());\n+\t\taddOperationCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\tif (!isAnonymous && !((JvmGenericType) type).isInterface()) {\n+\t\t\taddConstructorCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected void addOperationCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tList<IResolvedOperation> allOperations = resolvedFeatures.getAllOperations();\n+\t\tLightweightTypeReference inferredType = resolvedFeatures.getType();\n+\t\tfor (IResolvedOperation operation : allOperations) {\n+\t\t\tif (isCandidate(inferredType, operation, visibilityHelper)) {\n+\t\t\t\tresult.add(operation);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void addConstructorCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tLightweightTypeReference typeReference = resolvedFeatures.getType();\n+\t\tList<LightweightTypeReference> superTypes = typeReference.getSuperTypes();\n+\t\tfor (LightweightTypeReference superType : superTypes) {\n+\t\t\tif (!superType.isInterfaceType()) {\n+\t\t\t\tList<IResolvedConstructor> declaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t\t\tSet<String> erasedSignatures = Sets.<String>newHashSet();\n+\t\t\t\tfor (IResolvedConstructor constructor : declaredConstructors) {\n+\t\t\t\t\terasedSignatures.add(constructor.getResolvedErasureSignature());\n+\t\t\t\t}\n+\t\t\t\tResolvedFeatures superClass = overrideHelper.getResolvedFeatures(superType);\n+\t\t\t\tfor (IResolvedConstructor superclassConstructor : superClass.getDeclaredConstructors()) {\n+\t\t\t\t\tIResolvedConstructor overriddenConstructor = new ResolvedConstructor(\n+\t\t\t\t\t\t\tsuperclassConstructor.getDeclaration(), typeReference);\n+\t\t\t\t\tif (isCandidate(typeReference, overriddenConstructor, visibilityHelper)) {\n+\t\t\t\t\t\tif (erasedSignatures.add(superclassConstructor.getResolvedErasureSignature())) {\n+\t\t\t\t\t\t\tresult.add(overriddenConstructor);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean isCandidate(LightweightTypeReference type, IResolvedExecutable executable,\n+\t\t\tIVisibilityHelper visibilityHelper) {\n+\t\tJvmDeclaredType declaringType = executable.getDeclaration().getDeclaringType();\n+\t\tif (type.getType() != declaringType && isVisible(executable, visibilityHelper)) {\n+\t\t\tJvmExecutable rawExecutable = executable.getDeclaration();\n+\t\t\tif (rawExecutable instanceof JvmOperation) {\n+\t\t\t\tJvmOperation operation = ((JvmOperation) rawExecutable);\n+\t\t\t\tif (operation.isFinal() || operation.isStatic()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (type.getType() instanceof JvmGenericType && ((JvmGenericType) type.getType()).isInterface()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzODE2NA=="}, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU1OTUyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxNDozNVrOGaHdyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxNDozNVrOGaHdyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzODQ3NQ==", "bodyText": "No need for fqn", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430038475", "createdAt": "2020-05-25T18:14:35Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU2Mjg0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxNjozMFrOGaHfng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxNjozMFrOGaHfng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzODk0Mg==", "bodyText": "Just a list is probably fine", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430038942", "createdAt": "2020-05-25T18:16:30Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU2MzY4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxNzowNVrOGaHgFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxNzowNVrOGaHgFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTA2Mg==", "bodyText": "Make this an elsif", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039062", "createdAt": "2020-05-25T18:17:05Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU2NDQ3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxNzozMVrOGaHgjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxNzozMVrOGaHgjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTE4MQ==", "bodyText": "parentheses", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039181", "createdAt": "2020-05-25T18:17:31Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (numParameters == 0) {\n+\t\t\t\t\t\t\t\tinfo.brackets = \"[|]\";\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (int i = 0; (i < numParameters); i++) {\n+\t\t\t\t\t\t\t\t\tif (i != 0) {\n+\t\t\t\t\t\t\t\t\t\tb.append(\", \");\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb.append(\"p\" + (i + 1));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tinfo.brackets = (\"[\" + b.toString() + \"|]\");\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\tinfo.selectionOffset = (-b.length()) - 2;\n+\t\t\t\t\t\t\t\tinfo.selectionLength = b.length();\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isExplicitOperationCall((IIdentifiableElementDescription) proposedDescription)) {\n+\t\t\t\tinfo.brackets = \"()\";\n+\t\t\t\tinfo.selectionOffset = -1;\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\n+\tprotected LightweightTypeReferenceFactory getTypeConverter(XtextResource context) {\n+\t\treturn new LightweightTypeReferenceFactory(new StandardTypeReferenceOwner(typeComputationServices,\n+\t\t\t\tcontext)) {\n+\t\t\t@Override\n+\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(JvmParameterizedTypeReference reference) {\n+\t\t\t\tLightweightTypeReference result = super.doVisitParameterizedTypeReference(reference);\n+\t\t\t\tif (result.isFunctionType()) {\n+\t\t\t\t\treturn result.tryConvertToFunctionTypeReference(false);\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, JvmFeature feature, boolean withParents,\n+\t\t\tint insignificantParameters, String shortName, LightweightTypeReferenceFactory converter) {\n+\t\tStringBuilder labelBuilder = new StringBuilder(shortName);\n+\t\tStringBuilder descriptionBuilder = new StringBuilder();\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tif (withParents) {\n+\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU2NjA4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxODoyMVrOGaHhdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxODoyMVrOGaHhdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTQxMw==", "bodyText": "parentheses", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039413", "createdAt": "2020-05-25T18:18:21Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (numParameters == 0) {\n+\t\t\t\t\t\t\t\tinfo.brackets = \"[|]\";\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (int i = 0; (i < numParameters); i++) {\n+\t\t\t\t\t\t\t\t\tif (i != 0) {\n+\t\t\t\t\t\t\t\t\t\tb.append(\", \");\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb.append(\"p\" + (i + 1));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tinfo.brackets = (\"[\" + b.toString() + \"|]\");\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\tinfo.selectionOffset = (-b.length()) - 2;\n+\t\t\t\t\t\t\t\tinfo.selectionLength = b.length();\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isExplicitOperationCall((IIdentifiableElementDescription) proposedDescription)) {\n+\t\t\t\tinfo.brackets = \"()\";\n+\t\t\t\tinfo.selectionOffset = -1;\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\n+\tprotected LightweightTypeReferenceFactory getTypeConverter(XtextResource context) {\n+\t\treturn new LightweightTypeReferenceFactory(new StandardTypeReferenceOwner(typeComputationServices,\n+\t\t\t\tcontext)) {\n+\t\t\t@Override\n+\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(JvmParameterizedTypeReference reference) {\n+\t\t\t\tLightweightTypeReference result = super.doVisitParameterizedTypeReference(reference);\n+\t\t\t\tif (result.isFunctionType()) {\n+\t\t\t\t\treturn result.tryConvertToFunctionTypeReference(false);\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, JvmFeature feature, boolean withParents,\n+\t\t\tint insignificantParameters, String shortName, LightweightTypeReferenceFactory converter) {\n+\t\tStringBuilder labelBuilder = new StringBuilder(shortName);\n+\t\tStringBuilder descriptionBuilder = new StringBuilder();\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tif (withParents) {\n+\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t}\n+\t\t\tJvmTypeReference returnType = ((JvmOperation) feature).getReturnType();\n+\t\t\tif (returnType != null && returnType.getSimpleName() != null) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tlabelBuilder.append(converter.toLightweightReference(returnType).getHumanReadableName());\n+\t\t\t}\n+\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\tconverter.toPlainTypeReference(((JvmOperation) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\tif (!withParents) {\n+\t\t\t\tdescriptionBuilder.append(\".\");\n+\t\t\t\tdescriptionBuilder.append(((JvmOperation) feature).getSimpleName());\n+\t\t\t\tdescriptionBuilder.append(\"()\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (feature instanceof JvmField) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tif ((((JvmField) feature).getType() != null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU2NjU5OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxODo0MFrOGaHhuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxODo0MFrOGaHhuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTQ4MA==", "bodyText": "probably want to make the casted version a local variable", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039480", "createdAt": "2020-05-25T18:18:40Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (numParameters == 0) {\n+\t\t\t\t\t\t\t\tinfo.brackets = \"[|]\";\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (int i = 0; (i < numParameters); i++) {\n+\t\t\t\t\t\t\t\t\tif (i != 0) {\n+\t\t\t\t\t\t\t\t\t\tb.append(\", \");\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb.append(\"p\" + (i + 1));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tinfo.brackets = (\"[\" + b.toString() + \"|]\");\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\tinfo.selectionOffset = (-b.length()) - 2;\n+\t\t\t\t\t\t\t\tinfo.selectionLength = b.length();\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isExplicitOperationCall((IIdentifiableElementDescription) proposedDescription)) {\n+\t\t\t\tinfo.brackets = \"()\";\n+\t\t\t\tinfo.selectionOffset = -1;\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\n+\tprotected LightweightTypeReferenceFactory getTypeConverter(XtextResource context) {\n+\t\treturn new LightweightTypeReferenceFactory(new StandardTypeReferenceOwner(typeComputationServices,\n+\t\t\t\tcontext)) {\n+\t\t\t@Override\n+\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(JvmParameterizedTypeReference reference) {\n+\t\t\t\tLightweightTypeReference result = super.doVisitParameterizedTypeReference(reference);\n+\t\t\t\tif (result.isFunctionType()) {\n+\t\t\t\t\treturn result.tryConvertToFunctionTypeReference(false);\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, JvmFeature feature, boolean withParents,\n+\t\t\tint insignificantParameters, String shortName, LightweightTypeReferenceFactory converter) {\n+\t\tStringBuilder labelBuilder = new StringBuilder(shortName);\n+\t\tStringBuilder descriptionBuilder = new StringBuilder();\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tif (withParents) {\n+\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t}\n+\t\t\tJvmTypeReference returnType = ((JvmOperation) feature).getReturnType();\n+\t\t\tif (returnType != null && returnType.getSimpleName() != null) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tlabelBuilder.append(converter.toLightweightReference(returnType).getHumanReadableName());\n+\t\t\t}\n+\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\tconverter.toPlainTypeReference(((JvmOperation) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\tif (!withParents) {\n+\t\t\t\tdescriptionBuilder.append(\".\");\n+\t\t\t\tdescriptionBuilder.append(((JvmOperation) feature).getSimpleName());\n+\t\t\t\tdescriptionBuilder.append(\"()\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (feature instanceof JvmField) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tif ((((JvmField) feature).getType() != null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU2NzE3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxOToxMFrOGaHiFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxOToxMFrOGaHiFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTU3Mw==", "bodyText": "Just a list should be fine", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039573", "createdAt": "2020-05-25T18:19:10Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (numParameters == 0) {\n+\t\t\t\t\t\t\t\tinfo.brackets = \"[|]\";\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (int i = 0; (i < numParameters); i++) {\n+\t\t\t\t\t\t\t\t\tif (i != 0) {\n+\t\t\t\t\t\t\t\t\t\tb.append(\", \");\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb.append(\"p\" + (i + 1));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tinfo.brackets = (\"[\" + b.toString() + \"|]\");\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\tinfo.selectionOffset = (-b.length()) - 2;\n+\t\t\t\t\t\t\t\tinfo.selectionLength = b.length();\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isExplicitOperationCall((IIdentifiableElementDescription) proposedDescription)) {\n+\t\t\t\tinfo.brackets = \"()\";\n+\t\t\t\tinfo.selectionOffset = -1;\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\n+\tprotected LightweightTypeReferenceFactory getTypeConverter(XtextResource context) {\n+\t\treturn new LightweightTypeReferenceFactory(new StandardTypeReferenceOwner(typeComputationServices,\n+\t\t\t\tcontext)) {\n+\t\t\t@Override\n+\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(JvmParameterizedTypeReference reference) {\n+\t\t\t\tLightweightTypeReference result = super.doVisitParameterizedTypeReference(reference);\n+\t\t\t\tif (result.isFunctionType()) {\n+\t\t\t\t\treturn result.tryConvertToFunctionTypeReference(false);\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, JvmFeature feature, boolean withParents,\n+\t\t\tint insignificantParameters, String shortName, LightweightTypeReferenceFactory converter) {\n+\t\tStringBuilder labelBuilder = new StringBuilder(shortName);\n+\t\tStringBuilder descriptionBuilder = new StringBuilder();\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tif (withParents) {\n+\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t}\n+\t\t\tJvmTypeReference returnType = ((JvmOperation) feature).getReturnType();\n+\t\t\tif (returnType != null && returnType.getSimpleName() != null) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tlabelBuilder.append(converter.toLightweightReference(returnType).getHumanReadableName());\n+\t\t\t}\n+\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\tconverter.toPlainTypeReference(((JvmOperation) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\tif (!withParents) {\n+\t\t\t\tdescriptionBuilder.append(\".\");\n+\t\t\t\tdescriptionBuilder.append(((JvmOperation) feature).getSimpleName());\n+\t\t\t\tdescriptionBuilder.append(\"()\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (feature instanceof JvmField) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tif ((((JvmField) feature).getType() != null)) {\n+\t\t\t\t\tString fieldType = converter.toLightweightReference(((JvmField) feature).getType())\n+\t\t\t\t\t\t\t.getHumanReadableName();\n+\t\t\t\t\tif (fieldType != null) {\n+\t\t\t\t\t\tlabelBuilder.append(fieldType);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\t\tconverter.toPlainTypeReference(((JvmField) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\t} else if (feature instanceof JvmConstructor) {\n+\t\t\t\tif (withParents) {\n+\t\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tentry.setLabel(labelBuilder.toString());\n+\t\tentry.setDescription(descriptionBuilder.toString());\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, EObject element, String qualifiedNameAsString,\n+\t\t\tString shortName) {\n+\t\tQualifiedName qualifiedName = getQualifiedNameConverter().toQualifiedName(qualifiedNameAsString);\n+\t\tif (qualifiedName.getSegmentCount() > 1) {\n+\t\t\tentry.setLabel(qualifiedName.getLastSegment());\n+\t\t\tentry.setDescription(qualifiedNameAsString);\n+\t\t} else {\n+\t\t\tentry.setLabel(qualifiedNameAsString);\n+\t\t}\n+\t}\n+\n+\tprotected void appendParameters(StringBuilder result, JvmExecutable executable, int insignificantParameters,\n+\t\t\tLightweightTypeReferenceFactory ownedConverter) {\n+\t\tEList<JvmFormalParameter> declaredParameters = executable.getParameters();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU2NzQwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxOToxNlrOGaHiNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoxOToxNlrOGaHiNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTYwNA==", "bodyText": "parentheses", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039604", "createdAt": "2020-05-25T18:19:16Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (numParameters == 0) {\n+\t\t\t\t\t\t\t\tinfo.brackets = \"[|]\";\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (int i = 0; (i < numParameters); i++) {\n+\t\t\t\t\t\t\t\t\tif (i != 0) {\n+\t\t\t\t\t\t\t\t\t\tb.append(\", \");\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb.append(\"p\" + (i + 1));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tinfo.brackets = (\"[\" + b.toString() + \"|]\");\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\tinfo.selectionOffset = (-b.length()) - 2;\n+\t\t\t\t\t\t\t\tinfo.selectionLength = b.length();\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isExplicitOperationCall((IIdentifiableElementDescription) proposedDescription)) {\n+\t\t\t\tinfo.brackets = \"()\";\n+\t\t\t\tinfo.selectionOffset = -1;\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\n+\tprotected LightweightTypeReferenceFactory getTypeConverter(XtextResource context) {\n+\t\treturn new LightweightTypeReferenceFactory(new StandardTypeReferenceOwner(typeComputationServices,\n+\t\t\t\tcontext)) {\n+\t\t\t@Override\n+\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(JvmParameterizedTypeReference reference) {\n+\t\t\t\tLightweightTypeReference result = super.doVisitParameterizedTypeReference(reference);\n+\t\t\t\tif (result.isFunctionType()) {\n+\t\t\t\t\treturn result.tryConvertToFunctionTypeReference(false);\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, JvmFeature feature, boolean withParents,\n+\t\t\tint insignificantParameters, String shortName, LightweightTypeReferenceFactory converter) {\n+\t\tStringBuilder labelBuilder = new StringBuilder(shortName);\n+\t\tStringBuilder descriptionBuilder = new StringBuilder();\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tif (withParents) {\n+\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t}\n+\t\t\tJvmTypeReference returnType = ((JvmOperation) feature).getReturnType();\n+\t\t\tif (returnType != null && returnType.getSimpleName() != null) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tlabelBuilder.append(converter.toLightweightReference(returnType).getHumanReadableName());\n+\t\t\t}\n+\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\tconverter.toPlainTypeReference(((JvmOperation) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\tif (!withParents) {\n+\t\t\t\tdescriptionBuilder.append(\".\");\n+\t\t\t\tdescriptionBuilder.append(((JvmOperation) feature).getSimpleName());\n+\t\t\t\tdescriptionBuilder.append(\"()\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (feature instanceof JvmField) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tif ((((JvmField) feature).getType() != null)) {\n+\t\t\t\t\tString fieldType = converter.toLightweightReference(((JvmField) feature).getType())\n+\t\t\t\t\t\t\t.getHumanReadableName();\n+\t\t\t\t\tif (fieldType != null) {\n+\t\t\t\t\t\tlabelBuilder.append(fieldType);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\t\tconverter.toPlainTypeReference(((JvmField) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\t} else if (feature instanceof JvmConstructor) {\n+\t\t\t\tif (withParents) {\n+\t\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tentry.setLabel(labelBuilder.toString());\n+\t\tentry.setDescription(descriptionBuilder.toString());\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, EObject element, String qualifiedNameAsString,\n+\t\t\tString shortName) {\n+\t\tQualifiedName qualifiedName = getQualifiedNameConverter().toQualifiedName(qualifiedNameAsString);\n+\t\tif (qualifiedName.getSegmentCount() > 1) {\n+\t\t\tentry.setLabel(qualifiedName.getLastSegment());\n+\t\t\tentry.setDescription(qualifiedNameAsString);\n+\t\t} else {\n+\t\t\tentry.setLabel(qualifiedNameAsString);\n+\t\t}\n+\t}\n+\n+\tprotected void appendParameters(StringBuilder result, JvmExecutable executable, int insignificantParameters,\n+\t\t\tLightweightTypeReferenceFactory ownedConverter) {\n+\t\tEList<JvmFormalParameter> declaredParameters = executable.getParameters();\n+\t\tList<JvmFormalParameter> relevantParameters = declaredParameters\n+\t\t\t\t.subList(Math.min(insignificantParameters, declaredParameters.size()), declaredParameters.size());\n+\t\tfor (int i = 0; (i < relevantParameters.size()); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU2OTI0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/JavaSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoyMDozMFrOGaHjTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoyMDozMFrOGaHjTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTg4NQ==", "bodyText": "This does nothing in java :(", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039885", "createdAt": "2020-05-25T18:20:30Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/JavaSource.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class JavaSource {\n+\tprivate String fileName;\n+\n+\tprivate String code;\n+\n+\tpublic JavaSource(String fileName, String code) {\n+\t\tthis.fileName = fileName;\n+\t\tthis.code = code;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tfinal int prime = 31;\n+\t\tint result = 1;\n+\t\tresult = prime * result + ((code == null) ? 0 : code.hashCode());\n+\t\tresult = prime * result + ((fileName == null) ? 0 : fileName.hashCode());\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tJavaSource other = (JavaSource) obj;\n+\t\tif (code == null) {\n+\t\t\tif (other.code != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!code.equals(other.code))\n+\t\t\treturn false;\n+\t\tif (fileName == null) {\n+\t\t\tif (other.fileName != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!fileName.equals(other.fileName))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU3MTEyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/RegisteringFileSystemAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoyMTo1NVrOGaHkdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoyMTo1NVrOGaHkdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA0MDE4Mg==", "bodyText": "s/5/\".java\".length/", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430040182", "createdAt": "2020-05-25T18:21:55Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/RegisteringFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.generator.InMemoryFileSystemAccess;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.7\n+ */\n+public class RegisteringFileSystemAccess extends InMemoryFileSystemAccess {\n+\t/**\n+\t * @noreference This class is not intended to be referenced by clients.\n+\t */\n+\tpublic static class GeneratedFile {\n+\t\tprivate String path;\n+\n+\t\tprivate String javaClassName;\n+\n+\t\tprivate CharSequence contents;\n+\n+\t\tpublic GeneratedFile(String path, String javaClassName, CharSequence contents) {\n+\t\t\tthis.path = path;\n+\t\t\tthis.javaClassName = javaClassName;\n+\t\t\tthis.contents = contents;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((contents == null) ? 0 : contents.hashCode());\n+\t\t\tresult = prime * result + ((javaClassName == null) ? 0 : javaClassName.hashCode());\n+\t\t\tresult = prime * result + ((path == null) ? 0 : path.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tGeneratedFile other = (GeneratedFile) obj;\n+\t\t\tif (contents == null) {\n+\t\t\t\tif (other.contents != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!contents.equals(other.contents))\n+\t\t\t\treturn false;\n+\t\t\tif (javaClassName == null) {\n+\t\t\t\tif (other.javaClassName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!javaClassName.equals(other.javaClassName))\n+\t\t\t\treturn false;\n+\t\t\tif (path == null) {\n+\t\t\t\tif (other.path != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!path.equals(other.path))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"path\", path);\n+\t\t\tb.add(\"javaClassName\", javaClassName);\n+\t\t\tb.add(\"contents\", contents);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic String getPath() {\n+\t\t\treturn path;\n+\t\t}\n+\n+\t\tpublic String getJavaClassName() {\n+\t\t\treturn javaClassName;\n+\t\t}\n+\n+\t\tpublic CharSequence getContents() {\n+\t\t\treturn contents;\n+\t\t}\n+\t}\n+\n+\tprivate Set<RegisteringFileSystemAccess.GeneratedFile> generatedFiles = new HashSet<>();\n+\n+\tprivate String projectName;\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputConfigurationName, CharSequence contents) {\n+\t\tsuper.generateFile(fileName, outputConfigurationName, contents);\n+\t\tString path = getPath(fileName, outputConfigurationName);\n+\t\tString javaName = null;\n+\t\tif (fileName.endsWith(\".java\")) {\n+\t\t\tjavaName = fileName.substring(0, fileName.length() - 5).replace('/', '.');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU3MTQ3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/RegisteringFileSystemAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoyMjowOFrOGaHkpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoyMjowOFrOGaHkpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA0MDIzMA==", "bodyText": "No need for FQN", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430040230", "createdAt": "2020-05-25T18:22:08Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/RegisteringFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.generator.InMemoryFileSystemAccess;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.7\n+ */\n+public class RegisteringFileSystemAccess extends InMemoryFileSystemAccess {\n+\t/**\n+\t * @noreference This class is not intended to be referenced by clients.\n+\t */\n+\tpublic static class GeneratedFile {\n+\t\tprivate String path;\n+\n+\t\tprivate String javaClassName;\n+\n+\t\tprivate CharSequence contents;\n+\n+\t\tpublic GeneratedFile(String path, String javaClassName, CharSequence contents) {\n+\t\t\tthis.path = path;\n+\t\t\tthis.javaClassName = javaClassName;\n+\t\t\tthis.contents = contents;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((contents == null) ? 0 : contents.hashCode());\n+\t\t\tresult = prime * result + ((javaClassName == null) ? 0 : javaClassName.hashCode());\n+\t\t\tresult = prime * result + ((path == null) ? 0 : path.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tGeneratedFile other = (GeneratedFile) obj;\n+\t\t\tif (contents == null) {\n+\t\t\t\tif (other.contents != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!contents.equals(other.contents))\n+\t\t\t\treturn false;\n+\t\t\tif (javaClassName == null) {\n+\t\t\t\tif (other.javaClassName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!javaClassName.equals(other.javaClassName))\n+\t\t\t\treturn false;\n+\t\t\tif (path == null) {\n+\t\t\t\tif (other.path != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!path.equals(other.path))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"path\", path);\n+\t\t\tb.add(\"javaClassName\", javaClassName);\n+\t\t\tb.add(\"contents\", contents);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic String getPath() {\n+\t\t\treturn path;\n+\t\t}\n+\n+\t\tpublic String getJavaClassName() {\n+\t\t\treturn javaClassName;\n+\t\t}\n+\n+\t\tpublic CharSequence getContents() {\n+\t\t\treturn contents;\n+\t\t}\n+\t}\n+\n+\tprivate Set<RegisteringFileSystemAccess.GeneratedFile> generatedFiles = new HashSet<>();\n+\n+\tprivate String projectName;\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputConfigurationName, CharSequence contents) {\n+\t\tsuper.generateFile(fileName, outputConfigurationName, contents);\n+\t\tString path = getPath(fileName, outputConfigurationName);\n+\t\tString javaName = null;\n+\t\tif (fileName.endsWith(\".java\")) {\n+\t\t\tjavaName = fileName.substring(0, fileName.length() - 5).replace('/', '.');\n+\t\t}\n+\t\tgeneratedFiles.add(new RegisteringFileSystemAccess.GeneratedFile(path, javaName, contents));\n+\t}\n+\n+\tprotected String getPath(String fileName, String outputConfigurationName) {\n+\t\tString path = getPathes().get(outputConfigurationName);\n+\t\treturn \"/\" + projectName + \"/\" + path + \"/\" + fileName;\n+\t}\n+\n+\tpublic Set<RegisteringFileSystemAccess.GeneratedFile> getGeneratedFiles() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODU3NDg0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/typesystem/Oven.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoyNDoyNlrOGaHmpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxODoyNDoyNlrOGaHmpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA0MDc0MA==", "bodyText": "Make the casted var a local var", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430040740", "createdAt": "2020-05-25T18:24:26Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/typesystem/Oven.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing.typesystem;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.eclipse.emf.common.util.TreeIterator;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.testing.util.ParseHelper;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XClosure;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.util.ReflectExtensions;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.internal.CompoundReentrantTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.internal.RootResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.internal.TypeData;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.junit.Assert;\n+import org.junit.ComparisonFailure;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Utility to check a given expression for exceptions and integrity after it was\n+ * processed by the {@link IBatchTypeResolver}\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+@Beta\n+@Singleton\n+public class Oven extends Assert {\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\t@Inject\n+\tprivate ReflectExtensions reflectExtensions;\n+\n+\t@Inject\n+\tprivate ParseHelper<EObject> parseHelper;\n+\n+\tpublic void fireproof(CharSequence input) throws Exception {\n+\t\tfireproof(input.toString());\n+\t}\n+\n+\tpublic void fireproof(String input) throws Exception {\n+\t\ttry {\n+\t\t\tEObject file = parseHelper.parse(input);\n+\t\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(file);\n+\t\t\tAssert.assertNotNull(resolvedTypes);\n+\t\t\tif (file != null) {\n+\t\t\t\tTreeIterator<EObject> allContents = file.eAllContents();\n+\t\t\t\twhile (allContents.hasNext()) {\n+\t\t\t\t\tEObject content = allContents.next();\n+\t\t\t\t\tif (content instanceof XAbstractFeatureCall) {\n+\t\t\t\t\t\tassertExpressionTypeIsResolved(((XExpression) content), resolvedTypes);\n+\t\t\t\t\t\tif (((XAbstractFeatureCall) content).getImplicitReceiver() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6"}, "originalPosition": 70}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 721, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}