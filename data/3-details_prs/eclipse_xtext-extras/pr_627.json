{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4MjY1MTU3", "number": 627, "title": "[eclipse/xtext#1777] ported xtend code to java", "bodyText": "[eclipse/xtext#1777] ported xtend code to java\nSigned-off-by: Christian Dietrich christian.dietrich@itemis.de", "createdAt": "2020-07-13T13:42:15Z", "url": "https://github.com/eclipse/xtext-extras/pull/627", "merged": true, "mergeCommit": {"oid": "4ae39aeec343c7dd0fe0e60d18dd8f99e527a73e"}, "closed": true, "closedAt": "2020-07-14T12:58:46Z", "author": {"login": "cdietrich"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc00pHZgFqTQ0ODAyNzUzOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc01LT4AFqTQ0ODA1NzkzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MDI3NTM5", "url": "https://github.com/eclipse/xtext-extras/pull/627#pullrequestreview-448027539", "createdAt": "2020-07-14T11:39:52Z", "commit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTozOTo1M1rOGxP7JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMTo0NzoyMlrOGxQJog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDMwOQ==", "bodyText": "You can put this two lines higher and remove line 49 as well", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454294309", "createdAt": "2020-07-14T11:39:53Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng==", "bodyText": "There are lot of @Pure in the file that declares IntegerRange", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454294966", "createdAt": "2020-07-14T11:41:09Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTI5MQ==", "bodyText": "No need for the intValue() AFAIK", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454295291", "createdAt": "2020-07-14T11:41:49Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTU4Mg==", "bodyText": "newLines++ or +=1?", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454295582", "createdAt": "2020-07-14T11:42:23Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTkxMw==", "bodyText": "You can just make this one else if", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454295913", "createdAt": "2020-07-14T11:43:08Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzAxNw==", "bodyText": "Why is this a field? It's only used in one method", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454297017", "createdAt": "2020-07-14T11:45:21Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzU4NA==", "bodyText": "No need for booleanValue()", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454297584", "createdAt": "2020-07-14T11:46:28Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {\n+\t\t\t\t\t\t\tcomment = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (comment) {\n+\t\t\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, node.getOffset()));\n+\t\t\t\t}\n+\t\t\t\tresult.getLeafs().add(new CommentInfo(result, node, newLines, trailing));\n+\t\t\t} else {\n+\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, node, newLines, node.getOffset()));\n+\t\t\t}\n+\t\t\tif (newLines > 0) {\n+\t\t\t\ttrailing = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\tint whitespaceOffset = 0;\n+\t\t\tif (result.getLeafs().isEmpty()) {\n+\t\t\t\twhitespaceOffset = offset;\n+\t\t\t} else {\n+\t\t\t\twhitespaceOffset = IterableExtensions.last(result.getLeafs()).getNode().getEndOffset();\n+\t\t\t}\n+\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, whitespaceOffset));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic HiddenLeafs getHiddenLeafsAfter(INode node) {\n+\t\tILeafNode start = findPreviousLeaf(node, l -> !l.isHidden());\n+\t\tif (start != null) {\n+\t\t\treturn newHiddenLeafs(start.getEndOffset(), findNextHiddenLeafs(start));\n+\t\t} else {\n+\t\t\toffset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected List<ILeafNode> findNextHiddenLeafs(INode node) {\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tNodeIterator ni = new NodeIterator(node);\n+\t\twhile (ni.hasNext()) {\n+\t\t\tINode next = ni.next();\n+\t\t\tif (next instanceof ILeafNode) {\n+\t\t\t\tif (((ILeafNode) next).isHidden()) {\n+\t\t\t\t\tresult.add((ILeafNode) next);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected ILeafNode findPreviousLeaf(INode node, Function1<? super ILeafNode, ? extends Boolean> matches) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tif (current instanceof ILeafNode && matches.apply((ILeafNode) current).booleanValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzYyMg==", "bodyText": "No need for booleanValue()", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454297622", "createdAt": "2020-07-14T11:46:32Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {\n+\t\t\t\t\t\t\tcomment = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (comment) {\n+\t\t\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, node.getOffset()));\n+\t\t\t\t}\n+\t\t\t\tresult.getLeafs().add(new CommentInfo(result, node, newLines, trailing));\n+\t\t\t} else {\n+\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, node, newLines, node.getOffset()));\n+\t\t\t}\n+\t\t\tif (newLines > 0) {\n+\t\t\t\ttrailing = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\tint whitespaceOffset = 0;\n+\t\t\tif (result.getLeafs().isEmpty()) {\n+\t\t\t\twhitespaceOffset = offset;\n+\t\t\t} else {\n+\t\t\t\twhitespaceOffset = IterableExtensions.last(result.getLeafs()).getNode().getEndOffset();\n+\t\t\t}\n+\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, whitespaceOffset));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic HiddenLeafs getHiddenLeafsAfter(INode node) {\n+\t\tILeafNode start = findPreviousLeaf(node, l -> !l.isHidden());\n+\t\tif (start != null) {\n+\t\t\treturn newHiddenLeafs(start.getEndOffset(), findNextHiddenLeafs(start));\n+\t\t} else {\n+\t\t\toffset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected List<ILeafNode> findNextHiddenLeafs(INode node) {\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tNodeIterator ni = new NodeIterator(node);\n+\t\twhile (ni.hasNext()) {\n+\t\t\tINode next = ni.next();\n+\t\t\tif (next instanceof ILeafNode) {\n+\t\t\t\tif (((ILeafNode) next).isHidden()) {\n+\t\t\t\t\tresult.add((ILeafNode) next);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected ILeafNode findPreviousLeaf(INode node, Function1<? super ILeafNode, ? extends Boolean> matches) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tif (current instanceof ILeafNode && matches.apply((ILeafNode) current).booleanValue()) {\n+\t\t\treturn (ILeafNode) current;\n+\t\t}\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (previous instanceof ILeafNode && matches.apply((ILeafNode) previous).booleanValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5ODAxOA==", "bodyText": "Seems like a pretty useless comment to me", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454298018", "createdAt": "2020-07-14T11:47:22Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {\n+\t\t\t\t\t\t\tcomment = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (comment) {\n+\t\t\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, node.getOffset()));\n+\t\t\t\t}\n+\t\t\t\tresult.getLeafs().add(new CommentInfo(result, node, newLines, trailing));\n+\t\t\t} else {\n+\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, node, newLines, node.getOffset()));\n+\t\t\t}\n+\t\t\tif (newLines > 0) {\n+\t\t\t\ttrailing = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\tint whitespaceOffset = 0;\n+\t\t\tif (result.getLeafs().isEmpty()) {\n+\t\t\t\twhitespaceOffset = offset;\n+\t\t\t} else {\n+\t\t\t\twhitespaceOffset = IterableExtensions.last(result.getLeafs()).getNode().getEndOffset();\n+\t\t\t}\n+\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, whitespaceOffset));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic HiddenLeafs getHiddenLeafsAfter(INode node) {\n+\t\tILeafNode start = findPreviousLeaf(node, l -> !l.isHidden());\n+\t\tif (start != null) {\n+\t\t\treturn newHiddenLeafs(start.getEndOffset(), findNextHiddenLeafs(start));\n+\t\t} else {\n+\t\t\toffset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected List<ILeafNode> findNextHiddenLeafs(INode node) {\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tNodeIterator ni = new NodeIterator(node);\n+\t\twhile (ni.hasNext()) {\n+\t\t\tINode next = ni.next();\n+\t\t\tif (next instanceof ILeafNode) {\n+\t\t\t\tif (((ILeafNode) next).isHidden()) {\n+\t\t\t\t\tresult.add((ILeafNode) next);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected ILeafNode findPreviousLeaf(INode node, Function1<? super ILeafNode, ? extends Boolean> matches) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tif (current instanceof ILeafNode && matches.apply((ILeafNode) current).booleanValue()) {\n+\t\t\treturn (ILeafNode) current;\n+\t\t}\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (previous instanceof ILeafNode && matches.apply((ILeafNode) previous).booleanValue()) {\n+\t\t\t\t\treturn (ILeafNode) previous;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected List<ILeafNode> findPreviousHiddenLeafs(INode node) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (!Objects.equal(previous, current) && previous instanceof ILeafNode) {\n+\t\t\t\t\tif (((ILeafNode) previous).isHidden()) {\n+\t\t\t\t\t\tresult.add((ILeafNode) previous);\n+\t\t\t\t\t} else { // if(!result.empty)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c"}, "originalPosition": 161}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74ec6694b502020992034659f60e8efcae97393e", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/74ec6694b502020992034659f60e8efcae97393e", "committedDate": "2020-07-14T12:17:47Z", "message": "[eclipse/xtext#1777] ported xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4d3466e109d2bc1296ef61158fdbccd412080f9c", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/4d3466e109d2bc1296ef61158fdbccd412080f9c", "committedDate": "2020-07-13T12:33:22Z", "message": "[eclipse/xtext#1777] ported xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}, "afterCommit": {"oid": "74ec6694b502020992034659f60e8efcae97393e", "author": {"user": {"login": "cdietrich", "name": "Christian Dietrich"}}, "url": "https://github.com/eclipse/xtext-extras/commit/74ec6694b502020992034659f60e8efcae97393e", "committedDate": "2020-07-14T12:17:47Z", "message": "[eclipse/xtext#1777] ported xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MDU3OTMw", "url": "https://github.com/eclipse/xtext-extras/pull/627#pullrequestreview-448057930", "createdAt": "2020-07-14T12:27:28Z", "commit": {"oid": "74ec6694b502020992034659f60e8efcae97393e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4431, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}