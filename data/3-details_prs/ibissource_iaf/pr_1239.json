{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1OTg3OTE5", "number": 1239, "title": "Create first iteration of the list of groups and use them for first XSD", "bodyText": "", "createdAt": "2020-11-05T11:18:47Z", "url": "https://github.com/ibissource/iaf/pull/1239", "merged": true, "mergeCommit": {"oid": "85ef8198b8989c24cbae1557aa4fed45d68366d2"}, "closed": true, "closedAt": "2021-01-12T08:45:19Z", "author": {"login": "mhdirkse"}, "timelineItems": {"totalCount": 146, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdlKrt1AH2gAyNTE1OTg3OTE5OjZkOWI5MmU0ZTUyNjk0MDRhODJjZGQxYmZjOWUyOTdjYzhhNmMzN2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdvXE3-gFqTU2NjA0NTM2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6d9b92e4e5269404a82cdd1bfc9e297cc8a6c37b", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/6d9b92e4e5269404a82cdd1bfc9e297cc8a6c37b", "committedDate": "2020-12-11T16:39:14Z", "message": "Rename ElementTypeRole to ElementRole"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26b5c075c312352d0506c4d20a21295cef61c00c", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/26b5c075c312352d0506c4d20a21295cef61c00c", "committedDate": "2020-12-11T17:59:56Z", "message": "Integration test ElementRole"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "321ac5bceb0ddea89b6ee44464ca9d2fe8396c02", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/321ac5bceb0ddea89b6ee44464ca9d2fe8396c02", "committedDate": "2020-12-11T18:01:45Z", "message": "Correct typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a00ae973cbf9355824d26b1554e5fba6bcb6812d", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/a00ae973cbf9355824d26b1554e5fba6bcb6812d", "committedDate": "2020-12-11T18:33:11Z", "message": "Move convenience methods from DocWriterNew to FrankElement\n\nHave to better sort the methods of FrankElement\nHave to cover the convenience methdos by the unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f92980f7a2edd61a2de3b8dc1fd76a5fc010b70", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/9f92980f7a2edd61a2de3b8dc1fd76a5fc010b70", "committedDate": "2020-12-14T11:01:45Z", "message": "Set up test suite in which ancestors will be tested"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfdf93eef28c3c52fdaf091cdc0a23a518d30652", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/bfdf93eef28c3c52fdaf091cdc0a23a518d30652", "committedDate": "2020-12-14T11:52:13Z", "message": "Cover that the ancestor finding methods check the predicate arg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44b05d6daac70042aa81180e8328f5bcada1abf9", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/44b05d6daac70042aa81180e8328f5bcada1abf9", "committedDate": "2020-12-14T15:26:04Z", "message": "Improve code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27d8673d5f801c6c54d95131ae68a1036cfcfb4f", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/27d8673d5f801c6c54d95131ae68a1036cfcfb4f", "committedDate": "2020-12-14T15:26:37Z", "message": "Merge branch 'master' into fillDataModel4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a4cdb0deba9559a877b1b9d409653afaf59b16c", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/8a4cdb0deba9559a877b1b9d409653afaf59b16c", "committedDate": "2020-12-14T18:25:30Z", "message": "Add simple elements before complex stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f36d62964ec62605e775bd2246fb6465c775e756", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/f36d62964ec62605e775bd2246fb6465c775e756", "committedDate": "2020-12-15T08:48:51Z", "message": "General element option in group uppercase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69ae5a07dfda8b3f2cc3f4eeaaad7eee0976b139", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/69ae5a07dfda8b3f2cc3f4eeaaad7eee0976b139", "committedDate": "2020-12-15T11:50:25Z", "message": "Add getting cumulative children to the model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2982fb38376c01fd2562b5c0b87950511c2092c", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/e2982fb38376c01fd2562b5c0b87950511c2092c", "committedDate": "2020-12-15T12:06:25Z", "message": "More tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e290a23922688352c08208fb007bf8c4e010031", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/4e290a23922688352c08208fb007bf8c4e010031", "committedDate": "2020-12-15T14:58:43Z", "message": "Get child element roles of an element type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "174f70fee40e5c1eee1575ab3b4d1e195a5f8e86", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/174f70fee40e5c1eee1575ab3b4d1e195a5f8e86", "committedDate": "2020-12-15T15:49:04Z", "message": "Always write simple elements if type non-interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/be2dfa9eb7bb7a35167be309dd1f603782c80733", "committedDate": "2020-12-15T19:48:21Z", "message": "Add option to element groups for any element - not working yet!"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNDg4MDc4", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-553488078", "createdAt": "2020-12-16T09:14:16Z", "commit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOToxNDoxNlrOIG7PIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNDozOTo0M1rOIHIgbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzMjg5OQ==", "bodyText": "Deze class heet 'Filter', maar is nu een wrapper rondom DocWriterNewXmlUtils.\nHet lijkt me een complexe oplossing voor de wens om de simpele elementen eerst af te drukken.\nIk had me voorgesteld dat je dat niet zou bouwen als een afdrukfilter, maar als een selectiefilter:\nDat je eerst door alle simpele elementen heen itereert, en daar je ding op doet,\nen vervolgens door de complexe elementen, en dan die doet.\nOok vind ik het niet elegant dat deze class all DocWriterNewXmlUtils methods kopieert.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r544132899", "createdAt": "2020-12-16T09:14:16Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/XsdWriteFilter.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+abstract class XsdWriteFilter {\n+\tboolean isWritingOn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1MTMzMw==", "bodyText": "Moet dit niet zijn: findOrRegisterElementRole() ?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r544151333", "createdAt": "2020-12-16T09:40:28Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -143,10 +177,18 @@ public FrankElement findOrCreateFrankElement(Class<?> clazz) throws ReflectiveOp\n \t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n \t\tcurrent.setParent(parent);\n \t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n-\t\tcurrent.setConfigChildren(createConfigChildren(clazz.getMethods(), current));\n+\t\tcurrent.setConfigChildren(createConfigChildren(clazz.getDeclaredMethods(), current));\n+\t\t// Cannot be done directly by ConfigChild because the sequence is important.\n+\t\t// The call to setConfigChildren does the sorting.\n+\t\tcurrent.getConfigChildren(ALL).forEach(\n+\t\t\t\tc -> c.registerSyntax1NameWithElementType(c.getSyntax1Name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MDQzMQ==", "bodyText": "Een ConfigChild ontstaat doordat er een ConfigChildSetter method is in een FrankElement.\nEr is dan een 'syntax1naam' en een 'class of interface'.\nDe 'class of interface' definieert het ElementType\nDe combinatie van 'syntax1naam' en ElementType bepaalt ElementRole\nNu heeft ConfigChild een syntax1Naam en ElementType.\nDat zou moeten zijn: een ElementRole\nIk denk dat het beter is om in ConfigChild alleen maar een verwijzing naar ElementRole te hebben, en geen syntax1Name en ElementType meer.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r544170431", "createdAt": "2020-12-16T10:07:51Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -1,31 +1,82 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.Setter;\n import nl.nn.adapterframework.doc.IbisDoc;\n import nl.nn.adapterframework.util.LogUtil;\n \n-public class ConfigChild {\n+public class ConfigChild extends ElementChild {\n \tprivate static Logger log = LogUtil.getLogger(ConfigChild.class);\n \n-\tprivate @Getter FrankElement configParent;\n+\t@EqualsAndHashCode(callSuper = false)\n+\tstatic final class Key extends AbstractKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NDQ5NA==", "bodyText": "Ik denk dat dit beter een Map<String,ElementRole>kan zijn", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r544174494", "createdAt": "2020-12-16T10:13:54Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "diffHunk": "@@ -1,15 +1,53 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n import java.util.Map;\n \n import lombok.Getter;\n \n+/**\n+ * Represents a type of FrankElement instances, which appears in the FF! Java code as\n+ * a Java interface. FrankElement objects that represent an abstract Java class should\n+ * be omitted as members. This is done automatically when Spring is used to get the\n+ * implementing classes of a Java interface.\n+ *\n+ * @author martijn\n+ *\n+ */\n public class ElementType {\n \tprivate @Getter String fullName;\n \tprivate @Getter String simpleName;\n \tprivate @Getter Map<String, FrankElement> members;\n \tprivate @Getter boolean fromJavaInterface;\n+\t\n+\t/**\n+\t * For each syntax 1 name in this set, an &lt;xs:choice&gt; of &lt;xs:element&gt;\n+\t * is created in the XSD. The elements in a group correspond to the Java\n+\t * classes that implement the Java interface represented by this {@link ElementChild}.\n+\t * For each syntax 1 name a different group is needed because the syntax 2\n+\t * names of the elements are different.\n+\t * <p>\n+\t * A {@link LinkedHashSet} is being used to preserve the sequence with which\n+\t * the syntax 1 names were inserted.\n+\t */\n+\tprivate @Getter LinkedHashSet<String> configChildSyntax1Names = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM1MDMxNg==", "bodyText": "Dit moet dan zijn: findOrCreateElementRole(ElementType, syntax1naam)", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r544350316", "createdAt": "2020-12-16T14:39:43Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -41,11 +92,34 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n \t\t\t} catch(Exception e) {\n \t\t\t\tlog.warn(String.format(\"@IbisDoc for config child with parent [%s] and type [%s] has a non-integer order [%s], ignored\",\n-\t\t\t\t\t\tconfigParent.getSimpleName(),\n+\t\t\t\t\t\tgetOwningElement().getSimpleName(),\n \t\t\t\t\t\telementType.getSimpleName(),\n \t\t\t\t\t\tibisDoc.value()[0]));\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tpublic String getSyntax1NamePlural() {\n+\t\tif(syntax1Name.endsWith(\"s\")) {\n+\t\t\treturn syntax1Name;\n+\t\t} else {\n+\t\t\treturn syntax1Name + \"s\";\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic int compareTo(ElementChild other) {\n+\t\treturn CONFIG_CHILD_COMPARATOR.compare(this, (ConfigChild) other);\n+\t}\n+\n+\tvoid registerSyntax1NameWithElementType(final String syntax1Name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e873640c8ae1292b0d5c1ea19679cf3807228f2", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/7e873640c8ae1292b0d5c1ea19679cf3807228f2", "committedDate": "2020-12-17T13:20:42Z", "message": "Fix that the XSD was incorrect"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cad66a2db200172a79ae63131af53e8558c44ee", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/1cad66a2db200172a79ae63131af53e8558c44ee", "committedDate": "2020-12-17T15:41:39Z", "message": "Rename attribute \"elementType\" to \"elementRole\""}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fc16be024845d2ab47ae64fcca6800a05e520b2", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/1fc16be024845d2ab47ae64fcca6800a05e520b2", "committedDate": "2020-12-17T17:49:42Z", "message": "Sort config child setters before creating ConfigChild"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "996f4920681af38a912065044d5d2e83a8591318", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/996f4920681af38a912065044d5d2e83a8591318", "committedDate": "2020-12-17T18:33:47Z", "message": "ConfigChild creates ElementRole creates ElementType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fc7c42c961b38c1c2edf1d1c7ee8ad3ca558b4c", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/6fc7c42c961b38c1c2edf1d1c7ee8ad3ca558b4c", "committedDate": "2020-12-17T18:43:07Z", "message": "Rename methods and reorder them"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/6e0745df244d5e86d13e504f6f73ec158254ee1f", "committedDate": "2020-12-18T09:35:17Z", "message": "Unit test calculating the founder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15172a6b64ac78a2654fbeb8471f3c206104672f", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/15172a6b64ac78a2654fbeb8471f3c206104672f", "committedDate": "2020-12-18T09:50:03Z", "message": "Introduce name highestCommonInterface"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzQ2ODQ3", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-555346847", "createdAt": "2020-12-18T09:53:45Z", "commit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTo1Mzo0NlrOIIcQRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTozMTo1NFrOIIfX6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyMjQzNg==", "bodyText": "Mooi gedaan, ook met classbacks en de leesbare lambda's.\nHet valt mij wel op dat alle xsdElementType, xsdElementTypeMemberChildGroup, xsdDeclaredGroupNameForAttributes en xsdCumulativeGroupNameForAttributes methodes door elkaar staan. Voor de leesbaarheid is het handig deze bij elkaar te groeperen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545722436", "createdAt": "2020-12-18T09:53:46Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import static java.util.Arrays.asList;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.OPTIONAL;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.PROHIBITED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.REQUIRED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.DEFAULT;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.FIXED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.DEPRECATED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import nl.nn.adapterframework.core.IListener;\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.ElementRole;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+/**\n+ * This class writes the XML Schema document (XSD) that checks the validity of a\n+ * Frank configuration XML file. The XML Schema is written based on the information\n+ * in a {@link FrankDocModel} object (the model).\n+ * \n+ * <h1>The syntax 2 name</h1>\n+ *\n+ * Below, a few implementation details are explained. First, the integration specialist\n+ * references an element by a name the reveals both the requested Java class\n+ * (expressed as a {@link FrankElement} in the model)\n+ * and the role it plays (e.g. sender or error sender). These requirements are\n+ * implemented by model method {@link FrankElement#getXsdElementName}. This\n+ * method takes as an argument the relevant {@link ElementType} to which the {@link FrankElement}\n+ * of the Java class belongs. The link between this {@link ElementType} and the\n+ * containing &lt;xs:element&gt; is made through a {@link ConfigChild}.\n+ * The <code>syntax1Name</code> attribute of this {@link ConfigChild}\n+ * is the other argument required by {@link FrankElement#getXsdElementName}.\n+ * <p>\n+ * Each element within the Frank!Framework appears as an &lt;complexType&gt;\n+ * under the XSD root. It is not duplicated for the different roles it\n+ * can play. This complex type references a group of config children and a group\n+ * of attributes. A group of config children consists of &lt;xs:choice&gt; elements that\n+ * each list the allowed elements available to the integration specialist, element groups.\n+ * An option within an element group appears as an &lt;xs:element&gt; that has\n+ * the syntax 2 name as name and the XSD type of the referenced {@link FrankElement} as type.\n+ * <p>\n+ * There is a different element group for each combination of an {@link ElementType} and\n+ * config child syntax 1 name, so there can be multiple element groups per {@link ElementType}. This is\n+ * the only duplication we need because of syntax 2 names. A {@link FrankElement} is\n+ * represented in the XSD with a top-level &lt;xs:complexType&gt; item. That item references\n+ * attribute groups and XSD sequences for config children, but these are not duplicated\n+ * because of the syntax 2 name issue.\n+ *\n+ * <h1>Inheritance of attributes and config children</h1>\n+ * \n+ * Each {@link FrankElement} is represented by a top-level &lt;xs:complexType&gt;.\n+ * Each Frank!Framework element can have attributes or other elements. \n+ * These correspond to {@link FrankAttribute}\n+ * objects or {@link ConfigChild} objects in the model.\n+ * <p>\n+ * In the model, a {@link FrankElement} only holds its declared attributes, but\n+ * the top-level &lt;xs:complexType&gt; should allow both the declared attributes and the attributes\n+ * inherited from the ancestors of the {@link FrankElement} (the inherited attributes).\n+ * The same holds for configuration children. This similarity appears in the model\n+ * through the common base class {@link ElementChild}, which is a parent class of both\n+ * {@link FrankAttribute} and {@link ConfigChild}. An attribute defined high in the\n+ * class hierarchy of the Frank!Framework can be allowed for many FF! elements,\n+ * but we do not want to repeat the same &lt;xs:attribute&gt; tags in all these cases.\n+ * We solve this by grouping the attributes, and the config children, in the XSD, for example:\n+ * \n+ * <pre>\n+ * {@code\n+<xs:complexType name=\"ConfigurationType\">\n+  <xs:group ref=\"ConfigurationDeclaredChildGroup\" />\n+  <xs:attributeGroup ref=\"ConfigurationDeclaredAttributeGroup\" />\n+</xs:complexType>\n+}\n+ * </pre>\n+ * <p>\n+ * The example shows a group named <code>ConfigurationDeclaredChildGroup</code>. This group\n+ * declares all allowed child FF! elements.\n+ * <p>\n+ * An XSD group ending with \"DeclaredChildGroup\" only holds the <em>declared</em> configuration children\n+ * or attributes. This is sufficient for Frank config element &lt;Configuration&gt; because the corresponding\n+ * Java class has only <code>Object</code> as parent. We also use cumulative groups\n+ * that allow the declared items (attributes / config children) of a {@link FrankElement}\n+ * as well as the inherited items. The following example in the XSD illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"LockerCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"LockerDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"JdbcFacadeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+}\n+ * </pre>\n+ * The Frank!Framework has a Java class named <code>Locker</code> that has class\n+ * <code>JdbcFacade</code> as its parent. The group <code>LockerCumulativeAttributeGroup</code>\n+ * is defined recursively: all declared attributes of <code>Locker</code> are in, and all\n+ * declared and inherited attributes of the parent class <code>JdbcFacade</code>. The\n+ * recursion stops with the ancestor that holds the last inherited attributes, because\n+ * for that ancestor we do not introduce a cumulative group and use the declared group\n+ * only.\n+ * <p>\n+ * Another issue about groups needs explanation. Some Java classes of the Frank!Framework override\n+ * attributes that become then duplicate in the model. They appear as declared attributes\n+ * in two {@link FrankElement} objects, one modeling the Java subclass and one modeling the\n+ * Java ancestor class. In this situation, only the attribute (or config child) corresponding\n+ * to the Java subclass is needed. The attribute\n+ * of the ancestor class is omitted. The following example illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"SoapValidatorCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"SoapValidatorDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"Json2XmlValidatorDeclaredAttributeGroup\" />\n+  <xs:attribute name=\"ignoreUnknownNamespaces\" type=\"xs:string\" />\n+  ...\n+  <xs:attributeGroup ref=\"FixedForwardPipeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+ }\n+ * </pre>\n+ * Java class <code>SoapValidator</code> overrides a method <code>setRoot()</code> from\n+ * the grand-parent class <code>XmlValidator</code>. If the cumulative group of\n+ * the parent class <code>Json2XmlValidatorCumulativeAttributeGroup</code> would be referenced,\n+ * we would have attribute \"<code>root</code>\" twice. To avoid this, only the declared group\n+ * <code>Json2XmlValidatorDeclaredAttributeGroup</code> is referenced and the non-duplicate\n+ * attributes of <code>XmlValidator</code> are repeated. Higher up the dependency\n+ * hierarchy, there are no duplicate attributes. Therefore, the list of attributes\n+ * can end with referencing group <code>FixedForwardPipeCumulativeAttributeGroup</code>.\n+ * <p>\n+ * Please note that <code>SoapValidator</code> has a deprecated method <code>setSchema()</code>\n+ * that it overrdes from <code>XmlValidator</code>. The algorithm takes care to not only omit\n+ * attribute <code>schema</code> as a declared attribute,\n+ * but also as an inherited attributre of <code>SoapValidator</code>. Other descendants\n+ * of <code>XmlValidator</code> are not influenced by the override by <code>SoapValidator</code>.\n+ * This part of the algorithm is handled by package-private class\n+ * <code>nl.nn.adapterframework.doc.model.ChildRejector</code>.\n+ * <p>\n+ * Finally, 'technical' overrides are ignored by this algorithm, which are\n+ * setters with an override annotation that are not deprecated and lack\n+ * IbisDoc or IbisDocRef annotations.\n+ * \n+ * <h1> The options for a config child</h1>\n+ *\n+ * The {@link ConfigChild} class in the model determines what &lt;xs:element&gt; are allowed\n+ * as children of another &lt;xs:element&gt;. The containing &lt;xs:element&gt; is the\n+ * <code>owningElement</code> field, which is of type {@link FrankElement}. A {@link ConfigChild} is\n+ * characterized by the combination of an owning element and an {@link ElementType}. As an example\n+ * consider the {@link ConfigChild} that exists for the combination of owning element\n+ * \"<code>Receiver</code>\" and element type \"<code>IListener</code>\". It produces\n+ * the following XML schema:\n+ * <pre>\n+ * {@code\n+<xs:group ref=\"IListenerListenerElementGroup\" minOccurs=\"0\" maxOccurs=\"1\" />\n+}\n+ * </pre>\n+ * This snippet appears within <code>&lt;xs:group name=\"ReceiverDeclaredChildGroup\"&gt;&lt;xs:sequence&gt;</code>.\n+ * The snippet states that a Receiver can contain all elements related to a Java class implementing\n+ * {@link IListener}, playing the role of a listener. The duplication because of syntax 2 names becomes\n+ * visible here.\n+ *\n+ * @author martijn\n+ *\n+ */\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\tprivate static final String ELEMENT_GROUP = \"ElementGroup\";\n+\tprivate static final String ELEMENT_ROLE = \"elementRole\";\n+\n+\tprivate FrankDocModel model;\n+\tprivate String startClassName;\n+\tprivate XmlBuilder xsdRoot;\n+\tprivate Set<String> namesCreatedFrankElements;\n+\tprivate Set<ElementRole.Key> idsCreatedElementGroups;\n+\tprivate Set<String> namesElementTypesWithChildMemberGroup;\n+\tprivate XsdWriteFilter writeFilter;\n+\tprivate XsdWriteFilter.ControlStack writeControl;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t}\n+\n+\tpublic void init() {\n+\t\tinit(CONFIGURATION);\n+\t}\n+\n+\tpublic void init(String startClassName) {\n+\t\tthis.startClassName = startClassName;\n+\t}\n+\n+\tpublic String getSchema() {\n+\t\txsdRoot = getXmlSchema();\n+\t\tList<XsdWriteFilter> writeFilters = asList(\n+\t\t\t\tnew XsdWriteFilter.EnableSimpleElements(), new XsdWriteFilter.EnableComplexStuff());\n+\t\tfor(XsdWriteFilter writeFilter: writeFilters) {\n+\t\t\tthis.writeFilter = writeFilter;\n+\t\t\twriteControl = new XsdWriteFilter.ControlStack(writeFilter);\n+\t\t\tnamesCreatedFrankElements = new HashSet<>();\n+\t\t\tidsCreatedElementGroups = new HashSet<>();\n+\t\t\tnamesElementTypesWithChildMemberGroup = new HashSet<>();\n+\t\t\tFrankElement startElement = model.findFrankElement(startClassName);\n+\t\t\trecursivelyDefineXsdElementOfRoot(startElement);\n+\t\t}\n+\t\treturn xsdRoot.toXML(true);\n+\t}\n+\n+\tprivate String xsdElementType(FrankElement frankElement) {\n+\t\treturn frankElement.getSimpleName() + \"Type\";\n+\t}\n+\n+\tprivate void recursivelyDefineXsdElementOfRoot(FrankElement frankElement) {\n+\t\tif(checkNotDefined(frankElement)) {\n+\t\t\twriteControl.pushSimpleElement();\n+\t\t\tString xsdElementName = frankElement.getSimpleName();\n+\t\t\tXmlBuilder attributeBuilder = recursivelyDefineXsdElementUnchecked(\n+\t\t\t\t\txsdRoot, frankElement, xsdElementName);\n+\t\t\taddClassNameAttribute(attributeBuilder, frankElement);\n+\t\t\twriteControl.pop();\n+\t\t}\n+\t}\n+\n+\tprivate void addClassNameAttribute(XmlBuilder context, FrankElement frankElement) {\n+\t\twriteFilter.addAttribute(context, \"className\", FIXED, frankElement.getFullName(), PROHIBITED);\n+\t}\n+\n+\tprivate XmlBuilder recursivelyDefineXsdElementUnchecked(XmlBuilder context, FrankElement frankElement, String xsdElementName) {\n+\t\tXmlBuilder elementBuilder = writeFilter.addElementWithType(context, xsdElementName);\n+\t\tXmlBuilder complexType = writeFilter.addComplexType(elementBuilder);\n+\t\tXmlBuilder sequence = writeFilter.addSequence(complexType);\n+\t\tfrankElement.getCumulativeConfigChildren(IN_XSD, DEPRECATED).forEach(c -> addConfigChild(sequence, c));\n+\t\taddAttributeList(complexType, frankElement.getCumulativeAttributes(IN_XSD, DEPRECATED));\n+\t\treturn complexType;\n+\t}\n+\n+\tprivate void recursivelyDefineXsdElementType(FrankElement frankElement) {\n+\t\tif(checkNotDefined(frankElement)) {\n+\t\t\tElementBuildingStrategy elementBuildingStrategy = getElementBuildingStrategy(frankElement);\n+\t\t\taddConfigChildren(elementBuildingStrategy, frankElement);\n+\t\t\taddAttributes(elementBuildingStrategy, frankElement);\n+\t\t\trecursivelyDefineXsdElementType(frankElement.getNextAncestorThatHasConfigChildren(IN_XSD));\n+\t\t\trecursivelyDefineXsdElementType(frankElement.getNextAncestorThatHasAttributes(IN_XSD));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @param frankElement The {@link FrankElement} for which an XSD element or XSD type is needed, or null\n+\t * @return true if the input is not null and if the element is not yet created.\n+\t */\n+\tprivate boolean checkNotDefined(FrankElement frankElement) {\n+\t\tif(frankElement == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif(namesCreatedFrankElements.contains(frankElement.getFullName())) {\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tnamesCreatedFrankElements.add(frankElement.getFullName());\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * This class is responsible for adding an xs:element in the XML schema if required.\n+\t * If a FrankElement corresponds to an abstract class, then no XML element\n+\t * should be added. This is achieved using the derived class ElementOmitter.\n+\t *\n+\t * For an abstract FrankElement, the config child declared/cumulative groups\n+\t * and the attribute declared/cumulative groups are still needed. Adding them is\n+\t * outside the scope of this class.\n+\t */\n+\tprivate abstract class ElementBuildingStrategy {\n+\t\tabstract void addGroupRef(String referencedGroupName);\n+\t\tabstract void addAttributeGroupRef(String referencedGroupName);\n+\t}\n+\n+\tprivate ElementBuildingStrategy getElementBuildingStrategy(FrankElement element) {\n+\t\tif(element.isAbstract()) {\n+\t\t\treturn new ElementOmitter();\n+\t\t} else {\n+\t\t\treturn new ElementAdder(element);\n+\t\t}\n+\t}\n+\n+\tprivate class ElementAdder extends ElementBuildingStrategy {\n+\t\tprivate final XmlBuilder complexType;\n+\t\t\n+\t\tElementAdder(FrankElement frankElement) {\n+\t\t\tcomplexType = writeFilter.addComplexType(xsdRoot, xsdElementType(frankElement));\n+\t\t}\n+\n+\t\t@Override\n+\t\tvoid addGroupRef(String referencedGroupName) {\n+\t\t\twriteFilter.addGroupRef(complexType, referencedGroupName);\n+\t\t}\n+\n+\t\t@Override\n+\t\tvoid addAttributeGroupRef(String referencedGroupName) {\n+\t\t\twriteFilter.addAttributeGroupRef(complexType, referencedGroupName);\n+\t\t}\n+\t}\n+\n+\tprivate class ElementOmitter extends ElementBuildingStrategy {\n+\t\t@Override\n+\t\tvoid addGroupRef(String referencedGroupName) {\n+\t\t}\n+\t\t@Override\n+\t\tvoid addAttributeGroupRef(String referencedGroupName) {\n+\t\t}\n+\t}\n+\n+\tprivate void addConfigChildren(ElementBuildingStrategy elementBuildingStrategy, FrankElement frankElement) {\n+\t\tConsumer<GroupCreator.Callback<ConfigChild>> cumulativeGroupTrigger =\n+\t\t\t\tca -> frankElement.walkCumulativeConfigChildren(ca, IN_XSD, DEPRECATED);\n+\t\tnew GroupCreator<ConfigChild>(frankElement, cumulativeGroupTrigger, new GroupCreator.Callback<ConfigChild>() {\n+\t\t\tprivate XmlBuilder cumulativeBuilder;\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic List<ConfigChild> getChildrenOf(FrankElement elem) {\n+\t\t\t\treturn elem.getConfigChildren(IN_XSD);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic FrankElement getAncestorOf(FrankElement elem) {\n+\t\t\t\treturn elem.getNextAncestorThatHasConfigChildren(IN_XSD);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addGroupRef(xsdDeclaredGroupNameForChildren(referee));\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addGroupRef(xsdCumulativeGroupNameForChildren(referee));\t\t\t\t\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroup() {\n+\t\t\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, xsdDeclaredGroupNameForChildren(frankElement));\n+\t\t\t\tXmlBuilder sequence = writeFilter.addSequence(group);\n+\t\t\t\tfrankElement.getConfigChildren(IN_XSD).forEach(\n+\t\t\t\t\t\tc -> addConfigChild(sequence, c));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroup() {\n+\t\t\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, xsdCumulativeGroupNameForChildren(frankElement));\n+\t\t\t\tcumulativeBuilder = writeFilter.addSequence(group);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleSelectedChildren(List<ConfigChild> children, FrankElement owner) {\n+\t\t\t\tchildren.forEach(c -> addConfigChild(cumulativeBuilder, c));\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void handleChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addGroupRef(cumulativeBuilder, xsdDeclaredGroupNameForChildren(elem));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleCumulativeChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addGroupRef(cumulativeBuilder, xsdCumulativeGroupNameForChildren(elem));\n+\t\t\t}\n+\t\t}).run();\n+\t}\n+\n+\tprivate static String xsdDeclaredGroupNameForChildren(FrankElement element) {\n+\t\treturn element.getSimpleName() + \"DeclaredChildGroup\";\n+\t}\n+\n+\tprivate static String xsdCumulativeGroupNameForChildren(FrankElement element) {\n+\t\treturn element.getSimpleName() + \"CumulativeChildGroup\";\n+\t}\n+\n+\tprivate void addConfigChild(XmlBuilder context, ConfigChild child) {\n+\t\tElementRole theRole = model.findElementRole(child);\n+\t\tif(isNoElementTypeNeeded(theRole)) {\n+\t\t\taddConfigChildSingleReferredElement(context, child);\n+\t\t} else {\n+\t\t\taddConfigChildWithElementGroup(context, child);\n+\t\t}\n+\t}\n+\n+\tprivate boolean isNoElementTypeNeeded(ElementRole role) {\n+\t\tElementType elementType = role.getElementType();\n+\t\tif(elementType.isFromJavaInterface()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\telse {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\tprivate void addConfigChildSingleReferredElement(XmlBuilder context, ConfigChild child) {\n+\t\tElementRole role = model.findElementRole(child);\n+\t\tFrankElement elementInType = singleElementOf(role.getElementType());\n+\t\twriteFilter.addElementRef(\n+\t\t\t\tcontext,\n+\t\t\t\telementInType.getXsdElementName(role),\n+\t\t\t\tgetMinOccurs(child),\n+\t\t\t\tgetMaxOccurs(child));\n+\t\twriteControl.pushSimpleElement();\n+\t\trecursivelyDefineXsdElement(elementInType, role);\n+\t\twriteControl.pop();\n+\t}\n+\n+\tprivate void addConfigChildWithElementGroup(XmlBuilder context, ConfigChild child) {\n+\t\tElementRole role = model.findElementRole(child);\n+\t\twriteControl.pushComplexStuff();\n+\t\tdefineElementTypeGroup(role);\n+\t\twriteControl.pop();\n+\t\twriteFilter.addGroupRef(context, role.createXsdElementName(ELEMENT_GROUP), getMinOccurs(child), getMaxOccurs(child));\n+\t}\n+\n+\tprivate FrankElement singleElementOf(ElementType elementType) {\n+\t\treturn elementType.getMembers().values().iterator().next();\n+\t}\n+\n+\tprivate static String getMinOccurs(ConfigChild child) {\n+\t\tif(child.isMandatory()) {\n+\t\t\treturn \"1\";\n+\t\t} else {\n+\t\t\treturn \"0\";\n+\t\t}\n+\t}\n+\n+\tprivate static String getMaxOccurs(ConfigChild child) {\n+\t\tif(child.isAllowMultiple()) {\n+\t\t\treturn \"unbounded\";\n+\t\t} else {\n+\t\t\treturn \"1\";\n+\t\t}\n+\t}\n+\n+\tprivate void recursivelyDefineXsdElement(FrankElement frankElement, ElementRole role) {\n+\t\tif(checkNotDefined(frankElement)) {\n+\t\t\tString xsdElementName = frankElement.getXsdElementName(role);\n+\t\t\tXmlBuilder attributeBuilder = recursivelyDefineXsdElementUnchecked(xsdRoot, frankElement, xsdElementName);\n+\t\t\taddExtraAttributesNotFromModel(attributeBuilder, frankElement, role);\n+\t\t}\n+\t}\n+\n+\tprivate void defineElementTypeGroup(ElementRole role) {\n+\t\tElementRole.Key key = role.getKey();\n+\t\tif(! idsCreatedElementGroups.contains(key)) {\n+\t\t\tidsCreatedElementGroups.add(key);\n+\t\t\tdefineElementTypeGroupUnchecked(role);\n+\t\t}\n+\t}\n+\n+\tprivate void defineElementTypeGroupUnchecked(ElementRole role) {\n+\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, role.createXsdElementName(ELEMENT_GROUP));\n+\t\tXmlBuilder choice = writeFilter.addChoice(group);\n+\t\tList<FrankElement> frankElementOptions = role.getElementType().getMembers().values().stream()\n+\t\t\t\t.filter(f -> ! f.isDeprecated())\n+\t\t\t\t.filter(f -> ! f.isAbstract())\n+\t\t\t\t.collect(Collectors.toList());\n+\t\taddGenericElementOption(choice, role, disambiguateGenericOptionElementName(role, frankElementOptions));\n+\t\tfrankElementOptions.sort((o1, o2) -> o1.getSimpleName().compareTo(o2.getSimpleName()));\n+\t\tfor(FrankElement frankElement: frankElementOptions) {\n+\t\t\taddElementToElementGroup(choice, frankElement, role);\n+\t\t}\t\t\n+\t}\n+\n+\t// TODO: Move this to the model.\n+\tprivate String disambiguateGenericOptionElementName(ElementRole role, List<FrankElement> membersToInclude) {\n+\t\t// TODO: This is not nice but it is currently needed to properly disambiguate the\n+\t\t// different sequence numbers for Listener. We have generic elements like\n+\t\t// \"Listener_2\" and \"Listener_3\" for now.\n+\t\tString result = Utils.toUpperCamelCase(role.createXsdElementName(\"\"));\n+\t\tSet<String> conflictCandidates = membersToInclude.stream()\n+\t\t\t\t.map(f -> f.getXsdElementName(role))\n+\t\t\t\t.collect(Collectors.toSet());\n+\t\tif(conflictCandidates.contains(result)) {\n+\t\t\tresult = \"Generic\" + result;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate void addGenericElementOption(XmlBuilder choice, ElementRole role, String elementNameGenericOption) {\n+\t\tXmlBuilder genericElementOption = writeFilter.addElementWithType(\n+\t\t\t\tchoice, elementNameGenericOption);\n+\t\tXmlBuilder complexType = writeFilter.addComplexType(genericElementOption);\n+\t\taddElementTypeChildMembers(complexType, role);\n+\t\twriteFilter.addAttribute(complexType, ELEMENT_ROLE, FIXED, role.getSyntax1Name(), PROHIBITED);\n+\t\twriteFilter.addAttribute(complexType, \"className\", DEFAULT, null, REQUIRED);\n+\t\t// The XSD is invalid if addAnyAttribute is added before attributes elementType and className.\n+\t\twriteFilter.addAnyAttribute(complexType);\n+\t}\n+\n+\tprivate void addElementTypeChildMembers(XmlBuilder context, ElementRole role) {\n+\t\twriteFilter.addGroupRef(context, xsdElementTypeMemberChildGroup(role.getElementType()), \"0\", \"unbounded\");\n+\t\taddElementTypeMemberChildGroup(role);\n+\t}\n+\n+\tprivate String xsdElementTypeMemberChildGroup(ElementType elementType) {\n+\t\treturn elementType.getSimpleName() + \"MemberChildGroup\";\n+\t}\n+\n+\tprivate void addElementTypeMemberChildGroup(ElementRole role) {\n+\t\tif(! namesElementTypesWithChildMemberGroup.contains(role.getElementType().getFullName())) {\n+\t\t\tnamesElementTypesWithChildMemberGroup.add(role.getElementType().getFullName());\n+\t\t\taddElementTypeMemberChildGroupUnchecked(role);\n+\t\t}\n+\t}\n+\n+\tprivate void addElementTypeMemberChildGroupUnchecked(ElementRole role) {\n+\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, xsdElementTypeMemberChildGroup(role.getElementType()));\n+\t\tXmlBuilder choice = writeFilter.addChoice(group);\n+\t\tList<ElementRole> childRoles = model.getElementTypeMemberChildRoles(\n+\t\t\t\trole.getElementType(), IN_XSD, DEPRECATED, f -> ! f.isDeprecated());\n+\t\tchildRoles = childRoles.stream()\n+\t\t\t\t.map(ElementRole::getFounder)\n+\t\t\t\t.distinct()\n+\t\t\t\t.collect(Collectors.toList());\n+\t\tfor(ElementRole childRole: childRoles) {\n+\t\t\taddElementTypeMemberChildGroupOption(choice, childRole);\n+\t\t}\n+\t}\n+\n+\tprivate void addElementTypeMemberChildGroupOption(XmlBuilder choice, ElementRole childRole) {\n+\t\tif(isNoElementTypeNeeded(childRole)) {\n+\t\t\tFrankElement frankElement = singleElementOf(childRole.getElementType());\n+\t\t\tString xsdElementName = frankElement.getXsdElementName(childRole);\n+\t\t\twriteFilter.addElementRef(choice, xsdElementName);\n+\t\t} else {\n+\t\t\twriteFilter.addGroupRef(choice, childRole.createXsdElementName(ELEMENT_GROUP));\n+\t\t}\n+\t}\n+\n+\tprivate void addElementToElementGroup(XmlBuilder context, FrankElement frankElement, ElementRole role) {\n+\t\taddElementTypeRefToElementGroup(context, frankElement, role);\n+\t\trecursivelyDefineXsdElementType(frankElement);\n+\t}\n+\n+\tprivate void addElementTypeRefToElementGroup(XmlBuilder context, FrankElement frankElement, ElementRole role) {\n+\t\tXmlBuilder element = writeFilter.addElementWithType(context, frankElement.getXsdElementName(role));\n+\t\tXmlBuilder complexType = writeFilter.addComplexType(element);\n+\t\tXmlBuilder complexContent = writeFilter.addComplexContent(complexType);\n+\t\tXmlBuilder extension = writeFilter.addExtension(complexContent, xsdElementType(frankElement));\n+\t\taddExtraAttributesNotFromModel(extension, frankElement, role);\n+\t}\n+\n+\tprivate void addExtraAttributesNotFromModel(XmlBuilder context, FrankElement frankElement, ElementRole role) {\n+\t\twriteFilter.addAttribute(context, ELEMENT_ROLE, FIXED, role.getSyntax1Name(), PROHIBITED);\n+\t\taddClassNameAttribute(context, frankElement);\n+\t}\n+\n+\tprivate void addAttributes(ElementBuildingStrategy elementBuildingStrategy, FrankElement frankElement) {\n+\t\tConsumer<GroupCreator.Callback<FrankAttribute>> cumulativeGroupTrigger =\n+\t\t\t\tca -> frankElement.walkCumulativeAttributes(ca, IN_XSD, DEPRECATED);\n+\t\tnew GroupCreator<FrankAttribute>(frankElement, cumulativeGroupTrigger, new GroupCreator.Callback<FrankAttribute>() {\n+\t\t\tprivate XmlBuilder cumulativeBuilder;\n+\n+\t\t\t@Override\n+\t\t\tpublic List<FrankAttribute> getChildrenOf(FrankElement elem) {\n+\t\t\t\treturn elem.getAttributes(IN_XSD);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic FrankElement getAncestorOf(FrankElement elem) {\n+\t\t\t\treturn elem.getNextAncestorThatHasAttributes(IN_XSD);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addAttributeGroupRef(xsdDeclaredGroupNameForAttributes(referee));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addAttributeGroupRef(xsdCumulativeGroupNameForAttributes(referee));\t\t\t\t\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroup() {\n+\t\t\t\tXmlBuilder attributeGroup = writeFilter.addAttributeGroup(xsdRoot, xsdDeclaredGroupNameForAttributes(frankElement));\n+\t\t\t\taddAttributeList(attributeGroup, frankElement.getAttributes(IN_XSD));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroup() {\n+\t\t\t\tcumulativeBuilder = writeFilter.addAttributeGroup(xsdRoot, xsdCumulativeGroupNameForAttributes(frankElement));\t\t\t\t\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleSelectedChildren(List<FrankAttribute> children, FrankElement owner) {\n+\t\t\t\taddAttributeList(cumulativeBuilder, children);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addAttributeGroupRef(cumulativeBuilder, xsdDeclaredGroupNameForAttributes(elem));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleCumulativeChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addAttributeGroupRef(cumulativeBuilder, xsdCumulativeGroupNameForAttributes(elem));\t\t\t\t\n+\t\t\t}\n+\t\t}).run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 625}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNjYxMA==", "bodyText": "informative: Ik ben zelf geen grote fan van het importeren van static helper methodes. Dit heeft vooral te maken met de grote hoeveelheid dependencies in het project en de grote overlap aan duplicate methode namen in verschillende packages. Je kan zo niet (goed) zien waar iets vandaan komt.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545726610", "createdAt": "2020-12-18T10:01:14Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import static java.util.Arrays.asList;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.OPTIONAL;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.PROHIBITED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.REQUIRED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.DEFAULT;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.FIXED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.DEPRECATED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import nl.nn.adapterframework.core.IListener;\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.ElementRole;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+/**\n+ * This class writes the XML Schema document (XSD) that checks the validity of a\n+ * Frank configuration XML file. The XML Schema is written based on the information\n+ * in a {@link FrankDocModel} object (the model).\n+ * \n+ * <h1>The syntax 2 name</h1>\n+ *\n+ * Below, a few implementation details are explained. First, the integration specialist\n+ * references an element by a name the reveals both the requested Java class\n+ * (expressed as a {@link FrankElement} in the model)\n+ * and the role it plays (e.g. sender or error sender). These requirements are\n+ * implemented by model method {@link FrankElement#getXsdElementName}. This\n+ * method takes as an argument the relevant {@link ElementType} to which the {@link FrankElement}\n+ * of the Java class belongs. The link between this {@link ElementType} and the\n+ * containing &lt;xs:element&gt; is made through a {@link ConfigChild}.\n+ * The <code>syntax1Name</code> attribute of this {@link ConfigChild}\n+ * is the other argument required by {@link FrankElement#getXsdElementName}.\n+ * <p>\n+ * Each element within the Frank!Framework appears as an &lt;complexType&gt;\n+ * under the XSD root. It is not duplicated for the different roles it\n+ * can play. This complex type references a group of config children and a group\n+ * of attributes. A group of config children consists of &lt;xs:choice&gt; elements that\n+ * each list the allowed elements available to the integration specialist, element groups.\n+ * An option within an element group appears as an &lt;xs:element&gt; that has\n+ * the syntax 2 name as name and the XSD type of the referenced {@link FrankElement} as type.\n+ * <p>\n+ * There is a different element group for each combination of an {@link ElementType} and\n+ * config child syntax 1 name, so there can be multiple element groups per {@link ElementType}. This is\n+ * the only duplication we need because of syntax 2 names. A {@link FrankElement} is\n+ * represented in the XSD with a top-level &lt;xs:complexType&gt; item. That item references\n+ * attribute groups and XSD sequences for config children, but these are not duplicated\n+ * because of the syntax 2 name issue.\n+ *\n+ * <h1>Inheritance of attributes and config children</h1>\n+ * \n+ * Each {@link FrankElement} is represented by a top-level &lt;xs:complexType&gt;.\n+ * Each Frank!Framework element can have attributes or other elements. \n+ * These correspond to {@link FrankAttribute}\n+ * objects or {@link ConfigChild} objects in the model.\n+ * <p>\n+ * In the model, a {@link FrankElement} only holds its declared attributes, but\n+ * the top-level &lt;xs:complexType&gt; should allow both the declared attributes and the attributes\n+ * inherited from the ancestors of the {@link FrankElement} (the inherited attributes).\n+ * The same holds for configuration children. This similarity appears in the model\n+ * through the common base class {@link ElementChild}, which is a parent class of both\n+ * {@link FrankAttribute} and {@link ConfigChild}. An attribute defined high in the\n+ * class hierarchy of the Frank!Framework can be allowed for many FF! elements,\n+ * but we do not want to repeat the same &lt;xs:attribute&gt; tags in all these cases.\n+ * We solve this by grouping the attributes, and the config children, in the XSD, for example:\n+ * \n+ * <pre>\n+ * {@code\n+<xs:complexType name=\"ConfigurationType\">\n+  <xs:group ref=\"ConfigurationDeclaredChildGroup\" />\n+  <xs:attributeGroup ref=\"ConfigurationDeclaredAttributeGroup\" />\n+</xs:complexType>\n+}\n+ * </pre>\n+ * <p>\n+ * The example shows a group named <code>ConfigurationDeclaredChildGroup</code>. This group\n+ * declares all allowed child FF! elements.\n+ * <p>\n+ * An XSD group ending with \"DeclaredChildGroup\" only holds the <em>declared</em> configuration children\n+ * or attributes. This is sufficient for Frank config element &lt;Configuration&gt; because the corresponding\n+ * Java class has only <code>Object</code> as parent. We also use cumulative groups\n+ * that allow the declared items (attributes / config children) of a {@link FrankElement}\n+ * as well as the inherited items. The following example in the XSD illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"LockerCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"LockerDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"JdbcFacadeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+}\n+ * </pre>\n+ * The Frank!Framework has a Java class named <code>Locker</code> that has class\n+ * <code>JdbcFacade</code> as its parent. The group <code>LockerCumulativeAttributeGroup</code>\n+ * is defined recursively: all declared attributes of <code>Locker</code> are in, and all\n+ * declared and inherited attributes of the parent class <code>JdbcFacade</code>. The\n+ * recursion stops with the ancestor that holds the last inherited attributes, because\n+ * for that ancestor we do not introduce a cumulative group and use the declared group\n+ * only.\n+ * <p>\n+ * Another issue about groups needs explanation. Some Java classes of the Frank!Framework override\n+ * attributes that become then duplicate in the model. They appear as declared attributes\n+ * in two {@link FrankElement} objects, one modeling the Java subclass and one modeling the\n+ * Java ancestor class. In this situation, only the attribute (or config child) corresponding\n+ * to the Java subclass is needed. The attribute\n+ * of the ancestor class is omitted. The following example illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"SoapValidatorCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"SoapValidatorDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"Json2XmlValidatorDeclaredAttributeGroup\" />\n+  <xs:attribute name=\"ignoreUnknownNamespaces\" type=\"xs:string\" />\n+  ...\n+  <xs:attributeGroup ref=\"FixedForwardPipeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+ }\n+ * </pre>\n+ * Java class <code>SoapValidator</code> overrides a method <code>setRoot()</code> from\n+ * the grand-parent class <code>XmlValidator</code>. If the cumulative group of\n+ * the parent class <code>Json2XmlValidatorCumulativeAttributeGroup</code> would be referenced,\n+ * we would have attribute \"<code>root</code>\" twice. To avoid this, only the declared group\n+ * <code>Json2XmlValidatorDeclaredAttributeGroup</code> is referenced and the non-duplicate\n+ * attributes of <code>XmlValidator</code> are repeated. Higher up the dependency\n+ * hierarchy, there are no duplicate attributes. Therefore, the list of attributes\n+ * can end with referencing group <code>FixedForwardPipeCumulativeAttributeGroup</code>.\n+ * <p>\n+ * Please note that <code>SoapValidator</code> has a deprecated method <code>setSchema()</code>\n+ * that it overrdes from <code>XmlValidator</code>. The algorithm takes care to not only omit\n+ * attribute <code>schema</code> as a declared attribute,\n+ * but also as an inherited attributre of <code>SoapValidator</code>. Other descendants\n+ * of <code>XmlValidator</code> are not influenced by the override by <code>SoapValidator</code>.\n+ * This part of the algorithm is handled by package-private class\n+ * <code>nl.nn.adapterframework.doc.model.ChildRejector</code>.\n+ * <p>\n+ * Finally, 'technical' overrides are ignored by this algorithm, which are\n+ * setters with an override annotation that are not deprecated and lack\n+ * IbisDoc or IbisDocRef annotations.\n+ * \n+ * <h1> The options for a config child</h1>\n+ *\n+ * The {@link ConfigChild} class in the model determines what &lt;xs:element&gt; are allowed\n+ * as children of another &lt;xs:element&gt;. The containing &lt;xs:element&gt; is the\n+ * <code>owningElement</code> field, which is of type {@link FrankElement}. A {@link ConfigChild} is\n+ * characterized by the combination of an owning element and an {@link ElementType}. As an example\n+ * consider the {@link ConfigChild} that exists for the combination of owning element\n+ * \"<code>Receiver</code>\" and element type \"<code>IListener</code>\". It produces\n+ * the following XML schema:\n+ * <pre>\n+ * {@code\n+<xs:group ref=\"IListenerListenerElementGroup\" minOccurs=\"0\" maxOccurs=\"1\" />\n+}\n+ * </pre>\n+ * This snippet appears within <code>&lt;xs:group name=\"ReceiverDeclaredChildGroup\"&gt;&lt;xs:sequence&gt;</code>.\n+ * The snippet states that a Receiver can contain all elements related to a Java class implementing\n+ * {@link IListener}, playing the role of a listener. The duplication because of syntax 2 names becomes\n+ * visible here.\n+ *\n+ * @author martijn\n+ *\n+ */\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\tprivate static final String ELEMENT_GROUP = \"ElementGroup\";\n+\tprivate static final String ELEMENT_ROLE = \"elementRole\";\n+\n+\tprivate FrankDocModel model;\n+\tprivate String startClassName;\n+\tprivate XmlBuilder xsdRoot;\n+\tprivate Set<String> namesCreatedFrankElements;\n+\tprivate Set<ElementRole.Key> idsCreatedElementGroups;\n+\tprivate Set<String> namesElementTypesWithChildMemberGroup;\n+\tprivate XsdWriteFilter writeFilter;\n+\tprivate XsdWriteFilter.ControlStack writeControl;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t}\n+\n+\tpublic void init() {\n+\t\tinit(CONFIGURATION);\n+\t}\n+\n+\tpublic void init(String startClassName) {\n+\t\tthis.startClassName = startClassName;\n+\t}\n+\n+\tpublic String getSchema() {\n+\t\txsdRoot = getXmlSchema();\n+\t\tList<XsdWriteFilter> writeFilters = asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMjg4MQ==", "bodyText": "Is het een idee om de methodes geheel te verplaatsen naar de Utils klasse in plaats van er naar te refereren? Dit zijn utilities, en horen daarom hier thuis.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545732881", "createdAt": "2020-12-18T10:13:09Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/Utils.java", "diffHunk": "@@ -44,4 +60,12 @@ public static boolean isAttributeGetterOrSetter(Method method) {\n \tpublic static boolean isConfigChildSetter(Method method) {\n \t\treturn InfoBuilderSource.isConfigChildSetter(method);\n \t}\n+\n+\tpublic static String toUpperCamelCase(String arg) {\n+\t\treturn InfoBuilderSource.toUpperCamelCase(arg);\n+\t}\n+\n+\tpublic static String promoteIfPrimitive(String typeName) {\n+\t\treturn InfoBuilderSource.promoteIfPrimitive(typeName);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczNjEyMA==", "bodyText": "informative: probeer overal de methode argumenten op 1 regel te zetten, en niet soms op 1 regel, en soms onder elkaar. Het wordt er echt niet leesbaarder door om alles onder elkaar te zetten, en omdat onze schermen horizontaal staan mogen de regels best 150 characters lang zijn.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545736120", "createdAt": "2020-12-18T10:18:57Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/XsdWriteFilter.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+abstract class XsdWriteFilter {\n+\tboolean isWritingOn;\n+\n+\tabstract void startSimpleElement();\n+\tabstract void startComplexStuff();\n+\t\n+\tstatic class EnableSimpleElements extends XsdWriteFilter {\n+\t\t@Override\n+\t\tvoid startSimpleElement() {\n+\t\t\tthis.isWritingOn = true;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tvoid startComplexStuff() {\n+\t\t\tisWritingOn = false;\n+\t\t}\n+\t}\n+\n+\tstatic class EnableComplexStuff extends XsdWriteFilter {\n+\t\t@Override\n+\t\tvoid startSimpleElement() {\n+\t\t\tisWritingOn = false;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tvoid startComplexStuff() {\n+\t\t\tisWritingOn = true;\n+\t\t}\n+\t}\n+\n+\tprivate enum ControlNode {\n+\t\tSIMPLE_ELEMENT,\n+\t\tCOMPLEX_STUFF;\n+\t}\n+\n+\tstatic class ControlStack {\n+\t\tprivate final XsdWriteFilter slave;\n+\t\tprivate final Deque<ControlNode> controlNodes = new ArrayDeque<>();\n+\n+\t\tControlStack(XsdWriteFilter slave) {\n+\t\t\tthis.slave = slave;\n+\t\t\t// If all other write controls are popped, then we have complex stuff.\n+\t\t\tpushComplexStuff();\n+\t\t}\n+\n+\t\tvoid pushSimpleElement() {\n+\t\t\tcontrolNodes.addLast(ControlNode.SIMPLE_ELEMENT);\n+\t\t\tapply();\n+\t\t}\n+\n+\t\tvoid pushComplexStuff() {\n+\t\t\tcontrolNodes.addLast(ControlNode.COMPLEX_STUFF);\n+\t\t\tapply();\n+\t\t}\n+\n+\t\tvoid pop() {\n+\t\t\tcontrolNodes.removeLast();\n+\t\t\tapply();\n+\t\t}\n+\n+\t\tprivate void apply() {\n+\t\t\tswitch(controlNodes.getLast()) {\n+\t\t\tcase SIMPLE_ELEMENT:\n+\t\t\t\tslave.startSimpleElement();\n+\t\t\t\tbreak;\n+\t\t\tcase COMPLEX_STUFF:\n+\t\t\t\tslave.startComplexStuff();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvoid addElement(XmlBuilder context, String elementName, String elementType) {\n+\t\tif(isWritingOn) {\n+\t\t\tDocWriterNewXmlUtils.addElement(context, elementName, elementType);\n+\t\t}\n+\t}\n+\n+\tvoid addElementRef(\n+\t\t\tXmlBuilder context,\n+\t\t\tString elementName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1MzgwMg==", "bodyText": "Ik ben zelf geen grote fan van nested classes. Ik zie hier 3 nested classes voorkomen. Ik snap dat dit soms handig is, maar maak van deze Exceptie een losse klasse.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545753802", "createdAt": "2020-12-18T10:52:15Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -1,51 +1,162 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n-import org.apache.logging.log4j.Logger;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.springframework.core.annotation.AnnotationUtils;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.Setter;\n import nl.nn.adapterframework.doc.IbisDoc;\n-import nl.nn.adapterframework.util.LogUtil;\n \n-public class ConfigChild {\n-\tprivate static Logger log = LogUtil.getLogger(ConfigChild.class);\n+public class ConfigChild extends ElementChild {\n+\tprivate static final Comparator<SortNode> SORT_NODE_COMPARATOR =\n+\t\t\tComparator.comparing(SortNode::getSequenceInConfig)\n+\t\t\t.thenComparing(SortNode::getName);\n+\n+\tstatic final class SortNode implements Comparable<SortNode> {\n+\t\tprivate @Getter int sequenceInConfig = Integer.MAX_VALUE;\n+\t\tprivate @Getter String name;\n+\t\tprivate @Getter boolean documented;\n+\t\tprivate @Getter boolean deprecated;\n+\t\tprivate @Getter Method method;\n+\n+\t\tSortNode(Method method) {\n+\t\t\tthis.name = method.getName();\n+\t\t\tthis.method = method;\n+\t\t\tthis.documented = (method.getAnnotation(IbisDoc.class) != null);\n+\t\t\tthis.deprecated = isDeprecated(method);\n+\t\t}\n+\n+\t\tvoid parseIbisDocAnnotation() throws IbisDocAnnotationException {\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\t\tif(ibisDoc == null) {\n+\t\t\t\tthrow new IbisDocAnnotationException(String.format(\n+\t\t\t\t\t\t\"No @IbisDoc annotation on method [%s]\", name));\n+\t\t\t}\n+\t\t\tInteger optionalOrder = parseIbisDocAnnotation(ibisDoc);\n+\t\t\tif(optionalOrder != null) {\n+\t\t\t\tsequenceInConfig = optionalOrder;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate Integer parseIbisDocAnnotation(IbisDoc ibisDoc) throws IbisDocAnnotationException {\n+\t\t\tInteger result = null;\n+\t\t\tif(ibisDoc.value().length >= 1) {\n+\t\t\t\ttry {\n+\t\t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n+\t\t\t\t} catch(Exception e) {\n+\t\t\t\t\tthrow new IbisDocAnnotationException(String.format(\n+\t\t\t\t\t\t\t\"@IbisDoc annotation on method [%s] has no valid order\", name));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tprivate static boolean isDeprecated(Method m) {\n+\t\t\tDeprecated deprecated = m.getAnnotation(Deprecated.class);\n+\t\t\treturn (deprecated != null);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int compareTo(SortNode other) {\n+\t\t\treturn SORT_NODE_COMPARATOR.compare(this, other);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"serial\")\n+\tpublic static class IbisDocAnnotationException extends Exception {\t\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MzI0Ng==", "bodyText": "Kan je van ? een generic parameter maken?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tElementChild findElementChildMatch(ElementChild elementChild, Class<? extends ElementChild> kind) {\n          \n          \n            \n            \t\tMap<? extends AbstractKey, ? extends ElementChild> lookup = allChildren.get(kind);\n          \n          \n            \n            \t\treturn lookup.get(elementChild.getKey());\n          \n          \n            \n            \t}\n          \n          \n            \n            \t<C extends ElementChild> C findElementChildMatch(C elementChild) {\n          \n          \n            \n            \t\tMap<? extends AbstractKey, ? extends ElementChild> lookup = allChildren.get(elementChild.getClass());\n          \n          \n            \n            \t\treturn lookup.get(elementChild.getKey());\n          \n          \n            \n            \t}", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545763246", "createdAt": "2020-12-18T11:10:26Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,209 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.doc.model.ElementChild.AbstractKey;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter boolean isDeprecated = false;\n+\n+\t// Represents the Java superclass.\n+\tprivate @Getter FrankElement parent;\n+\n+\tprivate Map<Class<? extends ElementChild>, LinkedHashMap<? extends AbstractKey, ? extends ElementChild>> allChildren;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n+\t\tisDeprecated = clazz.getAnnotation(Deprecated.class) != null;\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.allChildren = new HashMap<>();\n+\t\tthis.allChildren.put(FrankAttribute.class, new LinkedHashMap<>());\n+\t\tthis.allChildren.put(ConfigChild.class, new LinkedHashMap<>());\n+\t}\n+\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tsetChildrenOfKind(inputAttributes, FrankAttribute.class);\n+\t}\n+\n+\tprivate <C extends ElementChild> void setChildrenOfKind(List<C> inputChildren, Class<C> kind) {\n+\t\tLinkedHashMap<AbstractKey, C> children = new LinkedHashMap<>();\n+\t\tfor(C c: inputChildren) {\n+\t\t\tif(children.containsKey(c.getKey())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes / config children with key [%s]\",\n+\t\t\t\t\t\tfullName, c.getKey().toString()));\n+\t\t\t} else {\n+\t\t\t\tchildren.put(c.getKey(), c);\n+\t\t\t}\n+\t\t}\n+\t\tallChildren.put(kind, children);\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<ElementChild> filter) {\n+\t\treturn getChildrenOfKind(filter, FrankAttribute.class);\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic <T extends ElementChild> List<T> getChildrenOfKind(\n+\t\t\tPredicate<ElementChild> selector, Class<T> kind) {\n+\t\tMap<? extends AbstractKey, ? extends ElementChild> lookup = allChildren.get(kind);\n+\t\treturn lookup.values().stream().filter(selector).map(c -> (T) c).collect(Collectors.toList());\n+\t}\n+\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tsetChildrenOfKind(children, ConfigChild.class);\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<ElementChild> filter) {\n+\t\treturn getChildrenOfKind(filter, ConfigChild.class);\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild, Class<? extends ElementChild> kind) {\n+\t\tMap<? extends AbstractKey, ? extends ElementChild> lookup = allChildren.get(kind);\n+\t\treturn lookup.get(elementChild.getKey());\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2ODc5NA==", "bodyText": "Gelieve hier nl.nn.adapterframework.testutil.TestFileUtils voor gebruiken, dan hebben wij 1 uniforme manier om testbestanden op te halen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545768794", "createdAt": "2020-12-18T11:21:46Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/DocWriterNewExamplesTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import nl.nn.adapterframework.core.Resource;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.util.Misc;\n+\n+@RunWith(Parameterized.class)\n+public class DocWriterNewExamplesTest {\n+\t@Parameters(name = \"{1}\")\n+\tpublic static Collection<Object[]> data() {\n+\t\treturn Arrays.asList(new Object[][] {\n+\t\t\t{\"examples-simple-digester-rules.xml\", \"nl.nn.adapterframework.doc.testtarget.examples.simple.Start\", \"simple.xsd\"}\n+\t\t});\n+\t}\n+\n+\t@Parameter(0)\n+\tpublic String digesterRulesFileName;\n+\n+\t@Parameter(1)\n+\tpublic String startClassName;\n+\n+\t@Parameter(2)\n+\tpublic String expectedXsdFileName;\n+\n+\t@Test\n+\tpublic void testXsd() throws Exception {\n+\t\tFrankDocModel model = createModel();\n+\t\tDocWriterNew docWriter = new DocWriterNew(model);\n+\t\tdocWriter.init(startClassName);\n+\t\tString actualXsd = docWriter.getSchema();\n+\t\tSystem.out.println(actualXsd);\n+\t\tString expectedXsd = getExpectedXsd();\n+\t\tassertEquals(expectedXsd.replace(\"\\r\\n\", \"\\n\"), actualXsd.replace(\"\\r\\n\", \"\\n\"));\n+\t}\n+\n+\tprivate FrankDocModel createModel() throws Exception {\n+\t\treturn FrankDocModel.populate(\n+\t\t\t\tgetDigesterRulesPath(digesterRulesFileName), startClassName);\n+\t}\n+\n+\tprivate String getDigesterRulesPath(String fileName) {\n+\t\treturn \"doc/\" + fileName;\n+\t}\n+\n+\tprivate String getExpectedXsd() throws Exception {\n+\t\tString fileName = \"doc/examplesExpected/\" + expectedXsdFileName;\n+\t\tResource resource = Resource.getResource(fileName);\n+\t\tInputStream is = resource.openStream();\n+\t\tReader reader = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));\n+\t\treturn Misc.readerToString(reader, \"\\n\", false);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2OTI1Mg==", "bodyText": "Gelieve hier nl.nn.adapterframework.testutil.TestAssertions voor gebruiken, dan hebben wij 1 uniforme manier om testbestanden cr/lf insensitive te vergelijken.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545769252", "createdAt": "2020-12-18T11:22:48Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/DocWriterNewExamplesTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import nl.nn.adapterframework.core.Resource;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.util.Misc;\n+\n+@RunWith(Parameterized.class)\n+public class DocWriterNewExamplesTest {\n+\t@Parameters(name = \"{1}\")\n+\tpublic static Collection<Object[]> data() {\n+\t\treturn Arrays.asList(new Object[][] {\n+\t\t\t{\"examples-simple-digester-rules.xml\", \"nl.nn.adapterframework.doc.testtarget.examples.simple.Start\", \"simple.xsd\"}\n+\t\t});\n+\t}\n+\n+\t@Parameter(0)\n+\tpublic String digesterRulesFileName;\n+\n+\t@Parameter(1)\n+\tpublic String startClassName;\n+\n+\t@Parameter(2)\n+\tpublic String expectedXsdFileName;\n+\n+\t@Test\n+\tpublic void testXsd() throws Exception {\n+\t\tFrankDocModel model = createModel();\n+\t\tDocWriterNew docWriter = new DocWriterNew(model);\n+\t\tdocWriter.init(startClassName);\n+\t\tString actualXsd = docWriter.getSchema();\n+\t\tSystem.out.println(actualXsd);\n+\t\tString expectedXsd = getExpectedXsd();\n+\t\tassertEquals(expectedXsd.replace(\"\\r\\n\", \"\\n\"), actualXsd.replace(\"\\r\\n\", \"\\n\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2OTk4NQ==", "bodyText": "Kan elke assertion statement hier ook op 1 regel?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545769985", "createdAt": "2020-12-18T11:24:13Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/AncestorKindsTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Class {@link FrankElement} has many different method to get children\n+ * and to search ancestors that have children. The tests in this class\n+ * are to test all these methods.\n+ * @author martijn\n+ *\n+ */\n+public class AncestorKindsTest {\n+\tprivate static final String PACKAGE = \"nl.nn.adapterframework.doc.testtarget.sparse.\";\n+\n+\tprivate FrankDocModel model;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tmodel = FrankDocModel.populate(\"doc/sparse-digester-rules.xml\", PACKAGE + \"ContainerChild\");\n+\t}\n+\n+\t@Test\n+\tpublic void testConfigChildrenOfPackageSparse() {\n+\t\tConfigChild child = model.findFrankElement(PACKAGE + \"ContainerChild\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerNoAncestorBecauseChildrenDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedConfigChildren\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeChild\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeNoAncestorBecauseAttributesDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedAttributes\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t}\n+\n+\t@Test\n+\tpublic void testAttributesOfPackageSparse() {\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"ContainerChild\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MDM5Ng==", "bodyText": "Probeer statements zo veel mogelijk op 1 regel te plaatsen. Dat is veel leesbaarder!", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545770396", "createdAt": "2020-12-18T11:25:02Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/AncestorKindsTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Class {@link FrankElement} has many different method to get children\n+ * and to search ancestors that have children. The tests in this class\n+ * are to test all these methods.\n+ * @author martijn\n+ *\n+ */\n+public class AncestorKindsTest {\n+\tprivate static final String PACKAGE = \"nl.nn.adapterframework.doc.testtarget.sparse.\";\n+\n+\tprivate FrankDocModel model;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tmodel = FrankDocModel.populate(\"doc/sparse-digester-rules.xml\", PACKAGE + \"ContainerChild\");\n+\t}\n+\n+\t@Test\n+\tpublic void testConfigChildrenOfPackageSparse() {\n+\t\tConfigChild child = model.findFrankElement(PACKAGE + \"ContainerChild\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerNoAncestorBecauseChildrenDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedConfigChildren\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeChild\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeNoAncestorBecauseAttributesDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedAttributes\")\n+\t\t\t\t.getConfigChildren(ALL).size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MTY4Mg==", "bodyText": "Hier ook graag elk statement op 1 regel.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545771682", "createdAt": "2020-12-18T11:27:49Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/FrankDocModelConfigChildrenTest.java", "diffHunk": "@@ -16,28 +20,42 @@\n \n public class FrankDocModelConfigChildrenTest {\n \tprivate static String CONTAINER = \"nl.nn.adapterframework.doc.testtarget.children.Container\";\n-\n+\tprivate static String CONTAINER_DERIVED = \"nl.nn.adapterframework.doc.testtarget.children.ContainerDerived\";\n+\tprivate static String CONTAINER_OTHER = \"nl.nn.adapterframework.doc.testtarget.children.ContainerOther\";\n+\t\n \tprivate FrankDocModel instance;\n \tprivate List<ConfigChild> configChildren;\n+\tprivate List<ConfigChild> configChildrenOfDerived;\n \n \t@Before\n \tpublic void setUp() throws SAXException, IOException, ReflectiveOperationException {\n \t\tinstance = new FrankDocModel();\n \t\tinstance.createConfigChildDescriptorsFrom(\"doc/simple-digester-rules.xml\");\n \t\tinstance.findOrCreateElementType(\n \t\t\t\tUtils.getClass(CONTAINER));\n-\t\tconfigChildren = instance.getAllElements().get(CONTAINER).getConfigChildren();\n+\t\tinstance.findOrCreateElementType(\n+\t\t\t\tUtils.getClass(CONTAINER_DERIVED));\n+\t\tinstance.findOrCreateElementType(\n+\t\t\t\tUtils.getClass(CONTAINER_OTHER));\n+\t\tinstance.setOverriddenFrom();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MzU0NQ==", "bodyText": "Fijn dat je commentaar toevoegt!", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545773545", "createdAt": "2020-12-18T11:31:54Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/testtarget/examples/simple/AbstractParentOfStart.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package nl.nn.adapterframework.doc.testtarget.examples.simple;\n+\n+//Should not appear as element in the XSD because it is abstract.\n+//Should appear as attribute group because it has an attribute", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "334506a03de7c63043e227aa836cb92ebfeef413", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/334506a03de7c63043e227aa836cb92ebfeef413", "committedDate": "2020-12-18T12:03:43Z", "message": "Multiple improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ed303d4f82b3e67b8f9f5932a3954f798fd4eb2", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/3ed303d4f82b3e67b8f9f5932a3954f798fd4eb2", "committedDate": "2020-12-18T12:07:29Z", "message": "Improve a test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c3a92f2680d45f17a66fc0a2f7e321e4873bd18", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/0c3a92f2680d45f17a66fc0a2f7e321e4873bd18", "committedDate": "2020-12-18T14:33:15Z", "message": "Let ElementType maintain ElementRole instead of syntax1Name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "195f27b7b9ebf312bfb2bb89218b1d2fe27fcb03", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/195f27b7b9ebf312bfb2bb89218b1d2fe27fcb03", "committedDate": "2021-01-04T11:28:10Z", "message": "Eliminate complex code of XsdWriteFilter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d805c47cc137952f52cd569dcdaf6600bb927cac", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/d805c47cc137952f52cd569dcdaf6600bb927cac", "committedDate": "2021-01-04T12:11:34Z", "message": "Move methods for names to the same spot in DocWriterNew"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d97907306a7565e49c16c419b2409d8dc06b0c58", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/d97907306a7565e49c16c419b2409d8dc06b0c58", "committedDate": "2021-01-04T16:02:47Z", "message": "Formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c335923885e2a66fcbb30b9746197a51b25d1ec2", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c335923885e2a66fcbb30b9746197a51b25d1ec2", "committedDate": "2021-01-04T16:10:41Z", "message": "Give IbisDocAnnotationException its own file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef5efb8ab653a29f4f25957818289e66e55d1fda", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/ef5efb8ab653a29f4f25957818289e66e55d1fda", "committedDate": "2021-01-04T16:24:37Z", "message": "Remove unneccessary arg of FrankElement.findElementChildMatch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10b7170097bb1d9f6d7d7ad7a985d129b3bf9bb4", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/10b7170097bb1d9f6d7d7ad7a985d129b3bf9bb4", "committedDate": "2021-01-04T16:34:44Z", "message": "Use TestAssertions.assertEqualsIgnoreCRLF"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da38a8fd896e13c8601762435aa4d81ebb7961b9", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/da38a8fd896e13c8601762435aa4d81ebb7961b9", "committedDate": "2021-01-04T16:54:59Z", "message": "Format test code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "369577a4b20709beaf38cbdfe5afcb0fbc1fdb04", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/369577a4b20709beaf38cbdfe5afcb0fbc1fdb04", "committedDate": "2021-01-05T10:50:49Z", "message": "Use method getTestFile()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dc4c7b7019ca6e242893414cbbf82c44c431480", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/4dc4c7b7019ca6e242893414cbbf82c44c431480", "committedDate": "2021-01-05T11:37:28Z", "message": "Add the default value of an attribute to its documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92765b60c37296fb6908a7c2ebdfe75ba5167d65", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/92765b60c37296fb6908a7c2ebdfe75ba5167d65", "committedDate": "2021-01-05T17:32:00Z", "message": "Added tracing - not tested in any way yet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a45f70bef3b415d76a47b3286873977717734109", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/a45f70bef3b415d76a47b3286873977717734109", "committedDate": "2021-01-06T17:20:07Z", "message": "Fix tracing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b04084f4f5b39864aa39550740b45f2d3049e66", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/4b04084f4f5b39864aa39550740b45f2d3049e66", "committedDate": "2021-01-07T17:26:52Z", "message": "Write JavaDoc package overview of the model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6a5549407c52a6673282a326b2c2730b2233204", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/f6a5549407c52a6673282a326b2c2730b2233204", "committedDate": "2021-01-08T13:43:26Z", "message": "Finish Javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/099e626cb07ed5c5ecafdf50909e7ad1315647da", "committedDate": "2021-01-11T08:56:25Z", "message": "Update license texts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MjAxODA0", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-565201804", "createdAt": "2021-01-11T09:56:26Z", "commit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo1NjoyN1rOIRORYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo1NjoyN1rOIRORYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMDUyOA==", "bodyText": "Vergeet niet je HTML tags te sluiten!", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554930528", "createdAt": "2021-01-11T09:56:27Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1MjA1NTg1", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-565205585", "createdAt": "2021-01-11T10:01:12Z", "commit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDowMToxM1rOIROcdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDowNzo1MFrOIROq6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMzM2Nw==", "bodyText": "Geeft getFullName() altijd de juiste waarde terug voor candidates.get(0) ?\nMoet dit niet result.getFullName() zijn?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554933367", "createdAt": "2021-01-11T10:01:13Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "diffHunk": "@@ -1,24 +1,149 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n+import nl.nn.adapterframework.util.LogUtil;\n \n+/**\n+ * Models a collection of FrankElement. The collection can be characterized by\n+ * a Java interface in the FF! sources, or there can be one member that is referenced\n+ * by its FrankElement. FrankElement objects that model an abstract Java class should\n+ * be omitted as members. This is done automatically when Spring is used to get the\n+ * implementing classes of a modeled Java interface.\n+ *\n+ * @author martijn\n+ *\n+ */\n public class ElementType {\n-\tprivate @Getter String fullName;\n-\tprivate @Getter String simpleName;\n+\tprivate static Logger log = LogUtil.getLogger(ElementType.class);\n \tprivate @Getter Map<String, FrankElement> members;\n \tprivate @Getter boolean fromJavaInterface;\n+\t\n+\tprivate @Getter LinkedHashSet<ElementRole> elementRoles = new LinkedHashSet<>();\n+\n+\tprivate static class InterfaceHierarchyItem {\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter String simpleName;\n+\t\tprivate @Getter Map<String, InterfaceHierarchyItem> parentInterfaces = new TreeMap<>();\n+\n+\t\tInterfaceHierarchyItem(Class<?> clazz) {\n+\t\t\tthis.fullName = clazz.getName();\n+\t\t\tthis.simpleName = clazz.getSimpleName();\n+\t\t\tif(clazz.isInterface()) {\n+\t\t\t\tfor(Class<?> superInterface: clazz.getInterfaces()) {\n+\t\t\t\t\tInterfaceHierarchyItem superInterfaceHierarchyItem = new InterfaceHierarchyItem(superInterface);\n+\t\t\t\t\tparentInterfaces.put(superInterfaceHierarchyItem.getFullName(), superInterfaceHierarchyItem);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<ElementType> findMatchingElementTypes(FrankDocModel model) {\n+\t\t\tElementType currentMatch = model.findElementType(fullName);\n+\t\t\tif(currentMatch != null) {\n+\t\t\t\treturn Arrays.asList(currentMatch);\n+\t\t\t}\n+\t\t\tList<ElementType> result = new ArrayList<>();\n+\t\t\tfor(String parentKey: parentInterfaces.keySet()) {\n+\t\t\t\tresult.addAll(parentInterfaces.get(parentKey).findMatchingElementTypes(model));\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\t}\n+\n+\tprivate final InterfaceHierarchyItem interfaceHierarchy;\n+\tprivate @Getter ElementType highestCommonInterface;\n \n \tElementType(Class<?> clazz) {\n-\t\tfullName = clazz.getName();\n-\t\tsimpleName = clazz.getSimpleName();\n+\t\tinterfaceHierarchy = new InterfaceHierarchyItem(clazz);\n \t\tmembers = new HashMap<>();\n \t\tthis.fromJavaInterface = clazz.isInterface();\n \t}\n \n+\tpublic String getFullName() {\n+\t\treturn interfaceHierarchy.getFullName();\n+\t}\n+\n+\tpublic String getSimpleName() {\n+\t\treturn interfaceHierarchy.getSimpleName();\n+\t}\n+\n \tvoid addMember(FrankElement member) {\n \t\tmembers.put(member.getFullName(), member);\n \t}\n+\n+\tFrankElement getSingletonElement() throws ReflectiveOperationException {\n+\t\tif(members.size() != 1) {\n+\t\t\tthrow new ReflectiveOperationException(String.format(\"Expected that ElementType [%s] contains exactly one element\", getFullName()));\n+\t\t}\n+\t\treturn members.values().iterator().next();\n+\t}\n+\n+\tvoid registerElementRole(ElementRole elementRole) {\n+\t\telementRoles.add(elementRole);\n+\t}\n+\n+\tvoid calculateHighestCommonInterface(FrankDocModel model) {\n+\t\thighestCommonInterface = this;\n+\t\tElementType nextCandidate = highestCommonInterface.getNextCommonInterface(model);\n+\t\twhile(nextCandidate != null) {\n+\t\t\thighestCommonInterface = nextCandidate;\n+\t\t\tnextCandidate = highestCommonInterface.getNextCommonInterface(model);\n+\t\t}\n+\t\tif(log.isTraceEnabled()) {\n+\t\t\tlog.trace(String.format(\"ElementType [%s] has highest common interface [%s]\", this.getFullName(), highestCommonInterface.getFullName()));\n+\t\t}\n+\t}\n+\n+\tprivate ElementType getNextCommonInterface(FrankDocModel model) {\n+\t\tif(! fromJavaInterface) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<ElementType> candidates = new ArrayList<>();\n+\t\tfor(String key: interfaceHierarchy.getParentInterfaces().keySet()) {\n+\t\t\tcandidates.addAll(interfaceHierarchy.getParentInterfaces().get(key).findMatchingElementTypes(model));\n+\t\t}\n+\t\tif(candidates.isEmpty()) {\n+\t\t\treturn null;\n+\t\t} else {\n+\t\t\tElementType result = candidates.get(0);\n+\t\t\tif(candidates.size() >= 2) {\n+\t\t\t\tlog.warn(String.format(\"There are multiple candidates for the next common interface of ElementType [%s], which are [%s]. Chose [%s]\",\n+\t\t\t\t\t\tgetFullName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzNzA2NQ==", "bodyText": "Ik denk dat je de verkeerde Collections geselecteerd hebt?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554937065", "createdAt": "2021-01-11T10:07:50Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -1,22 +1,45 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+\n import java.io.IOException;\n import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Set;\n import java.util.StringTokenizer;\n+import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.Logger;\n import org.springframework.core.annotation.AnnotationUtils;\n import org.xml.sax.SAXException;\n \n+import edu.emory.mathcs.backport.java.util.Collections;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7787152fd4a41a7d1167835ad4b9c4d4976e4262", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/7787152fd4a41a7d1167835ad4b9c4d4976e4262", "committedDate": "2021-01-11T10:51:39Z", "message": "Follow-up review comments by Niels"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NTEwNzIw", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-565510720", "createdAt": "2021-01-11T16:10:54Z", "commit": {"oid": "7787152fd4a41a7d1167835ad4b9c4d4976e4262"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2MDQ1MzY0", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-566045364", "createdAt": "2021-01-12T08:44:49Z", "commit": {"oid": "7787152fd4a41a7d1167835ad4b9c4d4976e4262"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0a3d69816a9e8eb843645a652bc4b29b3bd271d", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/a0a3d69816a9e8eb843645a652bc4b29b3bd271d", "committedDate": "2020-11-05T11:16:08Z", "message": "Create first iteration of the list of groups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e894a8374dc22b222a29abb29f289d5291461722", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/e894a8374dc22b222a29abb29f289d5291461722", "committedDate": "2020-11-05T11:24:17Z", "message": "Log exception and ignore long test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0OTEzNjIw", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-524913620", "createdAt": "2020-11-06T07:37:31Z", "commit": {"oid": "e894a8374dc22b222a29abb29f289d5291461722"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzozNzozMVrOHujAnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzozNzozMVrOHujAnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MDE0Mw==", "bodyText": "Het is heel goed dat je test classes en interfaces maakt, maar ik kan me voorstellen dat het verwarrend gaat zijn dat je daarvoor bekende termen als 'Pipe' en 'Listener' gebruikt, met name als ze af gaan wijken van wat bekend is.\nIn deze class heeft een 'Pipe' een 'Listener'. Dat is in het echt niet zo.\nIk herinner me nog een telefoongesprek waarin jij zoiets zei als dat een Pipe een Listener had. Je bedoelde toen misschien dit geval, maar ik was toen in verwarring.\nIk denk dat je hier dus beter andere termen kan gebruiken, zoals Parent en Child, of StructuredItem en SubItem", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r518570143", "createdAt": "2020-11-06T07:37:31Z", "author": {"login": "gvanbrakel"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/testtarget/groups/Pipe.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package nl.nn.adapterframework.doc.testtarget.groups;\n+\n+import nl.nn.adapterframework.doc.IbisDoc;\n+\n+public class Pipe implements IPipe {\n+\t@IbisDoc(\"10\")\n+\tpublic void setListener(Listener listener) {\n+\t}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e894a8374dc22b222a29abb29f289d5291461722"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2991813f65bd948c7b5edefa862032efe6fbfdce", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/2991813f65bd948c7b5edefa862032efe6fbfdce", "committedDate": "2020-11-06T12:51:25Z", "message": "First iteration of writing an XSD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef66f0e13b6ba0d713f60625c3a79e1977b354b8", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/ef66f0e13b6ba0d713f60625c3a79e1977b354b8", "committedDate": "2020-11-06T13:18:56Z", "message": "A complex type must always have a sequence"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af93f5e49327c03cf5d1d76788b8fe44d964f99d", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/af93f5e49327c03cf5d1d76788b8fe44d964f99d", "committedDate": "2020-11-09T08:54:29Z", "message": "Wrap config children in a tag indicating their function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e908619a21f7a76d4e8bd05393d34ade15b1f07a", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/e908619a21f7a76d4e8bd05393d34ade15b1f07a", "committedDate": "2020-11-09T09:53:42Z", "message": "Omit deprecated config children and attributes from XSD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d52e80ba30cf64b2dd9b8232ee746a376b12712b", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/d52e80ba30cf64b2dd9b8232ee746a376b12712b", "committedDate": "2020-11-09T11:34:26Z", "message": "Merge branch 'master' into fillDataModel4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24ab13d5df47762195c7f6b08775cee7e62377dd", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/24ab13d5df47762195c7f6b08775cee7e62377dd", "committedDate": "2020-11-09T13:32:40Z", "message": "Fix new ibisdoc.xsd by updating digester-rules.xml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fdcdbb2228dc81336172ce278273119ad383375", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/8fdcdbb2228dc81336172ce278273119ad383375", "committedDate": "2020-11-10T13:55:00Z", "message": "Apply inheritance for config children\n\nAttributes not yet done"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "771f22d4f26977acb87848b7394f4243d959e0a6", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/771f22d4f26977acb87848b7394f4243d959e0a6", "committedDate": "2020-11-12T14:26:27Z", "message": "Omit attribute overrides from XSD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4be7722914f46e44142a761c44690c0dbc13189", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/d4be7722914f46e44142a761c44690c0dbc13189", "committedDate": "2020-11-13T11:26:26Z", "message": "Add FrankElementStatistics - not unit tested"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bec56d604e12c634c2574dcdb68d734a2a5b16ba", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/bec56d604e12c634c2574dcdb68d734a2a5b16ba", "committedDate": "2020-11-13T17:23:47Z", "message": "Handle overrides in the XSD - not enough unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6066ea08bed168ddab879a2e964628acc7aa7e08", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/6066ea08bed168ddab879a2e964628acc7aa7e08", "committedDate": "2020-11-13T19:19:05Z", "message": "Fixed bugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ed18aa958face00d75ee463163956ad15252316", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/9ed18aa958face00d75ee463163956ad15252316", "committedDate": "2020-11-16T09:59:13Z", "message": "More statistics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cea6e3a7e695600d240fd943b41ae1b002334c12", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/cea6e3a7e695600d240fd943b41ae1b002334c12", "committedDate": "2020-11-16T14:08:59Z", "message": "More common code for groups and take care of abstract classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eba36da1970f29b337968e9048b062c9eb8e9d33", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/eba36da1970f29b337968e9048b062c9eb8e9d33", "committedDate": "2020-11-16T15:08:26Z", "message": "Maintain property whether an attribute is documented"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95648a42abf9e1b76d72de1c8276c1abb4f45e68", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/95648a42abf9e1b76d72de1c8276c1abb4f45e68", "committedDate": "2020-11-16T15:52:35Z", "message": "Finish documented properties of ConfigChild and FrankAttribute"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1a81dd99717baca6b38d558f6e9975ca5a61b79", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/b1a81dd99717baca6b38d558f6e9975ca5a61b79", "committedDate": "2020-11-16T16:02:48Z", "message": "Children that are overridden but not documented are ignored for XSD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23fd64bb1e271dda471abb3ec983d92994a846c7", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/23fd64bb1e271dda471abb3ec983d92994a846c7", "committedDate": "2020-11-16T16:44:32Z", "message": "Flatten the element hierarchy prescribed by the XSD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/d9d30609981971b04f05ad4fd69792be2b0d4a61", "committedDate": "2020-11-16T17:41:48Z", "message": "Omit useless types from XSD"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMzMyMjQy", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-532332242", "createdAt": "2020-11-17T12:56:12Z", "commit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMjo1NjoxMlrOH0zijQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzo0MTo0NVrOH01Tlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzMjQyOQ==", "bodyText": "Ik denk dat je hier zou moeten zeggen:\n\"all attributes: all declared attributes as well as all inherited attributes.\"", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525132429", "createdAt": "2020-11-17T12:56:12Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzMzczMw==", "bodyText": "Woord toevoegen:\nand an attribute that", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525133733", "createdAt": "2020-11-17T12:58:28Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzNDMxMg==", "bodyText": "Hierboven nog de copyright notice toevoegen", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525134312", "createdAt": "2020-11-17T12:59:32Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzNjcyMg==", "bodyText": "Je kan hier toch altijd addCumulativeGroup() doen?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525136722", "createdAt": "2020-11-17T13:03:46Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that\n+ * was overridden should be omitted.\n+ *\n+ * To support this, we make two kinds of groups for each FrankElement:\n+ * <ul>\n+ * <li> The cumulative group that holds all attributes (config children) and all inherited attributes.\n+ * <li> The declared group that holds only the declared attributes (config children).\n+ * This class traverses the inheritance hierarchy of a FrankElement and chooses whether\n+ * to repeat attributes, to reference the declared group or to reference the cumulative group.\n+ * @author martijn\n+ *\n+ * @param <K> The key type for referencing attributes or config children.\n+ */\n+abstract class CumulativeGroupCreator<K> {\n+\tprivate FrankElement current;\n+\tprivate Map<K, Boolean> items;\n+\tprivate Set<K> overridden;\n+\tprivate boolean isGroupRefRepetitionNotified;\n+\n+\tCumulativeGroupCreator() {\n+\t}\n+\n+\tvoid run(FrankElement start) {\n+\t\tenter(start);\n+\t\taddDeclaredGroup(start);\n+\t\toverridden = getCurrentOverrides();\n+\t\twhile(nextAncestor(current) != null) {\n+\t\t\tenter(nextAncestor(current));\n+\t\t\tif(overridden.isEmpty()) {\n+\t\t\t\tsafeAddCumulative();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\thandleOverridesForCurrent();\n+\t\t}\n+\t}\n+\n+\tprivate void enter(FrankElement current) {\n+\t\tthis.current = current;\n+\t\titems = itemsOf(current);\t\t\n+\t}\n+\n+\tprivate void safeAddCumulative() {\n+\t\tif(nextAncestor(current) == null) {\n+\t\t\taddDeclaredGroup(current);\n+\t\t} else {\n+\t\t\taddCumulativeGroup(current);\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0Njk4Nw==", "bodyText": "Kan je hier in twee regels commentaar uitleggen wat deze method doet?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525146987", "createdAt": "2020-11-17T13:20:28Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that\n+ * was overridden should be omitted.\n+ *\n+ * To support this, we make two kinds of groups for each FrankElement:\n+ * <ul>\n+ * <li> The cumulative group that holds all attributes (config children) and all inherited attributes.\n+ * <li> The declared group that holds only the declared attributes (config children).\n+ * This class traverses the inheritance hierarchy of a FrankElement and chooses whether\n+ * to repeat attributes, to reference the declared group or to reference the cumulative group.\n+ * @author martijn\n+ *\n+ * @param <K> The key type for referencing attributes or config children.\n+ */\n+abstract class CumulativeGroupCreator<K> {\n+\tprivate FrankElement current;\n+\tprivate Map<K, Boolean> items;\n+\tprivate Set<K> overridden;\n+\tprivate boolean isGroupRefRepetitionNotified;\n+\n+\tCumulativeGroupCreator() {\n+\t}\n+\n+\tvoid run(FrankElement start) {\n+\t\tenter(start);\n+\t\taddDeclaredGroup(start);\n+\t\toverridden = getCurrentOverrides();\n+\t\twhile(nextAncestor(current) != null) {\n+\t\t\tenter(nextAncestor(current));\n+\t\t\tif(overridden.isEmpty()) {\n+\t\t\t\tsafeAddCumulative();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\thandleOverridesForCurrent();\n+\t\t}\n+\t}\n+\n+\tprivate void enter(FrankElement current) {\n+\t\tthis.current = current;\n+\t\titems = itemsOf(current);\t\t\n+\t}\n+\n+\tprivate void safeAddCumulative() {\n+\t\tif(nextAncestor(current) == null) {\n+\t\t\taddDeclaredGroup(current);\n+\t\t} else {\n+\t\t\taddCumulativeGroup(current);\n+\t\t}\n+\t}\n+\n+\tprivate void handleOverridesForCurrent() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0OTIzOA==", "bodyText": "Kan je in twee regels commentaar uitleggen wat hieronder gebeurt?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525149238", "createdAt": "2020-11-17T13:24:13Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,470 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addAttribute;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addAttributeGroup;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addAttributeGroupRef;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addChoice;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addComplexType;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addDocumentation;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addElement;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addGroup;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addGroupRef;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addSequence;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ConfigChildKey;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.LogUtil;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(DocWriterNew.class);\n+\n+\tprivate FrankDocModel model;\n+\tprivate Map<String, String> syntax2Names;\n+\tList<SortKeyForXsd> xsdSortOrder;\n+\tprivate XmlBuilder xsdRoot;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t\tMap<String, List<FrankElement>> simpleNamePartitions = model.getAllElements().values().stream()\n+\t\t\t\t.collect(Collectors.groupingBy(\n+\t\t\t\t\t\tFrankElement::getSimpleName,\n+\t\t\t\t\t\tCollectors.toList()));\n+\t\tsyntax2Names = new HashMap<>();\n+\t\tfor(List<FrankElement> partition: simpleNamePartitions.values()) {\n+\t\t\tsyntax2Names.putAll(chooseSyntax2Names(partition));\n+\t\t}\n+\t}\n+\n+\tpublic void init() {\n+\t\txsdSortOrder = breadthFirstSort(CONFIGURATION);\n+\t}\n+\n+\tstatic Map<String, String> chooseSyntax2Names(List<FrankElement> elementPartition) {\n+\t\tMap<String, String> result = new HashMap<>();\n+\t\tif(elementPartition.size() == 1) {\n+\t\t\tFrankElement theElement = elementPartition.get(0);\n+\t\t\tresult.put(theElement.getFullName(), theElement.getSimpleName());\n+\t\t\treturn result;\n+\t\t}\n+\t\telse {\n+\t\t\tList<List<String>> nameComponents = new ArrayList<>();\n+\t\t\tfor(FrankElement element: elementPartition) {\n+\t\t\t\tList<String> packageNameComponents = Arrays.asList(element.getFullName().split(\"\\\\.\", -1));\n+\t\t\t\tif(! element.getSimpleName().equals(packageNameComponents.get(packageNameComponents.size() - 1))) {\n+\t\t\t\t\tlog.warn(String.format(\"Syntax 2 names may be wrong because there is a FrankElement with full name [%s] but simple name [%s]\",\n+\t\t\t\t\t\t\telement.getFullName(), element.getSimpleName()));\n+\t\t\t\t}\n+\t\t\t\tnameComponents.add(packageNameComponents);\n+\t\t\t}\n+\t\t\tList<String> fullNames = elementPartition.stream().map(elem -> elem.getFullName()).collect(Collectors.toList());\n+\t\t\tint numComponents = 2;\n+\t\t\twhile(true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE1ODM0Mg==", "bodyText": "Hier vind je de eerste definitie van het attribuut / het configChild. Is dat wat je wilt? Wil je niet de laatste hebben? Als je bijvoorbeeld documentatie wil overnemen, wil je die van de laatste.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525158342", "createdAt": "2020-11-17T13:38:20Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -48,4 +51,25 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t}\n \t\treturn result;\n \t}\n+\n+\t/**\n+\t * Calculate property overriddenFrom. Assumes that overriddenFrom has been\n+\t * set already for all ancestors in the FrankElement inheritance hierarchy.\n+\t */\n+\tpublic void calculateOverriddenFrom() {\n+\t\tConfigChildKey key = new ConfigChildKey(this);\n+\t\tFrankElement match = configParent;\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tConfigChild matchingChild = match.find(key);\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\tif(matchingChild.overriddenFrom != null) {\n+\t\t\t\t\tthis.overriddenFrom = matchingChild.overriddenFrom;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE2MTM2Ng==", "bodyText": "Ik denk dat ik ConfigChild en FrankElement een gezamelijk parent zou willen geven waarin calculateOverriddenFrom() z'n plek kan vinden.\nIk denk dat je GroupCreator daar ook simpeler van kan worden.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525161366", "createdAt": "2020-11-17T13:41:45Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankAttribute.java", "diffHunk": "@@ -49,4 +53,21 @@ void parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tvoid calculateOverriddenFrom() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9c62dac7aece9180bf1fb17f7708536c3196aac", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c9c62dac7aece9180bf1fb17f7708536c3196aac", "committedDate": "2020-11-17T15:44:19Z", "message": "Have first unit test of DocWriterNew"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd7cf1552cda0884523cd72b657c130a8cdff5cc", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/fd7cf1552cda0884523cd72b657c130a8cdff5cc", "committedDate": "2020-11-19T18:37:13Z", "message": "Not tested - Common base class for ConfigChild and FrankAttribute"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd2cebae4492633f190197a27aec4ef799196a1f", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/bd2cebae4492633f190197a27aec4ef799196a1f", "committedDate": "2020-11-20T11:44:28Z", "message": "Existing unit tests fixed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad3cd336cc5101096cd543a1f9faeb54e10485bb", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/ad3cd336cc5101096cd543a1f9faeb54e10485bb", "committedDate": "2020-11-20T17:15:33Z", "message": "Sort it out about annotation inheritance and the SELECTED predicate\n\nOne loose end still for attributes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f555067e6d26bc1aeb1932d8cef791f3df8d9c5f", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/f555067e6d26bc1aeb1932d8cef791f3df8d9c5f", "committedDate": "2020-11-20T17:33:36Z", "message": "Fix the loose end of the previous commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46919143f063e8b0a96c0414b9584d70e0f2a40d", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/46919143f063e8b0a96c0414b9584d70e0f2a40d", "committedDate": "2020-11-20T19:58:41Z", "message": "Cover walking XML schema groups with unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f777f17773ed98606dcc9a4e34bf86abbcec233b", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/f777f17773ed98606dcc9a4e34bf86abbcec233b", "committedDate": "2020-11-20T20:30:10Z", "message": "Omit irrelevant ancestors with writing XSD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c67190d2d94fb39bfa9a2d52f48819ca13e039c", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/6c67190d2d94fb39bfa9a2d52f48819ca13e039c", "committedDate": "2020-11-23T11:47:12Z", "message": "Produce an XSD with element references"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c30920590844d75920d44249267c278ece04112a", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c30920590844d75920d44249267c278ece04112a", "committedDate": "2020-11-23T11:50:29Z", "message": "Merge branch 'master' into fillDataModel4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da239c7fe5cb76b52bcca19bbacbad2164b1d13a", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/da239c7fe5cb76b52bcca19bbacbad2164b1d13a", "committedDate": "2020-11-23T11:52:14Z", "message": "Add message to ignore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "656edc3bb3ab9dafcc6957df5e4f98397b95b290", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/656edc3bb3ab9dafcc6957df5e4f98397b95b290", "committedDate": "2020-11-24T08:35:21Z", "message": "Rename xxxCombinationType to xxxElementType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9e95d484f720ad9894fd707be9b2f71d25c6009", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c9e95d484f720ad9894fd707be9b2f71d25c6009", "committedDate": "2020-11-24T09:12:43Z", "message": "Add property ConfigChild.syntax1NamePlural"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40446561c879ff0d8bf5f690cb3687fd053da2a8", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/40446561c879ff0d8bf5f690cb3687fd053da2a8", "committedDate": "2020-11-24T10:53:38Z", "message": "When allowMultiple, wrap the config child only once\n\nAlso fix bug that caused the element order to be non-deterministic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/67606376f4b6357c8b4eb8fd13a92178ccdecceb", "committedDate": "2020-11-24T13:21:54Z", "message": "Property overriddenFrom should not throw away information"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NDUwMzI2", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-536450326", "createdAt": "2020-11-23T13:01:23Z", "commit": {"oid": "6c67190d2d94fb39bfa9a2d52f48819ca13e039c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzowMToyM1rOH4MdQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo1NDozNlrOH5MILg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY4NjQwMw==", "bodyText": "Wat doet cast()?\nIk zie hem twee keer ge\u00efmplementeerd zijn met 'return this'.\nMoet hij dan abstract zijn?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r528686403", "createdAt": "2020-11-23T13:01:23Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}\n+ *\n+ * @author martijn\n+ *\n+ * @param <T>\n+ */\n+public abstract class ElementChild<T extends ElementChild<?>> {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild<?>> SELECTED = c ->\n+\t\t(! c.isDeprecated())\n+\t\t&& (c.isDocumented() || (c.getOverriddenFrom() == null));\n+\n+\tElementChild(final FrankElement owningElement) {\n+\t\tthis.owningElement = owningElement;\n+\t}\n+\n+\tpublic static Predicate<ElementChild<?>> ALL = c -> true;\n+\n+\tvoid calculateOverriddenFrom(BiFunction<FrankElement, T, T> lookup) {\n+\t\tFrankElement match = getOwningElement();\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tT matchingChild = lookup.apply(match, cast());\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\tFrankElement matchOverriddenFrom = matchingChild.getOverriddenFrom();\n+\t\t\t\tif(matchOverriddenFrom != null) {\n+\t\t\t\t\toverriddenFrom = matchOverriddenFrom;\n+\t\t\t\t} else {\n+\t\t\t\t\toverriddenFrom = match;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tabstract T cast();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c67190d2d94fb39bfa9a2d52f48819ca13e039c"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNDQwNg==", "bodyText": "Daar waar je cast() zou kunnen gebruiken, kan je toch ook gewoon 'this' gebruiken?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529724406", "createdAt": "2020-11-24T16:47:29Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -41,11 +40,24 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n \t\t\t} catch(Exception e) {\n \t\t\t\tlog.warn(String.format(\"@IbisDoc for config child with parent [%s] and type [%s] has a non-integer order [%s], ignored\",\n-\t\t\t\t\t\tconfigParent.getSimpleName(),\n+\t\t\t\t\t\tgetOwningElement().getSimpleName(),\n \t\t\t\t\t\telementType.getSimpleName(),\n \t\t\t\t\t\tibisDoc.value()[0]));\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tpublic String getSyntax1NamePlural() {\n+\t\tif(syntax1Name.endsWith(\"s\")) {\n+\t\t\treturn syntax1Name;\n+\t\t} else {\n+\t\t\treturn syntax1Name + \"s\";\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tConfigChild cast() {\n+\t\treturn this;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyOTU4Mg==", "bodyText": "Ik zou verwachten dat dit implementaties zouden zijn van een abstract method, en dat ze in ConfigChild resp. FrankAttribute gedefinieerd zouden zijn", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529729582", "createdAt": "2020-11-24T16:54:36Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,199 @@\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n \n+import org.apache.logging.log4j.Logger;\n+\n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final Comparator<ConfigChild> CONFIG_CHILD_COMPARATOR =\n+\t\t\tComparator.comparing(ConfigChild::getSequenceInConfig)\n+\t\t\t.thenComparing(ConfigChild::getSyntax1Name);\n+\tprivate static final Comparator<FrankAttribute> FRANK_ATTRIBUTE_COMPARATOR =\n+\t\t\tComparator.comparing(FrankAttribute::getOrder)\n+\t\t\t.thenComparing(FrankAttribute::getName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d657e7d272652297db15d560ae60befd2770a79", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/7d657e7d272652297db15d560ae60befd2770a79", "committedDate": "2020-11-26T08:09:48Z", "message": "Merge branch 'master' into fillDataModel4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44aceb92ec9818b808fca59645c81f59a6c903fd", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/44aceb92ec9818b808fca59645c81f59a6c903fd", "committedDate": "2020-11-26T08:39:07Z", "message": "Add copyright notices"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "524a9fcde8634261359273bc3dbdf648e935f9fd", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/524a9fcde8634261359273bc3dbdf648e935f9fd", "committedDate": "2020-11-26T12:45:00Z", "message": "Document attribute groups and config child groups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4377852273667aad4038ed80af5f8943cc2dee5e", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/4377852273667aad4038ed80af5f8943cc2dee5e", "committedDate": "2020-11-26T16:23:07Z", "message": "Document in DocWriterNew how the options are added for config children"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ab12a5d2e358afab972785c2ffbfd2c02a80435", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/0ab12a5d2e358afab972785c2ffbfd2c02a80435", "committedDate": "2020-11-26T16:36:16Z", "message": "Give testtarget classes names that do not conflict with the FF!"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab0ee0096874f112072de95161a48313268c0203", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/ab0ee0096874f112072de95161a48313268c0203", "committedDate": "2020-11-26T16:52:47Z", "message": "Document method named cast"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ec46f2cb5334cd747fbda09e5c2a7cd7ec21d5b", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/6ec46f2cb5334cd747fbda09e5c2a7cd7ec21d5b", "committedDate": "2020-11-27T08:52:20Z", "message": "Cover FrankElement.getAlias() with unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af74567efe941ee24a9bbbe3502f4814295497fc", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/af74567efe941ee24a9bbbe3502f4814295497fc", "committedDate": "2020-11-27T11:47:39Z", "message": "Omit abstract FrankElement as xs:element not not for groups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec2a837a32e094962bd394023b7b494e893b94db", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/ec2a837a32e094962bd394023b7b494e893b94db", "committedDate": "2020-11-27T18:30:36Z", "message": "First draft of rejecting deprecated children\n\nNot enough test coverage yet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a53fc448f291148c1fb382a2cce09b1f770404a4", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/a53fc448f291148c1fb382a2cce09b1f770404a4", "committedDate": "2020-11-30T11:04:55Z", "message": "Cover ChildRejector met unit tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd9f82fc7e735249cf39ee9e01bf2a0abae8fa31", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/dd9f82fc7e735249cf39ee9e01bf2a0abae8fa31", "committedDate": "2020-11-30T11:25:42Z", "message": "Improve code quality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2938904be668777d69afd57081469ccdf4049886", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/2938904be668777d69afd57081469ccdf4049886", "committedDate": "2020-11-30T14:17:44Z", "message": "Make attribute setter deprecated that only throws exception."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0598d0e29dceb12b5c06ccd8f23edfbd54067785", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/0598d0e29dceb12b5c06ccd8f23edfbd54067785", "committedDate": "2020-11-30T14:29:35Z", "message": "Move sorting children out of FrankElement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a45fc83ab8d062830f36c0ee8e5ad86dcc93a220", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/a45fc83ab8d062830f36c0ee8e5ad86dcc93a220", "committedDate": "2020-11-30T15:45:29Z", "message": "Fix checkForTypeConflict warnings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e714d148a33c04e00ba50958bfafc839c3bfc26e", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/e714d148a33c04e00ba50958bfafc839c3bfc26e", "committedDate": "2020-11-30T16:12:18Z", "message": "Explain child rejection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e689a0db593710b69e9f5c1f30ec96b6ba142c2", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/6e689a0db593710b69e9f5c1f30ec96b6ba142c2", "committedDate": "2020-12-01T11:35:57Z", "message": "Simplify by removing the type argument from ElementChild"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b1653caa8c81f7e9c4b0786a58d75e8badde7c6", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/1b1653caa8c81f7e9c4b0786a58d75e8badde7c6", "committedDate": "2020-12-01T11:41:31Z", "message": "ElementChild is not comparable, only its subclasses"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c73e7597062e96b0b6548604e17bfee63f37d102", "committedDate": "2020-12-01T12:13:21Z", "message": "Ignore DocWriterNew tests again"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTYwMTA2", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-541960106", "createdAt": "2020-12-01T14:37:39Z", "commit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDozNzozOVrOH8vhHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNTo1MTozN1rOH8ze3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ1NTEzNQ==", "bodyText": "Als ik 'Selected' lees, vraag ik me af 'waarvoor?' Volgens mij in dit geval: 'ElementToBeIncludedInXmlSchema'.\nKan je er zoiets van maken?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533455135", "createdAt": "2020-12-01T14:37:39Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.\n+ *\n+ * @author martijn\n+ */\n+public abstract class ElementChild {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild> SELECTED = c ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MzQyNg==", "bodyText": "Kan je hier in javadoc een beschrijving geven wat deze class is, en wat z'n twee descendants voorstellen?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533463426", "createdAt": "2020-12-01T14:44:30Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -1,13 +1,96 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n import lombok.Getter;\n \n-public class FrankDocGroup {\n+public abstract class FrankDocGroup {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2Njk5MA==", "bodyText": "Als je hier LinkedHashMaps gebruikt, kan je er later over itereren in de volgorde waarin je de elementen er in gestopt hebt", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533466990", "createdAt": "2020-12-01T14:47:07Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -32,9 +51,10 @@\n public class FrankDocModel {\n \tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n \tprivate static final String DIGESTER_RULES = \"digester-rules.xml\";\n-\t\n+\tstatic final String OTHER = \"Other\";\n+\n \tprivate @Getter Map<String, ConfigChildSetterDescriptor> configChildDescriptors;\n-\tprivate @Getter Map<String, FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankDocGroup> groups = new HashMap<>();\n \tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n \tprivate @Getter Map<String, ElementType> allTypes = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MjIzMw==", "bodyText": "Hier graag toevoegen, ter verduidelijking: \"This allows the framework code to distinguish null values (=not configured) from default values.\"", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533472233", "createdAt": "2020-12-01T14:52:01Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -200,6 +227,12 @@ public FrankElement findOrCreateFrankElement(Class<?> clazz) throws ReflectiveOp\n \tprivate void checkForTypeConflict(Method setter, Method getter, FrankElement attributeOwner) {\n \t\tString setterType = setter.getParameterTypes()[0].getName();\n \t\tString getterType = getter.getReturnType().getName();\n+\t\tif(getter.getName().startsWith(\"get\")) {\n+\t\t\t// For issers we require an exact match of the type name. For getters,\n+\t\t\t// the setter and the getter may mix boxed and unboxed types.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NTMyMA==", "bodyText": "Het is duidelijker als je hier de groepnaam tussen aanhalingstekens zet, als in: 'other'", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533475320", "createdAt": "2020-12-01T14:56:00Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -308,13 +345,87 @@ private static Method getParentMethod(String className, String methodName) {\n \t\t\tConfigChildSetterDescriptor configChildDescriptor = configChildDescriptors.get(m.getName());\n \t\t\tClass<?> elementClass = m.getParameterTypes()[0];\n \t\t\tconfigChild.setElementType(findOrCreateElementType(elementClass));\n+\t\t\tconfigChild.setDocumented(m.getAnnotation(IbisDoc.class) != null);\n \t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(m, IbisDoc.class);\n \t\t\tconfigChild.setSequenceInConfigFromIbisDocAnnotation(ibisDoc);\n \t\t\tconfigChild.setAllowMultiple(configChildDescriptor.isAllowMultiple());\n \t\t\tconfigChild.setMandatory(configChildDescriptor.isMandatory());\n+\t\t\tconfigChild.setDeprecated(isDeprecated(m));\n \t\t\tconfigChild.setSyntax1Name(configChildDescriptor.getSyntax1Name());\n \t\t\tresult.add(configChild);\n+\t\t\tcalculateAliases(configChild);\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tprivate boolean isDeprecated(Method m) {\n+\t\tDeprecated deprecated = AnnotationUtils.findAnnotation(m, Deprecated.class);\n+\t\treturn (deprecated != null);\n+\t}\n+\n+\t// TODO: Unit test this\n+\tprivate void calculateAliases(ConfigChild configChild) {\n+\t\tif(! configChild.getElementType().isFromJavaInterface()) {\n+\t\t\tCollection<FrankElement> members = configChild.getElementType().getMembers().values();\n+\t\t\tif(members.size() >= 1) {\n+\t\t\t\tFrankElement aliased = members.iterator().next();\n+\t\t\t\taliased.addAliasSource(configChild);\n+\t\t\t} else {\n+\t\t\t\tlog.warn(String.format(\"Found empty element type: [%s]\", configChild.getElementType().getFullName()));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void buildGroups() {\n+\t\tMap<String, List<FrankDocGroup>> groupsBase = new HashMap<>();\n+\t\tList<FrankElement> membersOfOther = new ArrayList<>();\n+\t\tfor(ElementType elementType: getAllTypes().values()) {\n+\t\t\tif(elementType.isFromJavaInterface()) {\n+\t\t\t\tif(groupsBase.containsKey(elementType.getSimpleName())) {\n+\t\t\t\t\tgroupsBase.get(elementType.getSimpleName()).add(FrankDocGroup.getInstanceFromElementType(elementType));\n+\t\t\t\t} else {\n+\t\t\t\t\tgroupsBase.put(elementType.getSimpleName(), Arrays.asList(FrankDocGroup.getInstanceFromElementType(elementType)));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ttry {\n+\t\t\t\t\tmembersOfOther.add(elementType.getSingletonElement());\n+\t\t\t\t} catch(ReflectiveOperationException e) {\n+\t\t\t\t\tlog.warn(String.format(\"Error adding ElementType [%s] to group other because it has multiple FrankElement objects: [%s]\",\n+\t\t\t\t\t\t\t\telementType.getFullName(),\n+\t\t\t\t\t\t\t\telementType.getMembers().values().stream().map(FrankElement::getSimpleName).collect(Collectors.joining(\", \"))),\n+\t\t\t\t\t\t\te);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif(groupsBase.containsKey(OTHER)) {\n+\t\t\tlog.warn(String.format(\"Name [%s] cannot been used for other because it is the name of an ElementType\", OTHER));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3ODI5MA==", "bodyText": "Parent is hier toch: de java superclass? Dat mag hier wel in een comment.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533478290", "createdAt": "2020-12-01T14:59:33Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4MDcxMw==", "bodyText": "Je kan hier volstaan met een LinkedHashMap<String, FrankAttribute> attributes, en een LinkedHashMap<ConfigChildKey, ConfigChild> configChildren. Als je de List wil hebben, vraag je daar de .values() van op.\nHet voorkomt dat je dubbele inserts moet doen, en dat je velden hebt die '...lookup' heten.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533480713", "createdAt": "2020-12-01T15:02:30Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4OTUwNA==", "bodyText": "Kan ConfigChild niet gewoon een getKey() method hebben?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533489504", "createdAt": "2020-12-01T15:13:19Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5MTMyMg==", "bodyText": "Dit is eigenlijk: getNextAncestorThatHasChildren(). Dan is het beter om het ook zo te noemen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533491322", "createdAt": "2020-12-01T15:15:38Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));\n+\t}\n+\n+\tpublic <T extends ElementChild> FrankElement getNextAncestor(Predicate<ElementChild> childFilter, Class<T> kind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NDA3Nw==", "bodyText": "als je getKey() in ElementChild definieert, en voor FrankAttribute implementeert als getName(), dan wordt deze code een stuk eenvoudiger.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533494077", "createdAt": "2020-12-01T15:19:06Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));\n+\t}\n+\n+\tpublic <T extends ElementChild> FrankElement getNextAncestor(Predicate<ElementChild> childFilter, Class<T> kind) {\n+\t\tFrankElement ancestor = parent;\n+\t\twhile((ancestor != null) && (ancestor.getChildren(childFilter, kind).size() == 0)) {\n+\t\t\tancestor = ancestor.getParent();\n+\t\t}\n+\t\treturn ancestor;\n+\t}\n+\n+\tpublic <T extends ElementChild> List<ElementChild> getChildren(Predicate<ElementChild> selector, Class<T> kind) {\n+\t\tList<ElementChild> result = new ArrayList<>();\n+\t\tif(kind.isAssignableFrom(FrankAttribute.class)) {\n+\t\t\tresult.addAll(getAttributes(selector));\n+\t\t}\n+\t\tif(kind.isAssignableFrom(ConfigChild.class)) {\n+\t\t\tresult.addAll(getConfigChildren(selector));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic void walkCumulativeAttributes(\n+\t\t\tCumulativeChildHandler<FrankAttribute> handler,\n+\t\t\tPredicate<ElementChild> childSelector,\n+\t\t\tPredicate<ElementChild> childRejector) {\n+\t\tnew AncestorChildNavigation<String, FrankAttribute>(\n+\t\t\t\thandler, childSelector, childRejector, FrankAttribute.class) {\n+\t\t\t@Override\n+\t\t\tString keyOf(ElementChild child) {\n+\t\t\t\treturn ((FrankAttribute) child).getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NDc1OA==", "bodyText": "Wat is een alias in dit geval? Zou je dat hier kunnen documenteren?\n-> ik zag later dat je dit al gedocumenteerd heb bij DocWriterNew. Toch graag hier ook twee regels, en evt. verwijzen naar DocWriterNew.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533494758", "createdAt": "2020-12-01T15:19:55Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));\n+\t}\n+\n+\tpublic <T extends ElementChild> FrankElement getNextAncestor(Predicate<ElementChild> childFilter, Class<T> kind) {\n+\t\tFrankElement ancestor = parent;\n+\t\twhile((ancestor != null) && (ancestor.getChildren(childFilter, kind).size() == 0)) {\n+\t\t\tancestor = ancestor.getParent();\n+\t\t}\n+\t\treturn ancestor;\n+\t}\n+\n+\tpublic <T extends ElementChild> List<ElementChild> getChildren(Predicate<ElementChild> selector, Class<T> kind) {\n+\t\tList<ElementChild> result = new ArrayList<>();\n+\t\tif(kind.isAssignableFrom(FrankAttribute.class)) {\n+\t\t\tresult.addAll(getAttributes(selector));\n+\t\t}\n+\t\tif(kind.isAssignableFrom(ConfigChild.class)) {\n+\t\t\tresult.addAll(getConfigChildren(selector));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic void walkCumulativeAttributes(\n+\t\t\tCumulativeChildHandler<FrankAttribute> handler,\n+\t\t\tPredicate<ElementChild> childSelector,\n+\t\t\tPredicate<ElementChild> childRejector) {\n+\t\tnew AncestorChildNavigation<String, FrankAttribute>(\n+\t\t\t\thandler, childSelector, childRejector, FrankAttribute.class) {\n+\t\t\t@Override\n+\t\t\tString keyOf(ElementChild child) {\n+\t\t\t\treturn ((FrankAttribute) child).getName();\n+\t\t\t}\n+\t\t}.run(this);\n+\t}\n+\n+\tpublic void walkCumulativeConfigChildren(\n+\t\t\tCumulativeChildHandler<ConfigChild> handler,\n+\t\t\tPredicate<ElementChild> childSelector,\n+\t\t\tPredicate<ElementChild> childRejector) {\n+\t\tnew AncestorChildNavigation<ConfigChildKey, ConfigChild>(\n+\t\t\t\thandler, childSelector, childRejector, ConfigChild.class) {\n+\t\t\t@Override\n+\t\t\tConfigChildKey keyOf(ElementChild child) {\n+\t\t\t\treturn new ConfigChildKey((ConfigChild) child);\n+\t\t\t}\n+\t\t}.run(this);\t\t\n+\t}\n+\n+\tpublic void addAliasSource(ConfigChild aliasSource) {\n+\t\taliasSources.add(aliasSource);\n+\t}\n+\n+\tpublic String getAlias() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUyMDA5NQ==", "bodyText": "Uit de private methods declaredGroupOrRepeatedChildren() in deze class maak ik op dat deze bedoeld is voor gebruik bij het opbouwen van de Xsd. Klopt dat? Dan zou dat ook in de naam naar voren moeten komen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533520095", "createdAt": "2020-12-01T15:51:37Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/AncestorChildNavigation.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+abstract class AncestorChildNavigation<K, T extends ElementChild> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1582f815ed877d92e632db607e50a490f52224cf", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/1582f815ed877d92e632db607e50a490f52224cf", "committedDate": "2020-12-03T08:29:06Z", "message": "Rename predicate SELECTED to IN_XSD and improve docs FrankDocGroup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55974d960e21e500039e14025cb2edf3d0981bde", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/55974d960e21e500039e14025cb2edf3d0981bde", "committedDate": "2020-12-03T08:52:38Z", "message": "Use LinkedHashMap for groups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15b4acd0496a769d77ff3e24382d4e097a698a2e", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/15b4acd0496a769d77ff3e24382d4e097a698a2e", "committedDate": "2020-12-03T09:13:24Z", "message": "Apply LinkedHashMap also in FrankElement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "befff9097f69570ab402524ceaea1edeee11c96b", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/befff9097f69570ab402524ceaea1edeee11c96b", "committedDate": "2020-12-03T09:29:54Z", "message": "Documentation updates and renames"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22656186e90f130b7576c69adb58760c279053ab", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/22656186e90f130b7576c69adb58760c279053ab", "committedDate": "2020-12-03T10:27:46Z", "message": "Introduce ElementChild.getKey(), always of type String"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75947f0d3f8f9ba83e0d04589e6280f304cc84d7", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/75947f0d3f8f9ba83e0d04589e6280f304cc84d7", "committedDate": "2020-12-03T10:33:16Z", "message": "Rename to getNextAncestorThatHasChildren"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84ddcfb76d092cfb92af362f4a77cf14363aeff8", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/84ddcfb76d092cfb92af362f4a77cf14363aeff8", "committedDate": "2020-12-03T11:12:20Z", "message": "Document FrankElement.getAlias()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2913ea5da20b962a48a3588ce49378a187511b67", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/2913ea5da20b962a48a3588ce49378a187511b67", "committedDate": "2020-12-03T11:15:39Z", "message": "Rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49d222d771beb9dd63341feedf51bdf5a065ce08", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/49d222d771beb9dd63341feedf51bdf5a065ce08", "committedDate": "2020-12-03T14:28:18Z", "message": "Reintroduce ConfigChildKey"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/419ff084eae3388bebafc4f07d03beb6ebbf30d9", "committedDate": "2020-12-03T14:29:25Z", "message": "Rename ConfigChildKey to Key"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTAzNzgy", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-544103782", "createdAt": "2020-12-03T15:50:14Z", "commit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo1MDoxNFrOH-jdqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoyMjowOVrOH-lCbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NDc5Mg==", "bodyText": "Key kan in deze samenstelling ook een interface zijn, wat door ConfigChild ge\u00efmplementeerd wordt.\nDan hoef je niet steeds een nieuw object te maken, maar kan je in getKey() gewoon 'this' teruggeven.\nHm, oh nee, toch niet, gaat niet goed met hashCode() en equals().\nNegeer deze feedback dus maar.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535354792", "createdAt": "2020-12-03T15:50:14Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -1,31 +1,69 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.Comparator;\n+\n import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.Setter;\n import nl.nn.adapterframework.doc.IbisDoc;\n import nl.nn.adapterframework.util.LogUtil;\n \n-public class ConfigChild {\n+public class ConfigChild extends ElementChild<ConfigChild.Key, ConfigChild> implements Comparable<ConfigChild> {\n \tprivate static Logger log = LogUtil.getLogger(ConfigChild.class);\n \n-\tprivate @Getter FrankElement configParent;\n+\t@EqualsAndHashCode\n+\tstatic final class Key {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic Key(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2MDMxOA==", "bodyText": "is a descendant of {@link FrankElement} <code>B</code>, toch?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535360318", "createdAt": "2020-12-03T15:56:38Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.\n+ *\n+ * @param <K> The type used to store keys, which are used to search for overrides.\n+ * @param <T> {@link FrankAttribute} or {@link ConfigChild}\n+ * \n+ * @author martijn\n+ */\n+public abstract class ElementChild<K, T extends ElementChild<K, T>> {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild<?, ?>> IN_XSD = c ->\n+\t\t(! c.isDeprecated())\n+\t\t&& (c.isDocumented() || (c.getOverriddenFrom() == null));\n+\n+\tpublic static Predicate<ElementChild<?, ?>> DEPRECATED = c -> c.isDeprecated();\n+\tpublic static Predicate<ElementChild<?, ?>> ALL = c -> true;\n+\tpublic static Predicate<ElementChild<?, ?>> NONE = c -> false;\n+\n+\tElementChild(final FrankElement owningElement) {\n+\t\tthis.owningElement = owningElement;\n+\t}\n+\n+\tvoid calculateOverriddenFrom() {\n+\t\tFrankElement match = getOwningElement();\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tElementChild<K, T> matchingChild = match.findElementChildMatch(this);\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\toverriddenFrom = match;\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get key that is used to match overrides. If {@link FrankElement} <code>A</code>\n+\t * is a descendant of {@link FrankAttribute} <code>B</code> and if their", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NjQ2Ng==", "bodyText": "'that has the classes that implement the interface of an {@link ElementType} that is defined with that interface',", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535376466", "createdAt": "2020-12-03T16:16:51Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -1,13 +1,113 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n import lombok.Getter;\n \n-public class FrankDocGroup {\n+/**\n+ * Holds a group of FrankElement objects for the Frank!Doc website.\n+ * This website will show a table-of-contents with the groups. When you\n+ * select a group, the FrankElement objects inside will be shown.\n+ * <p>\n+ * There are two kinds of groups that are represented by two subclasses of\n+ * {@link FrankDocGroup} that are also inner classes, namely\n+ * <code>FromType</code> and <code>Other</code>. <code>FromType</code>\n+ * holds a group that has the classes of an {@link ElementType}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzE2Nw==", "bodyText": "'that are each defined with a class rather then with an interface'", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535377167", "createdAt": "2020-12-03T16:17:43Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -1,13 +1,113 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n import lombok.Getter;\n \n-public class FrankDocGroup {\n+/**\n+ * Holds a group of FrankElement objects for the Frank!Doc website.\n+ * This website will show a table-of-contents with the groups. When you\n+ * select a group, the FrankElement objects inside will be shown.\n+ * <p>\n+ * There are two kinds of groups that are represented by two subclasses of\n+ * {@link FrankDocGroup} that are also inner classes, namely\n+ * <code>FromType</code> and <code>Other</code>. <code>FromType</code>\n+ * holds a group that has the classes of an {@link ElementType}.\n+ * <code>Other</code> holds a group of remaining {@link FrankElement}\n+ * that can be part of different {@link ElementType} objects.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4MDU4OA==", "bodyText": "De reden om de attributes niet te kunnen modificeren is er niet meer. Of is er nog een andere reden?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535380588", "createdAt": "2020-12-03T16:22:09Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,231 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\n+\t// Represents the Java superclass.\n+\tprivate @Getter FrankElement parent;\n+\n+\tprivate LinkedHashMap<String, FrankAttribute> attributes;\n+\tprivate LinkedHashMap<ConfigChild.Key, ConfigChild> configChildren;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NzA5MDcx", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-544709071", "createdAt": "2020-12-04T07:23:22Z", "commit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzoyMzoyM1rOH_D_Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzoyMzoyM1rOH_D_Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4NzcxNQ==", "bodyText": "Als je in ElementChild een Kind maakt, zoals:\nenum Kind {\n\tATTRIBUTE,\n\tCONFIGCHILD;\n}\n\nen ElementChild een getKind() geeft, dan kan je in FrankElement:\nprivate LinkedHashMap<String, FrankAttribute> attributes;\nprivate LinkedHashMap<ConfigChild.Key, ConfigChild> configChildren;\n\nvervangen door:\nprivate Map<Kind, LinkedHashMap<Object, ElementChild>> children;\n\nJe kan dan heel veel code die je nu apart hebt uitgeschreven voor Attributes en ConfigChildren op het niveau van ElementChild brengen.\nBijvoorbeeld:\nFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n\treturn attributes.get(attribute.getKey());\n}\n\nConfigChild findConfigChildMatch(ConfigChild configChild) {\n\treturn configChildren.get(configChild.getKey());\n}\n\nvervangen door\n<C extends ElementChild> C findElementChild(C child) {\n\treturn children.get(child.getKind()).get(child.getKey());\n}\n\nJe hoeft dan ook geen elementChild instanceof meer te doen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535887715", "createdAt": "2020-12-04T07:23:23Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,231 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\n+\t// Represents the Java superclass.\n+\tprivate @Getter FrankElement parent;\n+\n+\tprivate LinkedHashMap<String, FrankAttribute> attributes;\n+\tprivate LinkedHashMap<ConfigChild.Key, ConfigChild> configChildren;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5e8fa9d9c6f42148c8940ff0629d7eb3e5db263", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/f5e8fa9d9c6f42148c8940ff0629d7eb3e5db263", "committedDate": "2020-12-04T08:44:27Z", "message": "Merge branch 'master' into fillDataModel4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfb14837ba6ec9da30667fdf1c14f07e4169dba3", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/cfb14837ba6ec9da30667fdf1c14f07e4169dba3", "committedDate": "2020-12-04T08:53:16Z", "message": "Remove obsolete comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6f69409afe10d6f16fb7f469772cd3c82adcbe4", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/a6f69409afe10d6f16fb7f469772cd3c82adcbe4", "committedDate": "2020-12-04T09:22:00Z", "message": "Fix documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c47648ca7106b3116de75621ec8f4aefad7b90cd", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c47648ca7106b3116de75621ec8f4aefad7b90cd", "committedDate": "2020-12-04T10:07:04Z", "message": "Removed unused type argument T of ElementChild"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49de83b4d520696ce1ad29ec157c6b84c2811293", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/49de83b4d520696ce1ad29ec157c6b84c2811293", "committedDate": "2020-12-04T11:15:57Z", "message": "Remove type argument K from ElementChild"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ac7137eee271ec1c3396dc873266fab10b28c02", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/0ac7137eee271ec1c3396dc873266fab10b28c02", "committedDate": "2020-12-04T12:12:24Z", "message": "Make common logic for config children and attributes in FrankElement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa13e63c0a53f9c0b17f8b665dd1351421372cfc", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/fa13e63c0a53f9c0b17f8b665dd1351421372cfc", "committedDate": "2020-12-04T12:54:44Z", "message": "Remove getAttributes() and getConfigChildren() without predicate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c61ea434d430051261716c91140e822403b7f98", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/3c61ea434d430051261716c91140e822403b7f98", "committedDate": "2020-12-04T13:04:31Z", "message": "Add warning when overridden from deprecated ElementChild"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0OTU0MzUx", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-544954351", "createdAt": "2020-12-04T13:23:52Z", "commit": {"oid": "3c61ea434d430051261716c91140e822403b7f98"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzoyMzo1M1rOH_QumQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzozMjoxMVrOH_RCCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5NjQwOQ==", "bodyText": "Deze doe je ook al op regel 60", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r536096409", "createdAt": "2020-12-04T13:23:53Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -57,7 +86,7 @@ public static FrankDocModel populate() {\n \n \tpublic FrankDocModel() {\n \t\tconfigChildDescriptors = new HashMap<>();\n-\t\tgroups = new HashMap<>();\n+\t\tgroups = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c61ea434d430051261716c91140e822403b7f98"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMTM4Nw==", "bodyText": "hasNoConfigChildren is hier eigenlijk: hasNoElementChildrenOfKind", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r536101387", "createdAt": "2020-12-04T13:32:11Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/GroupCreator.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import nl.nn.adapterframework.doc.model.CumulativeChildHandler;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Helper class for building attribute groups and config child groups from the model.\n+ * See {@link DocWriterNew} to understand what we try to achieve.\n+ *\n+ * @author martijn\n+ *\n+ */\n+class GroupCreator<T extends ElementChild> {\n+\tstatic interface Callback<T extends ElementChild> extends CumulativeChildHandler<T> {\n+\t\tList<T> getChildrenOf(FrankElement elem);\n+\t\tFrankElement getAncestorOf(FrankElement elem);\n+\t\tvoid addDeclaredGroup();\n+\t\tvoid addCumulativeGroup();\n+\t\tvoid addDeclaredGroupRef(FrankElement referee);\n+\t\tvoid addCumulativeGroupRef(FrankElement referee);\n+\t}\n+\n+\tprivate FrankElement frankElement;\n+\tprivate Callback<T> callback;\n+\tprivate Consumer<Callback<T>> cumulativeGroupTrigger;\n+\n+\tGroupCreator(\n+\t\t\tFrankElement frankElement,\n+\t\t\tConsumer<Callback<T>> cumulativeGroupTrigger,\n+\t\t\tCallback<T> callback) {\n+\t\tthis.frankElement = frankElement;\n+\t\tthis.cumulativeGroupTrigger = cumulativeGroupTrigger;\n+\t\tthis.callback = callback;\n+\t}\n+\n+\tvoid run() {\n+\t\tboolean hasNoConfigChildren = callback.getChildrenOf(frankElement).isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c61ea434d430051261716c91140e822403b7f98"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b923ad6407f0c84124beea27d129934a32e853ac", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/b923ad6407f0c84124beea27d129934a32e853ac", "committedDate": "2020-12-04T16:45:53Z", "message": "Deprecation should not inherit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6d7892abf92082aa4e28079c69e255d4c494b54", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c6d7892abf92082aa4e28079c69e255d4c494b54", "committedDate": "2020-12-07T10:11:07Z", "message": "Follow up small review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c855863f4f3dba92856a0ec10a51b6ed35fe5fe", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/4c855863f4f3dba92856a0ec10a51b6ed35fe5fe", "committedDate": "2020-12-07T13:51:18Z", "message": "Calculate the syntax 2 xsd name of a FrankElement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44d04fb72fd6a983e48a44437e921e02b06da1eb", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/44d04fb72fd6a983e48a44437e921e02b06da1eb", "committedDate": "2020-12-07T16:09:45Z", "message": "Register syntax 1 name with ElementChild"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75b2992ff345ee93dc62f47664ad0983c2a00568", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/75b2992ff345ee93dc62f47664ad0983c2a00568", "committedDate": "2020-12-07T16:29:31Z", "message": "Add extra test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MzIwODM3", "url": "https://github.com/ibissource/iaf/pull/1239#pullrequestreview-546320837", "createdAt": "2020-12-07T16:31:44Z", "commit": {"oid": "44d04fb72fd6a983e48a44437e921e02b06da1eb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjozMTo0NVrOIAvWTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjozNDowNlrOIAvdJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY0NjY2OA==", "bodyText": "Volgens mij is recursie niet nodig. Uit het ElementType genereer je groepen voor elke syntax1naam. Die groepen bevatten een choice van elementen met een samengestelde naam (bijv. JavaErrorSender) en een verwijzing naar een complex-type. Die complex-types zijn voor elke syntax1naam binnen het ElementType hetzelfde, en kunnen dus gedeeld worden.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r537646668", "createdAt": "2020-12-07T16:31:45Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -113,6 +113,29 @@ public int compareTo(ElementChild other) {\n \t\treturn CONFIG_CHILD_COMPARATOR.compare(this, (ConfigChild) other);\n \t}\n \n+\t/**\n+\t * Registers the syntax 1 name of this {@link ConfigChild} with the\n+\t * {@link ElementType}. This is done recursively because the XSD does\n+\t * not only use the declared config children, but also the inherited\n+\t * config children of a {@link FrankElement}. For each combination of\n+\t * a syntax 1 name and an {@link ElementChild}, we have &lt;xs:group&gt;\n+\t * declarations in the XSD. The recursion ensures that references to\n+\t * ancestor groups are valid.\n+\t */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d04fb72fd6a983e48a44437e921e02b06da1eb"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY0ODQyMg==", "bodyText": "Als je in plaats van een TreeSet een LinkedHashSet gebruikt, blijft de volgorde van toevoegen behouden. Dan komt Sender voor ErrorSender, en dat is prettig.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r537648422", "createdAt": "2020-12-07T16:34:06Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "diffHunk": "@@ -35,6 +37,15 @@\n \tprivate @Getter String simpleName;\n \tprivate @Getter Map<String, FrankElement> members;\n \tprivate @Getter boolean fromJavaInterface;\n+\t\n+\t/**\n+\t * For each syntax 1 name in this set, an &lt;xs:choice&gt; of &lt;xs:element&gt;\n+\t * is created in the XSD. The elements in a group correspond to the Java\n+\t * classes that implement the Java interface represented by this {@link ElementChild}.\n+\t * For each syntax 1 name a different group is needed because the syntax 2\n+\t * names of the elements are different.\n+\t */\n+\tprivate @Getter Set<String> configChildSyntax1Names = new TreeSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d04fb72fd6a983e48a44437e921e02b06da1eb"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e29c7782a7a1427ab08782b85acebe9f0a6491d", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/6e29c7782a7a1427ab08782b85acebe9f0a6491d", "committedDate": "2020-12-08T11:22:06Z", "message": "Produce XSD that can validate in online tester\n\nNot all unit tests succeed yet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b583ca7f9b7c3655928eb6f03b44541b787d65dc", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/b583ca7f9b7c3655928eb6f03b44541b787d65dc", "committedDate": "2020-12-08T11:55:59Z", "message": "Add the fixed attributes that we need now\n\nNot yet for the root element"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60f9307a0e507ccfe6a97c586d0c06bf829b7e1a", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/60f9307a0e507ccfe6a97c586d0c06bf829b7e1a", "committedDate": "2020-12-08T15:02:48Z", "message": "Omit abstracts from ElementGroup and extend ElementGroup with generic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bc1961a55622cfa69c0ed3409a7525ea94323eb", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/4bc1961a55622cfa69c0ed3409a7525ea94323eb", "committedDate": "2020-12-08T17:40:38Z", "message": "Fixed unit tests, a few small review comments followed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e775f9de02e7a6605748434c656854a5d667da31", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/e775f9de02e7a6605748434c656854a5d667da31", "committedDate": "2020-12-08T19:36:19Z", "message": "Start improving the doc of DocWriterNew, not yet OK"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55581441ea385a3ffe6b3de193ab57848d2e6791", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/55581441ea385a3ffe6b3de193ab57848d2e6791", "committedDate": "2020-12-10T09:09:32Z", "message": "Remove dead code about aliases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b4125074744207945aadeeffa412e514b08cbbb", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/3b4125074744207945aadeeffa412e514b08cbbb", "committedDate": "2020-12-10T10:34:02Z", "message": "Add required and fixed modifiers to attributes as requested"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e20d090e43cf9a2ba46b445d09160eb0330a7b2", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/5e20d090e43cf9a2ba46b445d09160eb0330a7b2", "committedDate": "2020-12-10T10:46:55Z", "message": "Simplify element group names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "122b64900678d06b5eec90d7f595ea221533f6eb", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/122b64900678d06b5eec90d7f595ea221533f6eb", "committedDate": "2020-12-10T13:31:09Z", "message": "Add the creatingElementType to FrankElement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c11f26806cda49ed848c84e2777bc72ac9826329", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c11f26806cda49ed848c84e2777bc72ac9826329", "committedDate": "2020-12-10T14:27:49Z", "message": "Revert \"Add the creatingElementType to FrankElement\"\n\nThis reverts commit 122b64900678d06b5eec90d7f595ea221533f6eb."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec8f8c376b6acadab3039a328ab1cb6b68f916a9", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/ec8f8c376b6acadab3039a328ab1cb6b68f916a9", "committedDate": "2020-12-10T19:19:08Z", "message": "Omit FrankElement complex type and groups when possible"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53fb8f241917ad11417a1e05b2e3dff82a6d0cac", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/53fb8f241917ad11417a1e05b2e3dff82a6d0cac", "committedDate": "2020-12-10T21:05:54Z", "message": "Fix name clash for listener element groups - still hacky"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95472834490481ae9c4c08c2bfa0f5ab3b5374b0", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/95472834490481ae9c4c08c2bfa0f5ab3b5374b0", "committedDate": "2020-12-10T21:09:09Z", "message": "Fix warning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea0d442c84b0aa9a4757d7a8bce687edd9cce48f", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/ea0d442c84b0aa9a4757d7a8bce687edd9cce48f", "committedDate": "2020-12-11T11:15:25Z", "message": "Code class ElementTypeRole with unit test coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5038380a83ae53d537321cedfdf1b668fb12567", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/e5038380a83ae53d537321cedfdf1b668fb12567", "committedDate": "2020-12-11T11:30:14Z", "message": "Add Key class to ElementTypeRole"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57b901a498e1271f25414720ca9374c6d65e81c7", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/57b901a498e1271f25414720ca9374c6d65e81c7", "committedDate": "2020-12-11T13:53:36Z", "message": "Let FrankDocModel create ElementTypeRole objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4018f3263a519e7cf03369bd852d9eba0964f27c", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/4018f3263a519e7cf03369bd852d9eba0964f27c", "committedDate": "2020-12-11T14:50:14Z", "message": "Move statics of ElementTypeRole to a factory class"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1033, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}