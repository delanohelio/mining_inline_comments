{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NTkyMTAy", "number": 1113, "title": "Frank!Doc: Fill data model", "bodyText": "", "createdAt": "2020-09-30T15:23:55Z", "url": "https://github.com/ibissource/iaf/pull/1113", "merged": true, "mergeCommit": {"oid": "852aa6b33d8048323aeda9beb3203a56cbf9bd77"}, "closed": true, "closedAt": "2020-10-13T14:02:14Z", "author": {"login": "mhdirkse"}, "timelineItems": {"totalCount": 54, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdNm9UOgH2gAyNDk1NTkyMTAyOjg0NjMyNTliNGYxOTIwNDdmY2MzNTE4NGQ3ODlmYzNlNmYzZDA4M2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSJETVgFqTUwNzQ2OTMxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8463259b4f192047fcc35184d789fc3e6f3d083e", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/8463259b4f192047fcc35184d789fc3e6f3d083e", "committedDate": "2020-09-29T12:01:37Z", "message": "Work in progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abdb9a7c018578f68c372a7a2a3ab5828d750ec7", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/abdb9a7c018578f68c372a7a2a3ab5828d750ec7", "committedDate": "2020-09-30T07:23:28Z", "message": "Merge branch 'master' into fillDataModel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dab922ce4448c29616046936b3b7abf57adf3731", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/dab922ce4448c29616046936b3b7abf57adf3731", "committedDate": "2020-09-30T11:03:26Z", "message": "Make a start with filling the data model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6f1c6d5bd1065868537317f648b2e10f1881434", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/e6f1c6d5bd1065868537317f648b2e10f1881434", "committedDate": "2020-09-30T13:03:58Z", "message": "Move sorting SpringBeans to the test - sorting is not relevant outside the test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fc99fae1eaa68809d31597a5b686a18be6dcea2", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/2fc99fae1eaa68809d31597a5b686a18be6dcea2", "committedDate": "2020-09-30T15:22:45Z", "message": "Build a rudimentary FrankDocModel"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMDUwNTg0", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-500050584", "createdAt": "2020-10-01T06:49:17Z", "commit": {"oid": "2fc99fae1eaa68809d31597a5b686a18be6dcea2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNjo0OToxOFrOHa8nuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNjo0OToxOFrOHa8nuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxODIzNQ==", "bodyText": "Als je een exceptie gooit, dan altijd een concrete foutmelding, waar degene die hem ziet iets aan heeft om het probleem op te lossen", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498018235", "createdAt": "2020-10-01T06:49:18Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tstatic class AttributeSeed {\n+\t\tprivate @Getter String name;\n+\n+\t\tAttributeSeed(Method reflectMethod) {\n+\t\t\tname = reflectMethod.getName();\n+\t\t}\n+\n+\t\tAttributeSeed(String name) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\t}\n+\n+\tstatic class ElementSeed {\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methods;\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methodsWithInherited;\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter @Setter String simpleName;\n+\n+\t\tElementSeed(Class<?> clazz) {\n+\t\t\tmethods = new HashMap<>();\n+\t\t\tfor(Method reflect: clazz.getDeclaredMethods()) {\n+\t\t\t\t// Jacoco is a tool for code coverage. To have predictible results,\n+\t\t\t\t// we omit methods introduced by Jacoco.\n+\t\t\t\tif(reflect.getName().contains(\"jacoco\")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tmethods.put(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tmethodsWithInherited = new HashMap<>();\n+\t\t\tmethodsWithInherited.putAll(methods);\n+\t\t\tfor(Method reflect: clazz.getMethods()) {\n+\t\t\t\tmethodsWithInherited.putIfAbsent(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tfullName = clazz.getName();\n+\t\t\tsimpleName = clazz.getSimpleName();\n+\t\t}\n+\n+\t\tElementSeed(final String fullName) {\n+\t\t\tthis.fullName = fullName;\n+\t\t}\n+\t}\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc99fae1eaa68809d31597a5b686a18be6dcea2"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMDUxNzcx", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-500051771", "createdAt": "2020-10-01T06:51:25Z", "commit": {"oid": "2fc99fae1eaa68809d31597a5b686a18be6dcea2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNjo1MToyNVrOHa8ruA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNjo1MToyNVrOHa8ruA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxOTI1Ng==", "bodyText": "Ik denk dat het duidelijker / inzichtelijker is als deze code een method asFrankElement() is van ElementSeed,", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498019256", "createdAt": "2020-10-01T06:51:25Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tstatic class AttributeSeed {\n+\t\tprivate @Getter String name;\n+\n+\t\tAttributeSeed(Method reflectMethod) {\n+\t\t\tname = reflectMethod.getName();\n+\t\t}\n+\n+\t\tAttributeSeed(String name) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\t}\n+\n+\tstatic class ElementSeed {\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methods;\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methodsWithInherited;\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter @Setter String simpleName;\n+\n+\t\tElementSeed(Class<?> clazz) {\n+\t\t\tmethods = new HashMap<>();\n+\t\t\tfor(Method reflect: clazz.getDeclaredMethods()) {\n+\t\t\t\t// Jacoco is a tool for code coverage. To have predictible results,\n+\t\t\t\t// we omit methods introduced by Jacoco.\n+\t\t\t\tif(reflect.getName().contains(\"jacoco\")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tmethods.put(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tmethodsWithInherited = new HashMap<>();\n+\t\t\tmethodsWithInherited.putAll(methods);\n+\t\t\tfor(Method reflect: clazz.getMethods()) {\n+\t\t\t\tmethodsWithInherited.putIfAbsent(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tfullName = clazz.getName();\n+\t\t\tsimpleName = clazz.getSimpleName();\n+\t\t}\n+\n+\t\tElementSeed(final String fullName) {\n+\t\t\tthis.fullName = fullName;\n+\t\t}\n+\t}\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException();\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"Only retrieve Spring beans from an interface\");\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic List<ElementSeed> getSelfAndAncestorSeeds(Class<?> clazz) {\n+\t\tList<ElementSeed> result = new ArrayList<>();\n+\t\tresult.add(new ElementSeed(clazz));\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\twhile(superClass != null) {\n+\t\t\tresult.add(new ElementSeed(superClass));\n+\t\t\tsuperClass = superClass.getSuperclass();\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());\n+\t\tmodel.getGroups().add(group);\n+\t\treturn group;\n+\t}\n+\n+\tvoid addElementsToGroup(List<ElementSeed> elementHierarchy, FrankDocGroup group) {\n+\t\tList<ElementSeed> reversedSeeds = new ArrayList<>(elementHierarchy);\n+\t\tCollections.reverse(reversedSeeds);\n+\t\tFrankElement parent = null;\n+\t\tfor(ElementSeed seed: reversedSeeds) {\n+\t\t\tif(model.getAllElements().containsKey(seed.getFullName())) {\n+\t\t\t\tparent = model.getAllElements().get(seed.getFullName());\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tparent = createFrankElement(seed, parent);\n+\t\t\t\tmodel.getAllElements().put(parent.getFullName(), parent);\n+\t\t\t}\n+\t\t}\n+\t\tgroup.getElements().putIfAbsent(parent.getFullName(), parent);\n+\t}\n+\n+\tFrankElement createFrankElement(ElementSeed seed, FrankElement parent) {\n+\t\tFrankElement result = new FrankElement(seed.getFullName(), seed.getSimpleName());\n+\t\tresult.setParent(parent);\n+\t\tresult.setAttributes(createAttributes(seed));\n+\t\treturn result;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc99fae1eaa68809d31597a5b686a18be6dcea2"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMDU1NTU3", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-500055557", "createdAt": "2020-10-01T06:58:22Z", "commit": {"oid": "2fc99fae1eaa68809d31597a5b686a18be6dcea2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNjo1ODoyMlrOHa84Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNjo1ODoyMlrOHa84Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAyMjQwMw==", "bodyText": "Waarom haal je de inherited methods op? Dat moet de ElementSeed van de super class doen.\nElementSeed moet niets weten van inherited methods.", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498022403", "createdAt": "2020-10-01T06:58:22Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tstatic class AttributeSeed {\n+\t\tprivate @Getter String name;\n+\n+\t\tAttributeSeed(Method reflectMethod) {\n+\t\t\tname = reflectMethod.getName();\n+\t\t}\n+\n+\t\tAttributeSeed(String name) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\t}\n+\n+\tstatic class ElementSeed {\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methods;\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methodsWithInherited;\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter @Setter String simpleName;\n+\n+\t\tElementSeed(Class<?> clazz) {\n+\t\t\tmethods = new HashMap<>();\n+\t\t\tfor(Method reflect: clazz.getDeclaredMethods()) {\n+\t\t\t\t// Jacoco is a tool for code coverage. To have predictible results,\n+\t\t\t\t// we omit methods introduced by Jacoco.\n+\t\t\t\tif(reflect.getName().contains(\"jacoco\")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tmethods.put(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tmethodsWithInherited = new HashMap<>();\n+\t\t\tmethodsWithInherited.putAll(methods);\n+\t\t\tfor(Method reflect: clazz.getMethods()) {\n+\t\t\t\tmethodsWithInherited.putIfAbsent(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc99fae1eaa68809d31597a5b686a18be6dcea2"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7f73fd6e4fe3ac145947a5de607524f2cc15a6a", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/e7f73fd6e4fe3ac145947a5de607524f2cc15a6a", "committedDate": "2020-10-01T07:04:51Z", "message": "Attributes start with a lower-case letter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMDcxMTA5", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-500071109", "createdAt": "2020-10-01T07:23:46Z", "commit": {"oid": "2fc99fae1eaa68809d31597a5b686a18be6dcea2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzoyMzo0N1rOHa9orQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzoyMzo0N1rOHa9orQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNDg2MQ==", "bodyText": "Je moet niet 'altijd' de superclasses gaan verwerken. Als je dat doet, doe je het veel te vaak.\nJe moet zorgen dat je elke class maar \u00e9\u00e9n keer verwerkt.", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r498034861", "createdAt": "2020-10-01T07:23:47Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tstatic class AttributeSeed {\n+\t\tprivate @Getter String name;\n+\n+\t\tAttributeSeed(Method reflectMethod) {\n+\t\t\tname = reflectMethod.getName();\n+\t\t}\n+\n+\t\tAttributeSeed(String name) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\t}\n+\n+\tstatic class ElementSeed {\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methods;\n+\t\tprivate @Getter @Setter Map<String, AttributeSeed> methodsWithInherited;\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter @Setter String simpleName;\n+\n+\t\tElementSeed(Class<?> clazz) {\n+\t\t\tmethods = new HashMap<>();\n+\t\t\tfor(Method reflect: clazz.getDeclaredMethods()) {\n+\t\t\t\t// Jacoco is a tool for code coverage. To have predictible results,\n+\t\t\t\t// we omit methods introduced by Jacoco.\n+\t\t\t\tif(reflect.getName().contains(\"jacoco\")) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tmethods.put(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tmethodsWithInherited = new HashMap<>();\n+\t\t\tmethodsWithInherited.putAll(methods);\n+\t\t\tfor(Method reflect: clazz.getMethods()) {\n+\t\t\t\tmethodsWithInherited.putIfAbsent(reflect.getName(), new AttributeSeed(reflect));\n+\t\t\t}\n+\t\t\tfullName = clazz.getName();\n+\t\t\tsimpleName = clazz.getSimpleName();\n+\t\t}\n+\n+\t\tElementSeed(final String fullName) {\n+\t\t\tthis.fullName = fullName;\n+\t\t}\n+\t}\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException();\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"Only retrieve Spring beans from an interface\");\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic List<ElementSeed> getSelfAndAncestorSeeds(Class<?> clazz) {\n+\t\tList<ElementSeed> result = new ArrayList<>();\n+\t\tresult.add(new ElementSeed(clazz));\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\twhile(superClass != null) {\n+\t\t\tresult.add(new ElementSeed(superClass));\n+\t\t\tsuperClass = superClass.getSuperclass();\n+\t\t}\n+\t\treturn result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc99fae1eaa68809d31597a5b686a18be6dcea2"}, "originalPosition": 101}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a22264a1ee8184d834014ebedcb30c049781933", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/8a22264a1ee8184d834014ebedcb30c049781933", "committedDate": "2020-10-01T07:53:51Z", "message": "Attribute x exists if you have setX and isX"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f6c2dd487ab5da45b2b7cc3334045a56257edff", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/6f6c2dd487ab5da45b2b7cc3334045a56257edff", "committedDate": "2020-10-01T08:00:23Z", "message": "Improve code quality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "040c09e5ed307c81b7f31877ee4854c0115cc68c", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/040c09e5ed307c81b7f31877ee4854c0115cc68c", "committedDate": "2020-10-01T11:49:24Z", "message": "Add type checks to finding attributes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6725e41c1c322eee587c3f06423d6fef4a246b6e", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/6725e41c1c322eee587c3f06423d6fef4a246b6e", "committedDate": "2020-10-01T14:48:46Z", "message": "Process classes only once for creating FrankElement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72f06d92421900e566d1c186efec59dff8d2131a", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/72f06d92421900e566d1c186efec59dff8d2131a", "committedDate": "2020-10-01T15:26:59Z", "message": "Do not work with inherited methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c56c079b075854cca0d31e3fae55c1fd7ee545a", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/3c56c079b075854cca0d31e3fae55c1fd7ee545a", "committedDate": "2020-10-02T16:43:23Z", "message": "Remove the rejected seed classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e471d20f971b13a58cd32e656d59c7056edcb430", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/e471d20f971b13a58cd32e656d59c7056edcb430", "committedDate": "2020-10-02T16:49:13Z", "message": "Rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67112f84216f355029d684df1555af10d821032f", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/67112f84216f355029d684df1555af10d821032f", "committedDate": "2020-10-02T16:57:16Z", "message": "Follow up comment that thrown exceptions should be informative"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1609989cd66f838d92e67ede44ed39cee5af9f5e", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/1609989cd66f838d92e67ede44ed39cee5af9f5e", "committedDate": "2020-10-05T07:28:42Z", "message": "Merge branch 'master' into fillDataModel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c219a723912ed9c46a66fbb406635cb6d47f694a", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c219a723912ed9c46a66fbb406635cb6d47f694a", "committedDate": "2020-10-05T09:27:29Z", "message": "Set default AttributeReferenceGroup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b13e446c3c957a0b3943ac1ea34ff6bd002cbfd1", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/b13e446c3c957a0b3943ac1ea34ff6bd002cbfd1", "committedDate": "2020-10-05T09:47:21Z", "message": "Revert \"Set default AttributeReferenceGroup\"\n\nThis reverts commit c219a723912ed9c46a66fbb406635cb6d47f694a."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f0ecd8a7006e28c77e8980d0b1a4eb6a0b0b7c3", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/9f0ecd8a7006e28c77e8980d0b1a4eb6a0b0b7c3", "committedDate": "2020-10-05T10:04:09Z", "message": "Add describingElement to FrankAttribute\n\nStill without parsing @IbisDocRef, so at this stage we assume that the\ndescribingElement equals the owning element."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea9e64275cfabef4d91dae12393b36d83bf6b800", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/ea9e64275cfabef4d91dae12393b36d83bf6b800", "committedDate": "2020-10-05T14:42:07Z", "message": "Parse @IbisDoc annotation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d03ccc5d5a35e27f7cd406f3928c18666a040ea", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/2d03ccc5d5a35e27f7cd406f3928c18666a040ea", "committedDate": "2020-10-05T15:20:48Z", "message": "Renames"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c44111ba60f9a587b0afe45f459da5f965ddf0c9", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c44111ba60f9a587b0afe45f459da5f965ddf0c9", "committedDate": "2020-10-05T17:28:48Z", "message": "Finish parsing @IbisDoc and @IbisDocRef"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMTE0MTY0", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-503114164", "createdAt": "2020-10-06T15:50:05Z", "commit": {"oid": "c44111ba60f9a587b0afe45f459da5f965ddf0c9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo1MDowNVrOHdOiWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNjoyMDozOVrOHdP0oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODkyMg==", "bodyText": "Wat beschrijft dit?", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500408922", "createdAt": "2020-10-06T15:50:05Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.Map;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class FrankDocGroup {\n+\tprivate @Getter String name;\n+\tprivate @Getter @Setter String digesterRulesRef;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c44111ba60f9a587b0afe45f459da5f965ddf0c9"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNDc1Ng==", "bodyText": "Dit moet een method van FrankDocModel zijn", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500414756", "createdAt": "2020-10-06T15:58:13Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c44111ba60f9a587b0afe45f459da5f965ddf0c9"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNTExMw==", "bodyText": "Dit moet onderdeel van de constructor van de FrankDocGroup zijn", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500415113", "createdAt": "2020-10-06T15:58:42Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c44111ba60f9a587b0afe45f459da5f965ddf0c9"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxOTIwMQ==", "bodyText": "Dit zou een method van FrankDocModel moeten zijn, en dan findOrCreateFrankElement() moeten heten", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500419201", "createdAt": "2020-10-06T16:04:22Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());\n+\t\tmodel.getGroups().add(group);\n+\t\treturn group;\n+\t}\n+\n+\tvoid addElementsToGroup(Class<?> clazz, FrankDocGroup group) {\n+\t\tgroup.getElements().put(clazz.getName(), frankElement(clazz));\n+\t}\n+\n+\tFrankElement frankElement(Class<?> clazz) {\n+\t\tif(model.getAllElements().containsKey(clazz.getName())) {\n+\t\t\treturn model.getAllElements().get(clazz.getName());\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c44111ba60f9a587b0afe45f459da5f965ddf0c9"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyNDIxOA==", "bodyText": "Volgens mij kan je hier volstaan met:\nClass<?> superClass = clazz.getSuperclass()\nFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\nFrankElement current = createFrankElement(clazz, parent);\nmodel.getAllElements().put(clazz.getName(), current );", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500424218", "createdAt": "2020-10-06T16:11:54Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());\n+\t\tmodel.getGroups().add(group);\n+\t\treturn group;\n+\t}\n+\n+\tvoid addElementsToGroup(Class<?> clazz, FrankDocGroup group) {\n+\t\tgroup.getElements().put(clazz.getName(), frankElement(clazz));\n+\t}\n+\n+\tFrankElement frankElement(Class<?> clazz) {\n+\t\tif(model.getAllElements().containsKey(clazz.getName())) {\n+\t\t\treturn model.getAllElements().get(clazz.getName());\n+\t\t}\n+\t\tList<Class<?>> classesForNewElements = new ArrayList<>();\n+\t\tFrankElement parent = null;\n+\t\tClass<?> superClass = clazz;\n+\t\twhile(true) {\n+\t\t\tclassesForNewElements.add(superClass);\n+\t\t\tsuperClass = superClass.getSuperclass();\n+\t\t\tif(superClass == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(model.getAllElements().containsKey(superClass.getName())) {\n+\t\t\t\tparent = model.getAllElements().get(superClass.getName());\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tCollections.reverse(classesForNewElements);\n+\t\tfor(Class<?> seed: classesForNewElements) {\n+\t\t\tparent = createFrankElement(seed, parent);\n+\t\t\tmodel.getAllElements().put(parent.getFullName(), parent);\n+\t\t}\n+\t\treturn parent;\t\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c44111ba60f9a587b0afe45f459da5f965ddf0c9"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTMyMA==", "bodyText": "Waarom test je of er ook een getter is bij de setter? Dat is toch niet nodig?\nJe zou hoogstens een warning kunnen geven als er een getter is van een ander type dan de setter, want dat geeft problemen bij het laden van de configuratie.\nEn ook nog: als je zo'n test doet zoals hier, dan moet je niet eerst je hele candidate opbouwen en daarna pas checken of je hem wilt hebben, maar eerst die check doen.", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500429320", "createdAt": "2020-10-06T16:19:44Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());\n+\t\tmodel.getGroups().add(group);\n+\t\treturn group;\n+\t}\n+\n+\tvoid addElementsToGroup(Class<?> clazz, FrankDocGroup group) {\n+\t\tgroup.getElements().put(clazz.getName(), frankElement(clazz));\n+\t}\n+\n+\tFrankElement frankElement(Class<?> clazz) {\n+\t\tif(model.getAllElements().containsKey(clazz.getName())) {\n+\t\t\treturn model.getAllElements().get(clazz.getName());\n+\t\t}\n+\t\tList<Class<?>> classesForNewElements = new ArrayList<>();\n+\t\tFrankElement parent = null;\n+\t\tClass<?> superClass = clazz;\n+\t\twhile(true) {\n+\t\t\tclassesForNewElements.add(superClass);\n+\t\t\tsuperClass = superClass.getSuperclass();\n+\t\t\tif(superClass == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(model.getAllElements().containsKey(superClass.getName())) {\n+\t\t\t\tparent = model.getAllElements().get(superClass.getName());\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tCollections.reverse(classesForNewElements);\n+\t\tfor(Class<?> seed: classesForNewElements) {\n+\t\t\tparent = createFrankElement(seed, parent);\n+\t\t\tmodel.getAllElements().put(parent.getFullName(), parent);\n+\t\t}\n+\t\treturn parent;\t\t\n+\t}\n+\n+\tFrankElement createFrankElement(Class<?> clazz, FrankElement parent) {\n+\t\tFrankElement result = new FrankElement(clazz.getName(), clazz.getSimpleName());\n+\t\tresult.setParent(parent);\n+\t\tresult.setAttributes(createAttributes(result, clazz.getDeclaredMethods()));\n+\t\treturn result;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(FrankElement frankElement, Method[] methods) {\n+\t\tMap<String, String> setterAttributes = getAttributeToMethodNameMap(methods, \"set\");\n+\t\tMap<String, String> getterAttributes = getAttributeToMethodNameMap(methods, \"get\");\n+\t\tgetterAttributes.putAll(getAttributeToMethodNameMap(methods, \"is\"));\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String candidateAttributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(candidateAttributeName), candidateAttributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString candidateAttributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tFrankAttribute candidate = new FrankAttribute(candidateAttributeName);\n+\t\t\t\tcandidate.setDescribingElement(frankElement);\n+\t\t\t\tboolean isDocumented = documentAttribute(candidate, method);\n+\t\t\t\tif(getterAttributes.containsKey(candidateAttributeName) || isDocumented) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c44111ba60f9a587b0afe45f459da5f965ddf0c9"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyOTk4NA==", "bodyText": "Dit moet een method van FrankElement zijn", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r500429984", "createdAt": "2020-10-06T16:20:39Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,265 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class ModelBuilder {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(ModelBuilder.class);\n+\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t\tmodel.setGroups(new ArrayList<>());\n+\t\tmodel.setAllElements(new HashMap<>());\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = InfoBuilderSource.getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tFrankDocGroup addGroup(String name) {\n+\t\tFrankDocGroup group = new FrankDocGroup(name);\n+\t\tgroup.setElements(new HashMap<>());\n+\t\tmodel.getGroups().add(group);\n+\t\treturn group;\n+\t}\n+\n+\tvoid addElementsToGroup(Class<?> clazz, FrankDocGroup group) {\n+\t\tgroup.getElements().put(clazz.getName(), frankElement(clazz));\n+\t}\n+\n+\tFrankElement frankElement(Class<?> clazz) {\n+\t\tif(model.getAllElements().containsKey(clazz.getName())) {\n+\t\t\treturn model.getAllElements().get(clazz.getName());\n+\t\t}\n+\t\tList<Class<?>> classesForNewElements = new ArrayList<>();\n+\t\tFrankElement parent = null;\n+\t\tClass<?> superClass = clazz;\n+\t\twhile(true) {\n+\t\t\tclassesForNewElements.add(superClass);\n+\t\t\tsuperClass = superClass.getSuperclass();\n+\t\t\tif(superClass == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(model.getAllElements().containsKey(superClass.getName())) {\n+\t\t\t\tparent = model.getAllElements().get(superClass.getName());\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tCollections.reverse(classesForNewElements);\n+\t\tfor(Class<?> seed: classesForNewElements) {\n+\t\t\tparent = createFrankElement(seed, parent);\n+\t\t\tmodel.getAllElements().put(parent.getFullName(), parent);\n+\t\t}\n+\t\treturn parent;\t\t\n+\t}\n+\n+\tFrankElement createFrankElement(Class<?> clazz, FrankElement parent) {\n+\t\tFrankElement result = new FrankElement(clazz.getName(), clazz.getSimpleName());\n+\t\tresult.setParent(parent);\n+\t\tresult.setAttributes(createAttributes(result, clazz.getDeclaredMethods()));\n+\t\treturn result;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(FrankElement frankElement, Method[] methods) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c44111ba60f9a587b0afe45f459da5f965ddf0c9"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70222206d0c49546900f0330f4bbef0e8db9fc1a", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/70222206d0c49546900f0330f4bbef0e8db9fc1a", "committedDate": "2020-10-06T17:05:49Z", "message": "Fix the tests to check that the parent of a FrankElement is set"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d25b2217460e60b695ff6d1259f415da0e3325cc", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/d25b2217460e60b695ff6d1259f415da0e3325cc", "committedDate": "2020-10-07T07:13:52Z", "message": "Improve implementation of method frankElement()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fbb8b04a2c32a1f5cb72e4e1b53ce693ba85f23", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/3fbb8b04a2c32a1f5cb72e4e1b53ce693ba85f23", "committedDate": "2020-10-07T07:26:57Z", "message": "Remove field digesterRulesRef"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11e714107e7aa1c801fb41342a06ddafbaace195", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/11e714107e7aa1c801fb41342a06ddafbaace195", "committedDate": "2020-10-07T15:34:42Z", "message": "Add warnings to the log for irregularities in attribute methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bdbfa8a2a5d74063e0d9734d171045188e74f7c", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/9bdbfa8a2a5d74063e0d9734d171045188e74f7c", "committedDate": "2020-10-08T15:02:33Z", "message": "Setter without getter is attribute, and fix logging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37117d7bdc24b8f4c062a0b64293144b8faf16bd", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/37117d7bdc24b8f4c062a0b64293144b8faf16bd", "committedDate": "2020-10-08T15:09:44Z", "message": "Write a log message if an attribute has no getter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6c3e5d8c26335fb870f8624f49f13b2c561b8c4", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/e6c3e5d8c26335fb870f8624f49f13b2c561b8c4", "committedDate": "2020-10-08T16:22:18Z", "message": "Move construction logic of FrankElement to that class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c7191224c232b31e9f4bc28581877f539da289f", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/1c7191224c232b31e9f4bc28581877f539da289f", "committedDate": "2020-10-08T16:27:11Z", "message": "Remove setters from FrankElement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0d00be211e43cc1857a0369e4dc4f7b74e157fa", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/c0d00be211e43cc1857a0369e4dc4f7b74e157fa", "committedDate": "2020-10-08T16:41:16Z", "message": "Move frankElement() to FrankDocModel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "957c234780d27e630642b72eeb654d7ecbb2e74f", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/957c234780d27e630642b72eeb654d7ecbb2e74f", "committedDate": "2020-10-08T16:47:09Z", "message": "Improve constructors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/0f9c6bc6c9eec77c0673c8ce540e3a980fd75340", "committedDate": "2020-10-08T16:54:17Z", "message": "Move addGroup() to the model class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1NDQ4MDEz", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-505448013", "createdAt": "2020-10-09T08:04:31Z", "commit": {"oid": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwODowNDozMVrOHe_U8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwODo0MTozOVrOHfAnIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI1Njg4Mg==", "bodyText": "Dit kan beter een method addAsElement() van FrankDocGroup zijn", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502256882", "createdAt": "2020-10-09T08:04:31Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.doc.model.FrankDocGroup;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {\n+\t\tClass<?> interfaze = getClass(interfaceName);\n+\t\tif(interfaze == null) {\n+\t\t\tthrow new NullPointerException(\"Class or interface is not available on the classpath: \" + interfaceName);\n+\t\t}\n+\t\tif(!interfaze.isInterface()) {\n+\t\t\tthrow new IllegalArgumentException(\"This exists on the classpath but is not an interface: \" + interfaceName);\n+\t\t}\n+\t\tSet<SpringBean> unfiltered = InfoBuilderSource.getSpringBeans(interfaze);\n+\t\tList<SpringBean> result = new ArrayList<SpringBean>();\n+\t\tfor(SpringBean b: unfiltered) {\n+\t\t\tif(interfaze.isAssignableFrom(b.getClazz())) {\n+\t\t\t\tresult.add(b);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tvoid addElementsToGroup(Class<?> clazz, FrankDocGroup group) {\n+\t\tgroup.getElements().put(clazz.getName(), model.frankElement(clazz));\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI2MjE4OA==", "bodyText": "Dit moet een method van FrankDocModel zijn, en dan findOrCreateFrankElement() heten.\nJe hebt dan ook het FrankElementStore interface niet nodig.", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502262188", "createdAt": "2020-10-09T08:13:31Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI2NjIwMA==", "bodyText": "Heb je deze constructor zonder parent nu al nodig?", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502266200", "createdAt": "2020-10-09T08:20:27Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent, FrankElementStore store) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t\tthis.attributes = createAttributes(clazz.getDeclaredMethods(), store);\n+\t}\n+\n+\tFrankElement(final String fullName, final String simpleName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI2NzE3NQ==", "bodyText": "Deze warning moet er niet zijn.", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502267175", "createdAt": "2020-10-09T08:22:17Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent, FrankElementStore store) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t\tthis.attributes = createAttributes(clazz.getDeclaredMethods(), store);\n+\t}\n+\n+\tFrankElement(final String fullName, final String simpleName) {\n+\t\tthis.fullName = fullName;\n+\t\tthis.simpleName = simpleName;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElementStore store) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName));\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(String.format(\"FrankElement %s and attribute %s: no getter method\",\n+\t\t\t\t\t\t\tsimpleName, attributeName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3NDU1Nw==", "bodyText": "Deze method moet verhuizen naar FrankAttribute, en dan parseIbisDocAnnotation() heten.", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502274557", "createdAt": "2020-10-09T08:35:50Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent, FrankElementStore store) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t\tthis.attributes = createAttributes(clazz.getDeclaredMethods(), store);\n+\t}\n+\n+\tFrankElement(final String fullName, final String simpleName) {\n+\t\tthis.fullName = fullName;\n+\t\tthis.simpleName = simpleName;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElementStore store) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName));\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(String.format(\"FrankElement %s and attribute %s: no getter method\",\n+\t\t\t\t\t\t\tsimpleName, attributeName));\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(this);\n+\t\t\t\tdocumentAttribute(attribute, method, store);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tsimpleName, isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankElement::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tsimpleName, setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElementStore store) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(frankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass(), store));\n+\t\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t\t\tif(parsed.hasOrder) {\n+\t\t\t\t\tattribute.setOrder(parsed.getOrder());\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\tif(ibisDoc != null) {\n+\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(\"No documentation available for FrankElement %s, attribute %s\",\n+\t\t\t\t\tsimpleName, attribute.getName()));\n+\t\t}\n+\t}\n+\n+\tprivate class ParsedIbisDocRef {\n+\t\tprivate @Getter @Setter boolean hasOrder;\n+\t\tprivate @Getter @Setter int order;\n+\t\tprivate @Getter @Setter Method referredMethod;\n+\t}\n+\n+\tprivate ParsedIbisDocRef parseIbisDocRef(IbisDocRef ibisDocRef, Method originalMethod) {\n+\t\tParsedIbisDocRef result = new ParsedIbisDocRef();\n+\t\tresult.setHasOrder(false);\n+\t\tString[] values = ibisDocRef.value();\n+\t\tString methodString = null;\n+\t\tif (values.length == 1) {\n+\t\t\tmethodString = ibisDocRef.value()[0];\n+\t\t} else if (values.length == 2) {\n+\t\t\tmethodString = ibisDocRef.value()[1];\n+\t\t\ttry {\n+\t\t\t\tresult.setOrder(Integer.parseInt(ibisDocRef.value()[0]));\n+\t\t\t\tresult.setHasOrder(true);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tlog.warn(String.format(\"Could not parse order in @IbisDocRef annotation: \"\n+\t\t\t\t\t\t+ Integer.parseInt(ibisDocRef.value()[0])));\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(String.format(\"Invalid @IbisDocRef annotation on method: %s.%s\",\n+\t\t\t\t\toriginalMethod.getDeclaringClass().getName(), originalMethod.getName())));\n+\t\t\treturn null;\n+\t\t}\n+\t\tresult.setReferredMethod(getReferredMethod(methodString, originalMethod));\n+\t\treturn result;\n+\t}\n+\n+\tprivate static Method getReferredMethod(String methodString, Method originalMethod) {\n+\t\tString lastNameComponent = methodString.substring(methodString.lastIndexOf(\".\") + 1).trim();\n+\t\tchar firstLetter = lastNameComponent.toCharArray()[0];\n+\t\tString fullClassName = methodString;\n+\t\tString methodName = lastNameComponent;\n+\t\tif (Character.isLowerCase(firstLetter)) {\n+\t\t\tint index = methodString.lastIndexOf(\".\");\n+\t\t\tfullClassName = methodString.substring(0, index);\n+\t\t} else {\n+\t\t\tmethodName = originalMethod.getName();\n+\t\t}\n+\t\treturn getParentMethod(fullClassName, methodName);\n+\t}\n+\n+\tprivate static Method getParentMethod(String className, String methodName) {\n+\t\ttry {\n+\t\t\tClass<?> parentClass = Class.forName(className);\n+\t\t\tfor (Method parentMethod : parentClass.getMethods()) {\n+\t\t\t\tif (parentMethod.getName().equals(methodName)) {\n+\t\t\t\t\treturn parentMethod;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tlog.warn(String.format(\"Super class [\" + e + \"] was not found!\"));\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprivate void ibisDocIntoFrankElement(IbisDoc ibisDoc, FrankAttribute attribute) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3NTk4NQ==", "bodyText": "Het is niet 'e' die niet gevonden is, maar 'className'", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502275985", "createdAt": "2020-10-09T08:38:24Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent, FrankElementStore store) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t\tthis.attributes = createAttributes(clazz.getDeclaredMethods(), store);\n+\t}\n+\n+\tFrankElement(final String fullName, final String simpleName) {\n+\t\tthis.fullName = fullName;\n+\t\tthis.simpleName = simpleName;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElementStore store) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName));\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(String.format(\"FrankElement %s and attribute %s: no getter method\",\n+\t\t\t\t\t\t\tsimpleName, attributeName));\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(this);\n+\t\t\t\tdocumentAttribute(attribute, method, store);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tsimpleName, isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankElement::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tsimpleName, setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElementStore store) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(frankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass(), store));\n+\t\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t\t\tif(parsed.hasOrder) {\n+\t\t\t\t\tattribute.setOrder(parsed.getOrder());\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\tif(ibisDoc != null) {\n+\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(\"No documentation available for FrankElement %s, attribute %s\",\n+\t\t\t\t\tsimpleName, attribute.getName()));\n+\t\t}\n+\t}\n+\n+\tprivate class ParsedIbisDocRef {\n+\t\tprivate @Getter @Setter boolean hasOrder;\n+\t\tprivate @Getter @Setter int order;\n+\t\tprivate @Getter @Setter Method referredMethod;\n+\t}\n+\n+\tprivate ParsedIbisDocRef parseIbisDocRef(IbisDocRef ibisDocRef, Method originalMethod) {\n+\t\tParsedIbisDocRef result = new ParsedIbisDocRef();\n+\t\tresult.setHasOrder(false);\n+\t\tString[] values = ibisDocRef.value();\n+\t\tString methodString = null;\n+\t\tif (values.length == 1) {\n+\t\t\tmethodString = ibisDocRef.value()[0];\n+\t\t} else if (values.length == 2) {\n+\t\t\tmethodString = ibisDocRef.value()[1];\n+\t\t\ttry {\n+\t\t\t\tresult.setOrder(Integer.parseInt(ibisDocRef.value()[0]));\n+\t\t\t\tresult.setHasOrder(true);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tlog.warn(String.format(\"Could not parse order in @IbisDocRef annotation: \"\n+\t\t\t\t\t\t+ Integer.parseInt(ibisDocRef.value()[0])));\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(String.format(\"Invalid @IbisDocRef annotation on method: %s.%s\",\n+\t\t\t\t\toriginalMethod.getDeclaringClass().getName(), originalMethod.getName())));\n+\t\t\treturn null;\n+\t\t}\n+\t\tresult.setReferredMethod(getReferredMethod(methodString, originalMethod));\n+\t\treturn result;\n+\t}\n+\n+\tprivate static Method getReferredMethod(String methodString, Method originalMethod) {\n+\t\tString lastNameComponent = methodString.substring(methodString.lastIndexOf(\".\") + 1).trim();\n+\t\tchar firstLetter = lastNameComponent.toCharArray()[0];\n+\t\tString fullClassName = methodString;\n+\t\tString methodName = lastNameComponent;\n+\t\tif (Character.isLowerCase(firstLetter)) {\n+\t\t\tint index = methodString.lastIndexOf(\".\");\n+\t\t\tfullClassName = methodString.substring(0, index);\n+\t\t} else {\n+\t\t\tmethodName = originalMethod.getName();\n+\t\t}\n+\t\treturn getParentMethod(fullClassName, methodName);\n+\t}\n+\n+\tprivate static Method getParentMethod(String className, String methodName) {\n+\t\ttry {\n+\t\t\tClass<?> parentClass = Class.forName(className);\n+\t\t\tfor (Method parentMethod : parentClass.getMethods()) {\n+\t\t\t\tif (parentMethod.getName().equals(methodName)) {\n+\t\t\t\t\treturn parentMethod;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tlog.warn(String.format(\"Super class [\" + e + \"] was not found!\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3NzkyMA==", "bodyText": "Waarom is hij invalid? Laat dat weten in de foutmelding! Zoiets als: 'too many parameters in declaration'", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r502277920", "createdAt": "2020-10-09T08:41:39Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\n+\tpublic interface FrankElementStore {\n+\t\tboolean hasFrankElement(String name);\n+\t\tFrankElement getFrankElement(String name);\n+\t\tvoid addFrankElement(FrankElement frankElement);\n+\t\tint numFrankElements();\n+\t}\n+\n+\tpublic static FrankElement frankElement(Class<?> clazz, FrankElementStore store) {\n+\t\tif(store.hasFrankElement(clazz.getName())) {\n+\t\t\treturn store.getFrankElement(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : frankElement(superClass, store);\n+\t\tFrankElement current = new FrankElement(clazz, parent, store);\n+\t\tstore.addFrankElement(current);\n+\t\treturn current;\n+\t}\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent, FrankElementStore store) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t\tthis.attributes = createAttributes(clazz.getDeclaredMethods(), store);\n+\t}\n+\n+\tFrankElement(final String fullName, final String simpleName) {\n+\t\tthis.fullName = fullName;\n+\t\tthis.simpleName = simpleName;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElementStore store) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName));\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(String.format(\"FrankElement %s and attribute %s: no getter method\",\n+\t\t\t\t\t\t\tsimpleName, attributeName));\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(this);\n+\t\t\t\tdocumentAttribute(attribute, method, store);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tsimpleName, isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankElement::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tsimpleName, setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElementStore store) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(frankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass(), store));\n+\t\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t\t\tif(parsed.hasOrder) {\n+\t\t\t\t\tattribute.setOrder(parsed.getOrder());\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\tif(ibisDoc != null) {\n+\t\t\tibisDocIntoFrankElement(ibisDoc, attribute);\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(\"No documentation available for FrankElement %s, attribute %s\",\n+\t\t\t\t\tsimpleName, attribute.getName()));\n+\t\t}\n+\t}\n+\n+\tprivate class ParsedIbisDocRef {\n+\t\tprivate @Getter @Setter boolean hasOrder;\n+\t\tprivate @Getter @Setter int order;\n+\t\tprivate @Getter @Setter Method referredMethod;\n+\t}\n+\n+\tprivate ParsedIbisDocRef parseIbisDocRef(IbisDocRef ibisDocRef, Method originalMethod) {\n+\t\tParsedIbisDocRef result = new ParsedIbisDocRef();\n+\t\tresult.setHasOrder(false);\n+\t\tString[] values = ibisDocRef.value();\n+\t\tString methodString = null;\n+\t\tif (values.length == 1) {\n+\t\t\tmethodString = ibisDocRef.value()[0];\n+\t\t} else if (values.length == 2) {\n+\t\t\tmethodString = ibisDocRef.value()[1];\n+\t\t\ttry {\n+\t\t\t\tresult.setOrder(Integer.parseInt(ibisDocRef.value()[0]));\n+\t\t\t\tresult.setHasOrder(true);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tlog.warn(String.format(\"Could not parse order in @IbisDocRef annotation: \"\n+\t\t\t\t\t\t+ Integer.parseInt(ibisDocRef.value()[0])));\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(String.format(\"Invalid @IbisDocRef annotation on method: %s.%s\",\n+\t\t\t\t\toriginalMethod.getDeclaringClass().getName(), originalMethod.getName())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f9c6bc6c9eec77c0673c8ce540e3a980fd75340"}, "originalPosition": 190}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6914867e72e83b4abad9356720ee07f11b48478", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/b6914867e72e83b4abad9356720ee07f11b48478", "committedDate": "2020-10-09T11:37:00Z", "message": "Apply review comments.\n\nTODO: Reorganize tests to match the way classes were reorganized"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "843e0f45448a6fef45bc990e53af525a1384cfbd", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/843e0f45448a6fef45bc990e53af525a1384cfbd", "committedDate": "2020-10-09T12:39:48Z", "message": "FrankElementTest to FrankModelTest, maybe more than Eclipse rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/b4d3816722edebfbc592a2cd3ca3020892bb6b7e", "committedDate": "2020-10-09T15:17:59Z", "message": "In FrankDocGroup, introduce addAsElement()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MzQwMTMw", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-506340130", "createdAt": "2020-10-12T07:00:39Z", "commit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwNzowMDozOVrOHfxZIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwNzoyNzoxMVrOHfyKEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3NzE1NA==", "bodyText": "waarom itereer je hier niet over setterAttributes?", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503077154", "createdAt": "2020-10-12T07:00:39Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3ODIxNQ==", "bodyText": "Deze method zou je kunnen hernoemen in 'checkForTypeConflict()', zodat je weet wat je kan verwachten.", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503078215", "createdAt": "2020-10-12T07:03:14Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3OTE1Ng==", "bodyText": "Ik denk dat het op z'n plaats is als attributeOwner als argument van de constructor wordt meegegeven.", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503079156", "createdAt": "2020-10-12T07:05:10Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3OTgyOA==", "bodyText": "Parameters in log regels zetten we in het framework altijd tussen vierkante haken", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503079828", "createdAt": "2020-10-12T07:06:41Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3OTkyOA==", "bodyText": "Parameters in log regels zetten we in het framework altijd tussen vierkante haken", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503079928", "createdAt": "2020-10-12T07:06:52Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4MDM1NQ==", "bodyText": "Dit mag op \u00e9\u00e9n regel", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503080355", "createdAt": "2020-10-12T07:07:39Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElement attributeOwner) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4MDkxMw==", "bodyText": "Dit mag op \u00e9\u00e9n regel", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503080913", "createdAt": "2020-10-12T07:09:00Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElement attributeOwner) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(findOrCreateFrankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4Mzk5MA==", "bodyText": "Dit mag op \u00e9\u00e9n regel", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503083990", "createdAt": "2020-10-12T07:15:29Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElement attributeOwner) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(findOrCreateFrankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass()));\n+\t\t\t\tattribute.parseIbisDocAnnotation(ibisDoc);\n+\t\t\t\tif(parsed.hasOrder) {\n+\t\t\t\t\tattribute.setOrder(parsed.getOrder());\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\tif(ibisDoc != null) {\n+\t\t\tattribute.parseIbisDocAnnotation(ibisDoc);\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(\"No documentation available for FrankElement %s, attribute %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), attribute.getName()));\n+\t\t}\n+\t}\n+\n+\tprivate class ParsedIbisDocRef {\n+\t\tprivate @Getter @Setter boolean hasOrder;\n+\t\tprivate @Getter @Setter int order;\n+\t\tprivate @Getter @Setter Method referredMethod;\n+\t}\n+\n+\tprivate ParsedIbisDocRef parseIbisDocRef(IbisDocRef ibisDocRef, Method originalMethod) {\n+\t\tParsedIbisDocRef result = new ParsedIbisDocRef();\n+\t\tresult.setHasOrder(false);\n+\t\tString[] values = ibisDocRef.value();\n+\t\tString methodString = null;\n+\t\tif (values.length == 1) {\n+\t\t\tmethodString = ibisDocRef.value()[0];\n+\t\t} else if (values.length == 2) {\n+\t\t\tmethodString = ibisDocRef.value()[1];\n+\t\t\ttry {\n+\t\t\t\tresult.setOrder(Integer.parseInt(ibisDocRef.value()[0]));\n+\t\t\t\tresult.setHasOrder(true);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tlog.warn(String.format(\"Could not parse order in @IbisDocRef annotation: \"\n+\t\t\t\t\t\t+ Integer.parseInt(ibisDocRef.value()[0])));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4OTM0OA==", "bodyText": "Ik zie deze method nog niet buiten de tests gebruikt worden. Is er logica of configuratie die bepaalt welke groepen er zijn?", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503089348", "createdAt": "2020-10-12T07:26:30Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {\n+\t\t\t\tString attributeName = setterToAttributeName.get(method.getName());\n+\t\t\t\tif(getterAttributes.containsKey(attributeName)) {\n+\t\t\t\t\tcompareGetterWithSetter(method, getterAttributes.get(attributeName), attributeOwner);\n+\t\t\t\t}\n+\t\t\t\tFrankAttribute attribute = new FrankAttribute(attributeName);\n+\t\t\t\tattribute.setDescribingElement(attributeOwner);\n+\t\t\t\tdocumentAttribute(attribute, method, attributeOwner);\n+\t\t\t\tresult.add(attribute);\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate Map<String, Method> getGetterAndIsserAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> getterAttributes = getAttributeToMethodMap(methods, \"get\");\n+\t\tMap<String, Method> isserAttributes = getAttributeToMethodMap(methods, \"is\");\n+\t\tfor(String isserAttributeName : isserAttributes.keySet()) {\n+\t\t\tif(getterAttributes.containsKey(isserAttributeName)) {\n+\t\t\t\tlog.warn(String.format(\"For FrankElement %s, attribute %s has both a getX and an isX method\",\n+\t\t\t\t\t\tattributeOwner.getSimpleName(), isserAttributeName));\n+\t\t\t} else {\n+\t\t\t\tgetterAttributes.put(isserAttributeName, isserAttributes.get(isserAttributeName));\n+\t\t\t}\n+\t\t}\n+\t\treturn getterAttributes;\n+\t}\n+\n+\tstatic Map<String, Method> getAttributeToMethodMap(Method[] methods, String prefix) {\n+\t\tList<Method> methodList = Arrays.asList(methods);\n+\t\tmethodList = methodList.stream()\n+\t\t\t\t.filter(FrankDocModel::isGetterOrSetter)\n+\t\t\t\t.filter(m -> m.getName().startsWith(prefix) && (m.getName().length() > prefix.length()))\n+\t\t\t\t.collect(Collectors.toList());\t\t\n+\t\tMap<String, Method> result = new HashMap<>();\n+\t\tfor(Method method: methodList) {\n+\t\t\tString strippedName = method.getName().substring(prefix.length());\n+\t\t\tString attributeName = strippedName.substring(0, 1).toLowerCase() + strippedName.substring(1);\n+\t\t\tresult.put(attributeName, method);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic boolean isGetterOrSetter(Method method) {\n+\t\tboolean isSetter = method.getReturnType().isPrimitive()\n+\t\t\t\t&& method.getReturnType().getName().equals(\"void\")\n+\t\t\t\t&& (method.getParameterTypes().length == 1)\n+\t\t\t\t&& (method.getParameterTypes()[0].isPrimitive()\n+\t\t\t\t\t\t|| method.getParameterTypes()[0].getName().equals(JAVA_STRING));\n+\t\tboolean isGetter = (\n+\t\t\t\t\tmethod.getReturnType().isPrimitive()\n+\t\t\t\t\t|| method.getReturnType().getName().equals(JAVA_STRING)\n+\t\t\t\t) && (method.getParameterTypes().length == 0);\n+\t\treturn isSetter || isGetter;\n+\t}\n+\n+\tprivate void compareGetterWithSetter(Method setter, Method getter, FrankElement attributeOwner) {\n+\t\tString setterType = setter.getParameterTypes()[0].getName();\n+\t\tString getterType = getter.getReturnType().getName();\n+\t\tif(! getterType.equals(setterType)) {\n+\t\t\tlog.warn(String.format(\"In Frank element %s: setter %s has type %s while the getter has type %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), setter.getName(), setterType, getterType));\n+\t\t}\n+\t}\n+\n+\tprivate void documentAttribute(\n+\t\t\tFrankAttribute attribute,\n+\t\t\tMethod method,\n+\t\t\tFrankElement attributeOwner) {\n+\t\tattribute.setDeprecated(AnnotationUtils.findAnnotation(method, Deprecated.class) != null);\n+\t\tIbisDocRef ibisDocRef = AnnotationUtils.findAnnotation(method, IbisDocRef.class);\n+\t\tif(ibisDocRef != null) {\n+\t\t\tParsedIbisDocRef parsed = parseIbisDocRef(ibisDocRef, method);\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(parsed.getReferredMethod(), IbisDoc.class);\n+\t\t\tif(ibisDoc != null) {\n+\t\t\t\tattribute.setDescribingElement(findOrCreateFrankElement(\n+\t\t\t\t\t\tparsed.getReferredMethod().getDeclaringClass()));\n+\t\t\t\tattribute.parseIbisDocAnnotation(ibisDoc);\n+\t\t\t\tif(parsed.hasOrder) {\n+\t\t\t\t\tattribute.setOrder(parsed.getOrder());\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\tif(ibisDoc != null) {\n+\t\t\tattribute.parseIbisDocAnnotation(ibisDoc);\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(\"No documentation available for FrankElement %s, attribute %s\",\n+\t\t\t\t\tattributeOwner.getSimpleName(), attribute.getName()));\n+\t\t}\n+\t}\n+\n+\tprivate class ParsedIbisDocRef {\n+\t\tprivate @Getter @Setter boolean hasOrder;\n+\t\tprivate @Getter @Setter int order;\n+\t\tprivate @Getter @Setter Method referredMethod;\n+\t}\n+\n+\tprivate ParsedIbisDocRef parseIbisDocRef(IbisDocRef ibisDocRef, Method originalMethod) {\n+\t\tParsedIbisDocRef result = new ParsedIbisDocRef();\n+\t\tresult.setHasOrder(false);\n+\t\tString[] values = ibisDocRef.value();\n+\t\tString methodString = null;\n+\t\tif (values.length == 1) {\n+\t\t\tmethodString = ibisDocRef.value()[0];\n+\t\t} else if (values.length == 2) {\n+\t\t\tmethodString = ibisDocRef.value()[1];\n+\t\t\ttry {\n+\t\t\t\tresult.setOrder(Integer.parseInt(ibisDocRef.value()[0]));\n+\t\t\t\tresult.setHasOrder(true);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tlog.warn(String.format(\"Could not parse order in @IbisDocRef annotation: \"\n+\t\t\t\t\t\t+ Integer.parseInt(ibisDocRef.value()[0])));\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tlog.warn(String.format(String.format(\"Too many or zero parameters in @IbisDocRef annotation on method: %s.%s\",\n+\t\t\t\t\toriginalMethod.getDeclaringClass().getName(), originalMethod.getName())));\n+\t\t\treturn null;\n+\t\t}\n+\t\tresult.setReferredMethod(getReferredMethod(methodString, originalMethod));\n+\t\treturn result;\n+\t}\n+\n+\tprivate static Method getReferredMethod(String methodString, Method originalMethod) {\n+\t\tString lastNameComponent = methodString.substring(methodString.lastIndexOf(\".\") + 1).trim();\n+\t\tchar firstLetter = lastNameComponent.toCharArray()[0];\n+\t\tString fullClassName = methodString;\n+\t\tString methodName = lastNameComponent;\n+\t\tif (Character.isLowerCase(firstLetter)) {\n+\t\t\tint index = methodString.lastIndexOf(\".\");\n+\t\t\tfullClassName = methodString.substring(0, index);\n+\t\t} else {\n+\t\t\tmethodName = originalMethod.getName();\n+\t\t}\n+\t\treturn getParentMethod(fullClassName, methodName);\n+\t}\n+\n+\tprivate static Method getParentMethod(String className, String methodName) {\n+\t\ttry {\n+\t\t\tClass<?> parentClass = Class.forName(className);\n+\t\t\tfor (Method parentMethod : parentClass.getMethods()) {\n+\t\t\t\tif (parentMethod.getName().equals(methodName)) {\n+\t\t\t\t\treturn parentMethod;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tlog.warn(\"Super class [\" + className + \"] was not found!\");\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tpublic FrankDocGroup addGroup(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4OTY4MQ==", "bodyText": "Ik zie deze method nog niet gebruikt worden buiten de tests. Is er logica of configuratie die bepaalt welke element er in een groep zitten?", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503089681", "createdAt": "2020-10-12T07:27:11Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.Getter;\n+\n+public class FrankDocGroup {\n+\tprivate @Getter String name;\n+\tprivate @Getter Map<String, FrankElement> elements;\n+\n+\tpublic FrankDocGroup(String name) {\n+\t\tthis.name = name;\n+\t\tthis.elements = new HashMap<>();\n+\t}\n+\n+\tpublic void addAsElement(Class<?> clazz, FrankDocModel model) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a98c33b865a6b8489b4d77b3e7f7048ce1d9f0ec", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/a98c33b865a6b8489b4d77b3e7f7048ce1d9f0ec", "committedDate": "2020-10-12T09:06:59Z", "message": "Work in progress: process review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a1c13e80a9fca05ada7b51c20e2ba8d75596626", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/3a1c13e80a9fca05ada7b51c20e2ba8d75596626", "committedDate": "2020-10-12T09:22:46Z", "message": "Fix ModelBuilderTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6c5b1b5a768eb7d249827b92d7957fee5af54f2", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/a6c5b1b5a768eb7d249827b92d7957fee5af54f2", "committedDate": "2020-10-12T09:28:43Z", "message": "Fix FrankDocGroupTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97c6bccf97feca0bb184fc99de84fd71b48c0232", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/97c6bccf97feca0bb184fc99de84fd71b48c0232", "committedDate": "2020-10-12T10:57:21Z", "message": "Finish recreating the testtarget classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ed3b79322b36ad019db49504436c8a696c37b8c", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/1ed3b79322b36ad019db49504436c8a696c37b8c", "committedDate": "2020-10-12T10:59:10Z", "message": "Merge branch 'fixTestTargetWasNotCheckedIn' into fillDataModel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78a635b7f2d38f47fae0518a1ba081825a15930b", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/78a635b7f2d38f47fae0518a1ba081825a15930b", "committedDate": "2020-10-12T11:19:27Z", "message": "Fix bug."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTk2OTk1", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-506596995", "createdAt": "2020-10-12T12:59:48Z", "commit": {"oid": "78a635b7f2d38f47fae0518a1ba081825a15930b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjo1OTo0OFrOHf9t9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMzoxMjo1NVrOHf-MHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3OTA5NA==", "bodyText": "Je kan dan beter op regel 88 een LinkedHashMap gebruiken. Die volgt bij itereren de volgorde van toevoegen aan de collectie.\nJe kan dan hier wel direct over setterAttributes iterereren. Dat maakt de code beter te begrijpen.\nsetterToAttributeName kan dan vervallen", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503279094", "createdAt": "2020-10-12T12:59:48Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {\n+\t\tMap<String, Method> setterAttributes = getAttributeToMethodMap(methods, \"set\");\n+\t\tMap<String, Method> getterAttributes = getGetterAndIsserAttributes(methods, attributeOwner);\n+\t\tMap<String, String> setterToAttributeName = new HashMap<>();\n+\t\tfor(String attributeName: setterAttributes.keySet()) {\n+\t\t\tsetterToAttributeName.put(setterAttributes.get(attributeName).getName(), attributeName);\n+\t\t}\n+\t\tList<FrankAttribute> result = new ArrayList<>();\n+\t\tfor(Method method: methods) {\n+\t\t\tif(setterToAttributeName.containsKey(method.getName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3NzE1NA=="}, "originalCommit": {"oid": "b4d3816722edebfbc592a2cd3ca3020892bb6b7e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI4NDk4Nw==", "bodyText": "voor assertEquals() en assertSame() kan je static imports maken:\nimport static org.junit.Assert.assertEquals;\n\nAls je in de editor assertEquals<Ctrl-Space> typet, komt dat vanzelf.\nIn de code is dat herkenbaarder, en daardoor beter leesbaar", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503284987", "createdAt": "2020-10-12T13:09:47Z", "author": {"login": "gvanbrakel"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/FrankDocGroupTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.Map;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import nl.nn.adapterframework.doc.ModelBuilder;\n+\n+public class FrankDocGroupTest {\n+\tpublic static final String SIMPLE = \"nl.nn.adapterframework.doc.testtarget.simple\";\n+\tprivate static final String PARENT = SIMPLE + \".ListenerParent\";\n+\tprivate static final String CHILD = SIMPLE + \".ListenerChild\";\n+\n+\t@Test\n+\tpublic void whenChildElementAddedBeforeParentThenCorrectModel() {\n+\t\tModelBuilder builder = new ModelBuilder();\n+\t\tFrankDocGroup group = builder.getModel().addGroup(\"Listeners\");\n+\t\tgroup.addAsElement(ModelBuilder.getClass(CHILD), builder.getModel());\n+\t\tgroup.addAsElement(ModelBuilder.getClass(PARENT), builder.getModel());\n+\t\tcheckModelAfterChildAndParentAdded(builder.getModel());\n+\t}\n+\n+\t@Test\n+\tpublic void whenParentElementAddedBeforeChildThenCorrectModel() {\n+\t\tModelBuilder builder = new ModelBuilder();\n+\t\tFrankDocGroup group = builder.getModel().addGroup(\"Listeners\");\n+\t\tgroup.addAsElement(ModelBuilder.getClass(PARENT), builder.getModel());\n+\t\tgroup.addAsElement(ModelBuilder.getClass(CHILD), builder.getModel());\n+\t\tcheckModelAfterChildAndParentAdded(builder.getModel());\n+\t}\n+\n+\tprivate void checkModelAfterChildAndParentAdded(FrankDocModel model) {\n+\t\tAssert.assertEquals(1, model.getGroups().size());\n+\t\tFrankDocGroup actualGroup = model.getGroups().get(0);\n+\t\tMap<String, FrankElement> actualAllElements = model.getAllElements();\n+\t\tAssert.assertTrue(actualGroup.getElements().containsKey(PARENT));\n+\t\tAssert.assertTrue(actualGroup.getElements().containsKey(CHILD));\n+\t\tfor(String elementInGroup: actualGroup.getElements().keySet()) {\n+\t\t\tFrankElement groupElement = actualGroup.getElements().get(elementInGroup);\n+\t\t\tFrankElement allElement = actualAllElements.get(elementInGroup);\n+\t\t\tAssert.assertSame(\n+\t\t\t\t\t\"Different objects for group element and all element for element name: \" + elementInGroup,\n+\t\t\t\t\tgroupElement, allElement);\n+\t\t}\n+\t\tFrankElement actualObject = model.getAllElements().get(\"java.lang.Object\");\n+\t\tAssert.assertNull(actualObject.getParent());\n+\t\tFrankElement actualParent = actualGroup.getElements().get(PARENT);\n+\t\tAssert.assertSame(actualObject, actualParent.getParent());\n+\t\tAssert.assertEquals(PARENT, actualParent.getFullName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78a635b7f2d38f47fae0518a1ba081825a15930b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI4NjgxNA==", "bodyText": "Ik vind het prettiger om een javadoc te lezen die beschrijft wat de method doet, in plaats van dat te moeten reconstrueren uit de @param en @return tag", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503286814", "createdAt": "2020-10-12T13:12:55Z", "author": {"login": "gvanbrakel"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/FrankDocModelTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import nl.nn.adapterframework.doc.ModelBuilder;\n+\n+public class FrankDocModelTest {\n+\tprivate static final String IBISDOCREF = \"nl.nn.adapterframework.doc.testtarget.ibisdocref\";\n+\tprivate static final String REFERRED_CHILD = IBISDOCREF + \".ChildTarget\";\n+\tprivate static final String REFERRED_PARENT = IBISDOCREF + \".ParentTarget\";\n+\n+\tprivate FrankDocModel instance;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tinstance = new FrankDocModel();\n+\t}\n+\n+\t@Test\n+\tpublic void whenSetterAndGetterThenAttribute() {\n+\t\tcheckReflectAttributeCreated(\"attributeSetterGetter\");\n+\t}\n+\n+\tprivate FrankAttribute checkReflectAttributeCreated(String attributeName) {\n+\t\tMap<String, FrankAttribute> actual = getReflectInvestigatedFrankAttributes();\n+\t\tAssert.assertTrue(actual.containsKey(attributeName));\n+\t\tAssert.assertEquals(attributeName, actual.get(attributeName).getName());\n+\t\treturn actual.get(attributeName);\n+\t}\n+\n+\tprivate Map<String, FrankAttribute> getReflectInvestigatedFrankAttributes() {\n+\t\treturn getAttributesOfClass(\"nl.nn.adapterframework.doc.testtarget.reflect.FrankAttributeTarget\");\n+\t}\n+\n+\t/**\n+\t * @param className The name of the Class<?> to get FrankAttribute objects for.\n+\t * @return The FrankAttributes that ModelBuilder can produce from a Class<?>. Note\n+\t * that the describingElement is not set, because we are not testing here in relation\n+\t * to creating the enclosing FrankElement of the attributes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78a635b7f2d38f47fae0518a1ba081825a15930b"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "491491975a96054bd4513b4429f1a3309409534f", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/491491975a96054bd4513b4429f1a3309409534f", "committedDate": "2020-10-12T15:58:32Z", "message": "Follow-up review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MTcxMzI5", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-507171329", "createdAt": "2020-10-13T08:06:31Z", "commit": {"oid": "491491975a96054bd4513b4429f1a3309409534f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwODowNjozMVrOHgaY6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwODoyMTowNFrOHga-aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0ODg0MA==", "bodyText": "public/private ?", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503748840", "createdAt": "2020-10-13T08:06:31Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();\n+\t}\n+\n+\t/**\n+\t * @param interfaceName The interface for which we want SpringBean objects.\n+\t * @return All classes implementing interfaceName, ordered by their full class name.\n+\t */\n+\tstatic List<SpringBean> getSpringBeans(final String interfaceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "491491975a96054bd4513b4429f1a3309409534f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0OTMyMQ==", "bodyText": "Wat doet dit? Ik zie 2 static methodes die hier niets mee (kunnen) doen.", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503749321", "createdAt": "2020-10-13T08:07:16Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/ModelBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import lombok.Getter;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.objects.SpringBean;\n+\n+public class ModelBuilder {\n+\tprivate @Getter FrankDocModel model;\n+\n+\tpublic ModelBuilder() {\n+\t\tmodel = new FrankDocModel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "491491975a96054bd4513b4429f1a3309409534f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1NjU0OA==", "bodyText": "De code ziet er vrij complex uit, is het niet een stuk handig als je Spring BeanUtils#getPropertyDescriptors() gebuikt om een lijst met alle PropertyDescriptors terug te krijgen waar je over kan itereren?", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503756548", "createdAt": "2020-10-13T08:18:08Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.springframework.core.annotation.AnnotationUtils;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.IbisDoc;\n+import nl.nn.adapterframework.doc.IbisDocRef;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+public class FrankDocModel {\n+\tprivate static final String JAVA_STRING = \"java.lang.String\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n+\n+\tprivate @Getter List<FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n+\n+\tpublic FrankDocModel() {\n+\t\tgroups = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement findOrCreateFrankElement(Class<?> clazz) {\n+\t\tif(allElements.containsKey(clazz.getName())) {\n+\t\t\treturn allElements.get(clazz.getName());\n+\t\t}\n+\t\tClass<?> superClass = clazz.getSuperclass();\n+\t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n+\t\tFrankElement current = new FrankElement(clazz, parent);\n+\t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n+\t\tallElements.put(current.getFullName(), current);\n+\t\treturn current;\n+\t}\n+\n+\tList<FrankAttribute> createAttributes(Method[] methods, FrankElement attributeOwner) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "491491975a96054bd4513b4429f1a3309409534f"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc1ODQ0MA==", "bodyText": "Kan je deze twee (lege) @param weghalen?", "url": "https://github.com/ibissource/iaf/pull/1113#discussion_r503758440", "createdAt": "2020-10-13T08:21:04Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.List;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+public class FrankElement {\n+\tprivate final @Getter String fullName;\n+\tprivate final @Getter String simpleName;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter @Setter List<FrankAttribute> attributes;\n+\n+\tFrankElement(Class<?> clazz, FrankElement parent) {\n+\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis.parent = parent;\n+\t}\n+\n+\t/**\n+\t * Constructor for testing purposes. We want to test attribute construction in isolation,\n+\t * in which case we do not have a parent.\n+\t *\n+\t * @param fullName\n+\t * @param simpleName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "491491975a96054bd4513b4429f1a3309409534f"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8369bff4c3c3c39d08fd89c7b7da31bf0751d75b", "author": {"user": null}, "url": "https://github.com/ibissource/iaf/commit/8369bff4c3c3c39d08fd89c7b7da31bf0751d75b", "committedDate": "2020-10-13T09:46:21Z", "message": "Remove unnecessary @param tags found by Niels"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NDY2MjE4", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-507466218", "createdAt": "2020-10-13T13:58:47Z", "commit": {"oid": "8369bff4c3c3c39d08fd89c7b7da31bf0751d75b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NDY5MzE5", "url": "https://github.com/ibissource/iaf/pull/1113#pullrequestreview-507469319", "createdAt": "2020-10-13T14:01:43Z", "commit": {"oid": "8369bff4c3c3c39d08fd89c7b7da31bf0751d75b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1116, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}