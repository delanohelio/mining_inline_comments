{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1OTg3OTE5", "number": 1239, "reviewThreads": {"totalCount": 54, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzozNzozMVrOE1-bAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDowNzo1MFrOFNKlqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDMyNzA3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/nl/nn/adapterframework/doc/testtarget/groups/Pipe.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNzozNzozMVrOHujAnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTowODowOFrOH_Hc4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MDE0Mw==", "bodyText": "Het is heel goed dat je test classes en interfaces maakt, maar ik kan me voorstellen dat het verwarrend gaat zijn dat je daarvoor bekende termen als 'Pipe' en 'Listener' gebruikt, met name als ze af gaan wijken van wat bekend is.\nIn deze class heeft een 'Pipe' een 'Listener'. Dat is in het echt niet zo.\nIk herinner me nog een telefoongesprek waarin jij zoiets zei als dat een Pipe een Listener had. Je bedoelde toen misschien dit geval, maar ik was toen in verwarring.\nIk denk dat je hier dus beter andere termen kan gebruiken, zoals Parent en Child, of StructuredItem en SubItem", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r518570143", "createdAt": "2020-11-06T07:37:31Z", "author": {"login": "gvanbrakel"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/testtarget/groups/Pipe.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package nl.nn.adapterframework.doc.testtarget.groups;\n+\n+import nl.nn.adapterframework.doc.IbisDoc;\n+\n+public class Pipe implements IPipe {\n+\t@IbisDoc(\"10\")\n+\tpublic void setListener(Listener listener) {\n+\t}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e894a8374dc22b222a29abb29f289d5291461722"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE0MjkwMQ==", "bodyText": "Ik heb dit punt gedeeltelijk opgelost. Op deze specifieke plaats heb ik de namen veranderd, maar ik heb ook ergens de naam\nIListener laten staan. Dat is in package nl.nn.adapterframework.doc.testtarget.simple. Er is daar geen conflict omdat alleen het woord \"Listener\" overeen komt met het FF!. Alle andere classes in dit package hebben namen die niets met het FF! te maken hebben. Een andere reden om dit tweede geval niet te veranderen is dat de gerelateerde test code complexer is dus moeilijker aan te passen. Maar als ik er een of twee uur aan besteed dan is het gebeurd. Wil je dat ik dit af maak of is het goed zoals ik het gemaakt heb?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r531142901", "createdAt": "2020-11-26T16:45:13Z", "author": {"login": "mhdirkse"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/testtarget/groups/Pipe.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package nl.nn.adapterframework.doc.testtarget.groups;\n+\n+import nl.nn.adapterframework.doc.IbisDoc;\n+\n+public class Pipe implements IPipe {\n+\t@IbisDoc(\"10\")\n+\tpublic void setListener(Listener listener) {\n+\t}\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MDE0Mw=="}, "originalCommit": {"oid": "e894a8374dc22b222a29abb29f289d5291461722"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0NDQxNg==", "bodyText": "Ik heb geen bezwaar gezien. Daarom resolve ik hem nu.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535944416", "createdAt": "2020-12-04T09:08:08Z", "author": {"login": "mhdirkse"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/testtarget/groups/Pipe.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package nl.nn.adapterframework.doc.testtarget.groups;\n+\n+import nl.nn.adapterframework.doc.IbisDoc;\n+\n+public class Pipe implements IPipe {\n+\t@IbisDoc(\"10\")\n+\tpublic void setListener(Listener listener) {\n+\t}\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3MDE0Mw=="}, "originalCommit": {"oid": "e894a8374dc22b222a29abb29f289d5291461722"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjU2NTcyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMjo1NjoxMlrOH0zijQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMjo0NzoxOFrOH6aCKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzMjQyOQ==", "bodyText": "Ik denk dat je hier zou moeten zeggen:\n\"all attributes: all declared attributes as well as all inherited attributes.\"", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525132429", "createdAt": "2020-11-17T12:56:12Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwNTk5Mg==", "bodyText": "Deze opmerking slaat nu op een andere class, en daar heb ik hem ter harte genomen. Deze class is ondertussen weggehaald; hij was dubbelop.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r531005992", "createdAt": "2020-11-26T12:47:18Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzMjQyOQ=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjU3Mzg2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMjo1ODoyOFrOH0znpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMjo0ODo0OFrOH6aFRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzMzczMw==", "bodyText": "Woord toevoegen:\nand an attribute that", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525133733", "createdAt": "2020-11-17T12:58:28Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0NjM4OA==", "bodyText": "This text is not present anymore, because we have base class ElementChild and callback interface CumulativeChildHandler. I hope the code explains itself now.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529546388", "createdAt": "2020-11-24T13:31:51Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzMzczMw=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAwNjc5MQ==", "bodyText": "De formuleringen zijn nu anders. De uitleg staat nu in DocWriterNew en daar heb ik voorbeelden toegevoegd om te laten zien wat we willen bereiken.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r531006791", "createdAt": "2020-11-26T12:48:48Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzMzczMw=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjU3NzY4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMjo1OTozMlrOH0zp6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwOTowMzo0MlrOH6R0fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzNDMxMg==", "bodyText": "Hierboven nog de copyright notice toevoegen", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525134312", "createdAt": "2020-11-17T12:59:32Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg1ODAwOA==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r530858008", "createdAt": "2020-11-26T08:41:54Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzNDMxMg=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg3MTQyMg==", "bodyText": "I discovered that this file is obsolete and it has been removed. But I did take care of the copy right notices first.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r530871422", "createdAt": "2020-11-26T09:03:42Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzNDMxMg=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjU5MzM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzowMzo0NlrOH0zzUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNToyMzo0MlrOH06MMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzNjcyMg==", "bodyText": "Je kan hier toch altijd addCumulativeGroup() doen?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525136722", "createdAt": "2020-11-17T13:03:46Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that\n+ * was overridden should be omitted.\n+ *\n+ * To support this, we make two kinds of groups for each FrankElement:\n+ * <ul>\n+ * <li> The cumulative group that holds all attributes (config children) and all inherited attributes.\n+ * <li> The declared group that holds only the declared attributes (config children).\n+ * This class traverses the inheritance hierarchy of a FrankElement and chooses whether\n+ * to repeat attributes, to reference the declared group or to reference the cumulative group.\n+ * @author martijn\n+ *\n+ * @param <K> The key type for referencing attributes or config children.\n+ */\n+abstract class CumulativeGroupCreator<K> {\n+\tprivate FrankElement current;\n+\tprivate Map<K, Boolean> items;\n+\tprivate Set<K> overridden;\n+\tprivate boolean isGroupRefRepetitionNotified;\n+\n+\tCumulativeGroupCreator() {\n+\t}\n+\n+\tvoid run(FrankElement start) {\n+\t\tenter(start);\n+\t\taddDeclaredGroup(start);\n+\t\toverridden = getCurrentOverrides();\n+\t\twhile(nextAncestor(current) != null) {\n+\t\t\tenter(nextAncestor(current));\n+\t\t\tif(overridden.isEmpty()) {\n+\t\t\t\tsafeAddCumulative();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\thandleOverridesForCurrent();\n+\t\t}\n+\t}\n+\n+\tprivate void enter(FrankElement current) {\n+\t\tthis.current = current;\n+\t\titems = itemsOf(current);\t\t\n+\t}\n+\n+\tprivate void safeAddCumulative() {\n+\t\tif(nextAncestor(current) == null) {\n+\t\t\taddDeclaredGroup(current);\n+\t\t} else {\n+\t\t\taddCumulativeGroup(current);\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI0MTM5Mg==", "bodyText": "Als een FrankElement geen relevante ancestors heeft, dan is het niet nodig om een cumulatieve groep te maken. Die zou dubbel op zijn met de declared group. En als er geen cumulative group is, dan kan je hem ook niet gebruiken.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525241392", "createdAt": "2020-11-17T15:23:42Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that\n+ * was overridden should be omitted.\n+ *\n+ * To support this, we make two kinds of groups for each FrankElement:\n+ * <ul>\n+ * <li> The cumulative group that holds all attributes (config children) and all inherited attributes.\n+ * <li> The declared group that holds only the declared attributes (config children).\n+ * This class traverses the inheritance hierarchy of a FrankElement and chooses whether\n+ * to repeat attributes, to reference the declared group or to reference the cumulative group.\n+ * @author martijn\n+ *\n+ * @param <K> The key type for referencing attributes or config children.\n+ */\n+abstract class CumulativeGroupCreator<K> {\n+\tprivate FrankElement current;\n+\tprivate Map<K, Boolean> items;\n+\tprivate Set<K> overridden;\n+\tprivate boolean isGroupRefRepetitionNotified;\n+\n+\tCumulativeGroupCreator() {\n+\t}\n+\n+\tvoid run(FrankElement start) {\n+\t\tenter(start);\n+\t\taddDeclaredGroup(start);\n+\t\toverridden = getCurrentOverrides();\n+\t\twhile(nextAncestor(current) != null) {\n+\t\t\tenter(nextAncestor(current));\n+\t\t\tif(overridden.isEmpty()) {\n+\t\t\t\tsafeAddCumulative();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\thandleOverridesForCurrent();\n+\t\t}\n+\t}\n+\n+\tprivate void enter(FrankElement current) {\n+\t\tthis.current = current;\n+\t\titems = itemsOf(current);\t\t\n+\t}\n+\n+\tprivate void safeAddCumulative() {\n+\t\tif(nextAncestor(current) == null) {\n+\t\t\taddDeclaredGroup(current);\n+\t\t} else {\n+\t\t\taddCumulativeGroup(current);\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzNjcyMg=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjY1OTU4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzoyMDoyOFrOH00baw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjoyNjozMVrOH8qVmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0Njk4Nw==", "bodyText": "Kan je hier in twee regels commentaar uitleggen wat deze method doet?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525146987", "createdAt": "2020-11-17T13:20:28Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that\n+ * was overridden should be omitted.\n+ *\n+ * To support this, we make two kinds of groups for each FrankElement:\n+ * <ul>\n+ * <li> The cumulative group that holds all attributes (config children) and all inherited attributes.\n+ * <li> The declared group that holds only the declared attributes (config children).\n+ * This class traverses the inheritance hierarchy of a FrankElement and chooses whether\n+ * to repeat attributes, to reference the declared group or to reference the cumulative group.\n+ * @author martijn\n+ *\n+ * @param <K> The key type for referencing attributes or config children.\n+ */\n+abstract class CumulativeGroupCreator<K> {\n+\tprivate FrankElement current;\n+\tprivate Map<K, Boolean> items;\n+\tprivate Set<K> overridden;\n+\tprivate boolean isGroupRefRepetitionNotified;\n+\n+\tCumulativeGroupCreator() {\n+\t}\n+\n+\tvoid run(FrankElement start) {\n+\t\tenter(start);\n+\t\taddDeclaredGroup(start);\n+\t\toverridden = getCurrentOverrides();\n+\t\twhile(nextAncestor(current) != null) {\n+\t\t\tenter(nextAncestor(current));\n+\t\t\tif(overridden.isEmpty()) {\n+\t\t\t\tsafeAddCumulative();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\thandleOverridesForCurrent();\n+\t\t}\n+\t}\n+\n+\tprivate void enter(FrankElement current) {\n+\t\tthis.current = current;\n+\t\titems = itemsOf(current);\t\t\n+\t}\n+\n+\tprivate void safeAddCumulative() {\n+\t\tif(nextAncestor(current) == null) {\n+\t\t\taddDeclaredGroup(current);\n+\t\t} else {\n+\t\t\taddCumulativeGroup(current);\n+\t\t}\n+\t}\n+\n+\tprivate void handleOverridesForCurrent() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0NzU1OA==", "bodyText": "De structuur is veranderd. Ik heb nog steeds niet veel commentaar, maar ik hoop dat de nieuwe structuur duidelijker is. Is er nog commentaar nodig?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529547558", "createdAt": "2020-11-24T13:33:40Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that\n+ * was overridden should be omitted.\n+ *\n+ * To support this, we make two kinds of groups for each FrankElement:\n+ * <ul>\n+ * <li> The cumulative group that holds all attributes (config children) and all inherited attributes.\n+ * <li> The declared group that holds only the declared attributes (config children).\n+ * This class traverses the inheritance hierarchy of a FrankElement and chooses whether\n+ * to repeat attributes, to reference the declared group or to reference the cumulative group.\n+ * @author martijn\n+ *\n+ * @param <K> The key type for referencing attributes or config children.\n+ */\n+abstract class CumulativeGroupCreator<K> {\n+\tprivate FrankElement current;\n+\tprivate Map<K, Boolean> items;\n+\tprivate Set<K> overridden;\n+\tprivate boolean isGroupRefRepetitionNotified;\n+\n+\tCumulativeGroupCreator() {\n+\t}\n+\n+\tvoid run(FrankElement start) {\n+\t\tenter(start);\n+\t\taddDeclaredGroup(start);\n+\t\toverridden = getCurrentOverrides();\n+\t\twhile(nextAncestor(current) != null) {\n+\t\t\tenter(nextAncestor(current));\n+\t\t\tif(overridden.isEmpty()) {\n+\t\t\t\tsafeAddCumulative();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\thandleOverridesForCurrent();\n+\t\t}\n+\t}\n+\n+\tprivate void enter(FrankElement current) {\n+\t\tthis.current = current;\n+\t\titems = itemsOf(current);\t\t\n+\t}\n+\n+\tprivate void safeAddCumulative() {\n+\t\tif(nextAncestor(current) == null) {\n+\t\t\taddDeclaredGroup(current);\n+\t\t} else {\n+\t\t\taddCumulativeGroup(current);\n+\t\t}\n+\t}\n+\n+\tprivate void handleOverridesForCurrent() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0Njk4Nw=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE0NDU0NQ==", "bodyText": "Deze class is weg. We hebben nu callback interface CumulativeChildHandler, waarvan de methods een Javadoc comment hebben. Verder begint DocWriterNew nu met een algemeen overzicht van de XSD en van het model. Ten slotte is ElementChild gedocumenteerd.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r531144545", "createdAt": "2020-11-26T16:48:52Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that\n+ * was overridden should be omitted.\n+ *\n+ * To support this, we make two kinds of groups for each FrankElement:\n+ * <ul>\n+ * <li> The cumulative group that holds all attributes (config children) and all inherited attributes.\n+ * <li> The declared group that holds only the declared attributes (config children).\n+ * This class traverses the inheritance hierarchy of a FrankElement and chooses whether\n+ * to repeat attributes, to reference the declared group or to reference the cumulative group.\n+ * @author martijn\n+ *\n+ * @param <K> The key type for referencing attributes or config children.\n+ */\n+abstract class CumulativeGroupCreator<K> {\n+\tprivate FrankElement current;\n+\tprivate Map<K, Boolean> items;\n+\tprivate Set<K> overridden;\n+\tprivate boolean isGroupRefRepetitionNotified;\n+\n+\tCumulativeGroupCreator() {\n+\t}\n+\n+\tvoid run(FrankElement start) {\n+\t\tenter(start);\n+\t\taddDeclaredGroup(start);\n+\t\toverridden = getCurrentOverrides();\n+\t\twhile(nextAncestor(current) != null) {\n+\t\t\tenter(nextAncestor(current));\n+\t\t\tif(overridden.isEmpty()) {\n+\t\t\t\tsafeAddCumulative();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\thandleOverridesForCurrent();\n+\t\t}\n+\t}\n+\n+\tprivate void enter(FrankElement current) {\n+\t\tthis.current = current;\n+\t\titems = itemsOf(current);\t\t\n+\t}\n+\n+\tprivate void safeAddCumulative() {\n+\t\tif(nextAncestor(current) == null) {\n+\t\t\taddDeclaredGroup(current);\n+\t\t} else {\n+\t\t\taddCumulativeGroup(current);\n+\t\t}\n+\t}\n+\n+\tprivate void handleOverridesForCurrent() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0Njk4Nw=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3MDI2NA==", "bodyText": "Deze method heeft nu een betere naam.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533370264", "createdAt": "2020-12-01T12:26:31Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/CumulativeGroupCreator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Strategy class for handling overrides while writing an XML schema from a FrankDocModel.\n+ * This class is reused for building attribute groups and building config child groups.\n+ * The use of this class is explained for attribute groups.\n+ *\n+ * For each FrankElement in the model, we need an XSD attributeGroup that lists\n+ * all attributes and all inherited attributes. To keep the XSD small, we would like\n+ * to list the inherited attributes by referencing the attributeGroup of the parent.\n+ * This is not possible however when the current FrankElement overrides attributes.\n+ * In this case, the data from the current FrankElement is needed and attribute that\n+ * was overridden should be omitted.\n+ *\n+ * To support this, we make two kinds of groups for each FrankElement:\n+ * <ul>\n+ * <li> The cumulative group that holds all attributes (config children) and all inherited attributes.\n+ * <li> The declared group that holds only the declared attributes (config children).\n+ * This class traverses the inheritance hierarchy of a FrankElement and chooses whether\n+ * to repeat attributes, to reference the declared group or to reference the cumulative group.\n+ * @author martijn\n+ *\n+ * @param <K> The key type for referencing attributes or config children.\n+ */\n+abstract class CumulativeGroupCreator<K> {\n+\tprivate FrankElement current;\n+\tprivate Map<K, Boolean> items;\n+\tprivate Set<K> overridden;\n+\tprivate boolean isGroupRefRepetitionNotified;\n+\n+\tCumulativeGroupCreator() {\n+\t}\n+\n+\tvoid run(FrankElement start) {\n+\t\tenter(start);\n+\t\taddDeclaredGroup(start);\n+\t\toverridden = getCurrentOverrides();\n+\t\twhile(nextAncestor(current) != null) {\n+\t\t\tenter(nextAncestor(current));\n+\t\t\tif(overridden.isEmpty()) {\n+\t\t\t\tsafeAddCumulative();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\thandleOverridesForCurrent();\n+\t\t}\n+\t}\n+\n+\tprivate void enter(FrankElement current) {\n+\t\tthis.current = current;\n+\t\titems = itemsOf(current);\t\t\n+\t}\n+\n+\tprivate void safeAddCumulative() {\n+\t\tif(nextAncestor(current) == null) {\n+\t\t\taddDeclaredGroup(current);\n+\t\t} else {\n+\t\t\taddCumulativeGroup(current);\n+\t\t}\n+\t}\n+\n+\tprivate void handleOverridesForCurrent() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0Njk4Nw=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjY3MzE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzoyNDoxM1rOH00kNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzozNDoyNVrOH5BDLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0OTIzOA==", "bodyText": "Kan je in twee regels commentaar uitleggen wat hieronder gebeurt?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525149238", "createdAt": "2020-11-17T13:24:13Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,470 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addAttribute;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addAttributeGroup;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addAttributeGroupRef;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addChoice;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addComplexType;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addDocumentation;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addElement;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addGroup;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addGroupRef;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addSequence;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ConfigChildKey;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.LogUtil;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(DocWriterNew.class);\n+\n+\tprivate FrankDocModel model;\n+\tprivate Map<String, String> syntax2Names;\n+\tList<SortKeyForXsd> xsdSortOrder;\n+\tprivate XmlBuilder xsdRoot;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t\tMap<String, List<FrankElement>> simpleNamePartitions = model.getAllElements().values().stream()\n+\t\t\t\t.collect(Collectors.groupingBy(\n+\t\t\t\t\t\tFrankElement::getSimpleName,\n+\t\t\t\t\t\tCollectors.toList()));\n+\t\tsyntax2Names = new HashMap<>();\n+\t\tfor(List<FrankElement> partition: simpleNamePartitions.values()) {\n+\t\t\tsyntax2Names.putAll(chooseSyntax2Names(partition));\n+\t\t}\n+\t}\n+\n+\tpublic void init() {\n+\t\txsdSortOrder = breadthFirstSort(CONFIGURATION);\n+\t}\n+\n+\tstatic Map<String, String> chooseSyntax2Names(List<FrankElement> elementPartition) {\n+\t\tMap<String, String> result = new HashMap<>();\n+\t\tif(elementPartition.size() == 1) {\n+\t\t\tFrankElement theElement = elementPartition.get(0);\n+\t\t\tresult.put(theElement.getFullName(), theElement.getSimpleName());\n+\t\t\treturn result;\n+\t\t}\n+\t\telse {\n+\t\t\tList<List<String>> nameComponents = new ArrayList<>();\n+\t\t\tfor(FrankElement element: elementPartition) {\n+\t\t\t\tList<String> packageNameComponents = Arrays.asList(element.getFullName().split(\"\\\\.\", -1));\n+\t\t\t\tif(! element.getSimpleName().equals(packageNameComponents.get(packageNameComponents.size() - 1))) {\n+\t\t\t\t\tlog.warn(String.format(\"Syntax 2 names may be wrong because there is a FrankElement with full name [%s] but simple name [%s]\",\n+\t\t\t\t\t\t\telement.getFullName(), element.getSimpleName()));\n+\t\t\t\t}\n+\t\t\t\tnameComponents.add(packageNameComponents);\n+\t\t\t}\n+\t\t\tList<String> fullNames = elementPartition.stream().map(elem -> elem.getFullName()).collect(Collectors.toList());\n+\t\t\tint numComponents = 2;\n+\t\t\twhile(true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0ODA3Ng==", "bodyText": "Dit was functionaliteit die we bij nader inzien niet willen. Deze code is weg.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529548076", "createdAt": "2020-11-24T13:34:25Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,470 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addAttribute;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addAttributeGroup;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addAttributeGroupRef;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addChoice;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addComplexType;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addDocumentation;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addElement;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addGroup;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addGroupRef;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.addSequence;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ConfigChildKey;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.LogUtil;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\n+\tprivate static Logger log = LogUtil.getLogger(DocWriterNew.class);\n+\n+\tprivate FrankDocModel model;\n+\tprivate Map<String, String> syntax2Names;\n+\tList<SortKeyForXsd> xsdSortOrder;\n+\tprivate XmlBuilder xsdRoot;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t\tMap<String, List<FrankElement>> simpleNamePartitions = model.getAllElements().values().stream()\n+\t\t\t\t.collect(Collectors.groupingBy(\n+\t\t\t\t\t\tFrankElement::getSimpleName,\n+\t\t\t\t\t\tCollectors.toList()));\n+\t\tsyntax2Names = new HashMap<>();\n+\t\tfor(List<FrankElement> partition: simpleNamePartitions.values()) {\n+\t\t\tsyntax2Names.putAll(chooseSyntax2Names(partition));\n+\t\t}\n+\t}\n+\n+\tpublic void init() {\n+\t\txsdSortOrder = breadthFirstSort(CONFIGURATION);\n+\t}\n+\n+\tstatic Map<String, String> chooseSyntax2Names(List<FrankElement> elementPartition) {\n+\t\tMap<String, String> result = new HashMap<>();\n+\t\tif(elementPartition.size() == 1) {\n+\t\t\tFrankElement theElement = elementPartition.get(0);\n+\t\t\tresult.put(theElement.getFullName(), theElement.getSimpleName());\n+\t\t\treturn result;\n+\t\t}\n+\t\telse {\n+\t\t\tList<List<String>> nameComponents = new ArrayList<>();\n+\t\t\tfor(FrankElement element: elementPartition) {\n+\t\t\t\tList<String> packageNameComponents = Arrays.asList(element.getFullName().split(\"\\\\.\", -1));\n+\t\t\t\tif(! element.getSimpleName().equals(packageNameComponents.get(packageNameComponents.size() - 1))) {\n+\t\t\t\t\tlog.warn(String.format(\"Syntax 2 names may be wrong because there is a FrankElement with full name [%s] but simple name [%s]\",\n+\t\t\t\t\t\t\telement.getFullName(), element.getSimpleName()));\n+\t\t\t\t}\n+\t\t\t\tnameComponents.add(packageNameComponents);\n+\t\t\t}\n+\t\t\tList<String> fullNames = elementPartition.stream().map(elem -> elem.getFullName()).collect(Collectors.toList());\n+\t\t\tint numComponents = 2;\n+\t\t\twhile(true) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0OTIzOA=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjczMDkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzozODoyMFrOH01Hxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzozNzo0N1rOH5BMHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE1ODM0Mg==", "bodyText": "Hier vind je de eerste definitie van het attribuut / het configChild. Is dat wat je wilt? Wil je niet de laatste hebben? Als je bijvoorbeeld documentatie wil overnemen, wil je die van de laatste.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525158342", "createdAt": "2020-11-17T13:38:20Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -48,4 +51,25 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t}\n \t\treturn result;\n \t}\n+\n+\t/**\n+\t * Calculate property overriddenFrom. Assumes that overriddenFrom has been\n+\t * set already for all ancestors in the FrankElement inheritance hierarchy.\n+\t */\n+\tpublic void calculateOverriddenFrom() {\n+\t\tConfigChildKey key = new ConfigChildKey(this);\n+\t\tFrankElement match = configParent;\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tConfigChild matchingChild = match.find(key);\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\tif(matchingChild.overriddenFrom != null) {\n+\t\t\t\t\tthis.overriddenFrom = matchingChild.overriddenFrom;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIzOTc4NQ==", "bodyText": "In DocWriterNew itereer ik al vanaf een child over al zijn ancestors. Dan is het niet meer nodig om op te slaan waarvandaan een method overridden is. Als je in een ancestor de method vind, dan heb je de originele method. Zal ik dit veld vervangen door een boolean?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525239785", "createdAt": "2020-11-17T15:21:40Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -48,4 +51,25 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t}\n \t\treturn result;\n \t}\n+\n+\t/**\n+\t * Calculate property overriddenFrom. Assumes that overriddenFrom has been\n+\t * set already for all ancestors in the FrankElement inheritance hierarchy.\n+\t */\n+\tpublic void calculateOverriddenFrom() {\n+\t\tConfigChildKey key = new ConfigChildKey(this);\n+\t\tFrankElement match = configParent;\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tConfigChild matchingChild = match.find(key);\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\tif(matchingChild.overriddenFrom != null) {\n+\t\t\t\t\tthis.overriddenFrom = matchingChild.overriddenFrom;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE1ODM0Mg=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MDM2Nw==", "bodyText": "Ik neem bovenstaande opmerking terug. We willen geen informatie weggooien, dus de FrankElement referentie vervangen door een Boolean lijkt met toch geen goed idee. Ik heb de code veranderd zodat we in overriddenFrom de eerste match stoppen, zonder meteen de eerste definitie in de inheritance hierarchie op te zoeken.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529550367", "createdAt": "2020-11-24T13:37:47Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -48,4 +51,25 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t}\n \t\treturn result;\n \t}\n+\n+\t/**\n+\t * Calculate property overriddenFrom. Assumes that overriddenFrom has been\n+\t * set already for all ancestors in the FrankElement inheritance hierarchy.\n+\t */\n+\tpublic void calculateOverriddenFrom() {\n+\t\tConfigChildKey key = new ConfigChildKey(this);\n+\t\tFrankElement match = configParent;\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tConfigChild matchingChild = match.find(key);\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\tif(matchingChild.overriddenFrom != null) {\n+\t\t\t\t\tthis.overriddenFrom = matchingChild.overriddenFrom;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE1ODM0Mg=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Mjc0OTAyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankAttribute.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzo0MTo0NVrOH01Tlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzozODoxOFrOH5BNSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE2MTM2Ng==", "bodyText": "Ik denk dat ik ConfigChild en FrankElement een gezamelijk parent zou willen geven waarin calculateOverriddenFrom() z'n plek kan vinden.\nIk denk dat je GroupCreator daar ook simpeler van kan worden.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r525161366", "createdAt": "2020-11-17T13:41:45Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankAttribute.java", "diffHunk": "@@ -49,4 +53,21 @@ void parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tvoid calculateOverriddenFrom() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1MDY2Nw==", "bodyText": "Heb ik inmiddels gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529550667", "createdAt": "2020-11-24T13:38:18Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankAttribute.java", "diffHunk": "@@ -49,4 +53,21 @@ void parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tvoid calculateOverriddenFrom() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE2MTM2Ng=="}, "originalCommit": {"oid": "d9d30609981971b04f05ad4fd69792be2b0d4a61"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNTY2NTYxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzowMToyM1rOH4MdQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjoyNTo0OVrOH8qUJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY4NjQwMw==", "bodyText": "Wat doet cast()?\nIk zie hem twee keer ge\u00efmplementeerd zijn met 'return this'.\nMoet hij dan abstract zijn?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r528686403", "createdAt": "2020-11-23T13:01:23Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}\n+ *\n+ * @author martijn\n+ *\n+ * @param <T>\n+ */\n+public abstract class ElementChild<T extends ElementChild<?>> {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild<?>> SELECTED = c ->\n+\t\t(! c.isDeprecated())\n+\t\t&& (c.isDocumented() || (c.getOverriddenFrom() == null));\n+\n+\tElementChild(final FrankElement owningElement) {\n+\t\tthis.owningElement = owningElement;\n+\t}\n+\n+\tpublic static Predicate<ElementChild<?>> ALL = c -> true;\n+\n+\tvoid calculateOverriddenFrom(BiFunction<FrankElement, T, T> lookup) {\n+\t\tFrankElement match = getOwningElement();\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tT matchingChild = lookup.apply(match, cast());\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\tFrankElement matchOverriddenFrom = matchingChild.getOverriddenFrom();\n+\t\t\t\tif(matchOverriddenFrom != null) {\n+\t\t\t\t\toverriddenFrom = matchOverriddenFrom;\n+\t\t\t\t} else {\n+\t\t\t\t\toverriddenFrom = match;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tabstract T cast();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c67190d2d94fb39bfa9a2d52f48819ca13e039c"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5Nzg1NQ==", "bodyText": "Mijn code werkte niet omdat ik een ChildElement als argument meegaf in plaats van een ConfigChild of FrankAttribute. Dit heb ik opgelost met de cast() functie, die ElementChild naar T converteert. Dit is een abstracte method. De type parameter T is bounded en moet een subclass zijn van ElementChild. De implementatie van cast() verschijnt in FrankAttribute en in ConfigChild. Maar daar is de this pointer al van het juiste type. \"return this\" doet dus precies wat nodig is.\nIk had ook gewoon een cast kunnen maken als \"(FrankAttribute) elementChild\" of \"(ConfigChild) elementChild\", maar dan had je minder duidelijk kunnen zien dat die cast toegestaan is.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529797855", "createdAt": "2020-11-24T18:40:04Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}\n+ *\n+ * @author martijn\n+ *\n+ * @param <T>\n+ */\n+public abstract class ElementChild<T extends ElementChild<?>> {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild<?>> SELECTED = c ->\n+\t\t(! c.isDeprecated())\n+\t\t&& (c.isDocumented() || (c.getOverriddenFrom() == null));\n+\n+\tElementChild(final FrankElement owningElement) {\n+\t\tthis.owningElement = owningElement;\n+\t}\n+\n+\tpublic static Predicate<ElementChild<?>> ALL = c -> true;\n+\n+\tvoid calculateOverriddenFrom(BiFunction<FrankElement, T, T> lookup) {\n+\t\tFrankElement match = getOwningElement();\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tT matchingChild = lookup.apply(match, cast());\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\tFrankElement matchOverriddenFrom = matchingChild.getOverriddenFrom();\n+\t\t\t\tif(matchOverriddenFrom != null) {\n+\t\t\t\t\toverriddenFrom = matchOverriddenFrom;\n+\t\t\t\t} else {\n+\t\t\t\t\toverriddenFrom = match;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tabstract T cast();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY4NjQwMw=="}, "originalCommit": {"oid": "6c67190d2d94fb39bfa9a2d52f48819ca13e039c"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1Mjg1Mg==", "bodyText": "Ik heb een comment toegevoegd om dit uit te leggen. Dit zal ik binnenkort pushen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r531152852", "createdAt": "2020-11-26T17:06:57Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}\n+ *\n+ * @author martijn\n+ *\n+ * @param <T>\n+ */\n+public abstract class ElementChild<T extends ElementChild<?>> {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild<?>> SELECTED = c ->\n+\t\t(! c.isDeprecated())\n+\t\t&& (c.isDocumented() || (c.getOverriddenFrom() == null));\n+\n+\tElementChild(final FrankElement owningElement) {\n+\t\tthis.owningElement = owningElement;\n+\t}\n+\n+\tpublic static Predicate<ElementChild<?>> ALL = c -> true;\n+\n+\tvoid calculateOverriddenFrom(BiFunction<FrankElement, T, T> lookup) {\n+\t\tFrankElement match = getOwningElement();\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tT matchingChild = lookup.apply(match, cast());\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\tFrankElement matchOverriddenFrom = matchingChild.getOverriddenFrom();\n+\t\t\t\tif(matchOverriddenFrom != null) {\n+\t\t\t\t\toverriddenFrom = matchOverriddenFrom;\n+\t\t\t\t} else {\n+\t\t\t\t\toverriddenFrom = match;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tabstract T cast();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY4NjQwMw=="}, "originalCommit": {"oid": "6c67190d2d94fb39bfa9a2d52f48819ca13e039c"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2OTg5Mw==", "bodyText": "De oplossing met cast() was inderdaad te complex. Dit is opgeschoond.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533369893", "createdAt": "2020-12-01T12:25:49Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}\n+ *\n+ * @author martijn\n+ *\n+ * @param <T>\n+ */\n+public abstract class ElementChild<T extends ElementChild<?>> {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild<?>> SELECTED = c ->\n+\t\t(! c.isDeprecated())\n+\t\t&& (c.isDocumented() || (c.getOverriddenFrom() == null));\n+\n+\tElementChild(final FrankElement owningElement) {\n+\t\tthis.owningElement = owningElement;\n+\t}\n+\n+\tpublic static Predicate<ElementChild<?>> ALL = c -> true;\n+\n+\tvoid calculateOverriddenFrom(BiFunction<FrankElement, T, T> lookup) {\n+\t\tFrankElement match = getOwningElement();\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tT matchingChild = lookup.apply(match, cast());\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\tFrankElement matchOverriddenFrom = matchingChild.getOverriddenFrom();\n+\t\t\t\tif(matchOverriddenFrom != null) {\n+\t\t\t\t\toverriddenFrom = matchOverriddenFrom;\n+\t\t\t\t} else {\n+\t\t\t\t\toverriddenFrom = match;\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tabstract T cast();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY4NjQwMw=="}, "originalCommit": {"oid": "6c67190d2d94fb39bfa9a2d52f48819ca13e039c"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjE4MjAzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo0NzoyOVrOH5Lz9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjoyNDo0OFrOH8qSBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNDQwNg==", "bodyText": "Daar waar je cast() zou kunnen gebruiken, kan je toch ook gewoon 'this' gebruiken?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529724406", "createdAt": "2020-11-24T16:47:29Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -41,11 +40,24 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n \t\t\t} catch(Exception e) {\n \t\t\t\tlog.warn(String.format(\"@IbisDoc for config child with parent [%s] and type [%s] has a non-integer order [%s], ignored\",\n-\t\t\t\t\t\tconfigParent.getSimpleName(),\n+\t\t\t\t\t\tgetOwningElement().getSimpleName(),\n \t\t\t\t\t\telementType.getSimpleName(),\n \t\t\t\t\t\tibisDoc.value()[0]));\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tpublic String getSyntax1NamePlural() {\n+\t\tif(syntax1Name.endsWith(\"s\")) {\n+\t\t\treturn syntax1Name;\n+\t\t} else {\n+\t\t\treturn syntax1Name + \"s\";\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tConfigChild cast() {\n+\t\treturn this;\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5OTAyNw==", "bodyText": "Dan heb je een type mismatch, omdat ElementChild niet hetzelfde is als FrankAttribute en omdat ElementChild niet hetzelfde is als ConfigChild.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529799027", "createdAt": "2020-11-24T18:41:54Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -41,11 +40,24 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n \t\t\t} catch(Exception e) {\n \t\t\t\tlog.warn(String.format(\"@IbisDoc for config child with parent [%s] and type [%s] has a non-integer order [%s], ignored\",\n-\t\t\t\t\t\tconfigParent.getSimpleName(),\n+\t\t\t\t\t\tgetOwningElement().getSimpleName(),\n \t\t\t\t\t\telementType.getSimpleName(),\n \t\t\t\t\t\tibisDoc.value()[0]));\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tpublic String getSyntax1NamePlural() {\n+\t\tif(syntax1Name.endsWith(\"s\")) {\n+\t\t\treturn syntax1Name;\n+\t\t} else {\n+\t\t\treturn syntax1Name + \"s\";\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tConfigChild cast() {\n+\t\treturn this;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNDQwNg=="}, "originalCommit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5OTY0Nw==", "bodyText": "Sorry, angular brackets vallen weg. ElementChild<FrankAttribute> is niet hetzelfde als FrankAttribute", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529799647", "createdAt": "2020-11-24T18:42:56Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -41,11 +40,24 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n \t\t\t} catch(Exception e) {\n \t\t\t\tlog.warn(String.format(\"@IbisDoc for config child with parent [%s] and type [%s] has a non-integer order [%s], ignored\",\n-\t\t\t\t\t\tconfigParent.getSimpleName(),\n+\t\t\t\t\t\tgetOwningElement().getSimpleName(),\n \t\t\t\t\t\telementType.getSimpleName(),\n \t\t\t\t\t\tibisDoc.value()[0]));\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tpublic String getSyntax1NamePlural() {\n+\t\tif(syntax1Name.endsWith(\"s\")) {\n+\t\t\treturn syntax1Name;\n+\t\t} else {\n+\t\t\treturn syntax1Name + \"s\";\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tConfigChild cast() {\n+\t\treturn this;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNDQwNg=="}, "originalCommit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2OTM0OQ==", "bodyText": "Er is nu geen cast() meer. De complexiteit waar je bezwaar tegen had is opgeschoond.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533369349", "createdAt": "2020-12-01T12:24:48Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -41,11 +40,24 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n \t\t\t} catch(Exception e) {\n \t\t\t\tlog.warn(String.format(\"@IbisDoc for config child with parent [%s] and type [%s] has a non-integer order [%s], ignored\",\n-\t\t\t\t\t\tconfigParent.getSimpleName(),\n+\t\t\t\t\t\tgetOwningElement().getSimpleName(),\n \t\t\t\t\t\telementType.getSimpleName(),\n \t\t\t\t\t\tibisDoc.value()[0]));\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tpublic String getSyntax1NamePlural() {\n+\t\tif(syntax1Name.endsWith(\"s\")) {\n+\t\t\treturn syntax1Name;\n+\t\t} else {\n+\t\t\treturn syntax1Name + \"s\";\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tConfigChild cast() {\n+\t\treturn this;\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNDQwNg=="}, "originalCommit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjIxNDEwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo1NDozNlrOH5MILg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjozOTowNVrOH8Dmbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyOTU4Mg==", "bodyText": "Ik zou verwachten dat dit implementaties zouden zijn van een abstract method, en dat ze in ConfigChild resp. FrankAttribute gedefinieerd zouden zijn", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529729582", "createdAt": "2020-11-24T16:54:36Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,199 @@\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n \n+import org.apache.logging.log4j.Logger;\n+\n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final Comparator<ConfigChild> CONFIG_CHILD_COMPARATOR =\n+\t\t\tComparator.comparing(ConfigChild::getSequenceInConfig)\n+\t\t\t.thenComparing(ConfigChild::getSyntax1Name);\n+\tprivate static final Comparator<FrankAttribute> FRANK_ATTRIBUTE_COMPARATOR =\n+\t\t\tComparator.comparing(FrankAttribute::getOrder)\n+\t\t\t.thenComparing(FrankAttribute::getName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgwMzY3Mg==", "bodyText": "Ik had ook ElementChild.compareTo() kunnen invoeren, maar dan had ik het niet zo compact kunnen opschrijven. Je gebruikt twee velden om een totale ordening te krijgen, en dat gaat makkelijker met deze syntax dan als je het procedureel uitschrijft. Ik zou de comparators ook als static variables van ConfigChild en FrankAttribute kunnen defini\u00ebren, maar dan kunnen ze niet private zijn. Het FrankElement is de enige class die attributes en config children hoeft te sorteren volgens deze ordeningen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r529803672", "createdAt": "2020-11-24T18:50:04Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,199 @@\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n \n+import org.apache.logging.log4j.Logger;\n+\n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final Comparator<ConfigChild> CONFIG_CHILD_COMPARATOR =\n+\t\t\tComparator.comparing(ConfigChild::getSequenceInConfig)\n+\t\t\t.thenComparing(ConfigChild::getSyntax1Name);\n+\tprivate static final Comparator<FrankAttribute> FRANK_ATTRIBUTE_COMPARATOR =\n+\t\t\tComparator.comparing(FrankAttribute::getOrder)\n+\t\t\t.thenComparing(FrankAttribute::getName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyOTU4Mg=="}, "originalCommit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2NzQyMw==", "bodyText": "Ik zou er in ElementChild een protected veld van maken, met implementaties in ConfigChild en FrankAttribute. Ik zou dan daarmee de concessie doen dat het instance methods worden, terwijl het eigenlijk static methods zouden moeten zijn, (maar die kunnen niet erven zoals je zou willen). Het voordeel daarvan is, dat alle ConfigChild code in ConfigChild zit, en alle FrankAttriubte code in FrankAttribute. Ook is het een voordeel dat dan als je calculateOverriddenFrom() aanroept, niet ook nog een comparator functie hoeft mee te geven.\nIk denk dat ik dat toch wel het belangrijkst/prettigst vind, omdat het me helpt om overzicht over de code te krijgen.\nBedenk ook dat het hele idee van de ElementChild is om code die gezamelijk is voor ConfigChild en FrankAttribute bijeen te brengen. Het hebben van een comparator is er daar \u00e9\u00e9n van. De implementaties van het gezamelijke moeten dan ook in ConfigChild en FrankAttribute komen, en niet weer in een andere class.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r530167423", "createdAt": "2020-11-25T07:52:44Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,199 @@\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n \n+import org.apache.logging.log4j.Logger;\n+\n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final Comparator<ConfigChild> CONFIG_CHILD_COMPARATOR =\n+\t\t\tComparator.comparing(ConfigChild::getSequenceInConfig)\n+\t\t\t.thenComparing(ConfigChild::getSyntax1Name);\n+\tprivate static final Comparator<FrankAttribute> FRANK_ATTRIBUTE_COMPARATOR =\n+\t\t\tComparator.comparing(FrankAttribute::getOrder)\n+\t\t\t.thenComparing(FrankAttribute::getName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyOTU4Mg=="}, "originalCommit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjczNTU5OA==", "bodyText": "We hebben dit telefonisch besproken. De uitkomst van dat gesprek heb ik geimplementeerd.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r532735598", "createdAt": "2020-11-30T16:39:05Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,199 @@\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n \n+import org.apache.logging.log4j.Logger;\n+\n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\tprivate static final Comparator<ConfigChild> CONFIG_CHILD_COMPARATOR =\n+\t\t\tComparator.comparing(ConfigChild::getSequenceInConfig)\n+\t\t\t.thenComparing(ConfigChild::getSyntax1Name);\n+\tprivate static final Comparator<FrankAttribute> FRANK_ATTRIBUTE_COMPARATOR =\n+\t\t\tComparator.comparing(FrankAttribute::getOrder)\n+\t\t\t.thenComparing(FrankAttribute::getName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyOTU4Mg=="}, "originalCommit": {"oid": "67606376f4b6357c8b4eb8fd13a92178ccdecceb"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Njg0MDg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDozNzozOVrOH8vhHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTowNzoxMlrOH_Haxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ1NTEzNQ==", "bodyText": "Als ik 'Selected' lees, vraag ik me af 'waarvoor?' Volgens mij in dit geval: 'ElementToBeIncludedInXmlSchema'.\nKan je er zoiets van maken?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533455135", "createdAt": "2020-12-01T14:37:39Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.\n+ *\n+ * @author martijn\n+ */\n+public abstract class ElementChild {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild> SELECTED = c ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkxMzQxOA==", "bodyText": "Ik heb er IN_XSD van gemaakt. Is dat OK?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r534913418", "createdAt": "2020-12-03T08:30:08Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.\n+ *\n+ * @author martijn\n+ */\n+public abstract class ElementChild {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild> SELECTED = c ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ1NTEzNQ=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk0Mzg3OQ==", "bodyText": "Je hebt hem sinds dit commentaar gereviewed. Ik heb geen bezwaar gezien. Daarom resolve ik hem nu.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535943879", "createdAt": "2020-12-04T09:07:12Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.\n+ *\n+ * @author martijn\n+ */\n+public abstract class ElementChild {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild> SELECTED = c ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ1NTEzNQ=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Njg4OTQwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDo0NDozMFrOH8wBgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwODozMDoyOVrOH-Ijig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MzQyNg==", "bodyText": "Kan je hier in javadoc een beschrijving geven wat deze class is, en wat z'n twee descendants voorstellen?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533463426", "createdAt": "2020-12-01T14:44:30Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -1,13 +1,96 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n import lombok.Getter;\n \n-public class FrankDocGroup {\n+public abstract class FrankDocGroup {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDkxMzkzMA==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r534913930", "createdAt": "2020-12-03T08:30:29Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -1,13 +1,96 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n import lombok.Getter;\n \n-public class FrankDocGroup {\n+public abstract class FrankDocGroup {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2MzQyNg=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjkxMDA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDo0NzowN1rOH8wPbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwODo1MzozMlrOH-K_Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2Njk5MA==", "bodyText": "Als je hier LinkedHashMaps gebruikt, kan je er later over itereren in de volgorde waarin je de elementen er in gestopt hebt", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533466990", "createdAt": "2020-12-01T14:47:07Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -32,9 +51,10 @@\n public class FrankDocModel {\n \tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n \tprivate static final String DIGESTER_RULES = \"digester-rules.xml\";\n-\t\n+\tstatic final String OTHER = \"Other\";\n+\n \tprivate @Getter Map<String, ConfigChildSetterDescriptor> configChildDescriptors;\n-\tprivate @Getter Map<String, FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankDocGroup> groups = new HashMap<>();\n \tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n \tprivate @Getter Map<String, ElementType> allTypes = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk1Mzc3NA==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r534953774", "createdAt": "2020-12-03T08:53:32Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -32,9 +51,10 @@\n public class FrankDocModel {\n \tprivate static Logger log = LogUtil.getLogger(FrankDocModel.class);\n \tprivate static final String DIGESTER_RULES = \"digester-rules.xml\";\n-\t\n+\tstatic final String OTHER = \"Other\";\n+\n \tprivate @Getter Map<String, ConfigChildSetterDescriptor> configChildDescriptors;\n-\tprivate @Getter Map<String, FrankDocGroup> groups;\n+\tprivate @Getter Map<String, FrankDocGroup> groups = new HashMap<>();\n \tprivate @Getter Map<String, FrankElement> allElements = new HashMap<>();\n \tprivate @Getter Map<String, ElementType> allTypes = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ2Njk5MA=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Njk0MjU1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDo1MjowMVrOH8wj6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOTozMjozNlrOH-OKmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MjIzMw==", "bodyText": "Hier graag toevoegen, ter verduidelijking: \"This allows the framework code to distinguish null values (=not configured) from default values.\"", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533472233", "createdAt": "2020-12-01T14:52:01Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -200,6 +227,12 @@ public FrankElement findOrCreateFrankElement(Class<?> clazz) throws ReflectiveOp\n \tprivate void checkForTypeConflict(Method setter, Method getter, FrankElement attributeOwner) {\n \t\tString setterType = setter.getParameterTypes()[0].getName();\n \t\tString getterType = getter.getReturnType().getName();\n+\t\tif(getter.getName().startsWith(\"get\")) {\n+\t\t\t// For issers we require an exact match of the type name. For getters,\n+\t\t\t// the setter and the getter may mix boxed and unboxed types.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAwNTg1MA==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535005850", "createdAt": "2020-12-03T09:32:36Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -200,6 +227,12 @@ public FrankElement findOrCreateFrankElement(Class<?> clazz) throws ReflectiveOp\n \tprivate void checkForTypeConflict(Method setter, Method getter, FrankElement attributeOwner) {\n \t\tString setterType = setter.getParameterTypes()[0].getName();\n \t\tString getterType = getter.getReturnType().getName();\n+\t\tif(getter.getName().startsWith(\"get\")) {\n+\t\t\t// For issers we require an exact match of the type name. For getters,\n+\t\t\t// the setter and the getter may mix boxed and unboxed types.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3MjIzMw=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Njk2MTc4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDo1NjowMFrOH8wv-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOTozMjowMVrOH-OINA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NTMyMA==", "bodyText": "Het is duidelijker als je hier de groepnaam tussen aanhalingstekens zet, als in: 'other'", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533475320", "createdAt": "2020-12-01T14:56:00Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -308,13 +345,87 @@ private static Method getParentMethod(String className, String methodName) {\n \t\t\tConfigChildSetterDescriptor configChildDescriptor = configChildDescriptors.get(m.getName());\n \t\t\tClass<?> elementClass = m.getParameterTypes()[0];\n \t\t\tconfigChild.setElementType(findOrCreateElementType(elementClass));\n+\t\t\tconfigChild.setDocumented(m.getAnnotation(IbisDoc.class) != null);\n \t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(m, IbisDoc.class);\n \t\t\tconfigChild.setSequenceInConfigFromIbisDocAnnotation(ibisDoc);\n \t\t\tconfigChild.setAllowMultiple(configChildDescriptor.isAllowMultiple());\n \t\t\tconfigChild.setMandatory(configChildDescriptor.isMandatory());\n+\t\t\tconfigChild.setDeprecated(isDeprecated(m));\n \t\t\tconfigChild.setSyntax1Name(configChildDescriptor.getSyntax1Name());\n \t\t\tresult.add(configChild);\n+\t\t\tcalculateAliases(configChild);\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tprivate boolean isDeprecated(Method m) {\n+\t\tDeprecated deprecated = AnnotationUtils.findAnnotation(m, Deprecated.class);\n+\t\treturn (deprecated != null);\n+\t}\n+\n+\t// TODO: Unit test this\n+\tprivate void calculateAliases(ConfigChild configChild) {\n+\t\tif(! configChild.getElementType().isFromJavaInterface()) {\n+\t\t\tCollection<FrankElement> members = configChild.getElementType().getMembers().values();\n+\t\t\tif(members.size() >= 1) {\n+\t\t\t\tFrankElement aliased = members.iterator().next();\n+\t\t\t\taliased.addAliasSource(configChild);\n+\t\t\t} else {\n+\t\t\t\tlog.warn(String.format(\"Found empty element type: [%s]\", configChild.getElementType().getFullName()));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void buildGroups() {\n+\t\tMap<String, List<FrankDocGroup>> groupsBase = new HashMap<>();\n+\t\tList<FrankElement> membersOfOther = new ArrayList<>();\n+\t\tfor(ElementType elementType: getAllTypes().values()) {\n+\t\t\tif(elementType.isFromJavaInterface()) {\n+\t\t\t\tif(groupsBase.containsKey(elementType.getSimpleName())) {\n+\t\t\t\t\tgroupsBase.get(elementType.getSimpleName()).add(FrankDocGroup.getInstanceFromElementType(elementType));\n+\t\t\t\t} else {\n+\t\t\t\t\tgroupsBase.put(elementType.getSimpleName(), Arrays.asList(FrankDocGroup.getInstanceFromElementType(elementType)));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ttry {\n+\t\t\t\t\tmembersOfOther.add(elementType.getSingletonElement());\n+\t\t\t\t} catch(ReflectiveOperationException e) {\n+\t\t\t\t\tlog.warn(String.format(\"Error adding ElementType [%s] to group other because it has multiple FrankElement objects: [%s]\",\n+\t\t\t\t\t\t\t\telementType.getFullName(),\n+\t\t\t\t\t\t\t\telementType.getMembers().values().stream().map(FrankElement::getSimpleName).collect(Collectors.joining(\", \"))),\n+\t\t\t\t\t\t\te);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif(groupsBase.containsKey(OTHER)) {\n+\t\t\tlog.warn(String.format(\"Name [%s] cannot been used for other because it is the name of an ElementType\", OTHER));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAwNTIzNg==", "bodyText": "Ik heb dit comment ter harte genomen, maar ik weet niet zeker of je het zo goed vind. Ik resolve hem daarom nog niet.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535005236", "createdAt": "2020-12-03T09:32:01Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -308,13 +345,87 @@ private static Method getParentMethod(String className, String methodName) {\n \t\t\tConfigChildSetterDescriptor configChildDescriptor = configChildDescriptors.get(m.getName());\n \t\t\tClass<?> elementClass = m.getParameterTypes()[0];\n \t\t\tconfigChild.setElementType(findOrCreateElementType(elementClass));\n+\t\t\tconfigChild.setDocumented(m.getAnnotation(IbisDoc.class) != null);\n \t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(m, IbisDoc.class);\n \t\t\tconfigChild.setSequenceInConfigFromIbisDocAnnotation(ibisDoc);\n \t\t\tconfigChild.setAllowMultiple(configChildDescriptor.isAllowMultiple());\n \t\t\tconfigChild.setMandatory(configChildDescriptor.isMandatory());\n+\t\t\tconfigChild.setDeprecated(isDeprecated(m));\n \t\t\tconfigChild.setSyntax1Name(configChildDescriptor.getSyntax1Name());\n \t\t\tresult.add(configChild);\n+\t\t\tcalculateAliases(configChild);\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tprivate boolean isDeprecated(Method m) {\n+\t\tDeprecated deprecated = AnnotationUtils.findAnnotation(m, Deprecated.class);\n+\t\treturn (deprecated != null);\n+\t}\n+\n+\t// TODO: Unit test this\n+\tprivate void calculateAliases(ConfigChild configChild) {\n+\t\tif(! configChild.getElementType().isFromJavaInterface()) {\n+\t\t\tCollection<FrankElement> members = configChild.getElementType().getMembers().values();\n+\t\t\tif(members.size() >= 1) {\n+\t\t\t\tFrankElement aliased = members.iterator().next();\n+\t\t\t\taliased.addAliasSource(configChild);\n+\t\t\t} else {\n+\t\t\t\tlog.warn(String.format(\"Found empty element type: [%s]\", configChild.getElementType().getFullName()));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void buildGroups() {\n+\t\tMap<String, List<FrankDocGroup>> groupsBase = new HashMap<>();\n+\t\tList<FrankElement> membersOfOther = new ArrayList<>();\n+\t\tfor(ElementType elementType: getAllTypes().values()) {\n+\t\t\tif(elementType.isFromJavaInterface()) {\n+\t\t\t\tif(groupsBase.containsKey(elementType.getSimpleName())) {\n+\t\t\t\t\tgroupsBase.get(elementType.getSimpleName()).add(FrankDocGroup.getInstanceFromElementType(elementType));\n+\t\t\t\t} else {\n+\t\t\t\t\tgroupsBase.put(elementType.getSimpleName(), Arrays.asList(FrankDocGroup.getInstanceFromElementType(elementType)));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ttry {\n+\t\t\t\t\tmembersOfOther.add(elementType.getSingletonElement());\n+\t\t\t\t} catch(ReflectiveOperationException e) {\n+\t\t\t\t\tlog.warn(String.format(\"Error adding ElementType [%s] to group other because it has multiple FrankElement objects: [%s]\",\n+\t\t\t\t\t\t\t\telementType.getFullName(),\n+\t\t\t\t\t\t\t\telementType.getMembers().values().stream().map(FrankElement::getSimpleName).collect(Collectors.joining(\", \"))),\n+\t\t\t\t\t\t\te);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif(groupsBase.containsKey(OTHER)) {\n+\t\t\tlog.warn(String.format(\"Name [%s] cannot been used for other because it is the name of an ElementType\", OTHER));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NTMyMA=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Njk4MDczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDo1OTozM1rOH8w7kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOTozMToxMlrOH-ODOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3ODI5MA==", "bodyText": "Parent is hier toch: de java superclass? Dat mag hier wel in een comment.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533478290", "createdAt": "2020-12-01T14:59:33Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAwMzk2Mw==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535003963", "createdAt": "2020-12-03T09:31:12Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3ODI5MA=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Njk5NTUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNTowMjozMFrOH8xFCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOTozMDo0NlrOH-OAOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4MDcxMw==", "bodyText": "Je kan hier volstaan met een LinkedHashMap<String, FrankAttribute> attributes, en een LinkedHashMap<ConfigChildKey, ConfigChild> configChildren. Als je de List wil hebben, vraag je daar de .values() van op.\nHet voorkomt dat je dubbele inserts moet doen, en dat je velden hebt die '...lookup' heten.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533480713", "createdAt": "2020-12-01T15:02:30Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAwMzE5Mw==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535003193", "createdAt": "2020-12-03T09:30:46Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4MDcxMw=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzA1MTEwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToxMzoxOVrOH8xnYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDo0NToyM1rOH-fjsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4OTUwNA==", "bodyText": "Kan ConfigChild niet gewoon een getKey() method hebben?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533489504", "createdAt": "2020-12-01T15:13:19Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA3MTU4OQ==", "bodyText": "Gedaan. De prijs die we betalen is dat de key velden van ConfigChild in een String gecombineerd moeten worden. Dat was nodig om te zorgen dat ElementChild.getKey() van het type String kan zijn. Ik wilde het type argument K voor de key niet opnieuw invoeren, want ik voorzag veel problemen met type conversies tussen FrankAttribute, ConfigChild, ElementChild en ElementChild<?>", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535071589", "createdAt": "2020-12-03T10:30:42Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4OTUwNA=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA4ODk4Mw==", "bodyText": "Door de telefoon zei je dat je dat ik hier nog mee verder moet. Dat ga ik nog doen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535088983", "createdAt": "2020-12-03T10:46:20Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4OTUwNA=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI5MDgwMA==", "bodyText": "Ik heb mijn best gedaan. Er zijn in FrankElement vrij veel kasts tussen FrankAttribute, ElementChild en ConfigChild. Kan je kijken of je zo tevreden bent?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535290800", "createdAt": "2020-12-03T14:45:23Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4OTUwNA=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzA2MjEzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToxNTozOFrOH8xueg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMDo0Njo0MlrOH-TRAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5MTMyMg==", "bodyText": "Dit is eigenlijk: getNextAncestorThatHasChildren(). Dan is het beter om het ook zo te noemen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533491322", "createdAt": "2020-12-01T15:15:38Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));\n+\t}\n+\n+\tpublic <T extends ElementChild> FrankElement getNextAncestor(Predicate<ElementChild> childFilter, Class<T> kind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA4OTQxMQ==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535089411", "createdAt": "2020-12-03T10:46:42Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));\n+\t}\n+\n+\tpublic <T extends ElementChild> FrankElement getNextAncestor(Predicate<ElementChild> childFilter, Class<T> kind) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5MTMyMg=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzA3OTExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToxOTowNlrOH8x5PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMDo0NzoxN1rOH-TTZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NDA3Nw==", "bodyText": "als je getKey() in ElementChild definieert, en voor FrankAttribute implementeert als getName(), dan wordt deze code een stuk eenvoudiger.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533494077", "createdAt": "2020-12-01T15:19:06Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));\n+\t}\n+\n+\tpublic <T extends ElementChild> FrankElement getNextAncestor(Predicate<ElementChild> childFilter, Class<T> kind) {\n+\t\tFrankElement ancestor = parent;\n+\t\twhile((ancestor != null) && (ancestor.getChildren(childFilter, kind).size() == 0)) {\n+\t\t\tancestor = ancestor.getParent();\n+\t\t}\n+\t\treturn ancestor;\n+\t}\n+\n+\tpublic <T extends ElementChild> List<ElementChild> getChildren(Predicate<ElementChild> selector, Class<T> kind) {\n+\t\tList<ElementChild> result = new ArrayList<>();\n+\t\tif(kind.isAssignableFrom(FrankAttribute.class)) {\n+\t\t\tresult.addAll(getAttributes(selector));\n+\t\t}\n+\t\tif(kind.isAssignableFrom(ConfigChild.class)) {\n+\t\t\tresult.addAll(getConfigChildren(selector));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic void walkCumulativeAttributes(\n+\t\t\tCumulativeChildHandler<FrankAttribute> handler,\n+\t\t\tPredicate<ElementChild> childSelector,\n+\t\t\tPredicate<ElementChild> childRejector) {\n+\t\tnew AncestorChildNavigation<String, FrankAttribute>(\n+\t\t\t\thandler, childSelector, childRejector, FrankAttribute.class) {\n+\t\t\t@Override\n+\t\t\tString keyOf(ElementChild child) {\n+\t\t\t\treturn ((FrankAttribute) child).getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA5MDAyMQ==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535090021", "createdAt": "2020-12-03T10:47:17Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));\n+\t}\n+\n+\tpublic <T extends ElementChild> FrankElement getNextAncestor(Predicate<ElementChild> childFilter, Class<T> kind) {\n+\t\tFrankElement ancestor = parent;\n+\t\twhile((ancestor != null) && (ancestor.getChildren(childFilter, kind).size() == 0)) {\n+\t\t\tancestor = ancestor.getParent();\n+\t\t}\n+\t\treturn ancestor;\n+\t}\n+\n+\tpublic <T extends ElementChild> List<ElementChild> getChildren(Predicate<ElementChild> selector, Class<T> kind) {\n+\t\tList<ElementChild> result = new ArrayList<>();\n+\t\tif(kind.isAssignableFrom(FrankAttribute.class)) {\n+\t\t\tresult.addAll(getAttributes(selector));\n+\t\t}\n+\t\tif(kind.isAssignableFrom(ConfigChild.class)) {\n+\t\t\tresult.addAll(getConfigChildren(selector));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic void walkCumulativeAttributes(\n+\t\t\tCumulativeChildHandler<FrankAttribute> handler,\n+\t\t\tPredicate<ElementChild> childSelector,\n+\t\t\tPredicate<ElementChild> childRejector) {\n+\t\tnew AncestorChildNavigation<String, FrankAttribute>(\n+\t\t\t\thandler, childSelector, childRejector, FrankAttribute.class) {\n+\t\t\t@Override\n+\t\t\tString keyOf(ElementChild child) {\n+\t\t\t\treturn ((FrankAttribute) child).getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NDA3Nw=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzA4MzI1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToxOTo1NVrOH8x75g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMToxMjo1NlrOH-U8XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NDc1OA==", "bodyText": "Wat is een alias in dit geval? Zou je dat hier kunnen documenteren?\n-> ik zag later dat je dit al gedocumenteerd heb bij DocWriterNew. Toch graag hier ook twee regels, en evt. verwijzen naar DocWriterNew.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533494758", "createdAt": "2020-12-01T15:19:55Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));\n+\t}\n+\n+\tpublic <T extends ElementChild> FrankElement getNextAncestor(Predicate<ElementChild> childFilter, Class<T> kind) {\n+\t\tFrankElement ancestor = parent;\n+\t\twhile((ancestor != null) && (ancestor.getChildren(childFilter, kind).size() == 0)) {\n+\t\t\tancestor = ancestor.getParent();\n+\t\t}\n+\t\treturn ancestor;\n+\t}\n+\n+\tpublic <T extends ElementChild> List<ElementChild> getChildren(Predicate<ElementChild> selector, Class<T> kind) {\n+\t\tList<ElementChild> result = new ArrayList<>();\n+\t\tif(kind.isAssignableFrom(FrankAttribute.class)) {\n+\t\t\tresult.addAll(getAttributes(selector));\n+\t\t}\n+\t\tif(kind.isAssignableFrom(ConfigChild.class)) {\n+\t\t\tresult.addAll(getConfigChildren(selector));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic void walkCumulativeAttributes(\n+\t\t\tCumulativeChildHandler<FrankAttribute> handler,\n+\t\t\tPredicate<ElementChild> childSelector,\n+\t\t\tPredicate<ElementChild> childRejector) {\n+\t\tnew AncestorChildNavigation<String, FrankAttribute>(\n+\t\t\t\thandler, childSelector, childRejector, FrankAttribute.class) {\n+\t\t\t@Override\n+\t\t\tString keyOf(ElementChild child) {\n+\t\t\t\treturn ((FrankAttribute) child).getName();\n+\t\t\t}\n+\t\t}.run(this);\n+\t}\n+\n+\tpublic void walkCumulativeConfigChildren(\n+\t\t\tCumulativeChildHandler<ConfigChild> handler,\n+\t\t\tPredicate<ElementChild> childSelector,\n+\t\t\tPredicate<ElementChild> childRejector) {\n+\t\tnew AncestorChildNavigation<ConfigChildKey, ConfigChild>(\n+\t\t\t\thandler, childSelector, childRejector, ConfigChild.class) {\n+\t\t\t@Override\n+\t\t\tConfigChildKey keyOf(ElementChild child) {\n+\t\t\t\treturn new ConfigChildKey((ConfigChild) child);\n+\t\t\t}\n+\t\t}.run(this);\t\t\n+\t}\n+\n+\tpublic void addAliasSource(ConfigChild aliasSource) {\n+\t\taliasSources.add(aliasSource);\n+\t}\n+\n+\tpublic String getAlias() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTExNjg5Mg==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535116892", "createdAt": "2020-12-03T11:12:56Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,225 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n+\t@EqualsAndHashCode\n+\tprivate final class ConfigChildKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic ConfigChildKey(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter FrankElement parent;\n+\tprivate @Getter List<FrankAttribute> attributes;\n+\tprivate Map<String, FrankAttribute> attributeLookup;\n+\tprivate @Getter List<ConfigChild> configChildren;\n+\tprivate Map<ConfigChildKey, ConfigChild> configChildLookup;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.\n+\t * @param inputAttributes\n+\t */\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tCollections.sort(inputAttributes);\n+\t\tthis.attributes = Collections.unmodifiableList(inputAttributes);\n+\t\tattributeLookup = new HashMap<>();\n+\t\tfor(FrankAttribute a: attributes) {\n+\t\t\tif(attributeLookup.containsKey(a.getName())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes with name [%s]\",\n+\t\t\t\t\t\tfullName, a.getName()));\n+\t\t\t} else {\n+\t\t\t\tattributeLookup.put(a.getName(), a);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<? super FrankAttribute> filter) {\n+\t\treturn attributes.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\t/**\n+\t * Setter for config children. We prevent modifying the list of config children\n+\t * because we want to maintain the private field configChildLookup.\n+\t * @param children\n+\t */\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tCollections.sort(children);\n+\t\tthis.configChildren = Collections.unmodifiableList(children);\n+\t\tconfigChildLookup = new HashMap<>();\n+\t\tfor(ConfigChild c: children) {\n+\t\t\tConfigChildKey key = new ConfigChildKey(c);\n+\t\t\tif(configChildLookup.containsKey(key)) {\n+\t\t\t\tlog.warn(String.format(\"Different config children of Frank element [%s] have the same key\", fullName));\n+\t\t\t} else {\n+\t\t\t\tconfigChildLookup.put(key, c);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<? super ConfigChild> filter) {\n+\t\treturn configChildren.stream().filter(filter).collect(Collectors.toList());\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild) {\n+\t\tif(elementChild instanceof FrankAttribute) {\n+\t\t\treturn findAttributeMatch((FrankAttribute) elementChild);\n+\t\t} else if(elementChild instanceof ConfigChild) {\n+\t\t\treturn findConfigChildMatch((ConfigChild) elementChild);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"Expected a FrankAttribute or ConfigChild, but got a [%s]\",\n+\t\t\t\t\telementChild.getClass().getName()));\n+\t\t}\n+\t}\n+\n+\tFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n+\t\treturn attributeLookup.get(attribute.getName());\n+\t}\n+\n+\tConfigChild findConfigChildMatch(ConfigChild configChild) {\n+\t\treturn configChildLookup.get(new ConfigChildKey(configChild));\n+\t}\n+\n+\tpublic <T extends ElementChild> FrankElement getNextAncestor(Predicate<ElementChild> childFilter, Class<T> kind) {\n+\t\tFrankElement ancestor = parent;\n+\t\twhile((ancestor != null) && (ancestor.getChildren(childFilter, kind).size() == 0)) {\n+\t\t\tancestor = ancestor.getParent();\n+\t\t}\n+\t\treturn ancestor;\n+\t}\n+\n+\tpublic <T extends ElementChild> List<ElementChild> getChildren(Predicate<ElementChild> selector, Class<T> kind) {\n+\t\tList<ElementChild> result = new ArrayList<>();\n+\t\tif(kind.isAssignableFrom(FrankAttribute.class)) {\n+\t\t\tresult.addAll(getAttributes(selector));\n+\t\t}\n+\t\tif(kind.isAssignableFrom(ConfigChild.class)) {\n+\t\t\tresult.addAll(getConfigChildren(selector));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic void walkCumulativeAttributes(\n+\t\t\tCumulativeChildHandler<FrankAttribute> handler,\n+\t\t\tPredicate<ElementChild> childSelector,\n+\t\t\tPredicate<ElementChild> childRejector) {\n+\t\tnew AncestorChildNavigation<String, FrankAttribute>(\n+\t\t\t\thandler, childSelector, childRejector, FrankAttribute.class) {\n+\t\t\t@Override\n+\t\t\tString keyOf(ElementChild child) {\n+\t\t\t\treturn ((FrankAttribute) child).getName();\n+\t\t\t}\n+\t\t}.run(this);\n+\t}\n+\n+\tpublic void walkCumulativeConfigChildren(\n+\t\t\tCumulativeChildHandler<ConfigChild> handler,\n+\t\t\tPredicate<ElementChild> childSelector,\n+\t\t\tPredicate<ElementChild> childRejector) {\n+\t\tnew AncestorChildNavigation<ConfigChildKey, ConfigChild>(\n+\t\t\t\thandler, childSelector, childRejector, ConfigChild.class) {\n+\t\t\t@Override\n+\t\t\tConfigChildKey keyOf(ElementChild child) {\n+\t\t\t\treturn new ConfigChildKey((ConfigChild) child);\n+\t\t\t}\n+\t\t}.run(this);\t\t\n+\t}\n+\n+\tpublic void addAliasSource(ConfigChild aliasSource) {\n+\t\taliasSources.add(aliasSource);\n+\t}\n+\n+\tpublic String getAlias() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NDc1OA=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzI0NDA4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/AncestorChildNavigation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNTo1MTozN1rOH8ze3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMToxNjoxOVrOH-VJmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUyMDA5NQ==", "bodyText": "Uit de private methods declaredGroupOrRepeatedChildren() in deze class maak ik op dat deze bedoeld is voor gebruik bij het opbouwen van de Xsd. Klopt dat? Dan zou dat ook in de naam naar voren moeten komen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r533520095", "createdAt": "2020-12-01T15:51:37Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/AncestorChildNavigation.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+abstract class AncestorChildNavigation<K, T extends ElementChild> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEyMDI4Mw==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535120283", "createdAt": "2020-12-03T11:16:19Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/AncestorChildNavigation.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+abstract class AncestorChildNavigation<K, T extends ElementChild> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUyMDA5NQ=="}, "originalCommit": {"oid": "c73e7597062e96b0b6548604e17bfee63f37d102"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODgzMjIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo1MDoxNFrOH-jdqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo1MDoxNFrOH-jdqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NDc5Mg==", "bodyText": "Key kan in deze samenstelling ook een interface zijn, wat door ConfigChild ge\u00efmplementeerd wordt.\nDan hoef je niet steeds een nieuw object te maken, maar kan je in getKey() gewoon 'this' teruggeven.\nHm, oh nee, toch niet, gaat niet goed met hashCode() en equals().\nNegeer deze feedback dus maar.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535354792", "createdAt": "2020-12-03T15:50:14Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -1,31 +1,69 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.Comparator;\n+\n import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.Setter;\n import nl.nn.adapterframework.doc.IbisDoc;\n import nl.nn.adapterframework.util.LogUtil;\n \n-public class ConfigChild {\n+public class ConfigChild extends ElementChild<ConfigChild.Key, ConfigChild> implements Comparable<ConfigChild> {\n \tprivate static Logger log = LogUtil.getLogger(ConfigChild.class);\n \n-\tprivate @Getter FrankElement configParent;\n+\t@EqualsAndHashCode\n+\tstatic final class Key {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;\n+\t\tprivate final @Getter boolean mandatory;\n+\t\tprivate final @Getter boolean allowMultiple;\n+\n+\t\tpublic Key(ConfigChild configChild) {\n+\t\t\tsyntax1Name = configChild.getSyntax1Name();\n+\t\t\telementType = configChild.getElementType();\n+\t\t\tmandatory = configChild.isMandatory();\n+\t\t\tallowMultiple = configChild.isAllowMultiple();\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODg2ODIwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo1NjozOFrOH-jzPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOToyOToxNFrOH_ISJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2MDMxOA==", "bodyText": "is a descendant of {@link FrankElement} <code>B</code>, toch?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535360318", "createdAt": "2020-12-03T15:56:38Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.\n+ *\n+ * @param <K> The type used to store keys, which are used to search for overrides.\n+ * @param <T> {@link FrankAttribute} or {@link ConfigChild}\n+ * \n+ * @author martijn\n+ */\n+public abstract class ElementChild<K, T extends ElementChild<K, T>> {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild<?, ?>> IN_XSD = c ->\n+\t\t(! c.isDeprecated())\n+\t\t&& (c.isDocumented() || (c.getOverriddenFrom() == null));\n+\n+\tpublic static Predicate<ElementChild<?, ?>> DEPRECATED = c -> c.isDeprecated();\n+\tpublic static Predicate<ElementChild<?, ?>> ALL = c -> true;\n+\tpublic static Predicate<ElementChild<?, ?>> NONE = c -> false;\n+\n+\tElementChild(final FrankElement owningElement) {\n+\t\tthis.owningElement = owningElement;\n+\t}\n+\n+\tvoid calculateOverriddenFrom() {\n+\t\tFrankElement match = getOwningElement();\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tElementChild<K, T> matchingChild = match.findElementChildMatch(this);\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\toverriddenFrom = match;\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get key that is used to match overrides. If {@link FrankElement} <code>A</code>\n+\t * is a descendant of {@link FrankAttribute} <code>B</code> and if their", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk1ODA1Mw==", "bodyText": "Ja, je hebt gelijk. Ik heb het verbeterd.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535958053", "createdAt": "2020-12-04T09:29:14Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.\n+ *\n+ * @param <K> The type used to store keys, which are used to search for overrides.\n+ * @param <T> {@link FrankAttribute} or {@link ConfigChild}\n+ * \n+ * @author martijn\n+ */\n+public abstract class ElementChild<K, T extends ElementChild<K, T>> {\n+\tprivate @Getter FrankElement owningElement;\n+\t\n+\t/**\n+\t * The value is inherited from ElementChild corresponding to superclass.\n+\t */\n+\tprivate @Getter @Setter boolean deprecated;\n+\t\n+\t/**\n+\t * Only set to true if there is an IbisDoc or IbisDocRef annotation for\n+\t * this specific ElementChild, excluding inheritance. This property is\n+\t * intended to detect Java Override annotations that are only there for\n+\t * technical reasons, without relevance to the Frank developer.\n+\t * \n+\t * But values inside IbisDoc or IbisDocRef annotations are inherited.\n+\t * That is the case to allow documentation information to be stored more\n+\t * centrally.\n+\t */\n+\tprivate @Getter @Setter boolean documented;\n+\tprivate @Getter FrankElement overriddenFrom;\n+\n+\tpublic static Predicate<ElementChild<?, ?>> IN_XSD = c ->\n+\t\t(! c.isDeprecated())\n+\t\t&& (c.isDocumented() || (c.getOverriddenFrom() == null));\n+\n+\tpublic static Predicate<ElementChild<?, ?>> DEPRECATED = c -> c.isDeprecated();\n+\tpublic static Predicate<ElementChild<?, ?>> ALL = c -> true;\n+\tpublic static Predicate<ElementChild<?, ?>> NONE = c -> false;\n+\n+\tElementChild(final FrankElement owningElement) {\n+\t\tthis.owningElement = owningElement;\n+\t}\n+\n+\tvoid calculateOverriddenFrom() {\n+\t\tFrankElement match = getOwningElement();\n+\t\twhile(match.getParent() != null) {\n+\t\t\tmatch = match.getParent();\n+\t\t\tElementChild<K, T> matchingChild = match.findElementChildMatch(this);\n+\t\t\tif(matchingChild != null) {\n+\t\t\t\toverriddenFrom = match;\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Get key that is used to match overrides. If {@link FrankElement} <code>A</code>\n+\t * is a descendant of {@link FrankAttribute} <code>B</code> and if their", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2MDMxOA=="}, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODk3MjYyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoxNjo1MVrOH-kyUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOToyODo0M1rOH_IQsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NjQ2Ng==", "bodyText": "'that has the classes that implement the interface of an {@link ElementType} that is defined with that interface',", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535376466", "createdAt": "2020-12-03T16:16:51Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -1,13 +1,113 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n import lombok.Getter;\n \n-public class FrankDocGroup {\n+/**\n+ * Holds a group of FrankElement objects for the Frank!Doc website.\n+ * This website will show a table-of-contents with the groups. When you\n+ * select a group, the FrankElement objects inside will be shown.\n+ * <p>\n+ * There are two kinds of groups that are represented by two subclasses of\n+ * {@link FrankDocGroup} that are also inner classes, namely\n+ * <code>FromType</code> and <code>Other</code>. <code>FromType</code>\n+ * holds a group that has the classes of an {@link ElementType}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk1NzY4Mw==", "bodyText": "Ik haal hier uit dat je het onderscheid wilt zien tussen model objecten (bijvoorbeeld FrankElement) en de Java classes die erdoor worden gerepresenteerd. Ik heb je suggestie niet letterlijk overgenomen, maar deze gedachte heb ik verwerkt. Ik ben benieuwd wat je ervan vindt.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535957683", "createdAt": "2020-12-04T09:28:43Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -1,13 +1,113 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n import lombok.Getter;\n \n-public class FrankDocGroup {\n+/**\n+ * Holds a group of FrankElement objects for the Frank!Doc website.\n+ * This website will show a table-of-contents with the groups. When you\n+ * select a group, the FrankElement objects inside will be shown.\n+ * <p>\n+ * There are two kinds of groups that are represented by two subclasses of\n+ * {@link FrankDocGroup} that are also inner classes, namely\n+ * <code>FromType</code> and <code>Other</code>. <code>FromType</code>\n+ * holds a group that has the classes of an {@link ElementType}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NjQ2Ng=="}, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODk3NzE4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoxNzo0M1rOH-k1Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOToyNToyMVrOH_IIFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzE2Nw==", "bodyText": "'that are each defined with a class rather then with an interface'", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535377167", "createdAt": "2020-12-03T16:17:43Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -1,13 +1,113 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n import lombok.Getter;\n \n-public class FrankDocGroup {\n+/**\n+ * Holds a group of FrankElement objects for the Frank!Doc website.\n+ * This website will show a table-of-contents with the groups. When you\n+ * select a group, the FrankElement objects inside will be shown.\n+ * <p>\n+ * There are two kinds of groups that are represented by two subclasses of\n+ * {@link FrankDocGroup} that are also inner classes, namely\n+ * <code>FromType</code> and <code>Other</code>. <code>FromType</code>\n+ * holds a group that has the classes of an {@link ElementType}.\n+ * <code>Other</code> holds a group of remaining {@link FrankElement}\n+ * that can be part of different {@link ElementType} objects.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk1NTQ3OQ==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535955479", "createdAt": "2020-12-04T09:25:21Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocGroup.java", "diffHunk": "@@ -1,13 +1,113 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n import lombok.Getter;\n \n-public class FrankDocGroup {\n+/**\n+ * Holds a group of FrankElement objects for the Frank!Doc website.\n+ * This website will show a table-of-contents with the groups. When you\n+ * select a group, the FrankElement objects inside will be shown.\n+ * <p>\n+ * There are two kinds of groups that are represented by two subclasses of\n+ * {@link FrankDocGroup} that are also inner classes, namely\n+ * <code>FromType</code> and <code>Other</code>. <code>FromType</code>\n+ * holds a group that has the classes of an {@link ElementType}.\n+ * <code>Other</code> holds a group of remaining {@link FrankElement}\n+ * that can be part of different {@link ElementType} objects.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzE2Nw=="}, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODk5OTczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoyMjowOVrOH-lCbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzowODoxMFrOH_QKNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4MDU4OA==", "bodyText": "De reden om de attributes niet te kunnen modificeren is er niet meer. Of is er nog een andere reden?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535380588", "createdAt": "2020-12-03T16:22:09Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,231 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\n+\t// Represents the Java superclass.\n+\tprivate @Getter FrankElement parent;\n+\n+\tprivate LinkedHashMap<String, FrankAttribute> attributes;\n+\tprivate LinkedHashMap<ConfigChild.Key, ConfigChild> configChildren;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkzNTM0NQ==", "bodyText": "Ik heb dit comment weggehaald.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535935345", "createdAt": "2020-12-04T08:53:51Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,231 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\n+\t// Represents the Java superclass.\n+\tprivate @Getter FrankElement parent;\n+\n+\tprivate LinkedHashMap<String, FrankAttribute> attributes;\n+\tprivate LinkedHashMap<ConfigChild.Key, ConfigChild> configChildren;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4MDU4OA=="}, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NzA5NQ==", "bodyText": "Dit overbodige commentaar stond er ook voor config children. Daar is het nu ook weg.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r536087095", "createdAt": "2020-12-04T13:08:10Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,231 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\n+\t// Represents the Java superclass.\n+\tprivate @Getter FrankElement parent;\n+\n+\tprivate LinkedHashMap<String, FrankAttribute> attributes;\n+\tprivate LinkedHashMap<ConfigChild.Key, ConfigChild> configChildren;\n+\tprivate @Getter List<ConfigChild> aliasSources;\n+\tprivate String cachedAlias = null;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.aliasSources = new ArrayList<>();\n+\t}\n+\n+\tpublic FrankElement(final String fullName, final String simpleName) {\n+\t\tthis(fullName, simpleName, false);\n+\t}\n+\t\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\t/**\n+\t * Setter for attributes. We prevent modifying the list of attributes\n+\t * because we want to maintain the private field attributeLookup.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4MDU4OA=="}, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MjM4MTc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNzoyMzoyM1rOH_D_Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzowNjowOFrOH_QFeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4NzcxNQ==", "bodyText": "Als je in ElementChild een Kind maakt, zoals:\nenum Kind {\n\tATTRIBUTE,\n\tCONFIGCHILD;\n}\n\nen ElementChild een getKind() geeft, dan kan je in FrankElement:\nprivate LinkedHashMap<String, FrankAttribute> attributes;\nprivate LinkedHashMap<ConfigChild.Key, ConfigChild> configChildren;\n\nvervangen door:\nprivate Map<Kind, LinkedHashMap<Object, ElementChild>> children;\n\nJe kan dan heel veel code die je nu apart hebt uitgeschreven voor Attributes en ConfigChildren op het niveau van ElementChild brengen.\nBijvoorbeeld:\nFrankAttribute findAttributeMatch(FrankAttribute attribute) {\n\treturn attributes.get(attribute.getKey());\n}\n\nConfigChild findConfigChildMatch(ConfigChild configChild) {\n\treturn configChildren.get(configChild.getKey());\n}\n\nvervangen door\n<C extends ElementChild> C findElementChild(C child) {\n\treturn children.get(child.getKind()).get(child.getKey());\n}\n\nJe hoeft dan ook geen elementChild instanceof meer te doen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r535887715", "createdAt": "2020-12-04T07:23:23Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,231 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\n+\t// Represents the Java superclass.\n+\tprivate @Getter FrankElement parent;\n+\n+\tprivate LinkedHashMap<String, FrankAttribute> attributes;\n+\tprivate LinkedHashMap<ConfigChild.Key, ConfigChild> configChildren;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NTg4MA==", "bodyText": "Gelukt! Dank voor deze tip!", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r536085880", "createdAt": "2020-12-04T13:06:08Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,231 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\n+\t// Represents the Java superclass.\n+\tprivate @Getter FrankElement parent;\n+\n+\tprivate LinkedHashMap<String, FrankAttribute> attributes;\n+\tprivate LinkedHashMap<ConfigChild.Key, ConfigChild> configChildren;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4NzcxNQ=="}, "originalCommit": {"oid": "419ff084eae3388bebafc4f07d03beb6ebbf30d9"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzgxNzA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzoyMzo1M1rOH_QumQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxMzoxM1rOIAfU-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5NjQwOQ==", "bodyText": "Deze doe je ook al op regel 60", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r536096409", "createdAt": "2020-12-04T13:23:53Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -57,7 +86,7 @@ public static FrankDocModel populate() {\n \n \tpublic FrankDocModel() {\n \t\tconfigChildDescriptors = new HashMap<>();\n-\t\tgroups = new HashMap<>();\n+\t\tgroups = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c61ea434d430051261716c91140e822403b7f98"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NDE4Ng==", "bodyText": "Gedaan. Ik heb de laatste initializatie ook uit de constructor gehaald zodat de constructor weg kan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r537384186", "createdAt": "2020-12-07T10:13:13Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -57,7 +86,7 @@ public static FrankDocModel populate() {\n \n \tpublic FrankDocModel() {\n \t\tconfigChildDescriptors = new HashMap<>();\n-\t\tgroups = new HashMap<>();\n+\t\tgroups = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5NjQwOQ=="}, "originalCommit": {"oid": "3c61ea434d430051261716c91140e822403b7f98"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Mzg1MTQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/GroupCreator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzozMjoxMVrOH_RCCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDoxMjoxNFrOIAfSXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMTM4Nw==", "bodyText": "hasNoConfigChildren is hier eigenlijk: hasNoElementChildrenOfKind", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r536101387", "createdAt": "2020-12-04T13:32:11Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/GroupCreator.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import nl.nn.adapterframework.doc.model.CumulativeChildHandler;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Helper class for building attribute groups and config child groups from the model.\n+ * See {@link DocWriterNew} to understand what we try to achieve.\n+ *\n+ * @author martijn\n+ *\n+ */\n+class GroupCreator<T extends ElementChild> {\n+\tstatic interface Callback<T extends ElementChild> extends CumulativeChildHandler<T> {\n+\t\tList<T> getChildrenOf(FrankElement elem);\n+\t\tFrankElement getAncestorOf(FrankElement elem);\n+\t\tvoid addDeclaredGroup();\n+\t\tvoid addCumulativeGroup();\n+\t\tvoid addDeclaredGroupRef(FrankElement referee);\n+\t\tvoid addCumulativeGroupRef(FrankElement referee);\n+\t}\n+\n+\tprivate FrankElement frankElement;\n+\tprivate Callback<T> callback;\n+\tprivate Consumer<Callback<T>> cumulativeGroupTrigger;\n+\n+\tGroupCreator(\n+\t\t\tFrankElement frankElement,\n+\t\t\tConsumer<Callback<T>> cumulativeGroupTrigger,\n+\t\t\tCallback<T> callback) {\n+\t\tthis.frankElement = frankElement;\n+\t\tthis.cumulativeGroupTrigger = cumulativeGroupTrigger;\n+\t\tthis.callback = callback;\n+\t}\n+\n+\tvoid run() {\n+\t\tboolean hasNoConfigChildren = callback.getChildrenOf(frankElement).isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c61ea434d430051261716c91140e822403b7f98"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4MzUxOA==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r537383518", "createdAt": "2020-12-07T10:12:14Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/GroupCreator.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import nl.nn.adapterframework.doc.model.CumulativeChildHandler;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+\n+/**\n+ * Helper class for building attribute groups and config child groups from the model.\n+ * See {@link DocWriterNew} to understand what we try to achieve.\n+ *\n+ * @author martijn\n+ *\n+ */\n+class GroupCreator<T extends ElementChild> {\n+\tstatic interface Callback<T extends ElementChild> extends CumulativeChildHandler<T> {\n+\t\tList<T> getChildrenOf(FrankElement elem);\n+\t\tFrankElement getAncestorOf(FrankElement elem);\n+\t\tvoid addDeclaredGroup();\n+\t\tvoid addCumulativeGroup();\n+\t\tvoid addDeclaredGroupRef(FrankElement referee);\n+\t\tvoid addCumulativeGroupRef(FrankElement referee);\n+\t}\n+\n+\tprivate FrankElement frankElement;\n+\tprivate Callback<T> callback;\n+\tprivate Consumer<Callback<T>> cumulativeGroupTrigger;\n+\n+\tGroupCreator(\n+\t\t\tFrankElement frankElement,\n+\t\t\tConsumer<Callback<T>> cumulativeGroupTrigger,\n+\t\t\tCallback<T> callback) {\n+\t\tthis.frankElement = frankElement;\n+\t\tthis.cumulativeGroupTrigger = cumulativeGroupTrigger;\n+\t\tthis.callback = callback;\n+\t}\n+\n+\tvoid run() {\n+\t\tboolean hasNoConfigChildren = callback.getChildrenOf(frankElement).isEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwMTM4Nw=="}, "originalCommit": {"oid": "3c61ea434d430051261716c91140e822403b7f98"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTAzNTkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjozMTo0NVrOIAvWTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTo1OToxOVrOIBWZ0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY0NjY2OA==", "bodyText": "Volgens mij is recursie niet nodig. Uit het ElementType genereer je groepen voor elke syntax1naam. Die groepen bevatten een choice van elementen met een samengestelde naam (bijv. JavaErrorSender) en een verwijzing naar een complex-type. Die complex-types zijn voor elke syntax1naam binnen het ElementType hetzelfde, en kunnen dus gedeeld worden.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r537646668", "createdAt": "2020-12-07T16:31:45Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -113,6 +113,29 @@ public int compareTo(ElementChild other) {\n \t\treturn CONFIG_CHILD_COMPARATOR.compare(this, (ConfigChild) other);\n \t}\n \n+\t/**\n+\t * Registers the syntax 1 name of this {@link ConfigChild} with the\n+\t * {@link ElementType}. This is done recursively because the XSD does\n+\t * not only use the declared config children, but also the inherited\n+\t * config children of a {@link FrankElement}. For each combination of\n+\t * a syntax 1 name and an {@link ElementChild}, we have &lt;xs:group&gt;\n+\t * declarations in the XSD. The recursion ensures that references to\n+\t * ancestor groups are valid.\n+\t */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d04fb72fd6a983e48a44437e921e02b06da1eb"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI4NjU0Ng==", "bodyText": "Je hebt gelijk. Ik heb het aangepast.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r538286546", "createdAt": "2020-12-08T11:59:19Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -113,6 +113,29 @@ public int compareTo(ElementChild other) {\n \t\treturn CONFIG_CHILD_COMPARATOR.compare(this, (ConfigChild) other);\n \t}\n \n+\t/**\n+\t * Registers the syntax 1 name of this {@link ConfigChild} with the\n+\t * {@link ElementType}. This is done recursively because the XSD does\n+\t * not only use the declared config children, but also the inherited\n+\t * config children of a {@link FrankElement}. For each combination of\n+\t * a syntax 1 name and an {@link ElementChild}, we have &lt;xs:group&gt;\n+\t * declarations in the XSD. The recursion ensures that references to\n+\t * ancestor groups are valid.\n+\t */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY0NjY2OA=="}, "originalCommit": {"oid": "44d04fb72fd6a983e48a44437e921e02b06da1eb"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTA0NzY2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjozNDowNlrOIAvdJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjozNDowNlrOIAvdJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY0ODQyMg==", "bodyText": "Als je in plaats van een TreeSet een LinkedHashSet gebruikt, blijft de volgorde van toevoegen behouden. Dan komt Sender voor ErrorSender, en dat is prettig.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r537648422", "createdAt": "2020-12-07T16:34:06Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "diffHunk": "@@ -35,6 +37,15 @@\n \tprivate @Getter String simpleName;\n \tprivate @Getter Map<String, FrankElement> members;\n \tprivate @Getter boolean fromJavaInterface;\n+\t\n+\t/**\n+\t * For each syntax 1 name in this set, an &lt;xs:choice&gt; of &lt;xs:element&gt;\n+\t * is created in the XSD. The elements in a group correspond to the Java\n+\t * classes that implement the Java interface represented by this {@link ElementChild}.\n+\t * For each syntax 1 name a different group is needed because the syntax 2\n+\t * names of the elements are different.\n+\t */\n+\tprivate @Getter Set<String> configChildSyntax1Names = new TreeSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d04fb72fd6a983e48a44437e921e02b06da1eb"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTI1NzE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/XsdWriteFilter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOToxNDoxNlrOIG7PIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMTozNTo1OFrOINukGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzMjg5OQ==", "bodyText": "Deze class heet 'Filter', maar is nu een wrapper rondom DocWriterNewXmlUtils.\nHet lijkt me een complexe oplossing voor de wens om de simpele elementen eerst af te drukken.\nIk had me voorgesteld dat je dat niet zou bouwen als een afdrukfilter, maar als een selectiefilter:\nDat je eerst door alle simpele elementen heen itereert, en daar je ding op doet,\nen vervolgens door de complexe elementen, en dan die doet.\nOok vind ik het niet elegant dat deze class all DocWriterNewXmlUtils methods kopieert.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r544132899", "createdAt": "2020-12-16T09:14:16Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/XsdWriteFilter.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+abstract class XsdWriteFilter {\n+\tboolean isWritingOn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk2NDM2NA==", "bodyText": "Gerrit we hebben overlegd over de oplossing. Ik ga na de vacantie een helper class XmlGroupBuilder maken in package nl.nn.adapterframework.util. Die krijgt ongeveer dezelfde interface als XmlBuilder, maar maakt het mogelijk om XML elementen toe te voegen in een groep. In mijn helper class DocWriterNewXmlUtils heb ik nu methods als addElement, addComplexContent, etc. om de verschillende elementen aan de XSD toe te voegen. Die gebruiken onder water XmlBuilder, maar kunnen dan XmlGroupBuilder gaan gebruiken waar nodig. Het groeperen voegt dan bijna geen complexiteit meer toe aan DocWriterNew.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545964364", "createdAt": "2020-12-18T17:00:09Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/XsdWriteFilter.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+abstract class XsdWriteFilter {\n+\tboolean isWritingOn;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzMjg5OQ=="}, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI2NTMwNg==", "bodyText": "We hebben na mijn vakantie kort overlegd over bovenstaand idee. Er is geen helper class nodig, alleen twee lijstjes met XmlBuilder objecten. Ik heb net een commit gepushed met deze oplossing, en het wordt best elegant. Er is geen complexe architectuur nodig. Dank voor je feedback.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551265306", "createdAt": "2021-01-04T11:35:58Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/XsdWriteFilter.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+abstract class XsdWriteFilter {\n+\tboolean isWritingOn;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzMjg5OQ=="}, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTM4MjM5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTo0MDoyOFrOIG8XJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDo0Mzo1NVrOIIliWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1MTMzMw==", "bodyText": "Moet dit niet zijn: findOrRegisterElementRole() ?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r544151333", "createdAt": "2020-12-16T09:40:28Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -143,10 +177,18 @@ public FrankElement findOrCreateFrankElement(Class<?> clazz) throws ReflectiveOp\n \t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n \t\tcurrent.setParent(parent);\n \t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n-\t\tcurrent.setConfigChildren(createConfigChildren(clazz.getMethods(), current));\n+\t\tcurrent.setConfigChildren(createConfigChildren(clazz.getDeclaredMethods(), current));\n+\t\t// Cannot be done directly by ConfigChild because the sequence is important.\n+\t\t// The call to setConfigChildren does the sorting.\n+\t\tcurrent.getConfigChildren(ALL).forEach(\n+\t\t\t\tc -> c.registerSyntax1NameWithElementType(c.getSyntax1Name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3NDUyMw==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545874523", "createdAt": "2020-12-18T14:43:55Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -143,10 +177,18 @@ public FrankElement findOrCreateFrankElement(Class<?> clazz) throws ReflectiveOp\n \t\tFrankElement parent = superClass == null ? null : findOrCreateFrankElement(superClass);\n \t\tcurrent.setParent(parent);\n \t\tcurrent.setAttributes(createAttributes(clazz.getDeclaredMethods(), current));\n-\t\tcurrent.setConfigChildren(createConfigChildren(clazz.getMethods(), current));\n+\t\tcurrent.setConfigChildren(createConfigChildren(clazz.getDeclaredMethods(), current));\n+\t\t// Cannot be done directly by ConfigChild because the sequence is important.\n+\t\t// The call to setConfigChildren does the sorting.\n+\t\tcurrent.getConfigChildren(ALL).forEach(\n+\t\t\t\tc -> c.registerSyntax1NameWithElementType(c.getSyntax1Name()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1MTMzMw=="}, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTUwODE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDowNzo1MVrOIG9hvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxODo0Njo0NFrOIIDvFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MDQzMQ==", "bodyText": "Een ConfigChild ontstaat doordat er een ConfigChildSetter method is in een FrankElement.\nEr is dan een 'syntax1naam' en een 'class of interface'.\nDe 'class of interface' definieert het ElementType\nDe combinatie van 'syntax1naam' en ElementType bepaalt ElementRole\nNu heeft ConfigChild een syntax1Naam en ElementType.\nDat zou moeten zijn: een ElementRole\nIk denk dat het beter is om in ConfigChild alleen maar een verwijzing naar ElementRole te hebben, en geen syntax1Name en ElementType meer.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r544170431", "createdAt": "2020-12-16T10:07:51Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -1,31 +1,82 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.Setter;\n import nl.nn.adapterframework.doc.IbisDoc;\n import nl.nn.adapterframework.util.LogUtil;\n \n-public class ConfigChild {\n+public class ConfigChild extends ElementChild {\n \tprivate static Logger log = LogUtil.getLogger(ConfigChild.class);\n \n-\tprivate @Getter FrankElement configParent;\n+\t@EqualsAndHashCode(callSuper = false)\n+\tstatic final class Key extends AbstractKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMyMDcyNQ==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545320725", "createdAt": "2020-12-17T18:46:44Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -1,31 +1,82 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n import org.apache.logging.log4j.Logger;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.Setter;\n import nl.nn.adapterframework.doc.IbisDoc;\n import nl.nn.adapterframework.util.LogUtil;\n \n-public class ConfigChild {\n+public class ConfigChild extends ElementChild {\n \tprivate static Logger log = LogUtil.getLogger(ConfigChild.class);\n \n-\tprivate @Getter FrankElement configParent;\n+\t@EqualsAndHashCode(callSuper = false)\n+\tstatic final class Key extends AbstractKey {\n+\t\tprivate final @Getter String syntax1Name;\n+\t\tprivate final @Getter ElementType elementType;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MDQzMQ=="}, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTUzNTA1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxMzo1NFrOIG9xng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDo0MzozMFrOIIlgkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NDQ5NA==", "bodyText": "Ik denk dat dit beter een Map<String,ElementRole>kan zijn", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r544174494", "createdAt": "2020-12-16T10:13:54Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "diffHunk": "@@ -1,15 +1,53 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n import java.util.Map;\n \n import lombok.Getter;\n \n+/**\n+ * Represents a type of FrankElement instances, which appears in the FF! Java code as\n+ * a Java interface. FrankElement objects that represent an abstract Java class should\n+ * be omitted as members. This is done automatically when Spring is used to get the\n+ * implementing classes of a Java interface.\n+ *\n+ * @author martijn\n+ *\n+ */\n public class ElementType {\n \tprivate @Getter String fullName;\n \tprivate @Getter String simpleName;\n \tprivate @Getter Map<String, FrankElement> members;\n \tprivate @Getter boolean fromJavaInterface;\n+\t\n+\t/**\n+\t * For each syntax 1 name in this set, an &lt;xs:choice&gt; of &lt;xs:element&gt;\n+\t * is created in the XSD. The elements in a group correspond to the Java\n+\t * classes that implement the Java interface represented by this {@link ElementChild}.\n+\t * For each syntax 1 name a different group is needed because the syntax 2\n+\t * names of the elements are different.\n+\t * <p>\n+\t * A {@link LinkedHashSet} is being used to preserve the sequence with which\n+\t * the syntax 1 names were inserted.\n+\t */\n+\tprivate @Getter LinkedHashSet<String> configChildSyntax1Names = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3NDA2Ng==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545874066", "createdAt": "2020-12-18T14:43:30Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "diffHunk": "@@ -1,15 +1,53 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n import java.util.Map;\n \n import lombok.Getter;\n \n+/**\n+ * Represents a type of FrankElement instances, which appears in the FF! Java code as\n+ * a Java interface. FrankElement objects that represent an abstract Java class should\n+ * be omitted as members. This is done automatically when Spring is used to get the\n+ * implementing classes of a Java interface.\n+ *\n+ * @author martijn\n+ *\n+ */\n public class ElementType {\n \tprivate @Getter String fullName;\n \tprivate @Getter String simpleName;\n \tprivate @Getter Map<String, FrankElement> members;\n \tprivate @Getter boolean fromJavaInterface;\n+\t\n+\t/**\n+\t * For each syntax 1 name in this set, an &lt;xs:choice&gt; of &lt;xs:element&gt;\n+\t * is created in the XSD. The elements in a group correspond to the Java\n+\t * classes that implement the Java interface represented by this {@link ElementChild}.\n+\t * For each syntax 1 name a different group is needed because the syntax 2\n+\t * names of the elements are different.\n+\t * <p>\n+\t * A {@link LinkedHashSet} is being used to preserve the sequence with which\n+\t * the syntax 1 names were inserted.\n+\t */\n+\tprivate @Getter LinkedHashSet<String> configChildSyntax1Names = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NDQ5NA=="}, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMDcyMjkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNDozOTo0M1rOIHIgbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDo0MTo0OFrOIIlcKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM1MDMxNg==", "bodyText": "Dit moet dan zijn: findOrCreateElementRole(ElementType, syntax1naam)", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r544350316", "createdAt": "2020-12-16T14:39:43Z", "author": {"login": "gvanbrakel"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -41,11 +92,34 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n \t\t\t} catch(Exception e) {\n \t\t\t\tlog.warn(String.format(\"@IbisDoc for config child with parent [%s] and type [%s] has a non-integer order [%s], ignored\",\n-\t\t\t\t\t\tconfigParent.getSimpleName(),\n+\t\t\t\t\t\tgetOwningElement().getSimpleName(),\n \t\t\t\t\t\telementType.getSimpleName(),\n \t\t\t\t\t\tibisDoc.value()[0]));\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tpublic String getSyntax1NamePlural() {\n+\t\tif(syntax1Name.endsWith(\"s\")) {\n+\t\t\treturn syntax1Name;\n+\t\t} else {\n+\t\t\treturn syntax1Name + \"s\";\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic int compareTo(ElementChild other) {\n+\t\treturn CONFIG_CHILD_COMPARATOR.compare(this, (ConfigChild) other);\n+\t}\n+\n+\tvoid registerSyntax1NameWithElementType(final String syntax1Name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3MjkzNw==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545872937", "createdAt": "2020-12-18T14:41:48Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -41,11 +92,34 @@ private Integer parseIbisDocAnnotation(IbisDoc ibisDoc) {\n \t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n \t\t\t} catch(Exception e) {\n \t\t\t\tlog.warn(String.format(\"@IbisDoc for config child with parent [%s] and type [%s] has a non-integer order [%s], ignored\",\n-\t\t\t\t\t\tconfigParent.getSimpleName(),\n+\t\t\t\t\t\tgetOwningElement().getSimpleName(),\n \t\t\t\t\t\telementType.getSimpleName(),\n \t\t\t\t\t\tibisDoc.value()[0]));\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n+\n+\tpublic String getSyntax1NamePlural() {\n+\t\tif(syntax1Name.endsWith(\"s\")) {\n+\t\t\treturn syntax1Name;\n+\t\t} else {\n+\t\t\treturn syntax1Name + \"s\";\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic int compareTo(ElementChild other) {\n+\t\treturn CONFIG_CHILD_COMPARATOR.compare(this, (ConfigChild) other);\n+\t}\n+\n+\tvoid registerSyntax1NameWithElementType(final String syntax1Name) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM1MDMxNg=="}, "originalCommit": {"oid": "be2dfa9eb7bb7a35167be309dd1f603782c80733"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDA0NTI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwOTo1Mzo0NlrOIIcQRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMjoxMjoyOVrOINvh8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyMjQzNg==", "bodyText": "Mooi gedaan, ook met classbacks en de leesbare lambda's.\nHet valt mij wel op dat alle xsdElementType, xsdElementTypeMemberChildGroup, xsdDeclaredGroupNameForAttributes en xsdCumulativeGroupNameForAttributes methodes door elkaar staan. Voor de leesbaarheid is het handig deze bij elkaar te groeperen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545722436", "createdAt": "2020-12-18T09:53:46Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import static java.util.Arrays.asList;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.OPTIONAL;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.PROHIBITED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.REQUIRED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.DEFAULT;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.FIXED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.DEPRECATED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import nl.nn.adapterframework.core.IListener;\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.ElementRole;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+/**\n+ * This class writes the XML Schema document (XSD) that checks the validity of a\n+ * Frank configuration XML file. The XML Schema is written based on the information\n+ * in a {@link FrankDocModel} object (the model).\n+ * \n+ * <h1>The syntax 2 name</h1>\n+ *\n+ * Below, a few implementation details are explained. First, the integration specialist\n+ * references an element by a name the reveals both the requested Java class\n+ * (expressed as a {@link FrankElement} in the model)\n+ * and the role it plays (e.g. sender or error sender). These requirements are\n+ * implemented by model method {@link FrankElement#getXsdElementName}. This\n+ * method takes as an argument the relevant {@link ElementType} to which the {@link FrankElement}\n+ * of the Java class belongs. The link between this {@link ElementType} and the\n+ * containing &lt;xs:element&gt; is made through a {@link ConfigChild}.\n+ * The <code>syntax1Name</code> attribute of this {@link ConfigChild}\n+ * is the other argument required by {@link FrankElement#getXsdElementName}.\n+ * <p>\n+ * Each element within the Frank!Framework appears as an &lt;complexType&gt;\n+ * under the XSD root. It is not duplicated for the different roles it\n+ * can play. This complex type references a group of config children and a group\n+ * of attributes. A group of config children consists of &lt;xs:choice&gt; elements that\n+ * each list the allowed elements available to the integration specialist, element groups.\n+ * An option within an element group appears as an &lt;xs:element&gt; that has\n+ * the syntax 2 name as name and the XSD type of the referenced {@link FrankElement} as type.\n+ * <p>\n+ * There is a different element group for each combination of an {@link ElementType} and\n+ * config child syntax 1 name, so there can be multiple element groups per {@link ElementType}. This is\n+ * the only duplication we need because of syntax 2 names. A {@link FrankElement} is\n+ * represented in the XSD with a top-level &lt;xs:complexType&gt; item. That item references\n+ * attribute groups and XSD sequences for config children, but these are not duplicated\n+ * because of the syntax 2 name issue.\n+ *\n+ * <h1>Inheritance of attributes and config children</h1>\n+ * \n+ * Each {@link FrankElement} is represented by a top-level &lt;xs:complexType&gt;.\n+ * Each Frank!Framework element can have attributes or other elements. \n+ * These correspond to {@link FrankAttribute}\n+ * objects or {@link ConfigChild} objects in the model.\n+ * <p>\n+ * In the model, a {@link FrankElement} only holds its declared attributes, but\n+ * the top-level &lt;xs:complexType&gt; should allow both the declared attributes and the attributes\n+ * inherited from the ancestors of the {@link FrankElement} (the inherited attributes).\n+ * The same holds for configuration children. This similarity appears in the model\n+ * through the common base class {@link ElementChild}, which is a parent class of both\n+ * {@link FrankAttribute} and {@link ConfigChild}. An attribute defined high in the\n+ * class hierarchy of the Frank!Framework can be allowed for many FF! elements,\n+ * but we do not want to repeat the same &lt;xs:attribute&gt; tags in all these cases.\n+ * We solve this by grouping the attributes, and the config children, in the XSD, for example:\n+ * \n+ * <pre>\n+ * {@code\n+<xs:complexType name=\"ConfigurationType\">\n+  <xs:group ref=\"ConfigurationDeclaredChildGroup\" />\n+  <xs:attributeGroup ref=\"ConfigurationDeclaredAttributeGroup\" />\n+</xs:complexType>\n+}\n+ * </pre>\n+ * <p>\n+ * The example shows a group named <code>ConfigurationDeclaredChildGroup</code>. This group\n+ * declares all allowed child FF! elements.\n+ * <p>\n+ * An XSD group ending with \"DeclaredChildGroup\" only holds the <em>declared</em> configuration children\n+ * or attributes. This is sufficient for Frank config element &lt;Configuration&gt; because the corresponding\n+ * Java class has only <code>Object</code> as parent. We also use cumulative groups\n+ * that allow the declared items (attributes / config children) of a {@link FrankElement}\n+ * as well as the inherited items. The following example in the XSD illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"LockerCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"LockerDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"JdbcFacadeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+}\n+ * </pre>\n+ * The Frank!Framework has a Java class named <code>Locker</code> that has class\n+ * <code>JdbcFacade</code> as its parent. The group <code>LockerCumulativeAttributeGroup</code>\n+ * is defined recursively: all declared attributes of <code>Locker</code> are in, and all\n+ * declared and inherited attributes of the parent class <code>JdbcFacade</code>. The\n+ * recursion stops with the ancestor that holds the last inherited attributes, because\n+ * for that ancestor we do not introduce a cumulative group and use the declared group\n+ * only.\n+ * <p>\n+ * Another issue about groups needs explanation. Some Java classes of the Frank!Framework override\n+ * attributes that become then duplicate in the model. They appear as declared attributes\n+ * in two {@link FrankElement} objects, one modeling the Java subclass and one modeling the\n+ * Java ancestor class. In this situation, only the attribute (or config child) corresponding\n+ * to the Java subclass is needed. The attribute\n+ * of the ancestor class is omitted. The following example illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"SoapValidatorCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"SoapValidatorDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"Json2XmlValidatorDeclaredAttributeGroup\" />\n+  <xs:attribute name=\"ignoreUnknownNamespaces\" type=\"xs:string\" />\n+  ...\n+  <xs:attributeGroup ref=\"FixedForwardPipeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+ }\n+ * </pre>\n+ * Java class <code>SoapValidator</code> overrides a method <code>setRoot()</code> from\n+ * the grand-parent class <code>XmlValidator</code>. If the cumulative group of\n+ * the parent class <code>Json2XmlValidatorCumulativeAttributeGroup</code> would be referenced,\n+ * we would have attribute \"<code>root</code>\" twice. To avoid this, only the declared group\n+ * <code>Json2XmlValidatorDeclaredAttributeGroup</code> is referenced and the non-duplicate\n+ * attributes of <code>XmlValidator</code> are repeated. Higher up the dependency\n+ * hierarchy, there are no duplicate attributes. Therefore, the list of attributes\n+ * can end with referencing group <code>FixedForwardPipeCumulativeAttributeGroup</code>.\n+ * <p>\n+ * Please note that <code>SoapValidator</code> has a deprecated method <code>setSchema()</code>\n+ * that it overrdes from <code>XmlValidator</code>. The algorithm takes care to not only omit\n+ * attribute <code>schema</code> as a declared attribute,\n+ * but also as an inherited attributre of <code>SoapValidator</code>. Other descendants\n+ * of <code>XmlValidator</code> are not influenced by the override by <code>SoapValidator</code>.\n+ * This part of the algorithm is handled by package-private class\n+ * <code>nl.nn.adapterframework.doc.model.ChildRejector</code>.\n+ * <p>\n+ * Finally, 'technical' overrides are ignored by this algorithm, which are\n+ * setters with an override annotation that are not deprecated and lack\n+ * IbisDoc or IbisDocRef annotations.\n+ * \n+ * <h1> The options for a config child</h1>\n+ *\n+ * The {@link ConfigChild} class in the model determines what &lt;xs:element&gt; are allowed\n+ * as children of another &lt;xs:element&gt;. The containing &lt;xs:element&gt; is the\n+ * <code>owningElement</code> field, which is of type {@link FrankElement}. A {@link ConfigChild} is\n+ * characterized by the combination of an owning element and an {@link ElementType}. As an example\n+ * consider the {@link ConfigChild} that exists for the combination of owning element\n+ * \"<code>Receiver</code>\" and element type \"<code>IListener</code>\". It produces\n+ * the following XML schema:\n+ * <pre>\n+ * {@code\n+<xs:group ref=\"IListenerListenerElementGroup\" minOccurs=\"0\" maxOccurs=\"1\" />\n+}\n+ * </pre>\n+ * This snippet appears within <code>&lt;xs:group name=\"ReceiverDeclaredChildGroup\"&gt;&lt;xs:sequence&gt;</code>.\n+ * The snippet states that a Receiver can contain all elements related to a Java class implementing\n+ * {@link IListener}, playing the role of a listener. The duplication because of syntax 2 names becomes\n+ * visible here.\n+ *\n+ * @author martijn\n+ *\n+ */\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\tprivate static final String ELEMENT_GROUP = \"ElementGroup\";\n+\tprivate static final String ELEMENT_ROLE = \"elementRole\";\n+\n+\tprivate FrankDocModel model;\n+\tprivate String startClassName;\n+\tprivate XmlBuilder xsdRoot;\n+\tprivate Set<String> namesCreatedFrankElements;\n+\tprivate Set<ElementRole.Key> idsCreatedElementGroups;\n+\tprivate Set<String> namesElementTypesWithChildMemberGroup;\n+\tprivate XsdWriteFilter writeFilter;\n+\tprivate XsdWriteFilter.ControlStack writeControl;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t}\n+\n+\tpublic void init() {\n+\t\tinit(CONFIGURATION);\n+\t}\n+\n+\tpublic void init(String startClassName) {\n+\t\tthis.startClassName = startClassName;\n+\t}\n+\n+\tpublic String getSchema() {\n+\t\txsdRoot = getXmlSchema();\n+\t\tList<XsdWriteFilter> writeFilters = asList(\n+\t\t\t\tnew XsdWriteFilter.EnableSimpleElements(), new XsdWriteFilter.EnableComplexStuff());\n+\t\tfor(XsdWriteFilter writeFilter: writeFilters) {\n+\t\t\tthis.writeFilter = writeFilter;\n+\t\t\twriteControl = new XsdWriteFilter.ControlStack(writeFilter);\n+\t\t\tnamesCreatedFrankElements = new HashSet<>();\n+\t\t\tidsCreatedElementGroups = new HashSet<>();\n+\t\t\tnamesElementTypesWithChildMemberGroup = new HashSet<>();\n+\t\t\tFrankElement startElement = model.findFrankElement(startClassName);\n+\t\t\trecursivelyDefineXsdElementOfRoot(startElement);\n+\t\t}\n+\t\treturn xsdRoot.toXML(true);\n+\t}\n+\n+\tprivate String xsdElementType(FrankElement frankElement) {\n+\t\treturn frankElement.getSimpleName() + \"Type\";\n+\t}\n+\n+\tprivate void recursivelyDefineXsdElementOfRoot(FrankElement frankElement) {\n+\t\tif(checkNotDefined(frankElement)) {\n+\t\t\twriteControl.pushSimpleElement();\n+\t\t\tString xsdElementName = frankElement.getSimpleName();\n+\t\t\tXmlBuilder attributeBuilder = recursivelyDefineXsdElementUnchecked(\n+\t\t\t\t\txsdRoot, frankElement, xsdElementName);\n+\t\t\taddClassNameAttribute(attributeBuilder, frankElement);\n+\t\t\twriteControl.pop();\n+\t\t}\n+\t}\n+\n+\tprivate void addClassNameAttribute(XmlBuilder context, FrankElement frankElement) {\n+\t\twriteFilter.addAttribute(context, \"className\", FIXED, frankElement.getFullName(), PROHIBITED);\n+\t}\n+\n+\tprivate XmlBuilder recursivelyDefineXsdElementUnchecked(XmlBuilder context, FrankElement frankElement, String xsdElementName) {\n+\t\tXmlBuilder elementBuilder = writeFilter.addElementWithType(context, xsdElementName);\n+\t\tXmlBuilder complexType = writeFilter.addComplexType(elementBuilder);\n+\t\tXmlBuilder sequence = writeFilter.addSequence(complexType);\n+\t\tfrankElement.getCumulativeConfigChildren(IN_XSD, DEPRECATED).forEach(c -> addConfigChild(sequence, c));\n+\t\taddAttributeList(complexType, frankElement.getCumulativeAttributes(IN_XSD, DEPRECATED));\n+\t\treturn complexType;\n+\t}\n+\n+\tprivate void recursivelyDefineXsdElementType(FrankElement frankElement) {\n+\t\tif(checkNotDefined(frankElement)) {\n+\t\t\tElementBuildingStrategy elementBuildingStrategy = getElementBuildingStrategy(frankElement);\n+\t\t\taddConfigChildren(elementBuildingStrategy, frankElement);\n+\t\t\taddAttributes(elementBuildingStrategy, frankElement);\n+\t\t\trecursivelyDefineXsdElementType(frankElement.getNextAncestorThatHasConfigChildren(IN_XSD));\n+\t\t\trecursivelyDefineXsdElementType(frankElement.getNextAncestorThatHasAttributes(IN_XSD));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @param frankElement The {@link FrankElement} for which an XSD element or XSD type is needed, or null\n+\t * @return true if the input is not null and if the element is not yet created.\n+\t */\n+\tprivate boolean checkNotDefined(FrankElement frankElement) {\n+\t\tif(frankElement == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif(namesCreatedFrankElements.contains(frankElement.getFullName())) {\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tnamesCreatedFrankElements.add(frankElement.getFullName());\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * This class is responsible for adding an xs:element in the XML schema if required.\n+\t * If a FrankElement corresponds to an abstract class, then no XML element\n+\t * should be added. This is achieved using the derived class ElementOmitter.\n+\t *\n+\t * For an abstract FrankElement, the config child declared/cumulative groups\n+\t * and the attribute declared/cumulative groups are still needed. Adding them is\n+\t * outside the scope of this class.\n+\t */\n+\tprivate abstract class ElementBuildingStrategy {\n+\t\tabstract void addGroupRef(String referencedGroupName);\n+\t\tabstract void addAttributeGroupRef(String referencedGroupName);\n+\t}\n+\n+\tprivate ElementBuildingStrategy getElementBuildingStrategy(FrankElement element) {\n+\t\tif(element.isAbstract()) {\n+\t\t\treturn new ElementOmitter();\n+\t\t} else {\n+\t\t\treturn new ElementAdder(element);\n+\t\t}\n+\t}\n+\n+\tprivate class ElementAdder extends ElementBuildingStrategy {\n+\t\tprivate final XmlBuilder complexType;\n+\t\t\n+\t\tElementAdder(FrankElement frankElement) {\n+\t\t\tcomplexType = writeFilter.addComplexType(xsdRoot, xsdElementType(frankElement));\n+\t\t}\n+\n+\t\t@Override\n+\t\tvoid addGroupRef(String referencedGroupName) {\n+\t\t\twriteFilter.addGroupRef(complexType, referencedGroupName);\n+\t\t}\n+\n+\t\t@Override\n+\t\tvoid addAttributeGroupRef(String referencedGroupName) {\n+\t\t\twriteFilter.addAttributeGroupRef(complexType, referencedGroupName);\n+\t\t}\n+\t}\n+\n+\tprivate class ElementOmitter extends ElementBuildingStrategy {\n+\t\t@Override\n+\t\tvoid addGroupRef(String referencedGroupName) {\n+\t\t}\n+\t\t@Override\n+\t\tvoid addAttributeGroupRef(String referencedGroupName) {\n+\t\t}\n+\t}\n+\n+\tprivate void addConfigChildren(ElementBuildingStrategy elementBuildingStrategy, FrankElement frankElement) {\n+\t\tConsumer<GroupCreator.Callback<ConfigChild>> cumulativeGroupTrigger =\n+\t\t\t\tca -> frankElement.walkCumulativeConfigChildren(ca, IN_XSD, DEPRECATED);\n+\t\tnew GroupCreator<ConfigChild>(frankElement, cumulativeGroupTrigger, new GroupCreator.Callback<ConfigChild>() {\n+\t\t\tprivate XmlBuilder cumulativeBuilder;\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic List<ConfigChild> getChildrenOf(FrankElement elem) {\n+\t\t\t\treturn elem.getConfigChildren(IN_XSD);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic FrankElement getAncestorOf(FrankElement elem) {\n+\t\t\t\treturn elem.getNextAncestorThatHasConfigChildren(IN_XSD);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addGroupRef(xsdDeclaredGroupNameForChildren(referee));\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addGroupRef(xsdCumulativeGroupNameForChildren(referee));\t\t\t\t\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroup() {\n+\t\t\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, xsdDeclaredGroupNameForChildren(frankElement));\n+\t\t\t\tXmlBuilder sequence = writeFilter.addSequence(group);\n+\t\t\t\tfrankElement.getConfigChildren(IN_XSD).forEach(\n+\t\t\t\t\t\tc -> addConfigChild(sequence, c));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroup() {\n+\t\t\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, xsdCumulativeGroupNameForChildren(frankElement));\n+\t\t\t\tcumulativeBuilder = writeFilter.addSequence(group);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleSelectedChildren(List<ConfigChild> children, FrankElement owner) {\n+\t\t\t\tchildren.forEach(c -> addConfigChild(cumulativeBuilder, c));\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void handleChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addGroupRef(cumulativeBuilder, xsdDeclaredGroupNameForChildren(elem));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleCumulativeChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addGroupRef(cumulativeBuilder, xsdCumulativeGroupNameForChildren(elem));\n+\t\t\t}\n+\t\t}).run();\n+\t}\n+\n+\tprivate static String xsdDeclaredGroupNameForChildren(FrankElement element) {\n+\t\treturn element.getSimpleName() + \"DeclaredChildGroup\";\n+\t}\n+\n+\tprivate static String xsdCumulativeGroupNameForChildren(FrankElement element) {\n+\t\treturn element.getSimpleName() + \"CumulativeChildGroup\";\n+\t}\n+\n+\tprivate void addConfigChild(XmlBuilder context, ConfigChild child) {\n+\t\tElementRole theRole = model.findElementRole(child);\n+\t\tif(isNoElementTypeNeeded(theRole)) {\n+\t\t\taddConfigChildSingleReferredElement(context, child);\n+\t\t} else {\n+\t\t\taddConfigChildWithElementGroup(context, child);\n+\t\t}\n+\t}\n+\n+\tprivate boolean isNoElementTypeNeeded(ElementRole role) {\n+\t\tElementType elementType = role.getElementType();\n+\t\tif(elementType.isFromJavaInterface()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\telse {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\tprivate void addConfigChildSingleReferredElement(XmlBuilder context, ConfigChild child) {\n+\t\tElementRole role = model.findElementRole(child);\n+\t\tFrankElement elementInType = singleElementOf(role.getElementType());\n+\t\twriteFilter.addElementRef(\n+\t\t\t\tcontext,\n+\t\t\t\telementInType.getXsdElementName(role),\n+\t\t\t\tgetMinOccurs(child),\n+\t\t\t\tgetMaxOccurs(child));\n+\t\twriteControl.pushSimpleElement();\n+\t\trecursivelyDefineXsdElement(elementInType, role);\n+\t\twriteControl.pop();\n+\t}\n+\n+\tprivate void addConfigChildWithElementGroup(XmlBuilder context, ConfigChild child) {\n+\t\tElementRole role = model.findElementRole(child);\n+\t\twriteControl.pushComplexStuff();\n+\t\tdefineElementTypeGroup(role);\n+\t\twriteControl.pop();\n+\t\twriteFilter.addGroupRef(context, role.createXsdElementName(ELEMENT_GROUP), getMinOccurs(child), getMaxOccurs(child));\n+\t}\n+\n+\tprivate FrankElement singleElementOf(ElementType elementType) {\n+\t\treturn elementType.getMembers().values().iterator().next();\n+\t}\n+\n+\tprivate static String getMinOccurs(ConfigChild child) {\n+\t\tif(child.isMandatory()) {\n+\t\t\treturn \"1\";\n+\t\t} else {\n+\t\t\treturn \"0\";\n+\t\t}\n+\t}\n+\n+\tprivate static String getMaxOccurs(ConfigChild child) {\n+\t\tif(child.isAllowMultiple()) {\n+\t\t\treturn \"unbounded\";\n+\t\t} else {\n+\t\t\treturn \"1\";\n+\t\t}\n+\t}\n+\n+\tprivate void recursivelyDefineXsdElement(FrankElement frankElement, ElementRole role) {\n+\t\tif(checkNotDefined(frankElement)) {\n+\t\t\tString xsdElementName = frankElement.getXsdElementName(role);\n+\t\t\tXmlBuilder attributeBuilder = recursivelyDefineXsdElementUnchecked(xsdRoot, frankElement, xsdElementName);\n+\t\t\taddExtraAttributesNotFromModel(attributeBuilder, frankElement, role);\n+\t\t}\n+\t}\n+\n+\tprivate void defineElementTypeGroup(ElementRole role) {\n+\t\tElementRole.Key key = role.getKey();\n+\t\tif(! idsCreatedElementGroups.contains(key)) {\n+\t\t\tidsCreatedElementGroups.add(key);\n+\t\t\tdefineElementTypeGroupUnchecked(role);\n+\t\t}\n+\t}\n+\n+\tprivate void defineElementTypeGroupUnchecked(ElementRole role) {\n+\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, role.createXsdElementName(ELEMENT_GROUP));\n+\t\tXmlBuilder choice = writeFilter.addChoice(group);\n+\t\tList<FrankElement> frankElementOptions = role.getElementType().getMembers().values().stream()\n+\t\t\t\t.filter(f -> ! f.isDeprecated())\n+\t\t\t\t.filter(f -> ! f.isAbstract())\n+\t\t\t\t.collect(Collectors.toList());\n+\t\taddGenericElementOption(choice, role, disambiguateGenericOptionElementName(role, frankElementOptions));\n+\t\tfrankElementOptions.sort((o1, o2) -> o1.getSimpleName().compareTo(o2.getSimpleName()));\n+\t\tfor(FrankElement frankElement: frankElementOptions) {\n+\t\t\taddElementToElementGroup(choice, frankElement, role);\n+\t\t}\t\t\n+\t}\n+\n+\t// TODO: Move this to the model.\n+\tprivate String disambiguateGenericOptionElementName(ElementRole role, List<FrankElement> membersToInclude) {\n+\t\t// TODO: This is not nice but it is currently needed to properly disambiguate the\n+\t\t// different sequence numbers for Listener. We have generic elements like\n+\t\t// \"Listener_2\" and \"Listener_3\" for now.\n+\t\tString result = Utils.toUpperCamelCase(role.createXsdElementName(\"\"));\n+\t\tSet<String> conflictCandidates = membersToInclude.stream()\n+\t\t\t\t.map(f -> f.getXsdElementName(role))\n+\t\t\t\t.collect(Collectors.toSet());\n+\t\tif(conflictCandidates.contains(result)) {\n+\t\t\tresult = \"Generic\" + result;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate void addGenericElementOption(XmlBuilder choice, ElementRole role, String elementNameGenericOption) {\n+\t\tXmlBuilder genericElementOption = writeFilter.addElementWithType(\n+\t\t\t\tchoice, elementNameGenericOption);\n+\t\tXmlBuilder complexType = writeFilter.addComplexType(genericElementOption);\n+\t\taddElementTypeChildMembers(complexType, role);\n+\t\twriteFilter.addAttribute(complexType, ELEMENT_ROLE, FIXED, role.getSyntax1Name(), PROHIBITED);\n+\t\twriteFilter.addAttribute(complexType, \"className\", DEFAULT, null, REQUIRED);\n+\t\t// The XSD is invalid if addAnyAttribute is added before attributes elementType and className.\n+\t\twriteFilter.addAnyAttribute(complexType);\n+\t}\n+\n+\tprivate void addElementTypeChildMembers(XmlBuilder context, ElementRole role) {\n+\t\twriteFilter.addGroupRef(context, xsdElementTypeMemberChildGroup(role.getElementType()), \"0\", \"unbounded\");\n+\t\taddElementTypeMemberChildGroup(role);\n+\t}\n+\n+\tprivate String xsdElementTypeMemberChildGroup(ElementType elementType) {\n+\t\treturn elementType.getSimpleName() + \"MemberChildGroup\";\n+\t}\n+\n+\tprivate void addElementTypeMemberChildGroup(ElementRole role) {\n+\t\tif(! namesElementTypesWithChildMemberGroup.contains(role.getElementType().getFullName())) {\n+\t\t\tnamesElementTypesWithChildMemberGroup.add(role.getElementType().getFullName());\n+\t\t\taddElementTypeMemberChildGroupUnchecked(role);\n+\t\t}\n+\t}\n+\n+\tprivate void addElementTypeMemberChildGroupUnchecked(ElementRole role) {\n+\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, xsdElementTypeMemberChildGroup(role.getElementType()));\n+\t\tXmlBuilder choice = writeFilter.addChoice(group);\n+\t\tList<ElementRole> childRoles = model.getElementTypeMemberChildRoles(\n+\t\t\t\trole.getElementType(), IN_XSD, DEPRECATED, f -> ! f.isDeprecated());\n+\t\tchildRoles = childRoles.stream()\n+\t\t\t\t.map(ElementRole::getFounder)\n+\t\t\t\t.distinct()\n+\t\t\t\t.collect(Collectors.toList());\n+\t\tfor(ElementRole childRole: childRoles) {\n+\t\t\taddElementTypeMemberChildGroupOption(choice, childRole);\n+\t\t}\n+\t}\n+\n+\tprivate void addElementTypeMemberChildGroupOption(XmlBuilder choice, ElementRole childRole) {\n+\t\tif(isNoElementTypeNeeded(childRole)) {\n+\t\t\tFrankElement frankElement = singleElementOf(childRole.getElementType());\n+\t\t\tString xsdElementName = frankElement.getXsdElementName(childRole);\n+\t\t\twriteFilter.addElementRef(choice, xsdElementName);\n+\t\t} else {\n+\t\t\twriteFilter.addGroupRef(choice, childRole.createXsdElementName(ELEMENT_GROUP));\n+\t\t}\n+\t}\n+\n+\tprivate void addElementToElementGroup(XmlBuilder context, FrankElement frankElement, ElementRole role) {\n+\t\taddElementTypeRefToElementGroup(context, frankElement, role);\n+\t\trecursivelyDefineXsdElementType(frankElement);\n+\t}\n+\n+\tprivate void addElementTypeRefToElementGroup(XmlBuilder context, FrankElement frankElement, ElementRole role) {\n+\t\tXmlBuilder element = writeFilter.addElementWithType(context, frankElement.getXsdElementName(role));\n+\t\tXmlBuilder complexType = writeFilter.addComplexType(element);\n+\t\tXmlBuilder complexContent = writeFilter.addComplexContent(complexType);\n+\t\tXmlBuilder extension = writeFilter.addExtension(complexContent, xsdElementType(frankElement));\n+\t\taddExtraAttributesNotFromModel(extension, frankElement, role);\n+\t}\n+\n+\tprivate void addExtraAttributesNotFromModel(XmlBuilder context, FrankElement frankElement, ElementRole role) {\n+\t\twriteFilter.addAttribute(context, ELEMENT_ROLE, FIXED, role.getSyntax1Name(), PROHIBITED);\n+\t\taddClassNameAttribute(context, frankElement);\n+\t}\n+\n+\tprivate void addAttributes(ElementBuildingStrategy elementBuildingStrategy, FrankElement frankElement) {\n+\t\tConsumer<GroupCreator.Callback<FrankAttribute>> cumulativeGroupTrigger =\n+\t\t\t\tca -> frankElement.walkCumulativeAttributes(ca, IN_XSD, DEPRECATED);\n+\t\tnew GroupCreator<FrankAttribute>(frankElement, cumulativeGroupTrigger, new GroupCreator.Callback<FrankAttribute>() {\n+\t\t\tprivate XmlBuilder cumulativeBuilder;\n+\n+\t\t\t@Override\n+\t\t\tpublic List<FrankAttribute> getChildrenOf(FrankElement elem) {\n+\t\t\t\treturn elem.getAttributes(IN_XSD);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic FrankElement getAncestorOf(FrankElement elem) {\n+\t\t\t\treturn elem.getNextAncestorThatHasAttributes(IN_XSD);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addAttributeGroupRef(xsdDeclaredGroupNameForAttributes(referee));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addAttributeGroupRef(xsdCumulativeGroupNameForAttributes(referee));\t\t\t\t\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroup() {\n+\t\t\t\tXmlBuilder attributeGroup = writeFilter.addAttributeGroup(xsdRoot, xsdDeclaredGroupNameForAttributes(frankElement));\n+\t\t\t\taddAttributeList(attributeGroup, frankElement.getAttributes(IN_XSD));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroup() {\n+\t\t\t\tcumulativeBuilder = writeFilter.addAttributeGroup(xsdRoot, xsdCumulativeGroupNameForAttributes(frankElement));\t\t\t\t\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleSelectedChildren(List<FrankAttribute> children, FrankElement owner) {\n+\t\t\t\taddAttributeList(cumulativeBuilder, children);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addAttributeGroupRef(cumulativeBuilder, xsdDeclaredGroupNameForAttributes(elem));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleCumulativeChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addAttributeGroupRef(cumulativeBuilder, xsdCumulativeGroupNameForAttributes(elem));\t\t\t\t\n+\t\t\t}\n+\t\t}).run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 625}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI4MTEzOA==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551281138", "createdAt": "2021-01-04T12:12:29Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import static java.util.Arrays.asList;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.OPTIONAL;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.PROHIBITED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.REQUIRED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.DEFAULT;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.FIXED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.DEPRECATED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import nl.nn.adapterframework.core.IListener;\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.ElementRole;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+/**\n+ * This class writes the XML Schema document (XSD) that checks the validity of a\n+ * Frank configuration XML file. The XML Schema is written based on the information\n+ * in a {@link FrankDocModel} object (the model).\n+ * \n+ * <h1>The syntax 2 name</h1>\n+ *\n+ * Below, a few implementation details are explained. First, the integration specialist\n+ * references an element by a name the reveals both the requested Java class\n+ * (expressed as a {@link FrankElement} in the model)\n+ * and the role it plays (e.g. sender or error sender). These requirements are\n+ * implemented by model method {@link FrankElement#getXsdElementName}. This\n+ * method takes as an argument the relevant {@link ElementType} to which the {@link FrankElement}\n+ * of the Java class belongs. The link between this {@link ElementType} and the\n+ * containing &lt;xs:element&gt; is made through a {@link ConfigChild}.\n+ * The <code>syntax1Name</code> attribute of this {@link ConfigChild}\n+ * is the other argument required by {@link FrankElement#getXsdElementName}.\n+ * <p>\n+ * Each element within the Frank!Framework appears as an &lt;complexType&gt;\n+ * under the XSD root. It is not duplicated for the different roles it\n+ * can play. This complex type references a group of config children and a group\n+ * of attributes. A group of config children consists of &lt;xs:choice&gt; elements that\n+ * each list the allowed elements available to the integration specialist, element groups.\n+ * An option within an element group appears as an &lt;xs:element&gt; that has\n+ * the syntax 2 name as name and the XSD type of the referenced {@link FrankElement} as type.\n+ * <p>\n+ * There is a different element group for each combination of an {@link ElementType} and\n+ * config child syntax 1 name, so there can be multiple element groups per {@link ElementType}. This is\n+ * the only duplication we need because of syntax 2 names. A {@link FrankElement} is\n+ * represented in the XSD with a top-level &lt;xs:complexType&gt; item. That item references\n+ * attribute groups and XSD sequences for config children, but these are not duplicated\n+ * because of the syntax 2 name issue.\n+ *\n+ * <h1>Inheritance of attributes and config children</h1>\n+ * \n+ * Each {@link FrankElement} is represented by a top-level &lt;xs:complexType&gt;.\n+ * Each Frank!Framework element can have attributes or other elements. \n+ * These correspond to {@link FrankAttribute}\n+ * objects or {@link ConfigChild} objects in the model.\n+ * <p>\n+ * In the model, a {@link FrankElement} only holds its declared attributes, but\n+ * the top-level &lt;xs:complexType&gt; should allow both the declared attributes and the attributes\n+ * inherited from the ancestors of the {@link FrankElement} (the inherited attributes).\n+ * The same holds for configuration children. This similarity appears in the model\n+ * through the common base class {@link ElementChild}, which is a parent class of both\n+ * {@link FrankAttribute} and {@link ConfigChild}. An attribute defined high in the\n+ * class hierarchy of the Frank!Framework can be allowed for many FF! elements,\n+ * but we do not want to repeat the same &lt;xs:attribute&gt; tags in all these cases.\n+ * We solve this by grouping the attributes, and the config children, in the XSD, for example:\n+ * \n+ * <pre>\n+ * {@code\n+<xs:complexType name=\"ConfigurationType\">\n+  <xs:group ref=\"ConfigurationDeclaredChildGroup\" />\n+  <xs:attributeGroup ref=\"ConfigurationDeclaredAttributeGroup\" />\n+</xs:complexType>\n+}\n+ * </pre>\n+ * <p>\n+ * The example shows a group named <code>ConfigurationDeclaredChildGroup</code>. This group\n+ * declares all allowed child FF! elements.\n+ * <p>\n+ * An XSD group ending with \"DeclaredChildGroup\" only holds the <em>declared</em> configuration children\n+ * or attributes. This is sufficient for Frank config element &lt;Configuration&gt; because the corresponding\n+ * Java class has only <code>Object</code> as parent. We also use cumulative groups\n+ * that allow the declared items (attributes / config children) of a {@link FrankElement}\n+ * as well as the inherited items. The following example in the XSD illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"LockerCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"LockerDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"JdbcFacadeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+}\n+ * </pre>\n+ * The Frank!Framework has a Java class named <code>Locker</code> that has class\n+ * <code>JdbcFacade</code> as its parent. The group <code>LockerCumulativeAttributeGroup</code>\n+ * is defined recursively: all declared attributes of <code>Locker</code> are in, and all\n+ * declared and inherited attributes of the parent class <code>JdbcFacade</code>. The\n+ * recursion stops with the ancestor that holds the last inherited attributes, because\n+ * for that ancestor we do not introduce a cumulative group and use the declared group\n+ * only.\n+ * <p>\n+ * Another issue about groups needs explanation. Some Java classes of the Frank!Framework override\n+ * attributes that become then duplicate in the model. They appear as declared attributes\n+ * in two {@link FrankElement} objects, one modeling the Java subclass and one modeling the\n+ * Java ancestor class. In this situation, only the attribute (or config child) corresponding\n+ * to the Java subclass is needed. The attribute\n+ * of the ancestor class is omitted. The following example illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"SoapValidatorCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"SoapValidatorDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"Json2XmlValidatorDeclaredAttributeGroup\" />\n+  <xs:attribute name=\"ignoreUnknownNamespaces\" type=\"xs:string\" />\n+  ...\n+  <xs:attributeGroup ref=\"FixedForwardPipeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+ }\n+ * </pre>\n+ * Java class <code>SoapValidator</code> overrides a method <code>setRoot()</code> from\n+ * the grand-parent class <code>XmlValidator</code>. If the cumulative group of\n+ * the parent class <code>Json2XmlValidatorCumulativeAttributeGroup</code> would be referenced,\n+ * we would have attribute \"<code>root</code>\" twice. To avoid this, only the declared group\n+ * <code>Json2XmlValidatorDeclaredAttributeGroup</code> is referenced and the non-duplicate\n+ * attributes of <code>XmlValidator</code> are repeated. Higher up the dependency\n+ * hierarchy, there are no duplicate attributes. Therefore, the list of attributes\n+ * can end with referencing group <code>FixedForwardPipeCumulativeAttributeGroup</code>.\n+ * <p>\n+ * Please note that <code>SoapValidator</code> has a deprecated method <code>setSchema()</code>\n+ * that it overrdes from <code>XmlValidator</code>. The algorithm takes care to not only omit\n+ * attribute <code>schema</code> as a declared attribute,\n+ * but also as an inherited attributre of <code>SoapValidator</code>. Other descendants\n+ * of <code>XmlValidator</code> are not influenced by the override by <code>SoapValidator</code>.\n+ * This part of the algorithm is handled by package-private class\n+ * <code>nl.nn.adapterframework.doc.model.ChildRejector</code>.\n+ * <p>\n+ * Finally, 'technical' overrides are ignored by this algorithm, which are\n+ * setters with an override annotation that are not deprecated and lack\n+ * IbisDoc or IbisDocRef annotations.\n+ * \n+ * <h1> The options for a config child</h1>\n+ *\n+ * The {@link ConfigChild} class in the model determines what &lt;xs:element&gt; are allowed\n+ * as children of another &lt;xs:element&gt;. The containing &lt;xs:element&gt; is the\n+ * <code>owningElement</code> field, which is of type {@link FrankElement}. A {@link ConfigChild} is\n+ * characterized by the combination of an owning element and an {@link ElementType}. As an example\n+ * consider the {@link ConfigChild} that exists for the combination of owning element\n+ * \"<code>Receiver</code>\" and element type \"<code>IListener</code>\". It produces\n+ * the following XML schema:\n+ * <pre>\n+ * {@code\n+<xs:group ref=\"IListenerListenerElementGroup\" minOccurs=\"0\" maxOccurs=\"1\" />\n+}\n+ * </pre>\n+ * This snippet appears within <code>&lt;xs:group name=\"ReceiverDeclaredChildGroup\"&gt;&lt;xs:sequence&gt;</code>.\n+ * The snippet states that a Receiver can contain all elements related to a Java class implementing\n+ * {@link IListener}, playing the role of a listener. The duplication because of syntax 2 names becomes\n+ * visible here.\n+ *\n+ * @author martijn\n+ *\n+ */\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\tprivate static final String ELEMENT_GROUP = \"ElementGroup\";\n+\tprivate static final String ELEMENT_ROLE = \"elementRole\";\n+\n+\tprivate FrankDocModel model;\n+\tprivate String startClassName;\n+\tprivate XmlBuilder xsdRoot;\n+\tprivate Set<String> namesCreatedFrankElements;\n+\tprivate Set<ElementRole.Key> idsCreatedElementGroups;\n+\tprivate Set<String> namesElementTypesWithChildMemberGroup;\n+\tprivate XsdWriteFilter writeFilter;\n+\tprivate XsdWriteFilter.ControlStack writeControl;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t}\n+\n+\tpublic void init() {\n+\t\tinit(CONFIGURATION);\n+\t}\n+\n+\tpublic void init(String startClassName) {\n+\t\tthis.startClassName = startClassName;\n+\t}\n+\n+\tpublic String getSchema() {\n+\t\txsdRoot = getXmlSchema();\n+\t\tList<XsdWriteFilter> writeFilters = asList(\n+\t\t\t\tnew XsdWriteFilter.EnableSimpleElements(), new XsdWriteFilter.EnableComplexStuff());\n+\t\tfor(XsdWriteFilter writeFilter: writeFilters) {\n+\t\t\tthis.writeFilter = writeFilter;\n+\t\t\twriteControl = new XsdWriteFilter.ControlStack(writeFilter);\n+\t\t\tnamesCreatedFrankElements = new HashSet<>();\n+\t\t\tidsCreatedElementGroups = new HashSet<>();\n+\t\t\tnamesElementTypesWithChildMemberGroup = new HashSet<>();\n+\t\t\tFrankElement startElement = model.findFrankElement(startClassName);\n+\t\t\trecursivelyDefineXsdElementOfRoot(startElement);\n+\t\t}\n+\t\treturn xsdRoot.toXML(true);\n+\t}\n+\n+\tprivate String xsdElementType(FrankElement frankElement) {\n+\t\treturn frankElement.getSimpleName() + \"Type\";\n+\t}\n+\n+\tprivate void recursivelyDefineXsdElementOfRoot(FrankElement frankElement) {\n+\t\tif(checkNotDefined(frankElement)) {\n+\t\t\twriteControl.pushSimpleElement();\n+\t\t\tString xsdElementName = frankElement.getSimpleName();\n+\t\t\tXmlBuilder attributeBuilder = recursivelyDefineXsdElementUnchecked(\n+\t\t\t\t\txsdRoot, frankElement, xsdElementName);\n+\t\t\taddClassNameAttribute(attributeBuilder, frankElement);\n+\t\t\twriteControl.pop();\n+\t\t}\n+\t}\n+\n+\tprivate void addClassNameAttribute(XmlBuilder context, FrankElement frankElement) {\n+\t\twriteFilter.addAttribute(context, \"className\", FIXED, frankElement.getFullName(), PROHIBITED);\n+\t}\n+\n+\tprivate XmlBuilder recursivelyDefineXsdElementUnchecked(XmlBuilder context, FrankElement frankElement, String xsdElementName) {\n+\t\tXmlBuilder elementBuilder = writeFilter.addElementWithType(context, xsdElementName);\n+\t\tXmlBuilder complexType = writeFilter.addComplexType(elementBuilder);\n+\t\tXmlBuilder sequence = writeFilter.addSequence(complexType);\n+\t\tfrankElement.getCumulativeConfigChildren(IN_XSD, DEPRECATED).forEach(c -> addConfigChild(sequence, c));\n+\t\taddAttributeList(complexType, frankElement.getCumulativeAttributes(IN_XSD, DEPRECATED));\n+\t\treturn complexType;\n+\t}\n+\n+\tprivate void recursivelyDefineXsdElementType(FrankElement frankElement) {\n+\t\tif(checkNotDefined(frankElement)) {\n+\t\t\tElementBuildingStrategy elementBuildingStrategy = getElementBuildingStrategy(frankElement);\n+\t\t\taddConfigChildren(elementBuildingStrategy, frankElement);\n+\t\t\taddAttributes(elementBuildingStrategy, frankElement);\n+\t\t\trecursivelyDefineXsdElementType(frankElement.getNextAncestorThatHasConfigChildren(IN_XSD));\n+\t\t\trecursivelyDefineXsdElementType(frankElement.getNextAncestorThatHasAttributes(IN_XSD));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @param frankElement The {@link FrankElement} for which an XSD element or XSD type is needed, or null\n+\t * @return true if the input is not null and if the element is not yet created.\n+\t */\n+\tprivate boolean checkNotDefined(FrankElement frankElement) {\n+\t\tif(frankElement == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif(namesCreatedFrankElements.contains(frankElement.getFullName())) {\n+\t\t\treturn false;\n+\t\t} else {\n+\t\t\tnamesCreatedFrankElements.add(frankElement.getFullName());\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * This class is responsible for adding an xs:element in the XML schema if required.\n+\t * If a FrankElement corresponds to an abstract class, then no XML element\n+\t * should be added. This is achieved using the derived class ElementOmitter.\n+\t *\n+\t * For an abstract FrankElement, the config child declared/cumulative groups\n+\t * and the attribute declared/cumulative groups are still needed. Adding them is\n+\t * outside the scope of this class.\n+\t */\n+\tprivate abstract class ElementBuildingStrategy {\n+\t\tabstract void addGroupRef(String referencedGroupName);\n+\t\tabstract void addAttributeGroupRef(String referencedGroupName);\n+\t}\n+\n+\tprivate ElementBuildingStrategy getElementBuildingStrategy(FrankElement element) {\n+\t\tif(element.isAbstract()) {\n+\t\t\treturn new ElementOmitter();\n+\t\t} else {\n+\t\t\treturn new ElementAdder(element);\n+\t\t}\n+\t}\n+\n+\tprivate class ElementAdder extends ElementBuildingStrategy {\n+\t\tprivate final XmlBuilder complexType;\n+\t\t\n+\t\tElementAdder(FrankElement frankElement) {\n+\t\t\tcomplexType = writeFilter.addComplexType(xsdRoot, xsdElementType(frankElement));\n+\t\t}\n+\n+\t\t@Override\n+\t\tvoid addGroupRef(String referencedGroupName) {\n+\t\t\twriteFilter.addGroupRef(complexType, referencedGroupName);\n+\t\t}\n+\n+\t\t@Override\n+\t\tvoid addAttributeGroupRef(String referencedGroupName) {\n+\t\t\twriteFilter.addAttributeGroupRef(complexType, referencedGroupName);\n+\t\t}\n+\t}\n+\n+\tprivate class ElementOmitter extends ElementBuildingStrategy {\n+\t\t@Override\n+\t\tvoid addGroupRef(String referencedGroupName) {\n+\t\t}\n+\t\t@Override\n+\t\tvoid addAttributeGroupRef(String referencedGroupName) {\n+\t\t}\n+\t}\n+\n+\tprivate void addConfigChildren(ElementBuildingStrategy elementBuildingStrategy, FrankElement frankElement) {\n+\t\tConsumer<GroupCreator.Callback<ConfigChild>> cumulativeGroupTrigger =\n+\t\t\t\tca -> frankElement.walkCumulativeConfigChildren(ca, IN_XSD, DEPRECATED);\n+\t\tnew GroupCreator<ConfigChild>(frankElement, cumulativeGroupTrigger, new GroupCreator.Callback<ConfigChild>() {\n+\t\t\tprivate XmlBuilder cumulativeBuilder;\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic List<ConfigChild> getChildrenOf(FrankElement elem) {\n+\t\t\t\treturn elem.getConfigChildren(IN_XSD);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic FrankElement getAncestorOf(FrankElement elem) {\n+\t\t\t\treturn elem.getNextAncestorThatHasConfigChildren(IN_XSD);\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addGroupRef(xsdDeclaredGroupNameForChildren(referee));\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addGroupRef(xsdCumulativeGroupNameForChildren(referee));\t\t\t\t\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroup() {\n+\t\t\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, xsdDeclaredGroupNameForChildren(frankElement));\n+\t\t\t\tXmlBuilder sequence = writeFilter.addSequence(group);\n+\t\t\t\tfrankElement.getConfigChildren(IN_XSD).forEach(\n+\t\t\t\t\t\tc -> addConfigChild(sequence, c));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroup() {\n+\t\t\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, xsdCumulativeGroupNameForChildren(frankElement));\n+\t\t\t\tcumulativeBuilder = writeFilter.addSequence(group);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleSelectedChildren(List<ConfigChild> children, FrankElement owner) {\n+\t\t\t\tchildren.forEach(c -> addConfigChild(cumulativeBuilder, c));\n+\t\t\t}\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void handleChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addGroupRef(cumulativeBuilder, xsdDeclaredGroupNameForChildren(elem));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleCumulativeChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addGroupRef(cumulativeBuilder, xsdCumulativeGroupNameForChildren(elem));\n+\t\t\t}\n+\t\t}).run();\n+\t}\n+\n+\tprivate static String xsdDeclaredGroupNameForChildren(FrankElement element) {\n+\t\treturn element.getSimpleName() + \"DeclaredChildGroup\";\n+\t}\n+\n+\tprivate static String xsdCumulativeGroupNameForChildren(FrankElement element) {\n+\t\treturn element.getSimpleName() + \"CumulativeChildGroup\";\n+\t}\n+\n+\tprivate void addConfigChild(XmlBuilder context, ConfigChild child) {\n+\t\tElementRole theRole = model.findElementRole(child);\n+\t\tif(isNoElementTypeNeeded(theRole)) {\n+\t\t\taddConfigChildSingleReferredElement(context, child);\n+\t\t} else {\n+\t\t\taddConfigChildWithElementGroup(context, child);\n+\t\t}\n+\t}\n+\n+\tprivate boolean isNoElementTypeNeeded(ElementRole role) {\n+\t\tElementType elementType = role.getElementType();\n+\t\tif(elementType.isFromJavaInterface()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\telse {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\tprivate void addConfigChildSingleReferredElement(XmlBuilder context, ConfigChild child) {\n+\t\tElementRole role = model.findElementRole(child);\n+\t\tFrankElement elementInType = singleElementOf(role.getElementType());\n+\t\twriteFilter.addElementRef(\n+\t\t\t\tcontext,\n+\t\t\t\telementInType.getXsdElementName(role),\n+\t\t\t\tgetMinOccurs(child),\n+\t\t\t\tgetMaxOccurs(child));\n+\t\twriteControl.pushSimpleElement();\n+\t\trecursivelyDefineXsdElement(elementInType, role);\n+\t\twriteControl.pop();\n+\t}\n+\n+\tprivate void addConfigChildWithElementGroup(XmlBuilder context, ConfigChild child) {\n+\t\tElementRole role = model.findElementRole(child);\n+\t\twriteControl.pushComplexStuff();\n+\t\tdefineElementTypeGroup(role);\n+\t\twriteControl.pop();\n+\t\twriteFilter.addGroupRef(context, role.createXsdElementName(ELEMENT_GROUP), getMinOccurs(child), getMaxOccurs(child));\n+\t}\n+\n+\tprivate FrankElement singleElementOf(ElementType elementType) {\n+\t\treturn elementType.getMembers().values().iterator().next();\n+\t}\n+\n+\tprivate static String getMinOccurs(ConfigChild child) {\n+\t\tif(child.isMandatory()) {\n+\t\t\treturn \"1\";\n+\t\t} else {\n+\t\t\treturn \"0\";\n+\t\t}\n+\t}\n+\n+\tprivate static String getMaxOccurs(ConfigChild child) {\n+\t\tif(child.isAllowMultiple()) {\n+\t\t\treturn \"unbounded\";\n+\t\t} else {\n+\t\t\treturn \"1\";\n+\t\t}\n+\t}\n+\n+\tprivate void recursivelyDefineXsdElement(FrankElement frankElement, ElementRole role) {\n+\t\tif(checkNotDefined(frankElement)) {\n+\t\t\tString xsdElementName = frankElement.getXsdElementName(role);\n+\t\t\tXmlBuilder attributeBuilder = recursivelyDefineXsdElementUnchecked(xsdRoot, frankElement, xsdElementName);\n+\t\t\taddExtraAttributesNotFromModel(attributeBuilder, frankElement, role);\n+\t\t}\n+\t}\n+\n+\tprivate void defineElementTypeGroup(ElementRole role) {\n+\t\tElementRole.Key key = role.getKey();\n+\t\tif(! idsCreatedElementGroups.contains(key)) {\n+\t\t\tidsCreatedElementGroups.add(key);\n+\t\t\tdefineElementTypeGroupUnchecked(role);\n+\t\t}\n+\t}\n+\n+\tprivate void defineElementTypeGroupUnchecked(ElementRole role) {\n+\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, role.createXsdElementName(ELEMENT_GROUP));\n+\t\tXmlBuilder choice = writeFilter.addChoice(group);\n+\t\tList<FrankElement> frankElementOptions = role.getElementType().getMembers().values().stream()\n+\t\t\t\t.filter(f -> ! f.isDeprecated())\n+\t\t\t\t.filter(f -> ! f.isAbstract())\n+\t\t\t\t.collect(Collectors.toList());\n+\t\taddGenericElementOption(choice, role, disambiguateGenericOptionElementName(role, frankElementOptions));\n+\t\tfrankElementOptions.sort((o1, o2) -> o1.getSimpleName().compareTo(o2.getSimpleName()));\n+\t\tfor(FrankElement frankElement: frankElementOptions) {\n+\t\t\taddElementToElementGroup(choice, frankElement, role);\n+\t\t}\t\t\n+\t}\n+\n+\t// TODO: Move this to the model.\n+\tprivate String disambiguateGenericOptionElementName(ElementRole role, List<FrankElement> membersToInclude) {\n+\t\t// TODO: This is not nice but it is currently needed to properly disambiguate the\n+\t\t// different sequence numbers for Listener. We have generic elements like\n+\t\t// \"Listener_2\" and \"Listener_3\" for now.\n+\t\tString result = Utils.toUpperCamelCase(role.createXsdElementName(\"\"));\n+\t\tSet<String> conflictCandidates = membersToInclude.stream()\n+\t\t\t\t.map(f -> f.getXsdElementName(role))\n+\t\t\t\t.collect(Collectors.toSet());\n+\t\tif(conflictCandidates.contains(result)) {\n+\t\t\tresult = \"Generic\" + result;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate void addGenericElementOption(XmlBuilder choice, ElementRole role, String elementNameGenericOption) {\n+\t\tXmlBuilder genericElementOption = writeFilter.addElementWithType(\n+\t\t\t\tchoice, elementNameGenericOption);\n+\t\tXmlBuilder complexType = writeFilter.addComplexType(genericElementOption);\n+\t\taddElementTypeChildMembers(complexType, role);\n+\t\twriteFilter.addAttribute(complexType, ELEMENT_ROLE, FIXED, role.getSyntax1Name(), PROHIBITED);\n+\t\twriteFilter.addAttribute(complexType, \"className\", DEFAULT, null, REQUIRED);\n+\t\t// The XSD is invalid if addAnyAttribute is added before attributes elementType and className.\n+\t\twriteFilter.addAnyAttribute(complexType);\n+\t}\n+\n+\tprivate void addElementTypeChildMembers(XmlBuilder context, ElementRole role) {\n+\t\twriteFilter.addGroupRef(context, xsdElementTypeMemberChildGroup(role.getElementType()), \"0\", \"unbounded\");\n+\t\taddElementTypeMemberChildGroup(role);\n+\t}\n+\n+\tprivate String xsdElementTypeMemberChildGroup(ElementType elementType) {\n+\t\treturn elementType.getSimpleName() + \"MemberChildGroup\";\n+\t}\n+\n+\tprivate void addElementTypeMemberChildGroup(ElementRole role) {\n+\t\tif(! namesElementTypesWithChildMemberGroup.contains(role.getElementType().getFullName())) {\n+\t\t\tnamesElementTypesWithChildMemberGroup.add(role.getElementType().getFullName());\n+\t\t\taddElementTypeMemberChildGroupUnchecked(role);\n+\t\t}\n+\t}\n+\n+\tprivate void addElementTypeMemberChildGroupUnchecked(ElementRole role) {\n+\t\tXmlBuilder group = writeFilter.addGroup(xsdRoot, xsdElementTypeMemberChildGroup(role.getElementType()));\n+\t\tXmlBuilder choice = writeFilter.addChoice(group);\n+\t\tList<ElementRole> childRoles = model.getElementTypeMemberChildRoles(\n+\t\t\t\trole.getElementType(), IN_XSD, DEPRECATED, f -> ! f.isDeprecated());\n+\t\tchildRoles = childRoles.stream()\n+\t\t\t\t.map(ElementRole::getFounder)\n+\t\t\t\t.distinct()\n+\t\t\t\t.collect(Collectors.toList());\n+\t\tfor(ElementRole childRole: childRoles) {\n+\t\t\taddElementTypeMemberChildGroupOption(choice, childRole);\n+\t\t}\n+\t}\n+\n+\tprivate void addElementTypeMemberChildGroupOption(XmlBuilder choice, ElementRole childRole) {\n+\t\tif(isNoElementTypeNeeded(childRole)) {\n+\t\t\tFrankElement frankElement = singleElementOf(childRole.getElementType());\n+\t\t\tString xsdElementName = frankElement.getXsdElementName(childRole);\n+\t\t\twriteFilter.addElementRef(choice, xsdElementName);\n+\t\t} else {\n+\t\t\twriteFilter.addGroupRef(choice, childRole.createXsdElementName(ELEMENT_GROUP));\n+\t\t}\n+\t}\n+\n+\tprivate void addElementToElementGroup(XmlBuilder context, FrankElement frankElement, ElementRole role) {\n+\t\taddElementTypeRefToElementGroup(context, frankElement, role);\n+\t\trecursivelyDefineXsdElementType(frankElement);\n+\t}\n+\n+\tprivate void addElementTypeRefToElementGroup(XmlBuilder context, FrankElement frankElement, ElementRole role) {\n+\t\tXmlBuilder element = writeFilter.addElementWithType(context, frankElement.getXsdElementName(role));\n+\t\tXmlBuilder complexType = writeFilter.addComplexType(element);\n+\t\tXmlBuilder complexContent = writeFilter.addComplexContent(complexType);\n+\t\tXmlBuilder extension = writeFilter.addExtension(complexContent, xsdElementType(frankElement));\n+\t\taddExtraAttributesNotFromModel(extension, frankElement, role);\n+\t}\n+\n+\tprivate void addExtraAttributesNotFromModel(XmlBuilder context, FrankElement frankElement, ElementRole role) {\n+\t\twriteFilter.addAttribute(context, ELEMENT_ROLE, FIXED, role.getSyntax1Name(), PROHIBITED);\n+\t\taddClassNameAttribute(context, frankElement);\n+\t}\n+\n+\tprivate void addAttributes(ElementBuildingStrategy elementBuildingStrategy, FrankElement frankElement) {\n+\t\tConsumer<GroupCreator.Callback<FrankAttribute>> cumulativeGroupTrigger =\n+\t\t\t\tca -> frankElement.walkCumulativeAttributes(ca, IN_XSD, DEPRECATED);\n+\t\tnew GroupCreator<FrankAttribute>(frankElement, cumulativeGroupTrigger, new GroupCreator.Callback<FrankAttribute>() {\n+\t\t\tprivate XmlBuilder cumulativeBuilder;\n+\n+\t\t\t@Override\n+\t\t\tpublic List<FrankAttribute> getChildrenOf(FrankElement elem) {\n+\t\t\t\treturn elem.getAttributes(IN_XSD);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic FrankElement getAncestorOf(FrankElement elem) {\n+\t\t\t\treturn elem.getNextAncestorThatHasAttributes(IN_XSD);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addAttributeGroupRef(xsdDeclaredGroupNameForAttributes(referee));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroupRef(FrankElement referee) {\n+\t\t\t\telementBuildingStrategy.addAttributeGroupRef(xsdCumulativeGroupNameForAttributes(referee));\t\t\t\t\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addDeclaredGroup() {\n+\t\t\t\tXmlBuilder attributeGroup = writeFilter.addAttributeGroup(xsdRoot, xsdDeclaredGroupNameForAttributes(frankElement));\n+\t\t\t\taddAttributeList(attributeGroup, frankElement.getAttributes(IN_XSD));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void addCumulativeGroup() {\n+\t\t\t\tcumulativeBuilder = writeFilter.addAttributeGroup(xsdRoot, xsdCumulativeGroupNameForAttributes(frankElement));\t\t\t\t\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleSelectedChildren(List<FrankAttribute> children, FrankElement owner) {\n+\t\t\t\taddAttributeList(cumulativeBuilder, children);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addAttributeGroupRef(cumulativeBuilder, xsdDeclaredGroupNameForAttributes(elem));\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void handleCumulativeChildrenOf(FrankElement elem) {\n+\t\t\t\twriteFilter.addAttributeGroupRef(cumulativeBuilder, xsdCumulativeGroupNameForAttributes(elem));\t\t\t\t\n+\t\t\t}\n+\t\t}).run();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyMjQzNg=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 625}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDA3MzA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDowMToxNFrOIIcgkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDoyMzo0NVrOIRPOsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNjYxMA==", "bodyText": "informative: Ik ben zelf geen grote fan van het importeren van static helper methodes. Dit heeft vooral te maken met de grote hoeveelheid dependencies in het project en de grote overlap aan duplicate methode namen in verschillende packages. Je kan zo niet (goed) zien waar iets vandaan komt.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545726610", "createdAt": "2020-12-18T10:01:14Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import static java.util.Arrays.asList;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.OPTIONAL;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.PROHIBITED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.REQUIRED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.DEFAULT;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.FIXED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.DEPRECATED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import nl.nn.adapterframework.core.IListener;\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.ElementRole;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+/**\n+ * This class writes the XML Schema document (XSD) that checks the validity of a\n+ * Frank configuration XML file. The XML Schema is written based on the information\n+ * in a {@link FrankDocModel} object (the model).\n+ * \n+ * <h1>The syntax 2 name</h1>\n+ *\n+ * Below, a few implementation details are explained. First, the integration specialist\n+ * references an element by a name the reveals both the requested Java class\n+ * (expressed as a {@link FrankElement} in the model)\n+ * and the role it plays (e.g. sender or error sender). These requirements are\n+ * implemented by model method {@link FrankElement#getXsdElementName}. This\n+ * method takes as an argument the relevant {@link ElementType} to which the {@link FrankElement}\n+ * of the Java class belongs. The link between this {@link ElementType} and the\n+ * containing &lt;xs:element&gt; is made through a {@link ConfigChild}.\n+ * The <code>syntax1Name</code> attribute of this {@link ConfigChild}\n+ * is the other argument required by {@link FrankElement#getXsdElementName}.\n+ * <p>\n+ * Each element within the Frank!Framework appears as an &lt;complexType&gt;\n+ * under the XSD root. It is not duplicated for the different roles it\n+ * can play. This complex type references a group of config children and a group\n+ * of attributes. A group of config children consists of &lt;xs:choice&gt; elements that\n+ * each list the allowed elements available to the integration specialist, element groups.\n+ * An option within an element group appears as an &lt;xs:element&gt; that has\n+ * the syntax 2 name as name and the XSD type of the referenced {@link FrankElement} as type.\n+ * <p>\n+ * There is a different element group for each combination of an {@link ElementType} and\n+ * config child syntax 1 name, so there can be multiple element groups per {@link ElementType}. This is\n+ * the only duplication we need because of syntax 2 names. A {@link FrankElement} is\n+ * represented in the XSD with a top-level &lt;xs:complexType&gt; item. That item references\n+ * attribute groups and XSD sequences for config children, but these are not duplicated\n+ * because of the syntax 2 name issue.\n+ *\n+ * <h1>Inheritance of attributes and config children</h1>\n+ * \n+ * Each {@link FrankElement} is represented by a top-level &lt;xs:complexType&gt;.\n+ * Each Frank!Framework element can have attributes or other elements. \n+ * These correspond to {@link FrankAttribute}\n+ * objects or {@link ConfigChild} objects in the model.\n+ * <p>\n+ * In the model, a {@link FrankElement} only holds its declared attributes, but\n+ * the top-level &lt;xs:complexType&gt; should allow both the declared attributes and the attributes\n+ * inherited from the ancestors of the {@link FrankElement} (the inherited attributes).\n+ * The same holds for configuration children. This similarity appears in the model\n+ * through the common base class {@link ElementChild}, which is a parent class of both\n+ * {@link FrankAttribute} and {@link ConfigChild}. An attribute defined high in the\n+ * class hierarchy of the Frank!Framework can be allowed for many FF! elements,\n+ * but we do not want to repeat the same &lt;xs:attribute&gt; tags in all these cases.\n+ * We solve this by grouping the attributes, and the config children, in the XSD, for example:\n+ * \n+ * <pre>\n+ * {@code\n+<xs:complexType name=\"ConfigurationType\">\n+  <xs:group ref=\"ConfigurationDeclaredChildGroup\" />\n+  <xs:attributeGroup ref=\"ConfigurationDeclaredAttributeGroup\" />\n+</xs:complexType>\n+}\n+ * </pre>\n+ * <p>\n+ * The example shows a group named <code>ConfigurationDeclaredChildGroup</code>. This group\n+ * declares all allowed child FF! elements.\n+ * <p>\n+ * An XSD group ending with \"DeclaredChildGroup\" only holds the <em>declared</em> configuration children\n+ * or attributes. This is sufficient for Frank config element &lt;Configuration&gt; because the corresponding\n+ * Java class has only <code>Object</code> as parent. We also use cumulative groups\n+ * that allow the declared items (attributes / config children) of a {@link FrankElement}\n+ * as well as the inherited items. The following example in the XSD illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"LockerCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"LockerDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"JdbcFacadeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+}\n+ * </pre>\n+ * The Frank!Framework has a Java class named <code>Locker</code> that has class\n+ * <code>JdbcFacade</code> as its parent. The group <code>LockerCumulativeAttributeGroup</code>\n+ * is defined recursively: all declared attributes of <code>Locker</code> are in, and all\n+ * declared and inherited attributes of the parent class <code>JdbcFacade</code>. The\n+ * recursion stops with the ancestor that holds the last inherited attributes, because\n+ * for that ancestor we do not introduce a cumulative group and use the declared group\n+ * only.\n+ * <p>\n+ * Another issue about groups needs explanation. Some Java classes of the Frank!Framework override\n+ * attributes that become then duplicate in the model. They appear as declared attributes\n+ * in two {@link FrankElement} objects, one modeling the Java subclass and one modeling the\n+ * Java ancestor class. In this situation, only the attribute (or config child) corresponding\n+ * to the Java subclass is needed. The attribute\n+ * of the ancestor class is omitted. The following example illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"SoapValidatorCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"SoapValidatorDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"Json2XmlValidatorDeclaredAttributeGroup\" />\n+  <xs:attribute name=\"ignoreUnknownNamespaces\" type=\"xs:string\" />\n+  ...\n+  <xs:attributeGroup ref=\"FixedForwardPipeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+ }\n+ * </pre>\n+ * Java class <code>SoapValidator</code> overrides a method <code>setRoot()</code> from\n+ * the grand-parent class <code>XmlValidator</code>. If the cumulative group of\n+ * the parent class <code>Json2XmlValidatorCumulativeAttributeGroup</code> would be referenced,\n+ * we would have attribute \"<code>root</code>\" twice. To avoid this, only the declared group\n+ * <code>Json2XmlValidatorDeclaredAttributeGroup</code> is referenced and the non-duplicate\n+ * attributes of <code>XmlValidator</code> are repeated. Higher up the dependency\n+ * hierarchy, there are no duplicate attributes. Therefore, the list of attributes\n+ * can end with referencing group <code>FixedForwardPipeCumulativeAttributeGroup</code>.\n+ * <p>\n+ * Please note that <code>SoapValidator</code> has a deprecated method <code>setSchema()</code>\n+ * that it overrdes from <code>XmlValidator</code>. The algorithm takes care to not only omit\n+ * attribute <code>schema</code> as a declared attribute,\n+ * but also as an inherited attributre of <code>SoapValidator</code>. Other descendants\n+ * of <code>XmlValidator</code> are not influenced by the override by <code>SoapValidator</code>.\n+ * This part of the algorithm is handled by package-private class\n+ * <code>nl.nn.adapterframework.doc.model.ChildRejector</code>.\n+ * <p>\n+ * Finally, 'technical' overrides are ignored by this algorithm, which are\n+ * setters with an override annotation that are not deprecated and lack\n+ * IbisDoc or IbisDocRef annotations.\n+ * \n+ * <h1> The options for a config child</h1>\n+ *\n+ * The {@link ConfigChild} class in the model determines what &lt;xs:element&gt; are allowed\n+ * as children of another &lt;xs:element&gt;. The containing &lt;xs:element&gt; is the\n+ * <code>owningElement</code> field, which is of type {@link FrankElement}. A {@link ConfigChild} is\n+ * characterized by the combination of an owning element and an {@link ElementType}. As an example\n+ * consider the {@link ConfigChild} that exists for the combination of owning element\n+ * \"<code>Receiver</code>\" and element type \"<code>IListener</code>\". It produces\n+ * the following XML schema:\n+ * <pre>\n+ * {@code\n+<xs:group ref=\"IListenerListenerElementGroup\" minOccurs=\"0\" maxOccurs=\"1\" />\n+}\n+ * </pre>\n+ * This snippet appears within <code>&lt;xs:group name=\"ReceiverDeclaredChildGroup\"&gt;&lt;xs:sequence&gt;</code>.\n+ * The snippet states that a Receiver can contain all elements related to a Java class implementing\n+ * {@link IListener}, playing the role of a listener. The duplication because of syntax 2 names becomes\n+ * visible here.\n+ *\n+ * @author martijn\n+ *\n+ */\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\tprivate static final String ELEMENT_GROUP = \"ElementGroup\";\n+\tprivate static final String ELEMENT_ROLE = \"elementRole\";\n+\n+\tprivate FrankDocModel model;\n+\tprivate String startClassName;\n+\tprivate XmlBuilder xsdRoot;\n+\tprivate Set<String> namesCreatedFrankElements;\n+\tprivate Set<ElementRole.Key> idsCreatedElementGroups;\n+\tprivate Set<String> namesElementTypesWithChildMemberGroup;\n+\tprivate XsdWriteFilter writeFilter;\n+\tprivate XsdWriteFilter.ControlStack writeControl;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t}\n+\n+\tpublic void init() {\n+\t\tinit(CONFIGURATION);\n+\t}\n+\n+\tpublic void init(String startClassName) {\n+\t\tthis.startClassName = startClassName;\n+\t}\n+\n+\tpublic String getSchema() {\n+\t\txsdRoot = getXmlSchema();\n+\t\tList<XsdWriteFilter> writeFilters = asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3MTMxMg==", "bodyText": "Gerrit wou juist wel static imports voor functies van org.junit.Assert. Wanneer wel en wanneer geen statische imports?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545871312", "createdAt": "2020-12-18T14:39:00Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import static java.util.Arrays.asList;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.OPTIONAL;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.PROHIBITED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.REQUIRED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.DEFAULT;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.FIXED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.DEPRECATED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import nl.nn.adapterframework.core.IListener;\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.ElementRole;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+/**\n+ * This class writes the XML Schema document (XSD) that checks the validity of a\n+ * Frank configuration XML file. The XML Schema is written based on the information\n+ * in a {@link FrankDocModel} object (the model).\n+ * \n+ * <h1>The syntax 2 name</h1>\n+ *\n+ * Below, a few implementation details are explained. First, the integration specialist\n+ * references an element by a name the reveals both the requested Java class\n+ * (expressed as a {@link FrankElement} in the model)\n+ * and the role it plays (e.g. sender or error sender). These requirements are\n+ * implemented by model method {@link FrankElement#getXsdElementName}. This\n+ * method takes as an argument the relevant {@link ElementType} to which the {@link FrankElement}\n+ * of the Java class belongs. The link between this {@link ElementType} and the\n+ * containing &lt;xs:element&gt; is made through a {@link ConfigChild}.\n+ * The <code>syntax1Name</code> attribute of this {@link ConfigChild}\n+ * is the other argument required by {@link FrankElement#getXsdElementName}.\n+ * <p>\n+ * Each element within the Frank!Framework appears as an &lt;complexType&gt;\n+ * under the XSD root. It is not duplicated for the different roles it\n+ * can play. This complex type references a group of config children and a group\n+ * of attributes. A group of config children consists of &lt;xs:choice&gt; elements that\n+ * each list the allowed elements available to the integration specialist, element groups.\n+ * An option within an element group appears as an &lt;xs:element&gt; that has\n+ * the syntax 2 name as name and the XSD type of the referenced {@link FrankElement} as type.\n+ * <p>\n+ * There is a different element group for each combination of an {@link ElementType} and\n+ * config child syntax 1 name, so there can be multiple element groups per {@link ElementType}. This is\n+ * the only duplication we need because of syntax 2 names. A {@link FrankElement} is\n+ * represented in the XSD with a top-level &lt;xs:complexType&gt; item. That item references\n+ * attribute groups and XSD sequences for config children, but these are not duplicated\n+ * because of the syntax 2 name issue.\n+ *\n+ * <h1>Inheritance of attributes and config children</h1>\n+ * \n+ * Each {@link FrankElement} is represented by a top-level &lt;xs:complexType&gt;.\n+ * Each Frank!Framework element can have attributes or other elements. \n+ * These correspond to {@link FrankAttribute}\n+ * objects or {@link ConfigChild} objects in the model.\n+ * <p>\n+ * In the model, a {@link FrankElement} only holds its declared attributes, but\n+ * the top-level &lt;xs:complexType&gt; should allow both the declared attributes and the attributes\n+ * inherited from the ancestors of the {@link FrankElement} (the inherited attributes).\n+ * The same holds for configuration children. This similarity appears in the model\n+ * through the common base class {@link ElementChild}, which is a parent class of both\n+ * {@link FrankAttribute} and {@link ConfigChild}. An attribute defined high in the\n+ * class hierarchy of the Frank!Framework can be allowed for many FF! elements,\n+ * but we do not want to repeat the same &lt;xs:attribute&gt; tags in all these cases.\n+ * We solve this by grouping the attributes, and the config children, in the XSD, for example:\n+ * \n+ * <pre>\n+ * {@code\n+<xs:complexType name=\"ConfigurationType\">\n+  <xs:group ref=\"ConfigurationDeclaredChildGroup\" />\n+  <xs:attributeGroup ref=\"ConfigurationDeclaredAttributeGroup\" />\n+</xs:complexType>\n+}\n+ * </pre>\n+ * <p>\n+ * The example shows a group named <code>ConfigurationDeclaredChildGroup</code>. This group\n+ * declares all allowed child FF! elements.\n+ * <p>\n+ * An XSD group ending with \"DeclaredChildGroup\" only holds the <em>declared</em> configuration children\n+ * or attributes. This is sufficient for Frank config element &lt;Configuration&gt; because the corresponding\n+ * Java class has only <code>Object</code> as parent. We also use cumulative groups\n+ * that allow the declared items (attributes / config children) of a {@link FrankElement}\n+ * as well as the inherited items. The following example in the XSD illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"LockerCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"LockerDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"JdbcFacadeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+}\n+ * </pre>\n+ * The Frank!Framework has a Java class named <code>Locker</code> that has class\n+ * <code>JdbcFacade</code> as its parent. The group <code>LockerCumulativeAttributeGroup</code>\n+ * is defined recursively: all declared attributes of <code>Locker</code> are in, and all\n+ * declared and inherited attributes of the parent class <code>JdbcFacade</code>. The\n+ * recursion stops with the ancestor that holds the last inherited attributes, because\n+ * for that ancestor we do not introduce a cumulative group and use the declared group\n+ * only.\n+ * <p>\n+ * Another issue about groups needs explanation. Some Java classes of the Frank!Framework override\n+ * attributes that become then duplicate in the model. They appear as declared attributes\n+ * in two {@link FrankElement} objects, one modeling the Java subclass and one modeling the\n+ * Java ancestor class. In this situation, only the attribute (or config child) corresponding\n+ * to the Java subclass is needed. The attribute\n+ * of the ancestor class is omitted. The following example illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"SoapValidatorCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"SoapValidatorDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"Json2XmlValidatorDeclaredAttributeGroup\" />\n+  <xs:attribute name=\"ignoreUnknownNamespaces\" type=\"xs:string\" />\n+  ...\n+  <xs:attributeGroup ref=\"FixedForwardPipeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+ }\n+ * </pre>\n+ * Java class <code>SoapValidator</code> overrides a method <code>setRoot()</code> from\n+ * the grand-parent class <code>XmlValidator</code>. If the cumulative group of\n+ * the parent class <code>Json2XmlValidatorCumulativeAttributeGroup</code> would be referenced,\n+ * we would have attribute \"<code>root</code>\" twice. To avoid this, only the declared group\n+ * <code>Json2XmlValidatorDeclaredAttributeGroup</code> is referenced and the non-duplicate\n+ * attributes of <code>XmlValidator</code> are repeated. Higher up the dependency\n+ * hierarchy, there are no duplicate attributes. Therefore, the list of attributes\n+ * can end with referencing group <code>FixedForwardPipeCumulativeAttributeGroup</code>.\n+ * <p>\n+ * Please note that <code>SoapValidator</code> has a deprecated method <code>setSchema()</code>\n+ * that it overrdes from <code>XmlValidator</code>. The algorithm takes care to not only omit\n+ * attribute <code>schema</code> as a declared attribute,\n+ * but also as an inherited attributre of <code>SoapValidator</code>. Other descendants\n+ * of <code>XmlValidator</code> are not influenced by the override by <code>SoapValidator</code>.\n+ * This part of the algorithm is handled by package-private class\n+ * <code>nl.nn.adapterframework.doc.model.ChildRejector</code>.\n+ * <p>\n+ * Finally, 'technical' overrides are ignored by this algorithm, which are\n+ * setters with an override annotation that are not deprecated and lack\n+ * IbisDoc or IbisDocRef annotations.\n+ * \n+ * <h1> The options for a config child</h1>\n+ *\n+ * The {@link ConfigChild} class in the model determines what &lt;xs:element&gt; are allowed\n+ * as children of another &lt;xs:element&gt;. The containing &lt;xs:element&gt; is the\n+ * <code>owningElement</code> field, which is of type {@link FrankElement}. A {@link ConfigChild} is\n+ * characterized by the combination of an owning element and an {@link ElementType}. As an example\n+ * consider the {@link ConfigChild} that exists for the combination of owning element\n+ * \"<code>Receiver</code>\" and element type \"<code>IListener</code>\". It produces\n+ * the following XML schema:\n+ * <pre>\n+ * {@code\n+<xs:group ref=\"IListenerListenerElementGroup\" minOccurs=\"0\" maxOccurs=\"1\" />\n+}\n+ * </pre>\n+ * This snippet appears within <code>&lt;xs:group name=\"ReceiverDeclaredChildGroup\"&gt;&lt;xs:sequence&gt;</code>.\n+ * The snippet states that a Receiver can contain all elements related to a Java class implementing\n+ * {@link IListener}, playing the role of a listener. The duplication because of syntax 2 names becomes\n+ * visible here.\n+ *\n+ * @author martijn\n+ *\n+ */\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\tprivate static final String ELEMENT_GROUP = \"ElementGroup\";\n+\tprivate static final String ELEMENT_ROLE = \"elementRole\";\n+\n+\tprivate FrankDocModel model;\n+\tprivate String startClassName;\n+\tprivate XmlBuilder xsdRoot;\n+\tprivate Set<String> namesCreatedFrankElements;\n+\tprivate Set<ElementRole.Key> idsCreatedElementGroups;\n+\tprivate Set<String> namesElementTypesWithChildMemberGroup;\n+\tprivate XsdWriteFilter writeFilter;\n+\tprivate XsdWriteFilter.ControlStack writeControl;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t}\n+\n+\tpublic void init() {\n+\t\tinit(CONFIGURATION);\n+\t}\n+\n+\tpublic void init(String startClassName) {\n+\t\tthis.startClassName = startClassName;\n+\t}\n+\n+\tpublic String getSchema() {\n+\t\txsdRoot = getXmlSchema();\n+\t\tList<XsdWriteFilter> writeFilters = asList(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNjYxMA=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk2MTM3MQ==", "bodyText": "Gerrit, je hebt me door de telefoon verteld wat het criterium is. Als duidelijk is waar een method vandaan komt, zoals bij org.junit.Assert.* in unit tests, dan doen we een statische import. Als uit de context niet duidelijk is waar een method vandaan komt, dan doen we geen statische import.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545961371", "createdAt": "2020-12-18T16:55:16Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import static java.util.Arrays.asList;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.OPTIONAL;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.PROHIBITED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.REQUIRED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.DEFAULT;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.FIXED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.DEPRECATED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import nl.nn.adapterframework.core.IListener;\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.ElementRole;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+/**\n+ * This class writes the XML Schema document (XSD) that checks the validity of a\n+ * Frank configuration XML file. The XML Schema is written based on the information\n+ * in a {@link FrankDocModel} object (the model).\n+ * \n+ * <h1>The syntax 2 name</h1>\n+ *\n+ * Below, a few implementation details are explained. First, the integration specialist\n+ * references an element by a name the reveals both the requested Java class\n+ * (expressed as a {@link FrankElement} in the model)\n+ * and the role it plays (e.g. sender or error sender). These requirements are\n+ * implemented by model method {@link FrankElement#getXsdElementName}. This\n+ * method takes as an argument the relevant {@link ElementType} to which the {@link FrankElement}\n+ * of the Java class belongs. The link between this {@link ElementType} and the\n+ * containing &lt;xs:element&gt; is made through a {@link ConfigChild}.\n+ * The <code>syntax1Name</code> attribute of this {@link ConfigChild}\n+ * is the other argument required by {@link FrankElement#getXsdElementName}.\n+ * <p>\n+ * Each element within the Frank!Framework appears as an &lt;complexType&gt;\n+ * under the XSD root. It is not duplicated for the different roles it\n+ * can play. This complex type references a group of config children and a group\n+ * of attributes. A group of config children consists of &lt;xs:choice&gt; elements that\n+ * each list the allowed elements available to the integration specialist, element groups.\n+ * An option within an element group appears as an &lt;xs:element&gt; that has\n+ * the syntax 2 name as name and the XSD type of the referenced {@link FrankElement} as type.\n+ * <p>\n+ * There is a different element group for each combination of an {@link ElementType} and\n+ * config child syntax 1 name, so there can be multiple element groups per {@link ElementType}. This is\n+ * the only duplication we need because of syntax 2 names. A {@link FrankElement} is\n+ * represented in the XSD with a top-level &lt;xs:complexType&gt; item. That item references\n+ * attribute groups and XSD sequences for config children, but these are not duplicated\n+ * because of the syntax 2 name issue.\n+ *\n+ * <h1>Inheritance of attributes and config children</h1>\n+ * \n+ * Each {@link FrankElement} is represented by a top-level &lt;xs:complexType&gt;.\n+ * Each Frank!Framework element can have attributes or other elements. \n+ * These correspond to {@link FrankAttribute}\n+ * objects or {@link ConfigChild} objects in the model.\n+ * <p>\n+ * In the model, a {@link FrankElement} only holds its declared attributes, but\n+ * the top-level &lt;xs:complexType&gt; should allow both the declared attributes and the attributes\n+ * inherited from the ancestors of the {@link FrankElement} (the inherited attributes).\n+ * The same holds for configuration children. This similarity appears in the model\n+ * through the common base class {@link ElementChild}, which is a parent class of both\n+ * {@link FrankAttribute} and {@link ConfigChild}. An attribute defined high in the\n+ * class hierarchy of the Frank!Framework can be allowed for many FF! elements,\n+ * but we do not want to repeat the same &lt;xs:attribute&gt; tags in all these cases.\n+ * We solve this by grouping the attributes, and the config children, in the XSD, for example:\n+ * \n+ * <pre>\n+ * {@code\n+<xs:complexType name=\"ConfigurationType\">\n+  <xs:group ref=\"ConfigurationDeclaredChildGroup\" />\n+  <xs:attributeGroup ref=\"ConfigurationDeclaredAttributeGroup\" />\n+</xs:complexType>\n+}\n+ * </pre>\n+ * <p>\n+ * The example shows a group named <code>ConfigurationDeclaredChildGroup</code>. This group\n+ * declares all allowed child FF! elements.\n+ * <p>\n+ * An XSD group ending with \"DeclaredChildGroup\" only holds the <em>declared</em> configuration children\n+ * or attributes. This is sufficient for Frank config element &lt;Configuration&gt; because the corresponding\n+ * Java class has only <code>Object</code> as parent. We also use cumulative groups\n+ * that allow the declared items (attributes / config children) of a {@link FrankElement}\n+ * as well as the inherited items. The following example in the XSD illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"LockerCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"LockerDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"JdbcFacadeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+}\n+ * </pre>\n+ * The Frank!Framework has a Java class named <code>Locker</code> that has class\n+ * <code>JdbcFacade</code> as its parent. The group <code>LockerCumulativeAttributeGroup</code>\n+ * is defined recursively: all declared attributes of <code>Locker</code> are in, and all\n+ * declared and inherited attributes of the parent class <code>JdbcFacade</code>. The\n+ * recursion stops with the ancestor that holds the last inherited attributes, because\n+ * for that ancestor we do not introduce a cumulative group and use the declared group\n+ * only.\n+ * <p>\n+ * Another issue about groups needs explanation. Some Java classes of the Frank!Framework override\n+ * attributes that become then duplicate in the model. They appear as declared attributes\n+ * in two {@link FrankElement} objects, one modeling the Java subclass and one modeling the\n+ * Java ancestor class. In this situation, only the attribute (or config child) corresponding\n+ * to the Java subclass is needed. The attribute\n+ * of the ancestor class is omitted. The following example illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"SoapValidatorCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"SoapValidatorDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"Json2XmlValidatorDeclaredAttributeGroup\" />\n+  <xs:attribute name=\"ignoreUnknownNamespaces\" type=\"xs:string\" />\n+  ...\n+  <xs:attributeGroup ref=\"FixedForwardPipeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+ }\n+ * </pre>\n+ * Java class <code>SoapValidator</code> overrides a method <code>setRoot()</code> from\n+ * the grand-parent class <code>XmlValidator</code>. If the cumulative group of\n+ * the parent class <code>Json2XmlValidatorCumulativeAttributeGroup</code> would be referenced,\n+ * we would have attribute \"<code>root</code>\" twice. To avoid this, only the declared group\n+ * <code>Json2XmlValidatorDeclaredAttributeGroup</code> is referenced and the non-duplicate\n+ * attributes of <code>XmlValidator</code> are repeated. Higher up the dependency\n+ * hierarchy, there are no duplicate attributes. Therefore, the list of attributes\n+ * can end with referencing group <code>FixedForwardPipeCumulativeAttributeGroup</code>.\n+ * <p>\n+ * Please note that <code>SoapValidator</code> has a deprecated method <code>setSchema()</code>\n+ * that it overrdes from <code>XmlValidator</code>. The algorithm takes care to not only omit\n+ * attribute <code>schema</code> as a declared attribute,\n+ * but also as an inherited attributre of <code>SoapValidator</code>. Other descendants\n+ * of <code>XmlValidator</code> are not influenced by the override by <code>SoapValidator</code>.\n+ * This part of the algorithm is handled by package-private class\n+ * <code>nl.nn.adapterframework.doc.model.ChildRejector</code>.\n+ * <p>\n+ * Finally, 'technical' overrides are ignored by this algorithm, which are\n+ * setters with an override annotation that are not deprecated and lack\n+ * IbisDoc or IbisDocRef annotations.\n+ * \n+ * <h1> The options for a config child</h1>\n+ *\n+ * The {@link ConfigChild} class in the model determines what &lt;xs:element&gt; are allowed\n+ * as children of another &lt;xs:element&gt;. The containing &lt;xs:element&gt; is the\n+ * <code>owningElement</code> field, which is of type {@link FrankElement}. A {@link ConfigChild} is\n+ * characterized by the combination of an owning element and an {@link ElementType}. As an example\n+ * consider the {@link ConfigChild} that exists for the combination of owning element\n+ * \"<code>Receiver</code>\" and element type \"<code>IListener</code>\". It produces\n+ * the following XML schema:\n+ * <pre>\n+ * {@code\n+<xs:group ref=\"IListenerListenerElementGroup\" minOccurs=\"0\" maxOccurs=\"1\" />\n+}\n+ * </pre>\n+ * This snippet appears within <code>&lt;xs:group name=\"ReceiverDeclaredChildGroup\"&gt;&lt;xs:sequence&gt;</code>.\n+ * The snippet states that a Receiver can contain all elements related to a Java class implementing\n+ * {@link IListener}, playing the role of a listener. The duplication because of syntax 2 names becomes\n+ * visible here.\n+ *\n+ * @author martijn\n+ *\n+ */\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\tprivate static final String ELEMENT_GROUP = \"ElementGroup\";\n+\tprivate static final String ELEMENT_ROLE = \"elementRole\";\n+\n+\tprivate FrankDocModel model;\n+\tprivate String startClassName;\n+\tprivate XmlBuilder xsdRoot;\n+\tprivate Set<String> namesCreatedFrankElements;\n+\tprivate Set<ElementRole.Key> idsCreatedElementGroups;\n+\tprivate Set<String> namesElementTypesWithChildMemberGroup;\n+\tprivate XsdWriteFilter writeFilter;\n+\tprivate XsdWriteFilter.ControlStack writeControl;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t}\n+\n+\tpublic void init() {\n+\t\tinit(CONFIGURATION);\n+\t}\n+\n+\tpublic void init(String startClassName) {\n+\t\tthis.startClassName = startClassName;\n+\t}\n+\n+\tpublic String getSchema() {\n+\t\txsdRoot = getXmlSchema();\n+\t\tList<XsdWriteFilter> writeFilters = asList(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNjYxMA=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk0NjIyNQ==", "bodyText": "Precies!", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554946225", "createdAt": "2021-01-11T10:23:45Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/DocWriterNew.java", "diffHunk": "@@ -0,0 +1,646 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc;\n+\n+import static java.util.Arrays.asList;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.getXmlSchema;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.OPTIONAL;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.PROHIBITED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeUse.REQUIRED;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.DEFAULT;\n+import static nl.nn.adapterframework.doc.DocWriterNewXmlUtils.AttributeValueStatus.FIXED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.DEPRECATED;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import nl.nn.adapterframework.core.IListener;\n+import nl.nn.adapterframework.doc.model.ConfigChild;\n+import nl.nn.adapterframework.doc.model.ElementChild;\n+import nl.nn.adapterframework.doc.model.ElementRole;\n+import nl.nn.adapterframework.doc.model.ElementType;\n+import nl.nn.adapterframework.doc.model.FrankAttribute;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.doc.model.FrankElement;\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+/**\n+ * This class writes the XML Schema document (XSD) that checks the validity of a\n+ * Frank configuration XML file. The XML Schema is written based on the information\n+ * in a {@link FrankDocModel} object (the model).\n+ * \n+ * <h1>The syntax 2 name</h1>\n+ *\n+ * Below, a few implementation details are explained. First, the integration specialist\n+ * references an element by a name the reveals both the requested Java class\n+ * (expressed as a {@link FrankElement} in the model)\n+ * and the role it plays (e.g. sender or error sender). These requirements are\n+ * implemented by model method {@link FrankElement#getXsdElementName}. This\n+ * method takes as an argument the relevant {@link ElementType} to which the {@link FrankElement}\n+ * of the Java class belongs. The link between this {@link ElementType} and the\n+ * containing &lt;xs:element&gt; is made through a {@link ConfigChild}.\n+ * The <code>syntax1Name</code> attribute of this {@link ConfigChild}\n+ * is the other argument required by {@link FrankElement#getXsdElementName}.\n+ * <p>\n+ * Each element within the Frank!Framework appears as an &lt;complexType&gt;\n+ * under the XSD root. It is not duplicated for the different roles it\n+ * can play. This complex type references a group of config children and a group\n+ * of attributes. A group of config children consists of &lt;xs:choice&gt; elements that\n+ * each list the allowed elements available to the integration specialist, element groups.\n+ * An option within an element group appears as an &lt;xs:element&gt; that has\n+ * the syntax 2 name as name and the XSD type of the referenced {@link FrankElement} as type.\n+ * <p>\n+ * There is a different element group for each combination of an {@link ElementType} and\n+ * config child syntax 1 name, so there can be multiple element groups per {@link ElementType}. This is\n+ * the only duplication we need because of syntax 2 names. A {@link FrankElement} is\n+ * represented in the XSD with a top-level &lt;xs:complexType&gt; item. That item references\n+ * attribute groups and XSD sequences for config children, but these are not duplicated\n+ * because of the syntax 2 name issue.\n+ *\n+ * <h1>Inheritance of attributes and config children</h1>\n+ * \n+ * Each {@link FrankElement} is represented by a top-level &lt;xs:complexType&gt;.\n+ * Each Frank!Framework element can have attributes or other elements. \n+ * These correspond to {@link FrankAttribute}\n+ * objects or {@link ConfigChild} objects in the model.\n+ * <p>\n+ * In the model, a {@link FrankElement} only holds its declared attributes, but\n+ * the top-level &lt;xs:complexType&gt; should allow both the declared attributes and the attributes\n+ * inherited from the ancestors of the {@link FrankElement} (the inherited attributes).\n+ * The same holds for configuration children. This similarity appears in the model\n+ * through the common base class {@link ElementChild}, which is a parent class of both\n+ * {@link FrankAttribute} and {@link ConfigChild}. An attribute defined high in the\n+ * class hierarchy of the Frank!Framework can be allowed for many FF! elements,\n+ * but we do not want to repeat the same &lt;xs:attribute&gt; tags in all these cases.\n+ * We solve this by grouping the attributes, and the config children, in the XSD, for example:\n+ * \n+ * <pre>\n+ * {@code\n+<xs:complexType name=\"ConfigurationType\">\n+  <xs:group ref=\"ConfigurationDeclaredChildGroup\" />\n+  <xs:attributeGroup ref=\"ConfigurationDeclaredAttributeGroup\" />\n+</xs:complexType>\n+}\n+ * </pre>\n+ * <p>\n+ * The example shows a group named <code>ConfigurationDeclaredChildGroup</code>. This group\n+ * declares all allowed child FF! elements.\n+ * <p>\n+ * An XSD group ending with \"DeclaredChildGroup\" only holds the <em>declared</em> configuration children\n+ * or attributes. This is sufficient for Frank config element &lt;Configuration&gt; because the corresponding\n+ * Java class has only <code>Object</code> as parent. We also use cumulative groups\n+ * that allow the declared items (attributes / config children) of a {@link FrankElement}\n+ * as well as the inherited items. The following example in the XSD illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"LockerCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"LockerDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"JdbcFacadeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+}\n+ * </pre>\n+ * The Frank!Framework has a Java class named <code>Locker</code> that has class\n+ * <code>JdbcFacade</code> as its parent. The group <code>LockerCumulativeAttributeGroup</code>\n+ * is defined recursively: all declared attributes of <code>Locker</code> are in, and all\n+ * declared and inherited attributes of the parent class <code>JdbcFacade</code>. The\n+ * recursion stops with the ancestor that holds the last inherited attributes, because\n+ * for that ancestor we do not introduce a cumulative group and use the declared group\n+ * only.\n+ * <p>\n+ * Another issue about groups needs explanation. Some Java classes of the Frank!Framework override\n+ * attributes that become then duplicate in the model. They appear as declared attributes\n+ * in two {@link FrankElement} objects, one modeling the Java subclass and one modeling the\n+ * Java ancestor class. In this situation, only the attribute (or config child) corresponding\n+ * to the Java subclass is needed. The attribute\n+ * of the ancestor class is omitted. The following example illustrates this:\n+ * <pre>\n+ {@code\n+<xs:attributeGroup name=\"SoapValidatorCumulativeAttributeGroup\">\n+  <xs:attributeGroup ref=\"SoapValidatorDeclaredAttributeGroup\" />\n+  <xs:attributeGroup ref=\"Json2XmlValidatorDeclaredAttributeGroup\" />\n+  <xs:attribute name=\"ignoreUnknownNamespaces\" type=\"xs:string\" />\n+  ...\n+  <xs:attributeGroup ref=\"FixedForwardPipeCumulativeAttributeGroup\" />\n+</xs:attributeGroup>\n+ }\n+ * </pre>\n+ * Java class <code>SoapValidator</code> overrides a method <code>setRoot()</code> from\n+ * the grand-parent class <code>XmlValidator</code>. If the cumulative group of\n+ * the parent class <code>Json2XmlValidatorCumulativeAttributeGroup</code> would be referenced,\n+ * we would have attribute \"<code>root</code>\" twice. To avoid this, only the declared group\n+ * <code>Json2XmlValidatorDeclaredAttributeGroup</code> is referenced and the non-duplicate\n+ * attributes of <code>XmlValidator</code> are repeated. Higher up the dependency\n+ * hierarchy, there are no duplicate attributes. Therefore, the list of attributes\n+ * can end with referencing group <code>FixedForwardPipeCumulativeAttributeGroup</code>.\n+ * <p>\n+ * Please note that <code>SoapValidator</code> has a deprecated method <code>setSchema()</code>\n+ * that it overrdes from <code>XmlValidator</code>. The algorithm takes care to not only omit\n+ * attribute <code>schema</code> as a declared attribute,\n+ * but also as an inherited attributre of <code>SoapValidator</code>. Other descendants\n+ * of <code>XmlValidator</code> are not influenced by the override by <code>SoapValidator</code>.\n+ * This part of the algorithm is handled by package-private class\n+ * <code>nl.nn.adapterframework.doc.model.ChildRejector</code>.\n+ * <p>\n+ * Finally, 'technical' overrides are ignored by this algorithm, which are\n+ * setters with an override annotation that are not deprecated and lack\n+ * IbisDoc or IbisDocRef annotations.\n+ * \n+ * <h1> The options for a config child</h1>\n+ *\n+ * The {@link ConfigChild} class in the model determines what &lt;xs:element&gt; are allowed\n+ * as children of another &lt;xs:element&gt;. The containing &lt;xs:element&gt; is the\n+ * <code>owningElement</code> field, which is of type {@link FrankElement}. A {@link ConfigChild} is\n+ * characterized by the combination of an owning element and an {@link ElementType}. As an example\n+ * consider the {@link ConfigChild} that exists for the combination of owning element\n+ * \"<code>Receiver</code>\" and element type \"<code>IListener</code>\". It produces\n+ * the following XML schema:\n+ * <pre>\n+ * {@code\n+<xs:group ref=\"IListenerListenerElementGroup\" minOccurs=\"0\" maxOccurs=\"1\" />\n+}\n+ * </pre>\n+ * This snippet appears within <code>&lt;xs:group name=\"ReceiverDeclaredChildGroup\"&gt;&lt;xs:sequence&gt;</code>.\n+ * The snippet states that a Receiver can contain all elements related to a Java class implementing\n+ * {@link IListener}, playing the role of a listener. The duplication because of syntax 2 names becomes\n+ * visible here.\n+ *\n+ * @author martijn\n+ *\n+ */\n+public class DocWriterNew {\n+\tprivate static final String CONFIGURATION = \"nl.nn.adapterframework.configuration.Configuration\";\n+\tprivate static final String ELEMENT_GROUP = \"ElementGroup\";\n+\tprivate static final String ELEMENT_ROLE = \"elementRole\";\n+\n+\tprivate FrankDocModel model;\n+\tprivate String startClassName;\n+\tprivate XmlBuilder xsdRoot;\n+\tprivate Set<String> namesCreatedFrankElements;\n+\tprivate Set<ElementRole.Key> idsCreatedElementGroups;\n+\tprivate Set<String> namesElementTypesWithChildMemberGroup;\n+\tprivate XsdWriteFilter writeFilter;\n+\tprivate XsdWriteFilter.ControlStack writeControl;\n+\n+\tpublic DocWriterNew(FrankDocModel model) {\n+\t\tthis.model = model;\n+\t}\n+\n+\tpublic void init() {\n+\t\tinit(CONFIGURATION);\n+\t}\n+\n+\tpublic void init(String startClassName) {\n+\t\tthis.startClassName = startClassName;\n+\t}\n+\n+\tpublic String getSchema() {\n+\t\txsdRoot = getXmlSchema();\n+\t\tList<XsdWriteFilter> writeFilters = asList(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyNjYxMA=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDExNDM4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/Utils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxMzowOVrOIIc5EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo1MDo1M1rOIROEOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMjg4MQ==", "bodyText": "Is het een idee om de methodes geheel te verplaatsen naar de Utils klasse in plaats van er naar te refereren? Dit zijn utilities, en horen daarom hier thuis.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545732881", "createdAt": "2020-12-18T10:13:09Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/Utils.java", "diffHunk": "@@ -44,4 +60,12 @@ public static boolean isAttributeGetterOrSetter(Method method) {\n \tpublic static boolean isConfigChildSetter(Method method) {\n \t\treturn InfoBuilderSource.isConfigChildSetter(method);\n \t}\n+\n+\tpublic static String toUpperCamelCase(String arg) {\n+\t\treturn InfoBuilderSource.toUpperCamelCase(arg);\n+\t}\n+\n+\tpublic static String promoteIfPrimitive(String typeName) {\n+\t\treturn InfoBuilderSource.promoteIfPrimitive(typeName);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3MDM0MQ==", "bodyText": "Dat kan denk ik pas als we de bestaande code voor ibisdoc.xsd weggooien. Nu is er gemeenschappelijke code tussen de oude en de nieuwe oplossing. Deze verwijzingen zijn een manier om daarmee om te gaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545870341", "createdAt": "2020-12-18T14:37:31Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/Utils.java", "diffHunk": "@@ -44,4 +60,12 @@ public static boolean isAttributeGetterOrSetter(Method method) {\n \tpublic static boolean isConfigChildSetter(Method method) {\n \t\treturn InfoBuilderSource.isConfigChildSetter(method);\n \t}\n+\n+\tpublic static String toUpperCamelCase(String arg) {\n+\t\treturn InfoBuilderSource.toUpperCamelCase(arg);\n+\t}\n+\n+\tpublic static String promoteIfPrimitive(String typeName) {\n+\t\treturn InfoBuilderSource.promoteIfPrimitive(typeName);\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMjg4MQ=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkyNzE2Mw==", "bodyText": "Okey, zolang we het maar niet vergeten!", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554927163", "createdAt": "2021-01-11T09:50:53Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/Utils.java", "diffHunk": "@@ -44,4 +60,12 @@ public static boolean isAttributeGetterOrSetter(Method method) {\n \tpublic static boolean isConfigChildSetter(Method method) {\n \t\treturn InfoBuilderSource.isConfigChildSetter(method);\n \t}\n+\n+\tpublic static String toUpperCamelCase(String arg) {\n+\t\treturn InfoBuilderSource.toUpperCamelCase(arg);\n+\t}\n+\n+\tpublic static String promoteIfPrimitive(String typeName) {\n+\t\treturn InfoBuilderSource.promoteIfPrimitive(typeName);\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMjg4MQ=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDEzNjAwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/XsdWriteFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxODo1N1rOIIdFuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjowMzo1MFrOIN3OrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczNjEyMA==", "bodyText": "informative: probeer overal de methode argumenten op 1 regel te zetten, en niet soms op 1 regel, en soms onder elkaar. Het wordt er echt niet leesbaarder door om alles onder elkaar te zetten, en omdat onze schermen horizontaal staan mogen de regels best 150 characters lang zijn.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545736120", "createdAt": "2020-12-18T10:18:57Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/XsdWriteFilter.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+abstract class XsdWriteFilter {\n+\tboolean isWritingOn;\n+\n+\tabstract void startSimpleElement();\n+\tabstract void startComplexStuff();\n+\t\n+\tstatic class EnableSimpleElements extends XsdWriteFilter {\n+\t\t@Override\n+\t\tvoid startSimpleElement() {\n+\t\t\tthis.isWritingOn = true;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tvoid startComplexStuff() {\n+\t\t\tisWritingOn = false;\n+\t\t}\n+\t}\n+\n+\tstatic class EnableComplexStuff extends XsdWriteFilter {\n+\t\t@Override\n+\t\tvoid startSimpleElement() {\n+\t\t\tisWritingOn = false;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tvoid startComplexStuff() {\n+\t\t\tisWritingOn = true;\n+\t\t}\n+\t}\n+\n+\tprivate enum ControlNode {\n+\t\tSIMPLE_ELEMENT,\n+\t\tCOMPLEX_STUFF;\n+\t}\n+\n+\tstatic class ControlStack {\n+\t\tprivate final XsdWriteFilter slave;\n+\t\tprivate final Deque<ControlNode> controlNodes = new ArrayDeque<>();\n+\n+\t\tControlStack(XsdWriteFilter slave) {\n+\t\t\tthis.slave = slave;\n+\t\t\t// If all other write controls are popped, then we have complex stuff.\n+\t\t\tpushComplexStuff();\n+\t\t}\n+\n+\t\tvoid pushSimpleElement() {\n+\t\t\tcontrolNodes.addLast(ControlNode.SIMPLE_ELEMENT);\n+\t\t\tapply();\n+\t\t}\n+\n+\t\tvoid pushComplexStuff() {\n+\t\t\tcontrolNodes.addLast(ControlNode.COMPLEX_STUFF);\n+\t\t\tapply();\n+\t\t}\n+\n+\t\tvoid pop() {\n+\t\t\tcontrolNodes.removeLast();\n+\t\t\tapply();\n+\t\t}\n+\n+\t\tprivate void apply() {\n+\t\t\tswitch(controlNodes.getLast()) {\n+\t\t\tcase SIMPLE_ELEMENT:\n+\t\t\t\tslave.startSimpleElement();\n+\t\t\t\tbreak;\n+\t\t\tcase COMPLEX_STUFF:\n+\t\t\t\tslave.startComplexStuff();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvoid addElement(XmlBuilder context, String elementName, String elementType) {\n+\t\tif(isWritingOn) {\n+\t\t\tDocWriterNewXmlUtils.addElement(context, elementName, elementType);\n+\t\t}\n+\t}\n+\n+\tvoid addElementRef(\n+\t\t\tXmlBuilder context,\n+\t\t\tString elementName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQwNzI3Ng==", "bodyText": "Gedaan", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551407276", "createdAt": "2021-01-04T16:03:50Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/XsdWriteFilter.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package nl.nn.adapterframework.doc;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+\n+import nl.nn.adapterframework.util.XmlBuilder;\n+\n+abstract class XsdWriteFilter {\n+\tboolean isWritingOn;\n+\n+\tabstract void startSimpleElement();\n+\tabstract void startComplexStuff();\n+\t\n+\tstatic class EnableSimpleElements extends XsdWriteFilter {\n+\t\t@Override\n+\t\tvoid startSimpleElement() {\n+\t\t\tthis.isWritingOn = true;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tvoid startComplexStuff() {\n+\t\t\tisWritingOn = false;\n+\t\t}\n+\t}\n+\n+\tstatic class EnableComplexStuff extends XsdWriteFilter {\n+\t\t@Override\n+\t\tvoid startSimpleElement() {\n+\t\t\tisWritingOn = false;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tvoid startComplexStuff() {\n+\t\t\tisWritingOn = true;\n+\t\t}\n+\t}\n+\n+\tprivate enum ControlNode {\n+\t\tSIMPLE_ELEMENT,\n+\t\tCOMPLEX_STUFF;\n+\t}\n+\n+\tstatic class ControlStack {\n+\t\tprivate final XsdWriteFilter slave;\n+\t\tprivate final Deque<ControlNode> controlNodes = new ArrayDeque<>();\n+\n+\t\tControlStack(XsdWriteFilter slave) {\n+\t\t\tthis.slave = slave;\n+\t\t\t// If all other write controls are popped, then we have complex stuff.\n+\t\t\tpushComplexStuff();\n+\t\t}\n+\n+\t\tvoid pushSimpleElement() {\n+\t\t\tcontrolNodes.addLast(ControlNode.SIMPLE_ELEMENT);\n+\t\t\tapply();\n+\t\t}\n+\n+\t\tvoid pushComplexStuff() {\n+\t\t\tcontrolNodes.addLast(ControlNode.COMPLEX_STUFF);\n+\t\t\tapply();\n+\t\t}\n+\n+\t\tvoid pop() {\n+\t\t\tcontrolNodes.removeLast();\n+\t\t\tapply();\n+\t\t}\n+\n+\t\tprivate void apply() {\n+\t\t\tswitch(controlNodes.getLast()) {\n+\t\t\tcase SIMPLE_ELEMENT:\n+\t\t\t\tslave.startSimpleElement();\n+\t\t\t\tbreak;\n+\t\t\tcase COMPLEX_STUFF:\n+\t\t\t\tslave.startComplexStuff();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvoid addElement(XmlBuilder context, String elementName, String elementType) {\n+\t\tif(isWritingOn) {\n+\t\t\tDocWriterNewXmlUtils.addElement(context, elementName, elementType);\n+\t\t}\n+\t}\n+\n+\tvoid addElementRef(\n+\t\t\tXmlBuilder context,\n+\t\t\tString elementName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczNjEyMA=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDI1MTIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDo1MjoxNVrOIIeKyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjoxMToyN1rOIN3i_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1MzgwMg==", "bodyText": "Ik ben zelf geen grote fan van nested classes. Ik zie hier 3 nested classes voorkomen. Ik snap dat dit soms handig is, maar maak van deze Exceptie een losse klasse.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545753802", "createdAt": "2020-12-18T10:52:15Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -1,51 +1,162 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n-import org.apache.logging.log4j.Logger;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.springframework.core.annotation.AnnotationUtils;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.Setter;\n import nl.nn.adapterframework.doc.IbisDoc;\n-import nl.nn.adapterframework.util.LogUtil;\n \n-public class ConfigChild {\n-\tprivate static Logger log = LogUtil.getLogger(ConfigChild.class);\n+public class ConfigChild extends ElementChild {\n+\tprivate static final Comparator<SortNode> SORT_NODE_COMPARATOR =\n+\t\t\tComparator.comparing(SortNode::getSequenceInConfig)\n+\t\t\t.thenComparing(SortNode::getName);\n+\n+\tstatic final class SortNode implements Comparable<SortNode> {\n+\t\tprivate @Getter int sequenceInConfig = Integer.MAX_VALUE;\n+\t\tprivate @Getter String name;\n+\t\tprivate @Getter boolean documented;\n+\t\tprivate @Getter boolean deprecated;\n+\t\tprivate @Getter Method method;\n+\n+\t\tSortNode(Method method) {\n+\t\t\tthis.name = method.getName();\n+\t\t\tthis.method = method;\n+\t\t\tthis.documented = (method.getAnnotation(IbisDoc.class) != null);\n+\t\t\tthis.deprecated = isDeprecated(method);\n+\t\t}\n+\n+\t\tvoid parseIbisDocAnnotation() throws IbisDocAnnotationException {\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\t\tif(ibisDoc == null) {\n+\t\t\t\tthrow new IbisDocAnnotationException(String.format(\n+\t\t\t\t\t\t\"No @IbisDoc annotation on method [%s]\", name));\n+\t\t\t}\n+\t\t\tInteger optionalOrder = parseIbisDocAnnotation(ibisDoc);\n+\t\t\tif(optionalOrder != null) {\n+\t\t\t\tsequenceInConfig = optionalOrder;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate Integer parseIbisDocAnnotation(IbisDoc ibisDoc) throws IbisDocAnnotationException {\n+\t\t\tInteger result = null;\n+\t\t\tif(ibisDoc.value().length >= 1) {\n+\t\t\t\ttry {\n+\t\t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n+\t\t\t\t} catch(Exception e) {\n+\t\t\t\t\tthrow new IbisDocAnnotationException(String.format(\n+\t\t\t\t\t\t\t\"@IbisDoc annotation on method [%s] has no valid order\", name));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tprivate static boolean isDeprecated(Method m) {\n+\t\t\tDeprecated deprecated = m.getAnnotation(Deprecated.class);\n+\t\t\treturn (deprecated != null);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int compareTo(SortNode other) {\n+\t\t\treturn SORT_NODE_COMPARATOR.compare(this, other);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"serial\")\n+\tpublic static class IbisDocAnnotationException extends Exception {\t\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQxMjQ3OA==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551412478", "createdAt": "2021-01-04T16:11:27Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ConfigChild.java", "diffHunk": "@@ -1,51 +1,162 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n-import org.apache.logging.log4j.Logger;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.springframework.core.annotation.AnnotationUtils;\n \n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.Setter;\n import nl.nn.adapterframework.doc.IbisDoc;\n-import nl.nn.adapterframework.util.LogUtil;\n \n-public class ConfigChild {\n-\tprivate static Logger log = LogUtil.getLogger(ConfigChild.class);\n+public class ConfigChild extends ElementChild {\n+\tprivate static final Comparator<SortNode> SORT_NODE_COMPARATOR =\n+\t\t\tComparator.comparing(SortNode::getSequenceInConfig)\n+\t\t\t.thenComparing(SortNode::getName);\n+\n+\tstatic final class SortNode implements Comparable<SortNode> {\n+\t\tprivate @Getter int sequenceInConfig = Integer.MAX_VALUE;\n+\t\tprivate @Getter String name;\n+\t\tprivate @Getter boolean documented;\n+\t\tprivate @Getter boolean deprecated;\n+\t\tprivate @Getter Method method;\n+\n+\t\tSortNode(Method method) {\n+\t\t\tthis.name = method.getName();\n+\t\t\tthis.method = method;\n+\t\t\tthis.documented = (method.getAnnotation(IbisDoc.class) != null);\n+\t\t\tthis.deprecated = isDeprecated(method);\n+\t\t}\n+\n+\t\tvoid parseIbisDocAnnotation() throws IbisDocAnnotationException {\n+\t\t\tIbisDoc ibisDoc = AnnotationUtils.findAnnotation(method, IbisDoc.class);\n+\t\t\tif(ibisDoc == null) {\n+\t\t\t\tthrow new IbisDocAnnotationException(String.format(\n+\t\t\t\t\t\t\"No @IbisDoc annotation on method [%s]\", name));\n+\t\t\t}\n+\t\t\tInteger optionalOrder = parseIbisDocAnnotation(ibisDoc);\n+\t\t\tif(optionalOrder != null) {\n+\t\t\t\tsequenceInConfig = optionalOrder;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate Integer parseIbisDocAnnotation(IbisDoc ibisDoc) throws IbisDocAnnotationException {\n+\t\t\tInteger result = null;\n+\t\t\tif(ibisDoc.value().length >= 1) {\n+\t\t\t\ttry {\n+\t\t\t\t\tresult = Integer.valueOf(ibisDoc.value()[0]);\n+\t\t\t\t} catch(Exception e) {\n+\t\t\t\t\tthrow new IbisDocAnnotationException(String.format(\n+\t\t\t\t\t\t\t\"@IbisDoc annotation on method [%s] has no valid order\", name));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\tprivate static boolean isDeprecated(Method m) {\n+\t\t\tDeprecated deprecated = m.getAnnotation(Deprecated.class);\n+\t\t\treturn (deprecated != null);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int compareTo(SortNode other) {\n+\t\t\treturn SORT_NODE_COMPARATOR.compare(this, other);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"serial\")\n+\tpublic static class IbisDocAnnotationException extends Exception {\t\t", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc1MzgwMg=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDMxMzQzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToxMDoyNlrOIIevrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjoyNToyMlrOIN4GFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MzI0Ng==", "bodyText": "Kan je van ? een generic parameter maken?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tElementChild findElementChildMatch(ElementChild elementChild, Class<? extends ElementChild> kind) {\n          \n          \n            \n            \t\tMap<? extends AbstractKey, ? extends ElementChild> lookup = allChildren.get(kind);\n          \n          \n            \n            \t\treturn lookup.get(elementChild.getKey());\n          \n          \n            \n            \t}\n          \n          \n            \n            \t<C extends ElementChild> C findElementChildMatch(C elementChild) {\n          \n          \n            \n            \t\tMap<? extends AbstractKey, ? extends ElementChild> lookup = allChildren.get(elementChild.getClass());\n          \n          \n            \n            \t\treturn lookup.get(elementChild.getKey());\n          \n          \n            \n            \t}", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545763246", "createdAt": "2020-12-18T11:10:26Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,209 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.doc.model.ElementChild.AbstractKey;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter boolean isDeprecated = false;\n+\n+\t// Represents the Java superclass.\n+\tprivate @Getter FrankElement parent;\n+\n+\tprivate Map<Class<? extends ElementChild>, LinkedHashMap<? extends AbstractKey, ? extends ElementChild>> allChildren;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n+\t\tisDeprecated = clazz.getAnnotation(Deprecated.class) != null;\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.allChildren = new HashMap<>();\n+\t\tthis.allChildren.put(FrankAttribute.class, new LinkedHashMap<>());\n+\t\tthis.allChildren.put(ConfigChild.class, new LinkedHashMap<>());\n+\t}\n+\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tsetChildrenOfKind(inputAttributes, FrankAttribute.class);\n+\t}\n+\n+\tprivate <C extends ElementChild> void setChildrenOfKind(List<C> inputChildren, Class<C> kind) {\n+\t\tLinkedHashMap<AbstractKey, C> children = new LinkedHashMap<>();\n+\t\tfor(C c: inputChildren) {\n+\t\t\tif(children.containsKey(c.getKey())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes / config children with key [%s]\",\n+\t\t\t\t\t\tfullName, c.getKey().toString()));\n+\t\t\t} else {\n+\t\t\t\tchildren.put(c.getKey(), c);\n+\t\t\t}\n+\t\t}\n+\t\tallChildren.put(kind, children);\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<ElementChild> filter) {\n+\t\treturn getChildrenOfKind(filter, FrankAttribute.class);\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic <T extends ElementChild> List<T> getChildrenOfKind(\n+\t\t\tPredicate<ElementChild> selector, Class<T> kind) {\n+\t\tMap<? extends AbstractKey, ? extends ElementChild> lookup = allChildren.get(kind);\n+\t\treturn lookup.values().stream().filter(selector).map(c -> (T) c).collect(Collectors.toList());\n+\t}\n+\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tsetChildrenOfKind(children, ConfigChild.class);\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<ElementChild> filter) {\n+\t\treturn getChildrenOfKind(filter, ConfigChild.class);\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild, Class<? extends ElementChild> kind) {\n+\t\tMap<? extends AbstractKey, ? extends ElementChild> lookup = allChildren.get(kind);\n+\t\treturn lookup.get(elementChild.getKey());\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQyMTQ2MA==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551421460", "createdAt": "2021-01-04T16:25:22Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankElement.java", "diffHunk": "@@ -1,27 +1,209 @@\n+/* \n+Copyright 2020 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n-import lombok.Setter;\n+import nl.nn.adapterframework.doc.Utils;\n+import nl.nn.adapterframework.doc.model.ElementChild.AbstractKey;\n+import nl.nn.adapterframework.util.LogUtil;\n \n public class FrankElement {\n+\tprivate static Logger log = LogUtil.getLogger(FrankElement.class);\n+\n \tprivate final @Getter String fullName;\n \tprivate final @Getter String simpleName;\n-\tprivate @Getter @Setter FrankElement parent;\n-\tprivate @Getter @Setter List<FrankAttribute> attributes;\n-\tprivate @Getter @Setter List<ConfigChild> configChildren;\n+\tprivate final @Getter boolean isAbstract;\n+\tprivate @Getter boolean isDeprecated = false;\n+\n+\t// Represents the Java superclass.\n+\tprivate @Getter FrankElement parent;\n+\n+\tprivate Map<Class<? extends ElementChild>, LinkedHashMap<? extends AbstractKey, ? extends ElementChild>> allChildren;\n+\tprivate @Getter FrankElementStatistics statistics;\n \n \tFrankElement(Class<?> clazz) {\n-\t\tthis(clazz.getName(), clazz.getSimpleName());\n+\t\tthis(clazz.getName(), clazz.getSimpleName(), Modifier.isAbstract(clazz.getModifiers()));\n+\t\tisDeprecated = clazz.getAnnotation(Deprecated.class) != null;\n \t}\n \n \t/**\n \t * Constructor for testing purposes. We want to test attribute construction in isolation,\n \t * in which case we do not have a parent.\n+\t * TODO: Reorganize files such that this test constructor need not be public.\n \t */\n-\tFrankElement(final String fullName, final String simpleName) {\n+\tpublic FrankElement(final String fullName, final String simpleName, boolean isAbstract) {\n \t\tthis.fullName = fullName;\n \t\tthis.simpleName = simpleName;\n+\t\tthis.isAbstract = isAbstract;\n+\t\tthis.allChildren = new HashMap<>();\n+\t\tthis.allChildren.put(FrankAttribute.class, new LinkedHashMap<>());\n+\t\tthis.allChildren.put(ConfigChild.class, new LinkedHashMap<>());\n+\t}\n+\n+\tpublic void setParent(FrankElement parent) {\n+\t\tthis.parent = parent;\n+\t\tthis.statistics = new FrankElementStatistics(this);\n+\t}\n+\n+\tpublic void setAttributes(List<FrankAttribute> inputAttributes) {\n+\t\tsetChildrenOfKind(inputAttributes, FrankAttribute.class);\n+\t}\n+\n+\tprivate <C extends ElementChild> void setChildrenOfKind(List<C> inputChildren, Class<C> kind) {\n+\t\tLinkedHashMap<AbstractKey, C> children = new LinkedHashMap<>();\n+\t\tfor(C c: inputChildren) {\n+\t\t\tif(children.containsKey(c.getKey())) {\n+\t\t\t\tlog.warn(String.format(\"Frank element [%s] has multiple attributes / config children with key [%s]\",\n+\t\t\t\t\t\tfullName, c.getKey().toString()));\n+\t\t\t} else {\n+\t\t\t\tchildren.put(c.getKey(), c);\n+\t\t\t}\n+\t\t}\n+\t\tallChildren.put(kind, children);\n+\t}\n+\n+\tpublic List<FrankAttribute> getAttributes(Predicate<ElementChild> filter) {\n+\t\treturn getChildrenOfKind(filter, FrankAttribute.class);\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic <T extends ElementChild> List<T> getChildrenOfKind(\n+\t\t\tPredicate<ElementChild> selector, Class<T> kind) {\n+\t\tMap<? extends AbstractKey, ? extends ElementChild> lookup = allChildren.get(kind);\n+\t\treturn lookup.values().stream().filter(selector).map(c -> (T) c).collect(Collectors.toList());\n+\t}\n+\n+\tpublic void setConfigChildren(List<ConfigChild> children) {\n+\t\tsetChildrenOfKind(children, ConfigChild.class);\n+\t}\n+\n+\tpublic List<ConfigChild> getConfigChildren(Predicate<ElementChild> filter) {\n+\t\treturn getChildrenOfKind(filter, ConfigChild.class);\n+\t}\n+\n+\tElementChild findElementChildMatch(ElementChild elementChild, Class<? extends ElementChild> kind) {\n+\t\tMap<? extends AbstractKey, ? extends ElementChild> lookup = allChildren.get(kind);\n+\t\treturn lookup.get(elementChild.getKey());\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2MzI0Ng=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDM1MDM0OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/nl/nn/adapterframework/doc/DocWriterNewExamplesTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyMTo0NlrOIIfFWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxMDo1NDoxNlrOIOSwFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2ODc5NA==", "bodyText": "Gelieve hier nl.nn.adapterframework.testutil.TestFileUtils voor gebruiken, dan hebben wij 1 uniforme manier om testbestanden op te halen.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545768794", "createdAt": "2020-12-18T11:21:46Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/DocWriterNewExamplesTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import nl.nn.adapterframework.core.Resource;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.util.Misc;\n+\n+@RunWith(Parameterized.class)\n+public class DocWriterNewExamplesTest {\n+\t@Parameters(name = \"{1}\")\n+\tpublic static Collection<Object[]> data() {\n+\t\treturn Arrays.asList(new Object[][] {\n+\t\t\t{\"examples-simple-digester-rules.xml\", \"nl.nn.adapterframework.doc.testtarget.examples.simple.Start\", \"simple.xsd\"}\n+\t\t});\n+\t}\n+\n+\t@Parameter(0)\n+\tpublic String digesterRulesFileName;\n+\n+\t@Parameter(1)\n+\tpublic String startClassName;\n+\n+\t@Parameter(2)\n+\tpublic String expectedXsdFileName;\n+\n+\t@Test\n+\tpublic void testXsd() throws Exception {\n+\t\tFrankDocModel model = createModel();\n+\t\tDocWriterNew docWriter = new DocWriterNew(model);\n+\t\tdocWriter.init(startClassName);\n+\t\tString actualXsd = docWriter.getSchema();\n+\t\tSystem.out.println(actualXsd);\n+\t\tString expectedXsd = getExpectedXsd();\n+\t\tassertEquals(expectedXsd.replace(\"\\r\\n\", \"\\n\"), actualXsd.replace(\"\\r\\n\", \"\\n\"));\n+\t}\n+\n+\tprivate FrankDocModel createModel() throws Exception {\n+\t\treturn FrankDocModel.populate(\n+\t\t\t\tgetDigesterRulesPath(digesterRulesFileName), startClassName);\n+\t}\n+\n+\tprivate String getDigesterRulesPath(String fileName) {\n+\t\treturn \"doc/\" + fileName;\n+\t}\n+\n+\tprivate String getExpectedXsd() throws Exception {\n+\t\tString fileName = \"doc/examplesExpected/\" + expectedXsdFileName;\n+\t\tResource resource = Resource.getResource(fileName);\n+\t\tInputStream is = resource.openStream();\n+\t\tReader reader = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));\n+\t\treturn Misc.readerToString(reader, \"\\n\", false);\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQyOTYyOQ==", "bodyText": "In dit citaat staat geen assert. Moet hier iets veranderen?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551429629", "createdAt": "2021-01-04T16:38:24Z", "author": {"login": "mhdirkse"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/DocWriterNewExamplesTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import nl.nn.adapterframework.core.Resource;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.util.Misc;\n+\n+@RunWith(Parameterized.class)\n+public class DocWriterNewExamplesTest {\n+\t@Parameters(name = \"{1}\")\n+\tpublic static Collection<Object[]> data() {\n+\t\treturn Arrays.asList(new Object[][] {\n+\t\t\t{\"examples-simple-digester-rules.xml\", \"nl.nn.adapterframework.doc.testtarget.examples.simple.Start\", \"simple.xsd\"}\n+\t\t});\n+\t}\n+\n+\t@Parameter(0)\n+\tpublic String digesterRulesFileName;\n+\n+\t@Parameter(1)\n+\tpublic String startClassName;\n+\n+\t@Parameter(2)\n+\tpublic String expectedXsdFileName;\n+\n+\t@Test\n+\tpublic void testXsd() throws Exception {\n+\t\tFrankDocModel model = createModel();\n+\t\tDocWriterNew docWriter = new DocWriterNew(model);\n+\t\tdocWriter.init(startClassName);\n+\t\tString actualXsd = docWriter.getSchema();\n+\t\tSystem.out.println(actualXsd);\n+\t\tString expectedXsd = getExpectedXsd();\n+\t\tassertEquals(expectedXsd.replace(\"\\r\\n\", \"\\n\"), actualXsd.replace(\"\\r\\n\", \"\\n\"));\n+\t}\n+\n+\tprivate FrankDocModel createModel() throws Exception {\n+\t\treturn FrankDocModel.populate(\n+\t\t\t\tgetDigesterRulesPath(digesterRulesFileName), startClassName);\n+\t}\n+\n+\tprivate String getDigesterRulesPath(String fileName) {\n+\t\treturn \"doc/\" + fileName;\n+\t}\n+\n+\tprivate String getExpectedXsd() throws Exception {\n+\t\tString fileName = \"doc/examplesExpected/\" + expectedXsdFileName;\n+\t\tResource resource = Resource.getResource(fileName);\n+\t\tInputStream is = resource.openStream();\n+\t\tReader reader = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));\n+\t\treturn Misc.readerToString(reader, \"\\n\", false);\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2ODc5NA=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTgyNjE0Mw==", "bodyText": "het gaat hier om nl.nn.adapterframework.testutil.TestFileUtils.getTestFile()", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551826143", "createdAt": "2021-01-05T09:53:14Z", "author": {"login": "gvanbrakel"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/DocWriterNewExamplesTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import nl.nn.adapterframework.core.Resource;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.util.Misc;\n+\n+@RunWith(Parameterized.class)\n+public class DocWriterNewExamplesTest {\n+\t@Parameters(name = \"{1}\")\n+\tpublic static Collection<Object[]> data() {\n+\t\treturn Arrays.asList(new Object[][] {\n+\t\t\t{\"examples-simple-digester-rules.xml\", \"nl.nn.adapterframework.doc.testtarget.examples.simple.Start\", \"simple.xsd\"}\n+\t\t});\n+\t}\n+\n+\t@Parameter(0)\n+\tpublic String digesterRulesFileName;\n+\n+\t@Parameter(1)\n+\tpublic String startClassName;\n+\n+\t@Parameter(2)\n+\tpublic String expectedXsdFileName;\n+\n+\t@Test\n+\tpublic void testXsd() throws Exception {\n+\t\tFrankDocModel model = createModel();\n+\t\tDocWriterNew docWriter = new DocWriterNew(model);\n+\t\tdocWriter.init(startClassName);\n+\t\tString actualXsd = docWriter.getSchema();\n+\t\tSystem.out.println(actualXsd);\n+\t\tString expectedXsd = getExpectedXsd();\n+\t\tassertEquals(expectedXsd.replace(\"\\r\\n\", \"\\n\"), actualXsd.replace(\"\\r\\n\", \"\\n\"));\n+\t}\n+\n+\tprivate FrankDocModel createModel() throws Exception {\n+\t\treturn FrankDocModel.populate(\n+\t\t\t\tgetDigesterRulesPath(digesterRulesFileName), startClassName);\n+\t}\n+\n+\tprivate String getDigesterRulesPath(String fileName) {\n+\t\treturn \"doc/\" + fileName;\n+\t}\n+\n+\tprivate String getExpectedXsd() throws Exception {\n+\t\tString fileName = \"doc/examplesExpected/\" + expectedXsdFileName;\n+\t\tResource resource = Resource.getResource(fileName);\n+\t\tInputStream is = resource.openStream();\n+\t\tReader reader = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));\n+\t\treturn Misc.readerToString(reader, \"\\n\", false);\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2ODc5NA=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg1ODE5OQ==", "bodyText": "Gerrit heeft verteld dat deze code vervangen kan worden door de bestaande method TestFileUtils.getTestFile(). Dit heb ik gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551858199", "createdAt": "2021-01-05T10:54:16Z", "author": {"login": "mhdirkse"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/DocWriterNewExamplesTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import nl.nn.adapterframework.core.Resource;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.util.Misc;\n+\n+@RunWith(Parameterized.class)\n+public class DocWriterNewExamplesTest {\n+\t@Parameters(name = \"{1}\")\n+\tpublic static Collection<Object[]> data() {\n+\t\treturn Arrays.asList(new Object[][] {\n+\t\t\t{\"examples-simple-digester-rules.xml\", \"nl.nn.adapterframework.doc.testtarget.examples.simple.Start\", \"simple.xsd\"}\n+\t\t});\n+\t}\n+\n+\t@Parameter(0)\n+\tpublic String digesterRulesFileName;\n+\n+\t@Parameter(1)\n+\tpublic String startClassName;\n+\n+\t@Parameter(2)\n+\tpublic String expectedXsdFileName;\n+\n+\t@Test\n+\tpublic void testXsd() throws Exception {\n+\t\tFrankDocModel model = createModel();\n+\t\tDocWriterNew docWriter = new DocWriterNew(model);\n+\t\tdocWriter.init(startClassName);\n+\t\tString actualXsd = docWriter.getSchema();\n+\t\tSystem.out.println(actualXsd);\n+\t\tString expectedXsd = getExpectedXsd();\n+\t\tassertEquals(expectedXsd.replace(\"\\r\\n\", \"\\n\"), actualXsd.replace(\"\\r\\n\", \"\\n\"));\n+\t}\n+\n+\tprivate FrankDocModel createModel() throws Exception {\n+\t\treturn FrankDocModel.populate(\n+\t\t\t\tgetDigesterRulesPath(digesterRulesFileName), startClassName);\n+\t}\n+\n+\tprivate String getDigesterRulesPath(String fileName) {\n+\t\treturn \"doc/\" + fileName;\n+\t}\n+\n+\tprivate String getExpectedXsd() throws Exception {\n+\t\tString fileName = \"doc/examplesExpected/\" + expectedXsdFileName;\n+\t\tResource resource = Resource.getResource(fileName);\n+\t\tInputStream is = resource.openStream();\n+\t\tReader reader = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));\n+\t\treturn Misc.readerToString(reader, \"\\n\", false);\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2ODc5NA=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDM1MzE4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/nl/nn/adapterframework/doc/DocWriterNewExamplesTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyMjo0OFrOIIfHJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjozNToyNFrOIN4etg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2OTI1Mg==", "bodyText": "Gelieve hier nl.nn.adapterframework.testutil.TestAssertions voor gebruiken, dan hebben wij 1 uniforme manier om testbestanden cr/lf insensitive te vergelijken.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545769252", "createdAt": "2020-12-18T11:22:48Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/DocWriterNewExamplesTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import nl.nn.adapterframework.core.Resource;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.util.Misc;\n+\n+@RunWith(Parameterized.class)\n+public class DocWriterNewExamplesTest {\n+\t@Parameters(name = \"{1}\")\n+\tpublic static Collection<Object[]> data() {\n+\t\treturn Arrays.asList(new Object[][] {\n+\t\t\t{\"examples-simple-digester-rules.xml\", \"nl.nn.adapterframework.doc.testtarget.examples.simple.Start\", \"simple.xsd\"}\n+\t\t});\n+\t}\n+\n+\t@Parameter(0)\n+\tpublic String digesterRulesFileName;\n+\n+\t@Parameter(1)\n+\tpublic String startClassName;\n+\n+\t@Parameter(2)\n+\tpublic String expectedXsdFileName;\n+\n+\t@Test\n+\tpublic void testXsd() throws Exception {\n+\t\tFrankDocModel model = createModel();\n+\t\tDocWriterNew docWriter = new DocWriterNew(model);\n+\t\tdocWriter.init(startClassName);\n+\t\tString actualXsd = docWriter.getSchema();\n+\t\tSystem.out.println(actualXsd);\n+\t\tString expectedXsd = getExpectedXsd();\n+\t\tassertEquals(expectedXsd.replace(\"\\r\\n\", \"\\n\"), actualXsd.replace(\"\\r\\n\", \"\\n\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQyNzc2Ng==", "bodyText": "Gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551427766", "createdAt": "2021-01-04T16:35:24Z", "author": {"login": "mhdirkse"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/DocWriterNewExamplesTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package nl.nn.adapterframework.doc;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import nl.nn.adapterframework.core.Resource;\n+import nl.nn.adapterframework.doc.model.FrankDocModel;\n+import nl.nn.adapterframework.util.Misc;\n+\n+@RunWith(Parameterized.class)\n+public class DocWriterNewExamplesTest {\n+\t@Parameters(name = \"{1}\")\n+\tpublic static Collection<Object[]> data() {\n+\t\treturn Arrays.asList(new Object[][] {\n+\t\t\t{\"examples-simple-digester-rules.xml\", \"nl.nn.adapterframework.doc.testtarget.examples.simple.Start\", \"simple.xsd\"}\n+\t\t});\n+\t}\n+\n+\t@Parameter(0)\n+\tpublic String digesterRulesFileName;\n+\n+\t@Parameter(1)\n+\tpublic String startClassName;\n+\n+\t@Parameter(2)\n+\tpublic String expectedXsdFileName;\n+\n+\t@Test\n+\tpublic void testXsd() throws Exception {\n+\t\tFrankDocModel model = createModel();\n+\t\tDocWriterNew docWriter = new DocWriterNew(model);\n+\t\tdocWriter.init(startClassName);\n+\t\tString actualXsd = docWriter.getSchema();\n+\t\tSystem.out.println(actualXsd);\n+\t\tString expectedXsd = getExpectedXsd();\n+\t\tassertEquals(expectedXsd.replace(\"\\r\\n\", \"\\n\"), actualXsd.replace(\"\\r\\n\", \"\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2OTI1Mg=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDM1ODAwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/nl/nn/adapterframework/doc/model/AncestorKindsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyNDoxM1rOIIfKAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjo1NTo1M1rOIN5Qig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2OTk4NQ==", "bodyText": "Kan elke assertion statement hier ook op 1 regel?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545769985", "createdAt": "2020-12-18T11:24:13Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/AncestorKindsTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Class {@link FrankElement} has many different method to get children\n+ * and to search ancestors that have children. The tests in this class\n+ * are to test all these methods.\n+ * @author martijn\n+ *\n+ */\n+public class AncestorKindsTest {\n+\tprivate static final String PACKAGE = \"nl.nn.adapterframework.doc.testtarget.sparse.\";\n+\n+\tprivate FrankDocModel model;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tmodel = FrankDocModel.populate(\"doc/sparse-digester-rules.xml\", PACKAGE + \"ContainerChild\");\n+\t}\n+\n+\t@Test\n+\tpublic void testConfigChildrenOfPackageSparse() {\n+\t\tConfigChild child = model.findFrankElement(PACKAGE + \"ContainerChild\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerNoAncestorBecauseChildrenDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedConfigChildren\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeChild\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeNoAncestorBecauseAttributesDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedAttributes\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t}\n+\n+\t@Test\n+\tpublic void testAttributesOfPackageSparse() {\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"ContainerChild\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0MDUyMg==", "bodyText": "Gedaan. Ik heb alle test code beter geformat.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551440522", "createdAt": "2021-01-04T16:55:53Z", "author": {"login": "mhdirkse"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/AncestorKindsTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Class {@link FrankElement} has many different method to get children\n+ * and to search ancestors that have children. The tests in this class\n+ * are to test all these methods.\n+ * @author martijn\n+ *\n+ */\n+public class AncestorKindsTest {\n+\tprivate static final String PACKAGE = \"nl.nn.adapterframework.doc.testtarget.sparse.\";\n+\n+\tprivate FrankDocModel model;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tmodel = FrankDocModel.populate(\"doc/sparse-digester-rules.xml\", PACKAGE + \"ContainerChild\");\n+\t}\n+\n+\t@Test\n+\tpublic void testConfigChildrenOfPackageSparse() {\n+\t\tConfigChild child = model.findFrankElement(PACKAGE + \"ContainerChild\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerNoAncestorBecauseChildrenDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedConfigChildren\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeChild\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeNoAncestorBecauseAttributesDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedAttributes\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t}\n+\n+\t@Test\n+\tpublic void testAttributesOfPackageSparse() {\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"ContainerChild\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc2OTk4NQ=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDM2MDc5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/nl/nn/adapterframework/doc/model/AncestorKindsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyNTowMlrOIIfLnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjo1NjoyN1rOIN5R_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MDM5Ng==", "bodyText": "Probeer statements zo veel mogelijk op 1 regel te plaatsen. Dat is veel leesbaarder!", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545770396", "createdAt": "2020-12-18T11:25:02Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/AncestorKindsTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Class {@link FrankElement} has many different method to get children\n+ * and to search ancestors that have children. The tests in this class\n+ * are to test all these methods.\n+ * @author martijn\n+ *\n+ */\n+public class AncestorKindsTest {\n+\tprivate static final String PACKAGE = \"nl.nn.adapterframework.doc.testtarget.sparse.\";\n+\n+\tprivate FrankDocModel model;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tmodel = FrankDocModel.populate(\"doc/sparse-digester-rules.xml\", PACKAGE + \"ContainerChild\");\n+\t}\n+\n+\t@Test\n+\tpublic void testConfigChildrenOfPackageSparse() {\n+\t\tConfigChild child = model.findFrankElement(PACKAGE + \"ContainerChild\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerNoAncestorBecauseChildrenDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedConfigChildren\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeChild\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeNoAncestorBecauseAttributesDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedAttributes\")\n+\t\t\t\t.getConfigChildren(ALL).size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0MDg5Mw==", "bodyText": "Gedaan. Is het nu goed?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551440893", "createdAt": "2021-01-04T16:56:27Z", "author": {"login": "mhdirkse"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/AncestorKindsTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package nl.nn.adapterframework.doc.model;\n+\n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+import static nl.nn.adapterframework.doc.model.ElementChild.IN_XSD;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Class {@link FrankElement} has many different method to get children\n+ * and to search ancestors that have children. The tests in this class\n+ * are to test all these methods.\n+ * @author martijn\n+ *\n+ */\n+public class AncestorKindsTest {\n+\tprivate static final String PACKAGE = \"nl.nn.adapterframework.doc.testtarget.sparse.\";\n+\n+\tprivate FrankDocModel model;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tmodel = FrankDocModel.populate(\"doc/sparse-digester-rules.xml\", PACKAGE + \"ContainerChild\");\n+\t}\n+\n+\t@Test\n+\tpublic void testConfigChildrenOfPackageSparse() {\n+\t\tConfigChild child = model.findFrankElement(PACKAGE + \"ContainerChild\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerNoAncestorBecauseChildrenDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"ContainerAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertFalse(child.isDeprecated());\n+\t\tchild = model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedConfigChildren\")\n+\t\t\t\t.getConfigChildren(ALL).get(0);\n+\t\tassertTrue(child.isDeprecated());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeChild\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeNoAncestorBecauseAttributesDeprecated\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"AttributeAncestor\")\n+\t\t\t\t.getConfigChildren(ALL).size());\n+\t\tassertEquals(0, model.findFrankElement(PACKAGE + \"GrandParentWithDeprecatedAttributes\")\n+\t\t\t\t.getConfigChildren(ALL).size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MDM5Ng=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDM2OTQzOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/nl/nn/adapterframework/doc/model/FrankDocModelConfigChildrenTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMToyNzo0OVrOIIfQog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDoyMzowOVrOIRPNGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MTY4Mg==", "bodyText": "Hier ook graag elk statement op 1 regel.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545771682", "createdAt": "2020-12-18T11:27:49Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/FrankDocModelConfigChildrenTest.java", "diffHunk": "@@ -16,28 +20,42 @@\n \n public class FrankDocModelConfigChildrenTest {\n \tprivate static String CONTAINER = \"nl.nn.adapterframework.doc.testtarget.children.Container\";\n-\n+\tprivate static String CONTAINER_DERIVED = \"nl.nn.adapterframework.doc.testtarget.children.ContainerDerived\";\n+\tprivate static String CONTAINER_OTHER = \"nl.nn.adapterframework.doc.testtarget.children.ContainerOther\";\n+\t\n \tprivate FrankDocModel instance;\n \tprivate List<ConfigChild> configChildren;\n+\tprivate List<ConfigChild> configChildrenOfDerived;\n \n \t@Before\n \tpublic void setUp() throws SAXException, IOException, ReflectiveOperationException {\n \t\tinstance = new FrankDocModel();\n \t\tinstance.createConfigChildDescriptorsFrom(\"doc/simple-digester-rules.xml\");\n \t\tinstance.findOrCreateElementType(\n \t\t\t\tUtils.getClass(CONTAINER));\n-\t\tconfigChildren = instance.getAllElements().get(CONTAINER).getConfigChildren();\n+\t\tinstance.findOrCreateElementType(\n+\t\t\t\tUtils.getClass(CONTAINER_DERIVED));\n+\t\tinstance.findOrCreateElementType(\n+\t\t\t\tUtils.getClass(CONTAINER_OTHER));\n+\t\tinstance.setOverriddenFrom();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0MTc0Mw==", "bodyText": "Gedaan. Mogen de stream stappen wel ieder op hun eigen regel?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551441743", "createdAt": "2021-01-04T16:57:43Z", "author": {"login": "mhdirkse"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/FrankDocModelConfigChildrenTest.java", "diffHunk": "@@ -16,28 +20,42 @@\n \n public class FrankDocModelConfigChildrenTest {\n \tprivate static String CONTAINER = \"nl.nn.adapterframework.doc.testtarget.children.Container\";\n-\n+\tprivate static String CONTAINER_DERIVED = \"nl.nn.adapterframework.doc.testtarget.children.ContainerDerived\";\n+\tprivate static String CONTAINER_OTHER = \"nl.nn.adapterframework.doc.testtarget.children.ContainerOther\";\n+\t\n \tprivate FrankDocModel instance;\n \tprivate List<ConfigChild> configChildren;\n+\tprivate List<ConfigChild> configChildrenOfDerived;\n \n \t@Before\n \tpublic void setUp() throws SAXException, IOException, ReflectiveOperationException {\n \t\tinstance = new FrankDocModel();\n \t\tinstance.createConfigChildDescriptorsFrom(\"doc/simple-digester-rules.xml\");\n \t\tinstance.findOrCreateElementType(\n \t\t\t\tUtils.getClass(CONTAINER));\n-\t\tconfigChildren = instance.getAllElements().get(CONTAINER).getConfigChildren();\n+\t\tinstance.findOrCreateElementType(\n+\t\t\t\tUtils.getClass(CONTAINER_DERIVED));\n+\t\tinstance.findOrCreateElementType(\n+\t\t\t\tUtils.getClass(CONTAINER_OTHER));\n+\t\tinstance.setOverriddenFrom();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MTY4Mg=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk0NTgxOQ==", "bodyText": "Het ziet er zo goed uit!", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554945819", "createdAt": "2021-01-11T10:23:09Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/model/FrankDocModelConfigChildrenTest.java", "diffHunk": "@@ -16,28 +20,42 @@\n \n public class FrankDocModelConfigChildrenTest {\n \tprivate static String CONTAINER = \"nl.nn.adapterframework.doc.testtarget.children.Container\";\n-\n+\tprivate static String CONTAINER_DERIVED = \"nl.nn.adapterframework.doc.testtarget.children.ContainerDerived\";\n+\tprivate static String CONTAINER_OTHER = \"nl.nn.adapterframework.doc.testtarget.children.ContainerOther\";\n+\t\n \tprivate FrankDocModel instance;\n \tprivate List<ConfigChild> configChildren;\n+\tprivate List<ConfigChild> configChildrenOfDerived;\n \n \t@Before\n \tpublic void setUp() throws SAXException, IOException, ReflectiveOperationException {\n \t\tinstance = new FrankDocModel();\n \t\tinstance.createConfigChildDescriptorsFrom(\"doc/simple-digester-rules.xml\");\n \t\tinstance.findOrCreateElementType(\n \t\t\t\tUtils.getClass(CONTAINER));\n-\t\tconfigChildren = instance.getAllElements().get(CONTAINER).getConfigChildren();\n+\t\tinstance.findOrCreateElementType(\n+\t\t\t\tUtils.getClass(CONTAINER_DERIVED));\n+\t\tinstance.findOrCreateElementType(\n+\t\t\t\tUtils.getClass(CONTAINER_OTHER));\n+\t\tinstance.setOverriddenFrom();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MTY4Mg=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDM4MTQ0OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/nl/nn/adapterframework/doc/testtarget/examples/simple/AbstractParentOfStart.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMTozMTo1NFrOIIfX6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjo1Nzo1OFrOIN5V4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MzU0NQ==", "bodyText": "Fijn dat je commentaar toevoegt!", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r545773545", "createdAt": "2020-12-18T11:31:54Z", "author": {"login": "nielsm5"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/testtarget/examples/simple/AbstractParentOfStart.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package nl.nn.adapterframework.doc.testtarget.examples.simple;\n+\n+//Should not appear as element in the XSD because it is abstract.\n+//Should appear as attribute group because it has an attribute", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0MTg4OA==", "bodyText": "Graag gedaan.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r551441888", "createdAt": "2021-01-04T16:57:58Z", "author": {"login": "mhdirkse"}, "path": "core/src/test/java/nl/nn/adapterframework/doc/testtarget/examples/simple/AbstractParentOfStart.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package nl.nn.adapterframework.doc.testtarget.examples.simple;\n+\n+//Should not appear as element in the XSD because it is abstract.\n+//Should appear as attribute group because it has an attribute", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MzU0NQ=="}, "originalCommit": {"oid": "6e0745df244d5e86d13e504f6f73ec158254ee1f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5MzQ1MDM2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo1NjoyN1rOIRORYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNjoxNTowN1rOIRcsIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMDUyOA==", "bodyText": "Vergeet niet je HTML tags te sluiten!", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554930528", "createdAt": "2021-01-11T09:56:27Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk3MTA1MA==", "bodyText": "Gedaan. Ik heb op <ul> en <ol> gezocht om te zien of dit probleem ook elders speelt. Ik heb dit probleem nergens anders gevonden.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554971050", "createdAt": "2021-01-11T11:07:02Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMDUyOA=="}, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAwMTA5NA==", "bodyText": "De li's moeten ook nog gesloten worden", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r555001094", "createdAt": "2021-01-11T12:05:55Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMDUyOA=="}, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE2Njc1Mg==", "bodyText": "Ik heb een pagina gevonden waar staat dat dat niet hoeft. Zie https://stackoverflow.com/questions/33787753/javadoc-closing-tags", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r555166752", "createdAt": "2021-01-11T16:15:07Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementChild.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n+package nl.nn.adapterframework.doc.model;\n+\n+import java.util.function.Predicate;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import nl.nn.adapterframework.doc.DocWriterNew;\n+import nl.nn.adapterframework.util.LogUtil;\n+\n+/**\n+ * Base class of FrankAttribute and ConfigChild. This class was introduced\n+ * to implement the following common logic:\n+ * <ul>\n+ * <li> The decision whether to include an attribute or config child in the XML schema\n+ * is based on the same information.\n+ * <li> The structure is very similar in the XML schema for config children and\n+ * attributes. In both cases, we have cumulative groups that include inherited\n+ * items and declared groups that hold only items at the present level of the\n+ * inheritance hierarchy. Please see this in action at {@link DocWriterNew}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMDUyOA=="}, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5MzQ2ODY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDowMToxM1rOIROcdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMjowNzoyOVrOIRSoNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMzM2Nw==", "bodyText": "Geeft getFullName() altijd de juiste waarde terug voor candidates.get(0) ?\nMoet dit niet result.getFullName() zijn?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554933367", "createdAt": "2021-01-11T10:01:13Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "diffHunk": "@@ -1,24 +1,149 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n+import nl.nn.adapterframework.util.LogUtil;\n \n+/**\n+ * Models a collection of FrankElement. The collection can be characterized by\n+ * a Java interface in the FF! sources, or there can be one member that is referenced\n+ * by its FrankElement. FrankElement objects that model an abstract Java class should\n+ * be omitted as members. This is done automatically when Spring is used to get the\n+ * implementing classes of a modeled Java interface.\n+ *\n+ * @author martijn\n+ *\n+ */\n public class ElementType {\n-\tprivate @Getter String fullName;\n-\tprivate @Getter String simpleName;\n+\tprivate static Logger log = LogUtil.getLogger(ElementType.class);\n \tprivate @Getter Map<String, FrankElement> members;\n \tprivate @Getter boolean fromJavaInterface;\n+\t\n+\tprivate @Getter LinkedHashSet<ElementRole> elementRoles = new LinkedHashSet<>();\n+\n+\tprivate static class InterfaceHierarchyItem {\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter String simpleName;\n+\t\tprivate @Getter Map<String, InterfaceHierarchyItem> parentInterfaces = new TreeMap<>();\n+\n+\t\tInterfaceHierarchyItem(Class<?> clazz) {\n+\t\t\tthis.fullName = clazz.getName();\n+\t\t\tthis.simpleName = clazz.getSimpleName();\n+\t\t\tif(clazz.isInterface()) {\n+\t\t\t\tfor(Class<?> superInterface: clazz.getInterfaces()) {\n+\t\t\t\t\tInterfaceHierarchyItem superInterfaceHierarchyItem = new InterfaceHierarchyItem(superInterface);\n+\t\t\t\t\tparentInterfaces.put(superInterfaceHierarchyItem.getFullName(), superInterfaceHierarchyItem);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<ElementType> findMatchingElementTypes(FrankDocModel model) {\n+\t\t\tElementType currentMatch = model.findElementType(fullName);\n+\t\t\tif(currentMatch != null) {\n+\t\t\t\treturn Arrays.asList(currentMatch);\n+\t\t\t}\n+\t\t\tList<ElementType> result = new ArrayList<>();\n+\t\t\tfor(String parentKey: parentInterfaces.keySet()) {\n+\t\t\t\tresult.addAll(parentInterfaces.get(parentKey).findMatchingElementTypes(model));\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\t}\n+\n+\tprivate final InterfaceHierarchyItem interfaceHierarchy;\n+\tprivate @Getter ElementType highestCommonInterface;\n \n \tElementType(Class<?> clazz) {\n-\t\tfullName = clazz.getName();\n-\t\tsimpleName = clazz.getSimpleName();\n+\t\tinterfaceHierarchy = new InterfaceHierarchyItem(clazz);\n \t\tmembers = new HashMap<>();\n \t\tthis.fromJavaInterface = clazz.isInterface();\n \t}\n \n+\tpublic String getFullName() {\n+\t\treturn interfaceHierarchy.getFullName();\n+\t}\n+\n+\tpublic String getSimpleName() {\n+\t\treturn interfaceHierarchy.getSimpleName();\n+\t}\n+\n \tvoid addMember(FrankElement member) {\n \t\tmembers.put(member.getFullName(), member);\n \t}\n+\n+\tFrankElement getSingletonElement() throws ReflectiveOperationException {\n+\t\tif(members.size() != 1) {\n+\t\t\tthrow new ReflectiveOperationException(String.format(\"Expected that ElementType [%s] contains exactly one element\", getFullName()));\n+\t\t}\n+\t\treturn members.values().iterator().next();\n+\t}\n+\n+\tvoid registerElementRole(ElementRole elementRole) {\n+\t\telementRoles.add(elementRole);\n+\t}\n+\n+\tvoid calculateHighestCommonInterface(FrankDocModel model) {\n+\t\thighestCommonInterface = this;\n+\t\tElementType nextCandidate = highestCommonInterface.getNextCommonInterface(model);\n+\t\twhile(nextCandidate != null) {\n+\t\t\thighestCommonInterface = nextCandidate;\n+\t\t\tnextCandidate = highestCommonInterface.getNextCommonInterface(model);\n+\t\t}\n+\t\tif(log.isTraceEnabled()) {\n+\t\t\tlog.trace(String.format(\"ElementType [%s] has highest common interface [%s]\", this.getFullName(), highestCommonInterface.getFullName()));\n+\t\t}\n+\t}\n+\n+\tprivate ElementType getNextCommonInterface(FrankDocModel model) {\n+\t\tif(! fromJavaInterface) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<ElementType> candidates = new ArrayList<>();\n+\t\tfor(String key: interfaceHierarchy.getParentInterfaces().keySet()) {\n+\t\t\tcandidates.addAll(interfaceHierarchy.getParentInterfaces().get(key).findMatchingElementTypes(model));\n+\t\t}\n+\t\tif(candidates.isEmpty()) {\n+\t\t\treturn null;\n+\t\t} else {\n+\t\t\tElementType result = candidates.get(0);\n+\t\t\tif(candidates.size() >= 2) {\n+\t\t\t\tlog.warn(String.format(\"There are multiple candidates for the next common interface of ElementType [%s], which are [%s]. Chose [%s]\",\n+\t\t\t\t\t\tgetFullName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk1NzU3OA==", "bodyText": "Hier wordt een foutmelding in de log geschreven. In die foutmelding moet staan op welk ElementType object de getNextCommonInterface() method wordt toegepast. Dat ElementType wordt hier gerefereerd.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554957578", "createdAt": "2021-01-11T10:43:20Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "diffHunk": "@@ -1,24 +1,149 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n+import nl.nn.adapterframework.util.LogUtil;\n \n+/**\n+ * Models a collection of FrankElement. The collection can be characterized by\n+ * a Java interface in the FF! sources, or there can be one member that is referenced\n+ * by its FrankElement. FrankElement objects that model an abstract Java class should\n+ * be omitted as members. This is done automatically when Spring is used to get the\n+ * implementing classes of a modeled Java interface.\n+ *\n+ * @author martijn\n+ *\n+ */\n public class ElementType {\n-\tprivate @Getter String fullName;\n-\tprivate @Getter String simpleName;\n+\tprivate static Logger log = LogUtil.getLogger(ElementType.class);\n \tprivate @Getter Map<String, FrankElement> members;\n \tprivate @Getter boolean fromJavaInterface;\n+\t\n+\tprivate @Getter LinkedHashSet<ElementRole> elementRoles = new LinkedHashSet<>();\n+\n+\tprivate static class InterfaceHierarchyItem {\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter String simpleName;\n+\t\tprivate @Getter Map<String, InterfaceHierarchyItem> parentInterfaces = new TreeMap<>();\n+\n+\t\tInterfaceHierarchyItem(Class<?> clazz) {\n+\t\t\tthis.fullName = clazz.getName();\n+\t\t\tthis.simpleName = clazz.getSimpleName();\n+\t\t\tif(clazz.isInterface()) {\n+\t\t\t\tfor(Class<?> superInterface: clazz.getInterfaces()) {\n+\t\t\t\t\tInterfaceHierarchyItem superInterfaceHierarchyItem = new InterfaceHierarchyItem(superInterface);\n+\t\t\t\t\tparentInterfaces.put(superInterfaceHierarchyItem.getFullName(), superInterfaceHierarchyItem);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<ElementType> findMatchingElementTypes(FrankDocModel model) {\n+\t\t\tElementType currentMatch = model.findElementType(fullName);\n+\t\t\tif(currentMatch != null) {\n+\t\t\t\treturn Arrays.asList(currentMatch);\n+\t\t\t}\n+\t\t\tList<ElementType> result = new ArrayList<>();\n+\t\t\tfor(String parentKey: parentInterfaces.keySet()) {\n+\t\t\t\tresult.addAll(parentInterfaces.get(parentKey).findMatchingElementTypes(model));\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\t}\n+\n+\tprivate final InterfaceHierarchyItem interfaceHierarchy;\n+\tprivate @Getter ElementType highestCommonInterface;\n \n \tElementType(Class<?> clazz) {\n-\t\tfullName = clazz.getName();\n-\t\tsimpleName = clazz.getSimpleName();\n+\t\tinterfaceHierarchy = new InterfaceHierarchyItem(clazz);\n \t\tmembers = new HashMap<>();\n \t\tthis.fromJavaInterface = clazz.isInterface();\n \t}\n \n+\tpublic String getFullName() {\n+\t\treturn interfaceHierarchy.getFullName();\n+\t}\n+\n+\tpublic String getSimpleName() {\n+\t\treturn interfaceHierarchy.getSimpleName();\n+\t}\n+\n \tvoid addMember(FrankElement member) {\n \t\tmembers.put(member.getFullName(), member);\n \t}\n+\n+\tFrankElement getSingletonElement() throws ReflectiveOperationException {\n+\t\tif(members.size() != 1) {\n+\t\t\tthrow new ReflectiveOperationException(String.format(\"Expected that ElementType [%s] contains exactly one element\", getFullName()));\n+\t\t}\n+\t\treturn members.values().iterator().next();\n+\t}\n+\n+\tvoid registerElementRole(ElementRole elementRole) {\n+\t\telementRoles.add(elementRole);\n+\t}\n+\n+\tvoid calculateHighestCommonInterface(FrankDocModel model) {\n+\t\thighestCommonInterface = this;\n+\t\tElementType nextCandidate = highestCommonInterface.getNextCommonInterface(model);\n+\t\twhile(nextCandidate != null) {\n+\t\t\thighestCommonInterface = nextCandidate;\n+\t\t\tnextCandidate = highestCommonInterface.getNextCommonInterface(model);\n+\t\t}\n+\t\tif(log.isTraceEnabled()) {\n+\t\t\tlog.trace(String.format(\"ElementType [%s] has highest common interface [%s]\", this.getFullName(), highestCommonInterface.getFullName()));\n+\t\t}\n+\t}\n+\n+\tprivate ElementType getNextCommonInterface(FrankDocModel model) {\n+\t\tif(! fromJavaInterface) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<ElementType> candidates = new ArrayList<>();\n+\t\tfor(String key: interfaceHierarchy.getParentInterfaces().keySet()) {\n+\t\t\tcandidates.addAll(interfaceHierarchy.getParentInterfaces().get(key).findMatchingElementTypes(model));\n+\t\t}\n+\t\tif(candidates.isEmpty()) {\n+\t\t\treturn null;\n+\t\t} else {\n+\t\t\tElementType result = candidates.get(0);\n+\t\t\tif(candidates.size() >= 2) {\n+\t\t\t\tlog.warn(String.format(\"There are multiple candidates for the next common interface of ElementType [%s], which are [%s]. Chose [%s]\",\n+\t\t\t\t\t\tgetFullName(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMzM2Nw=="}, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTAwMTkwOQ==", "bodyText": "Ah, ik vroeg het mij af omdat in de log regel Chose staat... Misschien dat het duidelijke is/wordt als je er elementType [...] fullName [...] oid van maakt.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r555001909", "createdAt": "2021-01-11T12:07:29Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/ElementType.java", "diffHunk": "@@ -1,24 +1,149 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.Logger;\n \n import lombok.Getter;\n+import nl.nn.adapterframework.util.LogUtil;\n \n+/**\n+ * Models a collection of FrankElement. The collection can be characterized by\n+ * a Java interface in the FF! sources, or there can be one member that is referenced\n+ * by its FrankElement. FrankElement objects that model an abstract Java class should\n+ * be omitted as members. This is done automatically when Spring is used to get the\n+ * implementing classes of a modeled Java interface.\n+ *\n+ * @author martijn\n+ *\n+ */\n public class ElementType {\n-\tprivate @Getter String fullName;\n-\tprivate @Getter String simpleName;\n+\tprivate static Logger log = LogUtil.getLogger(ElementType.class);\n \tprivate @Getter Map<String, FrankElement> members;\n \tprivate @Getter boolean fromJavaInterface;\n+\t\n+\tprivate @Getter LinkedHashSet<ElementRole> elementRoles = new LinkedHashSet<>();\n+\n+\tprivate static class InterfaceHierarchyItem {\n+\t\tprivate @Getter String fullName;\n+\t\tprivate @Getter String simpleName;\n+\t\tprivate @Getter Map<String, InterfaceHierarchyItem> parentInterfaces = new TreeMap<>();\n+\n+\t\tInterfaceHierarchyItem(Class<?> clazz) {\n+\t\t\tthis.fullName = clazz.getName();\n+\t\t\tthis.simpleName = clazz.getSimpleName();\n+\t\t\tif(clazz.isInterface()) {\n+\t\t\t\tfor(Class<?> superInterface: clazz.getInterfaces()) {\n+\t\t\t\t\tInterfaceHierarchyItem superInterfaceHierarchyItem = new InterfaceHierarchyItem(superInterface);\n+\t\t\t\t\tparentInterfaces.put(superInterfaceHierarchyItem.getFullName(), superInterfaceHierarchyItem);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tList<ElementType> findMatchingElementTypes(FrankDocModel model) {\n+\t\t\tElementType currentMatch = model.findElementType(fullName);\n+\t\t\tif(currentMatch != null) {\n+\t\t\t\treturn Arrays.asList(currentMatch);\n+\t\t\t}\n+\t\t\tList<ElementType> result = new ArrayList<>();\n+\t\t\tfor(String parentKey: parentInterfaces.keySet()) {\n+\t\t\t\tresult.addAll(parentInterfaces.get(parentKey).findMatchingElementTypes(model));\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\t}\n+\n+\tprivate final InterfaceHierarchyItem interfaceHierarchy;\n+\tprivate @Getter ElementType highestCommonInterface;\n \n \tElementType(Class<?> clazz) {\n-\t\tfullName = clazz.getName();\n-\t\tsimpleName = clazz.getSimpleName();\n+\t\tinterfaceHierarchy = new InterfaceHierarchyItem(clazz);\n \t\tmembers = new HashMap<>();\n \t\tthis.fromJavaInterface = clazz.isInterface();\n \t}\n \n+\tpublic String getFullName() {\n+\t\treturn interfaceHierarchy.getFullName();\n+\t}\n+\n+\tpublic String getSimpleName() {\n+\t\treturn interfaceHierarchy.getSimpleName();\n+\t}\n+\n \tvoid addMember(FrankElement member) {\n \t\tmembers.put(member.getFullName(), member);\n \t}\n+\n+\tFrankElement getSingletonElement() throws ReflectiveOperationException {\n+\t\tif(members.size() != 1) {\n+\t\t\tthrow new ReflectiveOperationException(String.format(\"Expected that ElementType [%s] contains exactly one element\", getFullName()));\n+\t\t}\n+\t\treturn members.values().iterator().next();\n+\t}\n+\n+\tvoid registerElementRole(ElementRole elementRole) {\n+\t\telementRoles.add(elementRole);\n+\t}\n+\n+\tvoid calculateHighestCommonInterface(FrankDocModel model) {\n+\t\thighestCommonInterface = this;\n+\t\tElementType nextCandidate = highestCommonInterface.getNextCommonInterface(model);\n+\t\twhile(nextCandidate != null) {\n+\t\t\thighestCommonInterface = nextCandidate;\n+\t\t\tnextCandidate = highestCommonInterface.getNextCommonInterface(model);\n+\t\t}\n+\t\tif(log.isTraceEnabled()) {\n+\t\t\tlog.trace(String.format(\"ElementType [%s] has highest common interface [%s]\", this.getFullName(), highestCommonInterface.getFullName()));\n+\t\t}\n+\t}\n+\n+\tprivate ElementType getNextCommonInterface(FrankDocModel model) {\n+\t\tif(! fromJavaInterface) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<ElementType> candidates = new ArrayList<>();\n+\t\tfor(String key: interfaceHierarchy.getParentInterfaces().keySet()) {\n+\t\t\tcandidates.addAll(interfaceHierarchy.getParentInterfaces().get(key).findMatchingElementTypes(model));\n+\t\t}\n+\t\tif(candidates.isEmpty()) {\n+\t\t\treturn null;\n+\t\t} else {\n+\t\t\tElementType result = candidates.get(0);\n+\t\t\tif(candidates.size() >= 2) {\n+\t\t\t\tlog.warn(String.format(\"There are multiple candidates for the next common interface of ElementType [%s], which are [%s]. Chose [%s]\",\n+\t\t\t\t\t\tgetFullName(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzMzM2Nw=="}, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5MzQ5MjkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMDowNzo1MFrOIROq6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxMTowNzo0M1rOIRQxGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzNzA2NQ==", "bodyText": "Ik denk dat je de verkeerde Collections geselecteerd hebt?", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554937065", "createdAt": "2021-01-11T10:07:50Z", "author": {"login": "nielsm5"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -1,22 +1,45 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+\n import java.io.IOException;\n import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Set;\n import java.util.StringTokenizer;\n+import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.Logger;\n import org.springframework.core.annotation.AnnotationUtils;\n import org.xml.sax.SAXException;\n \n+import edu.emory.mathcs.backport.java.util.Collections;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDk3MTQxNw==", "bodyText": "Gefixed.", "url": "https://github.com/ibissource/iaf/pull/1239#discussion_r554971417", "createdAt": "2021-01-11T11:07:43Z", "author": {"login": "mhdirkse"}, "path": "core/src/main/java/nl/nn/adapterframework/doc/model/FrankDocModel.java", "diffHunk": "@@ -1,22 +1,45 @@\n+/* \n+Copyright 2020, 2021 WeAreFrank! \n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); \n+you may not use this file except in compliance with the License. \n+You may obtain a copy of the License at \n+\n+    http://www.apache.org/licenses/LICENSE-2.0 \n+\n+Unless required by applicable law or agreed to in writing, software \n+distributed under the License is distributed on an \"AS IS\" BASIS, \n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n+See the License for the specific language governing permissions and \n+limitations under the License. \n+*/\n+\n package nl.nn.adapterframework.doc.model;\n \n+import static nl.nn.adapterframework.doc.model.ElementChild.ALL;\n+\n import java.io.IOException;\n import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n+import java.util.Set;\n import java.util.StringTokenizer;\n+import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.Logger;\n import org.springframework.core.annotation.AnnotationUtils;\n import org.xml.sax.SAXException;\n \n+import edu.emory.mathcs.backport.java.util.Collections;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkzNzA2NQ=="}, "originalCommit": {"oid": "099e626cb07ed5c5ecafdf50909e7ad1315647da"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 623, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}