{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0ODY3NTAz", "number": 1365, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDowNTozMFrOEAv6og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjowMDo0M1rOEA8v-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjIwNTE0OnYy", "diffSide": "RIGHT", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDowNTozMFrOGcOGwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDowNTozMFrOGcOGwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDQxNg==", "bodyText": "I think we should handle a receiver IdentifierTree with name \u201cthis\u201d as well. Worth a test case if we don\u2019t already have one (review on thumbs)", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432244416", "createdAt": "2020-05-29T04:05:30Z", "author": {"login": "carterkozak"}, "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        if (!root.getParameters().isEmpty()) {\n+            Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n+            Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n+            if (!paramSymbol.equals(receiverSymbol)) {\n+                return Description.NO_MATCH;\n+            }\n+        }\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = receiver == null;\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {\n             return Description.NO_MATCH;\n         }\n \n         return buildDescription(root)\n                 .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state))\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n                 .build();\n     }\n \n-    private static boolean shouldIgnore(\n-            Symbol.MethodSymbol methodSymbol, LambdaExpressionTree root, MethodInvocationTree methodInvocation) {\n-        if (!methodSymbol.isStatic()) {\n-            if (root.getParameters().size() == 1) {\n-                Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n-                Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n-                return !paramSymbol.equals(receiverSymbol);\n-            }\n-            return true;\n+    private Description convertMethodInvocations(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        List<Symbol> methodParams = getSymbols(methodInvocation.getArguments());\n+        List<Symbol> lambdaParam = getSymbols(root.getParameters());\n+\n+        // We are guaranteed that all of root params are symbols so equality should handle cases where methodInvocation\n+        // arguments are not symbols or are out of order\n+        if (!methodParams.equals(lambdaParam)) {\n+            return Description.NO_MATCH;\n         }\n-        return !root.getParameters().isEmpty();\n+\n+        boolean isLocal = ASTHelpers.getReceiver(methodInvocation) == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjIwNjkyOnYy", "diffSide": "RIGHT", "path": "baseline-error-prone/src/test/java/com/palantir/baseline/errorprone/LambdaMethodReferenceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDowNzowNlrOGcOH7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDowNzowNlrOGcOH7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDcxNg==", "bodyText": "Not sure these negative tests are necessary when we have refactoring tests as well.", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432244716", "createdAt": "2020-05-29T04:07:06Z", "author": {"login": "carterkozak"}, "path": "baseline-error-prone/src/test/java/com/palantir/baseline/errorprone/LambdaMethodReferenceTest.java", "diffHunk": "@@ -67,7 +68,83 @@ void testFunction() {\n     }\n \n     @Test\n-    public void testPositive_block() {\n+    void testLocalInstanceMethod() {\n+        compilationHelper\n+                .addSourceLines(\n+                        \"Test.java\",\n+                        \"import \" + Optional.class.getName() + ';',\n+                        \"class Test {\",\n+                        \"  public Optional<Integer> foo(Optional<String> optional) {\",\n+                        \"    // BUG: Diagnostic contains: Lambda should be a method reference\",\n+                        \"    return optional.map(v -> bar(v));\",\n+                        \"  }\",\n+                        \"  private Integer bar(String value) {\",\n+                        \"    return value.length();\",\n+                        \"  }\",\n+                        \"}\")\n+                .doTest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjIxMzg5OnYy", "diffSide": "RIGHT", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoxMjoxN1rOGcOMLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoxMjoxN1rOGcOMLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NTgwNA==", "bodyText": "Can we remove the supplier case here in favor of the zero-length method invocation code path?", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432245804", "createdAt": "2020-05-29T04:12:17Z", "author": {"login": "carterkozak"}, "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjI0MTQzOnYy", "diffSide": "RIGHT", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDozMToyMVrOGcOcfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDozMToyMVrOGcOcfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0OTk4Mg==", "bodyText": "I think there might be some oddness if the method is. It provided by this, but an enclosing class, requiring prefix \u201cEnclosing.this.\u201c. Worth a test to verify, I\u2019d probably exclude that from the check rather than attempt to refactor since it\u2019s fairly uncommon.", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432249982", "createdAt": "2020-05-29T04:31:21Z", "author": {"login": "carterkozak"}, "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        if (!root.getParameters().isEmpty()) {\n+            Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n+            Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n+            if (!paramSymbol.equals(receiverSymbol)) {\n+                return Description.NO_MATCH;\n+            }\n+        }\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = receiver == null;\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {\n             return Description.NO_MATCH;\n         }\n \n         return buildDescription(root)\n                 .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state))\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n                 .build();\n     }\n \n-    private static boolean shouldIgnore(\n-            Symbol.MethodSymbol methodSymbol, LambdaExpressionTree root, MethodInvocationTree methodInvocation) {\n-        if (!methodSymbol.isStatic()) {\n-            if (root.getParameters().size() == 1) {\n-                Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n-                Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n-                return !paramSymbol.equals(receiverSymbol);\n-            }\n-            return true;\n+    private Description convertMethodInvocations(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        List<Symbol> methodParams = getSymbols(methodInvocation.getArguments());\n+        List<Symbol> lambdaParam = getSymbols(root.getParameters());\n+\n+        // We are guaranteed that all of root params are symbols so equality should handle cases where methodInvocation\n+        // arguments are not symbols or are out of order\n+        if (!methodParams.equals(lambdaParam)) {\n+            return Description.NO_MATCH;\n         }\n-        return !root.getParameters().isEmpty();\n+\n+        boolean isLocal = ASTHelpers.getReceiver(methodInvocation) == null;\n+        return buildDescription(root)\n+                .setMessage(MESSAGE)\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n+                .build();\n+    }\n+\n+    private static List<Symbol> getSymbols(List<? extends Tree> params) {\n+        return params.stream()\n+                .map(ASTHelpers::getSymbol)\n+                .filter(Objects::nonNull)\n+                .collect(ImmutableList.toImmutableList());\n     }\n \n     private static Optional<SuggestedFix> buildFix(\n             Symbol.MethodSymbol symbol,\n             MethodInvocationTree invocation,\n             LambdaExpressionTree root,\n-            VisitorState state) {\n+            VisitorState state,\n+            boolean isLocal) {\n         SuggestedFix.Builder builder = SuggestedFix.builder();\n-        return toMethodReference(qualifyTarget(symbol, invocation, builder, state))\n+        return toMethodReference(qualifyTarget(symbol, invocation, builder, state, isLocal))\n                 .map(qualified -> builder.replace(root, qualified).build());\n     }\n \n     private static String qualifyTarget(\n             Symbol.MethodSymbol symbol,\n             MethodInvocationTree invocation,\n             SuggestedFix.Builder builder,\n-            VisitorState state) {\n+            VisitorState state,\n+            boolean isLocal) {\n+        if (!symbol.isStatic() && isLocal) {\n+            return \"this.\" + symbol.name.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDMwNzc4OnYy", "diffSide": "RIGHT", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjowMDo0M1rOGci0hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjowMDo0M1rOGci0hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MzgxMw==", "bodyText": "Does this prevent us from fixing static method calls? I don't think static methods have receivers (but I may be incorrect)\n- value -> Preconditions.checkNotNull(value)\n+ Preconditions::checkNotNull", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432583813", "createdAt": "2020-05-29T16:00:43Z", "author": {"login": "carterkozak"}, "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,93 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = isLocal(methodInvocation);\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ecf78c33382ef0749b53388ba321269eeff645d"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2231, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}