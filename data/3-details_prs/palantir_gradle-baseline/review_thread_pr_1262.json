{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNTE3Mjg1", "number": 1262, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjoxNjozMlrODjcQFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo0Njo0NVrODj2-vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDg5NjIxOnYy", "diffSide": "RIGHT", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/plugins/BaselineExactDependencies.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjoxNjozMlrOFvQCvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjoxNjozMlrOFvQCvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA5MDIzOA==", "bodyText": "this should be per source set", "url": "https://github.com/palantir/gradle-baseline/pull/1262#discussion_r385090238", "createdAt": "2020-02-27T12:16:32Z", "author": {"login": "dansanduleac"}, "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/plugins/BaselineExactDependencies.java", "diffHunk": "@@ -60,47 +63,65 @@\n     @Override\n     public void apply(Project project) {\n         project.getPluginManager().withPlugin(\"java\", plugin -> {\n-            SourceSet mainSourceSet = project.getConvention()\n+            TaskProvider<Task> checkUnusedDependencies = project.getTasks().register(\"checkUnusedDependencies\");\n+            TaskProvider<Task> checkImplicitDependencies = project.getTasks().register(\"checkImplicitDependencies\");\n+\n+            project.getConvention()\n                     .getPlugin(JavaPluginConvention.class)\n                     .getSourceSets()\n-                    .getByName(SourceSet.MAIN_SOURCE_SET_NAME);\n-            Configuration compileClasspath =\n-                    project.getConfigurations().getByName(JavaPlugin.COMPILE_CLASSPATH_CONFIGURATION_NAME);\n-            Configuration compileOnly =\n-                    project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n-            Configuration justCompileOnlyResolvable = project.getConfigurations()\n-                    .create(\"baseline-exact-dependencies-compileOnly\", conf -> {\n-                        conf.setVisible(false);\n-                        conf.setCanBeConsumed(false);\n-                        conf.extendsFrom(compileOnly);\n-                        // Important! this ensures we resolve 'compile' variants rather than 'runtime'\n-                        // This is the same attribute that's being set on compileClasspath\n-                        conf.getAttributes()\n-                                .attribute(\n-                                        Usage.USAGE_ATTRIBUTE,\n-                                        project.getObjects().named(Usage.class, Usage.JAVA_API));\n-                    });\n-\n-            project.getTasks().create(\"checkUnusedDependencies\", CheckUnusedDependenciesTask.class, task -> {\n-                task.dependsOn(JavaPlugin.CLASSES_TASK_NAME);\n-                task.setSourceClasses(mainSourceSet.getOutput().getClassesDirs());\n-                task.dependenciesConfiguration(compileClasspath);\n-                task.sourceOnlyConfiguration(justCompileOnlyResolvable);\n-\n-                // this is liberally applied to ease the Java8 -> 11 transition\n-                task.ignore(\"javax.annotation\", \"javax.annotation-api\");\n-            });\n-\n-            project.getTasks().create(\"checkImplicitDependencies\", CheckImplicitDependenciesTask.class, task -> {\n-                task.dependsOn(JavaPlugin.CLASSES_TASK_NAME);\n-                task.setSourceClasses(mainSourceSet.getOutput().getClassesDirs());\n-                task.dependenciesConfiguration(compileClasspath);\n-\n-                task.ignore(\"org.slf4j\", \"slf4j-api\");\n-            });\n+                    .forEach(sourceSet ->\n+                            configureSourceSet(project, sourceSet, checkUnusedDependencies, checkImplicitDependencies));\n         });\n     }\n \n+    private static void configureSourceSet(\n+            Project project,\n+            SourceSet sourceSet,\n+            TaskProvider<Task> checkUnusedDependencies,\n+            TaskProvider<Task> checkImplicitDependencies) {\n+        Configuration compileClasspath =\n+                project.getConfigurations().getByName(sourceSet.getCompileClasspathConfigurationName());\n+        Configuration compileOnly = project.getConfigurations().getByName(sourceSet.getCompileOnlyConfigurationName());\n+        Configuration resolvableCompileOnly = project.getConfigurations()\n+                .create(\"baseline-exact-dependencies-\" + sourceSet.getCompileOnlyConfigurationName(), conf -> {\n+                    conf.setVisible(false);\n+                    conf.setCanBeConsumed(false);\n+                    conf.extendsFrom(compileOnly);\n+                    // Important! this ensures we resolve 'compile' variants rather than\n+                    // 'runtime'\n+                    // This is the same attribute that's being set on compileClasspath\n+                    conf.getAttributes()\n+                            .attribute(\n+                                    Usage.USAGE_ATTRIBUTE, project.getObjects().named(Usage.class, Usage.JAVA_API));\n+                });\n+        TaskProvider<CheckUnusedDependenciesTask> sourceSetUnusedDependencies = project.getTasks()\n+                .register(\n+                        GUtil.toLowerCamelCase(\"checkUnusedDependencies \" + sourceSet.getName()),\n+                        CheckUnusedDependenciesTask.class,\n+                        task -> {\n+                            task.dependsOn(JavaPlugin.CLASSES_TASK_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d599b2dcdb8bced9eb982011cd6549850223fc30"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDkzNTIxOnYy", "diffSide": "RIGHT", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/tasks/CheckUnusedDependenciesTask.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjoyOTo1MVrOFvQZvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMjoyOTo1MVrOFvQZvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA5NjEyNA==", "bodyText": "To be fair this method shouldn't exist, because I don't know in what situation users might actually use it.\nThe name is confusing now too since it implies source-only configurations need to be added, but we already add (ignore) all compileOnly configurations from all source sets.\nBut for now, let's at least throw eagerly if the user gave us a bad configuration.", "url": "https://github.com/palantir/gradle-baseline/pull/1262#discussion_r385096124", "createdAt": "2020-02-27T12:29:51Z", "author": {"login": "dansanduleac"}, "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/tasks/CheckUnusedDependenciesTask.java", "diffHunk": "@@ -190,6 +191,11 @@ public final void dependenciesConfiguration(Configuration dependenciesConfigurat\n     }\n \n     public final void sourceOnlyConfiguration(Configuration configuration) {\n+        Preconditions.checkNotNull(configuration);\n+        Preconditions.checkArgument(\n+                configuration.isCanBeResolved(),\n+                \"May only add sourceOnlyConfiguration if it is resolvable: %s\",\n+                configuration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f16f85ada959a12cc2d14508605e6d4c70df705"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTIxODUyOnYy", "diffSide": "RIGHT", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/plugins/BaselineExactDependencies.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTozMjozMVrOFv4_3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo0NTowMVrOFv5d5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MTI0Nw==", "bodyText": "Can we write a test for this?", "url": "https://github.com/palantir/gradle-baseline/pull/1262#discussion_r385761247", "createdAt": "2020-02-28T15:32:31Z", "author": {"login": "CRogers"}, "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/plugins/BaselineExactDependencies.java", "diffHunk": "@@ -60,45 +65,100 @@\n     @Override\n     public void apply(Project project) {\n         project.getPluginManager().withPlugin(\"java\", plugin -> {\n-            SourceSet mainSourceSet = project.getConvention()\n+            TaskProvider<Task> checkUnusedDependencies = project.getTasks().register(\"checkUnusedDependencies\");\n+            TaskProvider<Task> checkImplicitDependencies = project.getTasks().register(\"checkImplicitDependencies\");\n+\n+            project.getConvention()\n                     .getPlugin(JavaPluginConvention.class)\n                     .getSourceSets()\n-                    .getByName(SourceSet.MAIN_SOURCE_SET_NAME);\n-            Configuration compileClasspath =\n-                    project.getConfigurations().getByName(JavaPlugin.COMPILE_CLASSPATH_CONFIGURATION_NAME);\n-            Configuration compileOnly =\n-                    project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n-            Configuration justCompileOnlyResolvable = project.getConfigurations()\n-                    .create(\"baseline-exact-dependencies-compileOnly\", conf -> {\n-                        conf.setVisible(false);\n-                        conf.setCanBeConsumed(false);\n-                        conf.extendsFrom(compileOnly);\n-                        // Important! this ensures we resolve 'compile' variants rather than 'runtime'\n-                        // This is the same attribute that's being set on compileClasspath\n-                        conf.getAttributes()\n-                                .attribute(\n-                                        Usage.USAGE_ATTRIBUTE,\n-                                        project.getObjects().named(Usage.class, Usage.JAVA_API));\n-                    });\n-\n-            project.getTasks().create(\"checkUnusedDependencies\", CheckUnusedDependenciesTask.class, task -> {\n-                task.dependsOn(JavaPlugin.CLASSES_TASK_NAME);\n-                task.setSourceClasses(mainSourceSet.getOutput().getClassesDirs());\n-                task.dependenciesConfiguration(compileClasspath);\n-                task.sourceOnlyConfiguration(justCompileOnlyResolvable);\n-\n-                // this is liberally applied to ease the Java8 -> 11 transition\n-                task.ignore(\"javax.annotation\", \"javax.annotation-api\");\n-            });\n+                    .all(sourceSet ->\n+                            configureSourceSet(project, sourceSet, checkUnusedDependencies, checkImplicitDependencies));\n+        });\n+    }\n \n-            project.getTasks().create(\"checkImplicitDependencies\", CheckImplicitDependenciesTask.class, task -> {\n-                task.dependsOn(JavaPlugin.CLASSES_TASK_NAME);\n-                task.setSourceClasses(mainSourceSet.getOutput().getClassesDirs());\n-                task.dependenciesConfiguration(compileClasspath);\n+    private static void configureSourceSet(\n+            Project project,\n+            SourceSet sourceSet,\n+            TaskProvider<Task> checkUnusedDependencies,\n+            TaskProvider<Task> checkImplicitDependencies) {\n+        Configuration implementation =\n+                project.getConfigurations().getByName(sourceSet.getImplementationConfigurationName());\n+        Configuration compile = project.getConfigurations().getByName(sourceSet.getCompileConfigurationName());\n+        Configuration compileClasspath =\n+                project.getConfigurations().getByName(sourceSet.getCompileClasspathConfigurationName());\n \n-                task.ignore(\"org.slf4j\", \"slf4j-api\");\n-            });\n+        Configuration explicitCompile = project.getConfigurations()\n+                .create(\"baseline-exact-dependencies-\" + sourceSet.getName(), conf -> {\n+                    conf.setDescription(String.format(\n+                            \"Tracks the explicit (not inherited) dependencies added to either %s or %s\",\n+                            compile.toString(), implementation.toString()));\n+                    conf.setVisible(false);\n+                    conf.setCanBeConsumed(false);\n+                    // Important! this ensures we resolve 'compile' variants rather than 'runtime'\n+                    // This is the same attribute that's being set on compileClasspath\n+                    conf.getAttributes()\n+                            .attribute(\n+                                    Usage.USAGE_ATTRIBUTE, project.getObjects().named(Usage.class, Usage.JAVA_API));\n+                });\n+\n+        // Figure out what our compile dependencies are while ignoring dependencies we've inherited from other source\n+        // sets. For example, if we are `test`, some of our configurations extend from the `main` source set:\n+        // testImplementation     extendsFrom(implementation)\n+        //  \\-- testCompile       extendsFrom(compile)\n+        // We therefore want to look at only the dependencies _directly_ declared in the implementation and compile\n+        // configurations (belonging to our source set)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bdc909f80b746aa03bfda5981ed2331ea07d630"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2ODkzMg==", "bodyText": "Yep, wrote one", "url": "https://github.com/palantir/gradle-baseline/pull/1262#discussion_r385768932", "createdAt": "2020-02-28T15:45:01Z", "author": {"login": "dansanduleac"}, "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/plugins/BaselineExactDependencies.java", "diffHunk": "@@ -60,45 +65,100 @@\n     @Override\n     public void apply(Project project) {\n         project.getPluginManager().withPlugin(\"java\", plugin -> {\n-            SourceSet mainSourceSet = project.getConvention()\n+            TaskProvider<Task> checkUnusedDependencies = project.getTasks().register(\"checkUnusedDependencies\");\n+            TaskProvider<Task> checkImplicitDependencies = project.getTasks().register(\"checkImplicitDependencies\");\n+\n+            project.getConvention()\n                     .getPlugin(JavaPluginConvention.class)\n                     .getSourceSets()\n-                    .getByName(SourceSet.MAIN_SOURCE_SET_NAME);\n-            Configuration compileClasspath =\n-                    project.getConfigurations().getByName(JavaPlugin.COMPILE_CLASSPATH_CONFIGURATION_NAME);\n-            Configuration compileOnly =\n-                    project.getConfigurations().getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME);\n-            Configuration justCompileOnlyResolvable = project.getConfigurations()\n-                    .create(\"baseline-exact-dependencies-compileOnly\", conf -> {\n-                        conf.setVisible(false);\n-                        conf.setCanBeConsumed(false);\n-                        conf.extendsFrom(compileOnly);\n-                        // Important! this ensures we resolve 'compile' variants rather than 'runtime'\n-                        // This is the same attribute that's being set on compileClasspath\n-                        conf.getAttributes()\n-                                .attribute(\n-                                        Usage.USAGE_ATTRIBUTE,\n-                                        project.getObjects().named(Usage.class, Usage.JAVA_API));\n-                    });\n-\n-            project.getTasks().create(\"checkUnusedDependencies\", CheckUnusedDependenciesTask.class, task -> {\n-                task.dependsOn(JavaPlugin.CLASSES_TASK_NAME);\n-                task.setSourceClasses(mainSourceSet.getOutput().getClassesDirs());\n-                task.dependenciesConfiguration(compileClasspath);\n-                task.sourceOnlyConfiguration(justCompileOnlyResolvable);\n-\n-                // this is liberally applied to ease the Java8 -> 11 transition\n-                task.ignore(\"javax.annotation\", \"javax.annotation-api\");\n-            });\n+                    .all(sourceSet ->\n+                            configureSourceSet(project, sourceSet, checkUnusedDependencies, checkImplicitDependencies));\n+        });\n+    }\n \n-            project.getTasks().create(\"checkImplicitDependencies\", CheckImplicitDependenciesTask.class, task -> {\n-                task.dependsOn(JavaPlugin.CLASSES_TASK_NAME);\n-                task.setSourceClasses(mainSourceSet.getOutput().getClassesDirs());\n-                task.dependenciesConfiguration(compileClasspath);\n+    private static void configureSourceSet(\n+            Project project,\n+            SourceSet sourceSet,\n+            TaskProvider<Task> checkUnusedDependencies,\n+            TaskProvider<Task> checkImplicitDependencies) {\n+        Configuration implementation =\n+                project.getConfigurations().getByName(sourceSet.getImplementationConfigurationName());\n+        Configuration compile = project.getConfigurations().getByName(sourceSet.getCompileConfigurationName());\n+        Configuration compileClasspath =\n+                project.getConfigurations().getByName(sourceSet.getCompileClasspathConfigurationName());\n \n-                task.ignore(\"org.slf4j\", \"slf4j-api\");\n-            });\n+        Configuration explicitCompile = project.getConfigurations()\n+                .create(\"baseline-exact-dependencies-\" + sourceSet.getName(), conf -> {\n+                    conf.setDescription(String.format(\n+                            \"Tracks the explicit (not inherited) dependencies added to either %s or %s\",\n+                            compile.toString(), implementation.toString()));\n+                    conf.setVisible(false);\n+                    conf.setCanBeConsumed(false);\n+                    // Important! this ensures we resolve 'compile' variants rather than 'runtime'\n+                    // This is the same attribute that's being set on compileClasspath\n+                    conf.getAttributes()\n+                            .attribute(\n+                                    Usage.USAGE_ATTRIBUTE, project.getObjects().named(Usage.class, Usage.JAVA_API));\n+                });\n+\n+        // Figure out what our compile dependencies are while ignoring dependencies we've inherited from other source\n+        // sets. For example, if we are `test`, some of our configurations extend from the `main` source set:\n+        // testImplementation     extendsFrom(implementation)\n+        //  \\-- testCompile       extendsFrom(compile)\n+        // We therefore want to look at only the dependencies _directly_ declared in the implementation and compile\n+        // configurations (belonging to our source set)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MTI0Nw=="}, "originalCommit": {"oid": "6bdc909f80b746aa03bfda5981ed2331ea07d630"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTI3NTUxOnYy", "diffSide": "RIGHT", "path": "gradle-baseline-java/src/test/groovy/com/palantir/baseline/BaselineExactDependenciesTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo0Njo0NVrOFv5iKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo0Njo0NVrOFv5iKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MDAyNg==", "bodyText": "Without my latest changes (with the previous implementation at https://github.com/palantir/gradle-baseline/pull/1262/files/bc8e9e2cca856833a02d3d8775c9641378a8953f) this test failed with:\n* What went wrong:\nExecution failed for task ':checkUnusedDependenciesTest'.\n> Found 1 dependencies unused during compilation, please delete them from 'build.gradle' or choose one of the suggested fixes:\n  \tcom.google.guava:guava", "url": "https://github.com/palantir/gradle-baseline/pull/1262#discussion_r385770026", "createdAt": "2020-02-28T15:46:45Z", "author": {"login": "dansanduleac"}, "path": "gradle-baseline-java/src/test/groovy/com/palantir/baseline/BaselineExactDependenciesTest.groovy", "diffHunk": "@@ -109,6 +109,32 @@ class BaselineExactDependenciesTest extends AbstractPluginTest {\n         BuildResult result = with('checkUnusedDependencies', '--stacktrace').build()\n         result.task(':classes').getOutcome() == TaskOutcome.SUCCESS\n         result.task(':checkUnusedDependencies').getOutcome() == TaskOutcome.SUCCESS\n+        result.task(':checkUnusedDependenciesMain').getOutcome() == TaskOutcome.SUCCESS\n+    }\n+\n+    def 'checkUnusedDependenciesTest passes if dependency from main source set is not referenced in test'() {\n+        when:\n+        buildFile << standardBuildFile\n+        buildFile << \"\"\"\n+        repositories {\n+            mavenCentral()\n+        }\n+        dependencies {\n+            compile 'com.google.guava:guava:28.0-jre'\n+        }\n+        \"\"\"\n+        file('src/main/java/pkg/Foo.java') << '''\n+        package pkg;\n+        public class Foo {\n+            void foo() {\n+                com.google.common.collect.ImmutableList.of();\n+            }\n+        }\n+        '''.stripIndent()\n+\n+        then:\n+        def result = with('checkUnusedDependencies', '--stacktrace').build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29f4c912d07d898374b20108cf45d1aa7a07fb49"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2085, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}