{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0ODY3NTAz", "number": 1365, "title": "Convert multi param lambdas and local method invocations to method references", "bodyText": "Before this PR\nWe did not catch or convert any lambda that took multiple parameters to method references and we did not convert any local instance method either\nAfter this PR\n==COMMIT_MSG==\nConvert multi param lambdas and local method invocations to method references\n==COMMIT_MSG==\nPossible downsides?\nWe want to make sure this works in all cases so we should test against our large internal repo before merging", "createdAt": "2020-05-29T03:45:19Z", "url": "https://github.com/palantir/gradle-baseline/pull/1365", "merged": true, "mergeCommit": {"oid": "57408781ece8fe2f4292d5bd52a62c3385257439"}, "closed": true, "closedAt": "2020-06-01T20:55:33Z", "author": {"login": "ferozco"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcl5OeogH2gAyNDI0ODY3NTAzOjNmYTZmMWIxMjM5NjMxZjg0YTZiMGE2MTc3ZTU1OTNlYzQ1Y2I1YWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnGltigFqTQyMjE3MTMyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3fa6f1b1239631f84a6b0a6177e5593ec45cb5aa", "author": {"user": {"login": "ferozco", "name": "Felipe Orozco"}}, "url": "https://github.com/palantir/gradle-baseline/commit/3fa6f1b1239631f84a6b0a6177e5593ec45cb5aa", "committedDate": "2020-05-29T02:41:41Z", "message": "baby steps"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7fa4b0fd1888c4fdacb533440c0edbf924d4b70", "author": {"user": {"login": "ferozco", "name": "Felipe Orozco"}}, "url": "https://github.com/palantir/gradle-baseline/commit/c7fa4b0fd1888c4fdacb533440c0edbf924d4b70", "committedDate": "2020-05-29T03:41:53Z", "message": "convert local methods and multi param methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "author": {"user": {"login": "ferozco", "name": "Felipe Orozco"}}, "url": "https://github.com/palantir/gradle-baseline/commit/474512dbc8676a65536bd55662f7d1bc1c05dbe3", "committedDate": "2020-05-29T03:41:53Z", "message": "Add generated changelog entries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjM4Nzk0", "url": "https://github.com/palantir/gradle-baseline/pull/1365#pullrequestreview-420638794", "createdAt": "2020-05-29T04:05:30Z", "commit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDowNTozMFrOGcOGwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDoxMjoxN1rOGcOMLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDQxNg==", "bodyText": "I think we should handle a receiver IdentifierTree with name \u201cthis\u201d as well. Worth a test case if we don\u2019t already have one (review on thumbs)", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432244416", "createdAt": "2020-05-29T04:05:30Z", "author": {"login": "carterkozak"}, "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        if (!root.getParameters().isEmpty()) {\n+            Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n+            Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n+            if (!paramSymbol.equals(receiverSymbol)) {\n+                return Description.NO_MATCH;\n+            }\n+        }\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = receiver == null;\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {\n             return Description.NO_MATCH;\n         }\n \n         return buildDescription(root)\n                 .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state))\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n                 .build();\n     }\n \n-    private static boolean shouldIgnore(\n-            Symbol.MethodSymbol methodSymbol, LambdaExpressionTree root, MethodInvocationTree methodInvocation) {\n-        if (!methodSymbol.isStatic()) {\n-            if (root.getParameters().size() == 1) {\n-                Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n-                Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n-                return !paramSymbol.equals(receiverSymbol);\n-            }\n-            return true;\n+    private Description convertMethodInvocations(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        List<Symbol> methodParams = getSymbols(methodInvocation.getArguments());\n+        List<Symbol> lambdaParam = getSymbols(root.getParameters());\n+\n+        // We are guaranteed that all of root params are symbols so equality should handle cases where methodInvocation\n+        // arguments are not symbols or are out of order\n+        if (!methodParams.equals(lambdaParam)) {\n+            return Description.NO_MATCH;\n         }\n-        return !root.getParameters().isEmpty();\n+\n+        boolean isLocal = ASTHelpers.getReceiver(methodInvocation) == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDcxNg==", "bodyText": "Not sure these negative tests are necessary when we have refactoring tests as well.", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432244716", "createdAt": "2020-05-29T04:07:06Z", "author": {"login": "carterkozak"}, "path": "baseline-error-prone/src/test/java/com/palantir/baseline/errorprone/LambdaMethodReferenceTest.java", "diffHunk": "@@ -67,7 +68,83 @@ void testFunction() {\n     }\n \n     @Test\n-    public void testPositive_block() {\n+    void testLocalInstanceMethod() {\n+        compilationHelper\n+                .addSourceLines(\n+                        \"Test.java\",\n+                        \"import \" + Optional.class.getName() + ';',\n+                        \"class Test {\",\n+                        \"  public Optional<Integer> foo(Optional<String> optional) {\",\n+                        \"    // BUG: Diagnostic contains: Lambda should be a method reference\",\n+                        \"    return optional.map(v -> bar(v));\",\n+                        \"  }\",\n+                        \"  private Integer bar(String value) {\",\n+                        \"    return value.length();\",\n+                        \"  }\",\n+                        \"}\")\n+                .doTest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NTgwNA==", "bodyText": "Can we remove the supplier case here in favor of the zero-length method invocation code path?", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432245804", "createdAt": "2020-05-29T04:12:17Z", "author": {"login": "carterkozak"}, "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjQ1MzU3", "url": "https://github.com/palantir/gradle-baseline/pull/1365#pullrequestreview-420645357", "createdAt": "2020-05-29T04:31:21Z", "commit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDozMToyMVrOGcOcfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNDozMToyMVrOGcOcfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0OTk4Mg==", "bodyText": "I think there might be some oddness if the method is. It provided by this, but an enclosing class, requiring prefix \u201cEnclosing.this.\u201c. Worth a test to verify, I\u2019d probably exclude that from the check rather than attempt to refactor since it\u2019s fairly uncommon.", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432249982", "createdAt": "2020-05-29T04:31:21Z", "author": {"login": "carterkozak"}, "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        if (!root.getParameters().isEmpty()) {\n+            Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n+            Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n+            if (!paramSymbol.equals(receiverSymbol)) {\n+                return Description.NO_MATCH;\n+            }\n+        }\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = receiver == null;\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {\n             return Description.NO_MATCH;\n         }\n \n         return buildDescription(root)\n                 .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state))\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n                 .build();\n     }\n \n-    private static boolean shouldIgnore(\n-            Symbol.MethodSymbol methodSymbol, LambdaExpressionTree root, MethodInvocationTree methodInvocation) {\n-        if (!methodSymbol.isStatic()) {\n-            if (root.getParameters().size() == 1) {\n-                Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n-                Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n-                return !paramSymbol.equals(receiverSymbol);\n-            }\n-            return true;\n+    private Description convertMethodInvocations(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        List<Symbol> methodParams = getSymbols(methodInvocation.getArguments());\n+        List<Symbol> lambdaParam = getSymbols(root.getParameters());\n+\n+        // We are guaranteed that all of root params are symbols so equality should handle cases where methodInvocation\n+        // arguments are not symbols or are out of order\n+        if (!methodParams.equals(lambdaParam)) {\n+            return Description.NO_MATCH;\n         }\n-        return !root.getParameters().isEmpty();\n+\n+        boolean isLocal = ASTHelpers.getReceiver(methodInvocation) == null;\n+        return buildDescription(root)\n+                .setMessage(MESSAGE)\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n+                .build();\n+    }\n+\n+    private static List<Symbol> getSymbols(List<? extends Tree> params) {\n+        return params.stream()\n+                .map(ASTHelpers::getSymbol)\n+                .filter(Objects::nonNull)\n+                .collect(ImmutableList.toImmutableList());\n     }\n \n     private static Optional<SuggestedFix> buildFix(\n             Symbol.MethodSymbol symbol,\n             MethodInvocationTree invocation,\n             LambdaExpressionTree root,\n-            VisitorState state) {\n+            VisitorState state,\n+            boolean isLocal) {\n         SuggestedFix.Builder builder = SuggestedFix.builder();\n-        return toMethodReference(qualifyTarget(symbol, invocation, builder, state))\n+        return toMethodReference(qualifyTarget(symbol, invocation, builder, state, isLocal))\n                 .map(qualified -> builder.replace(root, qualified).build());\n     }\n \n     private static String qualifyTarget(\n             Symbol.MethodSymbol symbol,\n             MethodInvocationTree invocation,\n             SuggestedFix.Builder builder,\n-            VisitorState state) {\n+            VisitorState state,\n+            boolean isLocal) {\n+        if (!symbol.isStatic() && isLocal) {\n+            return \"this.\" + symbol.name.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3"}, "originalPosition": 148}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ac79db4930bc015819445a449f3579bf7a51dac", "author": {"user": {"login": "ferozco", "name": "Felipe Orozco"}}, "url": "https://github.com/palantir/gradle-baseline/commit/9ac79db4930bc015819445a449f3579bf7a51dac", "committedDate": "2020-05-29T12:53:20Z", "message": "handle explicit this"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f47bb7235f39a4b1a7ef60666c8d2e49049c766", "author": {"user": {"login": "ferozco", "name": "Felipe Orozco"}}, "url": "https://github.com/palantir/gradle-baseline/commit/7f47bb7235f39a4b1a7ef60666c8d2e49049c766", "committedDate": "2020-05-29T13:00:20Z", "message": "simplify"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ecf78c33382ef0749b53388ba321269eeff645d", "author": {"user": {"login": "ferozco", "name": "Felipe Orozco"}}, "url": "https://github.com/palantir/gradle-baseline/commit/0ecf78c33382ef0749b53388ba321269eeff645d", "committedDate": "2020-05-29T15:46:43Z", "message": "Merge branch 'fo/lambda-methods' of github.com:palantir/gradle-baseline into fo/lambda-methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMDg2MjIx", "url": "https://github.com/palantir/gradle-baseline/pull/1365#pullrequestreview-421086221", "createdAt": "2020-05-29T16:00:43Z", "commit": {"oid": "0ecf78c33382ef0749b53388ba321269eeff645d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjowMDo0M1rOGci0hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjowMDo0M1rOGci0hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MzgxMw==", "bodyText": "Does this prevent us from fixing static method calls? I don't think static methods have receivers (but I may be incorrect)\n- value -> Preconditions.checkNotNull(value)\n+ Preconditions::checkNotNull", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432583813", "createdAt": "2020-05-29T16:00:43Z", "author": {"login": "carterkozak"}, "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,93 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = isLocal(methodInvocation);\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ecf78c33382ef0749b53388ba321269eeff645d"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63697913887e4a07b6ef1f3c48333894d50148cc", "author": {"user": {"login": "ferozco", "name": "Felipe Orozco"}}, "url": "https://github.com/palantir/gradle-baseline/commit/63697913887e4a07b6ef1f3c48333894d50148cc", "committedDate": "2020-05-29T19:32:45Z", "message": "demonstrate static method with param"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a43e41c8c66e33c3cc9451e3d6588ba408ac02b", "author": {"user": {"login": "carterkozak", "name": "Carter Kozak"}}, "url": "https://github.com/palantir/gradle-baseline/commit/7a43e41c8c66e33c3cc9451e3d6588ba408ac02b", "committedDate": "2020-05-29T20:16:17Z", "message": "Ckozak/fo/lambda methods/fix (#1369)\n\n* Fix lambdas\n\n* dont change reference capture time\n\n* avoid refactoring lambdas with param types\n\n* cyclo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df14397f105db2b6ed623d6f228dc138f8343066", "author": {"user": {"login": "carterkozak", "name": "Carter Kozak"}}, "url": "https://github.com/palantir/gradle-baseline/commit/df14397f105db2b6ed623d6f228dc138f8343066", "committedDate": "2020-06-01T20:48:10Z", "message": "validate against ambiguous references (#1372)\n\n<!-- User-facing outcomes this PR delivers -->"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMTcxMzI2", "url": "https://github.com/palantir/gradle-baseline/pull/1365#pullrequestreview-422171326", "createdAt": "2020-06-01T20:49:45Z", "commit": {"oid": "df14397f105db2b6ed623d6f228dc138f8343066"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2115, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}