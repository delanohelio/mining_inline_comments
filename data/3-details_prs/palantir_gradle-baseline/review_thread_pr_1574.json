{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4Njk5ODkx", "number": 1574, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozMTowNVrOE-DRKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNDoyNzo1OVrOE-WYEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTAwNzE1OnYy", "diffSide": "RIGHT", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/tasks/CheckExplicitSourceCompatibilityTask.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozMTowNVrOH7DwKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjozMTowNVrOH7DwKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4OTUxMw==", "bodyText": "I broke tracing-java and tried it out, error message looks like this:\n1: Task failed with an exception.\n-----------\n* What went wrong:\nExecution failed for task ':tracing-jaxrs:checkExplicitSourceCompatibility'.\n> project ':tracing-jaxrs' must set sourceCompatibility explicitly in 'tracing-jaxrs/build.gradle', otherwise compilation will not be reproducible but instead depends on the Java version that Gradle is currently running with (11). To auto-fix, run\n\n       ./gradlew :tracing-jaxrs:checkExplicitSourceCompatibility --fix\n\n  This will automatically add a suggested line (you may need to adjust the number, e.g. to '1.8' for maximum compatibility).", "url": "https://github.com/palantir/gradle-baseline/pull/1574#discussion_r531689513", "createdAt": "2020-11-27T16:31:05Z", "author": {"login": "iamdanfox"}, "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/tasks/CheckExplicitSourceCompatibilityTask.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.baseline.tasks;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Collections;\n+import javax.inject.Inject;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Task;\n+import org.gradle.api.model.ObjectFactory;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.provider.Property;\n+import org.gradle.api.publish.PublishingExtension;\n+import org.gradle.api.specs.Spec;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.options.Option;\n+\n+/**\n+ * By default, Gradle will infer sourceCompat based on whatever JVM is currently being used to evaluate the\n+ * build.gradle files. This is bad for reproducibility because if we make an automated PR to upgrade the Java major\n+ * version (e.g. 11 -> 15) then a library might unintentionally start publishing jars containing Java15 bytecode!\n+ *\n+ * Better to just require everyone to specify sourceCompatibility explicitly!\n+ */\n+public class CheckExplicitSourceCompatibilityTask extends DefaultTask {\n+\n+    private final Property<Boolean> shouldFix;\n+\n+    @Inject\n+    public CheckExplicitSourceCompatibilityTask(ObjectFactory objectFactory) {\n+        setGroup(\"Verification\");\n+        setDescription(\"Ensures build.gradle specifies sourceCompatibility explicitly, otherwise it is inferred based\"\n+                + \" on $JAVA_HOME which is fragile.\");\n+        this.shouldFix = objectFactory.property(Boolean.class);\n+        this.shouldFix.set(false);\n+\n+        onlyIf(new Spec<Task>() {\n+            @Override\n+            public boolean isSatisfiedBy(Task element) {\n+                // sometimes people apply the 'java' plugin to projects that doesn't actually have any java code in it\n+                // (e.g. the root project), so if they're not publishing anything, then we don't bother enforcing the\n+                // sourceCompat thing\n+                PublishingExtension publishing = getProject().getExtensions().findByType(PublishingExtension.class);\n+                return publishing != null;\n+            }\n+        });\n+    }\n+\n+    @Option(option = \"fix\", description = \"Whether to apply the suggested fix to build.gradle\")\n+    public final void setShouldFix(boolean value) {\n+        shouldFix.set(value);\n+    }\n+\n+    @TaskAction\n+    public final void taskAction() throws IOException {\n+        // We're doing this naughty casting because we need access to the `getRawSourceCompatibility` method.\n+        org.gradle.api.plugins.internal.DefaultJavaPluginConvention convention =\n+                (org.gradle.api.plugins.internal.DefaultJavaPluginConvention)\n+                        getProject().getConvention().getPlugin(JavaPluginConvention.class);\n+\n+        if (convention.getRawSourceCompatibility() != null) {\n+            // In theory, users could configure the fancy new 'java toolchain' as an alternative to explicit\n+            // sourceCompatibility, but there's no method to access this yet (as of Gradle 6.8).\n+            return;\n+        }\n+\n+        if (shouldFix.get()) {\n+            Files.write(\n+                    getProject().getBuildFile().toPath(),\n+                    Collections.singletonList(String.format(\"%nsourceCompatibility = %s\", JavaVersion.current())),\n+                    StandardCharsets.UTF_8,\n+                    StandardOpenOption.APPEND,\n+                    StandardOpenOption.CREATE);\n+            return;\n+        }\n+\n+        throw new GradleException(String.format(\n+                \"%s must set sourceCompatibility explicitly in '%s', \"\n+                        + \"otherwise compilation will not be reproducible but instead depends on the Java version \"\n+                        + \"that Gradle is currently running with (%s). To auto-fix, run%n\"\n+                        + \"%n\"\n+                        + \"     ./gradlew %s --fix%n\"\n+                        + \"%n\"\n+                        + \"This will automatically add a suggested line \"\n+                        + \"(you may need to adjust the number, e.g. to '1.8' for maximum compatibility).\",\n+                getProject(),\n+                getProject().getRootProject().relativePath(getProject().getBuildFile()),\n+                JavaVersion.current(),\n+                getPath()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fade5c8f8630e08872a2f85312540901584f4b0"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODEzNzc2OnYy", "diffSide": "RIGHT", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/tasks/CheckExplicitSourceCompatibilityTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNDoyNzo1OVrOH7gE6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNDoyNzo1OVrOH7gE6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1MzU3OA==", "bodyText": "Should this also add a trailing newline at the end of the file?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                Collections.singletonList(String.format(\"%nsourceCompatibility = %s\", JavaVersion.current())),\n          \n          \n            \n                                Collections.singletonList(String.format(\"%nsourceCompatibility = %s%n\", JavaVersion.current())),", "url": "https://github.com/palantir/gradle-baseline/pull/1574#discussion_r532153578", "createdAt": "2020-11-29T04:27:59Z", "author": {"login": "schlosna"}, "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/tasks/CheckExplicitSourceCompatibilityTask.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.baseline.tasks;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Collections;\n+import javax.inject.Inject;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.JavaVersion;\n+import org.gradle.api.Task;\n+import org.gradle.api.model.ObjectFactory;\n+import org.gradle.api.plugins.JavaPluginConvention;\n+import org.gradle.api.provider.Property;\n+import org.gradle.api.publish.PublishingExtension;\n+import org.gradle.api.specs.Spec;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.api.tasks.options.Option;\n+\n+/**\n+ * By default, Gradle will infer sourceCompat based on whatever JVM is currently being used to evaluate the\n+ * build.gradle files. This is bad for reproducibility because if we make an automated PR to upgrade the Java major\n+ * version (e.g. 11 -> 15) then a library might unintentionally start publishing jars containing Java15 bytecode!\n+ *\n+ * Better to just require everyone to specify sourceCompatibility explicitly!\n+ */\n+public class CheckExplicitSourceCompatibilityTask extends DefaultTask {\n+\n+    private final Property<Boolean> shouldFix;\n+\n+    @Inject\n+    public CheckExplicitSourceCompatibilityTask(ObjectFactory objectFactory) {\n+        setGroup(\"Verification\");\n+        setDescription(\"Ensures build.gradle specifies sourceCompatibility explicitly, otherwise it is inferred based\"\n+                + \" on $JAVA_HOME which is fragile.\");\n+        this.shouldFix = objectFactory.property(Boolean.class);\n+        this.shouldFix.set(false);\n+\n+        onlyIf(new Spec<Task>() {\n+            @Override\n+            public boolean isSatisfiedBy(Task element) {\n+                // sometimes people apply the 'java' plugin to projects that doesn't actually have any java code in it\n+                // (e.g. the root project), so if they're not publishing anything, then we don't bother enforcing the\n+                // sourceCompat thing\n+                PublishingExtension publishing = getProject().getExtensions().findByType(PublishingExtension.class);\n+                return publishing != null;\n+            }\n+        });\n+    }\n+\n+    @Option(option = \"fix\", description = \"Whether to apply the suggested fix to build.gradle\")\n+    public final void setShouldFix(boolean value) {\n+        shouldFix.set(value);\n+    }\n+\n+    @TaskAction\n+    public final void taskAction() throws IOException {\n+        // We're doing this naughty casting because we need access to the `getRawSourceCompatibility` method.\n+        org.gradle.api.plugins.internal.DefaultJavaPluginConvention convention =\n+                (org.gradle.api.plugins.internal.DefaultJavaPluginConvention)\n+                        getProject().getConvention().getPlugin(JavaPluginConvention.class);\n+\n+        if (convention.getRawSourceCompatibility() != null) {\n+            // In theory, users could configure the fancy new 'java toolchain' as an alternative to explicit\n+            // sourceCompatibility, but there's no method to access this yet (as of Gradle 6.8).\n+            return;\n+        }\n+\n+        if (shouldFix.get()) {\n+            Files.write(\n+                    getProject().getBuildFile().toPath(),\n+                    Collections.singletonList(String.format(\"%nsourceCompatibility = %s\", JavaVersion.current())),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fade5c8f8630e08872a2f85312540901584f4b0"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2162, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}