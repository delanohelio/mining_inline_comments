{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4NTQyMzIz", "number": 3712, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDozMzozM1rODiGrng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDozNToxNFrODiGrzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDg3NjQ2OnYy", "diffSide": "RIGHT", "path": "src/com/palmergames/bukkit/towny/command/BaseCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDozMzozNFrOFtMx_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDozMzozNFrOFtMx_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzOTY0Nw==", "bodyText": "Remove debug code.", "url": "https://github.com/TownyAdvanced/Towny/pull/3712#discussion_r382939647", "createdAt": "2020-02-22T20:33:34Z", "author": {"login": "LlmDl"}, "path": "src/com/palmergames/bukkit/towny/command/BaseCommand.java", "diffHunk": "@@ -1,55 +1,75 @@\n package com.palmergames.bukkit.towny.command;\r\n \r\n import com.palmergames.bukkit.towny.TownyUniverse;\r\n-import com.palmergames.bukkit.towny.object.Nation;\r\n-import com.palmergames.bukkit.towny.object.Resident;\r\n-import com.palmergames.bukkit.towny.object.Town;\r\n+import com.palmergames.bukkit.towny.utils.NameUtil;\r\n import org.bukkit.command.Command;\r\n import org.bukkit.command.CommandSender;\r\n import org.bukkit.command.TabCompleter;\r\n \r\n-import java.util.LinkedList;\r\n+import java.util.ArrayList;\r\n import java.util.List;\r\n \r\n-\r\n public class BaseCommand implements TabCompleter{\r\n-\r\n+\t\r\n \t\r\n \t@Override\r\n \tpublic List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\r\n-\t\tLinkedList<String> output = new LinkedList<>();\r\n-\t\tString lastArg = \"\";\r\n+\t\treturn getTownyStartingWith(args[args.length - 1], \"rtn\");\r\n+\t}\r\n+\t\r\n+\t/**\r\n+\t * Returns a List<String> containing strings of resident, town, and/or nation names that match with arg.\r\n+\t * Can check for multiple types, for example \"rt\" would check for residents and towns but not nations or worlds.\r\n+\t *\r\n+\t * @param arg the string to match with the chosen type\r\n+\t * @param type the type of Towny object to check for, can be r(esident), t(own), n(ation), w(orld), or any combination of those to check\r\n+\t * @return Matches for the arg with the chosen type\r\n+\t */\r\n+\tstatic List<String> getTownyStartingWith(String arg, String type) {\r\n+\t\t//long start = System.nanoTime();\r\n+\t\tList<String> matches = new ArrayList<>();\r\n \t\tTownyUniverse townyUniverse = TownyUniverse.getInstance();\r\n+\t\t\r\n+\t\tif (type.contains(\"r\")) {\r\n+\t\t\tmatches.addAll(townyUniverse.getResidentsTrie().getStringsFromKey(arg));\r\n+\t\t}\r\n \r\n-\t\t// Get the last argument\r\n-\t\tif (args.length > 0) {\r\n-\t\t\tlastArg = args[args.length - 1].toLowerCase();\r\n+\t\tif (type.contains(\"t\")) {\r\n+\t\t\tmatches.addAll(townyUniverse.getTownsTrie().getStringsFromKey(arg));\r\n \t\t}\r\n \r\n-\t\tif (!lastArg.equalsIgnoreCase(\"\")) {\r\n-\t\t\t// Match nations\r\n-\t\t\tfor (Nation nation : townyUniverse.getDataSource().getNations()) {\r\n-\t\t\t\tif (nation.getName().toLowerCase().startsWith(lastArg)) {\r\n-\t\t\t\t\toutput.add(nation.getName());\r\n-\t\t\t\t}\r\n+\t\tif (type.contains(\"n\")) {\r\n+\t\t\tmatches.addAll(townyUniverse.getNationsTrie().getStringsFromKey(arg));\r\n+\t\t}\r\n+\t\t\r\n+\t\tif (type.contains(\"w\")) { // There aren't many worlds so check even if arg is empty\r\n+\t\t\tmatches.addAll(NameUtil.filterByStart(NameUtil.getNames(townyUniverse.getWorldMap().values()), arg));\r\n+\t\t}\r\n \r\n-\t\t\t}\r\n-\t\t\t// Match towns\r\n-\t\t\tfor (Town town : townyUniverse.getDataSource().getTowns()) {\r\n-\t\t\t\tif (town.getName().toLowerCase().startsWith(lastArg)) {\r\n-\t\t\t\t\toutput.add(town.getName());\r\n-\t\t\t\t}\r\n+\t\t//System.out.println(\"Found \"+matches.size()+\" for \"+type+\" in \"+(float)(System.nanoTime()-start)/1000000+\"ms\");\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8721d5af5b41139b277c5ff8359f57c76889c5b"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDg3Njk1OnYy", "diffSide": "RIGHT", "path": "src/com/palmergames/util/Trie.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDozNToxNFrOFtMyRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQyMDozNToxNFrOFtMyRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkzOTcxNg==", "bodyText": "Remove this line?", "url": "https://github.com/TownyAdvanced/Towny/pull/3712#discussion_r382939716", "createdAt": "2020-02-22T20:35:14Z", "author": {"login": "LlmDl"}, "path": "src/com/palmergames/util/Trie.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.palmergames.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Queue;\n+\n+/**\n+ * Dynamic trie structure that can add/remove keys and recursively get matching strings for a key \n+ * \n+ * @author stzups\n+ */\n+public class Trie {\n+\n+\tprivate static final int MAX_RETURNS = 100;\n+\t/**\n+\t * TrieNode implementation that handles any character and keeps track of its own children and character\n+\t */\n+\tpublic static class TrieNode {\n+\t\tList<TrieNode> children = new ArrayList<>();\n+\t\tchar character;\n+\t\tboolean endOfWord = false;\n+\n+\t\tTrieNode(char character) {\n+\t\t\tthis.character = character;\n+\t\t}\n+\t}\n+\n+\tprivate final TrieNode root;\n+\n+\t/**\n+\t * Constructor that creates a new trie with a null root\n+\t */\n+\tpublic Trie() {\n+\t\troot = new TrieNode(Character.MIN_VALUE);\n+\t}\n+\n+\t/**\n+\t * Adds and links new TrieNodes to the trie for each character in the string\n+\t * \n+\t * @param key key to add to trie, can be longer than one character\n+\t */\n+\tpublic void addKey(String key) {\n+\n+\t\t// Current trieNode to crawl through\n+\t\tTrieNode trieNode = root;\n+\n+\t\t// Loop through each character of key\n+\t\tfor (int i = 0; i < key.length(); i++) {\n+\t\t\tchar index = Character.toLowerCase(key.charAt(i)); // Case insensitive\n+\n+\t\t\tTrieNode lastNode = trieNode;\n+\t\t\tOptional<TrieNode> optional = lastNode.children.stream().filter(e -> e.character==index).findFirst();\n+\n+\t\t\tif (!optional.isPresent()) { // No existing TrieNode here, so make a new one\n+\t\t\t\ttrieNode = new TrieNode(index);\n+\t\t\t\tlastNode.children.add(trieNode); // Put this node as one of lastNode's children\n+\t\t\t} else {\n+\t\t\t\ttrieNode = optional.get();\n+\t\t\t}\n+\n+\t\t\tif (i == key.length()-1) { // Check if this is the last character of the key, indicating a word ending\n+\t\t\t\ttrieNode.endOfWord = true;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Removes TrieNodes for a key\n+\t * \n+\t * @param key key to remove\n+\t */\n+\tpublic void removeKey(String key) {\n+\t\t// Current trieNode to crawl through\n+\t\tTrieNode trieNode = root;\n+\t\tQueue<TrieNode> found = Collections.asLifoQueue(new LinkedList<>());\n+\n+\t\t// Loop through each character of key\n+\t\tfor (int i = 0; i < key.length(); i++) {\n+\t\t\tchar index = Character.toLowerCase(key.charAt(i)); // Case insensitive\n+\n+\t\t\tTrieNode lastNode = trieNode;\n+\t\t\t//found.add(lastNode); // Adds to list of TrieNodes to remove", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8721d5af5b41139b277c5ff8359f57c76889c5b"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1298, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}