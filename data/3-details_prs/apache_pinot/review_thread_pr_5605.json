{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4MjM1MTQx", "number": 5605, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODoxNToxNFrOEIFOmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMzoxNToxN1rOEIjy2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTA5NzIwOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/CombineGroupByOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODoxNToxNFrOGn1D7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxOTo0Nzo0NFrOGn4GNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzAwNQ==", "bodyText": "Perhaps add something to indicate that this is the combine phase? For example, Caught exception in combine phase of group-by...?", "url": "https://github.com/apache/pinot/pull/5605#discussion_r444417005", "createdAt": "2020-06-23T18:15:14Z", "author": {"login": "mayankshriv"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/CombineGroupByOperator.java", "diffHunk": "@@ -174,8 +173,8 @@ public void runJob() {\n           } catch (EarlyTerminationException e) {\n             // Early-terminated because query times out or is already satisfied\n           } catch (Exception e) {\n-            LOGGER.error(\"Exception processing CombineGroupBy for index {}, operator {}, brokerRequest {}\", index,\n-                _operators.get(index).getClass().getName(), _brokerRequest, e);\n+            LOGGER.error(\"Caught exception while processing group-by for index: {}, operator: {}, queryContext: {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bca3ed7c22eaeb0cccf971f7c3d061c64cdd3c6"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2Njc0MA==", "bodyText": "Added", "url": "https://github.com/apache/pinot/pull/5605#discussion_r444466740", "createdAt": "2020-06-23T19:47:44Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/CombineGroupByOperator.java", "diffHunk": "@@ -174,8 +173,8 @@ public void runJob() {\n           } catch (EarlyTerminationException e) {\n             // Early-terminated because query times out or is already satisfied\n           } catch (Exception e) {\n-            LOGGER.error(\"Exception processing CombineGroupBy for index {}, operator {}, brokerRequest {}\", index,\n-                _operators.get(index).getClass().getName(), _brokerRequest, e);\n+            LOGGER.error(\"Caught exception while processing group-by for index: {}, operator: {}, queryContext: {}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzAwNQ=="}, "originalCommit": {"oid": "9bca3ed7c22eaeb0cccf971f7c3d061c64cdd3c6"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzQwMTg3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/SimpleIndexedTable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTowNjo0M1rOGofXQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo1MDoxOVrOGogwOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMDA4Mg==", "bodyText": "Shouldn't this be replaced with FunctionContext?", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445110082", "createdAt": "2020-06-24T19:06:43Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/SimpleIndexedTable.java", "diffHunk": "@@ -49,12 +50,12 @@\n    * Initializes the data structures needed for this Table\n    * @param dataSchema data schema of the record's keys and values\n    * @param aggregationFunctions aggregation functions for the record's values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzMjg1OA==", "bodyText": "No. AggregationFunction is the execution class instead of the info class. FunctionContext will replace AggregationInfo in the following PR of replacing BrokerRequest classes in aggregation and transform functions", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445132858", "createdAt": "2020-06-24T19:50:19Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/table/SimpleIndexedTable.java", "diffHunk": "@@ -49,12 +50,12 @@\n    * Initializes the data structures needed for this Table\n    * @param dataSchema data schema of the record's keys and values\n    * @param aggregationFunctions aggregation functions for the record's values", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMDA4Mg=="}, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzU3ODA5OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo1OTo1NFrOGohD4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMToyNTozNlrOGojrRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzg5MQ==", "bodyText": "I am not sure why we had to change the logic. We already have support for schema mapping for a column right? getFinalSchemaMapIdx() is supposed to do that.", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445137891", "createdAt": "2020-06-24T19:59:54Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MDc0MA==", "bodyText": "getFinalSchemaMapIdx is renamed to getSelectExpressionIndexMap for readability.\nThe existing logic keeps the sql query check inside the loop, which is not efficient and not as readable IMO. The change makes the sql query check at the top level, and once we move to SQL completely, we can simply remove the else part.", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445180740", "createdAt": "2020-06-24T21:25:36Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzg5MQ=="}, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzU4NTI4OnYy", "diffSide": "LEFT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDowMTo1N1rOGohIPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMToyNzoyOFrOGojugg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzOTAwNQ==", "bodyText": "This existing logic seems simpler", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445139005", "createdAt": "2020-06-24T20:01:57Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {\n+      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n+\n+      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();\n+      int numSelectExpressions = selectExpressionIndexMap.length;\n+      String[] columnNames = resultTableSchema.getColumnNames();\n+      DataSchema.ColumnDataType[] columnDataTypes = resultTableSchema.getColumnDataTypes();\n+      String[] reorderedColumnNames = new String[numSelectExpressions];\n+      DataSchema.ColumnDataType[] reorderedColumnDataTypes = new DataSchema.ColumnDataType[numSelectExpressions];\n+      resultTableSchema = new DataSchema(reorderedColumnNames, reorderedColumnDataTypes);\n+      for (int i = 0; i < numSelectExpressions; i++) {\n+        reorderedColumnNames[i] = columnNames[selectExpressionIndexMap[i]];\n+        reorderedColumnDataTypes[i] = columnDataTypes[selectExpressionIndexMap[i]];\n       }\n-      if (_sqlSelectionList != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MTU3MA==", "bodyText": "I don't think so. The existing logic have the same if condition in 3 places (line 178, 195, 208), and this one is even in a while loop. Instead, the change makes it one time branching, which is much more clear IMO.", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445181570", "createdAt": "2020-06-24T21:27:28Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {\n+      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n+\n+      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();\n+      int numSelectExpressions = selectExpressionIndexMap.length;\n+      String[] columnNames = resultTableSchema.getColumnNames();\n+      DataSchema.ColumnDataType[] columnDataTypes = resultTableSchema.getColumnDataTypes();\n+      String[] reorderedColumnNames = new String[numSelectExpressions];\n+      DataSchema.ColumnDataType[] reorderedColumnDataTypes = new DataSchema.ColumnDataType[numSelectExpressions];\n+      resultTableSchema = new DataSchema(reorderedColumnNames, reorderedColumnDataTypes);\n+      for (int i = 0; i < numSelectExpressions; i++) {\n+        reorderedColumnNames[i] = columnNames[selectExpressionIndexMap[i]];\n+        reorderedColumnDataTypes[i] = columnDataTypes[selectExpressionIndexMap[i]];\n       }\n-      if (_sqlSelectionList != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzOTAwNQ=="}, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzYyNTg3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDoxNToyM1rOGohihw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMToyODo0MFrOGojwuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0NTczNQ==", "bodyText": "We should actually consider deleting this. We should not mix PQL with SQL. This code path is for PQL execution but SQL response format. We should not let users avail that. Ideally, it should be\nSQL query -> SQL execution -> SQL response\nPQL query -> PQL execution -> PQL response\nThe functions in this class are extraordinarily large in size and the code looks very confusing because of these branches (not related to this PR)", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445145735", "createdAt": "2020-06-24T20:15:23Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -486,69 +447,44 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, boolea\n       finalResultMaps[i] = finalResultMap;\n     }\n \n-    int aggregationNumsInFinalResult = 0;\n-    for (int i = 0; i < _numAggregationFunctions; i++) {\n-      if (aggregationFunctionsSelectStatus[i]) {\n-        aggregationNumsInFinalResult++;\n-      }\n-    }\n-\n-    if (aggregationNumsInFinalResult > 0) {\n-      String[] finalColumnNames = new String[aggregationNumsInFinalResult];\n-      Map<String, Comparable>[] finalOutResultMaps = new Map[aggregationNumsInFinalResult];\n-      String[] finalResultTableAggNames = new String[aggregationNumsInFinalResult];\n-      AggregationFunction[] finalAggregationFunctions = new AggregationFunction[aggregationNumsInFinalResult];\n-      int count = 0;\n-      for (int i = 0; i < _numAggregationFunctions; i++) {\n-        if (aggregationFunctionsSelectStatus[i]) {\n-          finalColumnNames[count] = columnNames[i];\n-          finalOutResultMaps[count] = finalResultMaps[i];\n-          AggregationFunction aggregationFunction = _aggregationFunctions[i];\n-          finalResultTableAggNames[count] = aggregationFunction.getResultColumnName();\n-          finalAggregationFunctions[count] = aggregationFunction;\n-          count++;\n+    // Trim the final result maps and set them into the broker response.\n+    AggregationGroupByTrimmingService aggregationGroupByTrimmingService =\n+        new AggregationGroupByTrimmingService(_aggregationFunctions, _queryContext.getLimit());\n+    List<GroupByResult>[] groupByResultLists = aggregationGroupByTrimmingService.trimFinalResults(finalResultMaps);\n+\n+    if (_responseFormatSql) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 393}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MjEzNg==", "bodyText": "Agree, but we have to keep this behavior for backward-compatibility.\nOnce we deprecate PQL semantic, all these checks will gone", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445182136", "createdAt": "2020-06-24T21:28:40Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -486,69 +447,44 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, boolea\n       finalResultMaps[i] = finalResultMap;\n     }\n \n-    int aggregationNumsInFinalResult = 0;\n-    for (int i = 0; i < _numAggregationFunctions; i++) {\n-      if (aggregationFunctionsSelectStatus[i]) {\n-        aggregationNumsInFinalResult++;\n-      }\n-    }\n-\n-    if (aggregationNumsInFinalResult > 0) {\n-      String[] finalColumnNames = new String[aggregationNumsInFinalResult];\n-      Map<String, Comparable>[] finalOutResultMaps = new Map[aggregationNumsInFinalResult];\n-      String[] finalResultTableAggNames = new String[aggregationNumsInFinalResult];\n-      AggregationFunction[] finalAggregationFunctions = new AggregationFunction[aggregationNumsInFinalResult];\n-      int count = 0;\n-      for (int i = 0; i < _numAggregationFunctions; i++) {\n-        if (aggregationFunctionsSelectStatus[i]) {\n-          finalColumnNames[count] = columnNames[i];\n-          finalOutResultMaps[count] = finalResultMaps[i];\n-          AggregationFunction aggregationFunction = _aggregationFunctions[i];\n-          finalResultTableAggNames[count] = aggregationFunction.getResultColumnName();\n-          finalAggregationFunctions[count] = aggregationFunction;\n-          count++;\n+    // Trim the final result maps and set them into the broker response.\n+    AggregationGroupByTrimmingService aggregationGroupByTrimmingService =\n+        new AggregationGroupByTrimmingService(_aggregationFunctions, _queryContext.getLimit());\n+    List<GroupByResult>[] groupByResultLists = aggregationGroupByTrimmingService.trimFinalResults(finalResultMaps);\n+\n+    if (_responseFormatSql) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0NTczNQ=="}, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 393}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzY0MTUyOnYy", "diffSide": "LEFT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDoyMDoyN1rOGohsiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTozMTo1OFrOGoj2iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0ODI5OQ==", "bodyText": "Looks like this piece of code was redundant and that'w why you invoke trimming on already computed finalResultMaps in the new code?", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445148299", "createdAt": "2020-06-24T20:20:27Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -486,69 +447,44 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, boolea\n       finalResultMaps[i] = finalResultMap;\n     }\n \n-    int aggregationNumsInFinalResult = 0;\n-    for (int i = 0; i < _numAggregationFunctions; i++) {\n-      if (aggregationFunctionsSelectStatus[i]) {\n-        aggregationNumsInFinalResult++;\n-      }\n-    }\n-\n-    if (aggregationNumsInFinalResult > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MzYyNw==", "bodyText": "The aggregationFunctionsSelectStatus is redundant (was introduced for HAVING clause), and thus this if check is no longer valid (always true). This part of the code is the same as before, the only change is the indentation.", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445183627", "createdAt": "2020-06-24T21:31:58Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -486,69 +447,44 @@ private void setGroupByResults(BrokerResponseNative brokerResponseNative, boolea\n       finalResultMaps[i] = finalResultMap;\n     }\n \n-    int aggregationNumsInFinalResult = 0;\n-    for (int i = 0; i < _numAggregationFunctions; i++) {\n-      if (aggregationFunctionsSelectStatus[i]) {\n-        aggregationNumsInFinalResult++;\n-      }\n-    }\n-\n-    if (aggregationNumsInFinalResult > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0ODI5OQ=="}, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 374}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDEwMjI3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMzoxMzo0M1rOGomJ8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMzozMjoxN1rOGomgqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyMTM2MQ==", "bodyText": "It will be good to add a comment here stating that this is for the code path for PQL query compiled by PQLCompiler but having both the options (groupByModeSql and responseFormatSqL to true).", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445221361", "createdAt": "2020-06-24T23:13:43Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {\n+      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n+\n+      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();\n+      int numSelectExpressions = selectExpressionIndexMap.length;\n+      String[] columnNames = resultTableSchema.getColumnNames();\n+      DataSchema.ColumnDataType[] columnDataTypes = resultTableSchema.getColumnDataTypes();\n+      String[] reorderedColumnNames = new String[numSelectExpressions];\n+      DataSchema.ColumnDataType[] reorderedColumnDataTypes = new DataSchema.ColumnDataType[numSelectExpressions];\n+      resultTableSchema = new DataSchema(reorderedColumnNames, reorderedColumnDataTypes);\n+      for (int i = 0; i < numSelectExpressions; i++) {\n+        reorderedColumnNames[i] = columnNames[selectExpressionIndexMap[i]];\n+        reorderedColumnDataTypes[i] = columnDataTypes[selectExpressionIndexMap[i]];\n       }\n-      if (_sqlSelectionList != null) {\n-        Object[] finalValues = new Object[_sqlSelectionList.size()];\n-        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n-          finalValues[i] = values[finalSchemaMapIdx[i]];\n+      while (rows.size() < limit && sortedIterator.hasNext()) {\n+        Record nextRecord = sortedIterator.next();\n+        Object[] values = nextRecord.getValues();\n+        for (int i = 0; i < _numAggregationFunctions; i++) {\n+          int valueIndex = i + _numGroupByExpressions;\n+          values[valueIndex] = AggregationFunctionUtils\n+              .getSerializableValue(_aggregationFunctions[i].extractFinalResult(values[valueIndex]));\n         }\n-        rows.add(finalValues);\n-      } else {\n-        rows.add(values);\n-      }\n-      numRows++;\n-    }\n \n-    DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n-    if (_sqlSelectionList != null) {\n-      int columnSize = _sqlSelectionList.size();\n-      String[] columns = new String[columnSize];\n-      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n-      for (int i = 0; i < columnSize; i++) {\n-        columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n-        columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        Object[] reorderedValues = new Object[numSelectExpressions];\n+        for (int i = 0; i < numSelectExpressions; i++) {\n+          reorderedValues[i] = values[selectExpressionIndexMap[i]];\n+        }\n+        rows.add(reorderedValues);\n       }\n-      finalDataSchema = new DataSchema(columns, columnDataTypes);\n-    }\n-    brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n-  }\n-\n-  /**\n-   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n-   * then aggregation functions.\n-   *\n-   * @return a mapping from final schema idx to corresponding idx in data table schema.\n-   */\n-  private int[] getFinalSchemaMapIdx() {\n-    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n-    int nextAggregationIdx = _numGroupBy;\n-    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n-      finalSchemaMapIdx[i] = getExpressionMapIdx(_sqlSelectionList.get(i), nextAggregationIdx);\n-      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n-        nextAggregationIdx++;\n+    } else {\n+      while (rows.size() < limit && sortedIterator.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyNzE3OA==", "bodyText": "Added", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445227178", "createdAt": "2020-06-24T23:32:17Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {\n+      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n+\n+      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();\n+      int numSelectExpressions = selectExpressionIndexMap.length;\n+      String[] columnNames = resultTableSchema.getColumnNames();\n+      DataSchema.ColumnDataType[] columnDataTypes = resultTableSchema.getColumnDataTypes();\n+      String[] reorderedColumnNames = new String[numSelectExpressions];\n+      DataSchema.ColumnDataType[] reorderedColumnDataTypes = new DataSchema.ColumnDataType[numSelectExpressions];\n+      resultTableSchema = new DataSchema(reorderedColumnNames, reorderedColumnDataTypes);\n+      for (int i = 0; i < numSelectExpressions; i++) {\n+        reorderedColumnNames[i] = columnNames[selectExpressionIndexMap[i]];\n+        reorderedColumnDataTypes[i] = columnDataTypes[selectExpressionIndexMap[i]];\n       }\n-      if (_sqlSelectionList != null) {\n-        Object[] finalValues = new Object[_sqlSelectionList.size()];\n-        for (int i = 0; i < finalSchemaMapIdx.length; i++) {\n-          finalValues[i] = values[finalSchemaMapIdx[i]];\n+      while (rows.size() < limit && sortedIterator.hasNext()) {\n+        Record nextRecord = sortedIterator.next();\n+        Object[] values = nextRecord.getValues();\n+        for (int i = 0; i < _numAggregationFunctions; i++) {\n+          int valueIndex = i + _numGroupByExpressions;\n+          values[valueIndex] = AggregationFunctionUtils\n+              .getSerializableValue(_aggregationFunctions[i].extractFinalResult(values[valueIndex]));\n         }\n-        rows.add(finalValues);\n-      } else {\n-        rows.add(values);\n-      }\n-      numRows++;\n-    }\n \n-    DataSchema finalDataSchema = getSQLResultTableSchema(dataSchema);\n-    if (_sqlSelectionList != null) {\n-      int columnSize = _sqlSelectionList.size();\n-      String[] columns = new String[columnSize];\n-      DataSchema.ColumnDataType[] columnDataTypes = new DataSchema.ColumnDataType[columnSize];\n-      for (int i = 0; i < columnSize; i++) {\n-        columns[i] = finalDataSchema.getColumnName(finalSchemaMapIdx[i]);\n-        columnDataTypes[i] = finalDataSchema.getColumnDataType(finalSchemaMapIdx[i]);\n+        Object[] reorderedValues = new Object[numSelectExpressions];\n+        for (int i = 0; i < numSelectExpressions; i++) {\n+          reorderedValues[i] = values[selectExpressionIndexMap[i]];\n+        }\n+        rows.add(reorderedValues);\n       }\n-      finalDataSchema = new DataSchema(columns, columnDataTypes);\n-    }\n-    brokerResponseNative.setResultTable(new ResultTable(finalDataSchema, rows));\n-  }\n-\n-  /**\n-   * Generate index mapping based on selection expression to DataTable schema, which is groupBy columns,\n-   * then aggregation functions.\n-   *\n-   * @return a mapping from final schema idx to corresponding idx in data table schema.\n-   */\n-  private int[] getFinalSchemaMapIdx() {\n-    int[] finalSchemaMapIdx = new int[_sqlSelectionList.size()];\n-    int nextAggregationIdx = _numGroupBy;\n-    for (int i = 0; i < _sqlSelectionList.size(); i++) {\n-      finalSchemaMapIdx[i] = getExpressionMapIdx(_sqlSelectionList.get(i), nextAggregationIdx);\n-      if (finalSchemaMapIdx[i] == nextAggregationIdx) {\n-        nextAggregationIdx++;\n+    } else {\n+      while (rows.size() < limit && sortedIterator.hasNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyMTM2MQ=="}, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDEwNTIxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMzoxNToxN1rOGomLyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMzoyOToyMFrOGomdSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyMTgzMw==", "bodyText": "Should add a comment here that this is for SQL query compiled by calcite compiler, parser and having both the options (groupByModeSql and responseFormatSqL to true). Eventually we just want this path (SQL only) after PQL is completely deleted.", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445221833", "createdAt": "2020-06-24T23:15:17Z", "author": {"login": "siddharthteotia"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {\n+      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n+\n+      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyNjMxMg==", "bodyText": "Good point, added", "url": "https://github.com/apache/pinot/pull/5605#discussion_r445226312", "createdAt": "2020-06-24T23:29:20Z", "author": {"login": "Jackie-Jiang"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/query/reduce/GroupByDataTableReducer.java", "diffHunk": "@@ -171,106 +160,81 @@ public void reduceAndSetResults(String tableName, DataSchema dataSchema,\n    */\n   private void setSQLGroupByInResultTable(BrokerResponseNative brokerResponseNative, DataSchema dataSchema,\n       Collection<DataTable> dataTables) {\n-\n+    DataSchema resultTableSchema = getSQLResultTableSchema(dataSchema);\n     IndexedTable indexedTable = getIndexedTable(dataSchema, dataTables);\n-\n-    int[] finalSchemaMapIdx = null;\n-    if (_sqlSelectionList != null) {\n-      finalSchemaMapIdx = getFinalSchemaMapIdx();\n-    }\n-    List<Object[]> rows = new ArrayList<>();\n     Iterator<Record> sortedIterator = indexedTable.iterator();\n-    int numRows = 0;\n-    while (numRows < _groupBy.getTopN() && sortedIterator.hasNext()) {\n-      Record nextRecord = sortedIterator.next();\n-      Object[] values = nextRecord.getValues();\n-\n-      int index = _numGroupBy;\n-      int aggNum = 0;\n-      while (index < _numColumns) {\n-        values[index] = AggregationFunctionUtils\n-            .getSerializableValue(_aggregationFunctions[aggNum++].extractFinalResult(values[index]));\n-        index++;\n+    int limit = _queryContext.getLimit();\n+    List<Object[]> rows = new ArrayList<>(limit);\n+\n+    if (_sqlQuery) {\n+      // NOTE: For SQL query, need to reorder the columns in the data table based on the select expressions.\n+\n+      int[] selectExpressionIndexMap = getSelectExpressionIndexMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyMTgzMw=="}, "originalCommit": {"oid": "d30362c59114fa71f9d03d30a55c64a54b10382f"}, "originalPosition": 133}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4365, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}