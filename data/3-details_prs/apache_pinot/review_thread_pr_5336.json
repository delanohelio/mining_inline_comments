{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzNzU1NjU2", "number": 5336, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjo0ODo1N1rOD5m5Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMToyNDowNlrOELDrIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzMyNjk0OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjo0ODo1N1rOGQ-YiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMTowNTo1MlrOGZHn6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1MjQ4OA==", "bodyText": "We dont need this logger right? We can use _logger ?", "url": "https://github.com/apache/pinot/pull/5336#discussion_r420452488", "createdAt": "2020-05-05T22:48:57Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.plugin.PluginManager;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    server:///segment_name\n+ * Note the host component is empty.\n+ * To use this segment fetcher, servers need to put \"server\" in their segment fetcher protocol.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PeerServerSegmentFetcher.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf043cc8b76fe36ddea821a440e1bbca326de2fd"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk5MjQ5MQ==", "bodyText": "done.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r428992491", "createdAt": "2020-05-22T01:05:52Z", "author": {"login": "chenboat"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.plugin.PluginManager;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    server:///segment_name\n+ * Note the host component is empty.\n+ * To use this segment fetcher, servers need to put \"server\" in their segment fetcher protocol.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PeerServerSegmentFetcher.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1MjQ4OA=="}, "originalCommit": {"oid": "bf043cc8b76fe36ddea821a440e1bbca326de2fd"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzMzMDI4OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjo0OTo1NVrOGQ-aVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMTowNjoxNlrOGZHoQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1Mjk0OQ==", "bodyText": "nit: I would declare the DOWNLOADER_CLASS without the starting dot, and add the intermediate dot here.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r420452949", "createdAt": "2020-05-05T22:49:55Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.plugin.PluginManager;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    server:///segment_name\n+ * Note the host component is empty.\n+ * To use this segment fetcher, servers need to put \"server\" in their segment fetcher protocol.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PeerServerSegmentFetcher.class);\n+  private static final String PEER_2_PEER_PROTOCOL = \"server\";\n+  private static final String DOWNLOADER_CLASS = \".downloader.class\";\n+  private HelixManager _helixManager;\n+  private String _helixClusterName;\n+  private HttpSegmentFetcher _httpSegmentFetcher;\n+\n+  public PeerServerSegmentFetcher(Configuration config, HelixManager helixManager, String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    String segmentDownloaderClass = config.getString(PEER_2_PEER_PROTOCOL + DOWNLOADER_CLASS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf043cc8b76fe36ddea821a440e1bbca326de2fd"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk5MjU3OA==", "bodyText": "not applicable anymore as the this config value is not used.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r428992578", "createdAt": "2020-05-22T01:06:16Z", "author": {"login": "chenboat"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.plugin.PluginManager;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    server:///segment_name\n+ * Note the host component is empty.\n+ * To use this segment fetcher, servers need to put \"server\" in their segment fetcher protocol.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PeerServerSegmentFetcher.class);\n+  private static final String PEER_2_PEER_PROTOCOL = \"server\";\n+  private static final String DOWNLOADER_CLASS = \".downloader.class\";\n+  private HelixManager _helixManager;\n+  private String _helixClusterName;\n+  private HttpSegmentFetcher _httpSegmentFetcher;\n+\n+  public PeerServerSegmentFetcher(Configuration config, HelixManager helixManager, String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    String segmentDownloaderClass = config.getString(PEER_2_PEER_PROTOCOL + DOWNLOADER_CLASS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1Mjk0OQ=="}, "originalCommit": {"oid": "bf043cc8b76fe36ddea821a440e1bbca326de2fd"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzQzMTgyOnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzozMTowNVrOGQ_UPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxMzozOVrOGS25lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2Nzc3NA==", "bodyText": "So, essentially we are saying that it can either be http or https segment fetcher (or some other class that extends from these), right? We need to get the config story right. Can we configure just the scheme and construct the rest of the url here and initialize the right fetcher? Do you anticipate any other class than these two being used?", "url": "https://github.com/apache/pinot/pull/5336#discussion_r420467774", "createdAt": "2020-05-05T23:31:05Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.plugin.PluginManager;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    server:///segment_name\n+ * Note the host component is empty.\n+ * To use this segment fetcher, servers need to put \"server\" in their segment fetcher protocol.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PeerServerSegmentFetcher.class);\n+  private static final String PEER_2_PEER_PROTOCOL = \"server\";\n+  private static final String DOWNLOADER_CLASS = \".downloader.class\";\n+  private HelixManager _helixManager;\n+  private String _helixClusterName;\n+  private HttpSegmentFetcher _httpSegmentFetcher;\n+\n+  public PeerServerSegmentFetcher(Configuration config, HelixManager helixManager, String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    String segmentDownloaderClass = config.getString(PEER_2_PEER_PROTOCOL + DOWNLOADER_CLASS);\n+    try {\n+      _httpSegmentFetcher = PluginManager.get().createInstance(segmentDownloaderClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf043cc8b76fe36ddea821a440e1bbca326de2fd"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTcxNw==", "bodyText": "Because this fetcher download segments from peer servers, http and https segment fetchers would be sufficient for usage considering the download API server supports.\nWhat do you mean \"construct the rest of the url here\"?  In the constructor? The complete url is a function of segment and we do not have segment info here. Right now the server discovery and url construction is done in per segment fetch basis. @mcvsubbu", "url": "https://github.com/apache/pinot/pull/5336#discussion_r422361717", "createdAt": "2020-05-08T20:38:03Z", "author": {"login": "chenboat"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.plugin.PluginManager;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    server:///segment_name\n+ * Note the host component is empty.\n+ * To use this segment fetcher, servers need to put \"server\" in their segment fetcher protocol.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PeerServerSegmentFetcher.class);\n+  private static final String PEER_2_PEER_PROTOCOL = \"server\";\n+  private static final String DOWNLOADER_CLASS = \".downloader.class\";\n+  private HelixManager _helixManager;\n+  private String _helixClusterName;\n+  private HttpSegmentFetcher _httpSegmentFetcher;\n+\n+  public PeerServerSegmentFetcher(Configuration config, HelixManager helixManager, String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    String segmentDownloaderClass = config.getString(PEER_2_PEER_PROTOCOL + DOWNLOADER_CLASS);\n+    try {\n+      _httpSegmentFetcher = PluginManager.get().createInstance(segmentDownloaderClass);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2Nzc3NA=="}, "originalCommit": {"oid": "bf043cc8b76fe36ddea821a440e1bbca326de2fd"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM4NzQ3Mg==", "bodyText": "I meant construct uri in this class (like you are doing) but based on the configured scheme", "url": "https://github.com/apache/pinot/pull/5336#discussion_r422387472", "createdAt": "2020-05-08T21:37:04Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.plugin.PluginManager;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    server:///segment_name\n+ * Note the host component is empty.\n+ * To use this segment fetcher, servers need to put \"server\" in their segment fetcher protocol.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PeerServerSegmentFetcher.class);\n+  private static final String PEER_2_PEER_PROTOCOL = \"server\";\n+  private static final String DOWNLOADER_CLASS = \".downloader.class\";\n+  private HelixManager _helixManager;\n+  private String _helixClusterName;\n+  private HttpSegmentFetcher _httpSegmentFetcher;\n+\n+  public PeerServerSegmentFetcher(Configuration config, HelixManager helixManager, String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    String segmentDownloaderClass = config.getString(PEER_2_PEER_PROTOCOL + DOWNLOADER_CLASS);\n+    try {\n+      _httpSegmentFetcher = PluginManager.get().createInstance(segmentDownloaderClass);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2Nzc3NA=="}, "originalCommit": {"oid": "bf043cc8b76fe36ddea821a440e1bbca326de2fd"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzAzMQ==", "bodyText": "The config I use now passed in the fetcher class (mainly for ease of testing). I can pass in scheme (http or https) too together with the class. But let us put this config choice in a broader discussion we had offline so that we plan everything in one discussion. The updated design is here: https://cwiki.apache.org/confluence/display/PINOT/By-passing+deep-store+requirement+for+Realtime+segment+completion#By-passingdeep-storerequirementforRealtimesegmentcompletion-Configchange", "url": "https://github.com/apache/pinot/pull/5336#discussion_r422427031", "createdAt": "2020-05-09T00:13:39Z", "author": {"login": "chenboat"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.plugin.PluginManager;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    server:///segment_name\n+ * Note the host component is empty.\n+ * To use this segment fetcher, servers need to put \"server\" in their segment fetcher protocol.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(PeerServerSegmentFetcher.class);\n+  private static final String PEER_2_PEER_PROTOCOL = \"server\";\n+  private static final String DOWNLOADER_CLASS = \".downloader.class\";\n+  private HelixManager _helixManager;\n+  private String _helixClusterName;\n+  private HttpSegmentFetcher _httpSegmentFetcher;\n+\n+  public PeerServerSegmentFetcher(Configuration config, HelixManager helixManager, String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    String segmentDownloaderClass = config.getString(PEER_2_PEER_PROTOCOL + DOWNLOADER_CLASS);\n+    try {\n+      _httpSegmentFetcher = PluginManager.get().createInstance(segmentDownloaderClass);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2Nzc3NA=="}, "originalCommit": {"oid": "bf043cc8b76fe36ddea821a440e1bbca326de2fd"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDU4MzA5OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMTozODozMlrOGeE4Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNzowNzo1NFrOGpD9_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MDM2Nw==", "bodyText": "we should get the config from the tableConfig", "url": "https://github.com/apache/pinot/pull/5336#discussion_r434190367", "createdAt": "2020-06-02T21:38:32Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    peer:///segment_name\n+ * Note the host component is empty.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final String PEER_2_PEER_PROTOCOL = \"peer\";\n+  private static final String PEER_SEGMENT_DOWNLOAD_SCHEME = \"peerSegmentDownloadScheme\";\n+  private HelixManager _helixManager;\n+  private String _helixClusterName;\n+  private HttpSegmentFetcher _httpSegmentFetcher;\n+  // The value is either https or http\n+  private final String _httpScheme;\n+\n+  public PeerServerSegmentFetcher(Configuration config, HelixManager helixManager, String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    switch (config.getString(PEER_SEGMENT_DOWNLOAD_SCHEME)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d86bec8d8a1b6aa51c21948a0400907520c6ef4"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcwOTgyMA==", "bodyText": "this is obsolete now.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r445709820", "createdAt": "2020-06-25T17:07:54Z", "author": {"login": "chenboat"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    peer:///segment_name\n+ * Note the host component is empty.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final String PEER_2_PEER_PROTOCOL = \"peer\";\n+  private static final String PEER_SEGMENT_DOWNLOAD_SCHEME = \"peerSegmentDownloadScheme\";\n+  private HelixManager _helixManager;\n+  private String _helixClusterName;\n+  private HttpSegmentFetcher _httpSegmentFetcher;\n+  // The value is either https or http\n+  private final String _httpScheme;\n+\n+  public PeerServerSegmentFetcher(Configuration config, HelixManager helixManager, String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    switch (config.getString(PEER_SEGMENT_DOWNLOAD_SCHEME)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MDM2Nw=="}, "originalCommit": {"oid": "3d86bec8d8a1b6aa51c21948a0400907520c6ef4"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDU4NjI3OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMTozOTo0MVrOGeE6Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMTozOTo0MVrOGeE6Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MDg4Nw==", "bodyText": "Change these to some definitions in constants class (or, they may already be there). Use those constants in PR#5478 as well, instead of hard-coded strings", "url": "https://github.com/apache/pinot/pull/5336#discussion_r434190887", "createdAt": "2020-06-02T21:39:41Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    peer:///segment_name\n+ * Note the host component is empty.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final String PEER_2_PEER_PROTOCOL = \"peer\";\n+  private static final String PEER_SEGMENT_DOWNLOAD_SCHEME = \"peerSegmentDownloadScheme\";\n+  private HelixManager _helixManager;\n+  private String _helixClusterName;\n+  private HttpSegmentFetcher _httpSegmentFetcher;\n+  // The value is either https or http\n+  private final String _httpScheme;\n+\n+  public PeerServerSegmentFetcher(Configuration config, HelixManager helixManager, String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    switch (config.getString(PEER_SEGMENT_DOWNLOAD_SCHEME)) {\n+      case \"https\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d86bec8d8a1b6aa51c21948a0400907520c6ef4"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDU5MTYyOnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMTo0MTo0NFrOGeE9mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMTo0MTo0NFrOGeE9mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MTc2OQ==", "bodyText": "Not sure how the peer-2-peer protocol plays here. Caller can create an http segment fetcher, or https segment fetcher based on the table config, right? The only extra logic that the caller needs is the construction of a URL. Maybe that can be in a utils class, or just in the caller as a method (if it is used by exactly one caller)", "url": "https://github.com/apache/pinot/pull/5336#discussion_r434191769", "createdAt": "2020-06-02T21:41:44Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/PeerServerSegmentFetcher.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.common.utils.fetcher;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import org.apache.commons.configuration.Configuration;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+\n+/**\n+ * This segment fetcher downloads the segment by first discovering the server having the segment through external view\n+ * of a Pinot table and then downloading the segment from the peer server using a configured http or https fetcher. By\n+ * default, HttpSegmentFetcher is used.\n+ * The format fo expected segment address uri is\n+ *    peer:///segment_name\n+ * Note the host component is empty.\n+ */\n+public class PeerServerSegmentFetcher extends BaseSegmentFetcher {\n+  private static final String PEER_2_PEER_PROTOCOL = \"peer\";\n+  private static final String PEER_SEGMENT_DOWNLOAD_SCHEME = \"peerSegmentDownloadScheme\";\n+  private HelixManager _helixManager;\n+  private String _helixClusterName;\n+  private HttpSegmentFetcher _httpSegmentFetcher;\n+  // The value is either https or http\n+  private final String _httpScheme;\n+\n+  public PeerServerSegmentFetcher(Configuration config, HelixManager helixManager, String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    switch (config.getString(PEER_SEGMENT_DOWNLOAD_SCHEME)) {\n+      case \"https\":\n+        _httpSegmentFetcher = new HttpsSegmentFetcher();\n+        _httpScheme = \"https\";\n+        break;\n+      default:\n+        _httpSegmentFetcher = new HttpSegmentFetcher();\n+        _httpScheme = \"http\";\n+    }\n+    _httpSegmentFetcher.init(config);\n+  }\n+\n+  public PeerServerSegmentFetcher(HttpSegmentFetcher httpSegmentFetcher, String httpScheme, HelixManager helixManager,\n+      String helixClusterName) {\n+    _helixManager = helixManager;\n+    _helixClusterName = helixClusterName;\n+    _httpSegmentFetcher = httpSegmentFetcher;\n+    _httpScheme = httpScheme;\n+  }\n+\n+  @Override\n+  public void fetchSegmentToLocalWithoutRetry(URI uri, File dest)\n+      throws Exception {\n+    if (!PEER_2_PEER_PROTOCOL.equals(uri.getScheme())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d86bec8d8a1b6aa51c21948a0400907520c6ef4"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTM0NzA5OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/SegmentFetcherFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjoyMzo1MVrOGgmPCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMDozNDoxOFrOGr0ejg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgzNDA1OQ==", "bodyText": "I think there a few definitions of these floating around in the code. It may be useful to take this opportunity to move it to Constants class.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r436834059", "createdAt": "2020-06-08T16:23:51Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/SegmentFetcherFactory.java", "diffHunk": "@@ -35,11 +35,11 @@ private SegmentFetcherFactory() {\n \n   public static final String PROTOCOLS_KEY = \"protocols\";\n   public static final String SEGMENT_FETCHER_CLASS_KEY_SUFFIX = \".class\";\n+  public static final String HTTP_PROTOCOL = \"http\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e24c6fb1e96ffd18d3486f34767dffa9b73a2ee0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYwMTc0Mg==", "bodyText": "done.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448601742", "createdAt": "2020-07-01T20:34:18Z", "author": {"login": "chenboat"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/SegmentFetcherFactory.java", "diffHunk": "@@ -35,11 +35,11 @@ private SegmentFetcherFactory() {\n \n   public static final String PROTOCOLS_KEY = \"protocols\";\n   public static final String SEGMENT_FETCHER_CLASS_KEY_SUFFIX = \".class\";\n+  public static final String HTTP_PROTOCOL = \"http\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgzNDA1OQ=="}, "originalCommit": {"oid": "e24c6fb1e96ffd18d3486f34767dffa9b73a2ee0"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTQ0NDE4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjo0ODo1MVrOGgnK4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDo1MTowNVrOGg1F3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg0OTM3Ng==", "bodyText": "\"PEER\" is an unparseable uri, so it is not a good idea to put it into the downloadUrl in metadata. It is best to leave it unset (or explicit set to null).\nI also suggest you should float metadata changes in an email like table config changes. I suggest that we should change as follows:\n(1) Change the segment completion protocol to mention \"PEER\" in the uri string (or, maybe a specific URI like \"peer://uri/of/server/segmentName\".\n(2). On the controller, if it receives a peer scheme from the server, it knows that the segment needs to be committed without a URI in the segment metadata.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r436849376", "createdAt": "2020-06-08T16:48:51Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,20 +273,81 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (!\"PEER\".equalsIgnoreCase(uri)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e24c6fb1e96ffd18d3486f34767dffa9b73a2ee0"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTQ4Mg==", "bodyText": "How about put a valid uri string like peer:///segmentName in the metadata? we do not need to specify the concrete server. When servers needs to do peer download, they will use segmentFinder.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r437075482", "createdAt": "2020-06-09T00:43:45Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,20 +273,81 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (!\"PEER\".equalsIgnoreCase(uri)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg0OTM3Ng=="}, "originalCommit": {"oid": "e24c6fb1e96ffd18d3486f34767dffa9b73a2ee0"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NzQ3MA==", "bodyText": "For sending email. yes and I will send it.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r437077470", "createdAt": "2020-06-09T00:51:05Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,20 +273,81 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (!\"PEER\".equalsIgnoreCase(uri)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg0OTM3Ng=="}, "originalCommit": {"oid": "e24c6fb1e96ffd18d3486f34767dffa9b73a2ee0"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTQ4MTAxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjo1ODo0OFrOGgnh0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODozOTozOVrOGrxQaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NTI0OQ==", "bodyText": "fetchSegmentToLocal already does retries", "url": "https://github.com/apache/pinot/pull/5336#discussion_r436855249", "createdAt": "2020-06-08T16:58:48Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,20 +273,81 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (!\"PEER\".equalsIgnoreCase(uri)) {\n+      try {\n+        downloadSegmentFromDeepStore(segmentName, indexLoadingConfig, uri);\n+      } catch (Exception e) {\n+        // Download from deep store failed; try to download from peer if peer download is setup for the table.\n+        if (isPeerSegmentDownloadEnabled(tableConfig)) {\n+          downloadSegmentFromPeer(segmentName, tableConfig.getValidationConfig().getPeerSegmentDownloadScheme(), indexLoadingConfig);\n+        } else {\n+          throw e;\n+        }\n+      }\n+    } else {\n+      if (isPeerSegmentDownloadEnabled(tableConfig)) {\n+        downloadSegmentFromPeer(segmentName, tableConfig.getValidationConfig().getPeerSegmentDownloadScheme(), indexLoadingConfig);\n+      } else {\n+        throw new RuntimeException(\"Peer segment download not enabled for segment \" + segmentName);\n+      }\n+    }\n+  }\n+\n+  private void downloadSegmentFromDeepStore(String segmentName, IndexLoadingConfig indexLoadingConfig, String uri) {\n     File tempSegmentFolder = new File(_indexDir, \"tmp-\" + segmentName + \".\" + System.currentTimeMillis());\n     File tempFile = new File(_indexDir, segmentName + \".tar.gz\");\n-    final File segmentFolder = new File(_indexDir, segmentName);\n-    FileUtils.deleteQuietly(segmentFolder);\n     try {\n       SegmentFetcherFactory.fetchSegmentToLocal(uri, tempFile);\n       _logger.info(\"Downloaded file from {} to {}; Length of downloaded file: {}\", uri, tempFile, tempFile.length());\n-      TarGzCompressionUtils.unTar(tempFile, tempSegmentFolder);\n-      _logger.info(\"Uncompressed file {} into tmp dir {}\", tempFile, tempSegmentFolder);\n-      FileUtils.moveDirectory(tempSegmentFolder.listFiles()[0], segmentFolder);\n-      _logger.info(\"Replacing LLC Segment {}\", segmentName);\n-      replaceLLSegment(segmentName, indexLoadingConfig);\n+      untarAndMoveSegment(segmentName, indexLoadingConfig, tempSegmentFolder, tempFile);\n+    } catch (Exception e) {\n+      _logger.warn(\"Failed to download segment {} from deep store: \", segmentName, e);\n+      throw new RuntimeException(e);\n+    } finally {\n+      FileUtils.deleteQuietly(tempFile);\n+      FileUtils.deleteQuietly(tempSegmentFolder);\n+    }\n+  }\n+\n+  private void untarAndMoveSegment(String segmentName, IndexLoadingConfig indexLoadingConfig, File tempSegmentFolder,\n+      File tempFile)\n+      throws IOException, ArchiveException {\n+    TarGzCompressionUtils.unTar(tempFile, tempSegmentFolder);\n+    _logger.info(\"Uncompressed file {} into tmp dir {}\", tempFile, tempSegmentFolder);\n+    final File segmentFolder = new File(_indexDir, segmentName);\n+    FileUtils.deleteQuietly(segmentFolder);\n+    FileUtils.moveDirectory(tempSegmentFolder.listFiles()[0], segmentFolder);\n+    _logger.info(\"Replacing LLC Segment {}\", segmentName);\n+    replaceLLSegment(segmentName, indexLoadingConfig);\n+  }\n+\n+  private boolean isPeerSegmentDownloadEnabled(TableConfig tableConfig) {\n+    return SegmentFetcherFactory.HTTP_PROTOCOL\n+        .equalsIgnoreCase(tableConfig.getValidationConfig().getPeerSegmentDownloadScheme())\n+        || SegmentFetcherFactory.HTTPS_PROTOCOL\n+        .equalsIgnoreCase(tableConfig.getValidationConfig().getPeerSegmentDownloadScheme());\n+  }\n+\n+  private void downloadSegmentFromPeer(String segmentName, String downloadScheme, IndexLoadingConfig indexLoadingConfig) {\n+    File tempSegmentFolder = new File(_indexDir, \"tmp-\" + segmentName + \".\" + System.currentTimeMillis());\n+    File tempFile = new File(_indexDir, segmentName + \".tar.gz\");\n+    try {\n+      RetryPolicies.exponentialBackoffRetryPolicy(RETRY_COUNT, RETRY_WAIT_MS, RETRY_DELAY_SCALE_FACTOR).attempt(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e24c6fb1e96ffd18d3486f34767dffa9b73a2ee0"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NDY3NQ==", "bodyText": "I know. Right now neither the SegmentFetcherFactory nor the SegmentFetcher provides the withoutRetry version as a public interface. More important, retries here also provides robustness for download, right?", "url": "https://github.com/apache/pinot/pull/5336#discussion_r437074675", "createdAt": "2020-06-09T00:40:35Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,20 +273,81 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (!\"PEER\".equalsIgnoreCase(uri)) {\n+      try {\n+        downloadSegmentFromDeepStore(segmentName, indexLoadingConfig, uri);\n+      } catch (Exception e) {\n+        // Download from deep store failed; try to download from peer if peer download is setup for the table.\n+        if (isPeerSegmentDownloadEnabled(tableConfig)) {\n+          downloadSegmentFromPeer(segmentName, tableConfig.getValidationConfig().getPeerSegmentDownloadScheme(), indexLoadingConfig);\n+        } else {\n+          throw e;\n+        }\n+      }\n+    } else {\n+      if (isPeerSegmentDownloadEnabled(tableConfig)) {\n+        downloadSegmentFromPeer(segmentName, tableConfig.getValidationConfig().getPeerSegmentDownloadScheme(), indexLoadingConfig);\n+      } else {\n+        throw new RuntimeException(\"Peer segment download not enabled for segment \" + segmentName);\n+      }\n+    }\n+  }\n+\n+  private void downloadSegmentFromDeepStore(String segmentName, IndexLoadingConfig indexLoadingConfig, String uri) {\n     File tempSegmentFolder = new File(_indexDir, \"tmp-\" + segmentName + \".\" + System.currentTimeMillis());\n     File tempFile = new File(_indexDir, segmentName + \".tar.gz\");\n-    final File segmentFolder = new File(_indexDir, segmentName);\n-    FileUtils.deleteQuietly(segmentFolder);\n     try {\n       SegmentFetcherFactory.fetchSegmentToLocal(uri, tempFile);\n       _logger.info(\"Downloaded file from {} to {}; Length of downloaded file: {}\", uri, tempFile, tempFile.length());\n-      TarGzCompressionUtils.unTar(tempFile, tempSegmentFolder);\n-      _logger.info(\"Uncompressed file {} into tmp dir {}\", tempFile, tempSegmentFolder);\n-      FileUtils.moveDirectory(tempSegmentFolder.listFiles()[0], segmentFolder);\n-      _logger.info(\"Replacing LLC Segment {}\", segmentName);\n-      replaceLLSegment(segmentName, indexLoadingConfig);\n+      untarAndMoveSegment(segmentName, indexLoadingConfig, tempSegmentFolder, tempFile);\n+    } catch (Exception e) {\n+      _logger.warn(\"Failed to download segment {} from deep store: \", segmentName, e);\n+      throw new RuntimeException(e);\n+    } finally {\n+      FileUtils.deleteQuietly(tempFile);\n+      FileUtils.deleteQuietly(tempSegmentFolder);\n+    }\n+  }\n+\n+  private void untarAndMoveSegment(String segmentName, IndexLoadingConfig indexLoadingConfig, File tempSegmentFolder,\n+      File tempFile)\n+      throws IOException, ArchiveException {\n+    TarGzCompressionUtils.unTar(tempFile, tempSegmentFolder);\n+    _logger.info(\"Uncompressed file {} into tmp dir {}\", tempFile, tempSegmentFolder);\n+    final File segmentFolder = new File(_indexDir, segmentName);\n+    FileUtils.deleteQuietly(segmentFolder);\n+    FileUtils.moveDirectory(tempSegmentFolder.listFiles()[0], segmentFolder);\n+    _logger.info(\"Replacing LLC Segment {}\", segmentName);\n+    replaceLLSegment(segmentName, indexLoadingConfig);\n+  }\n+\n+  private boolean isPeerSegmentDownloadEnabled(TableConfig tableConfig) {\n+    return SegmentFetcherFactory.HTTP_PROTOCOL\n+        .equalsIgnoreCase(tableConfig.getValidationConfig().getPeerSegmentDownloadScheme())\n+        || SegmentFetcherFactory.HTTPS_PROTOCOL\n+        .equalsIgnoreCase(tableConfig.getValidationConfig().getPeerSegmentDownloadScheme());\n+  }\n+\n+  private void downloadSegmentFromPeer(String segmentName, String downloadScheme, IndexLoadingConfig indexLoadingConfig) {\n+    File tempSegmentFolder = new File(_indexDir, \"tmp-\" + segmentName + \".\" + System.currentTimeMillis());\n+    File tempFile = new File(_indexDir, segmentName + \".tar.gz\");\n+    try {\n+      RetryPolicies.exponentialBackoffRetryPolicy(RETRY_COUNT, RETRY_WAIT_MS, RETRY_DELAY_SCALE_FACTOR).attempt(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NTI0OQ=="}, "originalCommit": {"oid": "e24c6fb1e96ffd18d3486f34767dffa9b73a2ee0"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMjQ3MQ==", "bodyText": "Move this retry logic to the BaseSegmentFetcher like I suggest there.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448102471", "createdAt": "2020-07-01T04:03:28Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,20 +273,81 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (!\"PEER\".equalsIgnoreCase(uri)) {\n+      try {\n+        downloadSegmentFromDeepStore(segmentName, indexLoadingConfig, uri);\n+      } catch (Exception e) {\n+        // Download from deep store failed; try to download from peer if peer download is setup for the table.\n+        if (isPeerSegmentDownloadEnabled(tableConfig)) {\n+          downloadSegmentFromPeer(segmentName, tableConfig.getValidationConfig().getPeerSegmentDownloadScheme(), indexLoadingConfig);\n+        } else {\n+          throw e;\n+        }\n+      }\n+    } else {\n+      if (isPeerSegmentDownloadEnabled(tableConfig)) {\n+        downloadSegmentFromPeer(segmentName, tableConfig.getValidationConfig().getPeerSegmentDownloadScheme(), indexLoadingConfig);\n+      } else {\n+        throw new RuntimeException(\"Peer segment download not enabled for segment \" + segmentName);\n+      }\n+    }\n+  }\n+\n+  private void downloadSegmentFromDeepStore(String segmentName, IndexLoadingConfig indexLoadingConfig, String uri) {\n     File tempSegmentFolder = new File(_indexDir, \"tmp-\" + segmentName + \".\" + System.currentTimeMillis());\n     File tempFile = new File(_indexDir, segmentName + \".tar.gz\");\n-    final File segmentFolder = new File(_indexDir, segmentName);\n-    FileUtils.deleteQuietly(segmentFolder);\n     try {\n       SegmentFetcherFactory.fetchSegmentToLocal(uri, tempFile);\n       _logger.info(\"Downloaded file from {} to {}; Length of downloaded file: {}\", uri, tempFile, tempFile.length());\n-      TarGzCompressionUtils.unTar(tempFile, tempSegmentFolder);\n-      _logger.info(\"Uncompressed file {} into tmp dir {}\", tempFile, tempSegmentFolder);\n-      FileUtils.moveDirectory(tempSegmentFolder.listFiles()[0], segmentFolder);\n-      _logger.info(\"Replacing LLC Segment {}\", segmentName);\n-      replaceLLSegment(segmentName, indexLoadingConfig);\n+      untarAndMoveSegment(segmentName, indexLoadingConfig, tempSegmentFolder, tempFile);\n+    } catch (Exception e) {\n+      _logger.warn(\"Failed to download segment {} from deep store: \", segmentName, e);\n+      throw new RuntimeException(e);\n+    } finally {\n+      FileUtils.deleteQuietly(tempFile);\n+      FileUtils.deleteQuietly(tempSegmentFolder);\n+    }\n+  }\n+\n+  private void untarAndMoveSegment(String segmentName, IndexLoadingConfig indexLoadingConfig, File tempSegmentFolder,\n+      File tempFile)\n+      throws IOException, ArchiveException {\n+    TarGzCompressionUtils.unTar(tempFile, tempSegmentFolder);\n+    _logger.info(\"Uncompressed file {} into tmp dir {}\", tempFile, tempSegmentFolder);\n+    final File segmentFolder = new File(_indexDir, segmentName);\n+    FileUtils.deleteQuietly(segmentFolder);\n+    FileUtils.moveDirectory(tempSegmentFolder.listFiles()[0], segmentFolder);\n+    _logger.info(\"Replacing LLC Segment {}\", segmentName);\n+    replaceLLSegment(segmentName, indexLoadingConfig);\n+  }\n+\n+  private boolean isPeerSegmentDownloadEnabled(TableConfig tableConfig) {\n+    return SegmentFetcherFactory.HTTP_PROTOCOL\n+        .equalsIgnoreCase(tableConfig.getValidationConfig().getPeerSegmentDownloadScheme())\n+        || SegmentFetcherFactory.HTTPS_PROTOCOL\n+        .equalsIgnoreCase(tableConfig.getValidationConfig().getPeerSegmentDownloadScheme());\n+  }\n+\n+  private void downloadSegmentFromPeer(String segmentName, String downloadScheme, IndexLoadingConfig indexLoadingConfig) {\n+    File tempSegmentFolder = new File(_indexDir, \"tmp-\" + segmentName + \".\" + System.currentTimeMillis());\n+    File tempFile = new File(_indexDir, segmentName + \".tar.gz\");\n+    try {\n+      RetryPolicies.exponentialBackoffRetryPolicy(RETRY_COUNT, RETRY_WAIT_MS, RETRY_DELAY_SCALE_FACTOR).attempt(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NTI0OQ=="}, "originalCommit": {"oid": "e24c6fb1e96ffd18d3486f34767dffa9b73a2ee0"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0ODk3MQ==", "bodyText": "done. thanks for the pointer.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448548971", "createdAt": "2020-07-01T18:39:39Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,20 +273,81 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (!\"PEER\".equalsIgnoreCase(uri)) {\n+      try {\n+        downloadSegmentFromDeepStore(segmentName, indexLoadingConfig, uri);\n+      } catch (Exception e) {\n+        // Download from deep store failed; try to download from peer if peer download is setup for the table.\n+        if (isPeerSegmentDownloadEnabled(tableConfig)) {\n+          downloadSegmentFromPeer(segmentName, tableConfig.getValidationConfig().getPeerSegmentDownloadScheme(), indexLoadingConfig);\n+        } else {\n+          throw e;\n+        }\n+      }\n+    } else {\n+      if (isPeerSegmentDownloadEnabled(tableConfig)) {\n+        downloadSegmentFromPeer(segmentName, tableConfig.getValidationConfig().getPeerSegmentDownloadScheme(), indexLoadingConfig);\n+      } else {\n+        throw new RuntimeException(\"Peer segment download not enabled for segment \" + segmentName);\n+      }\n+    }\n+  }\n+\n+  private void downloadSegmentFromDeepStore(String segmentName, IndexLoadingConfig indexLoadingConfig, String uri) {\n     File tempSegmentFolder = new File(_indexDir, \"tmp-\" + segmentName + \".\" + System.currentTimeMillis());\n     File tempFile = new File(_indexDir, segmentName + \".tar.gz\");\n-    final File segmentFolder = new File(_indexDir, segmentName);\n-    FileUtils.deleteQuietly(segmentFolder);\n     try {\n       SegmentFetcherFactory.fetchSegmentToLocal(uri, tempFile);\n       _logger.info(\"Downloaded file from {} to {}; Length of downloaded file: {}\", uri, tempFile, tempFile.length());\n-      TarGzCompressionUtils.unTar(tempFile, tempSegmentFolder);\n-      _logger.info(\"Uncompressed file {} into tmp dir {}\", tempFile, tempSegmentFolder);\n-      FileUtils.moveDirectory(tempSegmentFolder.listFiles()[0], segmentFolder);\n-      _logger.info(\"Replacing LLC Segment {}\", segmentName);\n-      replaceLLSegment(segmentName, indexLoadingConfig);\n+      untarAndMoveSegment(segmentName, indexLoadingConfig, tempSegmentFolder, tempFile);\n+    } catch (Exception e) {\n+      _logger.warn(\"Failed to download segment {} from deep store: \", segmentName, e);\n+      throw new RuntimeException(e);\n+    } finally {\n+      FileUtils.deleteQuietly(tempFile);\n+      FileUtils.deleteQuietly(tempSegmentFolder);\n+    }\n+  }\n+\n+  private void untarAndMoveSegment(String segmentName, IndexLoadingConfig indexLoadingConfig, File tempSegmentFolder,\n+      File tempFile)\n+      throws IOException, ArchiveException {\n+    TarGzCompressionUtils.unTar(tempFile, tempSegmentFolder);\n+    _logger.info(\"Uncompressed file {} into tmp dir {}\", tempFile, tempSegmentFolder);\n+    final File segmentFolder = new File(_indexDir, segmentName);\n+    FileUtils.deleteQuietly(segmentFolder);\n+    FileUtils.moveDirectory(tempSegmentFolder.listFiles()[0], segmentFolder);\n+    _logger.info(\"Replacing LLC Segment {}\", segmentName);\n+    replaceLLSegment(segmentName, indexLoadingConfig);\n+  }\n+\n+  private boolean isPeerSegmentDownloadEnabled(TableConfig tableConfig) {\n+    return SegmentFetcherFactory.HTTP_PROTOCOL\n+        .equalsIgnoreCase(tableConfig.getValidationConfig().getPeerSegmentDownloadScheme())\n+        || SegmentFetcherFactory.HTTPS_PROTOCOL\n+        .equalsIgnoreCase(tableConfig.getValidationConfig().getPeerSegmentDownloadScheme());\n+  }\n+\n+  private void downloadSegmentFromPeer(String segmentName, String downloadScheme, IndexLoadingConfig indexLoadingConfig) {\n+    File tempSegmentFolder = new File(_indexDir, \"tmp-\" + segmentName + \".\" + System.currentTimeMillis());\n+    File tempFile = new File(_indexDir, segmentName + \".tar.gz\");\n+    try {\n+      RetryPolicies.exponentialBackoffRetryPolicy(RETRY_COUNT, RETRY_WAIT_MS, RETRY_DELAY_SCALE_FACTOR).attempt(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NTI0OQ=="}, "originalCommit": {"oid": "e24c6fb1e96ffd18d3486f34767dffa9b73a2ee0"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjg4NTI1OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMzozODowNFrOGrVrog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMzozODowNFrOGrVrog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5NzE4Ng==", "bodyText": "add a warn log here with segment name and exception.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448097186", "createdAt": "2020-07-01T03:38:04Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,20 +276,82 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (uri != null && !uri.isEmpty()) {\n+      try {\n+        downloadSegmentFromDeepStore(segmentName, indexLoadingConfig, uri);\n+      } catch (Exception e) {\n+        // Download from deep store failed; try to download from peer if peer download is setup for the table.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e0d476387e38ad3133ce9d4e62a4e4e98db7dc4"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mjg4NTY4OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMzozODoyOVrOGrVr8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODoxMTo1OVrOGrwbHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5NzI2Nw==", "bodyText": "need another try/catch here for exceptions, and a similar log if that fails.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448097267", "createdAt": "2020-07-01T03:38:29Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,20 +276,82 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (uri != null && !uri.isEmpty()) {\n+      try {\n+        downloadSegmentFromDeepStore(segmentName, indexLoadingConfig, uri);\n+      } catch (Exception e) {\n+        // Download from deep store failed; try to download from peer if peer download is setup for the table.\n+        if (isPeerSegmentDownloadEnabled(tableConfig)) {\n+          downloadSegmentFromPeer(segmentName, tableConfig.getValidationConfig().getPeerSegmentDownloadScheme(), indexLoadingConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e0d476387e38ad3133ce9d4e62a4e4e98db7dc4"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzNTMyNw==", "bodyText": "The try/catch is in the downloadSegmentFromPeer method already. Added a warning log there.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448535327", "createdAt": "2020-07-01T18:11:59Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,20 +276,82 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (uri != null && !uri.isEmpty()) {\n+      try {\n+        downloadSegmentFromDeepStore(segmentName, indexLoadingConfig, uri);\n+      } catch (Exception e) {\n+        // Download from deep store failed; try to download from peer if peer download is setup for the table.\n+        if (isPeerSegmentDownloadEnabled(tableConfig)) {\n+          downloadSegmentFromPeer(segmentName, tableConfig.getValidationConfig().getPeerSegmentDownloadScheme(), indexLoadingConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5NzI2Nw=="}, "originalCommit": {"oid": "3e0d476387e38ad3133ce9d4e62a4e4e98db7dc4"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjkxOTA4OnYy", "diffSide": "RIGHT", "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/BaseSegmentFetcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNDowMjo0MVrOGrV_kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNDowMjo0MVrOGrV_kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMjI4OQ==", "bodyText": "Nice.\nHow about changing this to apply retries with backoff but use one of the uris at random ? Sort of similar to lines 68-77", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448102289", "createdAt": "2020-07-01T04:02:41Z", "author": {"login": "mcvsubbu"}, "path": "pinot-common/src/main/java/org/apache/pinot/common/utils/fetcher/BaseSegmentFetcher.java", "diffHunk": "@@ -75,6 +77,16 @@ public void fetchSegmentToLocal(URI uri, File dest)\n     });\n   }\n \n+  @Override\n+  public void fetchSegmentToLocal(List<URI> uris, File dest)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e0d476387e38ad3133ce9d4e62a4e4e98db7dc4"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjkzMDAzOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/PeerServerSegmentFinder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNDowOTo0NlrOGrWF7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODozODo0OFrOGrxO6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMzkxNg==", "bodyText": "Why are we looping around here? Why not just get the statemap for a segment?\nExternalView.getStateMap(segmentName) returns a Map<String, String> that we can iterate on.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448103916", "createdAt": "2020-07-01T04:09:46Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/util/PeerServerSegmentFinder.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.ListUtils;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * PeerServerSegmentFinder discovers all the servers having the input segment in a ONLINE state through external view of\n+ * a Pinot table.\n+ */\n+public class PeerServerSegmentFinder {\n+  private static final Logger _logger = LoggerFactory.getLogger(PeerServerSegmentFinder.class);\n+  /**\n+   *\n+   * @param segmentName\n+   * @param downloadScheme Can be either http or https.\n+   * @param helixManager\n+   * @return a list of uri strings of the form http(s)://hostname:port/segments/tablenameWithType/segmentName\n+   * for the servers hosting ONLINE segments; empty list if no such server found.\n+   */\n+  public static List<URI> getPeerServerURIs(String segmentName, String downloadScheme, HelixManager helixManager) {\n+    LLCSegmentName llcSegmentName = new LLCSegmentName(segmentName);\n+    String tableNameWithType =\n+        TableNameBuilder.forType(TableType.REALTIME).tableNameWithType(llcSegmentName.getTableName());\n+\n+    HelixAdmin helixAdmin = helixManager.getClusterManagmentTool();\n+    String clusterName = helixManager.getClusterName();\n+    if (clusterName == null) {\n+      _logger.error(\"ClusterName not found\");\n+      return ListUtils.EMPTY_LIST;\n+    }\n+    ExternalView externalViewForResource =\n+        HelixHelper.getExternalViewForResource(helixAdmin, clusterName, tableNameWithType);\n+    if (externalViewForResource == null) {\n+      _logger.warn(\"External View not found for table {}\", tableNameWithType);\n+      return ListUtils.EMPTY_LIST;\n+    }\n+    List<URI> onlineServerURIs = new ArrayList<>();\n+    // Find out the ONLINE server serving the segment.\n+    for (String segment : externalViewForResource.getPartitionSet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e0d476387e38ad3133ce9d4e62a4e4e98db7dc4"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU0ODU4Ng==", "bodyText": "good catch. I was using the getStateMaps a few lines below. Revised.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448548586", "createdAt": "2020-07-01T18:38:48Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/util/PeerServerSegmentFinder.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.ListUtils;\n+import org.apache.helix.HelixAdmin;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.pinot.common.utils.CommonConstants;\n+import org.apache.pinot.common.utils.LLCSegmentName;\n+import org.apache.pinot.common.utils.StringUtil;\n+import org.apache.pinot.common.utils.helix.HelixHelper;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.utils.builder.TableNameBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * PeerServerSegmentFinder discovers all the servers having the input segment in a ONLINE state through external view of\n+ * a Pinot table.\n+ */\n+public class PeerServerSegmentFinder {\n+  private static final Logger _logger = LoggerFactory.getLogger(PeerServerSegmentFinder.class);\n+  /**\n+   *\n+   * @param segmentName\n+   * @param downloadScheme Can be either http or https.\n+   * @param helixManager\n+   * @return a list of uri strings of the form http(s)://hostname:port/segments/tablenameWithType/segmentName\n+   * for the servers hosting ONLINE segments; empty list if no such server found.\n+   */\n+  public static List<URI> getPeerServerURIs(String segmentName, String downloadScheme, HelixManager helixManager) {\n+    LLCSegmentName llcSegmentName = new LLCSegmentName(segmentName);\n+    String tableNameWithType =\n+        TableNameBuilder.forType(TableType.REALTIME).tableNameWithType(llcSegmentName.getTableName());\n+\n+    HelixAdmin helixAdmin = helixManager.getClusterManagmentTool();\n+    String clusterName = helixManager.getClusterName();\n+    if (clusterName == null) {\n+      _logger.error(\"ClusterName not found\");\n+      return ListUtils.EMPTY_LIST;\n+    }\n+    ExternalView externalViewForResource =\n+        HelixHelper.getExternalViewForResource(helixAdmin, clusterName, tableNameWithType);\n+    if (externalViewForResource == null) {\n+      _logger.warn(\"External View not found for table {}\", tableNameWithType);\n+      return ListUtils.EMPTY_LIST;\n+    }\n+    List<URI> onlineServerURIs = new ArrayList<>();\n+    // Find out the ONLINE server serving the segment.\n+    for (String segment : externalViewForResource.getPartitionSet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMzkxNg=="}, "originalCommit": {"oid": "3e0d476387e38ad3133ce9d4e62a4e4e98db7dc4"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjQ2MzUxOnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMzoyMToxN1rOGr4U8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNDoyNjowN1rOGr8_ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2NDgxNw==", "bodyText": "check against uri not equal to CommonConstants.Segments.SomeConstant that we define as \"\". The controller and server should use the same.\nAlso, uri can never be null, since we never write it as null for a completed segments. You can remove that check", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448664817", "createdAt": "2020-07-01T23:21:17Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,21 +276,79 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (uri != null && !uri.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c8e266d8e206d256050df8bf64d7950daa7fa03"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc0MTI4Mw==", "bodyText": "Added the CommonConstants.Segments.METADATA_URI_FOR_PEER_DOWNLOAD constant.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r448741283", "createdAt": "2020-07-02T04:26:07Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -268,21 +276,79 @@ public void addSegment(String segmentName, TableConfig tableConfig, IndexLoading\n   }\n \n   public void downloadAndReplaceSegment(String segmentName, LLCRealtimeSegmentZKMetadata llcSegmentMetadata,\n-      IndexLoadingConfig indexLoadingConfig) {\n+      IndexLoadingConfig indexLoadingConfig, TableConfig tableConfig) {\n     final String uri = llcSegmentMetadata.getDownloadUrl();\n+    if (uri != null && !uri.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2NDgxNw=="}, "originalCommit": {"oid": "7c8e266d8e206d256050df8bf64d7950daa7fa03"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDI5OTg3OnYy", "diffSide": "RIGHT", "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMToyNDowNlrOGsdamg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMToyNzozNlrOGsdf7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3MjQ3NA==", "bodyText": "this is not needed anymore", "url": "https://github.com/apache/pinot/pull/5336#discussion_r449272474", "createdAt": "2020-07-02T21:24:06Z", "author": {"login": "mcvsubbu"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -57,9 +61,12 @@\n import org.apache.pinot.spi.data.FieldSpec;\n import org.apache.pinot.spi.data.Schema;\n \n+import static org.apache.pinot.common.utils.CommonConstants.Segment.METADATA_URI_FOR_PEER_DOWNLOAD;\n+\n \n @ThreadSafe\n public class RealtimeTableDataManager extends BaseTableDataManager {\n+  private static final String EMPTY_URL = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3fbb8faad0edef1434073d3f53f9baf5a2ce96c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3MzgzOA==", "bodyText": "done.", "url": "https://github.com/apache/pinot/pull/5336#discussion_r449273838", "createdAt": "2020-07-02T21:27:36Z", "author": {"login": "chenboat"}, "path": "pinot-core/src/main/java/org/apache/pinot/core/data/manager/realtime/RealtimeTableDataManager.java", "diffHunk": "@@ -57,9 +61,12 @@\n import org.apache.pinot.spi.data.FieldSpec;\n import org.apache.pinot.spi.data.Schema;\n \n+import static org.apache.pinot.common.utils.CommonConstants.Segment.METADATA_URI_FOR_PEER_DOWNLOAD;\n+\n \n @ThreadSafe\n public class RealtimeTableDataManager extends BaseTableDataManager {\n+  private static final String EMPTY_URL = \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3MjQ3NA=="}, "originalCommit": {"oid": "d3fbb8faad0edef1434073d3f53f9baf5a2ce96c"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3231, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}